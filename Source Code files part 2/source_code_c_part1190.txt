 has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{


    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) 
	{

        //
        // This value is only set by the total
        // timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) 
	{
        //
        // This value is only set by the regular
        // completion routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) 
	{
        //
        // This value is only set by the cancel
        // read routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } 
	else if(pPort->CountOnLastRead || pPort->ReadByIsr) 
	{
        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if(pPort->ReadByIsr) 
		{

            KeSynchronizeExecution(pCard->Interrupt, SerialUpdateReadByIsr, pPort);
         

#ifdef HYPERTERMINAL_FIX
            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(&pPort->LastReadTime);
            

            KeSetTimer(
                &pPort->ReadRequestIntervalTimer,
                *pPort->IntervalTimeToUse,
                &pPort->IntervalReadTimeoutDpc
                );
#else

            KeSetTimer(
                &pPort->ReadRequestIntervalTimer,
                pPort->IntervalTime,
                &pPort->IntervalReadTimeoutDpc
                );
#endif

            IoReleaseCancelSpinLock(oldIrql);

        } 
		else 
		{

#ifdef HYPERTERMINAL_FIX
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(&currentTime);
                
                

            if (RtlLargeIntegerGreaterThanOrEqualTo(RtlLargeIntegerSubtract(currentTime, pPort->LastReadTime),
                    pPort->IntervalTime)) 
            {            
                        
                SerialTryToCompleteCurrent(
                    pPort,
                    SerialGrabReadFromIsr,
                    oldIrql,
                    STATUS_TIMEOUT,
                    &pPort->CurrentReadIrp,
                    &pPort->ReadQueue,
                    &pPort->ReadRequestIntervalTimer,
                    &pPort->ReadRequestTotalTimer,
                    SerialStartRead,
                    SerialGetNextIrp
                    );

            } 
			else 
			{

                KeSetTimer(
                    &pPort->ReadRequestIntervalTimer,
                    *pPort->IntervalTimeToUse,
                    &pPort->IntervalReadTimeoutDpc
                    );

                IoReleaseCancelSpinLock(oldIrql);

            }
#else
            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            SerialTryToCompleteCurrent(
                pPort,
                SerialGrabReadFromIsr,
                oldIrql,
                STATUS_TIMEOUT,
                &pPort->CurrentReadIrp,
                &pPort->ReadQueue,
                &pPort->ReadRequestIntervalTimer,
                &pPort->ReadRequestTotalTimer,
                SerialStartRead,
                SerialGetNextIrp
                );
#endif

        }

    } 
	else 
	{
        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

#ifdef HYPERTERMINAL_FIX
        KeSetTimer(
            &pPort->ReadRequestIntervalTimer,
            *pPort->IntervalTimeToUse,
            &pPort->IntervalReadTimeoutDpc
            );
#else
        KeSetTimer(
            &pPort->ReadRequestIntervalTimer,
            pPort->IntervalTime,
            &pPort->IntervalReadTimeoutDpc
            );
#endif
        IoReleaseCancelSpinLock(oldIrql);

    }


}

ULONG
SerialGetCharsFromIntBuffer(
    PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    //
    // This value will be the number of characters that this
    // routine returns.  It will be the minimum of the number
    // of characters currently in the buffer or the number of
    // characters required for the read.
    //
    ULONG numberOfCharsToGet;

    //
    // This holds the number of characters between the first
    // readable character and - the last character we will read or
    // the real physical end of the buffer (not the last readable
    // character).
    //
    ULONG firstTryNumberToGet;


    //
    // The minimum of the number of characters we need and
    // the number of characters available
    //

    numberOfCharsToGet = pPort->CharsInInterruptBuffer;

    if(numberOfCharsToGet > pPort->NumberNeededForRead) 
	{
        numberOfCharsToGet = pPort->NumberNeededForRead;
    }

    if(numberOfCharsToGet) 
	{

        //
        // This will hold the number of characters between the
        // first available character and the end of the buffer.
        // Note that the buffer could wrap around but for the
        // purposes of the first copy we don't care about that.
        //

        firstTryNumberToGet = (pPort->LastCharSlot -
                               pPort->FirstReadableChar) + 1;

        if(firstTryNumberToGet > numberOfCharsToGet) 
		{

            //
            // The characters don't wrap. Actually they may wrap but
            // we don't care for the purposes of this read since the
            // characters we need are available before the wrap.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                numberOfCharsToGet
                );

            pPort->NumberNeededForRead -= numberOfCharsToGet;

            //
            // We now will move the pointer to the first character after
            // what we just copied into the users buffer.
            //
            // We need to check if the stream of readable characters
            // is wrapping around to the beginning of the buffer.
            //
            // Note that we may have just taken the last characters
            // at the end of the buffer.
            //

            if((pPort->FirstReadableChar + (numberOfCharsToGet - 1)) 
				== pPort->LastCharSlot) 
			{
                pPort->FirstReadableChar = pPort->InterruptReadBuffer;
            } 
			else 
			{
                pPort->FirstReadableChar += numberOfCharsToGet;
            }
        } 
		else 
		{
            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                firstTryNumberToGet
                );

            pPort->NumberNeededForRead -= firstTryNumberToGet;

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->InterruptReadBuffer,
                numberOfCharsToGet - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                           (numberOfCharsToGet -
                                            firstTryNumberToGet);

            pPort->NumberNeededForRead -= (numberOfCharsToGet -
                                               firstTryNumberToGet);

        }

    }

    pPort->CurrentReadIrp->IoStatus.Information += numberOfCharsToGet;

    return numberOfCharsToGet;

}

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the number of characters that
    remain in the interrupt buffer.  We need to use this routine
    since the count could be updated during the update by execution
    of the ISR.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension and count of the number of characters
              that we previously copied into the users buffer.  The
              structure actually has a third field that we don't
              use in this routine.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR update = Context;
    PPORT_DEVICE_EXTENSION pPort = update->pPort;

    ASSERT(pPort->CharsInInterruptBuffer >= update->CharsCopied);
    pPort->CharsInInterruptBuffer -= update->CharsCopied;

    //
    // Deal with flow control if necessary.
    //

    SerialHandleReducedIntBuffer(pPort);


    return FALSE;

}

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the users buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the users buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR updateChar = Context;
    PPORT_DEVICE_EXTENSION pPort = updateChar->pPort;

    SerialUpdateInterruptBuffer(Context);

    //
    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got
    // the last batch.
    //

    updateChar->CharsCopied = SerialGetCharsFromIntBuffer(pPort);

    SerialUpdateInterruptBuffer(Context);

    //
    // No more new characters will be "received" until we exit
    // this routine.  We again check to make sure that we
    // haven't satisfied this read, and if we haven't we set things
    // up so that the ISR copies into the user buffer.
    //

    if(pPort->NumberNeededForRead) 
	{

        //
        // We shouldn't be switching unless there are no
        // characters left.
        //

        ASSERT(!pPort->CharsInInterruptBuffer);

        //
        // We use the following to values to do inteval timing.
        //
        // CountOnLastRead is mostly used to simply prevent
        // the interval timer from timing out before any characters
        // are read. (Interval timing should only be effective
        // after the first character is read.)
        //
        // After the first time the interval timer fires and
        // characters have be read we will simply update with
        // the value of ReadByIsr and then set ReadByIsr to zero.
        // (We do that in a synchronization routine.
        //
        // If the interval timer dpc routine ever encounters
        // ReadByIsr == 0 when CountOnLastRead is non-zero it
        // will timeout the read.
        //
        // (Note that we have a special case of CountOnLastRead
        // < 0.  This is done by the read completion routines other
        // than the total timeout dpc to indicate that the total
        // timeout has expired.)
        //

        pPort->CountOnLastRead = pPort->CurrentReadIrp->IoStatus.Information;

        pPort->ReadByIsr = 0;

        //
        // By compareing the read buffer base address to the
        // the base address of the interrupt buffer the ISR
        // can determine whether we are using the interrupt
        // buffer or the user buffer.
        //

        pPort->ReadBufferBase = pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;

        //
        // The current char slot is after the last copied in
        // character.  We know there is always room since we
        // we wouldn't have gotten here if there wasn't.
        //

        pPort->CurrentCharSlot = pPort->ReadBufferBase +
            pPort->CurrentReadIrp->IoStatus.Information;

        //
        // The last position that a character can go is on the
        // last byte of user buffer.  While the actual allocated
        // buffer space may be bigger, we know that there is at
        // least as much as the read length.
        //

        pPort->LastCharSlot = pPort->ReadBufferBase +
                                      (IoGetCurrentIrpStackLocation(
                                          pPort->CurrentReadIrp
                                          )->Parameters.Read.Length
                                       - 1);

        //
        // Mark the irp as being in a cancelable state.
        //

        IoSetCancelRoutine(pPort->CurrentReadIrp, SerialCancelCurrentRead);
            
            

        //
        // Increment the reference count twice.
        //
        // Once for the Isr owning the irp and once
        // because the cancel routine has a reference
        // to it.
        //

        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);
        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

        updateChar->Completed = FALSE;

    } 
	else 
	{
        updateChar->Completed = TRUE;

    }

    return FALSE;

}
//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS 
{
    PPORT_DEVICE_EXTENSION pPort;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;

} SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;


NTSTATUS
SerialResizeBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    pPort - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

--*/

{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
    PSERIAL_QUEUE_SIZE rs = pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp);
                                   
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    pPort->CurrentReadIrp->IoStatus.Information = 0L;
    pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if (rs->InSize <= pPort->BufferSize) 
	{
        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //

        SpxFreeMem(newBuffer);
    } 
	else 
	{

        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.pPort = pPort;
        rp.OldBuffer = pPort->InterruptReadBuffer;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

        rp.NumberMoved = SerialMoveToNewIntBuffer(pPort, newBuffer);
                             

        KeSynchronizeExecution(
            pCard->Interrupt,
            SerialUpdateAndSwitchToNew,
            &rp
            );

        KeReleaseSpinLock(
            &pPort->ControlLock,
            controlIrql
            );

        //
        // Free up the memory that the old buffer consumed.
        //

        SpxFreeMem(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}

ULONG
SerialMoveToNewIntBuffer(
    PPORT_DEVICE_EXTENSION pPort,
    PUCHAR NewBuffer
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the "new" buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.
    NewBuffer - Where the characters are to be move to.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    ULONG numberOfCharsMoved = pPort->CharsInInterruptBuffer;

    if(numberOfCharsMoved) 
	{

        //
        // This holds the number of characters between the first
        // readable character and the last character we will read or
        // the real physical end of the buffer (not the last readable
        // character).
        //
        ULONG firstTryNumberToGet = (pPort->LastCharSlot -
                                     pPort->FirstReadableChar) + 1;

        if(firstTryNumberToGet >= numberOfCharsMoved) 
		{
            //
            // The characters don't wrap.
            //

            RtlMoveMemory(
                NewBuffer,
                pPort->FirstReadableChar,
                numberOfCharsMoved
                );

            if((pPort->FirstReadableChar+(numberOfCharsMoved-1)) 
				== pPort->LastCharSlot) 
			{
                pPort->FirstReadableChar = pPort->InterruptReadBuffer;
            } 
			else 
			{
                pPort->FirstReadableChar += numberOfCharsMoved;
            }
        } 
		else 
		{
            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(NewBuffer, pPort->FirstReadableChar, firstTryNumberToGet);
                
               

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                NewBuffer+firstTryNumberToGet,
                pPort->InterruptReadBuffer,
                numberOfCharsMoved - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                   numberOfCharsMoved - firstTryNumberToGet;

        }

    }

    return numberOfCharsMoved;

}

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_RESIZE_PARAMS params = Context;
    PPORT_DEVICE_EXTENSION pPort = params->pPort;
    ULONG tempCharsInInterruptBuffer = pPort->CharsInInterruptBuffer;

    ASSERT(pPort->CharsInInterruptBuffer >= params->NumberMoved);

    //
    // We temporarily reduce the chars in interrupt buffer to
    // "fool" the move routine.  We will restore it after the
    // move.
    //

    pPort->CharsInInterruptBuffer -= params->NumberMoved;

    if(pPort->CharsInInterruptBuffer) 
	{
        SerialMoveToNewIntBuffer(
            pPort,
            params->NewBuffer + params->NumberMoved
            );

    }

    pPort->CharsInInterruptBuffer = tempCharsInInterruptBuffer;


    pPort->LastCharSlot = params->NewBuffer + (params->NewBufferSize - 1);
    pPort->FirstReadableChar = params->NewBuffer;
    pPort->ReadBufferBase = params->NewBuffer;
    pPort->InterruptReadBuffer = params->NewBuffer;
    pPort->BufferSize = params->NewBufferSize;

    //
    // We *KNOW* that the new interrupt buffer is larger than the
    // old buffer.  We don't need to worry about it being full.
    //

    pPort->CurrentCharSlot = pPort->InterruptReadBuffer + pPort->CharsInInterruptBuffer;

    //
    // We set up the default xon/xoff limits.
    //

    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif                                 

    //
    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    //

    SerialHandleReducedIntBuffer(pPort);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\spx_iioc.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Dispatch Entry for INTERNAL IOCTLs					*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Internal IOCTLs support the SERENUM					*/
/*					attached serial device enumerator:					*/
/*					IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS				*/
/*					IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS				*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#define FILE_ID	SPX_IIOC_C		// File ID for Event Logging see SPX_DEFS.H for values.



/*****************************************************************************
**********************                                 ***********************
**********************   Spx_SerialInternalIoControl   ***********************
**********************                                 ***********************
******************************************************************************
	
prototype:		NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)

description:	Internal IOCTL dipatch routine.
				These IOCTLs are only issued from know trusted system components such as
				the SERENUM.SYS attached serial device enumerator and the mouse driver:

parameters:		pDevObj points to the device object structure
				pIrp points to the IOCTL Irp packet

returns:		STATUS_SUCCESS

*/

NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
	NTSTATUS				status;
	PIO_STACK_LOCATION		pIrpStack;
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	KIRQL					OldIrql;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Entry\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	if(SerialCompleteIfError(pDevObj, pIrp) != STATUS_SUCCESS)
		return(STATUS_CANCELLED);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0L;
	status = STATUS_SUCCESS;

	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
	case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
		{
			SERIAL_BASIC_SETTINGS	Basic;
			PSERIAL_BASIC_SETTINGS	pBasic;
			SERIAL_IOCTL_SYNC	S;

			if (pIrpStack->Parameters.DeviceIoControl.IoControlCode 
				== IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
			{
          
/* Check the buffer size... */

				if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength 
					< sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

/* Everything is 0 -- timeouts and flow control. */
/* If we add additional features, this zero memory method may not work. */

				RtlZeroMemory(&Basic,sizeof(SERIAL_BASIC_SETTINGS));
				pIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;

/* Save off the old settings... */

				RtlCopyMemory(&pBasic->Timeouts, &pPort->Timeouts, sizeof(SERIAL_TIMEOUTS));
				RtlCopyMemory(&pBasic->HandFlow, &pPort->HandFlow, sizeof(SERIAL_HANDFLOW));

/* Point to our new settings... */

				pBasic = &Basic;
			}
			else
			{
				if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;
			}

			KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

/* Set the timeouts...	*/

			RtlCopyMemory(&pPort->Timeouts, &pBasic->Timeouts, sizeof(SERIAL_TIMEOUTS));

/* Set flowcontrol... */

			S.pPort = pPort;
			S.Data = &pBasic->HandFlow;
			XXX_SetHandFlow(pPort, &S);		/* Set the handflow for specific hardware */

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

	default:
		status = STATUS_INVALID_PARAMETER;
		break;
	}

	pIrp->IoStatus.Status = status;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Complete\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	IoCompleteRequest(pIrp,0);

	return(status);

} /* Spx_SerialInternalIoControl */
                                                        
/* End of SPX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\spx_init.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_INIT.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	This module contains the code that load the driver.					*
*																						*
****************************************************************************************/


#define FILE_ID	SPX_INIT_C		// File ID for Event Logging see SPX_DEFS.H for values.


// Function Prototypes 
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
// End function prototypes.

// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#endif

// Gloabal Driver Data
UNICODE_STRING	SavedRegistryPath;

#if DBG
ULONG SpxDebugLevel = 0;		// Debug level for checked build
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//	DriverEntry - Load first and initialises entry points.								//
//////////////////////////////////////////////////////////////////////////////////////////
/*
Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    RegistryPath - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS 
*/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	// Holds status information return by various OS and driver initialization routines.
	NTSTATUS status;

	// We use this to query into the registry as to whether we should break at driver entry.
	RTL_QUERY_REGISTRY_TABLE paramTable[3];
	ULONG zero			= 0;
	ULONG debugLevel	= 0;
	ULONG shouldBreak	= 0;		
	PWCHAR path			= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	#if DBG
		DbgPrint( "%s: In DriverEntry\n", PRODUCT_NAME);
	#endif


	// Store Registry Path
	SavedRegistryPath.MaximumLength	= RegistryPath->MaximumLength;
	SavedRegistryPath.Length		= RegistryPath->Length;
	SavedRegistryPath.Buffer		= SpxAllocateMem(PagedPool, SavedRegistryPath.MaximumLength);

	if(SavedRegistryPath.Buffer)
	{
		RtlMoveMemory(SavedRegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
	
		RtlZeroMemory(&paramTable[0], sizeof(paramTable));
		paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[0].Name = L"BreakOnEntry";
		paramTable[0].EntryContext = &shouldBreak;
		paramTable[0].DefaultType = REG_DWORD;
		paramTable[0].DefaultData = &zero;
		paramTable[0].DefaultLength = sizeof(ULONG);
		paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[1].Name = L"DebugLevel";
		paramTable[1].EntryContext = &debugLevel;
		paramTable[1].DefaultType = REG_DWORD;
		paramTable[1].DefaultData = &zero;
		paramTable[1].DefaultLength = sizeof(ULONG);

		if(!SPX_SUCCESS(status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
														RegistryPath->Buffer, &paramTable[0], 
														NULL, NULL)))
		{
			shouldBreak = 0;
			debugLevel	= 0;
		}

	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;


 	#if DBG
		SpxDebugLevel = debugLevel;	
	//	SpxDebugLevel = (ULONG)-1;			// Prints all debug messages

	//	shouldBreak = 1;	// HARD CODED BREAKPOINT WITH CHECKED BUILD !!!
	#endif


	if(shouldBreak)
	{
		DbgBreakPoint();	// Break Debugger.
	}


	if(SPX_SUCCESS(status))
	{
		// Initialize the Driver Object with driver's entry points
		DriverObject->DriverUnload									= DriverUnload;
		DriverObject->DriverExtension->AddDevice					= Spx_AddDevice;
		DriverObject->MajorFunction[IRP_MJ_PNP]						= Spx_DispatchPnp;
		DriverObject->MajorFunction[IRP_MJ_POWER]					= Spx_DispatchPower;
		DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]			= Spx_Flush;
		DriverObject->MajorFunction[IRP_MJ_WRITE]					= Spx_Write;
		DriverObject->MajorFunction[IRP_MJ_READ]					= Spx_Read;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]			= Spx_IoControl;
		DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]	= Spx_InternalIoControl;
		DriverObject->MajorFunction[IRP_MJ_CREATE]					= Spx_CreateOpen;
		DriverObject->MajorFunction[IRP_MJ_CLOSE]					= Spx_Close;
		DriverObject->MajorFunction[IRP_MJ_CLEANUP]					= Spx_Cleanup;
		DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]		= Spx_QueryInformationFile;
		DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]			= Spx_SetInformationFile;
#ifdef WMI_SUPPORT
		DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]			= Spx_DispatchSystemControl;
#endif
		
	}
	else
	{
		// Free
		if(SavedRegistryPath.Buffer)
		{
			SpxFreeMem(SavedRegistryPath.Buffer);
			SavedRegistryPath.Buffer = NULL;
		}
	}


	return(status);

}	// DriverEntry 




//////////////////////////////////////////////////////////////////////////////////////////
//	DriverUnload - Called as driver unloads.											
//////////////////////////////////////////////////////////////////////////////////////////
VOID 
DriverUnload(IN PDRIVER_OBJECT pDriverObject)
/*++

Routine Description:

    This routine cleans up all of the resources allocated in DriverEntry.

Arguments:

    pDriverObject - Pointer to the driver object controling all of the
					devices.

Return Value:

    None.

--*/
{
	PAGED_CODE();
	
	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering DriverUnload\n", PRODUCT_NAME));

	// All Device Objects must have been deleted by now.
    ASSERT (pDriverObject->DeviceObject == NULL);

	// Free
	if(SavedRegistryPath.Buffer)
	{
		SpxFreeMem(SavedRegistryPath.Buffer);
		SavedRegistryPath.Buffer = NULL;
	}


	return;
}


// End of SPX_INIT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\spx_powr.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_POWER.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Handle all Power IRPS.												*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/
#define FILE_ID	SPX_POWR_C		// File ID for Event Logging see SPX_DEFS.H for values.

BOOLEAN	BREAK_ON_POWER_UP = FALSE;

// Prototypes
NTSTATUS Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp);
NTSTATUS Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp);
NTSTATUS Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp);
// End of prototypes


// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchPower)

#pragma alloc_text(PAGE, Spx_Card_FDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_CardSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_CardSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD3)

#pragma alloc_text(PAGE, Spx_Port_PDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_PortQuerySystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD3)

#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	Routine Description:
//		The power dispatch routine determine if the IRP is for a card or a port and 
//		then call the correct dispatch routine.
//
//	Arguments:
//		pDevObject	- pointer to a device object.
//		pIrp		- pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		CommonData	= (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO) 
        status = Spx_Card_FDO_DispatchPower(pDevObject, pIrp);
	else 
        status = Spx_Port_PDO_DispatchPower(pDevObject, pIrp);

    return status;
}	// Spx_DispatchPower


	
//////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//		The power dispatch routine to handle power IRPs for card devices.
//
//	Arguments:
//		pFDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pFDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:	// Driver MUST never fail this IRP.
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetSystemPowerState(pFDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetDevicePowerState(pFDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break; 
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
			
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			status = STATUS_NOT_SUPPORTED;
			break;

	}

	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_Card_FDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetSystemPowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetSystemPowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetSystemPowerState


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetDevicePowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetDevicePowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D0.\n", 
			PRODUCT_NAME, pCard->CardNumber));
		
		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D0.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D1.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D2.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D3.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D3.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}


	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetDevicePowerState




//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD0 -  Sets power state D0 for Card - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD0 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	status = Spx_PowerWaitForDriverBelow(pCard->LowerDeviceObject, pIrp);

	
#if DBG
	if(BREAK_ON_POWER_UP)
	{
		BREAK_ON_POWER_UP = FALSE;
	    KdPrint(("%s: Breaking debugger whilst powering up Card %d to debug after a hibernate\n", PRODUCT_NAME, pCard->CardNumber)); 
		DbgBreakPoint();
	}
#endif

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_CardPowerUp(pCard)))		// RESTORE HARDWARE STATE HERE & START CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD0;	// Store new power state.
		SetPnpPowerFlags(pCard, PPF_POWERED); 
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_SetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD3 -  Sets power state D3 for Card - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD3 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	ClearPnpPowerFlags(pCard, PPF_POWERED);		

	if(SPX_SUCCESS(pIrp->IoStatus.Status	= XXX_CardPowerDown(pCard))) // SAVE HARDWARE STATE HERE & STOP CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);						// Ready for next power IRP.
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);	// Pass IRP on down.

	return status;
}	// Spx_SetPowerStateD3







	
//////////////////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//	The power dispatch routine to handle power IRPs for port devices.
//
//	Arguments:
//		pPDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pPDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetSystemPowerState(pPDO, pIrp);
				
			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetDevicePowerState(pPDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
				
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortQuerySystemPowerState(pPDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));

				switch(pIrpStack->Parameters.Power.State.DeviceState)
				{
				case PowerDeviceD0:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to power state D0.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = STATUS_SUCCESS;
					break;

				case PowerDeviceD1:
				case PowerDeviceD2:
				case PowerDeviceD3:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to low power state D1, D2 or D3.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = XXX_PortQueryPowerDown(pPort);
					break;

				default:
					status = STATUS_SUCCESS;
					break;
					
				}

				break;
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));
				break;
			}

			pIrp->IoStatus.Status = status;
			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_SUPPORTED;
			break;
	}

	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_Port_PDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortSetSystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetSystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetSystemPowerState

//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortQuerySystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortQuerySystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortQuerySystemPowerState



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetDevicePowerState 
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetDevicePowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D0.\n", 
			PRODUCT_NAME, pPort->PortNumber));
		
		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D0.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D1.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D2.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D3.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D3.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetDevicePowerState 


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD0 -  Sets power state D0 for Port - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD0 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerUp(pPort)))		// RESTORE HARDWARE STATE HERE & START PORT
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pPort->DeviceState = PowerDeviceD0;	// Store new power state.
		SetPnpPowerFlags(pPort, PPF_POWERED); 
		Spx_UnstallIrps(pPort);				// Restart any queued IRPs (from a previous start)  
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD3 -  Sets power state D3 for Port - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD3 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	ClearPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerDown(pPort)))	// SAVE HARDWARE STATE HERE & STOP PORT
	{   
		// Inform Power Manager the of the new power state. 
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);
		pPort->DeviceState  = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD3



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PowerWaitForDriverBelow -  Waits for lower driver.
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp)
{
	KEVENT		EventWaitLowerDrivers;
	NTSTATUS	status;

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCopyCurrentIrpStackLocationToNext(pIrp);								// Copy parameters to the stack below 
	KeInitializeEvent(&EventWaitLowerDrivers, SynchronizationEvent, FALSE);	// Initialise event if need to wait 
	IoSetCompletionRoutine(pIrp, Spx_DispatchPnpPowerComplete, &EventWaitLowerDrivers, TRUE, TRUE, TRUE);

	if((status = PoCallDriver(pLowerDevObj, pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&EventWaitLowerDrivers, Executive, KernelMode, FALSE, NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} // Spx_PowerWaitForDriverBelow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\spx_pnp.c ===
#include "precomp.h"    // Precompiled header

/****************************************************************************************
*                                                                                       *
*   Module:         SPX_PNP.C                                                           *
*                                                                                       *
*   Creation:       27th September 1998                                                 *
*                                                                                       *
*   Author:         Paul Smith                                                          *
*                                                                                       *
*   Version:        1.0.0                                                               *
*                                                                                       *
*   Description:    Generic Plug and Play Functions to handle PnP IRPS.                 *
*                                                                                       *
****************************************************************************************/
/* History...

1.0.0   27/09/98 PBS    Creation.

*/

#define FILE_ID     SPX_PNP_C       // File ID for Event Logging see SPX_DEFS.H for values.

 
/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp);
NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard);
NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp);
NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort);
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject);


// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_AddDevice)
#pragma alloc_text (PAGE, Spx_DispatchPnp)

#pragma alloc_text (PAGE, Spx_Card_FDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Card_StartDevice)
#pragma alloc_text (PAGE, Spx_Card_StopDevice)
#pragma alloc_text (PAGE, Spx_Card_RemoveDevice)

#pragma alloc_text (PAGE, Spx_CallDriverBelow)

#pragma alloc_text (PAGE, Spx_Port_PDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Port_StartDevice)
#pragma alloc_text (PAGE, Spx_Port_StopDevice)
#pragma alloc_text (PAGE, Spx_Port_RemoveDevice)

#pragma alloc_text (PAGE, Spx_EnumPorts)
#pragma alloc_text (PAGE, Spx_DoExternalNaming)
#pragma alloc_text (PAGE, Spx_GetExternalName)
#pragma alloc_text (PAGE, Spx_RemoveExternalNaming)
#pragma alloc_text (PAGE, Spx_CreatePortInstanceID)
#endif


#include <initguid.h>
#include <ntddser.h>


/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_AddDevice   ******************************
*****************************                   ******************************
******************************************************************************

prototype:      NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)

description:    Create a functional device object (FDO) for the specified card physical device object.

parameters:     pDriver point to the driver object
                pPDO points to a card physical device object (PDO)

returns:        STATUS_SUCCESS
                STATUS_NO_MORE_ENTRIES
*/

NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          pDevObject = NULL;
    PCARD_DEVICE_EXTENSION  pCard = NULL;
    PDEVICE_OBJECT          pLowerDevObject = NULL;
    static ULONG            CardNumber = 0;
    ULONG                   i = 0;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_AddDevice.\n", PRODUCT_NAME));

    if(pPDO == NULL)
    {
        SpxDbgMsg(SPX_MISC_DBG, ("%s: In Spx_AddDevice - No more entries.\n", PRODUCT_NAME));
        return(STATUS_NO_MORE_ENTRIES);
    }

/* Create the device object... */

    status = IoCreateDevice(pDriverObject,
                            sizeof(CARD_DEVICE_EXTENSION),
                            NULL,                           // Doesn't need a name.
                            FILE_DEVICE_CONTROLLER, 
                            FILE_DEVICE_SECURE_OPEN, 
                            TRUE, 
                            &pDevObject);

    if(!SPX_SUCCESS(status))
    {
        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

        SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed for card %d. CardExt at 0x%X.\n",
            PRODUCT_NAME,CardNumber++,&pDevObject));

        sprintf(szErrorMsg, "Card %d: Failed IoCreateDevice.", CardNumber++);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pDriverObject,                  // Driver Object
                        NULL,                           // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        if(pDevObject)                  // Clean up Device Object
            IoDeleteDevice(pDevObject);

        SpxDbgMsg(SPX_ERRORS, ("%s: Leaving Spx_AddDevice - FAILURE.\n", PRODUCT_NAME));
        return(status);
    }


    ASSERT(pDevObject != NULL);

/* Initialise the device extension... */

    pCard = pDevObject->DeviceExtension;                            /* Point to card extension */
    RtlZeroMemory(pCard,sizeof(CARD_DEVICE_EXTENSION));             /* Zero extension structure */

    pDevObject->Flags |= DO_POWER_PAGABLE;              // Get power IRPs at IRQL PASSIVE_LEVEL 
    pDevObject->Flags &= ~DO_DEVICE_INITIALIZING;
    pLowerDevObject = IoAttachDeviceToDeviceStack(pDevObject,pPDO); /* Attach to device stack */
    ASSERT(pLowerDevObject != NULL);

    KeInitializeSpinLock(&pCard->PnpPowerFlagsLock);    /* Initialise the PNP flags lock */
    ClearPnpPowerFlags(pCard,PPF_STARTED);              /* Not started yet */
    ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);         /* Not pending a stop */
    ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);       /* Not pending a remove */

    pCard->IsFDO = TRUE;                                /* Card Object is a Functional Device Object (FDO) */
    pCard->CardNumber = CardNumber++;                   /* Enumerate card devices */
    pCard->DeviceObject = pDevObject;                   /* Back pointer to device object */
    pCard->LowerDeviceObject= pLowerDevObject;          /* Pointer to device below in device stack */
    pCard->DriverObject = pDriverObject;                /* Pointer to driver object */
    pCard->PDO = pPDO;                                  /* Pointer to card physical device object (PDO) */
    pCard->DeviceState = PowerDeviceD0;                 /* Initial power state */
    pCard->SystemState = PowerSystemWorking;            /* System in full power State */
    pCard->NumPDOs = 0;                                 /* Initialise attached port PDO pointers */

    for(i=0; i<PRODUCT_MAX_PORTS; i++)
        pCard->AttachedPDO[i] = NULL;

    SetPnpPowerFlags(pCard,PPF_POWERED);                /* Initially assumed we are powered */

    XXX_CardInit(pCard);                                /* Initialise non-hardware extension fields */

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Leaving Spx_AddDevice - SUCCESS.\n",PRODUCT_NAME));

    return(status);

} /* Spx_AddDevice */

/*****************************************************************************
****************************                     *****************************
****************************   Spx_DispatchPnp   *****************************
****************************                     *****************************
******************************************************************************

prototype:      NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:    The plug and play dispatch routine.
                Determines whether IRP is for a card or a port and calls other functions to handle it. 

parameters:     pDevObject points to a device object for this driver
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA     CommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS                status = STATUS_SUCCESS;
    
    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO)                                   /* Functional Device Object ? */
        status = Spx_Card_FDO_DispatchPnp(pDevObject,pIrp); /* Yes, must be card device */
    else    
        status = Spx_Port_PDO_DispatchPnp(pDevObject,pIrp); /* No, must be port device */

    return(status);

} /* Spx_DispatchPnp */

/*****************************************************************************
************************                              ************************
************************   Spx_Card_FDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)

description:    The plug and play dispatch routine to handle IRPs for card devices.

parameters:     pDevObject points to a card device object for this driver
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)
{
    PCARD_DEVICE_EXTENSION      pCard = pFDO->DeviceExtension;
    PDEVICE_OBJECT              pLowerDevObj = pCard->LowerDeviceObject;
    NTSTATUS                    status;
    PDEVICE_CAPABILITIES        pDevCaps = NULL;
    PIO_STACK_LOCATION          pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    PDEVICE_RELATIONS           pRelations = NULL;
    ULONG                       length = 0;
    ULONG                       i = 0;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 


    switch(pIrpStack->MinorFunction)
    {   

/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
    
    case    IRP_MN_START_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

            status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

/* If successful, then start the card... */

            if(NT_SUCCESS(status))
                status = Spx_Card_StartDevice(pFDO,pIrp);   /* Start the card */

            pIrp->IoStatus.Status = status;
            pIrp->IoStatus.Information = 0;
            IoCompleteRequest(pIrp,IO_NO_INCREMENT);
            break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

    case    IRP_MN_QUERY_DEVICE_RELATIONS:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));
            
            if(pIrpStack->Parameters.QueryDeviceRelations.Type != BusRelations) /* Only handle BusRelations */
            {
                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: IRP_MN_QUERY_DEVICE_RELATIONS for Card - Non bus.\n",PRODUCT_NAME));
                IoSkipCurrentIrpStackLocation(pIrp);
                status = IoCallDriver(pLowerDevObj,pIrp);
                break;
            }

/* Enumerate devices on the card... */

            Spx_EnumPorts(pFDO);                                /* Enumerate and create port device objects */

/* Tell the Plug and Play Manager any found ports... */

            i = 0;
            if(pIrp->IoStatus.Information)                      /* Get current device object count */
                i = ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Count;

            length = sizeof(DEVICE_RELATIONS)+((pCard->NumPDOs+i)*sizeof(PDEVICE_OBJECT));
            if(pRelations = SpxAllocateMem(NonPagedPool, length))/* Allocate new structure */
            {

/* Copy in the device objects so far... */

                if(i)
                    RtlCopyMemory
                    (
                        pRelations->Objects,
                        ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Objects,
                        i * sizeof (PDEVICE_OBJECT)
                    );

                pRelations->Count = i;                              /* Update device count */

/* Add specialix ports to the device relations... */

                if(pCard->NumPDOs)
                {
                    for(i=0; i<PRODUCT_MAX_PORTS; i++)
                    {
                        if(pCard->AttachedPDO[i])                   /* If object exists */
                        {                                           /* add to table */
                            pRelations->Objects[pRelations->Count++] = pCard->AttachedPDO[i];
                            ObReferenceObject(pCard->AttachedPDO[i]);
                        }
                    }
                }

                if(pIrp->IoStatus.Information != 0)                 /* If previous structure */
                    SpxFreeMem((PVOID)pIrp->IoStatus.Information);  /* then free */

                pIrp->IoStatus.Information = (ULONG_PTR)pRelations; /* Set new structure */

            }
            else
            {
                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                sprintf(szErrorMsg, "Card at %08lX: Insufficient resources.", pCard->PhysAddr);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                pCard->DriverObject,            // Driver Object
                                pCard->DeviceObject,            // Device Object (Optional)
                                PhysicalZero,                   // Physical Address 1
                                PhysicalZero,                   // Physical Address 2
                                0,                              // SequenceNumber
                                pIrpStack->MajorFunction,       // Major Function Code
                                0,                              // RetryCount
                                FILE_ID | __LINE__,             // UniqueErrorValue
                                STATUS_SUCCESS,                 // FinalStatus
                                szErrorMsg);                    // Error Message
            }

            pIrp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation(pIrp);                /* Copy parameters to next stack */
            status = IoCallDriver(pLowerDevObj,pIrp);           /* Call driver below */
            break;

/*****************************************************************************
**********************   IRP_MN_QUERY_PNP_DEVICE_STATE   *********************
*****************************************************************************/

    case    IRP_MN_QUERY_PNP_DEVICE_STATE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_PNP_DEVICE_STATE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_CAPABILITIES:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

    case    IRP_MN_QUERY_STOP_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));

            status = STATUS_SUCCESS;
            SetPnpPowerFlags(pCard,PPF_STOP_PENDING);   // We must now expect a STOP IRP

            if(SPX_SUCCESS(status))                     // If we can stop, pass IRP on down
            {
                pIrp->IoStatus.Status = status;
                IoSkipCurrentIrpStackLocation(pIrp);
                status = IoCallDriver(pLowerDevObj,pIrp);
            }
            else                                        // If we can't then complete
            {
                pIrp->IoStatus.Status = status;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            }
            break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

    case    IRP_MN_CANCEL_STOP_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

            status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

            if(SPX_SUCCESS(status))
            {
                // we return the device to its working state here.
                ClearPnpPowerFlags(pCard,PPF_STOP_PENDING); // We are no longer expecting a STOP IRP.
                status = STATUS_SUCCESS;
            }

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            break;

/*****************************************************************************
****************************   IRP_MN_STOP_DEVICE   **************************
*****************************************************************************/

    case    IRP_MN_STOP_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_STOP_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            Spx_Card_StopDevice(pCard);             /* Stop the card hardware */

            pIrp->IoStatus.Status = STATUS_SUCCESS; /* Cannot fail this request */
            IoSkipCurrentIrpStackLocation(pIrp);        
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
************************   IRP_MN_QUERY_REMOVE_DEVICE   **********************
*****************************************************************************/
                
    case    IRP_MN_QUERY_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            status = STATUS_SUCCESS;

            if(SPX_SUCCESS(status))                 // If we can stop, pass IRP on down
            {
                SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING); // We are now ready to remove the card
                pIrp->IoStatus.Status   = status;
                IoSkipCurrentIrpStackLocation(pIrp);
                status = IoCallDriver(pLowerDevObj,pIrp);
            }
            else                                    // If we can't then complete
            {
                pIrp->IoStatus.Status = status;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            }

            break;

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

    case    IRP_MN_CANCEL_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

/* Call driver below first... */

            status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

            if(SPX_SUCCESS(status))
            {
                ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);   // We are no longer expecting to remove the device.
            }

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp,IO_NO_INCREMENT);
            break;

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

    case    IRP_MN_SURPRISE_REMOVAL:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            status = Spx_Card_StopDevice(pCard);    // Lets stop the port ready for the REMOVE IRP if we are not already.

            SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING); // We are now ready to remove the card
            pIrp->IoStatus.Status = status;
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

    case IRP_MN_REMOVE_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_REMOVE_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            status = Spx_Card_RemoveDevice(pFDO);

            pIrp->IoStatus.Status = status;
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

    default:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Card %d.\n",
                PRODUCT_NAME,pIrpStack->MinorFunction,pCard->CardNumber));
            
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

    }

    return(status);

} /* Spx_Card_FDO_DispatchPnp */

/*****************************************************************************
**************************                         ***************************
**************************   Spx_CallDriverBelow   ***************************
**************************                         ***************************
******************************************************************************

prototype:      NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)

description:    Pass the IRP to the driver below this first and wait for it to complete.

parameters:     pLowerDevObj points to a device object for the device below
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)
{
    KEVENT      eventWaitLowerDrivers;
    NTSTATUS    status;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    IoCopyCurrentIrpStackLocationToNext(pIrp);                              /* Copy parameters to the stack below */
    KeInitializeEvent(&eventWaitLowerDrivers,SynchronizationEvent,FALSE);   /* Initialise event if need to wait */
    IoSetCompletionRoutine(pIrp,Spx_DispatchPnpPowerComplete,&eventWaitLowerDrivers,TRUE,TRUE,TRUE);

    if((status = IoCallDriver(pLowerDevObj,pIrp)) == STATUS_PENDING)
    {
        KeWaitForSingleObject(&eventWaitLowerDrivers,Executive,KernelMode,FALSE,NULL);
        status = pIrp->IoStatus.Status;
    }

    return(status);

} /* Spx_CallDriverBelow */

/************************************************************************************
************************                                    *************************
************************   Spx_DispatchPnpPowerComplete     *************************
************************                                    *************************
*************************************************************************************

prototype:      NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)

description:    The PnP IRP was completed by the lower-level drivers.
                Signal this to whoever registered us.

parameters:     pDevObject point to the device completing the IRP
                pIrp points to the Plug and Play I/O Request (IRP) to be completed
                Context was set when the lower driver was called (actually event)

returns:        NT Status Code

*/

NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)
{

    PIO_STACK_LOCATION  stack = NULL;
    PKEVENT             event = (PKEVENT) Context;
    NTSTATUS            status;

    
    UNREFERENCED_PARAMETER(pDevObject);

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering DispatchPnpComplete.\n",PRODUCT_NAME));

    status = STATUS_SUCCESS;
    stack = IoGetCurrentIrpStackLocation(pIrp);

    switch(stack->MajorFunction) 
    {
        case IRP_MJ_PNP:

            switch(stack->MinorFunction) 
            {
                case IRP_MN_START_DEVICE:       // Codes which need processing after lower drivers 
                case IRP_MN_QUERY_CAPABILITIES:
                case IRP_MN_CANCEL_STOP_DEVICE:
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    KeSetEvent(event,0,FALSE);      // Wake up waiting process //
                    return(STATUS_MORE_PROCESSING_REQUIRED);

                default:
                    break;
            }
            break;

        case IRP_MJ_POWER:
                KeSetEvent(event, 0, FALSE);        // Wake up waiting process 
                return(STATUS_MORE_PROCESSING_REQUIRED);

        default:
            break;

    }

    return(status);

} /* Spx_DispatchPnpPowerComplete */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Card_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:    Start the card device:
                    Process resources (interrupt, I/O, memory)
                    Initialise and start the hardware

parameters:     pDevObject point to the card device to start
                pIrp points to the start I/O Request (IRP)

returns:        NT Status Code

*/

NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
    PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
    PIO_STACK_LOCATION      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StartDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

/* Translate the card resources... */

    status = XXX_CardGetResources(  pDevObject,
                                    pIrpStack->Parameters.StartDevice.AllocatedResources,
                                    pIrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
    
    if(!SPX_SUCCESS(status))
        return(status);


/* Start the hardware... */

    if(!SPX_SUCCESS(status = XXX_CardStart(pCard)))
        return(status);

    SetPnpPowerFlags(pCard,PPF_STARTED);    /* Card has been started */

    return(status);

} /* Spx_Card_StartDevice */

/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_EnumPorts   ******************************
*****************************                   ******************************
******************************************************************************

prototype:      NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)

description:    Enumerate port devices found on the card device:

parameters:     pDevObject point to the card device to enumerate

returns:        NT Status Code

*/

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)
{
    PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
    PPORT_DEVICE_EXTENSION  pPort = NULL;

    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          PortPDO = NULL;

    UNICODE_STRING          PortPDOName;
    static ULONG            CurrentInstance = 0;

    UNICODE_STRING          InstanceStr;
    WCHAR                   InstanceNumberBuffer[10];
    POWER_STATE             PowerState;
    USHORT                  PortNumber  = 0;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_EnumPorts for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

// Name and create device objects for each port on the card... 
    
    for(PortNumber=0;PortNumber<pCard->NumberOfPorts;PortNumber++)
    {

        if(pCard->AttachedPDO[PortNumber] == NULL)          // Only create if not already present 
        {

// Create the base port name ("XxPort")... 
        
            RtlZeroMemory(&PortPDOName, sizeof(UNICODE_STRING));
            PortPDOName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
            PortPDOName.Buffer = SpxAllocateMem(PagedPool, PortPDOName.MaximumLength+sizeof(WCHAR));
            if(PortPDOName.Buffer == NULL) continue;
            RtlZeroMemory(PortPDOName.Buffer, PortPDOName.MaximumLength+sizeof(WCHAR));
            RtlAppendUnicodeToString(&PortPDOName, PORT_PDO_NAME_BASE);

// Create the instance ("0")... 

            RtlInitUnicodeString(&InstanceStr,NULL);
            InstanceStr.MaximumLength = sizeof(InstanceNumberBuffer);
            InstanceStr.Buffer = InstanceNumberBuffer;
            RtlIntegerToUnicodeString(CurrentInstance++, 10, &InstanceStr);

// Append instance to the device name ("XxPort0")... 

            RtlAppendUnicodeStringToString(&PortPDOName, &InstanceStr);

// Create the port device object with this name... 

            status = IoCreateDevice(pDevObject->DriverObject, 
                                    sizeof(PORT_DEVICE_EXTENSION),
                                    &PortPDOName,               // Object Name 
                                    FILE_DEVICE_SERIAL_PORT, 
                                    FILE_DEVICE_SECURE_OPEN, 
                                    TRUE, 
                                    &PortPDO);

            if(!SPX_SUCCESS(status))
            {
                SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed = %wZ\n",PRODUCT_NAME,&PortPDOName));
                SpxFreeMem(PortPDOName.Buffer);
                continue;
            }

            ASSERT(PortPDO != NULL);

// Increment the pdo's stacksize so that it can pass irps through... 

            PortPDO->StackSize += pDevObject->StackSize;

// Keep a pointer to the device in the card structure... 

            pCard->NumPDOs++;
            pCard->AttachedPDO[PortNumber] = PortPDO;
            ObReferenceObject(PortPDO);

// Initialise port device object and extension... 

            pPort = PortPDO->DeviceExtension;
            RtlZeroMemory(pPort,sizeof(PORT_DEVICE_EXTENSION));     // Clear the device extension 

            pPort->DeviceName = PortPDOName;

            KeInitializeSpinLock(&pPort->PnpPowerFlagsLock);        // Initialise the PNP flags lock 
            ClearPnpPowerFlags(pPort,PPF_STARTED);                  // Not started yet 
            ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);             // Not pending a stop 
            ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);           // Not pending a remove 
            ClearPnpPowerFlags(pPort,PPF_REMOVED);                  // Not removed 
            SetPnpPowerFlags(pPort,PPF_POWERED);                    // Initially powered up 

            InitializeListHead(&pPort->StalledIrpQueue);            // Initialise the stalled IRP list 
            KeInitializeSpinLock(&pPort->StalledIrpLock);           // Initialise the StalledIrpLock flags lock 
            pPort->UnstallingFlag = FALSE;                          // Initialise UnstallingIrps Flag.

            pPort->IsFDO = FALSE;
            pPort->PortNumber = PortNumber;                         // system port number 
            pPort->UniqueInstanceID = FALSE;                        // Instance ID not unique by default.
            pPort->DeviceIsOpen = FALSE;                            // Port is closed to start with 
            pPort->DeviceObject = PortPDO;                          // Backpointer to device object 
            pPort->DeviceState = PowerDeviceD0;                     // Port device in full power state 
            pPort->SystemState = PowerSystemWorking;                // System in full power State 
            pPort->pParentCardExt = pCard;                          // Point to the parent card extension 
            ExInitializeFastMutex(&pPort->OpenMutex);

            if(!SPX_SUCCESS(status = XXX_PortInit(pPort)))          // Initialise hardware 
                continue;

            // Inform Power Manager the of the new power state.
            PowerState.DeviceState = pPort->DeviceState;
            PoSetPowerState(pPort->DeviceObject, DevicePowerState, PowerState);

            PortPDO->Flags &= ~DO_DEVICE_INITIALIZING;              // Finished Initialising 
            PortPDO->Flags |= DO_BUFFERED_IO;                       // Do Buffered IO 
            PortPDO->Flags |= DO_BUS_ENUMERATED_DEVICE;             // Bus enumerated 
            PortPDO->Flags |= DO_POWER_PAGABLE;                     // Get power IRPs at IRQL PASSIVE_LEVEL 

        }
        else
        {
            PortPDO = pCard->AttachedPDO[PortNumber];
            pPort = PortPDO->DeviceExtension;

            if(pPort->PnpPowerFlags & PPF_REMOVED)
                ClearPnpPowerFlags(pPort,PPF_REMOVED);
        }
    }

    return(status);

} // End Spx_EnumPorts 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Card_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:    Stop the card device:
                    Stop the hardware
                    Deinitialise card resources (interrupt, I/O, memory)

parameters:     pCard points to the card device to stop

returns:        NT Status Code

*/

NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)
{
    NTSTATUS    status = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StopDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

    if(pCard->PnpPowerFlags & PPF_STARTED)      /* If card is running */
    {
        XXX_CardStop(pCard);                    /* Stop the card */
    }

    ClearPnpPowerFlags(pCard,PPF_STARTED);      /* Indicate card is stopped */
    ClearPnpPowerFlags(pCard,PPF_STOP_PENDING); /* Clear stop pending flag */

    return(status);

} /* Spx_Card_StopDevice */

/*****************************************************************************
*************************                           **************************
*************************   Spx_Card_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:    Remove the card device:
                    Deallocate any resources
                    Delete device object

parameters:     pDevObject points to the card device object to remove

returns:        NT Status Code

*/


NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
    PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
    PDEVICE_OBJECT          pPortPdo;
    PPORT_DEVICE_EXTENSION  pPort;
    NTSTATUS                status = STATUS_SUCCESS;
    int                     loop;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_Card_RemoveDevice for Card %d.\n", 
        PRODUCT_NAME, pCard->CardNumber));

/* First remove all "removed" port device objects... */

    for(loop=0; loop<PRODUCT_MAX_PORTS; loop++)
    {
        if(pPortPdo = pCard->AttachedPDO[loop])         /* Enumerated port PDO ? */
        {
            pPort = pPortPdo->DeviceExtension;          /* Get the device extension */
            XXX_PortDeInit(pPort);                      /* Deinitialise port structure */
            if(pPort->DeviceName.Buffer)
            {
                SpxFreeMem(pPort->DeviceName.Buffer);   /* Free device name buffer */
                pPort->DeviceName.Buffer = NULL;
            }
            pCard->AttachedPDO[loop] = NULL;            /* Remove the port PDO pointer */
            pCard->NumPDOs--;                           /* One less port attached */
            IoDeleteDevice(pPortPdo);                   /* Delete the port device object */
            ObDereferenceObject(pPortPdo);              /* Dereference the object */
        }
    }

/* Now, remove the card device object... */

    Spx_Card_StopDevice(pCard);                         /* Stop the card and release resources */
    XXX_CardDeInit(pCard);                              /* Deinitialise non-hardware fields */
    IoDetachDevice(pCard->LowerDeviceObject);           /* Detach card device from the device stack. */
    IoDeleteDevice(pDevObject);                         /* Delete Card FDO from system. */

    return(status);

} /* Spx_Card_RemoveDevice */



/*****************************************************************************
************************                              ************************
************************   Spx_Port_PDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)

description:    The plug and play dispatch routine to handle IRPs for port devices.

parameters:     pDevObject points to a port device object for this driver
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)
{
    PPORT_DEVICE_EXTENSION  pPort = pPDO->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    PIO_STACK_LOCATION      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    NTSTATUS                status;
    PWCHAR                  ReturnBuffer = NULL;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    status = pIrp->IoStatus.Status;

    switch (pIrpStack->MinorFunction) 
    {
   
/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
    
    case    IRP_MN_START_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Port %d.\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_UNSUCCESSFUL;

            if(SPX_SUCCESS(status = Spx_Port_StartDevice(pPDO)))
                Spx_UnstallIrps(pPort);                 // Restart any queued IRPs (from a previous start) 

            break;

/*****************************************************************************
*****************************   IRP_MN_QUERY_ID   ****************************
*****************************************************************************/
    
    case    IRP_MN_QUERY_ID:
    {
        PUNICODE_STRING pId = NULL;
        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

        switch(pIrpStack->Parameters.QueryId.IdType)
        {
        case    BusQueryCompatibleIDs:
        case    BusQueryDeviceID:
        case    BusQueryInstanceID:
        case    BusQueryHardwareIDs:
            {
                status = STATUS_SUCCESS;

                switch(pIrpStack->Parameters.QueryId.IdType)
                {
                case    BusQueryDeviceID:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryDeviceID Irp for Port %d.\n",
                            PRODUCT_NAME,pPort->PortNumber));
                        SpxDbgMsg(SPX_MISC_DBG,("%s: Device ID %wZ.\n", PRODUCT_NAME,&pPort->DeviceID));
                        pId = &pPort->DeviceID;
                        break;

                case    BusQueryInstanceID:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryInstanceID Irp for Port %d.\n",
                            PRODUCT_NAME, pPort->PortNumber));
                        SpxDbgMsg(SPX_MISC_DBG,("%s: Instance ID %wZ.\n",PRODUCT_NAME,&pPort->InstanceID));
                        pId = &pPort->InstanceID;
                        break;

                case    BusQueryCompatibleIDs:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryCompatibleIDs Irp for Port %d.\n",
                            PRODUCT_NAME, pPort->PortNumber));
                        pId = &pPort->CompatibleIDs;
                        break;

                case    BusQueryHardwareIDs:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryHardwareIDs Irp for Port %d.\n",
                            PRODUCT_NAME, pPort->PortNumber));
                        pId = &pPort->HardwareIDs;
                        break;
                
                default:
                    break;
                }

                if(pId)
                {
                    if(pId->Buffer)
                    {
                        if(ReturnBuffer = SpxAllocateMem(PagedPool, pId->Length + sizeof(WCHAR)))
                                RtlCopyMemory(ReturnBuffer, pId->Buffer, pId->Length + sizeof(WCHAR));
                        else    
                        {
                            sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                    pPort->PortNumber+1, pCard->PhysAddr);

                            Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                            pPort->DriverObject,            // Driver Object
                                            pPort->DeviceObject,            // Device Object (Optional)
                                            PhysicalZero,                   // Physical Address 1
                                            PhysicalZero,                   // Physical Address 2
                                            0,                              // SequenceNumber
                                            pIrpStack->MajorFunction,       // Major Function Code
                                            0,                              // RetryCount
                                            FILE_ID | __LINE__,             // UniqueErrorValue
                                            STATUS_SUCCESS,                 // FinalStatus
                                            szErrorMsg);                    // Error Message

                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }

                    pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
                }
                break;
            }
        
        default:
            break;
        }
        break;

    }

/*****************************************************************************
*************************   IRP_MN_QUERY_DEVICE_TEXT   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_DEVICE_TEXT:
    {
        PUNICODE_STRING pText = NULL;
        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_TEXT Irp for Port %d.\n",
                PRODUCT_NAME,pPort->PortNumber));

            if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription)
                pText = &pPort->DevDesc;

            if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation)
                pText = &pPort->DevLocation;

            if((pText == NULL)||(pText->Buffer == NULL))
                break;

            if(!(ReturnBuffer = SpxAllocateMem(PagedPool, pText->Length + sizeof(WCHAR))))
            {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                        pPort->PortNumber+1, pCard->PhysAddr);

                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                pPort->DriverObject,            // Driver Object
                                pPort->DeviceObject,            // Device Object (Optional)
                                PhysicalZero,                   // Physical Address 1
                                PhysicalZero,                   // Physical Address 2
                                0,                              // SequenceNumber
                                pIrpStack->MajorFunction,       // Major Function Code
                                0,                              // RetryCount
                                FILE_ID | __LINE__,             // UniqueErrorValue
                                STATUS_SUCCESS,                 // FinalStatus
                                szErrorMsg);                    // Error Message

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = STATUS_SUCCESS;
            RtlCopyMemory(ReturnBuffer, pText->Buffer, pText->Length + sizeof(WCHAR));
            pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
            break;
    }

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_CAPABILITIES:
    {
            PDEVICE_CAPABILITIES    pDevCaps = NULL;

            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));
            
            // Get the packet
            pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

            // Set the capabilities.
            pDevCaps->Version = 1;
            pDevCaps->Size = sizeof(DEVICE_CAPABILITIES);

            // We cannot wake the system.
            pDevCaps->SystemWake = PowerSystemUnspecified;
            pDevCaps->DeviceWake = PowerSystemUnspecified;

            // Set device state mapping...

            pDevCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
            pDevCaps->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

            // We have no latencies.
            pDevCaps->D1Latency = 0;
            pDevCaps->D2Latency = 0;
            pDevCaps->D3Latency = 0;

            // No locking or ejection.
            pDevCaps->LockSupported = FALSE;
            pDevCaps->EjectSupported = FALSE;

            // Removable
            pDevCaps->Removable = FALSE;

            // Not a Docking device.
            pDevCaps->DockDevice = FALSE;

            // System wide unique ID.
            pDevCaps->UniqueID = pPort->UniqueInstanceID;

            //UINumber
            pDevCaps->UINumber = pPort->PortNumber+1;

            // Raw capable
            pDevCaps->RawDeviceOK = TRUE;

            // Silent Install
            pDevCaps->SilentInstall = FALSE;

            // Surprise Removal
            pDevCaps->SurpriseRemovalOK = FALSE;

            status = STATUS_SUCCESS;
            break;
    }

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

    case    IRP_MN_QUERY_STOP_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_UNSUCCESSFUL;

            if(pPort->PnpPowerFlags & PPF_STARTED)
            {
                ExAcquireFastMutex(&pPort->OpenMutex);

                if(pPort->DeviceIsOpen) 
                {
                    ExReleaseFastMutex(&pPort->OpenMutex);
                    status = STATUS_DEVICE_BUSY;

                    SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
                        PRODUCT_NAME, pPort->PortNumber));
                }
                else
                {
                    SetPnpPowerFlags(pPort,PPF_STOP_PENDING);
                    status = STATUS_SUCCESS;
                    ExReleaseFastMutex(&pPort->OpenMutex);
                }
            }
            break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

    case    IRP_MN_CANCEL_STOP_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;
            ClearPnpPowerFlags(pPort,PPF_STOP_PENDING); // Clear the stop pending flag 
            Spx_UnstallIrps(pPort);                     // Restart any queued IRPs 
            break;

/*****************************************************************************
***************************   IRP_MN_STOP_DEVICE   ***************************
*****************************************************************************/

    case    IRP_MN_STOP_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_STOP_DEVICE Irp for Port %d\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;        // we must never fail this IRP (if we do we will probably unload).
            status = Spx_Port_StopDevice(pPort);
            ClearPnpPowerFlags(pPort,PPF_STOP_PENDING); // Clear the stop pending flag 
            break;

/*****************************************************************************
***********************   IRP_MN_QUERY_REMOVE_DEVICE   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_REMOVE_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));

            ExAcquireFastMutex(&pPort->OpenMutex);

            if(pPort->DeviceIsOpen) 
            {
                ExReleaseFastMutex(&pPort->OpenMutex);
                status = STATUS_DEVICE_BUSY;

                SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
                    PRODUCT_NAME, pPort->PortNumber));
            }
            else
            {
                SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING); // We are now ready to remove the port
                status = STATUS_SUCCESS;
                ExReleaseFastMutex(&pPort->OpenMutex);
            }

            break; 

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

    case    IRP_MN_CANCEL_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME, pPort->PortNumber));
            
            status = STATUS_SUCCESS;
            ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);   // We are no longer expecting to remove the device.
            break; 

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

    case    IRP_MN_SURPRISE_REMOVAL:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Port %d\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;        // we must never fail this IRP (if we do we will probably unload).
            status = Spx_Port_StopDevice(pPort);
            SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING); // We are now ready to remove the port
            break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

    case    IRP_MN_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_REMOVE_DEVICE Irp for Port %d\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;        // we must never fail this IRP (if we do we will probably unload).
            Spx_KillStalledIRPs(pPDO);      // Kill off any waiting IRPS on the stalled list 
            status = Spx_Port_RemoveDevice(pPDO);
            ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);   // Clear the pending flag 
            break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

    case    IRP_MN_QUERY_DEVICE_RELATIONS:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Port %d.\n", 
                PRODUCT_NAME, pPort->PortNumber));

            switch(pIrpStack->Parameters.QueryDeviceRelations.Type)
            {
            case TargetDeviceRelation:
                {
                    PDEVICE_RELATIONS pDevRel = NULL;

                    if(pIrp->IoStatus.Information != 0)
                        break;

                    if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
                    {
                        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);

                        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                        pPort->DriverObject,            // Driver Object
                                        pPort->DeviceObject,            // Device Object (Optional)
                                        PhysicalZero,                   // Physical Address 1
                                        PhysicalZero,                   // Physical Address 2
                                        0,                              // SequenceNumber
                                        pIrpStack->MajorFunction,       // Major Function Code
                                        0,                              // RetryCount
                                        FILE_ID | __LINE__,             // UniqueErrorValue
                                        STATUS_SUCCESS,                 // FinalStatus
                                        szErrorMsg);                    // Error Message

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    pDevRel->Count = 1;
                    pDevRel->Objects[0] = pPDO;
                    ObReferenceObject(pPDO);

                    status = STATUS_SUCCESS;
                    pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
                    break;
                }

            case BusRelations:
                {
                    PDEVICE_RELATIONS pDevRel = NULL;

                    if(pIrp->IoStatus.Information != 0)
                        break;

                    if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
                    {
                        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);
                        
                        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                        pPort->DriverObject,            // Driver Object
                                        pPort->DeviceObject,            // Device Object (Optional)
                                        PhysicalZero,                   // Physical Address 1
                                        PhysicalZero,                   // Physical Address 2
                                        0,                              // SequenceNumber
                                        pIrpStack->MajorFunction,       // Major Function Code
                                        0,                              // RetryCount
                                        FILE_ID | __LINE__,             // UniqueErrorValue
                                        STATUS_SUCCESS,                 // FinalStatus
                                        szErrorMsg);                    // Error Message

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    pDevRel->Count = 0;
                    status = STATUS_SUCCESS;
                    pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
                    break;

                }

            default:
                break;
            }
            break;


    default:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Port %d.\n", 
                PRODUCT_NAME,pIrpStack->MinorFunction, pPort->PortNumber));
            break;
    }

    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return(status);

} /* Spx_Port_PDO_DispatchPnp */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Port_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)

description:    Start the port device:
                    Setup external naming
                    Initialise and start the hardware

parameters:     pDevObject point to the card device to start
                pIrp points to the start I/O Request (IRP)

returns:        NT Status Code

*/

NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)
{

    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;    
    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StartDevice for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

    if(!pPort->CreatedSymbolicLink)
    {
        if(!SPX_SUCCESS(status = Spx_DoExternalNaming(pDevObject)))     // Set up external name for device 
            return(status);
    }

    if(!SPX_SUCCESS(status = XXX_PortStart(pPort)))             // Start hardware. 
    {
        Spx_RemoveExternalNaming(pDevObject);                   // Remove external naming.
        return(status);
    }

    SetPnpPowerFlags(pPort,PPF_STARTED);                        // Port has been started.
    ClearPnpPowerFlags(pPort,PPF_REMOVED);                      // Port is not removed...yet. 
    ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);                 // Not pending a stop. 
    ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);               // Not pending a remove. 

    return(status);

} // Spx_Port_StartDevice 


/*****************************************************************************
**************************                          **************************
**************************   Spx_GetExternalName   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)

description:    Setup external naming for a port:
                    get Dos Name for port 
                    form symbolic link name

parameters:     pDevObject points to the device object for the port to be named

returns:        NT Status Code

*/
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS                status = STATUS_SUCCESS;
    HANDLE                  PnPKeyHandle;
    UNICODE_STRING          TmpLinkName;
    WCHAR                   *pRegName = NULL;
    ULONG                   BuffLen = 0;
    CHAR                    szErrorMsg[MAX_ERROR_LOG_INSERT];   // Limited to 51 characters + 1 null 
        
    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_GetExternalName for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

    status = IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle);

    if(!SPX_SUCCESS(status))
        return(status);

// Get the device name allocated by the PNP manager from the registry... 
    if(pRegName = SpxAllocateMem(PagedPool,SYMBOLIC_NAME_LENGTH * sizeof(WCHAR) + sizeof(WCHAR)))
    {
        status = Spx_GetRegistryKeyValue(   PnPKeyHandle,
                                            L"PortName",
                                            sizeof(L"PortName"),
                                            pRegName,
                                            SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ZwClose(PnPKeyHandle);

    if(!SPX_SUCCESS(status))
    {
        if(pRegName != NULL) 
            SpxFreeMem(pRegName);

        return(STATUS_SUCCESS);         // Port has not been given a name yet but we must not fail.
    }

    RtlZeroMemory(&TmpLinkName, sizeof(UNICODE_STRING));

    if(!SPX_SUCCESS(status))
        goto NamingError;
    
    TmpLinkName.MaximumLength   = SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
    TmpLinkName.Buffer          = SpxAllocateMem(PagedPool, TmpLinkName.MaximumLength + sizeof(WCHAR));
    
    if(!TmpLinkName.Buffer)
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);

        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto NamingError;
    }

    RtlZeroMemory(TmpLinkName.Buffer, TmpLinkName.MaximumLength + sizeof(WCHAR));

    // Create the "\\DosDevices\\<SymbolicName>" string.
    RtlAppendUnicodeToString(&TmpLinkName, L"\\");
    RtlAppendUnicodeToString(&TmpLinkName, DEFAULT_DIRECTORY);
    RtlAppendUnicodeToString(&TmpLinkName, L"\\");
    RtlAppendUnicodeToString(&TmpLinkName, pRegName);

    pPort->SymbolicLinkName.Length          = 0;
    pPort->SymbolicLinkName.MaximumLength   = TmpLinkName.Length + sizeof(WCHAR);
    pPort->SymbolicLinkName.Buffer          = SpxAllocateMem(PagedPool, pPort->SymbolicLinkName.MaximumLength);
    
    if(!pPort->SymbolicLinkName.Buffer)
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);

        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto NamingError;
    }

    RtlZeroMemory(pPort->SymbolicLinkName.Buffer, pPort->SymbolicLinkName.MaximumLength);
    RtlAppendUnicodeStringToString(&pPort->SymbolicLinkName, &TmpLinkName);


    pPort->DosName.Buffer = SpxAllocateMem(PagedPool, 64 + sizeof(WCHAR));

    if(!pPort->DosName.Buffer)
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto NamingError;
    }

    pPort->DosName.MaximumLength = 64 + sizeof(WCHAR);

    pPort->DosName.Length = 0;
    RtlZeroMemory(pPort->DosName.Buffer, pPort->DosName.MaximumLength);
    RtlAppendUnicodeToString(&pPort->DosName, pRegName);
    RtlZeroMemory(((PUCHAR) (&pPort->DosName.Buffer[0])) + pPort->DosName.Length, sizeof(WCHAR));

    SpxDbgMsg(SPX_MISC_DBG, ("%s: DeviceName is %wZ\n", PRODUCT_NAME, &pPort->DeviceName));
    SpxDbgMsg(SPX_MISC_DBG, ("%s: DosName is %wZ\n", PRODUCT_NAME, &pPort->DosName));
    SpxDbgMsg(SPX_MISC_DBG, ("%s: SymbolicName is %wZ\n", PRODUCT_NAME, &pPort->SymbolicLinkName));

    if(pRegName != NULL)
        SpxFreeMem(pRegName);   // Free pRegName

    if(TmpLinkName.Buffer != NULL)
        SpxFreeMem(TmpLinkName.Buffer); // Free TmpLinkName

    return(status);


NamingError:;

    if(TmpLinkName.Buffer != NULL)
        SpxFreeMem(TmpLinkName.Buffer);

    if(pRegName != NULL)
        SpxFreeMem(pRegName);

    return(status);
}

/*****************************************************************************
**************************                          **************************
**************************   Spx_DoExternalNaming   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:    Setup external naming for a port:
                    create symbolic link
                    add to registry
                    register and enable interface

parameters:     pDevObject points to the device object for the port to be named

returns:        NT Status Code

*/
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS                status = STATUS_SUCCESS;
    CHAR                    szErrorMsg[MAX_ERROR_LOG_INSERT];   // Limited to 51 characters + 1 null 
        
    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DoExternalNaming for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

// Get external name...
    if( !SPX_SUCCESS(status = Spx_GetExternalName(pDevObject)) || (pPort->DosName.Buffer == NULL))
        return(status);


    status = IoCreateSymbolicLink(&pPort->SymbolicLinkName, &pPort->DeviceName);  // Create the symbolic link... 

    if(!SPX_SUCCESS(status))
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        goto ExternalNamingError;
    }

// Add mapping to "SERIALCOMM" section of registry... 
    pPort->CreatedSymbolicLink = TRUE;
    
    status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP,
                                    L"SERIALCOMM",
                                    pPort->DeviceName.Buffer,
                                    REG_SZ,
                                    pPort->DosName.Buffer,
                                    pPort->DosName.Length + sizeof(WCHAR));

    if(!SPX_SUCCESS(status))
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Registry error.", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        goto ExternalNamingError;
    }

    status = IoRegisterDeviceInterface( pDevObject, (LPGUID)&GUID_CLASS_COMPORT,
                                        NULL, &pPort->DeviceClassSymbolicName);

    if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Interface error.", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        pPort->DeviceClassSymbolicName.Buffer = NULL;
        
        goto ExternalNamingError;
    }

    // Enable the device interface.
    status = IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, TRUE);

    if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Interface error.", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        
        goto ExternalNamingError;
    }



    pPort->CreatedSerialCommEntry = TRUE;               // Set flag.

    return(status);


ExternalNamingError:;

    if(!SPX_SUCCESS(status))
        Spx_RemoveExternalNaming(pDevObject);           // Remove and tidy up any allocations 


    return(status);

} // End Spx_DoExternalNaming 

/*****************************************************************************
************************                              ************************
************************   Spx_RemoveExternalNaming   ************************
************************                              ************************
******************************************************************************

prototype:      NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:    Remove external naming:
                    remove symbolic link
                    remove from registry
                    stop interface

parameters:     pDevObject points to the device object for the port to be named.

returns:        NT Status Code

*/
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(pPort->CreatedSymbolicLink)
    {
        if(pPort->DosName.Buffer)
        {
            SpxFreeMem(pPort->DosName.Buffer);                      // Free DOS name buffer. 
            pPort->DosName.Buffer = NULL;
        }

        if(pPort->SymbolicLinkName.Buffer)
        {
            SpxFreeMem(pPort->SymbolicLinkName.Buffer);             // Free symbolic link name buffer. 
            pPort->SymbolicLinkName.Buffer = NULL;
        }

        Spx_GetExternalName(pDevObject);    // Get external name..

        if(pPort->SymbolicLinkName.Buffer)
            status = IoDeleteSymbolicLink(&pPort->SymbolicLinkName);    // Delete Symbolic Link. 

        if(pPort->DeviceClassSymbolicName.Buffer)   // Device Interface name
            IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, FALSE);  // Disable Device Interface.


        pPort->CreatedSymbolicLink = FALSE;                                             // Reset created flag. 
    }

    if(pPort->DosName.Buffer)
    {
        SpxFreeMem(pPort->DosName.Buffer);                  // Free DOS name buffer. 
        pPort->DosName.Buffer = NULL;
    }

    if(pPort->SymbolicLinkName.Buffer)
    {
        SpxFreeMem(pPort->SymbolicLinkName.Buffer);         // Free symbolic link name buffer. 
        pPort->SymbolicLinkName.Buffer = NULL;
    }

    if(pPort->CreatedSerialCommEntry && pPort->DeviceName.Buffer)
    {
        RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP,     // Delete SERIALCOMM registry entry. 
                                SERIAL_DEVICE_MAP,
                                pPort->DeviceName.Buffer);

        pPort->CreatedSerialCommEntry = FALSE;              // Reset created flag.
    }

    if(pPort->DeviceClassSymbolicName.Buffer)   // Device Interface name
    {           
        SpxFreeMem(pPort->DeviceClassSymbolicName.Buffer);                  // Free Device Interface Name.
        pPort->DeviceClassSymbolicName.Buffer = NULL;
    }

    return(STATUS_SUCCESS);

} // End Spx_RemoveExternalNaming 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Port_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)

description:    Stop the port device:
                    Stop the hardware
                    Remove external naming

parameters:     pPort points to the port device extension to be stopped

returns:        NT Status Code

*/

NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)
{
    NTSTATUS    status  = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StopDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

    if(pPort->PnpPowerFlags & PPF_STARTED)
        XXX_PortStop(pPort);                                    // Stop the port hardware. 

    ClearPnpPowerFlags(pPort,PPF_STARTED);                      // Indicate card is stopped. 
    ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);                 // Clear stop pending flag.

    return(status);

} // End Spx_Port_StopDevice

/*****************************************************************************
*************************                           **************************
*************************   Spx_Port_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:    Remove the port device object:
                    Remove PDO pointer from card structure
                    Deinitialise port hardware
                    Delete the device object

parameters:     pDevObject points to the port device object to be stopped

returns:        NT Status Code

*/
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort   = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard   = pPort->pParentCardExt;
    NTSTATUS                status  = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_RemoveDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

    if(pPort->PnpPowerFlags & PPF_REMOVED)                  // Has device been removed already?
        return(STATUS_SUCCESS);

    Spx_Port_StopDevice(pPort);                             // Stop the hardware.
    ClearPnpPowerFlags(pPort,PPF_STARTED);                  // Mark the PDO as stopped.

    Spx_RemoveExternalNaming(pDevObject);                   // Remove external naming. 


// Mark the port device as "removed", but don't delete the PDO until the card device is removed...
    SetPnpPowerFlags(pPort,PPF_REMOVED);                    // Mark the PDO as "removed".

    return(status);

} // End Spx_Port_RemoveDevice 




/////////////////////////////////////////////////////////////////////////////////////////////
// Create an Instance ID for the port and try to make it globally unique if possible.
//
NTSTATUS
Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort)
{
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS                status = STATUS_SUCCESS;
    CHAR                    szTemp[100];        // Space to hold string 
    int                     szTempPos = 0;
    HANDLE                  PnPKeyHandle;
    BOOLEAN                 UseBusWideInstanceID = FALSE;  // Try to create system wide unique instance IDs

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_CreatePortInstanceID for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

    status = IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_READ, &PnPKeyHandle);

    if(SPX_SUCCESS(status))
    {
        ULONG Data = 0;

        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, L"UseBusWideInstanceID", 
                            sizeof(L"UseBusWideInstanceID"), &Data, sizeof(ULONG))))
        {
            if(Data > 0)
                UseBusWideInstanceID = TRUE;  // Installer has told us to use a bus wide instance ID 
                                              // because child devices already exist with that type of ID.
        }
        

        ZwClose(PnPKeyHandle);
    }

    if(UseBusWideInstanceID)
    {
        pPort->UniqueInstanceID = FALSE;    // ID created is not unique system wide.
        status = STATUS_SUCCESS;
    }
    else
    {
        switch(pCard->InterfaceType)
        {
        case Isa:
            // Start Instance ID with ISA address
            szTempPos += sprintf(szTemp,"ISA&%08X%08X&", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
            pPort->UniqueInstanceID = TRUE; // ID created is unique system wide.
            status = STATUS_SUCCESS;
            break;

        case PCIBus:
            {
                ULONG PCI_BusNumber = 0;
                ULONG PCI_DeviceFunction = 0;
                ULONG ResultLength;

                // Try to get DevicePropertyBusNumber
                if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyBusNumber, 
                                            sizeof(PCI_BusNumber), &PCI_BusNumber, &ResultLength)))
                    break;


                // Start Instance ID with PCI bus number
                szTempPos += sprintf(szTemp,"PCI&%04X&", PCI_BusNumber);

                // Try to get DevicePropertyAddress
                if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyAddress, 
                                            sizeof(PCI_DeviceFunction), &PCI_DeviceFunction, &ResultLength)))
                    break;
                

                // Add on PCI Device and Function IDs
                szTempPos += sprintf(szTemp + szTempPos,"%08X&", PCI_DeviceFunction);
                pPort->UniqueInstanceID = TRUE; // ID created is unique system wide.

                status = STATUS_SUCCESS;
                break;
            }
        
        default:
            pPort->UniqueInstanceID = FALSE;    // ID created is not unique system wide.
            status = STATUS_SUCCESS;
            break;

        }

    }

    // Finish off the InstanceID with the port number on the card.
    sprintf(szTemp + szTempPos,"%04X", pPort->PortNumber);

    status = Spx_InitMultiString(FALSE, &pPort->InstanceID, szTemp, NULL);


    return status;
}



// End of SPX_PNP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\spx_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING pMofResourceName,
						OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchSystemControl)
#pragma alloc_text(PAGE, SpxPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpxPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpxPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataItem)
#endif




/********************************************************************************
********************								*****************************
********************	Spx_SystemControlDispatch	*****************************
********************								*****************************
********************************************************************************/
NTSTATUS
Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		pCommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION	IrpDisposition;
	PDEVICE_OBJECT			pLowerDevObj = pCommonData->LowerDeviceObject;
    NTSTATUS				status = pIrp->IoStatus.Status;

    PAGED_CODE();

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DispatchSystemControl.\n", PRODUCT_NAME));

    status = WmiSystemControl(&pCommonData->WmiLibInfo, pDevObject, pIrp, &IrpDisposition);
                                 
    switch(IrpDisposition)
    {
        case IrpProcessed:
        {
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            // This irp has not been completed, but has been fully processed, we will complete it now.
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            // This irp is either not a WMI irp or is a WMI irp targetted at a device lower in the stack.

			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }
                                    
        default:
        {
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
			
			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }        
    }
    
	return(status);
}







// End of prototypes.


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID StdSerialPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID StdSerialPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID StdSerialPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID StdSerialPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID StdSerialPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI

WMIGUIDREGINFO SpxPort_WmiGuidList[] =
{
    { &StdSerialPortNameGuid, 1, 0 },
    { &StdSerialPortCommGuid, 1, 0 },
    { &StdSerialPortHWGuid, 1, 0 },
    { &StdSerialPortPerfGuid, 1, 0 },
    { &StdSerialPortPropertiesGuid, 1, 0}
};


#define SpxPort_WmiGuidCount (sizeof(SpxPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpxPort_WmiGuidCount;
    WmilibContext->GuidList				= SpxPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpxPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpxPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpxPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpxPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	
    WmilibContext->WmiFunctionControl	= NULL;	

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.


	return(status);
}





NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\utils.c ===
#include "precomp.h"			
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains code that perform queueing and completion
    manipulation on requests.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer
    );


VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )

/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    DeviceObject - A pointer to the serial device object.

    QueueToClean - A pointer to the queue which we're going to clean out.

    CurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{
    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We acquire the cancel spin lock.  This will prevent the irps from moving around.
    //
    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //
    while(!IsListEmpty(QueueToClean)) 
	{
        PIRP currentLastIrp = CONTAINING_RECORD(QueueToClean->Blink, IRP, Tail.Overlay.ListEntry);
                                  
        RemoveEntryList(QueueToClean->Blink);
		SpxIRPCounter(pPort, currentLastIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(DeviceObject, currentLastIrp);
            
        IoAcquireCancelSpinLock(&cancelIrql);
    }

    //
    // The queue is clean.  Now go after the current if it's there.
    //
    if(*CurrentOpIrp) 
	{
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //
        if(cancelRoutine) 
		{
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for it.
            //
            cancelRoutine(DeviceObject, *CurrentOpIrp);

        } 
		else 
		{
            IoReleaseCancelSpinLock(cancelIrql);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(cancelIrql);
    }

}

VOID
SerialGetNextIrp(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    PIRP oldIrp;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    oldIrp = *CurrentOpIrp;

    if(CompleteCurrent) 
        ASSERT(!oldIrp->CancelRoutine);

    //
    // Check to see if there is a new irp to start up.
    //
    if(!IsListEmpty(QueueToProcess)) 
	{
        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(headOfList, IRP, Tail.Overlay.ListEntry);
		SpxIRPCounter(pPort, *CurrentOpIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    } 
	else 
	{
        *CurrentOpIrp = NULL;
    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(oldIrql);

    if(CompleteCurrent)
	{
		SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
	}
}

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    pPort - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //
    SERIAL_DEC_REFERENCE(*CurrentOpIrp);

    if(SynchRoutine) 
        KeSynchronizeExecution(pCard->Interrupt, SynchRoutine, pPort);


    //
    // Try to run down all other references to this irp.
    //
    SerialRundownIrpRefs(CurrentOpIrp, IntervalTimer, TotalTimer);

    //
    // See if the ref count is zero after trying to kill everybody else.
    //
    if(!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) 
	{
        PIRP newIrp;

        IoReleaseCancelSpinLock(IrqlForRelease);

        //
        // The ref count was zero so we should complete this
        // request.
        //
        // The following call will also cause the current irp to be
        // completed.
        //

        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if(StatusToUse == STATUS_CANCELLED) 
            (*CurrentOpIrp)->IoStatus.Information = 0;


        if(GetNextIrp) 
		{
            GetNextIrp(pPort, CurrentOpIrp, QueueToProcess, &newIrp, TRUE);
               
            if(newIrp) 
                Starter(pPort);

        } 
		else 
		{
            PIRP oldIrp = *CurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //
            *CurrentOpIrp = NULL;

			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(IrqlForRelease);
    }

}

VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    )

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

Return Value:

    None.

--*/


{

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if((*CurrentOpIrp)->CancelRoutine) 
	{
        SERIAL_DEC_REFERENCE(*CurrentOpIrp);

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    }

    if(IntervalTimer) 
	{

        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(IntervalTimer)) 
            SERIAL_DEC_REFERENCE(*CurrentOpIrp);
    }

    if(TotalTimer) 
	{

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(TotalTimer)) 
            SERIAL_DEC_REFERENCE(*CurrentOpIrp);

    }

}

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )

/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    pPort - Points to the serial device extension.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if(IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_WRITE)
	{
        pPort->TotalCharsQueued += IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length;
    } 
	else
	{
		if((IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_DEVICE_CONTROL)
			&& ((IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
            || (IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))) 
		{
			pPort->TotalCharsQueued++;
		}
	}

    if((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp))
    {
        //
        // There were no current operation.  Mark this one as current and start it up.
        //
        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(pPort);
	} 
	else 
	{
        //
        // We don't know how long the irp will be in the queue.  So we need to handle cancel.
        //
        if(Irp->Cancel) 
		{
            IoReleaseCancelSpinLock(oldIrql);

            Irp->IoStatus.Status = STATUS_CANCELLED;

			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp, 0);
            
			return STATUS_CANCELLED;

        } 
		else 
		{
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(QueueToExamine, &Irp->Tail.Overlay.ListEntry);
                
            IoSetCancelRoutine(Irp, SerialCancelQueued);
                
			SpxIRPCounter(pPort, Irp, IRP_QUEUED);	// Increment counter for performance stats.

            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;
        }
    }

}

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel Irps that currently reside on
    a queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

	SpxIRPCounter(pPort, Irp, IRP_DEQUEUED);	// Decrement counter for performance stats.

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued -= irpSp->Parameters.Write.Length;
    } 
	else
	{
		if(irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
		{
			//
			// If it's an immediate then we need to decrement the
			// count of chars queued.  If it's a resize then we
			// need to deallocate the pool that we're passing on
			// to the "resizing" routine.
			//

			if((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
				|| (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)) 
			{
				pPort->TotalCharsQueued--;
			} 
			else 
			{
				if(irpSp->Parameters.DeviceIoControl.IoControlCode ==IOCTL_SERIAL_SET_QUEUE_SIZE) 
				{
					//
					// We shoved the pointer to the memory into the
					// the type 3 buffer pointer which we KNOW we
					// never use.
					//

					ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					SpxFreeMem(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
				}
			}

		}
	}

    IoReleaseCancelSpinLock(Irp->CancelIrql);

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_SERIAL_INCREMENT);
  
}

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    if((pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pPort->ErrorWord) 
	{
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //
        if( (irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL)
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_SERIAL_GET_COMMSTATUS) ) 
		{
            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

	       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp, 0);
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\write.c ===
#include "precomp.h"			
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );



NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) 
	{
        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //
        return SerialStartOrQueue(pPort, Irp, &pPort->WriteQueue, &pPort->CurrentWriteIrp, SerialStartWrite);
    } 
	else 
	{
        Irp->IoStatus.Status = STATUS_SUCCESS;
       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, 0);
        return STATUS_SUCCESS;
    }

}

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    pPort - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

--*/

{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    do 
	{
        //
        // If there is an xoff counter then complete it.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if(pPort->CurrentXoffIrp) 
		{
            InsertHeadList(&pPort->WriteQueue,&pPort->CurrentWriteIrp->Tail.Overlay.ListEntry);
			SpxIRPCounter(pPort, pPort->CurrentWriteIrp, IRP_QUEUED);

            if(!SetFirstStatus) 
			{
                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            if(SERIAL_REFERENCE_COUNT(pPort->CurrentXoffIrp)) 
			{
                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

                pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

                //
                // The following call will actually release the cancel spin lock.
                //
                SerialTryToCompleteCurrent(	pPort,
											SerialGrabXoffFromIsr,
											OldIrql,
											STATUS_SERIAL_MORE_WRITES,
											&pPort->CurrentWriteIrp,
											&pPort->WriteQueue,
											NULL,
											&pPort->XoffCountTimer,
											SerialStartWrite,
											SerialGetNextWrite);
											
                return FirstStatus;

            } 
			else 
			{
                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

                return FirstStatus;
            }

        } 
		else 
		{
            IoReleaseCancelSpinLock(OldIrql);
        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

        Timeouts = pPort->Timeouts;

        KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

        if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier) 
		{
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
                                           
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading as a write.
            //
            TotalTime = RtlEnlargedUnsignedMultiply((IrpSp->MajorFunction == IRP_MJ_WRITE)?(IrpSp->Parameters.Write.Length):(1),
													Timeouts.WriteTotalTimeoutMultiplier);

            TotalTime = RtlLargeIntegerAdd(TotalTime, RtlConvertUlongToLargeInteger(Timeouts.WriteTotalTimeoutConstant));
            TotalTime = RtlExtendedIntegerMultiply(TotalTime, -10000);
        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //

        SERIAL_INIT_REFERENCE(pPort->CurrentWriteIrp);

        //
        // We need to see if this irp should be canceled.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        if(pPort->CurrentWriteIrp->Cancel) 
		{
            IoReleaseCancelSpinLock(OldIrql);
            pPort->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if(!SetFirstStatus) 
			{
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }

        } 
		else 
		{
            if(!SetFirstStatus) 
			{

                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(pPort->CurrentWriteIrp, SerialCancelCurrentWrite);
                
            SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

            if(UseATimer) 
			{

                KeSetTimer(&pPort->WriteRequestTotalTimer, TotalTime, &pPort->TotalWriteTimeoutDpc);

                //
                // This timer now has a reference to the irp.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);
            }

            KeSynchronizeExecution(pCard->Interrupt, SerialGiveWriteToIsr, pPort);
            IoReleaseCancelSpinLock(OldIrql);
            break;

        }

        //
        // Well the write was canceled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return FirstStatus;
}

VOID
SerialGetNextWrite(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

--*/

{
	PCARD_DEVICE_EXTENSION pCard = NULL;

    pPort = CONTAINING_RECORD(QueueToProcess, PORT_DEVICE_EXTENSION, WriteQueue);
	pCard = pPort->pParentCardExt;

    do 
	{
        //
        // We could be completing a flush.
        //
        if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_WRITE)
		{
            KIRQL OldIrql;

            ASSERT(pPort->TotalCharsQueued >= (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length));
                   
            IoAcquireCancelSpinLock(&OldIrql);
            pPort->TotalCharsQueued -= IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length;
            IoReleaseCancelSpinLock(OldIrql);
        } 
		else
		{
			if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
			{

				KIRQL OldIrql;

				IoAcquireCancelSpinLock(&OldIrql);

				//
				// If CurrentXoffIrp is not equal to null, this
				// implies that this is the "second" time around
				// for this irp, which implies that we should really
				// be completing it this time.
				//

				if (pPort->CurrentXoffIrp) 
				{
					pPort->CurrentXoffIrp = NULL;
					IoReleaseCancelSpinLock(OldIrql);
				} 
				else 
				{
					PIRP Irp = *CurrentOpIrp;

					PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

					//
					// We absolutely shouldn't have a cancel routine
					// at this point.
					//

					ASSERT(!Irp->CancelRoutine);

					//
					// This could only be a xoff counter masquerading as
					// a write irp.
					//

					pPort->TotalCharsQueued--;

					//
					// Check to see of the xoff irp has been set with success.
					// This means that the write completed normally.  If that
					// is the case, and it hasn't been set to cancel in the
					// meanwhile, then go on and make it the CurrentXoffIrp.
					//

					if(Irp->IoStatus.Status != STATUS_SUCCESS) 
					{

						//
						// Oh well, we can just finish it off.
						//
						NOTHING;

					} 
					else
					{
						if(Irp->Cancel) 
						{
							Irp->IoStatus.Status = STATUS_CANCELLED;
						} 
						else 
						{

							//
							// Give it a new cancel routine, and increment the
							// reference count because the cancel routine has
							// a reference to it.
							//

							IoSetCancelRoutine(Irp, SerialCancelCurrentXoff);

							SERIAL_INC_REFERENCE(Irp);

							//
							// We don't want to complete the current irp now.  This
							// will now get completed by the Xoff counter code.
							//
							CompleteCurrent = FALSE;

							//
							// Give the counter to the isr.
							//
							pPort->CurrentXoffIrp = Irp;
							KeSynchronizeExecution(pCard->Interrupt, SerialGiveXoffToIsr, pPort);                     
                        

							//
							// Start the timer for the counter and increment
							// the reference count since the timer has a
							// reference to the irp.
							//

							if(Xc->Timeout) 
							{
								KeSetTimer(&pPort->XoffCountTimer,
											RtlLargeIntegerNegate(RtlEnlargedUnsignedMultiply(10000,Xc->Timeout)),
											&pPort->XoffCountTimeoutDpc);

								SERIAL_INC_REFERENCE(Irp);
							}

						}
					}
				
					IoReleaseCancelSpinLock(OldIrql);

				}

			}
		}

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(pPort, CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent);
           
        if(!*NewIrp) 
		{
            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            KeSynchronizeExecution(pCard->Interrupt, SerialProcessEmptyTransmit, pPort);
            IoReleaseCancelSpinLock(OldIrql);
            break;

        } 
		else
		{
			if(IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction == IRP_MJ_FLUSH_BUFFERS)
			{

				//
				// If we encounter a flush request we just want to get
				// the next irp and complete the flush.
				//
				// Note that if NewIrp is non-null then it is also
				// equal to CurrentWriteIrp.
				//

				ASSERT((*NewIrp) == (*CurrentOpIrp));
				(*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
			} 
			else 
			{
				break;
			}
		}

    } while (TRUE);

}

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->IsrWaitMask && (pPort->IsrWaitMask & SERIAL_EV_TXEMPTY)
//	&& pPort->EmptiedTransmit
	&& (!pPort->TransmitImmediate) &&
        (!pPort->CurrentWriteIrp) && IsListEmpty(&pPort->WriteQueue)) {

        pPort->HistoryMask |= SERIAL_EV_TXEMPTY;
        if (pPort->IrpMaskLocation) {

            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            KeInsertQueueDpc(
                &pPort->CommWaitDpc,
                NULL,
                NULL
                );

        }

#if 0
        pPort->CountOfTryingToLowerRTS++;
        SerialPerhapsLowerRTS(pPort);
#endif
    }

    return FALSE;

}

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

    //
    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        pPort->WriteLength = IrpSp->Parameters.Write.Length;
        pPort->WriteCurrentChar =
            pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer;

    } else {

        pPort->WriteLength = 1;
        pPort->WriteCurrentChar =
            ((PUCHAR)pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer) +
            FIELD_OFFSET(
                SERIAL_XOFF_COUNTER,
                XoffChar
                );

    }

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

    //
    // Check first to see if an immediate char is transmitting.
    // If it is then we'll just slip in behind it when its
    // done.
    //

    if (!pPort->TransmitImmediate) {

        //
        // If there is no immediate char transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

// --------------------------------------------------- VIV  7/16/1993 begin
        if (pPort->HoldingEmpty) {
//            DISABLE_ALL_INTERRUPTS(pPort->Controller);
//            ENABLE_ALL_INTERRUPTS(pPort->Controller);
          Io8_EnableTxInterrupts(pPort);
        }
// --------------------------------------------------- VIV  7/16/1993 end
    }

#if 0
    //
    // The rts line may already be up from previous writes,
    // however, it won't take much additional time to turn
    // on the RTS line if we are doing transmit toggling.
    //

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(pPort);

    }
#endif

    return FALSE;

}

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    //

    if (pPort->WriteLength) {

        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if (IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)
            ->MajorFunction == IRP_MJ_WRITE) {

            pPort->CurrentWriteIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    pPort->CurrentWriteIrp
                    )->Parameters.Write.Length -
                pPort->WriteLength;

        } else {

            pPort->CurrentWriteIrp->IoStatus.Information = 0;

        }

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWriteIrp);

        pPort->WriteLength = 0;

    }

    return FALSE;

}

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->CountSinceXoff) {

        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        pPort->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentXoffIrp);

    }

    return FALSE;

}

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        OldIrql,
        STATUS_SERIAL_COUNTER_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PSERIAL_XOFF_COUNTER Xc =
        pPort->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    pPort->CountSinceXoff = Xc->Counter;

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\waitmask.c ===
#include "precomp.h"				
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    waitmask.c

Abstract:

    This module contains the code that is very specific to get/set/wait
    on event mask operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    );


NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/
{
    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SerialDump(SERDIAG3, ("SERIAL: In SerialStartMask\n"));
        
    ASSERT(pPort->CurrentMaskIrp);

    do 
	{
        SerialDump(SERDIAG4, ("SERIAL: STARMASK - CurrentMaskIrp: %x\n",pPort->CurrentMaskIrp));
            
        IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK) 
			|| (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK));

        if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK)
		{
            SerialDump(SERDIAG4, ("SERIAL - %x is a SETMASK irp\n",pPort->CurrentMaskIrp));

            //
            // Complete the old wait if there is one.
            //

            KeSynchronizeExecution(pCard->Interrupt, SerialFinishOldWait, pPort);

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!pPort->IrpMaskLocation);

            pPort->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if(!SetFirstStatus) 
			{

                SerialDump(
                    SERDIAG4,
                    ("SERIAL: %x was the first irp processed by this\n"
                     "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                    );

                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;
            }

            //
            // The following call will also cause the current
            // call to be completed.
            //

            SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                
            SerialDump(
                SERDIAG4,
                ("SERIAL: Perhaps another mask irp was found in the queue\n"
                 "------- %x/%x <- values should be the same\n",
                 pPort->CurrentMaskIrp,NewIrp)
                );


        } 
		else 
		{

            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be statisfied so it makes no sense to start it.
            //

            if((!pPort->IsrWaitMask) || (pPort->CurrentWaitIrp)) 
			{
                SerialDump(
                    SERDIAG4,
                    ("SERIAL: WaitIrp is invalid\n"
                     "------- IsrWaitMask: %x\n"
                     "------- CurrentWaitIrp: %x\n",
                     pPort->IsrWaitMask,
                     pPort->CurrentWaitIrp)
                    );

                pPort->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                if(!SetFirstStatus) 
				{
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x was the first irp processed by this\n"
                         "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                        );
                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;
                }

                SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                    
                SerialDump(
                    SERDIAG4,
                    ("SERIAL: Perhaps another mask irp was found in the queue\n"
                     "------- %x/%x <- values should be the same\n",
                     pPort->CurrentMaskIrp,NewIrp)
                    );
			} 
			else 
			{
                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be canceled
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if(pPort->CurrentMaskIrp->Cancel) 
				{
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x irp was already marked as cancelled\n",
                         pPort->CurrentMaskIrp)
                        );

                    IoReleaseCancelSpinLock(OldIrql);
                    pPort->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if(!SetFirstStatus) 
					{
                        SerialDump(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );

                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;
                    }

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                      
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                } 
				else 
				{

                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x will become the current wait irp\n",
                         pPort->CurrentMaskIrp)
                        );
                    
					if(!SetFirstStatus) 
					{
                        SerialDump(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );

                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(pPort->CurrentMaskIrp);
                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!pPort->IrpMaskLocation);
                    ASSERT(!pPort->CurrentWaitIrp);

                    pPort->CurrentWaitIrp = pPort->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(pPort->CurrentWaitIrp);
                    IoSetCancelRoutine(pPort->CurrentWaitIrp, SerialCancelWait);
                     

                    //
                    // Since the cancel routine has a reference to
                    // the irp we need to update the reference count.
                    //

                    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

                    KeSynchronizeExecution(pCard->Interrupt, SerialGiveWaitToIsr, pPort);
                        
                    IoReleaseCancelSpinLock(OldIrql);

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, FALSE);
                       
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3, ("SERIAL: In SerialGrabWaitFromIsr\n"));
        
    if(pPort->IrpMaskLocation) 
	{
        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWaitIrp);
    }

    return FALSE;
}


BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialGiveWaitToIsr\n")
        );
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!pPort->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

    if(!pPort->HistoryMask) 
	{
        SerialDump(
            SERDIAG4,
            ("SERIAL: No events occured prior to the wait call\n")
            );

        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        pPort->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        pPort->IrpMaskLocation = pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
           
        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

    } 
	else 
	{
        SerialDump(
            SERDIAG4,
            ("SERIAL: %x occurred prior to the wait - starting the\n"
             "------- completion code for %x\n",
             pPort->HistoryMask,pPort->CurrentWaitIrp)
            );

        *((ULONG *)pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer) 
			= pPort->HistoryMask;

        pPort->HistoryMask = 0;
        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        pPort->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

        KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
    
    }

    return FALSE;
}


BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3, ("SERIAL: In SerialFinishOldWait\n"));
    
	if(pPort->IrpMaskLocation) 
	{

        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );
        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

        KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
           
    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    pPort->HistoryMask &= *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);

    pPort->IsrWaitMask = *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);
                                            
    SerialDump(
        SERDIAG4,
        ("SERIAL: Set mask location of %x, in irp %x, with system buffer of %x\n",
         pPort->IrpMaskLocation,
         pPort->CurrentMaskIrp,pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer)
        );

    return FALSE;
}


VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERDIAG3, ("SERIAL: In SerialCancelWait\n"));

    SerialDump(
        SERDIAG4,
        ("SERIAL: Canceling wait for irp %x\n",pPort->CurrentWaitIrp)
        );

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWaitFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    SerialDump(SERDIAG3, ("SERIAL: In SerialCompleteWait\n"));

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialDump(
        SERDIAG4,
        ("SERIAL: Completing wait for irp %x\n",pPort->CurrentWaitIrp)
        );

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\esils.h ===
/************************************************************************/
/*																		*/
/*	Title:		Engineering Services Incident Log (ESIL)				*/
/*																		*/
/*	Author:		P.B Smith												*/
/*																		*/
/*	Version:	1.0.0 (I/O8+ NT Driver Version)							*/
/*																		*/
/*	Creation:	27th September 1998										*/
/*																		*/
/*	Description:	Contains descriptions and definitions of all		*/
/*					ESIL reports and modifications applied to the		*/
/*					I/O8+ NT Driver.									*/
/*																		*/
/************************************************************************/
#ifndef ESILS_H
#define ESILS_H

/* ESIL Log...
	
	ESIL		Date	 Author		Description
	====		====	 ======		=========== */





/* Temp fixes to be made into an ESIL */
#define SERENUM_FIX		
#define HYPERTERMINAL_FIX




#endif	// End of ESILS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\io8_card.h ===
#ifndef IO8_CARD_H
#define IO8_CARD_H	





//////////////////////////////////////////////////////////////////////////////////////////
// I/O8+ Card Device Extenstion.
// Information specific to I/O8+ card.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CARD_DEVICE_EXTENSION 
{

	COMMON_CARD_DEVICE_EXTENSION;	// Common Card Device Extension 
	
	ULONG CrystalFrequency;			// Frequency of onboard crystal

	PHYSICAL_ADDRESS	PCIConfigRegisters;
	ULONG				SpanOfPCIConfigRegisters;

} CARD_DEVICE_EXTENSION, *PCARD_DEVICE_EXTENSION;



//////////////////////////////////////////////////////////////////////////////////////////
// I/O8+ Port Device Extenstion.
// Information specific to I/O8+ Ports.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _PORT_DEVICE_EXTENSION 
{

	COMMON_PORT_DEVICE_EXTENSION;		// Common Card Device Extension 
	ULONG			SysPortNumber;		// System port number 
	
///////////////////////////////////////////////////////////////////
	UCHAR	ChannelNumber;

// THE ABOVE SHOULD NOT BE NEEDED - SHOULD USE PortNumber INSTEAD
///////////////////////////////////////////////////////////////////

#ifdef	CrystalFreqTest
	#define	CRYSTALFREQTEST_TX	1				// Begin transmit part of test 
	#define	CRYSTALFREQTEST_RX	2				// Begin receive part of test

    USHORT			CrystalFreqTest;			// Flag to indicate crystal frequency test 
    USHORT			CrystalFreqTestChars;		// Number of characters to test with 
    USHORT			CrystalFreqTestRxCount;		// Count of received characters 
    LARGE_INTEGER	CrystalFreqTestStartTime;	// Timestamp for beginning of test 
    LARGE_INTEGER	CrystalFreqTestStopTime;	// Timestamp for end of test 
#endif

	// Timing variables... 
    LARGE_INTEGER		IntervalTime;			// Read interval time 
	LARGE_INTEGER		ShortIntervalAmount;	// Short tread interval time 
	LARGE_INTEGER		LongIntervalAmount;		// Long read interval time 
	LARGE_INTEGER		CutOverAmount;			// Used to determine short/long interval time 
	LARGE_INTEGER		LastReadTime;			// System time of last read 
	PLARGE_INTEGER		IntervalTimeToUse;		// Interval timing delta time delay 


	// Queued IRP lists... 
	LIST_ENTRY		ReadQueue;		// Head of read IRP list, protected by cancel spinlock 
	LIST_ENTRY		WriteQueue;		// Head of write IRP list, protected by cancel spinlock 
	LIST_ENTRY		MaskQueue;		// Head of set/wait mask IRP list, protected by cancel spinlock 
	LIST_ENTRY		PurgeQueue;		// Head of purge IRP list, protected by cancel spinlock 


	// Current IRPs... 
	PIRP			CurrentReadIrp;			// Pointer to current read IRP 
	PIRP			CurrentWriteIrp;		// Pointer to current write IRP 
	PIRP			CurrentMaskIrp;			// Pointer to current mask IRP 
	PIRP			CurrentPurgeIrp;		// Pointer to current purge IRP 
	PIRP			CurrentWaitIrp;			// Pointer to current wait IRP 
	PIRP			CurrentImmediateIrp;	// Pointer to current send immediate IRP 
	PIRP			CurrentXoffIrp;			// Pointer to current XOFF_COUNTER IRP 

	// Write IRP variables... 
	ULONG			WriteLength;			// Write character count in current write IRP 
	PUCHAR			WriteCurrentChar;		// Pointer to write character in current write IRP 

	// Read IRP variables... 
	PUCHAR			InterruptReadBuffer;	// Read buffer current pointer in current read IRP 
	PUCHAR			ReadBufferBase;			// Read buffer base pointer in current read IRP 
	ULONG			CharsInInterruptBuffer;	// Characters read into read buffer 
//	KSPIN_LOCK		BufferLock;				// Spinlock protecting "CharsInInterruptBuffer" 
	PUCHAR			CurrentCharSlot;		// Pointer at space to store new read data 
	PUCHAR			LastCharSlot;			// Last valid position in read buffer 
	PUCHAR			FirstReadableChar;		// First read character in read buffer 
	ULONG			BufferSize;				// Read buffer size 
	ULONG			BufferSizePt8;			// 80% read buffer size 
	ULONG			NumberNeededForRead;	// Number of characters requested in current read IRP 


	// Mask IRP variables... 
	ULONG			IsrWaitMask;		// Wait mask in current wait IRP 
	ULONG			HistoryMask;		// History of masked events 
	ULONG			*IrpMaskLocation;	// Pointer to mask location 


	// Serial port configuration...
	ULONG				CurrentBaud;		// Current baud rate 
	ULONG				SupportedBauds;		// Bitmask defining supported baud rates 
	SERIAL_HANDFLOW		HandFlow;			// Current handshaking and flow control settings 
	UCHAR				LineControl;		// Current parity,databits,stopbits 
	SERIAL_CHARS		SpecialChars;		// Current Special error/replacement characters 
	SERIAL_TIMEOUTS		Timeouts;			// Read and write timeouts 
	UCHAR				ValidDataMask;		// Read data mask 
	UCHAR				EscapeChar;			// Escape character used with line/modem status strings 
	BOOLEAN				InsertEscChar;		// Indicates of EscapeChar should be inserted 


	// Serial port status... 
	LONG			CountSinceXoff;			// Nun chars read since XOFF counter started 
	ULONG			CountOfTryingToLowerRTS;// Count of processes trying to lower RTS 
	BOOLEAN			TransmitImmediate;		// Indicates of transmit immediate is pending 
	BOOLEAN			EmptiedTransmit;		// Indicates transmit empty 
	UCHAR			ImmediateChar;			// Character to be transmitted immediately 
	ULONG			TXHolding;				// Reasons for transmit blocked 
	ULONG			RXHolding;				// Reasons for receive blocked 
	ULONG			ErrorWord;				// Error conditions 
	ULONG			TotalCharsQueued;		// Total number of queued characters in all write IRPs 
	LONG			CountOnLastRead;		// Number of chars read last time interval timer DPC ran 
	ULONG			ReadByIsr;				// Number of characters read during ISR 

	KSPIN_LOCK		ControlLock;			// Used to protect certain fields 


	// Deferred procedure calls... 
	KDPC		CompleteWriteDpc;			// DPC used to complete write IRPs 
	KDPC		CompleteReadDpc;			// DPC used to complete read IRPs 
	KDPC		TotalReadTimeoutDpc;		// DPC used to handle read total timeout 
	KDPC		IntervalReadTimeoutDpc;		// DPC used to handle read interval timeout 
	KDPC		TotalWriteTimeoutDpc;		// DPC used to handle write total timeout 
	KDPC		CommErrorDpc;				// DPC used to handle cancel on error 
	KDPC		CommWaitDpc;				// DPC used to handle waking IRPs waiting on an event 
	KDPC		CompleteImmediateDpc;		// DPC used to handle transmitting an immediate character 
	KDPC		TotalImmediateTimeoutDpc;	// DPC used to handle immediate char timeout 
	KDPC		XoffCountTimeoutDpc;		// DPC used to handle XOFF_COUNT timeout 
	KDPC		XoffCountCompleteDpc;		// DPC used to complete XOFF_COUNT IRP 
	KDPC		StartTimerLowerRTSDpc;		// DPC used to check for RTS lowering 
	KDPC		PerhapsLowerRTSDpc;			// DPC used to check for RTS lowering 

	// Timers... 
	KTIMER		ReadRequestTotalTimer;		// Timer used to handle total read request timeout 
	KTIMER		ReadRequestIntervalTimer;	// Timer used to handle interval read timeout 
	KTIMER		WriteRequestTotalTimer;		// Timer used to handle total write request timeout 
	KTIMER		ImmediateTotalTimer;		// Timer used to handle send immediate timeout 
	KTIMER		XoffCountTimer;				// Timer used to handle XOFF_COUNT timeout 
	KTIMER		LowerRTSTimer;				// Timer used to handle lower RTS timing 




    // Set at intialization to indicate that on the current
    // architecture we need to unmap the base register address
    // when we unload the driver.
    BOOLEAN UnMapRegisters;

    // Set at intialization to indicate that on the current
    // architecture we need to unmap the interrupt status address
    // when we unload the driver.
    BOOLEAN UnMapStatus;


    // This is only accessed at interrupt level.  It keeps track
    // of whether the holding register is empty.
    // Really it keeps track whether Tx interrupts were Disabled or not.
    BOOLEAN HoldingEmpty;


#define BREAK_START 1
#define BREAK_END   2

    BOOLEAN DoBreak;

    // This simply indicates that the port associated with this
    // extension is part of a multiport card.
    BOOLEAN PortOnAMultiportCard;

    // These two booleans are used to indicate to the isr transmit
    // code that it should send the xon or xoff character.  They are
    // only accessed at open and at interrupt level.
    BOOLEAN SendXonChar;
    BOOLEAN SendXoffChar;

    // This boolean will be true if a 16550 is present *and* enabled.
    BOOLEAN FifoPresent;


} PORT_DEVICE_EXTENSION, *PPORT_DEVICE_EXTENSION;











// PORT_DEVICE_EXTENSION.CountOnLastRead definitions... 
#define		SERIAL_COMPLETE_READ_CANCEL		((LONG)-1)
#define		SERIAL_COMPLETE_READ_TOTAL		((LONG)-2)
#define		SERIAL_COMPLETE_READ_COMPLETE	((LONG)-3)

// PORT_DEVICE_EXTENSION.LineControl definitions... 
#define		SERIAL_5_DATA		((UCHAR)0x00)
#define		SERIAL_6_DATA		((UCHAR)0x01)
#define		SERIAL_7_DATA		((UCHAR)0x02)
#define		SERIAL_8_DATA		((UCHAR)0x03)
#define		SERIAL_DATA_MASK	((UCHAR)0x03)

#define		SERIAL_1_STOP		((UCHAR)0x00)
#define		SERIAL_1_5_STOP		((UCHAR)0x04) // Only valid for 5 data bits
#define		SERIAL_2_STOP		((UCHAR)0x04) // Not valid for 5 data bits
#define		SERIAL_STOP_MASK	((UCHAR)0x04)

#define		SERIAL_NONE_PARITY	((UCHAR)0x00)
#define		SERIAL_ODD_PARITY	((UCHAR)0x08)
#define		SERIAL_EVEN_PARITY	((UCHAR)0x18)
#define		SERIAL_MARK_PARITY	((UCHAR)0x28)
#define		SERIAL_SPACE_PARITY	((UCHAR)0x38)
#define		SERIAL_PARITY_MASK	((UCHAR)0x38)
#define		SERIAL_LCR_BREAK	0x40


// PORT_DEVICE_EXTENSION.SpecialChars default xon/xoff characters... 
#define		SERIAL_DEF_XON		0x11
#define		SERIAL_DEF_XOFF		0x13

// PORT_DEVICE_EXTENSION.TXHolding definitions... 
#define		SERIAL_TX_CTS		((ULONG)0x01)
#define		SERIAL_TX_DSR		((ULONG)0x02)
#define		SERIAL_TX_DCD		((ULONG)0x04)
#define		SERIAL_TX_XOFF		((ULONG)0x08)
#define		SERIAL_TX_BREAK		((ULONG)0x10)

// PORT_DEVICE_EXTENSION.RXHolding definitions...
#define		SERIAL_RX_DTR		((ULONG)0x01)
#define		SERIAL_RX_XOFF		((ULONG)0x02)
#define		SERIAL_RX_RTS		((ULONG)0x04)
#define		SERIAL_RX_DSR		((ULONG)0x08)	
#define		SERIAL_RX_FULL      ((ULONG)0x10)   // VIV: If Io8 Rx queue is full.

// PORT_DEVICE_EXTENSION.LastStatus definitions... 
#define		SERIAL_LSR_DR       0x01
#define		SERIAL_LSR_OE		0x02
#define		SERIAL_LSR_PE		0x04
#define		SERIAL_LSR_FE		0x08
#define		SERIAL_LSR_BI		0x10

// 16550 Modem Control Register definitions... 
#define		SERIAL_MCR_DTR		0x01
#define		SERIAL_MCR_RTS		0x02

// 16550 Modem Status Register definitions... 
#define		SERIAL_MSR_DCTS		0x01
#define		SERIAL_MSR_DDSR		0x02
#define		SERIAL_MSR_TERI		0x04
#define		SERIAL_MSR_DDCD		0x08
#define		SERIAL_MSR_CTS		0x10
#define		SERIAL_MSR_DSR		0x20
#define		SERIAL_MSR_RI		0x40
#define		SERIAL_MSR_DCD		0x80



// These masks define the interrupts that can be enabled or disabled.
//
// This interrupt is used to notify that there is new incomming
// data available.  The SERIAL_RDA interrupt is enabled by this bit.
#define SERIAL_IER_RDA   0x01


// This interrupt is used to notify that there is space available
// in the transmitter for another character.  The SERIAL_THR
// interrupt is enabled by this bit.
#define SERIAL_IER_THR   0x02

// This interrupt is used to notify that some sort of error occured
// with the incomming data.  The SERIAL_RLS interrupt is enabled by
// this bit.
#define SERIAL_IER_RLS   0x04

// This interrupt is used to notify that some sort of change has
// taken place in the modem control line.  The SERIAL_MS interrupt is
// enabled by this bit.
#define SERIAL_IER_MS    0x08


// These masks define the values of the interrupt identification
// register.  The low bit must be clear in the interrupt identification
// register for any of these interrupts to be valid.  The interrupts
// are defined in priority order, with the highest value being most
// important.  See above for a description of what each interrupt
// implies.
#define SERIAL_IIR_RLS      0x06
#define SERIAL_IIR_RDA      0x04
#define SERIAL_IIR_CTI      0x0c
#define SERIAL_IIR_THR      0x02
#define SERIAL_IIR_MS       0x00


// This bit mask get the value of the high two bits of the
// interrupt id register.  If this is a 16550 class chip
// these bits will be a one if the fifo's are enbled, otherwise
// they will always be zero.
#define SERIAL_IIR_FIFOS_ENABLED 0xc0

// If the low bit is logic one in the interrupt identification register
// this implies that *NO* interrupts are pending on the device.
#define SERIAL_IIR_NO_INTERRUPT_PENDING 0x01




// These masks define access to the fifo control register.

// Enabling this bit in the fifo control register will turn
// on the fifos.  If the fifos are enabled then the high two
// bits of the interrupt id register will be set to one.  Note
// that this only occurs on a 16550 class chip.  If the high
// two bits in the interrupt id register are not one then
// we know we have a lower model chip.
#define SERIAL_FCR_ENABLE     0x01
#define SERIAL_FCR_RCVR_RESET 0x02
#define SERIAL_FCR_TXMT_RESET 0x04


// This set of values define the high water marks (when the
// interrupts trip) for the receive fifo.
#define SERIAL_1_BYTE_HIGH_WATER   0x00
#define SERIAL_4_BYTE_HIGH_WATER   0x40
#define SERIAL_8_BYTE_HIGH_WATER   0x80
#define SERIAL_14_BYTE_HIGH_WATER  0xc0


// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
#define SERIAL_LCR_DLAB     0x80


// This bit is used for general purpose output.
#define SERIAL_MCR_OUT1     0x04

// This bit is used for general purpose output.
#define SERIAL_MCR_OUT2     0x08

// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
#define SERIAL_MCR_LOOP     0x10


// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
#define SERIAL_LSR_THRE     0x20


// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
#define SERIAL_LSR_TEMT     0x40


// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
#define SERIAL_LSR_FIFOERR  0x80


//
// This should be more than enough space to hold then
// numeric suffix of the device name.
//
#define DEVICE_NAME_DELTA 20


//
// Up to 16 Ports Per card.  However for sixteen
// port cards the interrupt status register must be
// the indexing kind rather then the bitmask kind.
//
#define SERIAL_MAX_PORTS_INDEXED      (16)
#define SERIAL_MAX_PORTS_NONINDEXED   (8)
















//---------------------------------------------------- VIV  8/5/1993 begin 
#if 0

//
// Sets the divisor latch register.  The divisor latch register
// is used to control the baud rate of the 8250.
//
// As with all of these routines it is assumed that it is called
// at a safe point to access the hardware registers.  In addition
// it also assumes that the data is correct.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// DesiredDivisor - The value to which the divisor latch register should
//                  be set.
//
#define WRITE_DIVISOR_LATCH(BaseAddress,DesiredDivisor)           \
do                                                                \
{                                                                 \
    PUCHAR Address = BaseAddress;                                 \
    SHORT Divisor = DesiredDivisor;                               \
    UCHAR LineControl;                                            \
    LineControl = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER); \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)                    \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_LSB,                                \
        (UCHAR)(Divisor & 0xff)                                   \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_MSB,                                \
        (UCHAR)((Divisor & 0xff00) >> 8)                          \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        LineControl                                               \
        );                                                        \
} while (0)

//
// Reads the divisor latch register.  The divisor latch register
// is used to control the baud rate of the 8250.
//
// As with all of these routines it is assumed that it is called
// at a safe point to access the hardware registers.  In addition
// it also assumes that the data is correct.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// DesiredDivisor - A pointer to the 2 byte word which will contain
//                  the value of the divisor.
//
#define READ_DIVISOR_LATCH(BaseAddress,PDesiredDivisor)           \
do                                                                \
{                                                                 \
    PUCHAR Address = BaseAddress;                                 \
    PSHORT PDivisor = PDesiredDivisor;                            \
    UCHAR LineControl;                                            \
    UCHAR Lsb;                                                    \
    UCHAR Msb;                                                    \
    LineControl = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER); \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)                    \
        );                                                        \
    Lsb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_LSB);             \
    Msb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_MSB);             \
    *PDivisor = Lsb;                                              \
    *PDivisor = *PDivisor | (((USHORT)Msb) << 8);                 \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        LineControl                                               \
        );                                                        \
} while (0)

//
// This macro reads the interrupt enable register.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
#define READ_INTERRUPT_ENABLE(BaseAddress)                     \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_ENABLE_REGISTER))

//
// This macro writes the interrupt enable register.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Values - The values to write to the interrupt enable register.
//
#define WRITE_INTERRUPT_ENABLE(BaseAddress,Values)                \
do                                                                \
{                                                                 \
    WRITE_PORT_UCHAR(                                             \
        BaseAddress+INTERRUPT_ENABLE_REGISTER,                    \
        Values                                                    \
        );                                                        \
} while (0)

//
// This macro disables all interrupts on the hardware.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define DISABLE_ALL_INTERRUPTS(BaseAddress)       \
do                                                \
{                                                 \
    WRITE_INTERRUPT_ENABLE(BaseAddress,0);        \
} while (0)

//
// This macro enables all interrupts on the hardware.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define ENABLE_ALL_INTERRUPTS(BaseAddress)        \
do                                                \
{                                                 \
                                                  \
    WRITE_INTERRUPT_ENABLE(                       \
        (BaseAddress),                            \
        (UCHAR)(SERIAL_IER_RDA | SERIAL_IER_THR | \
                SERIAL_IER_RLS | SERIAL_IER_MS)   \
        );                                        \
                                                  \
} while (0)

//
// This macro reads the interrupt identification register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Note that this routine potententially quites a transmitter
// empty interrupt.  This is because one way that the transmitter
// empty interrupt is cleared is to simply read the interrupt id
// register.
//
//
#define READ_INTERRUPT_ID_REG(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_IDENT_REGISTER))

//
// This macro reads the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_CONTROL(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_CONTROL_REGISTER))

//
// This macro reads the modem status register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_STATUS(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_STATUS_REGISTER))

//
// This macro reads a value out of the receive buffer
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_RECEIVE_BUFFER(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+RECEIVE_BUFFER_REGISTER))

//
// This macro reads the line status register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_LINE_STATUS(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+LINE_STATUS_REGISTER))

//
// This macro writes the line control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define WRITE_LINE_CONTROL(BaseAddress,NewLineControl)           \
do                                                               \
{                                                                \
    WRITE_PORT_UCHAR(                                            \
        (BaseAddress)+LINE_CONTROL_REGISTER,                     \
        (NewLineControl)                                         \
        );                                                       \
} while (0)

//
// This macro reads the line control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_LINE_CONTROL(BaseAddress)           \
    (READ_PORT_UCHAR((BaseAddress)+LINE_CONTROL_REGISTER))


//
// This macro writes to the transmit register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// TransmitChar - The character to send down the wire.
//
//
#define WRITE_TRANSMIT_HOLDING(BaseAddress,TransmitChar)       \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+TRANSMIT_HOLDING_REGISTER,               \
        (TransmitChar)                                         \
        );                                                     \
} while (0)

//
// This macro writes to the control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ControlValue - The value to set the fifo control register too.
//
//
#define WRITE_FIFO_CONTROL(BaseAddress,ControlValue)           \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+FIFO_CONTROL_REGISTER,                   \
        (ControlValue)                                         \
        );                                                     \
} while (0)

//
// This macro writes to the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ModemControl - The control bits to send to the modem control.
//
//
#define WRITE_MODEM_CONTROL(BaseAddress,ModemControl)          \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+MODEM_CONTROL_REGISTER,                  \
        (ModemControl)                                         \
        );                                                     \
} while (0)

#endif
//---------------------------------------------------- VIV  8/5/1993 end



#endif // End of IO8_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\io8_defs.h ===
#ifndef	IO8_DEFS_H
#define IO8_DEFS_H


// File IDs for Event Logging (top 8 bits only).
#define IO8_PNP_C		((ULONG)0x010000)
#define IO8_W2K_C		((ULONG)0x020000)

#define PRODUCT_MAX_PORTS		8

// Port Types.
#define IO8_RJ12				1

// Port device object name.
#define PORT_PDO_NAME_BASE		L"\\Device\\IO8Port"

// Tag used for memory allocations (must be 4 bytes in reverse).
#define MEMORY_TAG				'+8OI'

// Old debug stuff
#if DBG
#define SERDIAG1              ((ULONG)0x00000001)
#define SERDIAG2              ((ULONG)0x00000002)
#define SERDIAG3              ((ULONG)0x00000004)
#define SERDIAG4              ((ULONG)0x00000008)
#define SERDIAG5              ((ULONG)0x00000010)
#define SERFLOW               ((ULONG)0x20000000)
#define SERERRORS             ((ULONG)0x40000000)
#define SERBUGCHECK           ((ULONG)0x80000000)
extern ULONG SpxDebugLevel;

#define SerialDump(LEVEL,STRING)			\
        do {								\
            if (SpxDebugLevel & LEVEL) {	\
                DbgPrint STRING;			\
            }								\
            if (LEVEL == SERBUGCHECK) {		\
                ASSERT(FALSE);				\
            }								\
        } while (0)
#else
#define SerialDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


// I/O8+ HardwareIDs
#define IO8_ISA_HWID	L"SPX_IO8001"								// I/O8+ ISA card.
#define IO8_PCI_HWID	L"PCI\\VEN_11CB&DEV_2000&SUBSYS_B00811CB"	// I/O8+ PCI card.

//I/O8+ CardTypes
#define Io8Isa		0
#define Io8Pci		1


// Bus Types
#define BUSTYPE_ISA		0x00000001
#define	BUSTYPE_MCA		0x00000002
#define	BUSTYPE_EISA	0x00000004
#define	BUSTYPE_PCI		0x00000008		

/*****************************************************************************
***********************************   PCI   **********************************
*****************************************************************************/
// General definitions... 

#define		PLX_VENDOR_ID		0x10B5			// PLX test board vendor ID
#define		PLX_DEVICE_ID		0x9050			// PLX test board device ID 

#define		SPX_VENDOR_ID		0x11CB			// Assigned by the PCI SIG 
#define		SPX_PLXDEVICE_ID	0x2000			// PLX 9050 Bridge 

#define		SPX_SUB_VENDOR_ID	SPX_VENDOR_ID	// Same as vendor id 
#define		IO8_SUB_SYS_ID		0xB008			// Phase 2 (Z280) board



#endif	// End of IO8_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\io8_nt.h ===
/***************************************************************************\
*                                                                           *
*     IO8_NT.H    -   IO8+ Intelligent I/O Board driver                     *
*                                                                           *
*     Copyright (c) 1992-1993 Ring Zero Systems, Inc.                       *
*     All Rights Reserved.                                                  *
*                                                                           *
\***************************************************************************/
#ifndef IO8_NT_H
#define IO8_NT_H


/*
** Numbers of this and that in system
*/
#define	MAX_HOSTS		4
#define PORTS_PER_HOST	8
#define	MAX_PORTS		(MAX_HOSTS*PORTS_PER_HOST)

/*
** Ident byte. This is splattered across the DSR lines
** at all times.
*/
#define	IDENT		0x4D
#define	IDENTPCI	0xB2

/*
** Idle state of Global Service Vector
*/
#define	GSV_IDLE	0xFF

/*
** To enable/disable interrupts, write these values to the
** ADDRESS register.
*/
#define	INTENB		0x80
#define	INTDIS		0x00

/*
** CD1864 register stuff
*/
#define	GLOBAL		0x80
#define	CHANNEL		0x00

#define	SENDBREAK	0x81
#define	SENDDELAY	0x82
#define	STOPBREAK	0x83

/*
**  Definitions of all the registers that can appear on
**  the card. These are the CD1864 registers. High bit is set
**  to enable interrupts
*/
#define CCR			0x81	// Channel Command Register 
#define SRER		0x82	// Service Request Enable Register 
#define COR1		0x83	// Channel Option Register 1 
#define COR2		0x84	// Channel Option Register 2 
#define COR3		0x85	// Channel Option Register 3 
#define CCSR		0x86	// Channel Control Status Register 
#define RDCR		0x87	// Receive Data Count Register 
#define SCHR1		0x89	// Special Character Register 1 
#define SCHR2		0x8a	// Special Character Register 2 
#define SCHR3		0x8b	// Special Character Register 3 
#define SCHR4		0x8c	// Special Character Register 4 
#define MCOR1		0x90	// Modem Change Option Register 1 
#define MCOR2		0x91	// Modem Change Option Register 2 
#define MDCR		0x92	// Modem Change Register 
#define RTPR		0x98	// Receive Timeout Period Register 
#define MSVR		0xA8	// Modem Signal Value Register 
#define MSVRTS		0xA9	// Modem Signal Value-Request to Send 
#define MSVDTR		0xAa	// Modem Signal Value-Data Terminal Ready 
#define RBPRH		0xB1	// Receive Bit Rate Period Register High 
#define RBPRL		0xB2	// Receive Bit Rate Period Register Low 
#define RBR			0xB3	// Receiver Bit Register 
#define TBPRH		0xB9	// Transmit Bit Rate Period Register High 
#define TBPRL		0xBa	// Transmit Bit Rate Period Register Low 
#define GSVR		0xC0	// Global Service Vector Register 
#define GSCR1		0xC1	// Global Service Channel Register 1 
#define GSCR2		0xC2	// Global Service Channel Register 2 
#define GSCR3		0xC3	// Global Service Channel Register 3 
#define MSMR		0xE1	// Modem Service Match Register 
#define TSMR		0xE2	// Transmit Service Match Register 
#define RSMR		0xE3	// Receive Service Match Register 
#define CAR			0xE4	// Channel Access Register 
#define SRSR		0xE5	// Service Request Status Register 
#define SRCR		0xE6	// Service Request Configuration Register 
#define GFRCR		0xEb	// Global Firmware Revision Code Register 
#define PPRH		0xF0	// Prescaler Period Register High 
#define PPRL		0xF1	// Prescaler Period Register Low 
#define MRAR		0xF5	// Modem Request Acknowledge Register 
#define TRAR		0xF6	// Transmit Request Acknowledge Register 
#define RRAR		0xF7	// Receive Request Acknowledge Register 
#define RDR			0xF8	// Receiver Data Register 
#define RCSR		0xFa	// Receiver Character Status Register 
#define TDR			0xFb	// Transmit Data Register 
#define EOSRR		0xFf	// End of Service Request Register 

/* commands */
#define CHIP_RESET			0x81
#define CHAN_RESET			0x80
#define COR1_CHANGED		0x42
#define COR2_CHANGED		0x44
#define COR3_CHANGED		0x48
#define TXMTR_ENABLE		0x18
#define TXMTR_DISABLE		0x14
#define RCVR_ENABLE			0x12
#define RCVR_DISABLE		0x11
#define LLM_MODE			0x10	// Local Loopback Mode 
#define NO_LOOPBACK			0x00

/* register values */
#define	MSVR_DSR			0x80
#define	MSVR_CD				0x40
#define	MSVR_CTS			0x20
#define	MSVR_DTR			0x02
#define	MSVR_RTS			0x01
	
#define SRER_CONFIG			0xF9

#define	SRER_DSR			0x80
#define	SRER_CD				0x40
#define	SRER_CTS			0x20
#define	SRER_RXDATA			0x10
#define	SRER_RXSC			0x08
#define	SRER_TXRDY			0x04
#define	SRER_TXMPTY			0x02
#define	SRER_NNDT			0x01

#define	CCR_RESET_SOFT		0x80
#define	CCR_RESET_HARD		0x81
#define	CCR_CHANGE_COR1		0x42
#define	CCR_CHANGE_COR2		0x44
#define	CCR_CHANGE_COR3		0x48
#define	CCR_SEND_SC1		0x21
#define	CCR_SEND_SC2		0x22
#define	CCR_SEND_SC3		0x23
#define	CCR_SEND_SC4		0x24
#define	CCR_CTRL_RXDIS		0x11
#define	CCR_CTRL_RXEN		0x12
#define	CCR_CTRL_TXDIS		0x14
#define	CCR_CTRL_TXEN		0x18

#define	SRCR_REG_ACK_EN		0x40
#define	SRCR_REG_ACK_DIS	0x00

#define	COR1_NO_PARITY		0x00		// 000 
#define	COR1_ODD_PARITY		0xC0		// 110 
#define	COR1_EVEN_PARITY	0x40		// 010 
#define	COR1_IGN_PARITY		0x10
#define	COR1_MARK_PARITY	0xA0		// 101XXXXX 
#define	COR1_SPACE_PARITY	0x20		// 001XXXXX 
#define	COR1_1_STOP			0x00
#define	COR1_1_HALF_STOP	0x04
#define	COR1_2_STOP			0x08
#define	COR1_2_HALF_STOP	0x0C
#define	COR1_5_BIT			0x00
#define	COR1_6_BIT			0x01
#define	COR1_7_BIT			0x02
#define	COR1_8_BIT			0x03

#define	COR2_IXM			0x80
#define	COR2_TXIBE			0x40
#define	COR2_ETC			0x20
#define	COR2_LLM			0x10
#define	COR2_RLM			0x08
#define	COR2_RTSAO			0x04
#define	COR2_CTSAE			0x02
#define	COR2_DSRAE			0x01

#define	COR3_XONCD			0x80
#define	COR3_XOFFCD			0x40
#define	COR3_FCTM			0x20
#define	COR3_SCDE			0x10
#define	COR3_RXFIFO1		0x01
#define	COR3_RXFIFO2		0x02
#define	COR3_RXFIFO3		0x03
#define	COR3_RXFIFO4		0x04
#define	COR3_RXFIFO5		0x05
#define	COR3_RXFIFO6		0x06
#define	COR3_RXFIFO7		0x07
#define	COR3_RXFIFO8		0x08

#define	MCOR1_DSRZD			0x80
#define	MCOR1_CDZD			0x40
#define	MCOR1_CTSZD			0x20
#define MCOR1_NO_DTR		0x00
#define	MCOR1_DTR_THR_1		0x01
#define	MCOR1_DTR_THR_2		0x02
#define	MCOR1_DTR_THR_3		0x03
#define	MCOR1_DTR_THR_4		0x04
#define	MCOR1_DTR_THR_5		0x05
#define	MCOR1_DTR_THR_6		0x06
#define	MCOR1_DTR_THR_7		0x07
#define	MCOR1_DTR_THR_8		0x08

#define	MCOR2_DSROD			0x80
#define	MCOR2_CDOD			0x40
#define	MCOR2_CTSOD			0x20

#define	RCSR_TIMEOUT		0x80
#define	RCSR_SCD_MASK		0x70
#define	RCSR_SCD1			0x10
#define	RCSR_SCD2			0x20
#define RCSR_SCD3			0x30
#define RCSR_SCD4			0x40
#define	RCSR_BREAK			0x08
#define	RCSR_PARITY			0x04
#define	RCSR_FRAME			0x02
#define	RCSR_OVERRUN		0x01

#define	SRSR_ILVL_NONE		0x00
#define	SRSR_ILVL_RECV		0xC0
#define	SRSR_ILVL_TXMT		0x80
#define SRSR_ILVL_MODEM		0x40
#define	SRSR_IREQ3_MASK		0x30
#define	SRSR_IREQ3_EXT		0x20
#define	SRSR_IREQ3_INT		0x10
#define	SRSR_IREQ2_MASK		0x0C
#define	SRSR_IREQ2_EXT		0x08
#define	SRSR_IREQ2_INT		0x04
#define	SRSR_IREQ1_MASK		0x03
#define	SRSR_IREQ1_EXT		0x02
#define	SRSR_IREQ1_INT		0x01

//---------------------------------------------------- VIV  7/21/1993 begin
#define	MDCR_DDSR			0x80
#define	MDCR_DDCD			0x40
#define	MDCR_DCTS			0x20
//---------------------------------------------------- VIV  7/21/1993 end

typedef	unsigned char BYTE;
typedef	unsigned short WORD;
typedef	unsigned int DWORD;

typedef struct Io8Host
{
	int Address;	    // base address of card 
	int Interrupt;
	BYTE CurrentReg;	// last used register 
} Io8Host;


typedef struct Io8Port
{
	int	RxThreshold;	// how many characters to Rx before interrupt 
	int	RxTimeout;		// timeout(ms) before we timeout the read fifo
	int	IxAny;		    // is IxAny enabled? 
	char open_state;	// indicates if modem or local device open 
	char break_state;	// no break/ about to send break/ sent break 
} Io8Port;


#define IO8_LOCAL		0x01
#define IO8_MODEM		0x02

#define NO_BREAK		0x00
#define SEND_BREAK		0x01
#define BREAK_STARTED	0x02

extern	struct	tty io8__ttys[];

/*
** debug print macro
*/
#define DEBUG(x)	if (io8_debug>=x) printf

#ifndef TIOC
#define TIOC ('T'<<8)
#endif

#define	TCIO8DEBUG	(TIOC + 96)	
#define TCIO8PORTS	(TIOC + 107)
#define	TCIO8IXANY	(TIOC + 108)
#define	TCIO8GIXANY	(TIOC + 109)

/*   
** macros to get card number/ channel number from device
*/
#define GET_CARD(x) (((x) & 0x18)>>3)
#define GET_CHANNEL(x) ((x) & 0x7)

/*
** receive buffer threshold - interrupt when this is reached.
*/
#define RX_THRESHOLD	5

/*
** direct write defines - BUFF_MASK must be 1 less than BUFF_SIZE
*/
#define BUFF_SIZE		1024	
#define BUFF_MASK		1023
#define LOW_WATER		256
#define OP_DIRECT		1
#define OP_ONLCR_DIRECT	2

struct direct_buffer
{
	unsigned char	direct_possible,
	dir_in_progress;
	int		buff_in,
	buff_out;
	char io8_buff[BUFF_SIZE];
};


/*
** card details structure - this defines the structure which is patched at
** install time
*/
struct io8
{
	short vect;
	short addr;
};




#endif	// End of IO8_NT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\io8_proto.h ===
//////////////////////////////////////////////////////////////////
// Prototypes and macros that are used throughout the driver. 
//////////////////////////////////////////////////////////////////
#ifndef IO8_PROTO_H
#define IO8_PROTO_H


VOID DriverUnload(IN PDRIVER_OBJECT pDriverObject);

BOOLEAN Io8_Present(IN PVOID Context);
BOOLEAN Io8_ResetBoard(IN PVOID Context);
BOOLEAN Io8_ResetChannel(IN PVOID Context);
VOID    Io8_EnableAllInterrupts(IN PVOID Context);

BOOLEAN Io8_SetDTR(IN PVOID Context);
BOOLEAN Io8_ClearDTR(IN PVOID Context);

BOOLEAN Io8_Interrupt(IN PVOID Context);

BOOLEAN Io8_SwitchCardInterrupt(IN PVOID Context);

BOOLEAN	Io8_TestCrystal(IN PVOID Context);

BOOLEAN Io8_SetBaud(IN PVOID Context);
BOOLEAN Io8_SetLineControl(IN PVOID Context);
BOOLEAN Io8_SendXon(IN PVOID Context);
BOOLEAN Io8_SetFlowControl(IN PVOID Context);
VOID    Io8_SetChars(IN PVOID Context);

VOID    Io8_EnableTxInterrupts(IN PVOID Context);
VOID    Io8_EnableRxInterrupts(IN PVOID Context);
VOID    Io8_DisableRxInterrupts(IN PVOID Context);
VOID    Io8_DisableRxInterruptsNoChannel(IN PVOID Context);
VOID    Io8_DisableAllInterrupts(IN PVOID Context);

BOOLEAN Io8_TurnOnBreak(IN PVOID Context);
BOOLEAN Io8_TurnOffBreak(IN PVOID Context);

UCHAR   Io8_GetModemStatus(IN PVOID Context);
ULONG   Io8_GetModemControl(IN PVOID Context);

VOID    Io8_Simulate_Xon(IN PVOID Context);

typedef	struct	_SETBAUD
{
	PPORT_DEVICE_EXTENSION	pPort;
	ULONG					Baudrate;
	BOOLEAN					Result;

} SETBAUD, *PSETBAUD;



#endif	// End of IO8_PROTO.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\spx_card.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//  Card and Port device extension structures.
// 
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_CARD_H
#define SPX_CARD_H	

typedef	struct _CARD_DEVICE_EXTENSION *PCARD_DEV_EXT;
typedef	struct _PORT_DEVICE_EXTENSION *PPORT_DEV_EXT;

//////////////////////////////////////////////////////////////////////////////////////////
// Common header for all the device extensions 
// Common to all the PDOs and FDOs (cards and ports).
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_OBJECT_DATA
{
    PDEVICE_OBJECT	DeviceObject;			// A backpointer to the device object that contains this device extension.
    PDRIVER_OBJECT	DriverObject;			// Pointer to Driver Object
    BOOLEAN         IsFDO;					// A boolean to distringuish between PDO and FDO.
	PDEVICE_OBJECT	LowerDeviceObject;		// This is a pointer to the next lower device in the IRP stack.

    ULONG           DebugLevel;

	ULONG			PnpPowerFlags;			// Plug & Play / Power flags
	KSPIN_LOCK		PnpPowerFlagsLock;		// Lock for protecting the flags
	BOOLEAN         PowerQueryLock;			// Are we currently in a query power state? 
    LIST_ENTRY		StalledIrpQueue;		// List of stalled IRPs
	KSPIN_LOCK		StalledIrpLock;			// Lock for protecting stalled IRPs
	BOOLEAN			UnstallingFlag;			// Flag set if we are unstalling IRPs currently queued.

#ifndef	BUILD_SPXMINIPORT
	SYSTEM_POWER_STATE  SystemState;		// Current System Power State
    DEVICE_POWER_STATE  DeviceState;		// Current Device Power State
#endif

#ifdef WMI_SUPPORT
    WMILIB_CONTEXT		WmiLibInfo;			// WMI Information
#endif

} COMMON_OBJECT_DATA, *PCOMMON_OBJECT_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Configuration Data.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CONFIG_DATA 
{
	PHYSICAL_ADDRESS	RawPhysAddr;		// Raw physical address of card 
    PHYSICAL_ADDRESS    PhysAddr;			// Translated Physical address of card.
	PUCHAR				Controller;			// Virtual mapped sddress of card.
    ULONG               SpanOfController;	// Size of memory used by Cord.
    INTERFACE_TYPE      InterfaceType;		// Type of card (Isa or Pci)
    ULONG               BusNumber;			// Bus number card is using.
	ULONG				SlotNumber;			// Slot number on bus.		
    ULONG               AddressSpace;		// Flag used by SX
    ULONG               OriginalVector;		// Original Vector (bus relative)
    ULONG               OriginalIrql;		// Original Irql (bus relative)
    ULONG               TrVector;			// Translated Vector (system relative).
    KIRQL               TrIrql;				// Translated Irql (system relative).
    KINTERRUPT_MODE     InterruptMode;		// Interrupt mode (LevelSensitive or Latched)
	BOOLEAN				InterruptShareable;	// Interrupt shareable flag.
    KAFFINITY           ProcessorAffinity;	// Processor affintity.
	PKSERVICE_ROUTINE	OurIsr;				// Points to interrupt service routine.
    PVOID				OurIsrContext;		// Points to card device extension.
    PKINTERRUPT			Interrupt;			// Points to the interrupt object used by the card.
    ULONG               ClockRate;			// ClockRate.
} CONFIG_DATA,*PCONFIG_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_CARD_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	CONFIG_DATA;									// Card Config Data
	PDEVICE_OBJECT PDO;								// Pointer to Physical Device Object 

	UNICODE_STRING	DeviceName;						// Device name.
	ULONG			CardNumber;
	ULONG			NumberOfPorts;					// Number of ports attached to card.
	ULONG			NumPDOs;						// The PDOs currently enumerated.
	ULONG			CardType;						// Defines the type of host card.

	PDEVICE_OBJECT  AttachedPDO[PRODUCT_MAX_PORTS];	// Array of pointers to PDOs for ports attached to card.

} COMMON_CARD_DEVICE_EXTENSION, *PCOMMON_CARD_DEVICE_EXTENSION;



typedef struct _PORT_PERFORMANCE_STATS
{
    SERIALPERF_STATS;

	// IRPs with a Major Function of IRP_MJ_WRITE
	ULONG WriteIrpsSubmitted;
	ULONG WriteIrpsCompleted;
	ULONG WriteIrpsCancelled;
	ULONG WriteIrpsTimedOut;
	ULONG WriteIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_READ
	ULONG ReadIrpsSubmitted;
	ULONG ReadIrpsCompleted;
	ULONG ReadIrpsCancelled;
	ULONG ReadIrpsTimedOut;
	ULONG ReadIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_FLUSH_BUFFERS
	ULONG FlushIrpsSubmitted;
	ULONG FlushIrpsCompleted;
	ULONG FlushIrpsCancelled;
	ULONG FlushIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_DEVICE_CONTROL
	ULONG IoctlIrpsSubmitted;
	ULONG IoctlIrpsCompleted;
	ULONG IoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_INTERNAL_DEVICE_CONTROL
	ULONG InternalIoctlIrpsSubmitted;
	ULONG InternalIoctlIrpsCompleted;
	ULONG InternalIoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CREATE
	ULONG CreateIrpsSubmitted;
	ULONG CreateIrpsCompleted;
	ULONG CreateIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLOSE
	ULONG CloseIrpsSubmitted;
	ULONG CloseIrpsCompleted;
	ULONG CloseIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLEANUP
	ULONG CleanUpIrpsSubmitted;
	ULONG CleanUpIrpsCompleted;
	ULONG CleanUpIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION 
	ULONG InfoIrpsSubmitted;
	ULONG InfoIrpsCompleted;
	ULONG InfoIrpsCancelled;

} PORT_PERFORMANCE_STATS, *PPORT_PERFORMANCE_STATS;

//////////////////////////////////////////////////////////////////////////////////////////
// Common Port Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_PORT_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	PDEVICE_OBJECT		ParentFDO;					// A back pointer to the bus FDO  (this will be the LowerDeviceObject) 
	PCARD_DEV_EXT		pParentCardExt;				// Pointer to parent card device structure
	UNICODE_STRING		DeviceName;					// Device name eg. "\Device\PortName#".
	UNICODE_STRING		DeviceClassSymbolicName;	// Device Interface Name
	UNICODE_STRING		SerialCommEntry;			// Device name in SERIALCOMM Reg key eg. "PortName#".
	ULONG				PortNumber;					// Port number.
	UNICODE_STRING		DeviceID;					// Format: bus\device (must be most specific HardwareID)
	UNICODE_STRING		InstanceID;					// Instance ID 
	BOOLEAN				UniqueInstanceID;			// TRUE if InstanceID is gloablly unique, FALSE otherwise.
    UNICODE_STRING		HardwareIDs;				// Format bus\device or *PNPXXXX - meaning root enumerated
    UNICODE_STRING		CompatibleIDs;				// Compatible IDs to the Hardware ID
    UNICODE_STRING		DevDesc;					// Text describing device
    UNICODE_STRING		DevLocation;				// Text describing device location
	UNICODE_STRING		DosName;					// Dos device name "COM#" 
	UNICODE_STRING		SymbolicLinkName;			// External Device Name eg."\DosDevices\COM#".
	BOOLEAN				CreatedSymbolicLink;		// Flag to indicate that a symbolic link has been created.
	BOOLEAN				CreatedSerialCommEntry;		// Flag to indicate that a reg entry has been created in "SERIALCOMM"
	BOOLEAN				DeviceIsOpen;				// Flag to indicate when the port is open	
	ULONG				SavedModemControl;			// DTR/RTS signal states saved during power down
    FAST_MUTEX			OpenMutex;					// Mutex on open status

	    
#ifdef WMI_SUPPORT
	SERIAL_WMI_COMM_DATA	WmiCommData;			// WMI Comm Data
    SERIAL_WMI_HW_DATA		WmiHwData;				// WMI HW Data
	SERIAL_WMI_PERF_DATA	WmiPerfData;			// WMI Performance Data
#endif

    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
	PORT_PERFORMANCE_STATS PerfStats;

} COMMON_PORT_DEVICE_EXTENSION, *PCOMMON_PORT_DEVICE_EXTENSION;


#endif	// End of SPX_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\io8_ver.h ===
/*****************************************************************************
*****************************                     ****************************
*****************************   Current Version   ****************************
*****************************                     ****************************
*****************************************************************************/

#ifndef IO8_VER_H
#define IO8_VER_H

/* The following definitions are used to define the driver "properties" */

#define	VER_MAJOR			01
#define	VER_MINOR			00
#define	VER_REVISION		01

#define VER_BUILD			0022
#define VER_BUILDSTR		"0022"

#define	VERSION_NUMBER		VER_MAJOR,VER_MINOR,VER_REVISION,VER_BUILD
#define VERSION_NUMBER_STR	"1.0.1." VER_BUILDSTR

#define COMPANY_NAME		"Perle Systems Ltd. " 
#define COPYRIGHT_YEARS		"2001 "
#define COPYRIGHT_SYMBOL	" "

#define PRODUCT_NAME		"I/O8+"

#define SOFTWARE_NAME		" Serial Device Driver "
#define DRIVER_FILENAME 	"IO8.SYS"


#endif	// End of IO8_VER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\serialp.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 Microsoft Corporation

Module Name :
	
    serialp.h

Abstract:

    Prototypes and macros that are used throughout the driver.

Author:

    Anthony V. Ercolano                  September 26, 1991

Revision History:
--*/

#ifndef SERIALP_H
#define SERIALP_H

typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PPORT_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

BOOLEAN SerialGetStats(IN PVOID Context);		// Get Stats
BOOLEAN SerialClearStats(IN PVOID Context);		// Clear Stats (Called during open)

NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialGetNextWrite(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    );

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialSetDTR(
    IN PVOID Context
    );

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    );

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    );

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    );

BOOLEAN
SerialSetChars(
    IN PVOID Context
    );

BOOLEAN
SerialSetBaud(
    IN PVOID Context
    );

BOOLEAN
SerialSetLineControl(
    IN PVOID Context
    );

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    );

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    );

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialProdXonXoff(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN SendXon
    );

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    );

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_START_ROUTINE Starter,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp
    );

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN DoingTX
    );

BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialDispatchISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

NTSTATUS
SerialGetDivisorFromBaud(
    IN ULONG ClockRate,
    IN LONG DesiredBaud,
    OUT PSHORT AppropriateDivisor
    );

VOID
SerialUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
SerialReset(
    IN PVOID Context
    );

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    );

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCleanupDevice(
    IN PPORT_DEVICE_EXTENSION pPort
    );

UCHAR
SerialProcessLSR(
    IN PPORT_DEVICE_EXTENSION pPort, UCHAR LineStatus
    );

LARGE_INTEGER
SerialGetCharTime(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialSharerIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialIndexedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialBitMappedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

VOID
SerialPutChar(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN UCHAR CharToPut
    );

VOID SerialGetProperties(
	IN PPORT_DEVICE_EXTENSION pPort, 
	IN PSERIAL_COMMPROP Properties
	);


typedef struct _SERIAL_UPDATE_CHAR {
    PPORT_DEVICE_EXTENSION pPort;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC {
    PPORT_DEVICE_EXTENSION pPort;
    PVOID Data;
    } SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

//
// The following three macros are used to initialize, increment
// and decrement reference counts in IRPs that are used by
// this driver.  The reference count is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_INC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))++)

#define SERIAL_DEC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))--)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))


#endif // End of SERIALP.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\spx.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	File: SPX.H 
//
//	Contains:	Prototypes of functions to be supplied by a specific  
//				driver to integrate into NT generic PnP code.
//
//	Note:	All generic NT PnP code is prefixed by Spx_.
//			All funcions that are required to integrate into the generic 
//			code are prefixed by XXX_.
//
//
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_H
#define SPX_H	


// Purpose:		Interpret resources given to card by PnP Manager.
//
// Must:		Store resource details in card extension.
NTSTATUS
XXX_CardGetResources(	
	IN PDEVICE_OBJECT pDevObject, 
	IN PCM_RESOURCE_LIST PResList,
	IN PCM_RESOURCE_LIST PTrResList
	);

// Purpose:		Initialise card.
//				Find out how many ports are attached.
// 
// Must:		Fill in NumberOfPorts field in card extension.
NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Start up the card.
//
// Must:		Connect up any interrupts.
NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Stop the card.
//
// Must:		Stop Card from interrupting.
NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Deinitialise the card.
//
// Must:		Disconnect any interrupts.
NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Initialise the port extension.
//
// Must:		Store DeviceID, HardwareIDs, DevDesc into the port extension.
//					
NTSTATUS
XXX_PortInit(PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Start up the port.
//
// Must:		Get port ready to receive read and write commands.
NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort);


// Purpose:		Stop the port.
//
// Must:		Disconnect any resources and stop DPCs.
//				Do not delete the device object or symbolic link.
NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Deinitialise the port.
//
// Must:		Delete the device object & symbolic link.
NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Save the state of the card hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Restore the state of the card hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Save the state of the port hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Restore the state of the port hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Queries whether it is safe for the port to power down.
//
// Must:		Return STATUS_SUCCESS if OK to power down.			
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Set hand shaking and flow control on a port.
VOID 
XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS);

// Paging 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, XXX_CardGetResources)
#pragma alloc_text (PAGE, XXX_CardInit)
#pragma alloc_text (PAGE, XXX_CardDeInit)
#pragma alloc_text (PAGE, XXX_CardStart)
#pragma alloc_text (PAGE, XXX_CardStop)
#pragma alloc_text (PAGE, XXX_PortInit)
#pragma alloc_text (PAGE, XXX_PortDeInit)
#pragma alloc_text (PAGE, XXX_PortStart)
#pragma alloc_text (PAGE, XXX_PortStop)
#endif  


#endif	// End of SPX.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\spx_defs.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_DEFS.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	Definitions for all the common PnP and power code.						*
*																						*
****************************************************************************************/

#if	!defined(SPX_DEFS_H)
#define SPX_DEFS_H	

static const PHYSICAL_ADDRESS PhysicalZero = {0};

#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128

#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY		L"DosDevices"

#define MAX_ERROR_LOG_INSERT	52


// File IDs for Event Logging (top 8 bits only).
#define SPX_INIT_C		((ULONG)0x01000000)
#define SPX_PNP_C		((ULONG)0x02000000)
#define SPX_POWR_C		((ULONG)0x03000000)
#define SPX_DISP_C		((ULONG)0x04000000)
#define SPX_UTILS_C		((ULONG)0x05000000)
#define SPX_IIOC_C		((ULONG)0x06000000)




// COMMON_OBJECT_DATA.PnpPowerFlags definitions... 
#define	PPF_STARTED			0x00000001		// Device has been started 
#define	PPF_STOP_PENDING	0x00000002		// Device stop is pending 
#define	PPF_REMOVE_PENDING	0x00000004		// Device remove is pending 
#define	PPF_REMOVED			0x00000008		// Device has been removed 
#define	PPF_POWERED			0x00000010		// Device has been powered up 
			
typedef enum _SPX_MEM_COMPARES 
{
	AddressesAreEqual,
	AddressesOverlap,
	AddressesAreDisjoint

}SPX_MEM_COMPARES, *PSPX_MEM_COMPARES;

// IRP Counters
#define IRP_SUBMITTED		0x00000001	
#define IRP_COMPLETED		0x00000002
#define IRP_QUEUED			0x00000003
#define IRP_DEQUEUED		0x00000004


extern UNICODE_STRING SavedRegistryPath;	// Driver Registry Path.


#endif	// End of SPX_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\download.c ===
// Download programs for Z280 and T225 based SI/XIO/SX cards...

#include "precomp.h"			/* Precompiled Headers */
#include "si2_z280.c"			/* Z280 download code image */
#include "si3_t225.c"			/* T225 download code image */
#include "si4_cf.c"			/* ColdFire download code image */

/* End of DOWNLOAD.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\error.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the code that is very specific to error
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialKillAllReadsOrWrites(
        pPort->DeviceObject,
        &pPort->WriteQueue,
        &pPort->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        pPort->DeviceObject,
        &pPort->ReadQueue,
        &pPort->CurrentReadIrp
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\io8\incl\spx_misc.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_MISC.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	All Macros and function prototypes for the common PnP and power code.	*
*																						*
****************************************************************************************/

#if	!defined(SPX_MISC_H)
#define SPX_MISC_H	


// Prototypes for common PnP code.
NTSTATUS
Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPDO);

NTSTATUS
Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP	pIrp);

NTSTATUS 
Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp, IN PVOID Context);

NTSTATUS 
Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp);

NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...);

NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	);

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	);

VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp);

VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	);

ULONG	SpxGetNtCardType(PDEVICE_OBJECT pNtDevObj);
NTSTATUS Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort);

SPX_MEM_COMPARES Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB);

NTSTATUS PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard);

VOID SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set);
VOID SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set);

BOOLEAN 
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll);


PVOID SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);
PVOID SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);

#ifndef BUILD_SPXMINIPORT
void SpxFreeMem(PVOID pMem);
#endif
						   
VOID SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition);
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort);


// Filtered dispatch entry points... 
NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 
NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);	// SPX_DISP.C 
NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort);							// SPX_DISP.C 
VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj);							// SPX_DISP.C 


// End of prototypes for common PnP code.


#ifdef WMI_SUPPORT

NTSTATUS Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);

#define UPDATE_WMI_LINE_CONTROL(WmiCommData, LineControl)						\
do																				\
{																				\
																				\
	WmiCommData.BitsPerByte			= (LineControl & SERIAL_DATA_MASK) + 5;		\
	WmiCommData.ParityCheckEnable	= (LineControl & 0x08) ? TRUE : FALSE;		\
																				\
	switch(LineControl & SERIAL_PARITY_MASK)									\
	{																			\
	case SERIAL_ODD_PARITY:														\
		WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;								\
		break;																	\
																				\
	case SERIAL_EVEN_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;							\
		break;																	\
																				\
	case SERIAL_MARK_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;							\
		break;																	\
																				\
	case SERIAL_SPACE_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;							\
		break;																	\
																				\
	case SERIAL_NONE_PARITY:													\
	default:																	\
		WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;							\
		break;																	\
	}																			\
																				\
																				\
	if(LineControl & SERIAL_STOP_MASK)											\
	{																			\
		if((LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA)					\
			WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;							\
		else																	\
			WmiCommData.StopBits = SERIAL_WMI_STOP_2;							\
	}																			\
	else																		\
		WmiCommData.StopBits = SERIAL_WMI_STOP_1;								\
																				\
} while (0)


#define UPDATE_WMI_XON_XOFF_CHARS(WmiCommData, SpecialChars)					\
do																				\
{																				\
	WmiCommData.XoffCharacter	= SpecialChars.XoffChar;						\
	WmiCommData.XonCharacter	= SpecialChars.XonChar;							\
																				\
} while (0)


#define UPDATE_WMI_XMIT_THRESHOLDS(WmiCommData, HandFlow)						\
do																				\
{																				\
	WmiCommData.XoffXmitThreshold	= HandFlow.XoffLimit;						\
	WmiCommData.XonXmitThreshold	= HandFlow.XonLimit;						\
																				\
} while (0)

#endif



// Macros 

// Debug Messages
#if DBG
#define SPX_TRACE_CALLS			((ULONG)0x00000001)
#define SPX_TRACE_PNP_IRPS		((ULONG)0x00000002)
#define SPX_ERRORS				((ULONG)0x00000004)
#define SPX_MISC_DBG			((ULONG)0x00000008)
#define SPX_TRACE_POWER_IRPS	((ULONG)0x00000010)
#define	SPX_TRACE_IRP_PATH		((ULONG)0x00000020)
#define	SPX_TRACE_FILTER_IRPS	((ULONG)0x00000040)
//#define SERFLOW				((ULONG)0x00000080)
//#define SERERRORS				((ULONG)0x00000100)
//#define SERBUGCHECK			((ULONG)0x00000200)

extern ULONG SpxDebugLevel;		// Global Debug Level 

#define SpxDbgMsg(LEVEL, STRING)			\
        do{									\
            if(SpxDebugLevel & (LEVEL))		\
			{								\
                DbgPrint STRING;			\
            }								\
            if((LEVEL) == SERBUGCHECK)		\
			{								\
                ASSERT(FALSE);				\
            }								\
        }while (0)
#else
#define SpxDbgMsg(LEVEL, STRING) do {NOTHING;} while (0)
#endif




#define	SetPnpPowerFlags(pDevExt,Value)		\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), TRUE);		

#define	ClearPnpPowerFlags(pDevExt,Value)	\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), FALSE);	

#define SPX_SUCCESS(Status) ((NTSTATUS)(Status) == 0)

#define	SetUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), TRUE);		

#define	ClearUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), FALSE);	

// End of macros.

#endif	// End of SPX_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\modmflow.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    modmflow.c

Abstract:

    This module contains *MOST* of the code used to manipulate
    the modem control and status registers.  The vast majority
    of the remainder of flow control is concentrated in the
    Interrupt service routine.  A very small amount resides
    in the read code that pull characters out of the interrupt
    buffer.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    );


BOOLEAN
SerialSetDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    Slxos_SetDTR (Context);

    return FALSE;

}

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    Slxos_ClearDTR (Context);

    return FALSE;

}

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    Slxos_SetRTS (pPort);

    return FALSE;

}

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    Slxos_ClearRTS(pPort);

    return FALSE;

}

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    )

/*++

Routine Description:

    This routine adjusts the flow control based on new
    control flow.

Arguments:

    pPort - A pointer to the serial device extension.

    NewHandFlow - A pointer to a serial handflow structure
                  that is to become the new setup for flow
                  control.

Return Value:

    This routine always returns FALSE.

--*/

{

    SERIAL_HANDFLOW New = *NewHandFlow;

    //
    // If the pPort->DeviceIsOpen is FALSE that means
    // we are entering this routine in response to an open request.
    // If that is so, then we always proceed with the work regardless
    // of whether things have changed.
    //

    //
    // First we take care of the DTR flow control.  We only
    // do work if something has changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) !=
         (New.ControlHandShake & SERIAL_DTR_MASK))) {

        SpxDbgMsg(
            SERFLOW,
            ("SERIAL: Processing DTR flow for %x.\n",
            pPort->pChannel)
            );

        if (New.ControlHandShake & SERIAL_DTR_MASK) {

            //
            // Well we might want to set DTR.
            //
            // Before we do, we need to check whether we are doing
            // DTR flow control.  If we are then we need to check
            // if then number of characters in the interrupt buffer
            // exceeds the XoffLimit.  If it does then we don't
            // enable DTR AND we set the RXHolding to record that
            // we are holding because of the DTR.
            //

            if ((New.ControlHandShake & SERIAL_DTR_MASK)
                == SERIAL_DTR_HANDSHAKE) {

                if ((pPort->BufferSize - New.XoffLimit) >
                    pPort->CharsInInterruptBuffer) {

                    //
                    // However if we are already holding we don't want
                    // to turn it back on unless we exceed the Xon
                    // limit.
                    //

                    if (pPort->RXHolding & SERIAL_RX_DTR) {

                        //
                        // We can assume that its DTR line is already low.
                        //

                        if (pPort->CharsInInterruptBuffer >
                            (ULONG)New.XonLimit) {

                            SpxDbgMsg(
                                SERFLOW,
                                ("SERIAL: Removing DTR block on reception for %x\n",
                                 pPort->pChannel)
                                );
                            pPort->RXHolding &= ~SERIAL_RX_DTR;
                            SerialSetDTR(pPort);

                        }

                    } else {

                        SerialSetDTR(pPort);

                    }

                } else {

                    SpxDbgMsg(
                        SERFLOW,
                        ("SERIAL: Setting DTR block on reception for %x\n",
                         pPort->pChannel)
                        );
                    pPort->RXHolding |= SERIAL_RX_DTR;
                    SerialClrDTR(pPort);

                }

            } else {

                //
                // Note that if we aren't currently doing DTR flow control then
                // we MIGHT have been.  So even if we aren't currently doing
                // DTR flow control, we should still check if RX is holding
                // because of DTR.  If it is, then we should clear the holding
                // of this bit.
                //

                if (pPort->RXHolding & SERIAL_RX_DTR) {

                    SpxDbgMsg(
                        SERFLOW,
                        ("SERIAL: Removing dtr block of reception for %x\n",
                        pPort->pChannel)
                        );
                    pPort->RXHolding &= ~SERIAL_RX_DTR;

                }

                SerialSetDTR(pPort);

            }

        } else {

            //
            // The end result here will be that DTR is cleared.
            //
            // We first need to check whether reception is being held
            // up because of previous DTR flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (pPort->RXHolding & SERIAL_RX_DTR) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: removing dtr block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_DTR;

            }

            SerialClrDTR(pPort);

        }

    }

    //
    // Time to take care of the RTS Flow control.
    //
    // First we only do work if something has changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) !=
         (New.FlowReplace & SERIAL_RTS_MASK))) {

        SpxDbgMsg(
            SERFLOW,
            ("SERIAL: Processing RTS flow for %x.\n",
            pPort->pChannel)
            );

        if ((New.FlowReplace & SERIAL_RTS_MASK) ==
            SERIAL_RTS_HANDSHAKE) {

            //
            // Well we might want to set RTS.
            //
            // Before we do, we need to check whether we are doing
            // RTS flow control.  If we are then we need to check
            // if then number of characters in the interrupt buffer
            // exceeds the XoffLimit.  If it does then we don't
            // enable RTS AND we set the RXHolding to record that
            // we are holding because of the RTS.
            //

            if ((pPort->BufferSize - New.XoffLimit) >
                pPort->CharsInInterruptBuffer) {

                //
                // However if we are already holding we don't want
                // to turn it back on unless we exceed the Xon
                // limit.
                //

                if (pPort->RXHolding & SERIAL_RX_RTS) {

                    //
                    // We can assume that its RTS line is already low.
                    //

                    if (pPort->CharsInInterruptBuffer >
                        (ULONG)New.XonLimit) {

                       SpxDbgMsg(
                           SERFLOW,
                           ("SERIAL: Removing rts block of reception for %x\n",
                           pPort->pChannel)
                           );
                        pPort->RXHolding &= ~SERIAL_RX_RTS;
                        SerialSetRTS(pPort);

                    }

                } else {

                    SerialSetRTS(pPort);

                }

            } else {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: Setting RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding |= SERIAL_RX_RTS;
                SerialClrRTS(pPort);

            }

        } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                   SERIAL_RTS_CONTROL) {

            //
            // Note that if we aren't currently doing RTS flow control then
            // we MIGHT have been.  So even if we aren't currently doing
            // RTS flow control, we should still check if RX is holding
            // because of RTS.  If it is, then we should clear the holding
            // of this bit.
            //

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: Clearing RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_RTS;

            }

            SerialSetRTS(pPort);

        } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                   SERIAL_TRANSMIT_TOGGLE) {

            //
            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: TOGGLE Clearing RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_RTS;

            }

            //
            // We have to place the RTS value into the Extension
            // now so that the code that tests whether the
            // RTS line should be lowered will find that we
            // are "still" doing transmit toggling.  The code
            // for lowering can be invoked later by a timer so
            // it has to test whether it still needs to do its
            // work.
            //

            pPort->HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
            pPort->HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;

            //
            // The order of the tests is very important below.
            //
            // If there is a break then we should turn on the RTS.
            //
            // If there isn't a break but there are characters in
            // the hardware, then turn on the RTS.
            //
            // If there are writes pending that aren't being held
            // up, then turn on the RTS.
            //

            if ((pPort->TXHolding & SERIAL_TX_BREAK) ||
                Slxos_GetCharsInTxBuffer(pPort) != 0 ||
                (pPort->CurrentWriteIrp || pPort->TransmitImmediate ||
                 (!IsListEmpty(&pPort->WriteQueue)) &&
                 (!pPort->TXHolding))) {

                SerialSetRTS(pPort);

            } else {

                //
                // This routine will check to see if it is time
                // to lower the RTS because of transmit toggle
                // being on.  If it is ok to lower it, it will,
                // if it isn't ok, it will schedule things so
                // that it will get lowered later.
                //

                pPort->CountOfTryingToLowerRTS++;
                SerialPerhapsLowerRTS(pPort);

            }

        } else {

            //
            // The end result here will be that RTS is cleared.
            //
            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: Clearing RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_RTS;

            }

            SerialClrRTS(pPort);

        }

    }

    //
    // We now take care of automatic receive flow control.
    // We only do work if things have changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
         (New.FlowReplace & SERIAL_AUTO_RECEIVE))) {

        if (New.FlowReplace & SERIAL_AUTO_RECEIVE) {

            //
            // We wouldn't be here if it had been on before.
            //
            // We should check to see whether we exceed the turn
            // off limits.
            //
            // Note that since we are following the OS/2 flow
            // control rules we will never send an xon if
            // when enabling xon/xoff flow control we discover that
            // we could receive characters but we are held up due
            // to a previous Xoff.
            //

            if ((pPort->BufferSize - New.XoffLimit) <=
                pPort->CharsInInterruptBuffer) {

                //
                // Set the XOFF flag.  This will cause the driver to avoid
                // reading characters out of the hardware, and the hardware
                // will eventually send an XOFF itself.
                //
                pPort->RXHolding |= SERIAL_RX_XOFF;

            }

        } else {

            //
            // The app has disabled automatic receive flow control.
            //
            // If transmission was being held up because of
            // an automatic receive Xoff, then we should
            // cause an Xon to be sent.  Simply clearing the flag
            // will do the trick.
            //

            pPort->RXHolding &= ~SERIAL_RX_XOFF;

        }

    }

    //
    // We now take care of automatic transmit flow control.
    // We only do work if things have changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
         (New.FlowReplace & SERIAL_AUTO_TRANSMIT))) {

        if (New.FlowReplace & SERIAL_AUTO_TRANSMIT) {

            //
            // We wouldn't be here if it had been on before.
            //
            // BUG BUG ??? There is some belief that if autotransmit
            // was just enabled, I should go look in what we
            // already received, and if we find the xoff character
            // then we should stop transmitting.  I think this
            // is an application bug.  For now we just care about
            // what we see in the future.
            //

            ;

        } else {

            //
            // The app has disabled automatic transmit flow control.
            //

            if (pPort->TXHolding & SERIAL_TX_XOFF) {

                pPort->TXHolding &= ~SERIAL_TX_XOFF;

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialSetupNewHandFlow. TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->TXHolding)
                    );
            }

        }

    }

    //
    // At this point we can simply make sure that entire
    // handflow structure in the extension is updated.
    // This will cause an interrupt, and that will deal with
    // automatic flow control.
    //

    pPort->HandFlow = New;
    Slxos_SetFlowControl(pPort);

    return FALSE;

}

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the handshake and control
    flow in the device extension.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a handflow
              structure..

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_IOCTL_SYNC S = Context;
    PPORT_DEVICE_EXTENSION pPort = S->pPort;
    PSERIAL_HANDFLOW HandFlow = S->Data;

    SerialSetupNewHandFlow(
        pPort,
        HandFlow
        );

    SerialHandleModemUpdate(pPort);

    return FALSE;

}

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn on break in the hardware and
    record the fact the break is on, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(pPort);

    }
    pPort->TXHolding |= SERIAL_TX_BREAK;
    Slxos_TurnOnBreak(pPort);

    return FALSE;

}

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn off break in the hardware and
    record the fact the break is off, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->TXHolding & SERIAL_TX_BREAK) {

        Slxos_TurnOffBreak(pPort);

        pPort->TXHolding &= ~SERIAL_TX_BREAK;

        if (!pPort->TXHolding &&
            (pPort->TransmitImmediate ||
             pPort->WriteLength)) {
	
            Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

        } else {

            //
            // The following routine will lower the rts if we
            // are doing transmit toggling and there is no
            // reason to keep it up.
            //

            pPort->CountOfTryingToLowerRTS++;
            SerialPerhapsLowerRTS(pPort);

        }

    }

    return FALSE;

}

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xoff was received.  Even if the
    driver does not have automatic Xoff/Xon flowcontrol - This
    still will stop the transmission.  This is the OS/2 behavior
    and is not well specified for Windows.  Therefore we adopt
    the OS/2 behavior.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TXHolding |= SERIAL_TX_XOFF;

    SpxDbgMsg(
        SERDIAG1,
        ("%s: SerialPretendXoff. TXHolding = %d\n",
        PRODUCT_NAME,
        pPort->TXHolding)
        );
        
    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

		if (KeInsertQueueDpc(
		        &pPort->StartTimerLowerRTSDpc,
		        NULL,
		        NULL
		        ))

		    pPort->CountOfTryingToLowerRTS++;

    }

    return FALSE;

}

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xon was received.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->TXHolding) {

        //
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.


        if ((pPort->TXHolding & SERIAL_TX_XOFF) &&
            ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) ||
             (pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT))) {

            // Automatic Xon/Xoff transmit is enabled. Simulate Xon received.
            Slxos_Resume(pPort);

        }
        pPort->TXHolding &= ~SERIAL_TX_XOFF;

        SpxDbgMsg(
            SERDIAG1,
            ("%s: SerialPretendXon. TXHolding = %d\n",
            PRODUCT_NAME,
            pPort->TXHolding)
            );

        if (!pPort->TXHolding &&
            (pPort->TransmitImmediate ||
             pPort->WriteLength)) {

           Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

        }

    }

    return FALSE;

}

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is called to handle a reduction in the number
    of characters in the interrupt (typeahead) buffer.  It
    will check the current output flow control and re-enable transmission
    as needed.

    NOTE: This routine assumes that it is working at interrupt level.

Arguments:

    pPort - A pointer to the device extension.

Return Value:

    None.

--*/

{


    //
    // If we are doing receive side flow control and we are
    // currently "holding" then because we've emptied out
    // some characters from the interrupt buffer we need to
    // see if we can "re-enable" reception.
    //

    if (pPort->RXHolding) {

        if (pPort->CharsInInterruptBuffer <=
            (ULONG)pPort->HandFlow.XonLimit) {

            if (pPort->RXHolding & SERIAL_RX_DTR) {

                pPort->RXHolding &= ~SERIAL_RX_DTR;

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialHandleReducedIntBuffer() RX_DTR for %x. "
                    "RXHolding = %d, TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->pChannel,
                    pPort->RXHolding, pPort->TXHolding)
                    );
                    
                SerialSetDTR(pPort);
            }

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                pPort->RXHolding &= ~SERIAL_RX_RTS;
                Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialHandleReducedIntBuffer() RX_RTS for %x. "
                    "RXHolding = %d, TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->pChannel,
                    pPort->RXHolding,
                    pPort->TXHolding)
                    );

                SerialSetRTS(pPort);
            }

            if (pPort->RXHolding & SERIAL_RX_XOFF) {

                //
                // Clear the holding flag.  This may cause the receive
                // logic to empty the hardware receive buffers enough
                // to cause it to send an XON.
                //
                pPort->RXHolding &= ~SERIAL_RX_XOFF;
                Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialHandleReducedIntBuffer() RX_XOFF for %x. "
                    "RXHolding = %d, TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->pChannel,
                    pPort->RXHolding,
                    pPort->TXHolding)
                    );
            }

        }

    }

}

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will be to check on the modem status, and
    handle any appropriate event notification as well as
    any flow control appropriate to modem status lines.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    This returns the old value of the modem status register
    (extended into a ULONG).

--*/
{

    //
    // We keep this local so that after we are done
    // examining the modem status and we've updated
    // the transmission holding value, we know whether
    // we've changed from needing to hold up transmission
    // to transmission being able to proceed.
    //
    ULONG OldTXHolding = pPort->TXHolding;

    //
    // Holds the value in the mode status register.
    //
    UCHAR ModemStatus;

    ModemStatus = Slxos_GetModemStatus(pPort);

    //
    // If we are placing the modem status into the data stream
    // on every change, we should do it now.
    //

    if (pPort->EscapeChar) {

        if (ModemStatus & (SERIAL_MSR_DCTS |
                           SERIAL_MSR_DDSR |
                           SERIAL_MSR_TERI |
                           SERIAL_MSR_DDCD)) {

	    UCHAR	EscapeString[3] = {pPort->EscapeChar,SERIAL_LSRMST_MST,ModemStatus};

	    SerialPutBlock(pPort,EscapeString,3,FALSE);
        }

    }


    //
    // Take care of input flow control based on sensitivity
    // to the DSR.  This is done so that the application won't
    // see spurious data generated by odd devices.
    //
    // Basically, if we are doing dsr sensitivity then the
    // driver should only accept data when the dsr bit is
    // set.
    //

    if (pPort->HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) {

        if (ModemStatus & SERIAL_MSR_DSR) {

            //
            // The line is high.  Simply make sure that
            // RXHolding does't have the DSR bit.
            //

            pPort->RXHolding &= ~SERIAL_RX_DSR;

        } else {

            pPort->RXHolding |= SERIAL_RX_DSR;

        }

    } else {

        //
        // We don't have sensitivity due to DSR.  Make sure we
        // aren't holding. (We might have been, but the app just
        // asked that we don't hold for this reason any more.)
        //

        pPort->RXHolding &= ~SERIAL_RX_DSR;

    }

        //
        // Check to see if we have a wait
        // pending on the modem status events.  If we
        // do then we schedule a dpc to satisfy
        // that wait.
        //

    if (pPort->IsrWaitMask) {

        if ((pPort->IsrWaitMask & SERIAL_EV_CTS) &&
            (ModemStatus & SERIAL_MSR_DCTS)) {

            pPort->HistoryMask |= SERIAL_EV_CTS;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_DSR) &&
            (ModemStatus & SERIAL_MSR_DDSR)) {

            pPort->HistoryMask |= SERIAL_EV_DSR;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_RING) &&
            (ModemStatus & SERIAL_MSR_TERI)) {

            pPort->HistoryMask |= SERIAL_EV_RING;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_RLSD) &&
            (ModemStatus & SERIAL_MSR_DDCD)) {

            pPort->HistoryMask |= SERIAL_EV_RLSD;

        }

        if (pPort->IrpMaskLocation &&
            pPort->HistoryMask) {

            *pPort->IrpMaskLocation =
             pPort->HistoryMask;

            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->
                IoStatus.Information = sizeof(ULONG);

            KeInsertQueueDpc(
                &pPort->CommWaitDpc,
                NULL,
                NULL
                );
        }

    }

    //
    // We have an automatic Hardware Flow Control but we still need
    // to update flags for GetCommStatus().
    //
    // If the app has modem line flow control then
    // we check to see if we have to hold up transmission.
    //

    if (pPort->HandFlow.ControlHandShake &
        SERIAL_OUT_HANDSHAKEMASK) {

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_DSR_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DSR) {

                pPort->TXHolding &= ~SERIAL_TX_DSR;

            } else {

                pPort->TXHolding |= SERIAL_TX_DSR;

            }

        } else {

            pPort->TXHolding &= ~SERIAL_TX_DSR;

        }

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_DCD_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DCD) {

                pPort->TXHolding &= ~SERIAL_TX_DCD;

            } else {

                pPort->TXHolding |= SERIAL_TX_DCD;

            }

        } else {

            pPort->TXHolding &= ~SERIAL_TX_DCD;

        }

        //
        // If we hadn't been holding, and now we are then
        // queue off a dpc that will lower the RTS line
        // if we are doing transmit toggling.
        //

        if (!OldTXHolding && pPort->TXHolding &&
            (pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                SERIAL_TRANSMIT_TOGGLE) {

            if (KeInsertQueueDpc(
                    &pPort->StartTimerLowerRTSDpc,
                    NULL,
                    NULL
                    ))
                pPort->CountOfTryingToLowerRTS++;
        }

        //
        // We've done any adjusting that needed to be
        // done to the holding mask given updates
        // to the modem status.  If the Holding mask
        // is clear (and it wasn't clear to start)
        // and we have "write" work to do set things
        // up so that the transmission code gets invoked.
        //

        if (OldTXHolding && !pPort->TXHolding &&
            (pPort->TransmitImmediate || pPort->WriteLength)) {

            Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

        }

    } else {

        //
        // We need to check if transmission is holding
        // up because of modem status lines.  What
        // could have occurred is that for some strange
        // reason, the app has asked that we no longer
        // stop doing output flow control based on
        // the modem status lines.  If however, we
        // *had* been held up because of the status lines
        // then we need to clear up those reasons.
        //

        if (pPort->TXHolding & (SERIAL_TX_DCD | SERIAL_TX_DSR)) {

            pPort->TXHolding &= ~(SERIAL_TX_DCD | SERIAL_TX_DSR);

            if (OldTXHolding && !pPort->TXHolding &&
                (pPort->TransmitImmediate || pPort->WriteLength)) {

                Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

            }

        }

    }

    SpxDbgMsg(
        SERDIAG1,
        ("%s: SerialHandleModemUpdate for %x. "
        "RXHolding = %d, TXHolding = %d\n",
        PRODUCT_NAME,
        pPort->pChannel,
        pPort->RXHolding,
        pPort->TXHolding)
        );
        
    return ((ULONG)ModemStatus);
}

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;


    //
    // We first need to test if we are actually still doing
    // transmit toggle flow control.  If we aren't then
    // we have no reason to try be here.
    //

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        //
        // The order of the tests is very important below.
        //
        // If there is a break then we should leave on the RTS,
        // because when the break is turned off, it will submit
        // the code to shut down the RTS.
        //
        // If there are writes pending that aren't being held
        // up, then leave on the RTS, because the end of the write
        // code will cause this code to be reinvoked.  If the writes
        // are being held up, its ok to lower the RTS because the
        // upon trying to write the first character after transmission
        // is restarted, we will raise the RTS line.
        //

        if ((pPort->TXHolding & SERIAL_TX_BREAK) ||
            (pPort->CurrentWriteIrp || pPort->TransmitImmediate ||
             (!IsListEmpty(&pPort->WriteQueue)) &&
             (!pPort->TXHolding))) {

            NOTHING;

        } else {

            //
            // Looks good so far.  Call the line status check and processing
            // code, it will return the "current" line status value.  If
            // the holding and shift register are clear, lower the RTS line,
            // if they aren't clear, queue of a dpc that will cause a timer
            // to reinvoke us later.  We do this code here because no one
            // but this routine cares about the characters in the hardware,
            // so no routine by this routine will bother invoking to test
            // if the hardware is empty.
            //
            if (Slxos_GetCharsInTxBuffer(pPort) != 0) {

                //
                // Well it's not empty, try again later.
                //

                if (KeInsertQueueDpc(
                        &pPort->StartTimerLowerRTSDpc,
                        NULL,
                        NULL
                        ))
                    pPort->CountOfTryingToLowerRTS++;

            } else {

                //
                // Nothing in the hardware, lower the RTS.
                //

                SerialClrRTS(pPort);

            }

        }

    }

    //
    // We decrement the counter to indicate that we've reached
    // the end of the execution path that is trying to push
    // down the RTS line.
    //

    pPort->CountOfTryingToLowerRTS--;

    return FALSE;
}

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine starts a timer that when it expires will start
    a dpc that will check if it can lower the rts line because
    there are no characters in the hardware.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    LARGE_INTEGER CharTime;
    KIRQL OldIrql;
    ULONG nChars;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    //
    // Take out the lock to prevent the line control
    // from changing out from under us while we calculate
    // a character time.
    //

    KeAcquireSpinLock(
        &pPort->ControlLock,
        &OldIrql
        );

    CharTime = SerialGetCharTime(pPort);
    nChars = Slxos_GetCharsInTxBuffer(pPort);

    KeReleaseSpinLock(
        &pPort->ControlLock,
        OldIrql
        );

    CharTime = RtlExtendedIntegerMultiply(
                   CharTime,
                   nChars
                   );
    CharTime = RtlLargeIntegerNegate(CharTime);

    if (KeSetTimer(
            &pPort->LowerRTSTimer,
            CharTime,
            &pPort->PerhapsLowerRTSDpc
            )) {

        //
        // The timer was already in the timer queue.  This implies
        // that one path of execution that was trying to lower
        // the RTS has "died".  Synchronize with the ISR so that
        // we can lower the count.
        //

	Slxos_SyncExec(pPort,SerialDecrementRTSCounter,pPort,0x12);

    }

}

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This dpc routine exists solely to call the code that
    tests if the rts line should be lowered when TRANSMIT
    TOGGLE flow control is being used.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    Slxos_SyncExec(pPort,SerialPerhapsLowerRTS,pPort,0x13);

}

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine decrements the count of threads that are trying
    to lower RTS.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->CountOfTryingToLowerRTS--;

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\flush.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module contains the code that is very specific to flush
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


ULONG
Slxos_GetCharsInTxBuffer(
    IN PVOID Context
    );

NTSTATUS
SerialStartFlush(
    IN PPORT_DEVICE_EXTENSION pPort
    );


NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialFlush dispatch entry for: %x\n",Irp));

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    Irp->IoStatus.Information = 0L;

    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


    return SerialStartOrQueue(
               pPort,
               Irp,
               &pPort->WriteQueue,
               &pPort->CurrentWriteIrp,
               SerialStartFlush
               );

}

NTSTATUS
SerialStartFlush(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.

Arguments:

    pPort - Points to the serial device extension

Return Value:

    This will always return STATUS_SUCCESS.

--*/

{
    LARGE_INTEGER delay;
    PIRP NewIrp;
    ULONG limit = (102400/pPort->CurrentBaud);

    pPort->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    //
    // The following call will actually complete the flush.
    //

    SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    if(NewIrp) 
	{
        ASSERT(NewIrp == pPort->CurrentWriteIrp);
        SerialStartWrite(pPort);
    }

    //
    // flushes on NT are supposed to transmit all characters remaining in the
    // output buffer. The function should not return until all characters 
    // have gone
    //
    delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));

    while (limit)
	{
	KeDelayExecutionThread(KernelMode,FALSE,&delay);
	if (Slxos_GetCharsInTxBuffer(pPort)==0)
		break;
	limit--;
	}


    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\ioctl.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the ioctl dispatcher as well as a couple
    of routines that are generally just called in response to
    ioctl calls.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

// Prototypes
BOOLEAN SerialGetModemUpdate(IN PVOID Context);
BOOLEAN SerialGetCommStatus(IN PVOID Context);
VOID	SerialGetProperties(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_COMMPROP Properties);
BOOLEAN SerialSetEscapeChar(IN PVOID Context);
// End of Prototypes.    
    


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SerialGetStats(IN PVOID Context) 
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    return the perf stats to the caller.
//
// Arguments:
//    Context - Pointer to a the irp.
//
// Return Value:
//    This routine always returns FALSE.
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SerialGetStats(IN PVOID Context)
{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PPORT_DEVICE_EXTENSION pPort = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

	*sp = *((PSERIALPERF_STATS) &pPort->PerfStats);
  
	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SerialClearStats(IN PVOID Context) 
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    Context - Pointer to a the extension.
//
// Return Value:
//    This routine always returns FALSE.
////////////////////////////////////////////////////////////////////////////////

BOOLEAN
SerialClearStats(IN PVOID Context)
{
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)Context;

    RtlZeroMemory(&pPort->PerfStats, sizeof(SERIALPERF_STATS));

#ifdef WMI_SUPPORT
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));	
#endif

    return FALSE;
}


BOOLEAN
SerialSetChars(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the special characters for the
    driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a special characters
              structure.

Return Value:

    This routine always returns FALSE.

--*/
{

    ((PSERIAL_IOCTL_SYNC)Context)->pPort->SpecialChars =
        *((PSERIAL_CHARS)(((PSERIAL_IOCTL_SYNC)Context)->Data));

    Slxos_SetChars(((PSERIAL_IOCTL_SYNC)Context)->pPort);

    return FALSE;
}

BOOLEAN
SerialGetModemUpdate(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is simply used to call the interrupt level routine
    that handles modem status update.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

    *Result = SerialHandleModemUpdate(pPort);

    return FALSE;

}

BOOLEAN
SerialGetCommStatus(
    IN PVOID Context
    )

/*++

Routine Description:

    This is used to get the current state of the serial driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a serial status
              record.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    PSERIAL_STATUS Stat = ((PSERIAL_IOCTL_SYNC)Context)->Data;

    Stat->Errors = pPort->ErrorWord;
    pPort->ErrorWord = 0;

    //
    // BUG BUG We need to do something about eof (binary mode).
    //
    Stat->EofReceived = FALSE;

    Stat->AmountInInQueue = pPort->CharsInInterruptBuffer;

	// Get total amount of data queued, bytes in the IRP buffers and the card's circular buffer.
#if USE_NEW_TX_BUFFER_EMPTY_DETECT
    Stat->AmountInOutQueue = pPort->TotalCharsQueued + Slxos_GetCharsInTxBuffer(pPort) + ((PCHAN)pPort->pChannel)->tx_fifo_count;
#else
    Stat->AmountInOutQueue = pPort->TotalCharsQueued;
#endif

    if(pPort->WriteLength) 
	{
        //
        // By definition if we have a writelength the we have
        // a current write irp.
        //

        ASSERT(pPort->CurrentWriteIrp);
        ASSERT(Stat->AmountInOutQueue >= pPort->WriteLength);
        ASSERT((IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->
                Parameters.Write.Length) >=
                pPort->WriteLength);

        Stat->AmountInOutQueue -=
            IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)
            ->Parameters.Write.Length - (pPort->WriteLength);

    }

    Stat->WaitForImmediate = pPort->TransmitImmediate;

    Stat->HoldReasons = 0;
    
	if(pPort->TXHolding) 
	{
        if(pPort->TXHolding & SERIAL_TX_DSR) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;

        if(pPort->TXHolding & SERIAL_TX_DCD) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;

        if(pPort->TXHolding & SERIAL_TX_XOFF)
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;

        if(pPort->TXHolding & SERIAL_TX_BREAK) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;
    }

    if(pPort->RXHolding & SERIAL_RX_DSR)
        Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;

    if(pPort->RXHolding & SERIAL_RX_XOFF)
        Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;


    SpxDbgMsg( SERDIAG1,("%s: Err 0x%x HR 0x%x inq 0x%x outq 0x%x\n", PRODUCT_NAME,
    	Stat->Errors,Stat->HoldReasons,Stat->AmountInInQueue,
		Stat->AmountInOutQueue));

    return FALSE;

}

BOOLEAN
SerialSetEscapeChar(
    IN PVOID Context
    )

/*++

Routine Description:

    This is used to set the character that will be used to escape
    line status and modem status information when the application
    has set up that line status and modem status should be passed
    back in the data stream.

Arguments:

    Context - Pointer to the irp that is specify the escape character.
              Implicitly - An escape character of 0 means no escaping
              will occur.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort 
		= IoGetCurrentIrpStackLocation((PIRP)Context)->DeviceObject->DeviceExtension;

    pPort->EscapeChar = *(PUCHAR)((PIRP)Context)->AssociatedIrp.SystemBuffer;
       

    return FALSE;

}

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine provides the initial processing for all of the
    Ioctls for the serial device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    //
    KIRQL OldIrql;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialIOControl dispatch entry for: %x\n",Irp));

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) 
	{
	case IOCTL_SERIAL_SET_BAUD_RATE: 
		{
            ULONG BaudRate;
            //
            // Will hold the value of the appropriate divisor for
            // the requested baud rate.  If the baudrate is invalid
            // (because the device won't support that baud rate) then
            // this value is undefined.
            //

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_BAUD_RATE\n", PRODUCT_NAME));
                
            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BAUD_RATE)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            } 
			else 
			{
                BaudRate = ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;
            }

			if(!Slxos_CheckBaud(pPort,BaudRate))	// Check for valid rate 
			{
	    		Status = STATUS_INVALID_PARAMETER;
	    		break;
			}
#ifdef WMI_SUPPORT
			else
			{
				pPort->WmiCommData.BaudRate = BaudRate;
			}
#endif

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if(NT_SUCCESS(Status)) 
			{
                pPort->CurrentBaud = BaudRate;
				Slxos_SyncExec(pPort, Slxos_SetBaud, pPort, 0x05);
            }

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

	case IOCTL_SERIAL_GET_BAUD_RATE: 
		{
            PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_BAUD_RATE\n", PRODUCT_NAME));
                
            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_BAUD_RATE)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            Br->BaudRate = pPort->CurrentBaud;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);
            break;

        }

	case IOCTL_SERIAL_SET_LINE_CONTROL: 
		{
            //
            // Points to the line control record in the Irp.
            //
            PSERIAL_LINE_CONTROL Lc = ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

            UCHAR LData;
            UCHAR LStop;
            UCHAR LParity;
            UCHAR Mask = 0xff;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_LINE_CONTROL\n", PRODUCT_NAME));
            
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_LINE_CONTROL)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            switch (Lc->WordLength) 
			{
            case 5: 
				{
                    LData = SERIAL_5_DATA;
                    Mask = 0x1f;
					break;
                }

			case 6: 
				{
                    LData = SERIAL_6_DATA;
                    Mask = 0x3f;
                    break;
                }
 
			case 7: 
				{
                    LData = SERIAL_7_DATA;
                    Mask = 0x7f;
                    break;
                }

			case 8: 
				{
                    LData = SERIAL_8_DATA;
                    break;
                }
 			default: 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
				}
            }

            switch (Lc->Parity) 
			{
			case NO_PARITY: 
				{
                    LParity = SERIAL_NONE_PARITY;
                    break;
                }

			case EVEN_PARITY: 
				{
                    LParity = SERIAL_EVEN_PARITY;
                    break;
                }

			case ODD_PARITY: 
				{
                    LParity = SERIAL_ODD_PARITY;
                    break;
                }
               
			case SPACE_PARITY: 
				{
                    LParity = SERIAL_SPACE_PARITY;
                    break;
                }
 
			case MARK_PARITY: 
				{
                    LParity = SERIAL_MARK_PARITY;
                    break;
                }

			default: 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                    break;
                }

            }

            switch (Lc->StopBits) 
			{
			case STOP_BIT_1: 
				{
                    LStop = SERIAL_1_STOP;
                    break;
                }

			case STOP_BITS_1_5: 
				{
                    if (LData != SERIAL_5_DATA) 
					{
                        Status = STATUS_INVALID_PARAMETER;
                        goto DoneWithIoctl;
                    }

                    LStop = SERIAL_1_5_STOP;
                    break;
                }


			case STOP_BITS_2: 
				{
                    if (LData == SERIAL_5_DATA) 
					{
                        Status = STATUS_INVALID_PARAMETER;
                        goto DoneWithIoctl;
                    }

                    LStop = SERIAL_2_STOP;
                    break;
                }
 
			default: 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                }
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            pPort->LineControl = (UCHAR)((pPort->LineControl & SERIAL_LCR_BREAK) | (LData | LParity | LStop));
            pPort->ValidDataMask = Mask;

			Slxos_SyncExec(pPort,Slxos_SetLineControl,pPort,0x06);

#ifdef WMI_SUPPORT
			UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            break;
        }
        
	case IOCTL_SERIAL_GET_LINE_CONTROL: 
		{
            PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_LINE_CONTROL\n", PRODUCT_NAME));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_LINE_CONTROL)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
               
                

            switch (pPort->LineControl & SERIAL_DATA_MASK) 
			{
			case SERIAL_5_DATA: 
				{
                    Lc->WordLength = 5;
                    break;
                }

			case SERIAL_6_DATA: 
				{
                    Lc->WordLength = 6;
                    break;
                }

			case SERIAL_7_DATA: 
				{
                    Lc->WordLength = 7;
                    break;
                }

			case SERIAL_8_DATA: 
				{
                    Lc->WordLength = 8;
                    break;
                }
            }

            switch (pPort->LineControl & SERIAL_PARITY_MASK) 
			{
            case SERIAL_NONE_PARITY: 
				{
                    Lc->Parity = NO_PARITY;
                    break;
                }
                
			case SERIAL_ODD_PARITY: 
				{
                    Lc->Parity = ODD_PARITY;
                    break;
                }

			case SERIAL_EVEN_PARITY: 
				{
                    Lc->Parity = EVEN_PARITY;
                    break;
                }

			case SERIAL_MARK_PARITY: 
				{
                    Lc->Parity = MARK_PARITY;
                    break;
                }

			case SERIAL_SPACE_PARITY: 
				{
                    Lc->Parity = SPACE_PARITY;
                    break;
                }
            }

            if (pPort->LineControl & SERIAL_2_STOP) 
			{
                if(Lc->WordLength == 5) 
					Lc->StopBits = STOP_BITS_1_5;
                else 
				    Lc->StopBits = STOP_BITS_2;
			} 
			else 
			{
                Lc->StopBits = STOP_BIT_1;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_SET_TIMEOUTS: 
		{
            PSERIAL_TIMEOUTS NewTimeouts = ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));

            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_SET_TIMEOUTS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_TIMEOUTS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if((NewTimeouts->ReadIntervalTimeout == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG)) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

            pPort->Timeouts.ReadIntervalTimeout			= NewTimeouts->ReadIntervalTimeout;
            pPort->Timeouts.ReadTotalTimeoutMultiplier	= NewTimeouts->ReadTotalTimeoutMultiplier;
            pPort->Timeouts.ReadTotalTimeoutConstant	= NewTimeouts->ReadTotalTimeoutConstant;
            pPort->Timeouts.WriteTotalTimeoutMultiplier = NewTimeouts->WriteTotalTimeoutMultiplier;
            pPort->Timeouts.WriteTotalTimeoutConstant	= NewTimeouts->WriteTotalTimeoutConstant;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_TIMEOUTS: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_TIMEOUTS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_TIMEOUTS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
               
            *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = pPort->Timeouts;
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_SET_CHARS: 
		{
            SERIAL_IOCTL_SYNC S;
            PSERIAL_CHARS NewChars = ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));
                
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_CHARS\n",PRODUCT_NAME));
            
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_CHARS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // The only thing that can be wrong with the chars
            // is that the xon and xoff characters are the
            // same.
            //

            if(NewChars->XonChar == NewChars->XoffChar) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // We acquire the control lock so that only
            // one request can GET or SET the characters
            // at a time.  The sets could be synchronized
            // by the interrupt spinlock, but that wouldn't
            // prevent multiple gets at the same time.
            //

            S.pPort = pPort;
            S.Data = NewChars;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            //
            // Under the protection of the lock, make sure that
            // the xon and xoff characters aren't the same as
            // the escape character.
            //

            if(pPort->EscapeChar) 
			{
                if ((pPort->EscapeChar == NewChars->XonChar) || (pPort->EscapeChar == NewChars->XoffChar)) 
				{

                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                        
                    break;
                }
            }

			Slxos_SyncExec(pPort,SerialSetChars,&S,0x07);

#ifdef WMI_SUPPORT
			UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_CHARS: 
		{
            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_GET_CHARS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_CHARS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) = pPort->SpecialChars;
            Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

	case IOCTL_SERIAL_SET_DTR:
	case IOCTL_SERIAL_CLR_DTR: 
		{

            //
            // We acquire the lock so that we can check whether
            // automatic DTR flow control is enabled.  If it is
            // then we return an error since the app is not allowed
            // to touch this if it is automatic.
            //
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET/CLR_DTR\n",PRODUCT_NAME));

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
			{
	            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            } 
			else 
			{
				LARGE_INTEGER L = RtlConvertLongToLargeInteger(-10000);

				if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR)
					Slxos_SyncExec(pPort,SerialSetDTR,pPort,0x08);
				else    
					Slxos_SyncExec(pPort,SerialClrDTR,pPort,0x04);

				KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

				//
				// Wait 10 msecs for SLXOS card to respond.
				//				
				KeDelayExecutionThread(KernelMode, FALSE, &L);
            }

            break;
        }
        
	case IOCTL_SERIAL_RESET_DEVICE: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_RESET_DEVICE\n",PRODUCT_NAME));
            break;
        }
        
	case IOCTL_SERIAL_SET_RTS:
	case IOCTL_SERIAL_CLR_RTS: 
		{
            //
            // We acquire the lock so that we can check whether
            // automatic RTS flow control or transmit toggling
            // is enabled.  If it is then we return an error since
            // the app is not allowed to touch this if it is automatic
            // or toggling.
            //

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET/CLR_RTS\n",PRODUCT_NAME));

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if(((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE)
				|| ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK)) == SERIAL_TRANSMIT_TOGGLE) 
			{
	            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            } 
			else 
			{
				LARGE_INTEGER L = RtlConvertLongToLargeInteger(-10000);

			if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_RTS)
				Slxos_SyncExec(pPort, SerialSetRTS, pPort, 0x09);
			else    
				Slxos_SyncExec(pPort, SerialClrRTS, pPort, 0x03);

	            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

				//
				// Wait 10 msecs for SLXOS card to respond.
				//				
				KeDelayExecutionThread(KernelMode, FALSE, &L);
            }

            break;

        }
        
	case IOCTL_SERIAL_SET_XOFF: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_XOFF\n",PRODUCT_NAME));
                
			Slxos_SyncExec(pPort,SerialPretendXoff,pPort,0x0A);
            break;
        }
        
	case IOCTL_SERIAL_SET_XON: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_XON\n", PRODUCT_NAME));
                
			Slxos_SyncExec(pPort,SerialPretendXon,pPort,0x0B);
            break;
        }
        
	case IOCTL_SERIAL_SET_BREAK_ON: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_BREAK_ON\n",PRODUCT_NAME));
                
			Slxos_SyncExec(pPort,SerialTurnOnBreak,pPort,0x0C);
            break;
        }
        
	case IOCTL_SERIAL_SET_BREAK_OFF: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_BREAK_OFF\n"PRODUCT_NAME));
                
		    Slxos_SyncExec(pPort,SerialTurnOffBreak,pPort,0x0D);
            break;
        }
        
	case IOCTL_SERIAL_SET_QUEUE_SIZE: 
		{
            //
            // Type ahead buffer is fixed, so we just validate
            // the the user's request is not bigger than our
            // own internal buffer size.
            //

            PSERIAL_QUEUE_SIZE Rs = ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_QUEUE_SIZE\n",PRODUCT_NAME));
                
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_QUEUE_SIZE)) 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // We have to allocate the memory for the new
            // buffer while we're still in the context of the
            // caller.  We don't even try to protect this
            // with a lock because the value could be stale
            // as soon as we release the lock - the only time
            // we will know for sure is when we actually try
            // to do the resize.
            //

            if (Rs->InSize <= pPort->BufferSize) 
			{
                Status = STATUS_SUCCESS;
                break;
            }

            try 
			{
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer 
					= SpxAllocateMemWithQuota(NonPagedPool, Rs->InSize);
            } 
			except(EXCEPTION_EXECUTE_HANDLER) 
			{
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                Status = GetExceptionCode();
            }

            if (!IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) 
			{
                break;
            }

            //
            // Well the data passed was big enough.  Do the request.
            //
            // There are two reason we place it in the read queue:
            //
            // 1) We want to serialize these resize requests so that
            //    they don't contend with each other.
            //
            // 2) We want to serialize these requests with reads since
            //    we don't want reads and resizes contending over the
            //    read buffer.
            //

            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->ReadQueue,
                       &pPort->CurrentReadIrp,
                       SerialStartRead
                       );

            break;

        }
        
	case IOCTL_SERIAL_GET_WAIT_MASK: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_WAIT_MASK\n",PRODUCT_NAME));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Simple scalar read.  No reason to acquire a lock.
            //

            Irp->IoStatus.Information = sizeof(ULONG);

            *((ULONG *)Irp->AssociatedIrp.SystemBuffer) = pPort->IsrWaitMask;

            break;
        }

	case IOCTL_SERIAL_SET_WAIT_MASK: 
		{
            ULONG NewMask;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_WAIT_MASK\n",PRODUCT_NAME));

            SpxDbgMsg(SERDIAG3 | SERIRPPATH, ("SERIAL: In Ioctl processing for set mask\n"));
                
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
			{
                SpxDbgMsg(SERDIAG3,("SERIAL: Invalid size for the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.InputBufferLength));
                   
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            } 
			else 
			{
                NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
            }

            //
            // Make sure that the mask only contains valid
            // waitable events.
            //

            if (NewMask & ~(SERIAL_EV_RXCHAR   |
                            SERIAL_EV_RXFLAG   |
                            SERIAL_EV_TXEMPTY  |
                            SERIAL_EV_CTS      |
                            SERIAL_EV_DSR      |
                            SERIAL_EV_RLSD     |
                            SERIAL_EV_BREAK    |
                            SERIAL_EV_ERR      |
                            SERIAL_EV_RING     |
                            SERIAL_EV_PERR     |
                            SERIAL_EV_RX80FULL |
                            SERIAL_EV_EVENT1   |
                            SERIAL_EV_EVENT2)) 
			{
                SpxDbgMsg(SERDIAG3, ("SERIAL: Unknown mask %x\n",NewMask));

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Either start this irp or put it on the
            // queue.
            //
            SpxDbgMsg(SERDIAG3 | SERIRPPATH, ("SERIAL: Starting or queuing set mask irp %x\n",Irp));
                
            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->MaskQueue,
                       &pPort->CurrentMaskIrp,
                       SerialStartMask
                       );
        }
        
	case IOCTL_SERIAL_WAIT_ON_MASK: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_WAIT_ON_MASK\n",PRODUCT_NAME));

            SpxDbgMsg(SERDIAG3 | SERIRPPATH,("SERIAL: In Ioctl processing for wait mask\n"));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
                SpxDbgMsg(SERDIAG3,("SERIAL: Invalid size for the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.InputBufferLength));
                    
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Either start this irp or put it on the
            // queue.
            //
            SpxDbgMsg(SERDIAG3 | SERIRPPATH, ("SERIAL: Starting or queuing wait mask irp %x\n",Irp));
                
            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->MaskQueue,
                       &pPort->CurrentMaskIrp,
                       SerialStartMask
                       );
        }
        
	case IOCTL_SERIAL_IMMEDIATE_CHAR: 
		{
            KIRQL OldIrql;
            BOOLEAN FailRequest;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_IMMEDIATE_CHAR\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            IoAcquireCancelSpinLock(&OldIrql);
            
			if(pPort->CurrentImmediateIrp) 
			{
                FailRequest = TRUE;
                Status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = Status;
                IoReleaseCancelSpinLock(OldIrql);
            } 
			else 
			{
                //
                // We can queue the char.  We need to set
                // a cancel routine because flow control could
                // keep the char from transmitting.  Make sure
                // that the irp hasn't already been cancelled.
                //

                if(Irp->Cancel) 
				{
                    IoReleaseCancelSpinLock(OldIrql);
                    Irp->IoStatus.Status = STATUS_CANCELLED;
                    Status = STATUS_CANCELLED;
                } 
				else 
				{
                    pPort->CurrentImmediateIrp = Irp;
                    pPort->TotalCharsQueued++;
                    IoReleaseCancelSpinLock(OldIrql);

                    SerialStartImmediate(pPort);	// Start IRP

                    return STATUS_PENDING;
                }
            }

            break;
        }
        
	case IOCTL_SERIAL_PURGE: 
		{
            ULONG Mask;

            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_PURGE\n",PRODUCT_NAME));
             
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Check to make sure that the mask only has
            // 0 or the other appropriate values.
            //

            Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

            if ((!Mask) || (Mask & (~(SERIAL_PURGE_TXABORT |
                                      SERIAL_PURGE_RXABORT |
                                      SERIAL_PURGE_TXCLEAR |
                                      SERIAL_PURGE_RXCLEAR))))
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // Either start this irp or put it on the queue.
            return SerialStartOrQueue(pPort,Irp, &pPort->PurgeQueue, 
						&pPort->CurrentPurgeIrp, SerialStartPurge);
        }
        
	case IOCTL_SERIAL_GET_HANDFLOW: 
		{
            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_GET_HANDFLOW\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_HANDFLOW)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) = pPort->HandFlow;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_SET_HANDFLOW: 
		{
            SERIAL_IOCTL_SYNC S;
            PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_HANDFLOW\n",PRODUCT_NAME));
               
            //
            // Make sure that the hand shake and control is the
            // right size.
            //
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_HANDFLOW))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Make sure that there are no invalid bits set in
            // the control and handshake.
            //

            if(HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if(HandFlow->FlowReplace & SERIAL_FLOW_INVALID) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Make sure that the app hasn't set an invalid DTR mode.
            //

            if((HandFlow->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Make sure that haven't set totally invalid xon/xoff
            // limits.
            //

            if((HandFlow->XonLimit < 0) || ((ULONG)HandFlow->XonLimit > pPort->BufferSize))
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if((HandFlow->XoffLimit < 0) || ((ULONG)HandFlow->XoffLimit > pPort->BufferSize))
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            S.pPort = pPort;
            S.Data = HandFlow;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            //
            // Under the protection of the lock, make sure that
            // we aren't turning on error replacement when we
            // are doing line status/modem status insertion.
            //

            if(pPort->EscapeChar) 
			{
                if(HandFlow->FlowReplace & SERIAL_ERROR_CHAR) 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    
					KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

                    break;
                }
            }

			Slxos_SyncExec(pPort,SerialSetHandFlow,&S,0x0E);

#ifdef WMI_SUPPORT
			UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_MODEMSTATUS: 
		{
            ULONG ModemControl;
            SERIAL_IOCTL_SYNC S;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_MODEMSTATUS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);

            S.pPort = pPort;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			Slxos_SyncExec(pPort,SerialGetModemUpdate,&S,0x0F);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            break;

        }
        
	case IOCTL_SERIAL_GET_DTRRTS: 
		{
            ULONG ModemControl;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_DTRRTS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Reading this hardware has no effect on the device.
            //

            ModemControl = Slxos_GetModemControl(pPort);

            ModemControl &= SERIAL_DTR_STATE | SERIAL_RTS_STATE;

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;

            break;
        }
        
	case IOCTL_SERIAL_GET_COMMSTATUS: 
		{
            SERIAL_IOCTL_SYNC S;

            SpxDbgMsg( SERDIAG1, ("%s: IOCTL_SERIAL_GET_COMMSTATUS\n",PRODUCT_NAME));
               

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_STATUS))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

            S.pPort = pPort;
            S.Data =  Irp->AssociatedIrp.SystemBuffer;

            //
            // Acquire the cancel spin lock so nothing much
            // changes while we're getting the state.
            //

            IoAcquireCancelSpinLock(&OldIrql);

			Slxos_SyncExec(pPort,SerialGetCommStatus,&S,0x10);

            IoReleaseCancelSpinLock(OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_PROPERTIES: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_PROPERTIES\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_COMMPROP)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // No synchronization is required since this information is "static".
            SerialGetProperties(pPort, Irp->AssociatedIrp.SystemBuffer);

            Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;
        }
        
	case IOCTL_SERIAL_XOFF_COUNTER: 
		{
			PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_XOFF_COUNTER\n",PRODUCT_NAME));
            
            Status = STATUS_NOT_IMPLEMENTED;

			/* 
            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_XOFF_COUNTER)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if(Xc->Counter <= 0) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // So far so good.  Put the irp onto the write queue.
            //

            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->WriteQueue,
                       &pPort->CurrentWriteIrp,
                       SerialStartWrite
                       );
			*/

			break;
        }
        
	case IOCTL_SERIAL_LSRMST_INSERT: 
		{
            PUCHAR escapeChar = Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_LSRMST_INSERT\n",PRODUCT_NAME));
               
            //
            // Make sure we get a byte.
            //

            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if(*escapeChar) 
			{
                //
                // We've got some escape work to do.  We will make sure that
                // the character is not the same as the Xon or Xoff character,
                // or that we are already doing error replacement.
                //

                if((*escapeChar == pPort->SpecialChars.XoffChar) 
					|| (*escapeChar == pPort->SpecialChars.XonChar) 
					|| (pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)) 
				{
                    Status = STATUS_INVALID_PARAMETER;

                    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                        
                    break;
                }
            }

			Slxos_SyncExec(pPort,SerialSetEscapeChar,Irp,0x11);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

        
	case IOCTL_SERIAL_GET_STATS: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
			Irp->IoStatus.Status = STATUS_SUCCESS;

			Slxos_SyncExec(pPort, SerialGetStats, Irp, 0x22);
			break;
		}

    case IOCTL_SERIAL_CLEAR_STATS: 
		{
			Slxos_SyncExec(pPort, SerialClearStats, pPort, 0x23);
			break;
		}


    default: 
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = Status;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,3);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}

VOID
SerialGetProperties(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_COMMPROP Properties
    )

/*++

Routine Description:

    This function returns the capabilities of this particular
    serial device.

Arguments:

    pPort - The serial device extension.

    Properties - The structure used to return the properties

Return Value:

    None.

--*/

{
    SpxDbgMsg(
        SERDIAG1,
        ("%s: SerialGetProperties for %x.\n",
        PRODUCT_NAME,
        pPort->pChannel)
        );

    RtlZeroMemory(
        Properties,
        sizeof(SERIAL_COMMPROP)
        );

    Properties->PacketLength = sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion = 2;
    Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue = 0;
    Properties->MaxRxQueue = 0;

    Properties->MaxBaud = SERIAL_BAUD_USER;
    Properties->SettableBaud = pPort->SupportedBauds;
    if(((PCHAN)pPort->pChannel)->type == SXDC)
    {
	Properties->SettableBaud |= SERIAL_BAUD_134_5;
	Properties->SettableBaud |= SERIAL_BAUD_7200;
	Properties->SettableBaud |= SERIAL_BAUD_14400;
	Properties->SettableBaud |= SERIAL_BAUD_56K;
	Properties->SettableBaud |= SERIAL_BAUD_128K;
    }

    Properties->ProvSubType = SERIAL_SP_RS232;
    Properties->ProvCapabilities = SERIAL_PCF_DTRDSR |
                                   SERIAL_PCF_RTSCTS |
                                   SERIAL_PCF_CD     |
                                   SERIAL_PCF_PARITY_CHECK |
                                   SERIAL_PCF_XONXOFF |
                                   SERIAL_PCF_SETXCHAR |
                                   SERIAL_PCF_TOTALTIMEOUTS |
                                   SERIAL_PCF_INTTIMEOUTS;
    Properties->SettableParams = SERIAL_SP_PARITY |
                                 SERIAL_SP_BAUD |
                                 SERIAL_SP_DATABITS |
                                 SERIAL_SP_STOPBITS |
                                 SERIAL_SP_HANDSHAKING |
                                 SERIAL_SP_PARITY_CHECK |
                                 SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData = SERIAL_DATABITS_5 |
                               SERIAL_DATABITS_6 |
                               SERIAL_DATABITS_7 |
                               SERIAL_DATABITS_8;
    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN |
                                     SERIAL_PARITY_MARK |
                                     SERIAL_PARITY_SPACE;

    Properties->CurrentTxQueue = 0;
    Properties->CurrentRxQueue = pPort->BufferSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\isr.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    isr.c

Abstract:

    This module contains the interrupt service routine for the
    serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the serial port driver.
    It will determine whether the serial port is the source of this
    interrupt.  If it is, then this routine will do the minimum of
    processing to quiet the interrupt.  It will store any information
    necessary for later processing.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We *do not* use this parameter.

    Context - This is really a pointer to the multiport dispatch object
    for this device.

Return Value:

    This function will return TRUE if the serial port is the source
    of this interrupt, FALSE otherwise.

--*/
{
    //
    // Holds the information specific to handling this device.
    //
    PCARD_DEVICE_EXTENSION pCard = Context;

    //
    // Will hold whether we've serviced any interrupt causes in this
    // routine.
    //
    BOOLEAN ServicedAnInterrupt;

    UNREFERENCED_PARAMETER(InterruptObject);

    ServicedAnInterrupt = Slxos_Interrupt(pCard);

    return ServicedAnInterrupt;

}

/*****************************************************************************
*****************************                    *****************************
*****************************   SerialPutBlock   *****************************
*****************************                    *****************************
******************************************************************************

Prototype:	UCHAR	SerialPutBlock(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pBlock,IN UCHAR BlockLen,BOOLEAN Filter)

Description:	Places a block of characters in the user/interrupt buffer and performs flow control
				checks and filtering as necessary.

Parameters:		pPort points to the extension for the current channel
				pBlock points to a contiguous block of bytes
				BlockLen is the length of the block
				Filter indicates if character filtering is to be performed.

Returns:		The number of characters actually queued

NOTE:			This routine is only called at device level.

*/

UCHAR	SerialPutBlock(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pBlock,IN UCHAR BlockLen,BOOLEAN Filter)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	UCHAR					OriginalBlockLen = BlockLen;
    KIRQL					OldIrql;
	ULONG					TransferLen;

/* Skip DSR input sensitivity, as by the time data reaches this routine it is almost certainly */
/* out of synchronization with the data.  This task should be performed by the device itself. */

/* Check to see if the data really needs byte-by-byte filtering... */

	if((Filter)							/* IF Filter is specified */
	&&((pPort->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING)==0)		/* AND NO NULL stripping */
	&&((pPort->IsrWaitMask & (SERIAL_EV_RXCHAR | SERIAL_EV_RXFLAG))==0)	/* AND NO receive any/specific data events */
	&&(pPort->EscapeChar == 0))				/* AND NO Escape character */
		Filter = FALSE;						/* THEN Switch off filtering */

/* Copy as much data as possible into the user buffer... */

	if(pPort->ReadBufferBase != pPort->InterruptReadBuffer)		/* User buffer ? */
	{								/* Yes, must be room for at least one char (by definition) */
		pPort->ReadByIsr++;			/* Increment to inform interval timer read has occurred */

		if(Filter)						/* Filtered transfer */
		{
			while((BlockLen) && (pPort->CurrentCharSlot <= pPort->LastCharSlot))
			{
				TransferLen = SerialTransferReadChar(pPort,pBlock,pPort->CurrentCharSlot);
				pPort->CurrentCharSlot += TransferLen&0xFF;	/* Update buffer pointer */
				pBlock += (TransferLen>>8)&0xFF;			/* Update block pointer */
				BlockLen -= (UCHAR)(TransferLen>>8)&0xFF;	/* Update block length */
			}
		}
		else							/* Non-filtered, optimised transfer */
		{
			TransferLen = pPort->LastCharSlot + 1 - pPort->CurrentCharSlot;/* Calculate available space */
			
			if(TransferLen > BlockLen) 
				TransferLen = BlockLen;	/* Trim to available data */
			
			if(pCard->CardType == SiPCI)
				SpxCopyBytes(pPort->CurrentCharSlot,pBlock,TransferLen);	/* Byte-by-Byte Transfer */
			else	
				RtlMoveMemory(pPort->CurrentCharSlot,pBlock,TransferLen);	/* Optimised Transfer */
			
			pPort->CurrentCharSlot += TransferLen;		/* Update buffer pointer */
			pBlock += TransferLen;						/* Update block pointer */
			BlockLen -= (UCHAR)TransferLen;				/* Update block length */
		}

		if(pPort->CurrentCharSlot > pPort->LastCharSlot)		/* User buffer full */
		{							/* Switch to ISR buffer and complete read */
			pPort->ReadBufferBase		= pPort->InterruptReadBuffer;
			pPort->CurrentCharSlot		= pPort->InterruptReadBuffer;
			pPort->FirstReadableChar	= pPort->InterruptReadBuffer;
			pPort->LastCharSlot			= pPort->InterruptReadBuffer + (pPort->BufferSize - 1);

			KeAcquireSpinLock(&pPort->BufferLock, &OldIrql);
			pPort->CharsInInterruptBuffer = 0;
			KeReleaseSpinLock(&pPort->BufferLock, OldIrql);

			pPort->CurrentReadIrp->IoStatus.Information 
				= IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length;
			
			KeInsertQueueDpc(&pPort->CompleteReadDpc, NULL, NULL);
		}
	}

/* Now, check interrupt buffer and flow off if remaining buffer space is less or equal to user specified limit... */

    if((pPort->BufferSize - pPort->HandFlow.XoffLimit) <= (pPort->CharsInInterruptBuffer + BlockLen))
    {
		if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
			pPort->RXHolding |= SERIAL_RX_DTR;		/* DTR flow off */

		if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE)
			pPort->RXHolding |= SERIAL_RX_RTS;		/* RTS flow off */

		if(pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
			pPort->RXHolding |= SERIAL_RX_XOFF;		/* XOFF flow off */
	}

/* Enqueue characters in the interrupt buffer... */

	if(BlockLen)
	{
		ULONG	CharsInInterruptBufferWas = pPort->CharsInInterruptBuffer;

		if(Filter)
		{
			while((BlockLen) && (pPort->CharsInInterruptBuffer < pPort->BufferSize))
			{
				TransferLen = SerialTransferReadChar(pPort,pBlock,pPort->CurrentCharSlot);
				pPort->CurrentCharSlot += TransferLen&0xFF;	/* Update buffer pointer */

				if(pPort->CurrentCharSlot > pPort->LastCharSlot)	/* Check for buffer wrap */
					pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
				
				KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
				pPort->CharsInInterruptBuffer += TransferLen&0xFF;/* Update buffer count */
				KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
				
				pBlock += (TransferLen>>8)&0xFF;			/* Update block pointer */
				BlockLen -= (UCHAR)(TransferLen>>8)&0xFF;	/* Update block length */
			}
		}
		else							/* Non-filtered, optimised transfer */
		{
			while(BlockLen)
			{
				TransferLen = pPort->BufferSize - pPort->CharsInInterruptBuffer;	/* Calculate available space */
				
				if(TransferLen == 0) 
					break;					/* No space left */
				
				if(TransferLen > (ULONG)(pPort->LastCharSlot + 1 - pPort->CurrentCharSlot)) /* Does space wrap ? */
					TransferLen = pPort->LastCharSlot + 1 - pPort->CurrentCharSlot;	/* Yes */
				
				if(TransferLen > BlockLen) 
					TransferLen = BlockLen;		/* Trim to available data */
				
				if(pCard->CardType == SiPCI)
					SpxCopyBytes(pPort->CurrentCharSlot,pBlock,TransferLen);	/* Byte-by-Byte Transfer */
				else	
					RtlMoveMemory(pPort->CurrentCharSlot,pBlock,TransferLen);/* Optimised Transfer */
				
				pPort->CurrentCharSlot += TransferLen;				/* Update buffer pointer */
				
				if(pPort->CurrentCharSlot > pPort->LastCharSlot)			/* Check for buffer wrap */
					pPort->CurrentCharSlot = pPort->InterruptReadBuffer;

				KeAcquireSpinLock(&pPort->BufferLock, &OldIrql);
				pPort->CharsInInterruptBuffer += TransferLen;			/* Update buffer count */
				KeReleaseSpinLock(&pPort->BufferLock, OldIrql);
				
				pBlock += TransferLen;						/* Update block pointer */
				BlockLen -= (UCHAR)TransferLen;					/* Update block length */
			}
		}

/* Check for 80% full... */

		if((CharsInInterruptBufferWas < pPort->BufferSizePt8)		/* If buffer WAS < 80% */
		&&(pPort->CharsInInterruptBuffer >= pPort->BufferSizePt8)	/* AND is now >= 80% */
		&&(pPort->IsrWaitMask & SERIAL_EV_RX80FULL))				/* AND someone is waiting for this */
		{
			pPort->HistoryMask |= SERIAL_EV_RX80FULL;

			if(pPort->IrpMaskLocation)
			{
				*pPort->IrpMaskLocation = pPort->HistoryMask;
				pPort->IrpMaskLocation = NULL;
				pPort->HistoryMask = 0;
				pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
				KeInsertQueueDpc(&pPort->CommWaitDpc,NULL,NULL);
			}
		}

/* Check for and handle buffer full... */

		if((pPort->CharsInInterruptBuffer >= pPort->BufferSize)			/* If no more room */
		&&(BlockLen)													/* AND more data to queue */
		&&((pPort->RXHolding & (SERIAL_RX_DTR | SERIAL_RX_RTS | SERIAL_RX_XOFF)) == 0))	/* AND NOT flowed off */
		{
			pBlock += BlockLen;				/* Discard remaining data */
			BlockLen = 0;					/* Update block length */
			pPort->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
			pPort->PerfStats.BufferOverrunErrorCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.BufferOverrunErrorCount++;
#endif

			if(pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
			{						/* Store error char in last buffer position */
				if(pPort->CurrentCharSlot == pPort->InterruptReadBuffer)
					pPort->InterruptReadBuffer[pPort->BufferSize-1] = pPort->SpecialChars.ErrorChar;
				else	
					pPort->CurrentCharSlot[-1] = pPort->SpecialChars.ErrorChar;
			}

			if(pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) /* Queue error Dpc */
				KeInsertQueueDpc(&pPort->CommErrorDpc, NULL, NULL);
		}

	} /* if(BlockLen) */

/* If the xoff counter is non-zero then decrement it and if zero, complete that irp... */

	if(pPort->CountSinceXoff)
	{
		if(pPort->CountSinceXoff <= (long)(OriginalBlockLen - BlockLen))
		{
			pPort->CurrentXoffIrp->IoStatus.Status = STATUS_SUCCESS;
			pPort->CurrentXoffIrp->IoStatus.Information = 0;
			KeInsertQueueDpc(&pPort->XoffCountCompleteDpc, NULL, NULL);
		}
		else
		{
			pPort->CountSinceXoff -= (OriginalBlockLen - BlockLen);
		}
	}

	pPort->PerfStats.ReceivedCount += (OriginalBlockLen - BlockLen);	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
	pPort->WmiPerfData.ReceivedCount += (OriginalBlockLen - BlockLen);
#endif

	return(OriginalBlockLen - BlockLen);				/* Return amount of data transferred */

} /* SerialPutBlock */

/*****************************************************************************
*************************                            *************************
*************************   SerialTransferReadChar   *************************
*************************                            *************************
******************************************************************************

Prototype:	USHORT	SerialTransferReadChar(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pFrom,IN PUCHAR pTo)

Description:	Copies a character from pFrom to pTo after filtering with:
				Data mask
				NULL stripping
				Wait for any character
				Wait for specific character
				ESCape character

Parameters:		pPort points to the extension for the current channel
				pFrom points to buffer to copy from
				pTo points to buffer to copy to

Returns:		Top byte = amount to adjust "From" buffer
				Bottom byte = amount to adjust "To" buffer

NOTE:	This routine is only called at device level.

*/

USHORT	SerialTransferReadChar(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pFrom,IN PUCHAR pTo)
{
	UCHAR	ReadChar;

/* Check for escape character insertion... */

	if(pPort->InsertEscChar)
	{
		*pTo = SERIAL_LSRMST_ESCAPE;			/* Insert extra escape character */
		pPort->InsertEscChar = FALSE;			/* Reset flag */
		return(0x0001);					/* Update "To" buffer only */
	}

	ReadChar = *pFrom;					/* Get read character */

/* Check for null stripping... */

	if(!ReadChar && (pPort->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING))
		return(0x0100);					/* Update "From" buffer only */

/* Check for waiting events... */

	if(pPort->IsrWaitMask)
	{
		if(pPort->IsrWaitMask & SERIAL_EV_RXCHAR)	/* Wait for any character */
			pPort->HistoryMask |= SERIAL_EV_RXCHAR;

		if((pPort->IsrWaitMask & SERIAL_EV_RXFLAG)	/* Wait for specific character */
		&&(pPort->SpecialChars.EventChar == ReadChar))
			pPort->HistoryMask |= SERIAL_EV_RXFLAG;

		if(pPort->IrpMaskLocation && pPort->HistoryMask)	/* Wake up waiting IRP */
		{
			*pPort->IrpMaskLocation = pPort->HistoryMask;
			pPort->IrpMaskLocation = NULL;
			pPort->HistoryMask = 0;
			pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
			KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
		}
	}

/* Check for escape character in normal data... */

	if(pPort->EscapeChar&&(pPort->EscapeChar==ReadChar))
		pPort->InsertEscChar = TRUE;		/* Set flag to insert extra escape character */

/* Store character... */

	*pTo = ReadChar;					/* Store character */
	return(0x0101);						/* Update both "To" and "From" buffers */

} /* SerialTransferReadChar */


UCHAR
SerialProcessLSR(
    IN PPORT_DEVICE_EXTENSION pPort, UCHAR LineStatus
    )

/*++

Routine Description:

    This routine, which only runs at device level, totally
    processes everything that might have changed in the
    line status register.

Arguments:

    pPort - The serial device extension.

    LineStatus - The line status register.

Return Value:

    The value of the line status register.

--*/

{
    SpxDbgMsg(
        SERDIAG1,
        ("%s: In SerialProcessLSR() for %x. "
        "LineStatus = %x.\n",
		PRODUCT_NAME,
        pPort->pChannel,
        LineStatus)
        );
        
    //
    // We have some sort of data problem in the receive.  For any of these
    // errors we may abort all current reads and writes.
    //
    //
    // If we are inserting the value of the line status into the data stream
    // then we should put the escape character in now.
    //

    if(pPort->EscapeChar) 
	{
		UCHAR EscapeString[3] = {pPort->EscapeChar, SERIAL_LSRMST_LSR_NODATA, LineStatus};

		SerialPutBlock(pPort,EscapeString,3,FALSE);
    }

    if(LineStatus & SERIAL_LSR_OE)		// Hardware Overrun Error? 
	{
		pPort->ErrorWord |= SERIAL_ERROR_OVERRUN;	// Yes 
		pPort->PerfStats.SerialOverrunErrorCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
		pPort->WmiPerfData.SerialOverrunErrorCount++;
#endif
	}

    if(LineStatus & SERIAL_LSR_BI) 
	{
        pPort->ErrorWord |= SERIAL_ERROR_BREAK;

        if(pPort->HandFlow.FlowReplace & SERIAL_BREAK_CHAR) 
		    SerialPutBlock(pPort,&pPort->SpecialChars.BreakChar,1,FALSE);
    }
    else
    {
		if(LineStatus & SERIAL_LSR_PE)	// Parity Error ? 
		{
			pPort->ErrorWord |= SERIAL_ERROR_PARITY;	// Yes 
			pPort->PerfStats.ParityErrorCount++;		// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.ParityErrorCount++;
#endif
		}

		if(LineStatus & SERIAL_LSR_FE)	// Framing Error ? 
		{
			pPort->ErrorWord |= SERIAL_ERROR_FRAMING;	// Yes 
			pPort->PerfStats.FrameErrorCount++;			// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.FrameErrorCount++;
#endif
		}
    }

    //
    // If the application has requested it, abort all the reads and writes
    // on an error.
    //

    if(pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) 
	{
        KeInsertQueueDpc(&pPort->CommErrorDpc, NULL, NULL);
    }

    //
    // Check to see if we have a wait pending on the comm error events.  If
    // we do then we schedule a DPC to satisfy that wait.
    //

    if(pPort->IsrWaitMask) 
	{
		if((pPort->IsrWaitMask & SERIAL_EV_ERR)
		&&(LineStatus & (SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE)))
		{
			pPort->HistoryMask |= SERIAL_EV_ERR;
		}

        if((pPort->IsrWaitMask & SERIAL_EV_BREAK) && (LineStatus & SERIAL_LSR_BI)) 
		{
            pPort->HistoryMask |= SERIAL_EV_BREAK;
        }

        if (pPort->IrpMaskLocation && pPort->HistoryMask) 
		{
            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
 
        }
    }

    return LineStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//  Precompiled Header
/////////////////////////////////////////////////////////////////////////////

#include <ntddk.h>
#include <ntddser.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#define USE_NEW_TX_BUFFER_EMPTY_DETECT  1

#define WMI_SUPPORT // Include WMI Support code
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>


// Structures and definitions.
#include "sx_ver.h" // Dirver Version Information
#include "spx_defs.h"   // Definitions
#include "sx_defs.h"    // SX Specific Definitions
#include "spx_card.h"   // Common Card Info
#include "sx_card.h"    // SX card and port device extension structures
#include "spx_misc.h"   // Misc 

// SX specific function prototypes
#include "serialp.h"    // Exportable Function Prototypes
#include "slxosexp.h"   // SI/XIO/SX Exported Function Prototypes
#include "slxos_nt.h"   // SI/XIO/SX Family Card Definitions

// Common PnP function prototypes.
#include "spx.h"    // Common PnP header

//
// MS change 8/14/00
// In the sources file we specify only i386 sources, but IA64 still
// precompiles the headers.  Since spx_log.h is generated, it won't
// be here for IA64
//

#if defined(i386)
#include "sx_log.h"  // I/O8+ Specific Error Log Messages
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\immediat.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    immediat.c

Abstract:

    This module contains the code that is very specific to transmit
    immediate character operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

VOID
SerialGetNextImmediate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    );



VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will calculate the timeouts needed for the
    write.  It will then hand the irp off to the isr.  It
    will need to be careful in case the irp has been cancelled.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;


    UseATimer = FALSE;
    pPort->CurrentImmediateIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pPort->CurrentImmediateIrp);

    //
    // Calculate the timeout value needed for the request.  Note that the
    // values stored in the timeout record are in milliseconds. Note that
    // if the timeout values are zero then we won't start the timer.
    //

    KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);
        

    Timeouts = pPort->Timeouts;

    KeReleaseSpinLock(&pPort->ControlLock,OldIrql);
        

    if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier) 
	{

        UseATimer = TRUE;

        //
        // We have some timer values to calculate.
        //

        TotalTime = RtlEnlargedUnsignedMultiply(1,Timeouts.WriteTotalTimeoutMultiplier);

        TotalTime = RtlLargeIntegerAdd(TotalTime,RtlConvertUlongToLargeInteger(Timeouts.WriteTotalTimeoutConstant));

        TotalTime = RtlExtendedIntegerMultiply(TotalTime,-10000);

    }

    //
    // As the irp might be going to the isr, this is a good time
    // to initialize the reference count.
    //

    SERIAL_INIT_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // We need to see if this irp should be cancelled.
    //

    IoAcquireCancelSpinLock(&OldIrql);

    if(pPort->CurrentImmediateIrp->Cancel) 
	{
        PIRP OldIrp = pPort->CurrentImmediateIrp;

        pPort->CurrentImmediateIrp = NULL;
        IoReleaseCancelSpinLock(OldIrql);

        OldIrp->IoStatus.Status = STATUS_CANCELLED;
        OldIrp->IoStatus.Information = 0;

        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",OldIrp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(OldIrp,1);
#endif
		SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(OldIrp, 0);
    } 
	else 
	{

        //
        // We give the irp to to the isr to write out.  We set a cancel
        // routine that knows how to grab the current write away from the isr.
        //

        IoSetCancelRoutine(pPort->CurrentImmediateIrp, SerialCancelImmediate);
            

        //
        // Since the cancel routine knows about the irp we
        // increment the reference count.
        //

        SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);

        if(UseATimer) 
		{
            KeSetTimer(&pPort->ImmediateTotalTimer, TotalTime, &pPort->TotalImmediateTimeoutDpc);
                
            //
            // Since the timer knows about the irp we increment
            // the reference count.
            //

            SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);
        }

		Slxos_SyncExec(pPort,SerialGiveImmediateToIsr,pPort,0x00);

        IoReleaseCancelSpinLock(OldIrql);

    }

}

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabImmediateFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

VOID
SerialGetNextImmediate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This routine is used to complete the current immediate
    irp.  Even though the current immediate will always be
    completed and there is no queue associated with it, we
    use this routine so that we can try to satisfy a wait
    for transmit queue empty event. 

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.  This should point
                   to CurrentImmediateIrp.

    QueueToProcess - Always NULL.

    NewIrp - Always NULL on exit to this routine.

    CompleteCurrent - Should always be true for this routine.


Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PIRP OldIrp;

    UNREFERENCED_PARAMETER(QueueToProcess);
    UNREFERENCED_PARAMETER(CompleteCurrent);

    pPort = CONTAINING_RECORD(CurrentOpIrp, PORT_DEVICE_EXTENSION, CurrentImmediateIrp);
	OldIrp = *CurrentOpIrp;

    IoAcquireCancelSpinLock(&OldIrql);

    ASSERT(pPort->TotalCharsQueued >= 1);
    pPort->TotalCharsQueued--;

    *CurrentOpIrp = NULL;
    *NewIrp = NULL;

    Slxos_SyncExec(pPort,SerialProcessEmptyTransmit,pPort,0x01);

    IoReleaseCancelSpinLock(OldIrql);

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",OldIrp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(OldIrp,2);
#endif

	SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(OldIrp, IO_SERIAL_INCREMENT);

}

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel an irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabImmediateFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TransmitImmediate = TRUE;
    pPort->ImmediateChar = *((UCHAR *) (pPort->CurrentImmediateIrp->AssociatedIrp.SystemBuffer));
       

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // Check first to see if a write is going on.  If
    // there is then we'll just slip in during the write.
    //

    if(!pPort->WriteLength) 
	{
        //
        // If there is no normal write transmitting then we will poll the
        // board (which we can do at any time).  Otherwise, we know the board
        // will interrupt us in due course.
        //

        Slxos_PollForInterrupt(pPort->pParentCardExt,FALSE);
    }

    return FALSE;

}

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or cancelling, from the ISR.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->TransmitImmediate) 
	{

        pPort->TransmitImmediate = FALSE;

        //
        // Since the isr no longer references this irp, we can
        // decrement its reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentImmediateIrp);
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\openclos.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module contains the code that is very specific to
    opening, closing, and cleaning up in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    );

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    );

//
// Just a bogus little routine to make sure that we
// can synch with the ISR.
//
BOOLEAN
SerialNullSynch(
    IN PVOID Context
    ) {

    UNREFERENCED_PARAMETER(Context);
    return FALSE;
}

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We connect up to the interrupt for the create/open and initialize
    the structures needed to maintain an open for a device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialCreateOpen dispatch entry for: %x\n",Irp));
    SpxDbgMsg(SERDIAG3,("SERIAL: In SerialCreateOpen\n"));

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

	if(DeviceObject->DeviceType != FILE_DEVICE_SERIAL_PORT)	
	{
	    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return(STATUS_NO_SUCH_DEVICE);
	}

    //
    // Before we do anything, let's make sure they aren't trying
    // to create a directory.  This is a silly, but what's a driver to do!?
    //

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE)
	{
        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;

        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,4);
#endif
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_NOT_A_DIRECTORY;
    }

    //
    // Create a buffer for the RX data when no reads are outstanding.
    //

    pPort->InterruptReadBuffer = NULL;
    pPort->BufferSize = 0;

    switch (MmQuerySystemSize()) 
	{
        case MmLargeSystem: 
			{
				pPort->BufferSize = 4096;
				pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
                                                 
				if(pPort->InterruptReadBuffer) 
				{
					break;
				}
			}

        case MmMediumSystem: 
			{
				pPort->BufferSize = 1024;
				pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
                                                
				if(pPort->InterruptReadBuffer) 
				{
					break;
				}

			}

        case MmSmallSystem: 
			{
				pPort->BufferSize = 128;
				pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
			}

    }

    if (!pPort->InterruptReadBuffer) 
	{
        pPort->BufferSize = 0;
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,5);
#endif
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
            
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // On a new open we "flush" the read queue by initializing the
    // count of characters.
    //

    {
    	KIRQL	OldIrql;
		KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
		pPort->CharsInInterruptBuffer = 0;
		KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    pPort->LastCharSlot = pPort->InterruptReadBuffer + (pPort->BufferSize - 1);
                              

    pPort->ReadBufferBase = pPort->InterruptReadBuffer;
    pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
    pPort->FirstReadableChar = pPort->InterruptReadBuffer;
    pPort->TotalCharsQueued = 0;

	Slxos_SyncExec(pPort,SpxClearAllPortStats,pPort,0x24);

    //
    // We set up the default xon/xoff limits.
    //

    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));
                                   

    pPort->IrpMaskLocation = NULL;
    pPort->HistoryMask = 0;
    pPort->IsrWaitMask = 0;

    //
    // The escape char replacement must be reset upon every open.
    //

    pPort->EscapeChar = 0;
    pPort->InsertEscChar = FALSE;

    Irp->IoStatus.Status = STATUS_SUCCESS;

    Slxos_SyncExec(pPort,SerialMarkOpen,pPort,0x14);

    Irp->IoStatus.Information = 0L;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,6);
#endif
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

VOID
SerialWaitForTxToDrain(
    IN PPORT_DEVICE_EXTENSION pPort
    )
/*++

Routine Description:

    Wait (via KeDelayExecutionThread) for the transmit buffer to drain.

Arguments:

    pPort - The device extension

Return Value:

    None.

--*/
{
    //
    // This "timer value" is used to wait until the hardware is
    // empty.
    //
    LARGE_INTEGER nCharDelay;

    //
    // Holds a character time.
    //
    LARGE_INTEGER charTime;

    //
    // Used to hold the number of characters in the transmit hardware.
    //
    ULONG nChars;

    charTime = RtlLargeIntegerNegate(SerialGetCharTime(pPort));

/* Calculate the number of characters still to transmit... */

	nChars = Slxos_GetCharsInTxBuffer(pPort);	/* Number of characters waiting  */
	nChars += 10;					/* Plus a bit */

/* Wait for the time it would take the characters to drain... */

	while(Slxos_GetCharsInTxBuffer(pPort))	/* While chars in tx buffer */
	{
		KeDelayExecutionThread(KernelMode,FALSE,&charTime);	/* Wait one char time */
		
		if(nChars-- == 0)					/* Timeout */
			break;
	}

/* ESIL_0925 08/11/99 */
	Slxos_SyncExec(pPort,Slxos_FlushTxBuff,pPort,0x25);		/* Flush buffer */
/* ESIL_0925 08/11/99 */

}

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We simply disconnect the interrupt for now.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // This "timer value" is used to wait 10 character times before
    // we actually "run down" all of the flow control/break junk.
    //
    LARGE_INTEGER nCharDelay;

    //
    // Holds a character time.
    //
    LARGE_INTEGER charTime;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialClose dispatch entry for: %x\n",Irp));
    SpxDbgMsg(SERDIAG3,("SERIAL: In SerialClose\n"));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    charTime = RtlLargeIntegerNegate(SerialGetCharTime(pPort));

    //
    // Synchronize with the ISR to let it know that interrupts are
    // no longer important.
    //

    Slxos_SyncExec(pPort,SerialMarkClose,pPort,0x15);

    //
    // Synchronize with the isr to turn off break if it
    // is already on.
    //

    Slxos_SyncExec(pPort,SerialTurnOffBreak,pPort,0x0D);

    //
    // If the driver has automatically transmitted an Xoff in
    // the context of automatic receive flow control then we
    // should transmit an Xon.
    //

    if(pPort->RXHolding & SERIAL_RX_XOFF) 
        Slxos_SendXon(pPort);

    //
    // Wait until all characters have been emptied out of the hardware.
    //
    SerialWaitForTxToDrain(pPort);

    //
    // The hardware is empty.  Delay 10 character times before
    // shut down all the flow control.
    //
    nCharDelay = RtlExtendedIntegerMultiply(charTime,10);

    KeDelayExecutionThread(KernelMode, TRUE, &nCharDelay);
        
    SerialClrDTR(pPort);
    SerialClrRTS(pPort);

    //
    // Tell the hardware the device is closed.
    //

    Slxos_DisableAllInterrupts(pPort);


    //
    // Clean out the holding reasons (since we are closed).
    //

    pPort->RXHolding = 0;
    pPort->TXHolding = 0;

    //
    // All is done.  The port has been disabled from interrupting
    // so there is no point in keeping the memory around.
    //

    pPort->BufferSize = 0;
    SpxFreeMem(pPort->InterruptReadBuffer);
    pPort->InterruptReadBuffer = NULL;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,7);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine sets a boolean to true to mark the fact that somebody
    opened the device and it's worthwhile to pay attention to
    interrupts.  It also tells the hardware that the device is open.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

	pPort->DataInTxBuffer = FALSE;		// Reset flag to show that buffer is empty.

    // Open the board
    Slxos_EnableAllInterrupts(pPort);

    // Configure Channel.
    Slxos_ResetChannel(pPort);

    pPort->DeviceIsOpen = TRUE;
    pPort->ErrorWord = 0;


#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
	pPort->WmiCommData.IsBusy = TRUE;
#endif

    return FALSE;

}

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine merely sets a boolean to false to mark the fact that
    somebody closed the device and it's no longer worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->DeviceIsOpen = FALSE;

#ifdef WMI_SUPPORT
	pPort->WmiCommData.IsBusy	= FALSE;
#endif

    return FALSE;

}

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is used to kill all longstanding IO operations.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    KIRQL oldIrql;

    SpxDbgMsg(SERIRPPATH, ("SERIAL: SerialCleanup dispatch entry for: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
        

    //
    // First kill all the reads and writes.
    //

    SerialKillAllReadsOrWrites(DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);
        
    //
    // Next get rid of purges.
    //

    SerialKillAllReadsOrWrites(DeviceObject, &pPort->PurgeQueue, &pPort->CurrentPurgeIrp);
        

    //
    // Get rid of any mask operations.
    //

    SerialKillAllReadsOrWrites(DeviceObject, &pPort->MaskQueue, &pPort->CurrentMaskIrp);

    //
    // Now get rid a pending wait mask irp.
    //

    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CurrentWaitIrp) 
	{
        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pPort->CurrentWaitIrp->CancelRoutine;
        pPort->CurrentWaitIrp->Cancel = TRUE;

        if(cancelRoutine) 
		{
            pPort->CurrentWaitIrp->CancelIrql = oldIrql;
            pPort->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(DeviceObject, pPort->CurrentWaitIrp);
        }
    } 
	else 
	{
        IoReleaseCancelSpinLock(oldIrql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,8);
#endif


	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

LARGE_INTEGER
SerialGetCharTime(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.

Arguments:

    pPort - Just what it says.

Return Value:

    100 nanosecond intervals in a character time.

--*/

{

    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;

    switch (pPort->LineControl & SERIAL_DATA_MASK) 
	{
        case SERIAL_5_DATA:
            dataSize = 5;
            break;

        case SERIAL_6_DATA:
            dataSize = 6;
            break;

        case SERIAL_7_DATA:
            dataSize = 7;
            break;

        case SERIAL_8_DATA:
            dataSize = 8;
            break;
    }

    paritySize = 1;

    if((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_NONE_PARITY)
        paritySize = 0;


    if (pPort->LineControl & SERIAL_2_STOP) 
	{
        // Even if it is 1.5, for sanity's sake we're going to say 2.
        stopSize = 2;
    } 
	else 
	{
        stopSize = 1;
    }

    //
    // First we calculate the number of 100 nanosecond intervals which
    // are in a single bit time (approximately).  Then multiply by the
    // number of bits in a character (start, data, parity, and stop bits).
    //

    bitTime = (10000000+(pPort->CurrentBaud-1))/pPort->CurrentBaud;
    charTime = (1 + dataSize + paritySize + stopSize) * bitTime;

    return RtlConvertUlongToLargeInteger(charTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\si2_z280.c ===
/* SI2_Z280.C Version, Bootstrap and Download Code Arrays... */

char *si2_z280_ident = "%W%";

/* SI2_Z280 embedded version... 

	Copyright (c) Specialix Research Ltd 1988-1998
	Z280 Download Code Version 1.43
	

*/

unsigned char si2_z280_download[] =
{
	0x00,0xC3,0x86,0x00,0x02,0x00,0x08,0x01,	/* 0000: ...... */
	0x00,0x00,0x88,0x18,0x00,0x00,0x8C,0x18,	/* 0008: ...... */
	0x00,0x00,0xF6,0x1A,0x00,0x00,0xC5,0x04,	/* 0010: ...... */
	0x02,0x00,0x08,0x01,0x02,0x00,0x08,0x01,	/* 0018: ........ */
	0x02,0x00,0x08,0x01,0x02,0x00,0x08,0x01,	/* 0020: ........ */
	0x02,0x00,0x08,0x01,0x00,0x00,0xED,0x0F,	/* 0028: ....... */
	0x00,0x00,0x0C,0x10,0x02,0x00,0x08,0x01,	/* 0030: ........ */
	0x02,0x00,0x08,0x01,0x00,0x00,0x00,0x00,	/* 0038: ........ */
	0x20,0x00,0x00,0x01,0x00,0x3C,0x00,0x00,	/* 0040:  ....<.. */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0048: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0050: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0058: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0060: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0068: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0070: ........ */
	0x00,0x3A,0x47,0x00,0xFE,0x00,0xC2,0x08,	/* 0078: .:G... */
	0x01,0xDD,0x3E,0x48,0x00,0x01,0x31,0xBF,	/* 0080: .>H..1 */
	0x00,0xC3,0x2A,0x13,0xFF,0xFF,0xFF,0xFF,	/* 0088: .*. */
	0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xCC,	/* 0090: ...... */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 0098:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 00A0:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 00A8:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 00B0:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x3A,	/* 00B8: : */
	0x41,0x00,0xFE,0x00,0xC2,0x2A,0x13,0x21,	/* 00C0: A..*.! */
	0x00,0x08,0x0E,0xF0,0xED,0xBF,0x00,0x00,	/* 00C8: ..... */
	0x00,0x21,0x40,0x00,0x0E,0x12,0xED,0x6E,	/* 00D0: .!@...n */
	0x3A,0x92,0x00,0xFE,0x01,0x20,0x05,0x21,	/* 00D8: :.. .! */
	0xC2,0x05,0x18,0x03,0x21,0x8C,0x18,0x7D,	/* 00E0: ...!.} */
	0xE6,0xF0,0x6F,0x3E,0x00,0x46,0x23,0x3D,	/* 00E8: o>.F#= */
	0xFE,0x00,0x20,0xF9,0x21,0x80,0x00,0x0E,	/* 00F0: . !.. */
	0x12,0xED,0x6E,0xDD,0x3E,0x47,0x00,0x01,	/* 00F8: .n>G.. */
	0xCD,0x15,0x01,0x00,0x18,0xFE,0x00,0x00,	/* 0100: ...... */
	0xDD,0xD1,0x06,0x01,0xED,0x55,0xDD,0x3E,	/* 0108: ..U> */
	0x00,0x00,0xFE,0x76,0xC9,0xCD,0xF9,0x01,	/* 0110: ..v. */
	0xFE,0x01,0x20,0x03,0xCD,0x89,0x04,0xC9,	/* 0118: . .. */
	0xE0,0x81,0x80,0x80,0x00,0x00,0x00,0x00,	/* 0120: .... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0128: ........ */
	0x8C,0x00,0xF0,0xD0,0x00,0xF0,0x00,0xC0,	/* 0130: ... */
	0x00,0x00,0xF0,0xD0,0x00,0xF0,0x00,0xC0,	/* 0138: .... */
	0x00,0x00,0x21,0x0D,0x00,0x0E,0xFF,0xED,	/* 0140: ..!... */
	0x6E,0x21,0xF8,0x2F,0x11,0x0E,0x80,0x01,	/* 0148: n!.... */
	0x08,0x00,0xED,0xB0,0x2A,0x43,0x00,0x0E,	/* 0150: ..*C.. */
	0xFF,0xED,0x6E,0xDD,0x3E,0x16,0x80,0x00,	/* 0158: n>.. */
	0xC9,0x79,0xFE,0x00,0x28,0x2A,0xED,0x2D,	/* 0160: y.(*- */
	0xA0,0xFF,0xED,0x2A,0x00,0x00,0x3A,0x2F,	/* 0168: *..:. */
	0x01,0xFE,0x40,0x20,0x07,0xFD,0xED,0xF6,	/* 0170: .@ . */
	0xA0,0x18,0x18,0x05,0xFD,0xED,0xF6,0xA0,	/* 0178: ... */
	0x02,0xDD,0x2A,0x24,0x01,0xED,0x2D,0x00,	/* 0180: .*$.-. */
	0x00,0xE5,0xDD,0xE1,0xDD,0x22,0x24,0x01,	/* 0188: ."$. */
	0x78,0x32,0x2F,0x01,0xED,0x2A,0x00,0x00,	/* 0190: x2..*.. */
	0xDD,0x01,0x00,0x00,0xDD,0x73,0x08,0xDD,	/* 0198: ...s. */
	0x36,0x1C,0x00,0xDD,0x36,0x1D,0x00,0x7B,	/* 01A0: 6..6..{ */
	0xE6,0x0F,0xDD,0x77,0x02,0xDD,0x71,0x03,	/* 01A8: .w.q. */
	0xFD,0xED,0x2D,0x06,0x00,0x7B,0xE6,0xE0,	/* 01B0: -..{ */
	0xFE,0x00,0x20,0x08,0xDD,0x36,0x04,0x00,	/* 01B8: . .6.. */
	0xFD,0x36,0x40,0xFF,0xDD,0xE5,0xFD,0x7E,	/* 01C0: 6@~ */
	0x7F,0xDD,0x77,0x1E,0x3E,0x08,0xED,0x2A,	/* 01C8: w.>.* */
	0x0A,0x00,0xDD,0xED,0x2A,0x60,0x01,0xDD,	/* 01D0: ..*`. */
	0xE5,0xDD,0xC1,0x3D,0x28,0x0C,0xDD,0xED,	/* 01D8: =(. */
	0x2A,0x00,0x03,0xFD,0xED,0xF6,0x02,0x00,	/* 01E0: *.... */
	0x18,0xED,0xDD,0xE1,0xED,0x2A,0x00,0x00,	/* 01E8: .*.. */
	0xFD,0xED,0xF6,0x60,0x01,0xE5,0xDD,0xE1,	/* 01F0: `. */
	0xC9,0x21,0x40,0x00,0x5E,0xDD,0x11,0x02,	/* 01F8: !@.^.. */
	0x80,0xFF,0xFF,0xDD,0x3E,0x06,0x80,0x01,	/* 0200: >.. */
	0xDD,0x3E,0x82,0x80,0x00,0xDD,0x21,0x80,	/* 0208: >.! */
	0x80,0xDD,0x22,0x24,0x01,0xFD,0x21,0x00,	/* 0210: "$.!. */
	0x70,0xFD,0x22,0x28,0x01,0x0E,0x00,0x16,	/* 0218: p"(.... */
	0x01,0xE5,0x2A,0x30,0x01,0x7E,0xDD,0x13,	/* 0220: .*0.~. */
	0x30,0x01,0xE1,0xFE,0xFF,0xCA,0x76,0x03,	/* 0228: 0.v. */
	0x5F,0xFE,0x04,0x28,0x10,0xFE,0x24,0x28,	/* 0230: _.(.$( */
	0x0C,0x06,0x08,0xDD,0x3E,0x2E,0x01,0x08,	/* 0238: ...>... */
	0xCD,0x61,0x01,0x18,0x0C,0x06,0x04,0xDD,	/* 0240: a..... */
	0x3E,0x2E,0x01,0x04,0xCD,0x61,0x01,0x18,	/* 0248: >...a.. */
	0x00,0x21,0xA0,0x02,0xDD,0x0E,0x00,0x2B,	/* 0250: .!...+ */
	0xFD,0xED,0xF7,0xA0,0xFF,0x20,0xF5,0xFD,	/* 0258:   */
	0xED,0x2D,0xA2,0xFF,0xDD,0x36,0xC2,0xFF,	/* 0260: -6 */
	0x7B,0xE6,0xE0,0xDD,0x77,0xC4,0xFE,0x00,	/* 0268: {w. */
	0x20,0x2A,0xED,0x32,0x00,0x00,0xCB,0x9D,	/* 0270:  *2.. */
	0xFD,0x36,0x02,0x0A,0xFD,0x1E,0x04,0x00,	/* 0278: 6..... */
	0xE0,0xFD,0x1E,0x05,0x00,0x00,0xCD,0xD6,	/* 0280: .... */
	0x1D,0xFD,0x7B,0x0E,0x00,0xFD,0x1E,0x0D,	/* 0288: .{.... */
	0x00,0x00,0xFD,0x36,0x02,0x90,0xDD,0x36,	/* 0290: ..6.6 */
	0xA6,0x01,0x18,0x00,0xDD,0x36,0xAE,0x10,	/* 0298: ...6. */
	0xDD,0x36,0xBF,0x01,0xDD,0x72,0xAF,0x2A,	/* 02A0: 6.r* */
	0x24,0x01,0xED,0x2D,0xA4,0xFF,0x3A,0x2E,	/* 02A8: $.-:. */
	0x01,0x90,0xDD,0x77,0xA7,0xFE,0x04,0xFA,	/* 02B0: .w. */
	0xC9,0x02,0xFD,0x7E,0x7F,0xE6,0xF0,0xCB,	/* 02B8: .~ */
	0x3F,0xCB,0x3F,0xCB,0x3F,0xCB,0x3F,0x18,	/* 02C0: ????. */
	0x05,0xFD,0x7E,0x7F,0xE6,0x0F,0xDD,0x77,	/* 02C8: .~.w */
	0xC4,0x21,0x32,0x01,0xC5,0x4F,0xE6,0x07,	/* 02D0: !2.O. */
	0xFE,0x05,0x20,0x17,0x78,0xFE,0x08,0x28,	/* 02D8: . .x.( */
	0x04,0xFE,0x04,0x20,0x0E,0xDD,0x36,0xC7,	/* 02E0: .. .6 */
	0x01,0x3E,0x08,0x90,0xFD,0x77,0x7F,0xFD,	/* 02E8: .>.w */
	0x36,0x4B,0x80,0x06,0x00,0xED,0xC6,0x7E,	/* 02F0: 6K..~ */
	0xDD,0x77,0xC6,0xC1,0x05,0x20,0x23,0x2A,	/* 02F8: w. #* */
	0x28,0x01,0xFD,0xED,0xF6,0x80,0x00,0x22,	/* 0300: (.." */
	0x28,0x01,0xFD,0x2A,0x28,0x01,0x2A,0x20,	/* 0308: (.*(.*  */
	0x01,0xED,0x2D,0xA0,0xFF,0xED,0x2A,0x00,	/* 0310: .-*. */
	0x00,0xFD,0xED,0xF6,0x00,0x04,0x0C,0xC3,	/* 0318: .... */
	0x1F,0x02,0xED,0x2A,0x00,0x00,0xFD,0xED,	/* 0320: ..*.. */
	0xF6,0x00,0x03,0xED,0x2D,0xA0,0xFF,0xE5,	/* 0328: ..- */
	0xDD,0xE1,0xED,0x32,0x00,0x00,0x3A,0x2E,	/* 0330: 2..:. */
	0x01,0xFE,0x08,0x20,0x14,0x7B,0xFE,0x28,	/* 0338: .. .{( */
	0xCA,0x51,0x02,0xFE,0x48,0xCA,0x51,0x02,	/* 0340: Q.HQ. */
	0xFD,0xED,0xF6,0x08,0x00,0xCB,0x02,0x18,	/* 0348: .... */
	0x1F,0x7B,0xFE,0x24,0xCA,0x51,0x02,0x78,	/* 0350: .{$Q.x */
	0xFE,0x02,0x20,0x09,0xFD,0xED,0xF6,0x08,	/* 0358: . .. */
	0x00,0xCB,0x02,0x18,0x0B,0xFD,0xED,0xF6,	/* 0360: .... */
	0x18,0x00,0xCB,0x02,0xCB,0x02,0xCB,0x02,	/* 0368: ..... */
	0xE5,0xFD,0xE1,0xC3,0x51,0x02,0xCD,0x42,	/* 0370: Q.B */
	0x01,0xDD,0x11,0x04,0x80,0x42,0x01,0xDD,	/* 0378: ...B. */
	0x3E,0x00,0x80,0x01,0x3E,0x01,0xC9,0xFD,	/* 0380: >..>. */
	0xED,0x2C,0xA2,0xFF,0xCD,0x8D,0x0E,0x18,	/* 0388: ,.. */
	0x05,0xFD,0xED,0x2C,0xA2,0xFF,0xCD,0xE4,	/* 0390: ., */
	0x0D,0x26,0x00,0xC3,0xF1,0x05,0xFD,0xED,	/* 0398: .&.. */
	0x2C,0xA2,0xFF,0xCD,0x8D,0x0E,0x26,0x00,	/* 03A0: ,.&. */
	0xC3,0xF1,0x05,0xFD,0xED,0x2C,0xA2,0xFF,	/* 03A8: ., */
	0xCD,0x11,0x0E,0x26,0x00,0xC3,0xF1,0x05,	/* 03B0: ..&.. */
	0xFD,0xED,0x2C,0xA2,0xFF,0xCD,0x2E,0x0E,	/* 03B8: ,.. */
	0x26,0x00,0xC3,0xF1,0x05,0xFD,0xED,0x2C,	/* 03C0: &.., */
	0xA2,0xFF,0xFD,0x36,0x02,0x60,0xDD,0x36,	/* 03C8: 6.`6 */
	0xAE,0x12,0xDD,0x3E,0xC3,0x05,0x01,0x26,	/* 03D0: .>..& */
	0x00,0xC3,0xF1,0x05,0xFD,0xED,0x2C,0xA2,	/* 03D8: .., */
	0xFF,0xFD,0x36,0x02,0x75,0xDD,0x36,0xAE,	/* 03E0: 6.u6 */
	0x00,0xDD,0x3E,0xC3,0x05,0x01,0x26,0x00,	/* 03E8: .>..&. */
	0xC3,0xF1,0x05,0x26,0x00,0xC3,0xF1,0x05,	/* 03F0: .&.. */
	0xFD,0xED,0x2C,0xA2,0xFF,0xDD,0x7E,0xAD,	/* 03F8: ,~ */
	0xDD,0x77,0xAC,0xDD,0x7E,0xB5,0xE6,0x10,	/* 0400: w~. */
	0x28,0x25,0xED,0x32,0x00,0x00,0xCB,0x5D,	/* 0408: (%2..] */
	0x28,0x0A,0xCB,0x9D,0xFD,0x7B,0x0D,0x00,	/* 0410: (.{.. */
	0xCB,0x2F,0x18,0x06,0xFD,0x7B,0x0D,0x00,	/* 0418: ...{.. */
	0xCB,0x27,0x2F,0xE6,0x02,0x20,0x08,0xFD,	/* 0420: '.. . */
	0x36,0x02,0x30,0xFD,0x36,0x02,0x04,0xDD,	/* 0428: 6.06.. */
	0x7E,0xA8,0xE6,0x06,0xFE,0x06,0x20,0x0E,	/* 0430: ~.. . */
	0xDD,0xCB,0xA8,0x96,0xDD,0xCB,0xA9,0x4E,	/* 0438: N */
	0x20,0x04,0xDD,0xCB,0xA3,0xA6,0xDD,0x36,	/* 0440:  .6 */
	0xAE,0x00,0xDD,0x3E,0xC3,0x05,0x01,0x26,	/* 0448: .>..& */
	0x00,0xC3,0xF1,0x05,0xFD,0xED,0x2C,0xA2,	/* 0450: .., */
	0xFF,0xDD,0x7E,0xAB,0xDD,0x77,0xAA,0xDD,	/* 0458: ~w */
	0x36,0xAE,0x00,0xDD,0x3E,0xC3,0x05,0x01,	/* 0460: 6.>.. */
	0x26,0x00,0xC3,0xF1,0x05,0xDD,0xCB,0xA8,	/* 0468: &.. */
	0x4E,0x28,0x08,0xDD,0xCB,0xA8,0xD6,0xDD,	/* 0470: N(. */
	0xCB,0xA3,0xE6,0xDD,0x36,0xAE,0x00,0xDD,	/* 0478: 6. */
	0x3E,0xC3,0x05,0x01,0x26,0x00,0xC3,0xF1,	/* 0480: >..&. */
	0x05,0xDD,0x2A,0x20,0x01,0x21,0xFE,0x00,	/* 0488: .* .!. */
	0x0E,0x08,0xED,0x6E,0x3E,0x28,0xD3,0xE0,	/* 0490: ..n>( */
	0x2A,0x02,0x80,0x01,0xE2,0x00,0xED,0xBF,	/* 0498: *... */
	0x3E,0xE0,0xD3,0xE1,0x3A,0x06,0x80,0x32,	/* 04A0: >:.2 */
	0xC2,0x04,0x21,0xFF,0x00,0x0E,0x08,0xED,	/* 04A8: .!... */
	0x6E,0x26,0x00,0x3A,0x93,0x00,0xFE,0x01,	/* 04B0: n&.:.. */
	0xC2,0xF6,0x05,0xD9,0x26,0x00,0xD9,0xC3,	/* 04B8: .&. */
	0x12,0x0D,0x00,0x00,0x00,0xDD,0xD1,0xC3,	/* 04C0: ..... */
	0x04,0xF5,0xC5,0xE5,0xDD,0xE5,0xFD,0xE5,	/* 04C8: . */
	0x3A,0x16,0x80,0xFE,0x01,0x20,0x08,0xCD,	/* 04D0: :.. . */
	0x42,0x01,0xDD,0x3E,0xC3,0x05,0x01,0x3A,	/* 04D8: B.>..: */
	0x93,0x00,0xFE,0x01,0x28,0x2C,0xDD,0x21,	/* 04E0: ..(,! */
	0xE0,0x81,0x18,0x10,0xDD,0xED,0x2C,0xA0,	/* 04E8: .., */
	0xFF,0xED,0x2A,0x00,0x00,0xFD,0xED,0xF7,	/* 04F0: *.. */
	0xE0,0x81,0x28,0x16,0xDD,0x7E,0xAE,0xFE,	/* 04F8: (.~ */
	0x00,0x20,0xE9,0xFD,0xED,0x2C,0xA2,0xFF,	/* 0500: . , */
	0xDD,0x46,0xA9,0xCB,0x68,0x28,0xDD,0xC3,	/* 0508: Fh( */
	0x72,0x08,0x21,0xFE,0x00,0x0E,0x08,0xED,	/* 0510: r.!... */
	0x6E,0x2A,0x02,0x80,0x01,0xE2,0x00,0xED,	/* 0518: n*... */
	0xBF,0x3E,0x00,0xD3,0xE1,0x3E,0xE0,0xD3,	/* 0520: >.> */
	0xE1,0x3A,0x93,0x00,0xFE,0x01,0x28,0x03,	/* 0528: :..(. */
	0xED,0x7F,0x01,0xDD,0x13,0x0A,0x80,0xDD,	/* 0530: ... */
	0x3C,0x0C,0x80,0x3A,0xC3,0x05,0xFE,0x00,	/* 0538: <.:.. */
	0x20,0x0E,0x3A,0xC2,0x05,0xFE,0x00,0x28,	/* 0540:  .:..( */
	0x27,0x3A,0xC2,0x04,0xFE,0x00,0x20,0x20,	/* 0548: ':..   */
	0xDD,0x3E,0x01,0xF0,0x01,0xDD,0x3E,0xC2,	/* 0550: >..> */
	0x05,0x00,0x3A,0x08,0x80,0xFE,0x01,0x28,	/* 0558: ..:..( */
	0x0A,0xDD,0x3E,0x0C,0x80,0x00,0xDD,0x3E,	/* 0560: .>..> */
	0x08,0x80,0x01,0xDD,0x3E,0xC3,0x05,0x00,	/* 0568: ..>.. */
	0xF3,0x3A,0xC2,0x04,0xFE,0x00,0x20,0x06,	/* 0570: :.. . */
	0x3A,0x06,0x80,0x32,0xC2,0x04,0xDD,0x3D,	/* 0578: :.2.= */
	0xC2,0x04,0x21,0xFF,0x00,0x0E,0x08,0xED,	/* 0580: .!... */
	0x6E,0xFD,0xE1,0xDD,0xE1,0xE1,0xC1,0xF1,	/* 0588: n */
	0xED,0x55,0xC4,0x05,0x9E,0x03,0x87,0x03,	/* 0590: U... */
	0x91,0x03,0x9E,0x03,0xAB,0x03,0xC5,0x03,	/* 0598: .... */
	0xDC,0x03,0xF3,0x03,0xF3,0x03,0xB8,0x03,	/* 05A0: .... */
	0x2F,0x04,0xF8,0x03,0x54,0x04,0x6D,0x04,	/* 05A8: ...T.m. */
	0xF3,0x03,0xF3,0x03,0xF3,0x03,0x29,0x10,	/* 05B0: ...). */
	0xFD,0x10,0xF3,0x03,0xF3,0x03,0xC7,0x11,	/* 05B8: .... */
	0x29,0x10,0x00,0x00,0xFD,0xED,0x2C,0xA2,	/* 05C0: )..., */
	0xFF,0xFD,0x4C,0xFD,0x5E,0x01,0xCB,0x61,	/* 05C8: L^.a */
	0x20,0x38,0xCB,0x53,0x28,0x17,0xDD,0x6E,	/* 05D0:  8S(.n */
	0xAC,0xDD,0x7E,0xAD,0x95,0x28,0x0E,0xE6,	/* 05D8: ~(. */
	0x3F,0xCA,0x27,0x07,0xDD,0x79,0xFD,0x77,	/* 05E0: ?'.yw */
	0x03,0x2C,0xDD,0x75,0xAC,0xCB,0x43,0x20,	/* 05E8: .,uC  */
	0x52,0xDD,0x7E,0xA1,0xDD,0x67,0xDD,0x7E,	/* 05F0: R~g~ */
	0xAE,0xFE,0x00,0x28,0xC7,0xFE,0x10,0x28,	/* 05F8: .(.( */
	0xF0,0x6F,0xFD,0xED,0xF6,0x92,0x05,0xED,	/* 0600: o. */
	0x26,0xE9,0xDD,0x4E,0xA8,0xDD,0x46,0xA9,	/* 0608: &NF */
	0xCB,0x53,0x28,0x25,0xCB,0x71,0xC2,0xDC,	/* 0610: S(%q */
	0x06,0xCB,0x51,0x20,0x1C,0xDD,0x6E,0xAC,	/* 0618: .Q .n */
	0xDD,0x7E,0xAD,0x95,0x28,0x13,0xE6,0x3F,	/* 0620: ~(.? */
	0xCA,0x00,0x07,0xDD,0x79,0xFE,0x0A,0xCA,	/* 0628: ..y. */
	0xE3,0x06,0xFD,0x77,0x03,0x2C,0xDD,0x75,	/* 0630: .w.,u */
	0xAC,0xCB,0x43,0x20,0x0C,0xCB,0x61,0x20,	/* 0638: C .a  */
	0x6A,0x18,0xAE,0xDD,0x4E,0xA8,0xDD,0x46,	/* 0640: j.NF */
	0xA9,0xFD,0x36,0x02,0x40,0xFD,0x7E,0x03,	/* 0648: 6.@~. */
	0xDD,0xA6,0xC3,0xFE,0x00,0xCA,0x10,0x08,	/* 0650: ... */
	0xCB,0x49,0x20,0x34,0x08,0xDD,0x6E,0xAA,	/* 0658: I 4.n */
	0x7D,0x3C,0xDD,0x96,0xAB,0xCB,0x7F,0x28,	/* 0660: }<( */
	0x05,0xFE,0xFE,0xF2,0xED,0x08,0x08,0x26,	/* 0668: ...& */
	0x01,0xCB,0x78,0xC2,0x2F,0x08,0xED,0x0B,	/* 0670: .x... */
	0x26,0x00,0x2C,0xDD,0x75,0xAA,0xDD,0x3E,	/* 0678: &.,u> */
	0xC2,0x05,0x01,0xCB,0x59,0xCA,0xED,0x08,	/* 0680: ..Y. */
	0x08,0xFE,0xC0,0xCA,0x96,0x07,0x18,0x23,	/* 0688: ...# */
	0xCB,0x41,0xCA,0xE6,0x07,0xCB,0x51,0xC2,	/* 0690: A.Q */
	0xEC,0x07,0xDD,0xBE,0xB1,0x20,0xBD,0xCB,	/* 0698: .  */
	0xD1,0xDD,0xCB,0xA3,0xE6,0xDD,0x71,0xA8,	/* 06A0: q */
	0xC3,0xED,0x08,0xDD,0x6E,0xAA,0x7D,0x3C,	/* 06A8: .n}< */
	0xDD,0x96,0xAB,0xCB,0x7F,0xC2,0xED,0x08,	/* 06B0: . */
	0xFE,0x40,0xF2,0xED,0x08,0xCB,0x79,0xC2,	/* 06B8: @.y */
	0xC2,0x07,0xCB,0x69,0xCA,0xED,0x08,0xCB,	/* 06C0: .i. */
	0xA1,0xCB,0xF1,0xDD,0x71,0xA8,0xDD,0xCB,	/* 06C8: q */
	0xB4,0x7E,0xCA,0xED,0x08,0xFD,0x36,0x02,	/* 06D0: ~.6. */
	0x80,0xC3,0xED,0x08,0xCB,0x79,0xC2,0x7E,	/* 06D8: .y~ */
	0x07,0x18,0x6B,0xCB,0x50,0xCA,0x32,0x06,	/* 06E0: ..kP2. */
	0xCB,0x40,0x20,0x0C,0xFD,0x36,0x03,0x0D,	/* 06E8: @ .6.. */
	0xCB,0xC0,0xDD,0x70,0xA9,0xC3,0x39,0x06,	/* 06F0: p9. */
	0xCB,0x80,0xDD,0x70,0xA9,0xC3,0x32,0x06,	/* 06F8: p2. */
	0xDD,0x7E,0xAD,0x95,0xFE,0x40,0x20,0x12,	/* 0700: ~@ . */
	0xCB,0x58,0xCA,0x2B,0x06,0xCB,0x98,0xDD,	/* 0708: X+. */
	0x70,0xA9,0xDD,0x3E,0xC3,0x05,0x01,0xC3,	/* 0710: p>.. */
	0x2B,0x06,0xFE,0xC0,0xC2,0x2B,0x06,0xCB,	/* 0718: +.+. */
	0xD8,0xDD,0x70,0xA9,0xC3,0x2B,0x06,0xDD,	/* 0720: p+. */
	0x7E,0xAD,0x95,0xFE,0x40,0x20,0x13,0xDD,	/* 0728: ~@ . */
	0xCB,0xA9,0x5E,0xCA,0xE4,0x05,0xDD,0xCB,	/* 0730: ^. */
	0xA9,0x9E,0xDD,0x3E,0xC3,0x05,0x01,0xC3,	/* 0738: >.. */
	0xE4,0x05,0xFE,0xC0,0xC2,0xE4,0x05,0xDD,	/* 0740: .. */
	0xCB,0xA9,0xDE,0xC3,0xE4,0x05,0xDD,0xCB,	/* 0748: . */
	0xBA,0x5E,0x28,0x06,0xDD,0x56,0xB2,0xFD,	/* 0750: ^(.V */
	0x72,0x03,0xDD,0xCB,0xB4,0x7E,0x28,0x04,	/* 0758: r.~(. */
	0xFD,0x36,0x02,0x80,0xCB,0xB1,0xCB,0xA9,	/* 0760: 6. */
	0xCB,0xA1,0xDD,0x71,0xA8,0xCB,0x48,0xC2,	/* 0768: qH */
	0x39,0x06,0xCB,0x51,0xC2,0x39,0x06,0xDD,	/* 0770: 9.Q9. */
	0xCB,0xA3,0xA6,0xC3,0x39,0x06,0xDD,0xCB,	/* 0778: 9. */
	0xBA,0x5E,0x28,0x06,0xDD,0x56,0xB3,0xFD,	/* 0780: ^(.V */
	0x72,0x03,0xCB,0xE9,0xCB,0xB9,0xCB,0xB1,	/* 0788: r. */
	0xDD,0x71,0xA8,0xC3,0x39,0x06,0xCB,0x69,	/* 0790: q9.i */
	0x20,0x0F,0xCB,0xF9,0xCB,0xF1,0xCB,0xE1,	/* 0798:  . */
	0xDD,0xCB,0xA3,0xE6,0xDD,0x71,0xA8,0x18,	/* 07A0: q. */
	0x02,0xCB,0xB1,0xDD,0xCB,0xB4,0x7E,0xCA,	/* 07A8: .~ */
	0xED,0x08,0xFD,0x36,0x02,0x90,0xCB,0xE1,	/* 07B0: .6. */
	0xDD,0xCB,0xA3,0xE6,0xDD,0x71,0xA8,0xC3,	/* 07B8: q */
	0xED,0x08,0xCB,0xB9,0xCB,0xB1,0xCB,0xA1,	/* 07C0: . */
	0xDD,0x71,0xA8,0xDD,0xCB,0xB4,0x7E,0x28,	/* 07C8: q~( */
	0x04,0xFD,0x36,0x02,0x80,0xCB,0x48,0xC2,	/* 07D0: .6.H */
	0xED,0x08,0xCB,0x51,0xC2,0xED,0x08,0xDD,	/* 07D8: .Q. */
	0xCB,0xA3,0xA6,0xC3,0xED,0x08,0xDD,0xBE,	/* 07E0: . */
	0xB0,0xC2,0x9A,0x06,0xCB,0x91,0xCB,0x48,	/* 07E8: .H */
	0x20,0x0C,0xCB,0x61,0x20,0x08,0xCB,0x71,	/* 07F0:  .a .q */
	0x20,0x04,0xDD,0xCB,0xA3,0xA6,0xDD,0x71,	/* 07F8:  .q */
	0xA8,0xDD,0xBE,0xB0,0xCA,0xED,0x08,0xDD,	/* 0800: . */
	0xBE,0xB1,0xCA,0xED,0x08,0xC3,0x5C,0x06,	/* 0808: .\. */
	0xCB,0x7B,0xCA,0x58,0x06,0xDD,0xCB,0xC1,	/* 0810: {X. */
	0x46,0xC2,0xED,0x08,0xDD,0xCB,0xC1,0x4E,	/* 0818: F.N */
	0xCA,0x58,0x06,0xDD,0xCB,0xB9,0xC6,0xDD,	/* 0820: X. */
	0x3E,0xC3,0x05,0x01,0xC3,0xED,0x08,0x57,	/* 0828: >...W */
	0x7B,0xE6,0x70,0x7A,0x20,0x0E,0xDD,0xCB,	/* 0830: {pz . */
	0xC1,0x56,0xCA,0x76,0x06,0xFE,0xFF,0x28,	/* 0838: Vv.( */
	0x27,0xC3,0x76,0x06,0xDD,0xCB,0xC1,0x5E,	/* 0840: 'v.^ */
	0x28,0x05,0x26,0x00,0xC3,0xED,0x08,0xDD,	/* 0848: (.&.. */
	0xCB,0xC1,0x56,0x20,0x06,0xDD,0x0E,0x00,	/* 0850: V ... */
	0xC3,0x78,0x06,0xDD,0x0E,0xFF,0x2C,0xDD,	/* 0858: x.., */
	0x0E,0x00,0x2C,0xED,0x0B,0xC3,0x78,0x06,	/* 0860: ..,.x. */
	0xDD,0x0E,0xFF,0x2C,0xDD,0x0E,0xFF,0xC3,	/* 0868: .,. */
	0x78,0x06,0xED,0x32,0x00,0x00,0xCB,0x5D,	/* 0870: x.2..] */
	0x28,0x0A,0xCB,0x9D,0xFD,0x7B,0x0D,0x00,	/* 0878: (.{.. */
	0xCB,0x2F,0x18,0x06,0xFD,0x7B,0x0D,0x00,	/* 0880: ...{.. */
	0xCB,0x27,0x26,0x00,0x2F,0xCB,0x60,0x20,	/* 0888: '&..`  */
	0x04,0xE6,0x26,0x18,0x02,0xE6,0x24,0xDD,	/* 0890: .&..$ */
	0xBE,0xB8,0xCA,0xEC,0x04,0xF5,0xDD,0xAE,	/* 0898: . */
	0xB8,0xE6,0x04,0x20,0x10,0xF1,0xDD,0x77,	/* 08A0: . .w */
	0xB8,0xDD,0xCB,0xB9,0xCE,0xDD,0x3E,0xC3,	/* 08A8: > */
	0x05,0x01,0xC3,0xEC,0x04,0xDD,0xCB,0xB5,	/* 08B0: ... */
	0x66,0x28,0xEA,0xF1,0xF5,0xFD,0x36,0x02,	/* 08B8: f(6. */
	0x10,0xFD,0x36,0x02,0x30,0xFD,0x36,0x02,	/* 08C0: .6.06. */
	0x20,0xCB,0x57,0x28,0x0F,0xFD,0x7E,0x00,	/* 08C8:  W(.~. */
	0xDD,0x7E,0xB5,0xFD,0x77,0x00,0xFD,0x36,	/* 08D0: ~w.6 */
	0x02,0x05,0x18,0xC9,0xFD,0x7E,0x00,0xDD,	/* 08D8: ...~. */
	0x7E,0xB5,0xE6,0xEF,0xFD,0x77,0x00,0xFD,	/* 08E0: ~w. */
	0x36,0x02,0x05,0x18,0xB8,0xFD,0x5E,0x01,	/* 08E8: 6...^. */
	0xC3,0xED,0x05,0xFD,0xED,0x2C,0xA2,0xFF,	/* 08F0: ., */
	0xDD,0x7E,0xA7,0xFD,0x77,0x7F,0xE6,0x03,	/* 08F8: ~w. */
	0xFD,0x77,0x68,0xC9,0xF5,0xC5,0xDD,0x7E,	/* 0900: wh~ */
	0xC6,0xFD,0x46,0x6C,0xA0,0x47,0x0E,0x00,	/* 0908: FlG.. */
	0xCB,0x78,0x28,0x02,0xCB,0xD1,0xFD,0x7E,	/* 0910: x(.~ */
	0x09,0xDD,0xCB,0xB5,0x66,0x28,0x04,0xF6,	/* 0918: .f(. */
	0x02,0x18,0x02,0xE6,0xFD,0xFD,0x77,0x09,	/* 0920: ...w. */
	0xCB,0x68,0x28,0x02,0xCB,0xF1,0xCB,0x60,	/* 0928: h(.` */
	0x28,0x02,0xCB,0xE9,0xCB,0x70,0x28,0x02,	/* 0930: (.p(. */
	0xCB,0xC9,0xDD,0x71,0xB8,0xC1,0xF1,0xC9,	/* 0938: q */
	0xCD,0xF3,0x08,0xDD,0x7E,0xBF,0xFE,0x01,	/* 0940: .~. */
	0x20,0x22,0xED,0x2C,0xA4,0xFF,0xDD,0x7E,	/* 0948:  ",~ */
	0xA7,0xFE,0x04,0xF2,0x61,0x09,0xFD,0x1C,	/* 0950: .a.. */
	0x1C,0x00,0xF6,0x08,0xFD,0x77,0x7F,0x18,	/* 0958: ...w. */
	0x2D,0xFD,0x1C,0x1D,0x00,0xF6,0x20,0xFD,	/* 0960: -...  */
	0x77,0x7F,0x18,0x22,0xDD,0x7E,0xC5,0xFE,	/* 0968: w."~ */
	0x01,0x28,0x1B,0xDD,0xCB,0xA9,0x4E,0x20,	/* 0970: .(.N  */
	0x15,0xDD,0xCB,0xA9,0xC6,0xDD,0x7E,0xC7,	/* 0978: .~ */
	0xFE,0x01,0x28,0x05,0xFD,0x36,0x06,0x92,	/* 0980: .(.6. */
	0xC9,0xFD,0x36,0x06,0x94,0xC9,0xDD,0x36,	/* 0988: 6.6 */
	0xBF,0x00,0xFD,0x7E,0x05,0xFE,0x00,0xC0,	/* 0990: .~.. */
	0xDD,0x7E,0xC5,0xFE,0x01,0xCA,0x62,0x0B,	/* 0998: ~.b. */
	0xDD,0x7E,0xC7,0xFE,0x01,0x20,0x19,0xFD,	/* 09A0: ~. . */
	0x7E,0x40,0xFE,0x42,0x28,0x07,0xFD,0x36,	/* 09A8: ~@B(.6 */
	0x72,0x31,0xC3,0xD9,0x0A,0xFD,0x36,0x76,	/* 09B0: r1.6v */
	0x00,0xFD,0x36,0x72,0x42,0xC3,0xD9,0x0A,	/* 09B8: .6rB. */
	0xDD,0x7E,0xB6,0xE6,0x0F,0xCB,0x27,0x4F,	/* 09C0: ~.'O */
	0x06,0x00,0xFD,0x7E,0x40,0xFE,0x42,0x28,	/* 09C8: ..~@B( */
	0x05,0x21,0x68,0x18,0x18,0x03,0x21,0x4C,	/* 09D0: .!h...!L */
	0x18,0xED,0xC6,0x46,0xFD,0x70,0x72,0x23,	/* 09D8: .Fpr# */
	0x46,0xFD,0x70,0x76,0xDD,0x7E,0xB6,0xE6,	/* 09E0: Fpv~ */
	0xF0,0xCB,0x3F,0xCB,0x3F,0xCB,0x3F,0x4F,	/* 09E8: ???O */
	0x06,0x00,0xFD,0x7E,0x40,0xFE,0x42,0x28,	/* 09F0: ..~@B( */
	0x05,0x21,0x68,0x18,0x18,0x03,0x21,0x4C,	/* 09F8: .!h...!L */
	0x18,0xED,0xC6,0x46,0xFD,0x70,0x78,0x23,	/* 0A00: .Fpx# */
	0x46,0xFD,0x70,0x7C,0xDD,0x7E,0xBB,0xFD,	/* 0A08: Fp|~ */
	0x77,0x1A,0xDD,0x7E,0xBC,0xFD,0x77,0x1B,	/* 0A10: w.~w. */
	0xDD,0x7E,0xBD,0xFD,0x77,0x1C,0xDD,0x7E,	/* 0A18: ~w.~ */
	0xBE,0xFD,0x77,0x1D,0xDD,0x36,0xB9,0x00,	/* 0A20: w.6. */
	0xDD,0x7E,0xB4,0xE6,0x03,0x47,0xDD,0x7E,	/* 0A28: ~.G~ */
	0xB4,0xE6,0x14,0xFE,0x10,0x28,0x0C,0xFE,	/* 0A30: ..(. */
	0x04,0x28,0x04,0x3E,0x40,0x18,0x06,0x3E,	/* 0A38: .(.>@..> */
	0xC0,0x18,0x02,0x3E,0x00,0xB0,0x47,0xDD,	/* 0A40: ..>.G */
	0x7E,0xBA,0xE6,0x80,0x20,0x04,0x78,0xF6,	/* 0A48: ~ .x */
	0x10,0x47,0xDD,0x7E,0xB5,0xE6,0x0F,0xFE,	/* 0A50: .G~. */
	0x07,0x78,0x20,0x04,0xF6,0x00,0x18,0x02,	/* 0A58: .x .... */
	0xF6,0x08,0xFD,0x77,0x08,0xDD,0x7E,0xB5,	/* 0A60: .w.~ */
	0xE6,0x10,0x28,0x04,0x06,0x02,0x18,0x02,	/* 0A68: .(..... */
	0x06,0x00,0xDD,0x7E,0xB5,0xE6,0x80,0x28,	/* 0A70: ..~( */
	0x04,0x3E,0x10,0xB0,0x47,0xDD,0x7E,0xBA,	/* 0A78: .>.G~ */
	0xE6,0x02,0x28,0x11,0xDD,0x7E,0xBA,0xE6,	/* 0A80: .(.~ */
	0x01,0x28,0x06,0x3E,0xC0,0xB0,0x47,0x18,	/* 0A88: .(.>G. */
	0x04,0x3E,0x40,0xB0,0x47,0xFD,0x70,0x09,	/* 0A90: .>@Gp. */
	0xDD,0x7E,0xBA,0xE6,0x02,0x28,0x06,0xFD,	/* 0A98: ~.(. */
	0x36,0x0A,0x36,0x18,0x04,0xFD,0x36,0x0A,	/* 0AA0: 6.6..6. */
	0x06,0xDD,0xCB,0xC0,0x5E,0x28,0x04,0x06,	/* 0AA8: .^(.. */
	0x02,0x18,0x0C,0xDD,0xCB,0xC0,0x56,0x28,	/* 0AB0: ...V( */
	0x04,0x06,0x04,0x18,0x02,0x06,0x03,0xDD,	/* 0AB8: ....... */
	0xCB,0xC0,0x46,0x28,0x04,0x3E,0x18,0x18,	/* 0AC0: F(.>.. */
	0x0C,0xDD,0xCB,0xC0,0x4E,0x28,0x04,0x3E,	/* 0AC8: .N(.> */
	0x00,0x18,0x02,0x3E,0x08,0xB0,0xFD,0x77,	/* 0AD0: ...>.w */
	0x1E,0xDD,0x7E,0xBA,0xE6,0x04,0x28,0x16,	/* 0AD8: .~.(. */
	0xDD,0x7E,0xC7,0xFE,0x01,0x20,0x07,0xFD,	/* 0AE0: ~. . */
	0x7E,0x40,0xFE,0x42,0x28,0x08,0x06,0x02,	/* 0AE8: ~@B(... */
	0xDD,0xCB,0xA9,0x96,0x18,0x02,0x06,0x00,	/* 0AF0: .... */
	0xDD,0x7E,0xC2,0xFE,0xFF,0x28,0x04,0x3E,	/* 0AF8: ~(.> */
	0x80,0xB0,0x47,0xFD,0x70,0x1F,0xDD,0x7E,	/* 0B00: Gp.~ */
	0xBA,0xDD,0xCB,0xB4,0x7E,0x20,0x06,0xDD,	/* 0B08: ~ . */
	0xCB,0xBA,0x76,0x28,0x02,0xF6,0x08,0x4F,	/* 0B10: v(..O */
	0xDD,0xAE,0xA8,0xE6,0x9B,0x47,0xDD,0x7E,	/* 0B18: G~ */
	0xA8,0xA8,0xCB,0x5F,0x28,0x02,0xE6,0x0F,	/* 0B20: _(.. */
	0x47,0xDD,0x70,0xA8,0x79,0xE6,0xFB,0xDD,	/* 0B28: Gpy */
	0xAE,0xA9,0xE6,0xA4,0x47,0xDD,0x7E,0xA9,	/* 0B30: G~ */
	0xA8,0xDD,0x77,0xA9,0xDD,0x7E,0xC7,0xFE,	/* 0B38: w~ */
	0x01,0x20,0x12,0xFD,0x7E,0x40,0xFE,0x42,	/* 0B40: . .~@B */
	0x20,0x0B,0xDD,0x7E,0xBA,0xE6,0x04,0x28,	/* 0B48:  .~.( */
	0x04,0xDD,0xCB,0xA9,0xD6,0xFD,0x36,0x21,	/* 0B50: .6! */
	0x02,0xFD,0x36,0x05,0x4E,0xDD,0x36,0xC5,	/* 0B58: .6.N6 */
	0x01,0xC9,0xDD,0x36,0xC5,0x00,0xDD,0xCB,	/* 0B60: .6. */
	0xA8,0x86,0xDD,0x7E,0xC7,0xFE,0x01,0xCA,	/* 0B68: ~. */
	0x1D,0x0C,0xFD,0x36,0x05,0x1A,0xDD,0xCB,	/* 0B70: ..6.. */
	0xB7,0x46,0x20,0x06,0xDD,0xCB,0xB4,0x7E,	/* 0B78: F .~ */
	0x28,0x13,0xDD,0x7E,0xC4,0xE6,0x08,0x20,	/* 0B80: (.~.  */
	0x06,0xFD,0x36,0x6C,0x01,0x18,0x17,0xFD,	/* 0B88: .6l... */
	0x36,0x6D,0x02,0x18,0x11,0xDD,0x7E,0xC4,	/* 0B90: 6m...~ */
	0xE6,0x08,0x20,0x06,0xFD,0x36,0x6C,0x00,	/* 0B98: . .6l. */
	0x18,0x04,0xFD,0x36,0x6D,0x00,0xDD,0xCB,	/* 0BA0: ..6m. */
	0xB7,0x4E,0x20,0x06,0xDD,0xCB,0xBA,0x76,	/* 0BA8: N .v */
	0x28,0x13,0xDD,0x7E,0xC4,0xE6,0x08,0x20,	/* 0BB0: (.~.  */
	0x06,0xFD,0x36,0x6D,0x02,0x18,0x17,0xFD,	/* 0BB8: .6m... */
	0x36,0x6C,0x01,0x18,0x11,0xDD,0x7E,0xC4,	/* 0BC0: 6l...~ */
	0xE6,0x08,0x20,0x06,0xFD,0x36,0x6D,0x00,	/* 0BC8: . .6m. */
	0x18,0x04,0xFD,0x36,0x6C,0x00,0xDD,0xCB,	/* 0BD0: ..6l. */
	0xBA,0x6E,0x28,0x15,0xCD,0x04,0x09,0xDD,	/* 0BD8: n(... */
	0x7E,0xB5,0xE6,0x10,0x28,0x04,0x3E,0xB0,	/* 0BE0: ~.(.> */
	0x18,0x02,0x3E,0xF0,0xDD,0xA6,0xC6,0x18,	/* 0BE8: ..>. */
	0x06,0x3E,0x00,0xDD,0x36,0xB8,0x24,0xFD,	/* 0BF0: .>.6$ */
	0x77,0x16,0xDD,0xCB,0xBA,0x76,0x28,0x0A,	/* 0BF8: w.v(. */
	0xDD,0xCB,0xC4,0x5E,0x20,0x04,0xF6,0x08,	/* 0C00: ^ .. */
	0x18,0x0E,0xDD,0xCB,0xB4,0x7E,0x28,0x08,	/* 0C08: ..~(. */
	0xDD,0xCB,0xC4,0x5E,0x28,0x02,0xF6,0x08,	/* 0C10: ^(.. */
	0xFD,0x77,0x15,0x18,0x0C,0xFD,0x36,0x15,	/* 0C18: w...6. */
	0x00,0xFD,0x36,0x16,0x00,0xFD,0x36,0x05,	/* 0C20: .6..6. */
	0x18,0xFD,0x36,0x06,0x90,0xDD,0x36,0xAE,	/* 0C28: .6.6 */
	0x00,0xDD,0x3E,0xC3,0x05,0x01,0xC9,0xCD,	/* 0C30: .>.. */
	0xF3,0x08,0xFD,0x7E,0x6C,0xE6,0x80,0x28,	/* 0C38: .~l( */
	0x0A,0xDD,0x36,0xAE,0x00,0xDD,0x3E,0xC3,	/* 0C40: .6.> */
	0x05,0x01,0xC9,0xDD,0x36,0xAE,0x06,0xC9,	/* 0C48: ..6. */
	0xCD,0x40,0x09,0x18,0x05,0xFD,0xED,0x2C,	/* 0C50: @..., */
	0xA2,0xFF,0xCD,0x37,0x0C,0x26,0x00,0xC3,	/* 0C58: 7.&. */
	0x12,0x0D,0xCD,0x40,0x09,0x26,0x00,0xC3,	/* 0C60: ..@.&. */
	0x12,0x0D,0xCD,0xFC,0x1C,0x26,0x00,0xC3,	/* 0C68: ...&. */
	0x12,0x0D,0xCD,0x1A,0x1D,0x26,0x00,0xC3,	/* 0C70: ....&. */
	0x12,0x0D,0x26,0x00,0xC3,0x12,0x0D,0xCD,	/* 0C78: ..&... */
	0xF3,0x08,0xFD,0x7E,0x05,0xFE,0x00,0x28,	/* 0C80: .~..( */
	0x05,0x26,0x00,0xC3,0x12,0x0D,0xDD,0x7E,	/* 0C88: .&...~ */
	0xAD,0xDD,0x77,0xAC,0xFD,0x36,0x05,0x82,	/* 0C90: w6. */
	0xCD,0xF3,0x08,0xDD,0x7E,0xC7,0xFE,0x01,	/* 0C98: .~. */
	0x28,0x08,0xFD,0x7E,0x0B,0xE6,0xFB,0xFD,	/* 0CA0: (.~. */
	0x77,0x0B,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0CA8: w.6.> */
	0xC3,0x05,0x01,0x26,0x00,0x18,0x5B,0xFD,	/* 0CB0: ..&..[ */
	0xED,0x2C,0xA2,0xFF,0xDD,0x7E,0xAB,0xDD,	/* 0CB8: ,~ */
	0x77,0xAA,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0CC0: w6.> */
	0xC3,0x05,0x01,0x26,0x00,0x18,0x43,0xCD,	/* 0CC8: ..&..C */
	0xF3,0x08,0xFD,0x7E,0x0B,0xF6,0x04,0xFD,	/* 0CD0: .~.. */
	0x77,0x0B,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0CD8: w.6.> */
	0xC3,0x05,0x01,0x26,0x00,0x18,0x2B,0xCD,	/* 0CE0: ..&..+ */
	0x84,0x1B,0x26,0x00,0x18,0x24,0x7A,0x0C,	/* 0CE8: .&..$z. */
	0x62,0x0C,0x50,0x0C,0x55,0x0C,0x62,0x0C,	/* 0CF0: b.P.U.b. */
	0x6A,0x0C,0x3F,0x1C,0x9B,0x1C,0x7A,0x0C,	/* 0CF8: j.?..z. */
	0x7A,0x0C,0x72,0x0C,0x98,0x0C,0x7F,0x0C,	/* 0D00: z.r... */
	0xB7,0x0C,0xCF,0x0C,0xE7,0x0C,0x7A,0x0C,	/* 0D08: ...z. */
	0x7A,0x0C,0xED,0x7F,0x17,0xDD,0x7E,0xA1,	/* 0D10: z..~ */
	0xDD,0x67,0xDD,0x7E,0xAE,0xFE,0x00,0xF3,	/* 0D18: g~. */
	0xC2,0xB7,0x0D,0xDD,0x46,0xA8,0xCB,0x40,	/* 0D20: .F@ */
	0xCA,0xC4,0x0D,0xCB,0x60,0x28,0xE3,0xCD,	/* 0D28: .`( */
	0xF3,0x08,0xCB,0x78,0x28,0x16,0xFD,0x7E,	/* 0D30: .x(.~ */
	0x05,0xFE,0x00,0x20,0xD5,0xFD,0x36,0x05,	/* 0D38: .. 6. */
	0x24,0xCB,0xE8,0xCB,0xB8,0xCB,0xB0,0xDD,	/* 0D40: $ */
	0x70,0xA8,0x18,0xC6,0xDD,0x6E,0xAA,0x7D,	/* 0D48: p.n} */
	0xDD,0x96,0xAB,0xCB,0x7F,0x20,0xBB,0xFE,	/* 0D50:   */
	0x40,0xF2,0x12,0x0D,0xDD,0xCB,0xBA,0x5E,	/* 0D58: @..^ */
	0x28,0x0B,0xFD,0x7E,0x05,0xFE,0x00,0x20,	/* 0D60: (.~..  */
	0xA9,0xFD,0x36,0x05,0x23,0xDD,0xCB,0xB4,	/* 0D68: 6.# */
	0x7E,0x28,0x19,0xDD,0x7E,0xC4,0xE6,0x08,	/* 0D70: ~(.~. */
	0x20,0x06,0xFD,0x36,0x6C,0x01,0x18,0x0C,	/* 0D78:  .6l... */
	0xFD,0x36,0x6D,0x02,0xFD,0x7E,0x15,0xF6,	/* 0D80: 6m.~. */
	0x08,0xFD,0x77,0x15,0xDD,0xCB,0xBA,0x76,	/* 0D88: .w.v */
	0x28,0x19,0xDD,0x7E,0xC4,0xE6,0x08,0x20,	/* 0D90: (.~.  */
	0x0E,0xFD,0x36,0x6D,0x02,0xFD,0x7E,0x15,	/* 0D98: .6m.~. */
	0xF6,0x08,0xFD,0x77,0x15,0x18,0x04,0xFD,	/* 0DA0: .w... */
	0x36,0x6C,0x01,0xCB,0xB0,0xCB,0xA8,0xCB,	/* 0DA8: 6l. */
	0xA0,0xDD,0x70,0xA8,0xC3,0x12,0x0D,0xFE,	/* 0DB0: p.. */
	0x10,0xCA,0x12,0x0D,0x6F,0xFD,0xED,0x3C,	/* 0DB8: ...o< */
	0xEE,0x0C,0xFD,0xE9,0xDD,0x6E,0xAC,0xDD,	/* 0DC0: .n */
	0x7E,0xAD,0x95,0xCA,0x2B,0x0D,0xDD,0xCB,	/* 0DC8: ~+. */
	0xA8,0xC6,0xCD,0xF3,0x08,0xFD,0x7E,0x06,	/* 0DD0: .~. */
	0xF6,0x04,0xFD,0x77,0x06,0xDD,0x36,0xC9,	/* 0DD8: .w.6 */
	0x01,0xC3,0x2B,0x0D,0xED,0x32,0x00,0x00,	/* 0DE0: .+.2.. */
	0xCB,0x5D,0x28,0x0B,0xCB,0x9D,0xFD,0x7B,	/* 0DE8: ](.{ */
	0x0D,0x00,0x2F,0xE6,0x08,0x18,0x07,0xFD,	/* 0DF0: ...... */
	0x7B,0x0D,0x00,0x2F,0xE6,0x02,0xFE,0x00,	/* 0DF8: {..... */
	0x28,0x0A,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0E00: (.6.> */
	0xC3,0x05,0x01,0xC9,0xDD,0x36,0xAE,0x06,	/* 0E08: ..6. */
	0xC9,0x26,0x00,0xDD,0x7E,0xAC,0xDD,0x96,	/* 0E10: &.~ */
	0xAD,0x28,0x04,0xF1,0xC3,0xC4,0x05,0xDD,	/* 0E18: (.. */
	0x7E,0xBF,0xFE,0x01,0x28,0x08,0xFD,0x7E,	/* 0E20: ~.(.~ */
	0x01,0xCB,0x5F,0xC8,0x18,0x10,0xDD,0x36,	/* 0E28: ._..6 */
	0xAA,0x00,0xDD,0x36,0xAB,0x00,0xDD,0x36,	/* 0E30: .6.6 */
	0xAC,0x00,0xDD,0x36,0xAD,0x00,0xFD,0xED,	/* 0E38: .6. */
	0x2C,0xA2,0xFF,0xDD,0xCB,0xB7,0x46,0x20,	/* 0E40: ,F  */
	0x04,0xFD,0x36,0x02,0x90,0xFD,0x36,0x02,	/* 0E48: .6.6. */
	0x30,0xFD,0x36,0x02,0x20,0xDD,0x36,0xBF,	/* 0E50: 06. 6 */
	0x01,0xDD,0xCB,0xB7,0x4E,0x20,0x24,0xFD,	/* 0E58: .N $ */
	0xE5,0xED,0x32,0x00,0x00,0x7D,0xE6,0x80,	/* 0E60: 2..} */
	0x6F,0xFD,0xED,0x2C,0xA4,0xFF,0xFD,0x7E,	/* 0E68: o,~ */
	0x04,0x47,0xDD,0x7E,0xAF,0x2F,0xA0,0xFD,	/* 0E70: .G~. */
	0x77,0x04,0xE5,0xFD,0xE1,0x2F,0xFD,0x77,	/* 0E78: w..w */
	0x40,0xFD,0xE1,0xDD,0x36,0xAE,0x10,0xDD,	/* 0E80: @6. */
	0x3E,0xC3,0x05,0x01,0xC9,0xDD,0x7E,0xBF,	/* 0E88: >..~ */
	0xFE,0x01,0x28,0x06,0xFD,0x7E,0x01,0xCB,	/* 0E90: .(.~. */
	0x5F,0xC8,0xDD,0x36,0xBF,0x00,0xFD,0x36,	/* 0E98: _6.6 */
	0x02,0x18,0xDD,0x7E,0xB4,0xE6,0x7F,0xFD,	/* 0EA0: ..~ */
	0x77,0x00,0xDD,0xCB,0xB4,0x7E,0x20,0x12,	/* 0EA8: w.~ . */
	0xDD,0xCB,0xB7,0x46,0x20,0x06,0xFD,0x36,	/* 0EB0: F .6 */
	0x02,0x90,0x18,0x0A,0xFD,0x36,0x02,0x80,	/* 0EB8: ...6. */
	0x18,0x04,0xFD,0x36,0x02,0x80,0xDD,0x7E,	/* 0EC0: ..6.~ */
	0xB5,0xFD,0x77,0x00,0xCB,0x67,0x20,0x06,	/* 0EC8: w.g . */
	0xDD,0xCB,0xA9,0xA6,0x18,0x04,0xDD,0xCB,	/* 0ED0: .. */
	0xA9,0xE6,0xFD,0xE5,0xED,0x32,0x00,0x00,	/* 0ED8: 2.. */
	0x7D,0xE6,0x80,0x6F,0xFD,0xED,0x2C,0xA4,	/* 0EE0: }o, */
	0xFF,0xFD,0x7E,0x04,0xDD,0xCB,0xB7,0x4E,	/* 0EE8: ~.N */
	0x28,0x05,0xDD,0xB6,0xAF,0x18,0x06,0x47,	/* 0EF0: (...G */
	0xDD,0x7E,0xAF,0x2F,0xA0,0xFD,0x77,0x04,	/* 0EF8: ~.w. */
	0xE5,0xFD,0xE1,0x2F,0xFD,0x77,0x40,0xFD,	/* 0F00: .w@ */
	0xE1,0xDD,0x7E,0xB6,0xFD,0x77,0x01,0xDD,	/* 0F08: ~w. */
	0x36,0xB9,0x00,0xDD,0x7E,0xBB,0xDD,0x77,	/* 0F10: 6.~w */
	0xB0,0xDD,0x7E,0xBC,0xDD,0x77,0xB1,0xDD,	/* 0F18: ~w */
	0x7E,0xBD,0xDD,0x77,0xB2,0xDD,0x7E,0xBE,	/* 0F20: ~w~ */
	0xDD,0x77,0xB3,0xDD,0x36,0xB9,0x00,0xDD,	/* 0F28: w6. */
	0x7E,0xBA,0xDD,0xCB,0xB4,0x7E,0x28,0x02,	/* 0F30: ~~(. */
	0xF6,0x08,0x4F,0xDD,0xAE,0xA8,0xE6,0xDB,	/* 0F38: .O */
	0x47,0xDD,0x7E,0xA8,0xA8,0xCB,0x48,0x28,	/* 0F40: G~H( */
	0x02,0xCB,0x97,0xCB,0x5F,0x28,0x02,0xE6,	/* 0F48: ._(. */
	0x0F,0x47,0x79,0xE6,0x54,0x20,0x0A,0xDD,	/* 0F50: .GyT . */
	0xCB,0xA9,0x8E,0xDD,0xCB,0xA3,0xA6,0x18,	/* 0F58: . */
	0x08,0xDD,0xCB,0xA3,0xE6,0xDD,0xCB,0xA9,	/* 0F60: . */
	0xCE,0xDD,0x70,0xA8,0x79,0xDD,0xAE,0xA9,	/* 0F68: py */
	0xE6,0xA4,0x47,0xDD,0x7E,0xA9,0xA8,0xCB,	/* 0F70: G~ */
	0x50,0x28,0x02,0xCB,0x87,0xDD,0x77,0xA9,	/* 0F78: P(.w */
	0xCB,0x6F,0x20,0x06,0xDD,0x36,0xB8,0x24,	/* 0F80: o .6$ */
	0x18,0x39,0xED,0x32,0x00,0x00,0xCB,0x5D,	/* 0F88: .92..] */
	0x28,0x0A,0xCB,0x9D,0xFD,0x7B,0x0D,0x00,	/* 0F90: (.{.. */
	0xCB,0x2F,0x18,0x06,0xFD,0x7B,0x0D,0x00,	/* 0F98: ...{.. */
	0xCB,0x27,0x2F,0xDD,0xCB,0xA9,0x66,0x20,	/* 0FA0: '.f  */
	0x04,0xE6,0x26,0x18,0x13,0xE6,0x24,0xDD,	/* 0FA8: .&..$ */
	0x77,0xB8,0xCB,0x57,0x18,0x0D,0xDD,0x7E,	/* 0FB0: wW..~ */
	0xB5,0xE6,0xEF,0xFD,0x77,0x00,0x18,0x03,	/* 0FB8: w... */
	0xDD,0x77,0xB8,0xDD,0x7E,0xC0,0xDD,0x77,	/* 0FC0: w~w */
	0xC1,0xDD,0x7E,0xC2,0xDD,0x77,0xC3,0xFD,	/* 0FC8: ~w */
	0x36,0x02,0x05,0xDD,0x36,0xAE,0x00,0xDD,	/* 0FD0: 6..6. */
	0x3E,0xC3,0x05,0x01,0xC9,0x45,0x6E,0x64,	/* 0FD8: >..End */
	0x20,0x6F,0x66,0x20,0x74,0x61,0x20,0x63,	/* 0FE0:  of ta c */
	0x6F,0x64,0x65,0x00,0x00,0xDD,0xD1,0xEB,	/* 0FE8: ode.. */
	0x0F,0xE5,0xDD,0xE5,0xC5,0xDD,0x2A,0x2A,	/* 0FF0: .** */
	0x01,0x0E,0x15,0xED,0xB7,0x21,0x00,0x00,	/* 0FF8: ...!.. */
	0xED,0xBF,0xDD,0x36,0xAE,0x2A,0xC1,0xDD,	/* 1000: 6* */
	0xE1,0xE1,0xED,0x55,0xDD,0xD1,0xEB,0x0F,	/* 1008: U. */
	0xE5,0xDD,0xE5,0xC5,0xDD,0x2A,0x2C,0x01,	/* 1010: *,. */
	0x0E,0x1D,0x21,0x00,0x00,0xED,0xBF,0xDD,	/* 1018: ..!.. */
	0x36,0xAE,0x2A,0xC1,0xDD,0xE1,0xE1,0xED,	/* 1020: 6* */
	0x55,0xFD,0xED,0x2C,0xA2,0xFF,0xDD,0x7E,	/* 1028: U,~ */
	0xB2,0xE6,0x0C,0x20,0x25,0xDD,0x7E,0xB2,	/* 1030: . %~ */
	0xE6,0x10,0x28,0x1E,0xFD,0x36,0x00,0x0F,	/* 1038: .(.6.. */
	0xFD,0x36,0x00,0x01,0xFD,0x36,0x00,0x07,	/* 1040: 6..6.. */
	0xFD,0x36,0x00,0x03,0xDD,0x7E,0xB3,0xF6,	/* 1048: 6..~ */
	0x09,0xFD,0x36,0x00,0x05,0xFD,0x77,0x00,	/* 1050: .6..w. */
	0x18,0x0C,0xDD,0x7E,0xB3,0xF6,0x08,0xFD,	/* 1058: ..~. */
	0x36,0x00,0x05,0xFD,0x77,0x00,0xED,0x32,	/* 1060: 6..w.2 */
	0x02,0x00,0x7C,0xF6,0xF0,0x67,0xDD,0x7E,	/* 1068: ..|g~ */
	0xA7,0xFE,0x01,0x20,0x44,0x0E,0x10,0xED,	/* 1070: . D.. */
	0xBF,0x21,0x0F,0x80,0x0E,0x11,0xED,0xBF,	/* 1078: !... */
	0xED,0x2A,0x00,0x00,0x7C,0xF6,0xF0,0x67,	/* 1080: *..|g */
	0x0E,0x12,0xED,0xBF,0xDD,0x7C,0xE6,0x7F,	/* 1088: ..| */
	0xF6,0x0F,0x6F,0x26,0x00,0x0E,0x13,0xED,	/* 1090: .o&... */
	0xBF,0xED,0x2C,0xAA,0xFF,0x0E,0x14,0xED,	/* 1098: ,.. */
	0xBF,0x21,0x84,0x88,0x0E,0x15,0xED,0xBF,	/* 10A0: !.. */
	0xFD,0x36,0x00,0x01,0xFD,0x36,0x00,0xC0,	/* 10A8: 6..6. */
	0x26,0x00,0xDD,0x36,0xAE,0x28,0xC3,0xF1,	/* 10B0: &.6( */
	0x05,0x0E,0x18,0xED,0xBF,0x21,0x0F,0x80,	/* 10B8: ...!. */
	0x0E,0x19,0xED,0xBF,0xED,0x2A,0x00,0x00,	/* 10C0: ..*.. */
	0x7C,0xF6,0xF0,0x67,0x0E,0x1A,0xED,0xBF,	/* 10C8: |g.. */
	0xDD,0x7C,0xE6,0x7F,0xF6,0x0F,0x6F,0x26,	/* 10D0: |.o& */
	0x00,0x0E,0x1B,0xED,0xBF,0xED,0x2C,0xAA,	/* 10D8: ..., */
	0xFF,0x0E,0x1C,0xED,0xBF,0x21,0x84,0x88,	/* 10E0: ..! */
	0x0E,0x1D,0xED,0xBF,0xFD,0x36,0x00,0x01,	/* 10E8: ..6.. */
	0xFD,0x36,0x00,0xC0,0x26,0x00,0xDD,0x36,	/* 10F0: 6.&.6 */
	0xAE,0x28,0xC3,0xF1,0x05,0xFD,0xED,0x2C,	/* 10F8: (., */
	0xA2,0xFF,0xDD,0x7E,0xB2,0xE6,0x0C,0x20,	/* 1100: ~.  */
	0x15,0xDD,0x7E,0xB2,0xE6,0x10,0x28,0x0E,	/* 1108: .~.(. */
	0xDD,0x7E,0xB1,0xF6,0x11,0xFD,0x36,0x00,	/* 1110: ~.6. */
	0x03,0xFD,0x77,0x00,0x18,0x0C,0xDD,0x7E,	/* 1118: .w...~ */
	0xB1,0xF6,0x01,0xFD,0x36,0x00,0x03,0xFD,	/* 1120: .6.. */
	0x77,0x00,0xED,0x32,0x02,0x00,0x7C,0xF6,	/* 1128: w.2..| */
	0xF0,0x67,0xDD,0x7E,0xA7,0xFE,0x01,0x20,	/* 1130: g~.  */
	0x47,0x0E,0x12,0xED,0xBF,0x21,0x0F,0x80,	/* 1138: G..!. */
	0x0E,0x13,0xED,0xBF,0xED,0x2A,0x00,0x0C,	/* 1140: ..*.. */
	0x7C,0xF6,0xF0,0x67,0x0E,0x10,0xED,0xBF,	/* 1148: |g.. */
	0xED,0x2A,0x00,0x0C,0x7C,0xE6,0x7F,0xF6,	/* 1150: *..| */
	0x0F,0x6F,0x26,0x00,0x0E,0x11,0xED,0xBF,	/* 1158: .o&... */
	0xED,0x2C,0xAA,0xFF,0x0E,0x14,0xED,0xBF,	/* 1160: ,.. */
	0x21,0x80,0xA0,0x0E,0x15,0xED,0xBF,0xFD,	/* 1168: !.. */
	0x36,0x00,0x01,0xFD,0x36,0x00,0xE0,0x26,	/* 1170: 6..6.& */
	0x00,0xDD,0x36,0xAE,0x28,0xC3,0xF1,0x05,	/* 1178: .6(. */
	0x0E,0x1A,0xED,0xBF,0x21,0x0F,0x80,0x0E,	/* 1180: ..!.. */
	0x1B,0xED,0xBF,0xED,0x2A,0x00,0x0C,0x7C,	/* 1188: .*..| */
	0xF6,0xF0,0x67,0x0E,0x18,0xED,0xBF,0xED,	/* 1190: g.. */
	0x2A,0x00,0x0C,0x7C,0xE6,0x7F,0xF6,0x0F,	/* 1198: *..|. */
	0x6F,0x26,0x00,0x0E,0x19,0xED,0xBF,0xED,	/* 11A0: o&... */
	0x2C,0xAA,0xFF,0x0E,0x1C,0xED,0xBF,0x21,	/* 11A8: ,..! */
	0x80,0xA0,0x0E,0x1D,0xED,0xBF,0xFD,0x36,	/* 11B0: ..6 */
	0x00,0x01,0xFD,0x36,0x00,0xE0,0x26,0x00,	/* 11B8: ..6.&. */
	0xDD,0x36,0xAE,0x28,0xC3,0xF1,0x05,0xFD,	/* 11C0: 6(. */
	0xED,0x2C,0xA2,0xFF,0xDD,0x7E,0xB1,0xFD,	/* 11C8: ,~ */
	0x36,0x00,0x03,0xFD,0x77,0x00,0xDD,0x7E,	/* 11D0: 6..w.~ */
	0xB2,0xFD,0x36,0x00,0x04,0xFD,0x77,0x00,	/* 11D8: 6..w. */
	0xDD,0x7E,0xB3,0xFD,0x36,0x00,0x05,0xFD,	/* 11E0: ~6.. */
	0x77,0x00,0xDD,0x7E,0xB4,0xFD,0x36,0x00,	/* 11E8: w.~6. */
	0x06,0xFD,0x77,0x00,0xDD,0x7E,0xB5,0xFD,	/* 11F0: .w.~ */
	0x36,0x00,0x07,0xFD,0x77,0x00,0xDD,0x7E,	/* 11F8: 6..w.~ */
	0xB8,0xFD,0x36,0x00,0x0A,0xFD,0x77,0x00,	/* 1200: 6..w. */
	0xDD,0x7E,0xBA,0xFD,0x36,0x00,0x0C,0xFD,	/* 1208: ~6.. */
	0x77,0x00,0xDD,0x7E,0xBB,0xFD,0x36,0x00,	/* 1210: w.~6. */
	0x0D,0xFD,0x77,0x00,0xDD,0x36,0xAE,0x2A,	/* 1218: .w.6* */
	0xDD,0x3E,0xC3,0x05,0x01,0x26,0x00,0xC3,	/* 1220: >..&. */
	0xF1,0x05,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1228: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1230: 8.H.X.h. */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1238: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1240: 8.H.X.h. */
	0x78,0x00,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1248: x.....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1250: 8.H.X.h. */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1258: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1260: 8.H.X.h. */
	0x78,0x00,0x7A,0x00,0x6A,0x00,0xFA,0x00,	/* 1268: x.z.j.. */
	0xAA,0x00,0xBA,0x00,0xCA,0x00,0x08,0x80,	/* 1270: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1278: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1280: 8.H.X.h. */
	0x08,0x01,0x7A,0x00,0x6A,0x00,0xFA,0x00,	/* 1288: ..z.j.. */
	0xAA,0x00,0xBA,0x00,0xCA,0x00,0x08,0x80,	/* 1290: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1298: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 12A0: 8.H.X.h. */
	0x08,0x01,0x6A,0x00,0x7A,0x00,0xFA,0x00,	/* 12A8: ..j.z.. */
	0x9A,0x00,0xAA,0x00,0xBA,0x00,0x08,0x80,	/* 12B0: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 12B8: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 12C0: 8.H.X.h. */
	0x08,0x01,0x6A,0x00,0x7A,0x00,0xFA,0x00,	/* 12C8: ..j.z.. */
	0x9A,0x00,0xAA,0x00,0xBA,0x00,0x08,0x80,	/* 12D0: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 12D8: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 12E0: 8.H.X.h. */
	0x08,0x01,0x8A,0x00,0x9A,0x00,0xFA,0x00,	/* 12E8: ..... */
	0xBA,0x00,0xCA,0x00,0xDA,0x00,0x08,0x80,	/* 12F0: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 12F8: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1300: 8.H.X.h. */
	0x08,0x01,0x8A,0x00,0x9A,0x00,0xFA,0x00,	/* 1308: ..... */
	0xBA,0x00,0xCA,0x00,0xDA,0x00,0x08,0x80,	/* 1310: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1318: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1320: 8.H.X.h. */
	0x08,0x01,0x3A,0x41,0x00,0xFE,0x00,0x20,	/* 1328: ..:A..  */
	0xF9,0x3A,0x00,0x80,0x2F,0x47,0x32,0x00,	/* 1330: :..G2. */
	0x80,0x3A,0x00,0x80,0xB8,0x28,0x07,0xDD,	/* 1338: :.(. */
	0x3E,0x01,0x00,0x20,0x18,0x05,0xDD,0x3E,	/* 1340: >.. ..> */
	0x01,0x00,0x40,0x3A,0x42,0x00,0xFE,0x01,	/* 1348: ..@:B.. */
	0x20,0x06,0xDD,0x11,0x28,0x13,0x08,0x40,	/* 1350:  ..(..@ */
	0x2A,0x43,0x00,0x0E,0xFF,0xED,0x6E,0x2A,	/* 1358: *C..n* */
	0x45,0x00,0x0E,0x02,0xED,0x6E,0x21,0x60,	/* 1360: E...n!` */
	0x00,0x0E,0x12,0xED,0x6E,0x21,0x02,0x00,	/* 1368: ...n!.. */
	0x0E,0x00,0xED,0x6E,0x21,0xFF,0x00,0x0E,	/* 1370: ..n!.. */
	0x08,0xED,0x6E,0x21,0x00,0x00,0x0E,0x16,	/* 1378: .n!.... */
	0xED,0x6E,0x3E,0x3F,0xD3,0xE8,0x0E,0x1F,	/* 1380: n>?.. */
	0x21,0x00,0x00,0xED,0xBF,0xED,0x4E,0x3E,	/* 1388: !..N> */
	0x00,0x0E,0xF5,0xDD,0x21,0x2A,0x12,0xED,	/* 1390: ..!*. */
	0x2C,0x00,0x00,0xD3,0xF1,0xED,0xBF,0x3C,	/* 1398: ,..< */
	0xDD,0x23,0xDD,0x23,0xFE,0x20,0x20,0xEF,	/* 13A0: ##   */
	0x21,0x00,0x08,0x0E,0xF0,0xED,0xBF,0x00,	/* 13A8: !.... */
	0x00,0x00,0xDD,0x21,0x8C,0x00,0xFD,0x21,	/* 13B0: ..!.! */
	0x00,0x70,0x21,0x80,0x00,0x0E,0x00,0xFD,	/* 13B8: .p!... */
	0xE5,0x06,0x04,0xFD,0x7E,0x0D,0xE6,0xA0,	/* 13C0: ..~. */
	0xFE,0xA0,0x20,0x44,0xE5,0xED,0x32,0x00,	/* 13C8:  D2. */
	0x00,0xFD,0xED,0xF6,0x10,0x00,0xE5,0xFD,	/* 13D0: ... */
	0xE1,0xE1,0x10,0xE7,0xFD,0xE1,0xFD,0x7E,	/* 13D8: .~ */
	0x01,0xFE,0xFF,0xCA,0x92,0x14,0xDD,0x3E,	/* 13E0: ..> */
	0x92,0x00,0x01,0x3A,0x93,0x00,0xFE,0x01,	/* 13E8: ..:.. */
	0xCA,0xDA,0x14,0xFD,0x7E,0x40,0xE6,0x01,	/* 13F0: .~@. */
	0x20,0x0B,0xDD,0x36,0x00,0x08,0xFD,0xED,	/* 13F8:  .6.. */
	0xF6,0x00,0x19,0x18,0x76,0xDD,0x36,0x00,	/* 1400: ...v6. */
	0x04,0xFD,0xED,0xF6,0x00,0x0D,0x18,0x6B,	/* 1408: ....k */
	0xFD,0xE1,0xFD,0x36,0x7F,0x08,0xDD,0x3E,	/* 1410: 6.> */
	0x93,0x00,0x01,0x3A,0x92,0x00,0xFE,0x01,	/* 1418: ..:.. */
	0xCA,0xDA,0x14,0xCD,0x82,0x15,0xFD,0x36,	/* 1420: ..6 */
	0x7F,0x10,0xFD,0x7E,0x7F,0xE6,0xF0,0xFE,	/* 1428: .~ */
	0xF0,0x20,0x0B,0xDD,0x36,0x00,0x24,0xFD,	/* 1430:  .6.$ */
	0xED,0xF6,0x00,0x0D,0x18,0x3D,0xFD,0x36,	/* 1438: ...=6 */
	0x7F,0x34,0xCD,0x82,0x15,0xFD,0x36,0x7F,	/* 1440: 4.6 */
	0x40,0xFD,0x36,0x7F,0x00,0xFD,0x36,0x68,	/* 1448: @6.6h */
	0x00,0xFD,0x36,0x18,0x00,0xFD,0x36,0x7F,	/* 1450: .6..6 */
	0x04,0xFD,0x36,0x68,0x00,0xFD,0x36,0x18,	/* 1458: .6h.6. */
	0x55,0xFD,0x36,0x7F,0x00,0xFD,0x7E,0x18,	/* 1460: U6.~. */
	0xFE,0x55,0x20,0x06,0xDD,0x36,0x00,0x48,	/* 1468: U .6.H */
	0x18,0x04,0xDD,0x36,0x00,0x28,0xFD,0xED,	/* 1470: ..6.( */
	0xF6,0x00,0x19,0xDD,0x23,0xE5,0xED,0x32,	/* 1478: ..#2 */
	0x00,0x00,0xFD,0xED,0xF6,0x80,0x00,0xE5,	/* 1480: ... */
	0xFD,0xE1,0xE1,0x0C,0x79,0xFE,0x04,0xC2,	/* 1488: .y. */
	0xBF,0x13,0x79,0xFE,0x00,0x28,0x43,0xE5,	/* 1490: .y.(C */
	0x21,0xDD,0x0F,0xFD,0xED,0xF7,0x00,0x10,	/* 1498: !... */
	0xE1,0xF2,0xAB,0x14,0x3A,0x91,0x00,0xFE,	/* 14A0: .:. */
	0x01,0x20,0x05,0xDD,0x3E,0x94,0x00,0x01,	/* 14A8: . .>.. */
	0x3A,0x01,0x00,0xFE,0x40,0x28,0x39,0x22,	/* 14B0: :..@(9" */
	0x95,0x00,0x21,0x00,0x80,0x3A,0x94,0x00,	/* 14B8: .!.:. */
	0xFE,0x01,0x20,0x07,0xFD,0xED,0xFE,0x00,	/* 14C0: . .. */
	0x20,0x18,0x05,0xFD,0xED,0xFE,0x00,0x10,	/* 14C8:  .... */
	0xDD,0xED,0xDE,0x95,0x00,0xFA,0xE8,0x14,	/* 14D0: .. */
	0x18,0x16,0xDD,0x3E,0x00,0x00,0xFF,0x18,	/* 14D8: ..>... */
	0x0E,0xDD,0x3E,0x00,0x00,0x02,0x18,0x07,	/* 14E0: .>..... */
	0xDD,0x3E,0x00,0x00,0x03,0x18,0x00,0x76,	/* 14E8: >.....v */
	0x21,0x00,0x00,0x0E,0xF0,0xED,0xBF,0x00,	/* 14F0: !.... */
	0x00,0x00,0x01,0xF3,0x1D,0x21,0x00,0x00,	/* 14F8: ....!.. */
	0x3A,0x01,0x00,0xFE,0x20,0x20,0x14,0x3A,	/* 1500: :..  .: */
	0x94,0x00,0xFE,0x01,0x20,0x05,0x11,0x00,	/* 1508: .. ... */
	0x60,0x18,0x0B,0x01,0xDD,0x0F,0x11,0x00,	/* 1510: `...... */
	0x70,0x18,0x03,0x11,0x00,0x80,0xED,0xB0,	/* 1518: p.... */
	0x3A,0x01,0x00,0xFE,0x20,0x20,0x12,0x3A,	/* 1520: :..  .: */
	0x94,0x00,0xFE,0x01,0x28,0x0B,0x01,0xF3,	/* 1528: ..(.. */
	0x0D,0x11,0x00,0x60,0x21,0x00,0x10,0xED,	/* 1530: ...`!.. */
	0xB0,0x3A,0x01,0x00,0xFE,0x20,0x20,0x05,	/* 1538: :..  . */
	0x21,0x70,0x00,0x18,0x03,0x21,0x80,0x00,	/* 1540: !p...!. */
	0x0E,0x06,0xED,0x6E,0x3A,0x01,0x00,0xFE,	/* 1548: ..n:.. */
	0x20,0x20,0x13,0x3A,0x94,0x00,0xFE,0x01,	/* 1550:   .:.. */
	0x20,0x06,0xDD,0x21,0xAA,0x12,0x18,0x0A,	/* 1558:  .!... */
	0xDD,0x21,0x6A,0x12,0x18,0x04,0xDD,0x21,	/* 1560: !j...! */
	0xEA,0x12,0x3E,0x00,0x0E,0xF5,0xED,0x2C,	/* 1568: .>.., */
	0x00,0x00,0xD3,0xF1,0xED,0xBF,0x3C,0xDD,	/* 1570: ..< */
	0x23,0xDD,0x23,0xFE,0x20,0x20,0xEF,0xC3,	/* 1578: ##   */
	0xC7,0x00,0xF5,0xC5,0xE5,0xFD,0x36,0x66,	/* 1580: .6f */
	0x01,0xFD,0x36,0x68,0x03,0xFD,0x36,0x74,	/* 1588: .6h.6t */
	0x00,0xFD,0x36,0x68,0x02,0xFD,0x36,0x74,	/* 1590: .6h.6t */
	0x00,0xFD,0x36,0x68,0x01,0xFD,0x36,0x74,	/* 1598: .6h.6t */
	0x00,0xFD,0x36,0x68,0x00,0xFD,0x36,0x74,	/* 15A0: .6h.6t */
	0x00,0xFD,0x36,0x68,0x03,0xFD,0x36,0x7A,	/* 15A8: .6h.6z */
	0x00,0xFD,0x36,0x68,0x02,0xFD,0x36,0x7A,	/* 15B0: .6h.6z */
	0x00,0xFD,0x36,0x68,0x01,0xFD,0x36,0x7A,	/* 15B8: .6h.6z */
	0x00,0xFD,0x36,0x68,0x00,0xFD,0x36,0x7A,	/* 15C0: .6h.6z */
	0x00,0xFD,0x36,0x68,0x04,0xFD,0x36,0x6D,	/* 15C8: .6h.6m */
	0xA8,0xFD,0x36,0x6E,0x00,0xFD,0x36,0x6F,	/* 15D0: 6n.6o */
	0x00,0xFD,0x36,0x6C,0x01,0xFD,0x36,0x66,	/* 15D8: .6l.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x66,	/* 15E0: .6f.6f */
	0x03,0xFD,0x36,0x68,0x04,0xFD,0x36,0x6D,	/* 15E8: .6h.6m */
	0xA8,0xFD,0x36,0x6E,0x20,0xFD,0x36,0x6F,	/* 15F0: 6n 6o */
	0x00,0xFD,0x36,0x66,0x03,0xFD,0x36,0x66,	/* 15F8: .6f.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x6C,	/* 1600: .6f.6l */
	0x00,0x06,0x0F,0xFD,0x36,0x66,0x03,0x10,	/* 1608: ...6f.. */
	0xFA,0xFD,0x36,0x68,0x04,0xFD,0x36,0x6D,	/* 1610: 6h.6m */
	0x00,0xFD,0x36,0x6E,0x20,0xFD,0x36,0x6F,	/* 1618: .6n 6o */
	0x03,0xFD,0x36,0x6C,0x01,0xFD,0x36,0x66,	/* 1620: .6l.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x66,	/* 1628: .6f.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x6C,	/* 1630: .6f.6l */
	0x00,0xFD,0x36,0x66,0x00,0xFD,0x36,0x68,	/* 1638: .6f.6h */
	0x00,0x21,0xFF,0x7F,0x2B,0xFD,0xED,0xF7,	/* 1640: .!+ */
	0x00,0x00,0x20,0xF8,0xFD,0x36,0x40,0x00,	/* 1648: .. 6@. */
	0xFD,0x36,0x05,0x81,0x21,0xFF,0x7F,0xFD,	/* 1650: 6.! */
	0x7E,0x40,0xFE,0x00,0x28,0xF9,0xFD,0x36,	/* 1658: ~@.(6 */
	0x4B,0x00,0xFD,0x36,0x7E,0xC3,0x06,0x04,	/* 1660: K.6~.. */
	0x05,0xFD,0x70,0x68,0xFD,0x36,0x18,0x00,	/* 1668: .ph6.. */
	0x78,0xFE,0x00,0x20,0xF3,0xE1,0xC1,0xF1,	/* 1670: x.  */
	0xC9,0x43,0x6F,0x70,0x79,0x72,0x69,0x67,	/* 1678: Copyrig */
	0x68,0x74,0x20,0x28,0x63,0x29,0x20,0x53,	/* 1680: ht (c) S */
	0x70,0x65,0x63,0x69,0x61,0x6C,0x69,0x78,	/* 1688: pecialix */
	0x20,0x52,0x65,0x73,0x65,0x61,0x72,0x63,	/* 1690:  Researc */
	0x68,0x20,0x4C,0x74,0x64,0x20,0x31,0x39,	/* 1698: h Ltd 19 */
	0x38,0x38,0x2D,0x31,0x39,0x39,0x38,0x0D,	/* 16A0: 88-1998. */
	0x0A,0x5A,0x32,0x38,0x30,0x20,0x44,0x6F,	/* 16A8: .Z280 Do */
	0x77,0x6E,0x6C,0x6F,0x61,0x64,0x20,0x43,	/* 16B0: wnload C */
	0x6F,0x64,0x65,0x20,0x56,0x65,0x72,0x73,	/* 16B8: ode Vers */
	0x69,0x6F,0x6E,0x20,0x31,0x2E,0x34,0x33,	/* 16C0: ion 1.43 */
	0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1700: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1708: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1710: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1718: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1720: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1728: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1730: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1738: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1740: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1748: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1750: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1758: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1760: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1768: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1770: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1778: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1780: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1788: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1790: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1798: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1800: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1808: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1810: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1818: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1820: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1828: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1830: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1838: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1840: ........ */
	0x00,0x00,0x42,0x41,0x82,0x04,0x16,0x00,	/* 1848: ..BA... */
	0x41,0x00,0x41,0x04,0x82,0x03,0x41,0x03,	/* 1850: A.A..A. */
	0x82,0x02,0x4E,0x02,0x41,0x02,0x82,0x01,	/* 1858: .N.A.. */
	0x57,0x02,0x41,0x01,0x82,0x00,0x2B,0x00,	/* 1860: W.A..+. */
	0xA3,0x04,0x1B,0x00,0x51,0x00,0x51,0x04,	/* 1868: ...Q.Q. */
	0xA3,0x03,0x51,0x03,0xA3,0x02,0x62,0x02,	/* 1870: .Q..b. */
	0x51,0x02,0xA3,0x01,0x6D,0x02,0x51,0x01,	/* 1878: Q..m.Q. */
	0xA3,0x00,0x36,0x00,0x49,0x4E,0x00,0x00,	/* 1880: .6.IN.. */
	0x1E,0x01,0x18,0x02,0x1E,0x00,0xDD,0xD1,	/* 1888: ...... */
	0x86,0x18,0xF5,0xDD,0xE5,0x21,0x80,0x80,	/* 1890: .! */
	0x54,0xFD,0x7B,0x08,0x00,0xFD,0xED,0x3C,	/* 1898: T{..< */
	0x06,0x00,0xFE,0x24,0x28,0x04,0x06,0x04,	/* 18A0: ..$(... */
	0x18,0x02,0x06,0x00,0xFD,0x70,0x7F,0xCB,	/* 18A8: ....p */
	0x43,0x20,0x05,0xFD,0x7E,0x6A,0x18,0x03,	/* 18B0: C .~j.. */
	0xFD,0x7E,0x6B,0x4F,0xCB,0x7F,0xCA,0x56,	/* 18B8: ~kOV */
	0x19,0xE6,0x03,0xFD,0x77,0x68,0xED,0x3A,	/* 18C0: ..wh: */
	0x08,0x00,0xB0,0xCB,0x27,0x85,0x6F,0xDD,	/* 18C8: ..'o */
	0xED,0x3C,0x02,0x00,0xCB,0x43,0xC2,0x88,	/* 18D0: <..C */
	0x19,0xD9,0xDD,0x6E,0xAC,0xDD,0x7E,0xAD,	/* 18D8: .n~ */
	0x95,0x4F,0xE6,0x0C,0xFE,0x0C,0x28,0x06,	/* 18E0: O..(. */
	0x79,0xE6,0x30,0xCA,0xC1,0x1A,0xDD,0x7E,	/* 18E8: y0.~ */
	0xA9,0xE6,0x05,0xC2,0x6E,0x1A,0x79,0xCB,	/* 18F0: .n.y */
	0x7F,0x20,0x05,0xFE,0x0C,0xFA,0xB2,0x1A,	/* 18F8:  ... */
	0xDD,0x79,0xFD,0x77,0x63,0x2C,0xDD,0x79,	/* 1900: ywc,y */
	0xFD,0x77,0x63,0x2C,0xDD,0x79,0xFD,0x77,	/* 1908: wc,yw */
	0x63,0x2C,0xDD,0x79,0xFD,0x77,0x63,0x2C,	/* 1910: c,ywc, */
	0xDD,0x79,0xFD,0x77,0x63,0x2C,0xDD,0x79,	/* 1918: ywc,y */
	0xFD,0x77,0x63,0x2C,0xDD,0x79,0xFD,0x77,	/* 1920: wc,yw */
	0x63,0x2C,0xDD,0x79,0xFD,0x77,0x63,0x2C,	/* 1928: c,ywc, */
	0xDD,0x79,0xFD,0x77,0x63,0x2C,0xDD,0x79,	/* 1930: ywc,y */
	0xFD,0x77,0x63,0x2C,0xDD,0x79,0xFD,0x77,	/* 1938: wc,yw */
	0x63,0x2C,0xDD,0x79,0xFD,0x77,0x63,0x2C,	/* 1940: c,ywc, */
	0xDD,0x75,0xAC,0xD9,0x79,0xE6,0x3F,0xCB,	/* 1948: uy? */
	0x43,0x20,0x30,0xFD,0x77,0x6A,0x62,0x2E,	/* 1950: C 0wjb. */
	0x80,0xCB,0x50,0x28,0x05,0x06,0x00,0xC3,	/* 1958: P(... */
	0xAC,0x18,0xDD,0xED,0x3A,0x02,0x00,0xDD,	/* 1960: .:.. */
	0x66,0xFF,0xFD,0xED,0xF7,0x80,0x00,0xC2,	/* 1968: f. */
	0x98,0x18,0xDD,0xE1,0xF1,0xED,0x55,0xFD,	/* 1970: .U */
	0x7E,0x62,0xED,0x0B,0x2C,0x10,0xF8,0x18,	/* 1978: ~b.,.. */
	0x2A,0x49,0x4E,0xFD,0x77,0x6B,0x18,0xCE,	/* 1980: *INwk. */
	0xD9,0xFD,0x7E,0x43,0xFE,0x07,0x28,0x57,	/* 1988: ~C.(W */
	0x26,0x01,0xDD,0x7E,0xAB,0xDD,0x6E,0xAA,	/* 1990: &.~n */
	0x95,0x3D,0x4F,0xFD,0x46,0x0E,0x58,0xCB,	/* 1998: =OF.X */
	0x7F,0x20,0x04,0xB8,0xFA,0xD3,0x19,0x16,	/* 19A0:  ... */
	0x00,0x18,0xCC,0xDD,0x3E,0xC2,0x05,0x01,	/* 19A8: ..>.. */
	0x7A,0xFE,0x00,0x20,0x2A,0xDD,0xCB,0xA8,	/* 19B0: z. * */
	0x5E,0x28,0x10,0x79,0xCB,0x7F,0x20,0x0B,	/* 19B8: ^(.y . */
	0xFE,0x40,0xFA,0xCB,0x19,0x93,0xFE,0x40,	/* 19C0: @.@ */
	0xFA,0xF8,0x19,0xDD,0x75,0xAA,0x26,0x00,	/* 19C8: .u&. */
	0xC3,0x4B,0x19,0xFE,0x00,0x28,0x09,0x16,	/* 19D0: K..(.. */
	0x01,0x78,0x91,0x5F,0x41,0x18,0x98,0x43,	/* 19D8: .x_A.C */
	0xFD,0x7E,0x62,0x10,0xFB,0x18,0xE4,0xDD,	/* 19E0: ~b.. */
	0xCB,0xB9,0xC6,0xDD,0x3E,0xC3,0x05,0x01,	/* 19E8: >.. */
	0xFD,0x7E,0x62,0xFD,0x7E,0x62,0x18,0xD6,	/* 19F0: ~b~b. */
	0xDD,0xCB,0xBA,0x5E,0x28,0x1F,0xDD,0xCB,	/* 19F8: ^(. */
	0xA8,0x6E,0x20,0x19,0xFD,0x7E,0x05,0xFE,	/* 1A00: n .~. */
	0x00,0x20,0x0A,0xFD,0x36,0x05,0x24,0xDD,	/* 1A08: . .6.$ */
	0xCB,0xA8,0xEE,0x18,0x08,0xDD,0xCB,0xA8,	/* 1A10: .. */
	0xFE,0xDD,0xCB,0xA8,0xF6,0xDD,0xCB,0xA8,	/* 1A18:  */
	0xE6,0xDD,0xCB,0xB4,0x7E,0x28,0x19,0xDD,	/* 1A20: ~(. */
	0x7E,0xC4,0xE6,0x08,0x20,0x06,0xFD,0x36,	/* 1A28: ~. .6 */
	0x6C,0x00,0x18,0x0C,0xFD,0x7E,0x15,0xE6,	/* 1A30: l...~. */
	0xF0,0xFD,0x77,0x15,0xFD,0x36,0x6D,0x00,	/* 1A38: w.6m. */
	0xDD,0xCB,0xBA,0x76,0x28,0x85,0xDD,0x7E,	/* 1A40: v(~ */
	0xC4,0xE6,0x08,0x20,0x0E,0xFD,0x7E,0x15,	/* 1A48: . .~. */
	0xE6,0xF0,0xFD,0x77,0x15,0xFD,0x36,0x6D,	/* 1A50: w.6m */
	0x00,0x18,0x04,0xFD,0x36,0x6C,0x00,0xDD,	/* 1A58: ...6l. */
	0xCB,0xA8,0xEE,0xDD,0xCB,0xA8,0xBE,0xDD,	/* 1A60:  */
	0xCB,0xA8,0xB6,0xC3,0xCB,0x19,0xDD,0xCB,	/* 1A68: . */
	0xA9,0x46,0x28,0x13,0xDD,0xCB,0xA9,0xCE,	/* 1A70: F(. */
	0xDD,0xCB,0xA9,0x86,0xFD,0x7E,0x06,0xE6,	/* 1A78: ~. */
	0xF9,0xFD,0x77,0x06,0xC3,0x48,0x19,0x79,	/* 1A80: w.H.y */
	0xCB,0x7F,0x20,0x0C,0xFE,0x0C,0xF2,0x98,	/* 1A88:  .. */
	0x1A,0xFE,0x00,0x28,0x52,0x47,0x18,0x02,	/* 1A90: ..(RG.. */
	0x06,0x0C,0xDD,0x79,0xFE,0x0A,0x28,0x08,	/* 1A98: ..y.(. */
	0xFD,0x77,0x63,0x2C,0x10,0xF4,0x18,0x3F,	/* 1AA0: wc,..? */
	0xFD,0x36,0x63,0x0D,0xFD,0x36,0x63,0x0A,	/* 1AA8: 6c.6c. */
	0x18,0xF1,0xFE,0x00,0x28,0x31,0x47,0xDD,	/* 1AB0: ..(1G */
	0x79,0xFD,0x77,0x63,0x2C,0x10,0xF8,0x18,	/* 1AB8: ywc,.. */
	0x26,0x79,0xE6,0xC0,0xFE,0x40,0x20,0x13,	/* 1AC0: &y@ . */
	0xDD,0xCB,0xA9,0x5E,0xCA,0xEE,0x18,0xDD,	/* 1AC8: ^. */
	0xCB,0xA9,0x9E,0xDD,0x3E,0xC3,0x05,0x01,	/* 1AD0: >.. */
	0xC3,0xEE,0x18,0xFE,0xC0,0xC2,0xEE,0x18,	/* 1AD8: .. */
	0xDD,0xCB,0xA9,0xDE,0xC3,0xEE,0x18,0xFD,	/* 1AE0: . */
	0x7E,0x06,0xE6,0xF9,0xFD,0x77,0x06,0xDD,	/* 1AE8: ~.w. */
	0xCB,0xA8,0x86,0xC3,0x48,0x19,0xDD,0xD1,	/* 1AF0: H. */
	0x86,0x18,0xF5,0xC5,0xD5,0xE5,0xFD,0xE5,	/* 1AF8: . */
	0xDD,0xE5,0x21,0x80,0x80,0x54,0xFD,0x7B,	/* 1B00: !T{ */
	0x08,0x00,0xFD,0xED,0x3C,0x06,0x00,0xFE,	/* 1B08: ..<.. */
	0x24,0x28,0x04,0x06,0x04,0x18,0x02,0x06,	/* 1B10: $(...... */
	0x00,0x78,0xED,0x3B,0x1A,0x00,0xFD,0x70,	/* 1B18: .x;..p */
	0x7F,0xFD,0x7E,0x69,0xCB,0x7F,0x28,0x2C,	/* 1B20: ~i(, */
	0xFD,0x5E,0x68,0xE6,0x03,0xFD,0x77,0x68,	/* 1B28: ^h.wh */
	0xED,0x3A,0x0A,0x00,0xB0,0xCB,0x27,0x85,	/* 1B30: :..' */
	0x6F,0xED,0x26,0xE5,0xDD,0xE1,0xC5,0xCD,	/* 1B38: o& */
	0x04,0x09,0xDD,0x3E,0xC3,0x05,0x01,0xDD,	/* 1B40: ..>.. */
	0xCB,0xB9,0xCE,0xFD,0x7E,0x69,0xE6,0x3F,	/* 1B48: ~i? */
	0xFD,0x77,0x69,0xC1,0x62,0x2E,0x80,0xCB,	/* 1B50: wib. */
	0x50,0x28,0x04,0x06,0x00,0x18,0xBA,0xE5,	/* 1B58: P(.... */
	0xDD,0xE1,0xDD,0x66,0x01,0xFD,0xED,0xF7,	/* 1B60: f. */
	0x80,0x00,0x20,0x99,0xDD,0xE1,0xFD,0xE1,	/* 1B68: .  */
	0xE1,0xD1,0xC1,0xF1,0xED,0x55,0xE5,0x21,	/* 1B70: U! */
	0xE8,0x03,0x2B,0xFD,0xED,0xF7,0x00,0x00,	/* 1B78: .+.. */
	0x20,0xF8,0xE1,0xC9,0xCD,0xF3,0x08,0xDD,	/* 1B80:  . */
	0x7E,0xC7,0xFE,0x01,0xC2,0x28,0x1C,0xFD,	/* 1B88: ~.(. */
	0x36,0x6F,0x03,0xCD,0x76,0x1B,0xFD,0x7E,	/* 1B90: 6o.v.~ */
	0x6F,0xE6,0x20,0x20,0x07,0xDD,0x36,0xC8,	/* 1B98: o  .6 */
	0x09,0xC3,0x28,0x1C,0xFD,0x36,0x6F,0x02,	/* 1BA0: .(.6o. */
	0xCD,0x76,0x1B,0xFD,0x7E,0x6F,0xE6,0x20,	/* 1BA8: v.~o  */
	0x28,0x06,0xDD,0x36,0xC8,0x0A,0x18,0x70,	/* 1BB0: (.6..p */
	0xFD,0x36,0x6F,0x06,0xCD,0x76,0x1B,0xFD,	/* 1BB8: 6o.v. */
	0x7E,0x6F,0xE6,0x10,0x20,0x06,0xDD,0x36,	/* 1BC0: ~o. .6 */
	0xC8,0x0B,0x18,0x5C,0xFD,0x36,0x6F,0x02,	/* 1BC8: ..\6o. */
	0xCD,0x76,0x1B,0xFD,0x7E,0x6F,0xE6,0x20,	/* 1BD0: v.~o  */
	0x28,0x06,0xDD,0x36,0xC8,0x0A,0x18,0x48,	/* 1BD8: (.6..H */
	0x06,0x08,0xFD,0x36,0x6F,0x02,0xCD,0x76,	/* 1BE0: ..6o.v */
	0x1B,0xFD,0x36,0x6F,0x00,0xCD,0x76,0x1B,	/* 1BE8: .6o.v. */
	0xFD,0x7E,0x6F,0xE6,0x80,0x20,0x28,0x10,	/* 1BF0: ~o (. */
	0xE9,0xFD,0x36,0x6F,0x02,0xCD,0x76,0x1B,	/* 1BF8: 6o.v. */
	0xFD,0x36,0x6F,0x00,0x21,0xE8,0x03,0xFD,	/* 1C00: 6o.!. */
	0x7E,0x6F,0xE6,0x40,0x20,0x16,0x2B,0xFD,	/* 1C08: ~o@ .+ */
	0xED,0xF7,0x00,0x00,0x20,0xF1,0xDD,0x36,	/* 1C10: .. 6 */
	0xC8,0x0D,0xDD,0x77,0xB8,0x18,0x09,0xDD,	/* 1C18: .w.. */
	0x70,0xC8,0x18,0x04,0xDD,0x36,0xC8,0x00,	/* 1C20: p..6. */
	0xCD,0x76,0x1B,0xFD,0x36,0x6F,0x02,0xCD,	/* 1C28: v.6o. */
	0x76,0x1B,0xFD,0x36,0x6F,0x00,0xFD,0x36,	/* 1C30: v.6o.6 */
	0x05,0x80,0xDD,0x36,0xAE,0x00,0xC9,0xCD,	/* 1C38: .6. */
	0xF3,0x08,0xDD,0xCB,0xA9,0x4E,0x20,0x23,	/* 1C40: .N # */
	0xDD,0xCB,0xA9,0xC6,0xDD,0x7E,0xC7,0xFE,	/* 1C48: ~ */
	0x01,0x28,0x0F,0xFD,0x7E,0x06,0xF6,0x02,	/* 1C50: .(.~.. */
	0xE6,0xFB,0xFD,0x77,0x06,0x26,0x00,0xC3,	/* 1C58: w.&. */
	0x12,0x0D,0xFD,0x36,0x06,0x84,0x26,0x00,	/* 1C60: ..6.&. */
	0xC3,0x12,0x0D,0xFD,0x7E,0x06,0xE6,0xF9,	/* 1C68: ..~. */
	0xFD,0x77,0x06,0xFD,0x7E,0x09,0xF6,0x20,	/* 1C70: w.~.  */
	0xFD,0x77,0x09,0xFD,0x7E,0x50,0xFD,0x77,	/* 1C78: w.~Pw */
	0x65,0xFD,0x36,0x63,0x00,0xFD,0x36,0x63,	/* 1C80: e6c.6c */
	0x81,0xFD,0x36,0x12,0x02,0xDD,0x36,0xAE,	/* 1C88: 6..6 */
	0x12,0xDD,0x3E,0xC3,0x05,0x01,0x26,0x00,	/* 1C90: .>..&. */
	0xC3,0x12,0x0D,0xCD,0xF3,0x08,0xDD,0x7E,	/* 1C98: ...~ */
	0xC5,0xFE,0x01,0x28,0x27,0xFD,0x7E,0x12,	/* 1CA0: .('~. */
	0xFE,0x00,0x28,0x05,0x26,0x00,0xC3,0x12,	/* 1CA8: .(.&.. */
	0x0D,0xFD,0x7E,0x50,0xFD,0x77,0x65,0xFD,	/* 1CB0: .~Pwe */
	0x36,0x63,0x00,0xFD,0x36,0x63,0x83,0xFD,	/* 1CB8: 6c.6c */
	0x36,0x12,0x02,0xDD,0x36,0xC5,0x01,0x26,	/* 1CC0: 6..6.& */
	0x00,0xC3,0x12,0x0D,0xFD,0x7E,0x12,0xFE,	/* 1CC8: ...~. */
	0x00,0x28,0x05,0x26,0x00,0xC3,0x12,0x0D,	/* 1CD0: .(.&... */
	0xFD,0x7E,0x06,0xF6,0x04,0xE6,0xFD,0xFD,	/* 1CD8: ~.. */
	0x77,0x06,0xFD,0x7E,0x09,0xE6,0xDF,0xFD,	/* 1CE0: w.~. */
	0x77,0x09,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 1CE8: w.6.> */
	0xC3,0x05,0x01,0xDD,0x36,0xC5,0x00,0x26,	/* 1CF0: ..6.& */
	0x00,0xC3,0x12,0x0D,0x26,0x00,0xDD,0x7E,	/* 1CF8: ...&.~ */
	0xAC,0xDD,0x96,0xAD,0x28,0x04,0xF1,0xC3,	/* 1D00: (. */
	0x23,0x0D,0xCD,0xF3,0x08,0xDD,0x7E,0xBF,	/* 1D08: #..~ */
	0xFE,0x01,0x28,0x50,0xDD,0xCB,0xA9,0x4E,	/* 1D10: .(PN */
	0x28,0x29,0xCD,0xF3,0x08,0xED,0x2C,0xA4,	/* 1D18: ()., */
	0xFF,0xDD,0x7E,0xA7,0xFE,0x04,0xF2,0x36,	/* 1D20: ~.6 */
	0x1D,0xFD,0x1D,0x1C,0x00,0x20,0x35,0xF6,	/* 1D28: .... 5 */
	0x10,0xFD,0x77,0x7F,0x18,0x2E,0xFD,0x1D,	/* 1D30: .w... */
	0x1D,0x00,0x20,0x28,0xF6,0x40,0xFD,0x77,	/* 1D38: .. (@w */
	0x7F,0x18,0x21,0xDD,0x7E,0xC9,0xFE,0x01,	/* 1D40: .!~. */
	0x20,0x10,0xDD,0xCB,0xA9,0xC6,0xDD,0x7E,	/* 1D48:  .~ */
	0xC7,0xFE,0x01,0x28,0x0A,0xFD,0x36,0x06,	/* 1D50: .(.6. */
	0x92,0xC9,0xDD,0xCB,0xA9,0xCE,0xC9,0xFD,	/* 1D58:  */
	0x36,0x06,0x94,0xC9,0xDD,0x36,0xAA,0x00,	/* 1D60: 6.6. */
	0xDD,0x36,0xAB,0x00,0xDD,0x36,0xAC,0x00,	/* 1D68: 6.6. */
	0xDD,0x36,0xAD,0x00,0xDD,0x36,0xC9,0x00,	/* 1D70: 6.6. */
	0xCD,0xF3,0x08,0xFD,0x7E,0x05,0xFE,0x00,	/* 1D78: .~.. */
	0xC0,0xDD,0xCB,0xA9,0x8E,0xDD,0x7E,0xC7,	/* 1D80: ~ */
	0xFE,0x01,0x20,0x06,0xFD,0x36,0x05,0x14,	/* 1D88: . .6.. */
	0x18,0x32,0xDD,0xCB,0xB7,0x46,0x20,0x11,	/* 1D90: .2F . */
	0xDD,0x7E,0xC4,0xE6,0x08,0x20,0x06,0xFD,	/* 1D98: ~. . */
	0x36,0x6C,0x00,0x18,0x04,0xFD,0x36,0x6D,	/* 1DA0: 6l...6m */
	0x00,0xDD,0xCB,0xB7,0x4E,0x20,0x11,0xDD,	/* 1DA8: .N . */
	0x7E,0xC4,0xE6,0x08,0x20,0x06,0xFD,0x36,	/* 1DB0: ~. .6 */
	0x6D,0x00,0x18,0x04,0xFD,0x36,0x6C,0x00,	/* 1DB8: m...6l. */
	0xFD,0x36,0x05,0x80,0xFD,0x36,0x06,0x00,	/* 1DC0: 6.6.. */
	0xDD,0x36,0xBF,0x01,0xDD,0x36,0xAE,0x10,	/* 1DC8: 6.6. */
	0xDD,0x3E,0xC3,0x05,0x01,0xC9,0x3A,0x49,	/* 1DD0: >..:I */
	0x00,0xFE,0x01,0x28,0x0B,0xFD,0x1E,0x06,	/* 1DD8: ..(... */
	0x00,0x00,0xFD,0x1E,0x07,0x00,0x02,0xC9,	/* 1DE0: ...... */
	0xFD,0x1E,0x06,0x00,0x09,0xFD,0x1E,0x07,	/* 1DE8: ...... */
	0x00,0x00,0xC9,0x02,0x44,0x02,0x44,0x02,	/* 1DF0: ...D.D. */
	0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,	/* 1DF8: @.@.@.@. */
	0x44,0x02,0x44,0x02,0x44,0x02,0x44,0x02,	/* 1E00: D.D.D.D. */
	0x44,0x02,0x40,0x02,0x40,0x02,0x44,0x02,	/* 1E08: D.@.@.D. */
	0x44,0x20,0x1E,0x44,0x03,0x44,0x02,0x44,	/* 1E10: D .D.D.D */
	0x02,0x44,0x01,0x40,0x20,0x14,0x44,0x03,	/* 1E18: .D.@ .D. */
	0x40,0x12,0x44,0x05,0x40,0x03,0x40,0x16,	/* 1E20: @.D.@.@. */
	0x44,0x02,0x40,0x07,0x44,0x0A,0x40,0x05,	/* 1E28: D.@.D.@. */
	0x40,0x11,0x40,0x20,0x03,0x40,0x18,0x44,	/* 1E30: @.@ .@.D */
	0x12,0x44,0x09,0x44,0x02,0x44,0x20,0x46,	/* 1E38: .D.D.D F */
	0x40,0x17,0x44,0x06,0x44,0x06,0x44,0x03,	/* 1E40: @.D.D.D. */
	0x44,0x04,0x44,0x0D,0x44,0x02,0x44,0x06,	/* 1E48: D.D.D.D. */
	0x44,0x02,0x44,0x20,0x18,0x40,0x1F,0x44,	/* 1E50: D.D .@.D */
	0x05,0x44,0x07,0x44,0x18,0x44,0x20,0x0C,	/* 1E58: .D.D.D . */
	0x44,0x06,0x44,0x02,0x44,0x01,0x44,0x0F,	/* 1E60: D.D.D.D. */
	0x44,0x15,0x44,0x08,0x44,0x03,0x44,0x0D,	/* 1E68: D.D.D.D. */
	0x44,0x1D,0x44,0x01,0x44,0x14,0x40,0x08,	/* 1E70: D.D.D.@. */
	0x40,0x03,0x44,0x06,0x40,0x03,0x44,0x06,	/* 1E78: @.D.@.D. */
	0x40,0x03,0x44,0x06,0x40,0x03,0x44,0x0F,	/* 1E80: @.D.@.D. */
	0x44,0x04,0x44,0x0F,0x44,0x04,0x44,0x03,	/* 1E88: D.D.D.D. */
	0x44,0x20,0x34,0x44,0x04,0x44,0x11,0x44,	/* 1E90: D 4D.D.D */
	0x04,0x44,0x14,0x44,0x04,0x44,0x02,0x40,	/* 1E98: .D.D.D.@ */
	0x1B,0x44,0x0A,0x40,0x03,0x44,0x05,0x40,	/* 1EA0: .D.@.D.@ */
	0x05,0x44,0x0F,0x40,0x02,0x44,0x02,0x40,	/* 1EA8: .D.@.D.@ */
	0x20,0x0E,0x44,0x18,0x40,0x10,0x44,0x05,	/* 1EB0:  .D.@.D. */
	0x44,0x05,0x44,0x0B,0x44,0x14,0x44,0x03,	/* 1EB8: D.D.D.D. */
	0x44,0x08,0x44,0x02,0x44,0x10,0x44,0x44,	/* 1EC0: D.D.D.DD */
	0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,	/* 1EC8: DDDDDDDD */
	0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,	/* 1ED0: DDDDDDDD */
	0x40,0x40,0x44,0x44,0x40,0x40,0x20,0x00,	/* 1ED8: @@DD@@ . */
	0x44,0x20,0x01,0x44,0x10,0x44,0x10,0x44,	/* 1EE0: D .D.D.D */
	0x05,0x44,0x20,0x04,0x44,0x14,0x44,0x06,	/* 1EE8: .D .D.D. */
	0x44,0x0A,0x44,0x04,0x44,0x04,0x44,0x05,	/* 1EF0: D.D.D.D. */
	0x44,0x03,0x44,0x0F,0x44,0x0B,0x44,0x03,	/* 1EF8: D.D.D.D. */
	0x44,0x03,0x44,0x03,0x44,0x0C,0x44,0x05,	/* 1F00: D.D.D.D. */
	0x44,0x03,0x44,0x05,0x44,0x0E,0x44,0x06,	/* 1F08: D.D.D.D. */
	0x44,0x0B,0x44,0x07,0x44,0x02,0x44,0x03,	/* 1F10: D.D.D.D. */
	0x44,0x06,0x44,0x0D,0x44,0x06,0x44,0x02,	/* 1F18: D.D.D.D. */
	0x44,0x03,0x44,0x05,0x44,0x20,0x02,0x44,	/* 1F20: D.D.D .D */
	0x03,0x44,0x05,0x44,0x16,0x44,0x1A,0x44,	/* 1F28: .D.D.D.D */
	0x0E,0x44,0x16,0x44,0x03,0x44,0x05,0x44,	/* 1F30: .D.D.D.D */
	0x04,0x44,0x19,0x44,0x04,0x44,0x01,0x44,	/* 1F38: .D.D.D.D */
	0x03,0x44,0x05,0x44,0x05,0x44,0x06,0x44,	/* 1F40: .D.D.D.D */
	0x02,0x44,0x0C,0x44,0x05,0x44,0x09,0x44,	/* 1F48: .D.D.D.D */
	0x0A,0x44,0x0B,0x44,0x08,0x44,0x20,0x09,	/* 1F50: .D.D.D . */
	0x44,0x12,0x44,0x02,0x44,0x20,0x1C,0x44,	/* 1F58: D.D.D .D */
	0x20,0x2E,0x44,0x11,0x44,0x20,0x28,0x44,	/* 1F60:  .D.D (D */
	0x13,0x44,0x09,0x44,0x12,0x40,0x03,0x40,	/* 1F68: .D.D.@.@ */
	0x20,0x01,0x40,0x03,0x40,0x21,0x4F,0x44,	/* 1F70:  .@.@!OD */
	0x20,0x4B,0x44,0x20,0x34,0x40,0x03,0x44,	/* 1F78:  KD 4@.D */
	0x0D,0x40,0x08,0x44,0x08,0x44,0x03,0x44,	/* 1F80: .@.D.D.D */
	0x01,0x44,0x03,0x44,0x01,0x40,0x03,0x44,	/* 1F88: .D.D.@.D */
	0x01,0x40,0x03,0x44,0x03,0x44,0x01,0x44,	/* 1F90: .@.D.D.D */
	0x0A,0x44,0x0B,0x44,0x15,0x40,0x16,0x40,	/* 1F98: .D.D.@.@ */
	0x06,0x44,0x0E,0x40,0x06,0x40,0x04,0x44,	/* 1FA0: .D.@.@.D */
	0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x44,	/* 1FA8: DDDDD@@D */
	0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,	/* 1FB0: DDDDDDDD */
	0x44,0x0F,0x44,0x06,0x44,0x05,0x44,0x20,	/* 1FB8: D.D.D.D  */
	0x08,0x44,0x20,0x39,0x44,0x03,0x44,0x04,	/* 1FC0: .D 9D.D. */
	0x44,0x0A,0x44,0x05,0x44,0x0D,0x44,0x20,	/* 1FC8: D.D.D.D  */
	0x04,0x40,0x13,0x40,0x20,0x4A,0x40,0x21,	/* 1FD0: .@.@ J@! */
	0x2E,0x40,0x14,0x44,0x06,0x40,0x15,0x44,	/* 1FD8: .@.D.@.D */
	0x06,0x40,0x20,0x7F,0x40,0x20,0x22,0x40,	/* 1FE0: .@ @ "@ */
	0x20,0x61,0x40,0x20,0x25,0x40,0x20,0x3B,	/* 1FE8:  a@ %@ ; */
	0x40,0x04,0x40,0x20,0xE1,0x40,0x1F,0x40,	/* 1FF0: @.@ @.@ */
	0x06,0x44,0x03,0x40,0x05,0x40,0x20,0x13,	/* 1FF8: .D.@.@ . */
	0x44,0x1D,0x40,0x20,0x0E,0x44,0x02,0x40,	/* 2000: D.@ .D.@ */
	0x02,0x40,0x03,0x44,0x20,0x05,0x40,0x02,	/* 2008: .@.D .@. */
	0x40,0x03,0x44,0x01,0x44,0x1D,0x44,0x20,	/* 2010: @.D.D.D  */
	0x2B,0x44,0x07,0x40,0x07,0x44,0x01,0x40,	/* 2018: +D.@.D.@ */
	0x06,0x40,0x09,0x40,0x04,0x40,0x13,0x40,	/* 2020: .@.@.@.@ */
	0x01,0x44,0x20,0x03,0x44,0x0B,0x40,0x0A,	/* 2028: .D .D.@. */
	0x40,0x12,0x40,0x05,0x44,0x20,0x03,0x40,	/* 2030: @.@.D .@ */
	0x06,0x44,0x04,0x44,0x04,0x44,0x16,0x40,	/* 2038: .D.D.D.@ */
	0x22,0xEE,0x44,0x20,0x0D,0x44,0x16,0x44,	/* 2040: "D .D.D */
	0x13,0x44,0x06,0x44,0x08,0x44,0x20,0x40,	/* 2048: .D.D.D @ */
	0x44,0x0E,0x44,0x20,0x13,0x44,0x06,0x40,	/* 2050: D.D .D.@ */
	0x14,0x44,0x04,0x44,0x06,0x44,0x1A,0x40,	/* 2058: .D.D.D.@ */
	0x20,0x5D,0x44,0x17,0x44,0x08,0x44,0x20,	/* 2060:  ]D.D.D  */
	0x1C,0x44,0x06,0x40,0x02,0x44,0x03,0x44,	/* 2068: .D.@.D.D */
	0x05,0x44,0x0D,0x44,0x02,0x44,0x20,0x26,	/* 2070: .D.D.D & */
	0x40,0x02,0x40,0x20,0x1F,0x40,0x06,0x44,	/* 2078: @.@ .@.D */
	0x05,0x44,0x0C,0x44,0x05,0x44,0x12,0x44,	/* 2080: .D.D.D.D */
	0x12,0x44,0x14,0x44,0x05,0x44,0x0E,0x44,	/* 2088: .D.D.D.D */
	0x20,0x09,0x44,0x05,0x44,0x0E,0x40,0x1E,	/* 2090:  .D.D.@. */
	0x40,0x07,0x40,0x20,0x08,0x40,0x04,0x40,	/* 2098: @.@ .@.@ */
	0x01,0x40,0x11,0x40,0x19,0x40,0x0A,0x40,	/* 20A0: .@.@.@.@ */
	0x18,0x40,0x08,0x40,0x0C,0x40,0x01,0x40,	/* 20A8: .@.@.@.@ */
	0x0E,0x40,0x0A,0x44,0x20,0x30,0x40,0x20,	/* 20B0: .@.D 0@  */
	0x37,0x40,0x03,0x40,0x00,0x00           	/* 20B8: 7@.@..   */

};
int si2_z280_dsize = sizeof(si2_z280_download);		/* 0x20BE (8382) */

unsigned short si2_z280_downloadaddr = 0x0000;

/* End of SI2_Z280.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\purge.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    purge.c

Abstract:

    This module contains the code that is very specific to purge
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.

Arguments:

    pPort - Pointer to the device extension.

Return Value:

    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.

--*/

{

    PIRP NewIrp;

    do {

        ULONG Mask;

        Mask = *((ULONG *)
                 (pPort->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

        if (Mask & SERIAL_PURGE_TXABORT) {

            SerialKillAllReadsOrWrites(
                pPort->DeviceObject,
                &pPort->WriteQueue,
                &pPort->CurrentWriteIrp
                );

            SerialKillAllReadsOrWrites(
                pPort->DeviceObject,
                &pPort->WriteQueue,
                &pPort->CurrentXoffIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXABORT) {

            SerialKillAllReadsOrWrites(
                pPort->DeviceObject,
                &pPort->ReadQueue,
                &pPort->CurrentReadIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXCLEAR) {

            KIRQL OldIrql;

            //
            // Clean out the interrupt buffer.
            //
            // Note that we do this under protection of the
            // the driver's control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.
            //

            KeAcquireSpinLock(
                &pPort->ControlLock,
                &OldIrql
                );

	    Slxos_SyncExec(pPort,SerialPurgeInterruptBuff,pPort,0x16);

            KeReleaseSpinLock(
                &pPort->ControlLock,
                OldIrql
                );

        }

        if(Mask&SERIAL_PURGE_TXCLEAR)
        {
		KIRQL OldIrql;

		KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);
		Slxos_SyncExec(pPort,Slxos_FlushTxBuff,pPort,0x17);
		KeReleaseSpinLock(&pPort->ControlLock,OldIrql);
        }

        pPort->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        pPort->CurrentPurgeIrp->IoStatus.Information = 0;

        SerialGetNextIrp(pPort, &pPort->CurrentPurgeIrp, &pPort->PurgeQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return STATUS_SUCCESS;

}

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply resets the interrupt (typeahead) buffer.

    NOTE: This routine is being called from KeSynchronizeExecution.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The typeahead buffer is by definition empty if there
    // currently is a read owned by the isr.
    //


    if (pPort->ReadBufferBase == pPort->InterruptReadBuffer) {

        pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
        pPort->FirstReadableChar = pPort->InterruptReadBuffer;
        pPort->LastCharSlot = pPort->InterruptReadBuffer +
                                      (pPort->BufferSize - 1);
    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
        pPort->CharsInInterruptBuffer = 0;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

        SerialHandleReducedIntBuffer(pPort);

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\si3_t225.c ===
/* SI3_T225.C Version, Bootstrap and Download Code Arrays... */

char *si3_t225_ident = "%W%";

/* SI3_T225 embedded version... 

	Copyright (c) Perle Systems Ltd 1996-2000.
	JET__.BIN Version 4.0.4 Created Sep 18 2000 @ 14:55:45

*/

unsigned char si3_t225_bootstrap[] =
{
	0x28,0x20,0x21,0x02,0x60,0x0a
};
int si3_t225_bsize = sizeof(si3_t225_bootstrap);

unsigned short si3_t225_bootloadaddr = 0x8000 - sizeof(si3_t225_bootstrap);

unsigned char si3_t225_download[] =
{
	0x00,0x00,0x1C,0x5D,0x00,0x00,0x00,0x00,	/* 0000: ...].... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0008: ........ */
	0x24,0xF2,0x21,0xF8,0x24,0xF2,0x21,0xFC,	/* 0010: $!$! */
	0x22,0xF9,0x25,0xF7,0x46,0x23,0xFC,0xD4,	/* 0018: "%F# */
	0x40,0x31,0xD1,0x21,0x20,0x20,0x20,0x40,	/* 0020: @1!   @ */
	0x71,0xF4,0xD2,0x23,0x4B,0xD3,0x73,0x72,	/* 0028: q#Ksr */
	0x71,0x24,0xFA,0x74,0x23,0xFC,0x2F,0x2F,	/* 0030: q$t#.. */
	0x2F,0x4E,0xF6,0x4D,0x6F,0x6E,0x20,0x53,	/* 0038: .NMon S */
	0x65,0x70,0x20,0x31,0x38,0x20,0x31,0x34,	/* 0040: ep 18 14 */
	0x3A,0x35,0x35,0x3A,0x34,0x38,0x20,0x32,	/* 0048: :55:48 2 */
	0x30,0x30,0x30,0x0A,0x00,0x6A,0x65,0x74,	/* 0050: 000..jet */
	0x2E,0x65,0x70,0x72,0x00,0x20,0x20,0x22,	/* 0058: .epr.  " */
	0xB0,0x21,0x12,0xDD,0x24,0xF2,0x21,0xF8,	/* 0060: !.$! */
	0x24,0xF2,0x21,0xFC,0x22,0xF9,0x25,0xF8,	/* 0068: $!"% */
	0x40,0xDE,0x4B,0xDF,0x24,0xF2,0x7E,0x24,	/* 0070: @K$~$ */
	0xF2,0xFA,0xE0,0x1E,0x4B,0x22,0xF1,0x40,	/* 0078: .K"@ */
	0x25,0xF4,0x22,0x46,0x21,0xFB,0xD0,0x24,	/* 0080: %"F!$ */
	0xF2,0xD1,0x24,0x4B,0x21,0xFB,0xD2,0x72,	/* 0088: $K!r */
	0x84,0x21,0xD0,0x72,0x30,0x21,0x70,0xF2,	/* 0090: !r0!p */
	0x21,0xD1,0x21,0x71,0xD2,0x1B,0xD3,0x7D,	/* 0098: !!q.} */
	0xD4,0x40,0xD5,0x1C,0xD6,0x19,0xD7,0x1A,	/* 00A0: @... */
	0xD8,0x21,0x70,0xF6,0x60,0xBC,0x7D,0x27,	/* 00A8: !p`}' */
	0x88,0xDD,0x22,0x40,0x21,0xFB,0xD0,0x44,	/* 00B0: "@!D */
	0x24,0xF2,0xFA,0xD1,0x24,0xF2,0xD2,0x7B,	/* 00B8: $${ */
	0x83,0x60,0x4C,0x24,0xF6,0x21,0x71,0xF2,	/* 00C0: `L$!q */
	0xD3,0x7D,0xD4,0x24,0xF2,0xD5,0x7A,0x7D,	/* 00C8: }$z} */
	0xF2,0xD6,0x79,0x73,0xF2,0xF6,0x21,0xF5,	/* 00D0: ys! */
	0x20,0x6A,0x03,0x00,0x00,0x60,0xB0,0x40,	/* 00D8:  j...`@ */
	0xD1,0x40,0xDE,0x21,0x75,0x67,0x88,0xDD,	/* 00E0: @!ug */
	0x40,0x21,0x73,0xE0,0x10,0x23,0x24,0x91,	/* 00E8: @!s.#$ */
	0x28,0x45,0x71,0xF4,0x22,0x2B,0xAE,0x71,	/* 00F0: (Eq"+q */
	0x46,0x24,0xF0,0xDF,0x71,0x23,0x4F,0x24,	/* 00F8: F$q#O$ */
	0xF6,0xD5,0x7F,0xC0,0x23,0xAC,0x7E,0xA7,	/* 0100: #~ */
	0x7C,0xD6,0x76,0x75,0xF2,0xDC,0x02,0x7D,	/* 0108: |vu.} */
	0xD6,0x75,0xA6,0x75,0x76,0x10,0x22,0x2F,	/* 0110: uuv.". */
	0x9A,0x40,0xD2,0x44,0xD3,0x74,0x41,0x72,	/* 0118: @DtAr */
	0x24,0xF1,0x24,0xF6,0x21,0xA4,0x72,0x21,	/* 0120: $$!r! */
	0x71,0xFA,0x71,0xFE,0x75,0xAC,0x76,0x27,	/* 0128: qquv' */
	0x88,0x21,0x74,0xF2,0x72,0x21,0x71,0xFA,	/* 0130: !tr!q */
	0x75,0xFB,0x12,0x22,0x42,0x22,0xF1,0x22,	/* 0138: u."B"" */
	0x26,0x0D,0x7F,0xC2,0x22,0x25,0xAE,0x75,	/* 0140: &."%u */
	0xC0,0xA7,0x41,0xDE,0x40,0xD4,0x22,0x25,	/* 0148: A@"% */
	0x03,0x75,0xC9,0xA7,0x41,0xDE,0x40,0xD4,	/* 0150: .uA@ */
	0x22,0x24,0x09,0x75,0xC7,0xA7,0x41,0xDE,	/* 0158: "$.uA */
	0x40,0xD4,0x22,0x23,0x0F,0x75,0xC1,0xA7,	/* 0160: @"#.u */
	0x40,0xDE,0x40,0xD4,0x22,0x23,0x05,0x75,	/* 0168: @@"#.u */
	0xC2,0x22,0xA6,0x41,0xD2,0x72,0x21,0xAE,	/* 0170: "Ar! */
	0x10,0x22,0x2B,0x95,0x71,0x28,0xC2,0xA4,	/* 0178: ."+q( */
	0x72,0x81,0xD2,0x08,0x71,0x28,0xC3,0xA4,	/* 0180: r.q( */
	0x72,0x60,0x8F,0xD2,0x72,0xA6,0x7B,0x21,	/* 0188: r`r{! */
	0x71,0xFA,0x71,0xFE,0x62,0x0F,0x22,0x20,	/* 0190: qqb."  */
	0x0B,0x75,0xC4,0xAC,0x1C,0x10,0x22,0x24,	/* 0198: .u.."$ */
	0x95,0x7C,0x21,0x76,0xE0,0x21,0x2F,0x0C,	/* 01A0: |!v!.. */
	0x75,0xC6,0xA9,0x21,0x78,0x10,0x22,0x23,	/* 01A8: u!x."# */
	0x95,0x21,0x2F,0x00,0x75,0xCB,0xA9,0x21,	/* 01B0: !..u! */
	0x77,0x10,0x22,0x22,0x99,0x21,0x2E,0x04,	/* 01B8: w.""!.. */
	0x75,0xC8,0xAC,0x1C,0x10,0x22,0x21,0x9E,	/* 01C0: u.."! */
	0x7C,0x21,0x77,0xE0,0x21,0x2D,0x05,0x75,	/* 01C8: |!w!-.u */
	0xCA,0xAC,0x1C,0x10,0x22,0x20,0x9F,0x7C,	/* 01D0: .." | */
	0x21,0x78,0xE0,0x21,0x2C,0x06,0x75,0xCC,	/* 01D8: !x!,.u */
	0x2C,0xA5,0x40,0xD6,0x40,0xDA,0x40,0xD8,	/* 01E0: ,@@@ */
	0x7D,0xD7,0x41,0xD6,0x10,0x22,0x24,0x91,	/* 01E8: }A."$ */
	0x23,0x4F,0x71,0xF9,0xC0,0xD6,0x76,0x22,	/* 01F0: #Oqv" */
	0xA7,0x7A,0x41,0xF2,0xDA,0x40,0xD2,0x44,	/* 01F8: zA@D */
	0xD3,0x74,0x41,0x72,0x24,0xF1,0x24,0xF6,	/* 0200: tAr$$ */
	0xA6,0x72,0x21,0x71,0xFA,0x71,0xFE,0x12,	/* 0208: r!qq. */
	0x21,0x43,0x22,0xF1,0x10,0x22,0x21,0x99,	/* 0210: !C"."! */
	0x23,0x4F,0x71,0xF9,0xC0,0xD6,0x62,0x06,	/* 0218: #Oqb. */
	0x71,0x23,0x4F,0x24,0xF6,0xD5,0x7A,0x40,	/* 0220: q#O$z@ */
	0xF9,0x23,0xA0,0x75,0xA6,0x75,0x77,0x10,	/* 0228: #uuw. */
	0x21,0x2E,0x90,0x40,0xD2,0x44,0xD3,0x74,	/* 0230: !.@Dt */
	0x41,0x72,0x24,0xF1,0x24,0xF6,0x21,0xA4,	/* 0238: Ar$$! */
	0x72,0x21,0x71,0xFA,0x71,0xFE,0x75,0xAC,	/* 0240: r!qqu */
	0x77,0x27,0x88,0x21,0x74,0xF2,0x72,0x21,	/* 0248: w'!tr! */
	0x71,0xFA,0x75,0xFB,0x12,0x22,0x42,0x22,	/* 0250: qu."B" */
	0xF1,0x24,0x0A,0x41,0xD6,0x76,0x21,0xAF,	/* 0258: $.Av! */
	0x75,0x77,0x10,0x21,0x2A,0x9D,0x77,0x75,	/* 0260: uw.!*wu */
	0xF2,0xD7,0x78,0x75,0xF2,0xD8,0x10,0x21,	/* 0268: xu.! */
	0x2B,0x9F,0x23,0x4F,0x71,0xF9,0xD6,0x71,	/* 0270: +#Oqq */
	0x23,0x4F,0x24,0xF6,0xD5,0x62,0x0E,0x40,	/* 0278: #O$b.@ */
	0xD2,0x44,0xD3,0x74,0x41,0x72,0x24,0xF1,	/* 0280: DtAr$ */
	0x24,0xF6,0x21,0xA4,0x72,0x21,0x71,0xFA,	/* 0288: $!r!q */
	0x78,0xFE,0x78,0xAC,0x7D,0x27,0x88,0x21,	/* 0290: xx}'! */
	0x74,0xF2,0x72,0x21,0x71,0xFA,0x78,0xFB,	/* 0298: tr!qx */
	0x12,0x22,0x42,0x22,0xF1,0x2F,0x0D,0x75,	/* 02A0: ."B"..u */
	0xCD,0x22,0xAB,0x40,0xD6,0x7A,0xD7,0x77,	/* 02A8: "@zw */
	0x22,0xA0,0x10,0x21,0x27,0x9B,0x40,0xD2,	/* 02B0: ".!'@ */
	0x44,0xD3,0x74,0x41,0x72,0x24,0xF1,0x24,	/* 02B8: DtAr$$ */
	0xF6,0xA6,0x72,0x21,0x71,0xFA,0x71,0xFE,	/* 02C0: r!qq */
	0x12,0x21,0x43,0x22,0xF1,0x16,0x22,0x40,	/* 02C8: .!C"."@ */
	0x22,0xF1,0x40,0xDA,0x2C,0x0E,0x75,0xCE,	/* 02D0: "@,.u */
	0x2C,0xAA,0x40,0xD0,0x40,0xD2,0x40,0xD3,	/* 02D8: ,@@@ */
	0x41,0xD0,0x70,0x22,0xA7,0x73,0x72,0x46,	/* 02E0: Ap"srF */
	0x23,0xF6,0xD2,0xD3,0x10,0x21,0x24,0x91,	/* 02E8: #.!$ */
	0x71,0x23,0x4F,0x24,0xF6,0x21,0xFD,0xD8,	/* 02F0: q#O$! */
	0xD9,0x40,0x72,0x78,0x23,0xF7,0xD2,0x73,	/* 02F8: @rx#s */
	0x79,0x23,0xF7,0xD3,0x2C,0x40,0x71,0xF9,	/* 0300: y#,@q */
	0xC0,0xD0,0x62,0x06,0x28,0x20,0x40,0xD6,	/* 0308: b.( @ */
	0x40,0xD7,0x73,0x77,0xF9,0xC0,0x21,0xA1,	/* 0310: @sw! */
	0x73,0x77,0xF4,0xC0,0xAD,0x72,0x24,0xF2,	/* 0318: swr$ */
	0x23,0xF3,0x76,0x24,0xF2,0x23,0xF3,0xF9,	/* 0320: #v$# */
	0xC0,0xC0,0x27,0xA8,0x73,0x77,0xF9,0xC0,	/* 0328: 'sw */
	0x21,0xA1,0x73,0x77,0xF4,0xC0,0xAD,0x72,	/* 0330: !swr */
	0x24,0xF2,0x23,0xF3,0x76,0x24,0xF2,0x23,	/* 0338: $#v$# */
	0xF3,0xF9,0xC0,0xC0,0x25,0xAE,0x40,0x72,	/* 0340: %@r */
	0x76,0x24,0xFF,0xD8,0x73,0x77,0x24,0xFF,	/* 0348: v$sw$ */
	0xD9,0x79,0x40,0xF9,0xC0,0xAC,0x79,0xC0,	/* 0350: y@y */
	0xAA,0x78,0x24,0xF2,0x23,0xF3,0x60,0x4F,	/* 0358: x$#`O */
	0xF9,0xC0,0xC0,0x21,0xAE,0x76,0x24,0xF2,	/* 0360: !v$ */
	0xF2,0x2F,0x4F,0xF0,0x27,0x2F,0x2F,0x4F,	/* 0368: .O'..O */
	0xF0,0x24,0x96,0x40,0x76,0x27,0x2F,0x2F,	/* 0370: $@v'.. */
	0x4F,0x23,0xF7,0xD6,0x77,0x40,0x23,0xF7,	/* 0378: O#w@# */
	0xD7,0x21,0x0F,0x40,0x72,0x76,0x24,0xFF,	/* 0380: !.@rv$ */
	0xD8,0x73,0x77,0x24,0xFF,0xD9,0x79,0x78,	/* 0388: sw$yx */
	0x24,0xFC,0xD0,0x76,0x24,0xF2,0xF2,0x2F,	/* 0390: $v$. */
	0x4F,0xF0,0x70,0xF0,0x21,0x9B,0x72,0xD6,	/* 0398: Op!r */
	0x73,0xD7,0x67,0x08,0x0A,0x75,0xDB,0x74,	/* 03A0: sg..ut */
	0x41,0x7B,0x24,0xF1,0x24,0xFB,0xD4,0x10,	/* 03A8: A{$$. */
	0x27,0x9F,0x62,0x23,0x0B,0x21,0xB0,0x22,	/* 03B0: 'b#.!" */
	0xF0,0x60,0xBE,0x41,0xD0,0x70,0xD1,0x75,	/* 03B8: `Apu */
	0x73,0x23,0xFB,0x74,0x71,0xF9,0x21,0xAB,	/* 03C0: s#tq! */
	0x70,0x74,0x71,0xF4,0xF9,0xA4,0x74,0x71,	/* 03C8: ptqtq */
	0xF4,0xD0,0x73,0x71,0x73,0xF2,0x70,0x24,	/* 03D0: sqsp$ */
	0xFA,0x71,0x70,0xF2,0xD1,0x70,0x70,0xF2,	/* 03D8: qppp */
	0xD0,0x61,0x00,0xB2,0x22,0xF0,0x60,0xBF,	/* 03E0: a."` */
	0x40,0xD0,0x40,0x73,0xE0,0x41,0xD0,0x70,	/* 03E8: @@sAp */
	0x21,0xAE,0x73,0x30,0x46,0x24,0xF1,0x73,	/* 03F0: !s0F$s */
	0xE0,0x72,0x23,0x95,0x73,0x30,0x72,0x31,	/* 03F8: r#s0r1 */
	0x23,0x4F,0x24,0xF6,0xF2,0x73,0xE0,0x2C,	/* 0400: #O$s, */
	0x40,0x72,0x31,0xF9,0xC0,0xD0,0x62,0x0F,	/* 0408: @r1b. */
	0xB1,0x22,0xF0,0x71,0x21,0x33,0x30,0x71,	/* 0410: "q!30q */
	0x21,0x32,0xF2,0x72,0x27,0x88,0x71,0x21,	/* 0418: !2r'q! */
	0x34,0xF2,0x73,0x24,0xFA,0x71,0x21,0x33,	/* 0420: 4s$q!3 */
	0x30,0x73,0xF5,0x71,0x21,0x33,0xE0,0x22,	/* 0428: 0sq!3" */
	0xF0,0x71,0x21,0x33,0x30,0x71,0x21,0x32,	/* 0430: q!30q!2 */
	0xF2,0xF1,0x71,0xE1,0x71,0x21,0x33,0x30,	/* 0438: qq!30 */
	0x81,0x71,0x21,0x33,0xE0,0x22,0xF0,0x8A,	/* 0440: q!3" */
	0xF4,0x2C,0x89,0x3C,0x00,0x00,0x07,0x00,	/* 0448: ,<.... */
	0x00,0x08,0x00,0x00,0x00,0x81,0x00,0x80,	/* 0450: ...... */
	0xFF,0x7F,0xFF,0x7F,0xC4,0x8E,0x80,0x8E,	/* 0458:  */
	0x46,0x8E,0xFF,0x80,0x00,0x00,0x02,0x00,	/* 0460: F.... */
	0x01,0x00,0x5C,0x00,0xEE,0x57,0xEE,0x57,	/* 0468: ..\.WW */
	0x0C,0x00,0x06,0x00,0x2E,0x81,0x00,0x00,	/* 0470: ....... */
	0xFF,0x80,0x00,0x00,0xFF,0x80,0x00,0x00,	/* 0478: .... */
	0xFF,0x80,0xFF,0x80,0x2C,0x8E,0x03,0x00,	/* 0480: ,.. */
	0x3C,0x02,0x00,0x02,0x00,0x11,0x00,0x7C,	/* 0488: <......| */
	0x8E,0x02,0x00,0x12,0x00,0x46,0x8E,0x02,	/* 0490: ....F. */
	0x00,0x13,0x00,0xFF,0x80,0x60,0xBC,0x21,	/* 0498: ...`! */
	0xF5,0x00,0x00,0x00,0x00,0x54,0x57,0x00,	/* 04A0: ....TW. */
	0x00,0xD4,0x47,0xC6,0x02,0x06,0x00,0xC6,	/* 04A8: .G... */
	0x83,0x00,0x00,0xFF,0x80,0x5C,0x02,0xD0,	/* 04B0: ..\. */
	0x83,0x00,0x08,0x2C,0x86,0xFF,0x80,0x2C,	/* 04B8: ..,, */
	0x8E,0x04,0x00,0x04,0x00,0x20,0x02,0x00,	/* 04C0: .... .. */
	0x11,0x00,0xC0,0x8E,0x02,0x00,0x12,0x00,	/* 04C8: ...... */
	0x80,0x8E,0x02,0x00,0x13,0x00,0xFF,0x80,	/* 04D0: .... */
	0x02,0x00,0x04,0x00,0xBC,0x8E,0x00,0x00,	/* 04D8: ...... */
	0x00,0x00,0x60,0xBC,0x21,0xF5,0x8A,0x2E,	/* 04E0: ..`!. */
	0x89,0x06,0x7C,0x8E,0x46,0x8E,0xFF,0x80,	/* 04E8: .|F */
	0x8A,0xCB,0x06,0x89,0x06,0xC0,0x8E,0x80,	/* 04F0: .. */
	0x8E,0xFF,0x80,0x86,0xF4,0x2C,0x8B,0xC5,	/* 04F8: , */
	0xDD,0x15,0x85,0x00,0x00,0x00,0x00,0x60,	/* 0500: .....` */
	0xBC,0x75,0x30,0x20,0xD3,0x73,0x38,0x30,	/* 0508: u0 s80 */
	0x6C,0x48,0xF2,0x75,0x25,0x95,0xA5,0x28,	/* 0510: lHu%( */
	0x4E,0x75,0x25,0x93,0x26,0x44,0xD0,0x73,	/* 0518: Nu%&Ds */
	0x51,0x73,0x50,0x75,0x24,0x9D,0xA5,0x28,	/* 0520: QsPu$( */
	0x41,0x75,0x24,0x93,0x73,0x31,0xD0,0x26,	/* 0528: Au$s1& */
	0x44,0xD1,0x40,0xD2,0x73,0x39,0x73,0x30,	/* 0530: D@s9s0 */
	0x75,0x24,0x90,0xA5,0x29,0x44,0x75,0x22,	/* 0538: u$)Du" */
	0x9E,0x2C,0x48,0xD0,0x73,0x53,0x73,0x52,	/* 0540: ,HsSsR */
	0x75,0x22,0x98,0xA5,0x28,0x45,0x75,0x21,	/* 0548: u"(Eu! */
	0x9E,0x73,0x33,0xD0,0x2C,0x48,0xD1,0x40,	/* 0550: s3,H@ */
	0xD2,0x73,0x3A,0x73,0x32,0x75,0x21,0x9B,	/* 0558: s:s2u! */
	0xA4,0x28,0x45,0x75,0x9A,0x75,0x21,0x9B,	/* 0560: (Euu! */
	0xB4,0x22,0xF0,0x2B,0x0E,0x20,0x20,0x2E,	/* 0568: "+.  . */
	0x02,0x20,0x20,0x28,0x02,0x20,0x20,0x22,	/* 0570: .  (.  " */
	0x28,0x0B,0x20,0x24,0x28,0x2E,0x05,0x22,	/* 0578: (. $(.." */
	0x2C,0x0B,0x20,0x21,0x29,0x0D,0x20,0x03,	/* 0580: ,. !). . */
	0x00,0x02,0x00,0x01,0x00,0x00,0x00,0xDC,	/* 0588: ....... */
	0x00,0x60,0xBF,0x72,0x21,0x5F,0x20,0x20,	/* 0590: .`r!_   */
	0xD0,0x70,0x72,0xE0,0x20,0x22,0x46,0x21,	/* 0598: pr "F! */
	0xFB,0x25,0xFA,0x30,0xF2,0x70,0xEA,0x21,	/* 05A0: %0p! */
	0x4A,0x21,0xFB,0x25,0xFA,0x30,0xF2,0x70,	/* 05A8: J!%0p */
	0xE9,0x70,0x2C,0x5F,0x20,0x20,0x70,0xE8,	/* 05B0: p,_  p */
	0x70,0x63,0x4A,0x21,0xFB,0x44,0x24,0x2F,	/* 05B8: pcJ!D$. */
	0x2D,0x9B,0xB1,0x22,0xF0,0x40,0x02,0x86,	/* 05C0: -"@. */
	0x02,0x01,0x00,0x00,0x00,0x60,0xBE,0x73,	/* 05C8: .....`s */
	0x31,0x20,0xD1,0x41,0x74,0x71,0x32,0x30,	/* 05D0: 1 Atq20 */
	0x24,0xFF,0xF0,0xC0,0xA5,0x24,0xF2,0xB2,	/* 05D8: $$ */
	0x22,0xF0,0x71,0x30,0xD0,0x71,0x30,0x74,	/* 05E0: "q0q0t */
	0xF2,0x71,0xE0,0x71,0x32,0x30,0x74,0xF4,	/* 05E8: qq20t */
	0x71,0x32,0xE0,0x70,0xB2,0x22,0xF0,0x60,	/* 05F0: q2p"` */
	0xBF,0x75,0xC0,0xA4,0x24,0x20,0x40,0xD5,	/* 05F8: u$ @ */
	0x21,0x40,0x72,0x63,0x98,0x73,0xE0,0x75,	/* 0600: !@rcsu */
	0x72,0x63,0x92,0x74,0xE0,0x73,0x30,0x24,	/* 0608: rcts0$ */
	0xF2,0xF4,0xA7,0x74,0x30,0x24,0xF2,0xF4,	/* 0610: t0$ */
	0xC0,0xA4,0x41,0xB1,0x22,0xF0,0x75,0xD0,	/* 0618: A"u */
	0x2A,0x45,0x74,0x30,0x72,0x23,0x95,0x40,	/* 0620: *Et0r#@ */
	0xB1,0x22,0xF0,0x60,0xBF,0x72,0x31,0x20,	/* 0628: "`r1  */
	0xD0,0x73,0x72,0x22,0x9B,0x70,0xE0,0x70,	/* 0630: sr"pp */
	0x30,0x67,0x20,0x20,0xC0,0xA5,0x28,0x4E,	/* 0638: 0g  (N */
	0xB1,0x22,0xF0,0x73,0x70,0xE1,0x73,0x70,	/* 0640: "spsp */
	0x32,0xE0,0x70,0x31,0x70,0x33,0xE0,0x40,	/* 0648: 2p1p3@ */
	0xB1,0x22,0xF0,0x72,0x21,0x20,0x40,0xE0,	/* 0650: "r! @ */
	0x71,0x9A,0x22,0xF0,0x25,0x24,0x23,0x01,	/* 0658: q"%$#. */
	0x25,0x21,0x28,0x01,0x24,0x29,0x2C,0x08,	/* 0660: %!(.$),. */
	0x20,0x00,0x00,0x94,0x00,0x60,0xBF,0x72,	/* 0668:  ...`r */
	0x22,0x5A,0x20,0x20,0xD0,0x70,0x72,0xE1,	/* 0670: "Z  pr */
	0x20,0x70,0x60,0x5C,0x20,0x20,0x70,0xE3,	/* 0678:  p`\  p */
	0x70,0x60,0x5B,0x20,0x20,0x70,0xE2,0x70,	/* 0680: p`[  pp */
	0x62,0x4D,0x21,0xFB,0x41,0x24,0x2F,0x20,	/* 0688: bM!A$.  */
	0x9C,0xB1,0x22,0xF0,0x20,0x02,0x00,0x00,	/* 0690: " ... */
	0x00,0x43,0x6F,0x70,0x79,0x72,0x69,0x67,	/* 0698: .Copyrig */
	0x68,0x74,0x20,0x28,0x63,0x29,0x20,0x50,	/* 06A0: ht (c) P */
	0x65,0x72,0x6C,0x65,0x20,0x53,0x79,0x73,	/* 06A8: erle Sys */
	0x74,0x65,0x6D,0x73,0x20,0x4C,0x74,0x64,	/* 06B0: tems Ltd */
	0x20,0x31,0x39,0x39,0x36,0x2D,0x32,0x30,	/* 06B8:  1996-20 */
	0x30,0x30,0x2E,0x0D,0x0A,0x4A,0x45,0x54,	/* 06C0: 00...JET */
	0x5F,0x5F,0x2E,0x42,0x49,0x4E,0x20,0x56,	/* 06C8: __.BIN V */
	0x65,0x72,0x73,0x69,0x6F,0x6E,0x20,0x34,	/* 06D0: ersion 4 */
	0x2E,0x30,0x2E,0x34,0x20,0x43,0x72,0x65,	/* 06D8: .0.4 Cre */
	0x61,0x74,0x65,0x64,0x20,0x53,0x65,0x70,	/* 06E0: ated Sep */
	0x20,0x31,0x38,0x20,0x32,0x30,0x30,0x30,	/* 06E8:  18 2000 */
	0x20,0x40,0x20,0x31,0x34,0x3A,0x35,0x35,	/* 06F0:  @ 14:55 */
	0x3A,0x34,0x35,0x00,0x45,0x30,0x20,0xC4,	/* 06F8: :45.E0  */
	0x00,0x60,0xBF,0x72,0x22,0x5E,0x20,0x20,	/* 0700: .`r"^   */
	0xD0,0x70,0x72,0xE2,0x20,0x61,0x4B,0x21,	/* 0708: pr aK! */
	0xFB,0x70,0x42,0x24,0xFA,0x67,0x40,0x21,	/* 0710: pB$g@! */
	0xFB,0x70,0xE1,0xB1,0x22,0xF0,0x20,0x03,	/* 0718: p" . */
	0x00,0x00,0x00,0x60,0xBD,0x74,0x33,0x20,	/* 0720: ...`t3  */
	0xD2,0x40,0xD1,0x71,0x72,0xE0,0x27,0x20,	/* 0728: @qr'  */
	0x20,0x40,0xD0,0x40,0x71,0x74,0x26,0x9C,	/* 0730:  @@qt& */
	0x21,0x20,0x40,0xD0,0x40,0x27,0x2E,0x20,	/* 0738: ! @@'.  */
	0x40,0x74,0x26,0x90,0x24,0x40,0x72,0x30,	/* 0740: @t&$@r0 */
	0x81,0x23,0xFB,0x72,0x31,0x30,0x72,0x30,	/* 0748: #r10r0 */
	0xE2,0x26,0x44,0x72,0x30,0xE1,0x74,0x24,	/* 0750: &Dr0t$ */
	0x9F,0x72,0x30,0x23,0xFB,0x72,0x30,0xF1,	/* 0758: r0#r0 */
	0xC1,0x23,0xA3,0x28,0x40,0xD0,0x72,0x32,	/* 0760: #(@r2 */
	0x30,0x74,0x24,0x90,0x70,0x88,0xF1,0x2F,	/* 0768: 0t$p. */
	0x40,0x24,0xF6,0xC0,0xA5,0x74,0x23,0x98,	/* 0770: @$t# */
	0x21,0x0C,0x41,0x72,0x33,0x30,0x40,0x24,	/* 0778: !.Ar30@$ */
	0xFF,0xF0,0xC0,0xA9,0x72,0x34,0x30,0xC0,	/* 0780: r40 */
	0xA4,0x74,0x22,0x98,0x09,0x72,0x35,0x30,	/* 0788: t".r50 */
	0x74,0x22,0x95,0x74,0x22,0x96,0x21,0x20,	/* 0790: t"t"!  */
	0x40,0xD0,0x70,0x30,0x25,0xFA,0x41,0xF2,	/* 0798: @p0%A */
	0x70,0xE0,0x60,0x02,0x25,0x22,0x2E,0x09,	/* 07A0: p`.%".. */
	0x23,0x21,0x21,0x03,0x25,0x23,0x2D,0x02,	/* 07A8: #!!.%#-. */
	0x22,0x29,0x2F,0x06,0x21,0x29,0x2F,0x0D,	/* 07B0: ")..!).. */
	0x25,0x23,0x2A,0x08,0x23,0x28,0x0F,0x20,	/* 07B8: %#*.#(.  */
	0x20,0x00,0x00,0x6E,0x00,0x60,0xBF,0x72,	/* 07C0:  ..n.`r */
	0x23,0x50,0x20,0x20,0xD0,0x70,0x72,0xE3,	/* 07C8: #P  pr */
	0x20,0x70,0x60,0x51,0x20,0x20,0x70,0xE5,	/* 07D0:  p`Q  p */
	0x70,0x28,0x54,0x20,0x20,0x70,0xE4,0x70,	/* 07D8: p(T  pp */
	0x28,0x55,0x20,0x20,0x70,0xE3,0x70,0x61,	/* 07E0: (U  ppa */
	0x5F,0x20,0x20,0x70,0xE2,0x70,0x60,0x5E,	/* 07E8: _  pp`^ */
	0x20,0x20,0x70,0xE1,0x70,0x63,0x48,0x21,	/* 07F0:   ppcH! */
	0xFB,0x41,0x24,0x2D,0x29,0x9F,0xB1,0x22,	/* 07F8: A$-)" */
	0xF0,0x04,0x00,0x00,0x00,0x60,0xBF,0x72,	/* 0800: ....`r */
	0x34,0x20,0xD0,0x73,0xD3,0x70,0x30,0x30,	/* 0808: 4 sp00 */
	0x31,0xAE,0x40,0x23,0x2D,0x20,0x49,0x70,	/* 0810: 1@#- Ip */
	0x30,0x30,0x31,0x21,0xFA,0x72,0x99,0x04,	/* 0818: 001!r. */
	0x29,0x4C,0x72,0x94,0x72,0x96,0x61,0x05,	/* 0820: )Lrra. */
	0x24,0x27,0x2F,0x08,0x23,0x24,0x26,0x07,	/* 0828: $'..#$&. */
	0x20,0xB0,0x18,0x60,0xBF,0x72,0x23,0x56,	/* 0830:  .`r#V */
	0x20,0x20,0xD0,0x70,0x72,0xE4,0x20,0x70,	/* 0838:   pr p */
	0x60,0x5A,0x20,0x20,0x70,0xE0,0xB1,0x22,	/* 0840: `Z  p" */
	0xF0,0x05,0x00,0x00,0x00,0x72,0xD2,0x24,	/* 0848: ....r$ */
	0xF2,0x58,0x71,0x9A,0x71,0x9C,0x40,0x27,	/* 0850: Xqq@' */
	0x28,0x20,0x40,0xE0,0x60,0x01,0x24,0x25,	/* 0858: ( @`.$% */
	0x27,0x0D,0x23,0x24,0x2E,0x03,0x20,0x06,	/* 0860: '.#$.. . */
	0x00,0x00,0x00,0x60,0xBD,0x41,0x75,0x27,	/* 0868: ...`Au' */
	0x20,0x2C,0x4C,0xF2,0xE0,0x43,0x75,0x27,	/* 0870:  ,LCu' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 0878:  -@@u' */
	0x20,0x2E,0x48,0xF2,0xE0,0x42,0x75,0x27,	/* 0880:  .HBu' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 0888:  -@@u' */
	0x20,0x2E,0x48,0xF2,0xE0,0x41,0x75,0x27,	/* 0890:  .HAu' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 0898:  -@@u' */
	0x20,0x2E,0x48,0xF2,0xE0,0x40,0x75,0x27,	/* 08A0:  .H@u' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 08A8:  -@@u' */
	0x20,0x2E,0x48,0xF2,0xE0,0x43,0x75,0x27,	/* 08B0:  .HCu' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 08B8:  -@@u' */
	0x20,0x2F,0x44,0xF2,0xE0,0x42,0x75,0x27,	/* 08C0:  .DBu' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 08C8:  -@@u' */
	0x20,0x2F,0x44,0xF2,0xE0,0x41,0x75,0x27,	/* 08D0:  .DAu' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 08D8:  -@@u' */
	0x20,0x2F,0x44,0xF2,0xE0,0x40,0x75,0x27,	/* 08E0:  .D@u' */
	0x20,0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,	/* 08E8:  -@@u' */
	0x20,0x2F,0x44,0xF2,0xE0,0x44,0x75,0x27,	/* 08F0:  .DDu' */
	0x20,0x2D,0x40,0xF2,0xE0,0x2A,0x48,0x75,	/* 08F8:  -@*Hu */
	0x27,0x20,0x2D,0x4A,0xF2,0xE0,0x40,0x75,	/* 0900: ' -J@u */
	0x27,0x20,0x2D,0x4C,0xF2,0xE0,0x40,0x75,	/* 0908: ' -L@u */
	0x27,0x20,0x2D,0x4E,0xF2,0xE0,0x41,0x75,	/* 0910: ' -NAu */
	0x27,0x20,0x2D,0x48,0xF2,0xE0,0x43,0x75,	/* 0918: ' -HCu */
	0x27,0x20,0x2C,0x4C,0xF2,0xE0,0x43,0x75,	/* 0920: ' ,LCu */
	0x27,0x20,0x2C,0x4C,0xF2,0xE0,0x43,0x75,	/* 0928: ' ,LCu */
	0x27,0x20,0x2C,0x4C,0xF2,0xE0,0x44,0x75,	/* 0930: ' ,LDu */
	0x27,0x20,0x2D,0x40,0xF2,0xE0,0x2A,0x48,	/* 0938: ' -@*H */
	0x75,0x27,0x20,0x2D,0x4A,0xF2,0xE0,0x22,	/* 0940: u' -J" */
	0x40,0x75,0x27,0x20,0x2D,0x4C,0xF2,0xE0,	/* 0948: @u' -L */
	0x40,0x75,0x27,0x20,0x2D,0x4E,0xF2,0xE0,	/* 0950: @u' -N */
	0x43,0x75,0x27,0x20,0x2C,0x4C,0xF2,0xE0,	/* 0958: Cu' ,L */
	0x43,0x75,0x27,0x20,0x2C,0x4C,0xF2,0xE0,	/* 0960: Cu' ,L */
	0x43,0x75,0x27,0x20,0x2C,0x4C,0xF2,0xE0,	/* 0968: Cu' ,L */
	0x40,0x75,0x27,0x20,0x2D,0x48,0xF2,0xE0,	/* 0970: @u' -H */
	0x40,0xD2,0x21,0x40,0x72,0xF9,0xAD,0x43,	/* 0978: @!@rC */
	0x75,0x27,0x20,0x2C,0x4C,0xF2,0xE0,0x72,	/* 0980: u' ,Lr */
	0x81,0xD2,0x61,0x0E,0x44,0x75,0x27,0x20,	/* 0988: a.Du'  */
	0x2D,0x40,0xF2,0xE0,0x40,0x75,0x27,0x20,	/* 0990: -@@u'  */
	0x2D,0x4A,0xF2,0xE0,0x22,0x40,0x75,0x27,	/* 0998: -J"@u' */
	0x20,0x2D,0x4C,0xF2,0xE0,0x43,0x75,0x27,	/* 09A0:  -LCu' */
	0x20,0x2D,0x4E,0xF2,0xE0,0x41,0x75,0x27,	/* 09A8:  -NAu' */
	0x20,0x2D,0x48,0xF2,0xE0,0x43,0x75,0x27,	/* 09B0:  -HCu' */
	0x20,0x2C,0x4C,0xF2,0xE0,0x43,0x75,0x27,	/* 09B8:  ,LCu' */
	0x20,0x2C,0x4C,0xF2,0xE0,0x43,0x75,0x27,	/* 09C0:  ,LCu' */
	0x20,0x2C,0x4C,0xF2,0xE0,0x43,0x75,0x27,	/* 09C8:  ,LCu' */
	0x20,0x2C,0x4C,0xF2,0xE0,0x40,0x75,0x27,	/* 09D0:  ,L@u' */
	0x20,0x2D,0x48,0xF2,0xE0,0x40,0x75,0x27,	/* 09D8:  -H@u' */
	0x20,0x2C,0x4C,0xF2,0xE0,0x40,0x75,0x27,	/* 09E0:  ,L@u' */
	0x20,0x2D,0x40,0xF2,0xE0,0x26,0x44,0x74,	/* 09E8:  -@&Dt */
	0x21,0x25,0x2B,0x93,0xB3,0x22,0xF0,0x60,	/* 09F0: !%+"` */
	0xBD,0x75,0x31,0xD0,0x40,0xD1,0x75,0x87,	/* 09F8: u1@u */
	0xF1,0x75,0x32,0x27,0x2F,0x2F,0x4F,0x24,	/* 0A00: u2'..O$ */
	0xF6,0x89,0x23,0xFB,0x75,0x87,0xF1,0x70,	/* 0A08: #up */
	0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x75,0x87,	/* 0A10: ' .Nu */
	0xF1,0x43,0x24,0xF6,0x70,0x27,0x20,0x2D,	/* 0A18: C$p' - */
	0x40,0xF2,0xE0,0x70,0x27,0x20,0x2D,0x48,	/* 0A20: @p' -H */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x75,0x22,	/* 0A28: 0.O$u" */
	0x86,0xF1,0x24,0xF6,0xD2,0x72,0x28,0x40,	/* 0A30: $r(@ */
	0x24,0xF6,0xA5,0x71,0x44,0x24,0xFB,0xD1,	/* 0A38: $qD$ */
	0x72,0x22,0x40,0x24,0xF6,0xA6,0x71,0x24,	/* 0A40: r"@$q$ */
	0x40,0x24,0xFB,0xD1,0x72,0x21,0x40,0x24,	/* 0A48: @$r!@$ */
	0xF6,0xA6,0x71,0x22,0x40,0x24,0xFB,0xD1,	/* 0A50: q"@$ */
	0x72,0x24,0x40,0x24,0xF6,0xA5,0x71,0x42,	/* 0A58: r$@$qB */
	0x24,0xFB,0xD1,0x71,0x75,0x21,0x88,0x23,	/* 0A60: $qu!# */
	0xFB,0xB3,0x22,0xF0,0x60,0xBC,0x40,0xD2,	/* 0A68: "`@ */
	0x42,0x72,0xF9,0x2D,0xA6,0x72,0x23,0xF4,	/* 0A70: Br-r# */
	0x23,0xF4,0x76,0x27,0x20,0x2F,0x4E,0xF2,	/* 0A78: #v' .N */
	0xE0,0x76,0x75,0x62,0x2E,0x95,0x72,0xC0,	/* 0A80: vub.r */
	0x21,0xA8,0x76,0x27,0x20,0x2F,0x4E,0xF2,	/* 0A88: !v' .N */
	0x30,0x47,0x24,0xF6,0xD1,0x76,0x27,0x20,	/* 0A90: 0G$v'  */
	0x2F,0x4E,0xF2,0x30,0x48,0x24,0xF6,0xD3,	/* 0A98: .N0H$ */
	0x21,0x0A,0x76,0x27,0x20,0x2F,0x4E,0xF2,	/* 0AA0: !.v' .N */
	0x30,0x2F,0x4F,0x24,0xF6,0x44,0x24,0xF0,	/* 0AA8: 0.O$D$ */
	0xD1,0x76,0x27,0x20,0x2F,0x4E,0xF2,0x30,	/* 0AB0: v' .N0 */
	0x48,0x24,0xF6,0xD3,0x71,0xC5,0xAA,0x28,	/* 0AB8: H$q( */
	0x40,0x76,0x27,0x20,0x29,0x46,0xF2,0xE0,	/* 0AC0: @v' )F */
	0x08,0x40,0x76,0x27,0x20,0x29,0x46,0xF2,	/* 0AC8: .@v' )F */
	0xE0,0x22,0x47,0x76,0x27,0x20,0x2F,0x4C,	/* 0AD0: "Gv' .L */
	0xF2,0xE0,0x40,0xD0,0x44,0x70,0xF9,0x23,	/* 0AD8: @Dp# */
	0xAF,0x70,0x76,0x27,0x20,0x2D,0x40,0xF2,	/* 0AE0: pv' -@ */
	0xE0,0x70,0xC0,0x22,0xAE,0x71,0xC5,0x22,	/* 0AE8: p"q" */
	0xAA,0x40,0x76,0x27,0x20,0x2E,0x4C,0xF2,	/* 0AF0: @v' .L */
	0xE0,0x24,0x44,0x76,0x27,0x20,0x28,0x40,	/* 0AF8: $Dv' (@ */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF9,0xAA,	/* 0B00: 0.O$ */
	0x24,0x42,0x76,0x27,0x20,0x2E,0x44,0xF2,	/* 0B08: $Bv' .D */
	0xE0,0x09,0x21,0x4F,0x76,0x27,0x20,0x2E,	/* 0B10: .!Ov' . */
	0x44,0xF2,0xE0,0x70,0x81,0xD0,0x64,0x0C,	/* 0B18: Dpd. */
	0x40,0x76,0x27,0x20,0x23,0x40,0xF2,0xE0,	/* 0B20: @v' #@ */
	0x40,0x76,0x27,0x20,0x2D,0x48,0xF2,0xE0,	/* 0B28: @v' -H */
	0x40,0x76,0x27,0x20,0x2D,0x4A,0xF2,0xE0,	/* 0B30: @v' -J */
	0x76,0x27,0x20,0x20,0x4A,0xF2,0x30,0x2F,	/* 0B38: v'  J0. */
	0x4F,0x24,0xF6,0xC0,0x60,0xA2,0x72,0x81,	/* 0B40: O$`r */
	0xD2,0x6D,0x05,0xB4,0x22,0xF0,0x60,0xBA,	/* 0B48: m."` */
	0x77,0x36,0x20,0xD5,0x21,0x28,0x40,0xD3,	/* 0B50: w6 !(@ */
	0x41,0x27,0x28,0x28,0x40,0xE0,0x75,0x25,	/* 0B58: A'((@u% */
	0x33,0x30,0x87,0xF1,0x81,0x75,0x25,0x33,	/* 0B60: 30u%3 */
	0x30,0x87,0x23,0xFB,0x41,0x27,0x28,0x28,	/* 0B68: 0#A'(( */
	0x40,0xE0,0x73,0x21,0x37,0xD3,0x40,0x27,	/* 0B70: @s!7@' */
	0x28,0x28,0x40,0xE0,0x73,0x8E,0xF1,0x25,	/* 0B78: ((@s% */
	0xFA,0xD4,0x40,0xF4,0x21,0xA0,0x74,0x75,	/* 0B80: @!tu */
	0x22,0x5C,0xFA,0x30,0xD2,0x73,0x77,0x21,	/* 0B88: "\0sw! */
	0x24,0x21,0x98,0x21,0x29,0xA7,0x73,0x31,	/* 0B90: $!!)s1 */
	0xD2,0x73,0x34,0xD1,0x74,0xC0,0x25,0xA8,	/* 0B98: s4t% */
	0x71,0x41,0x24,0xF6,0xC0,0x25,0xA1,0x73,	/* 0BA0: qA$%s */
	0x8D,0xF1,0x73,0x8C,0xF1,0xF4,0x24,0xA8,	/* 0BA8: s$ */
	0x71,0x41,0x24,0xFB,0xD1,0x71,0x73,0xE4,	/* 0BB0: qA$qs */
	0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,	/* 0BB8: ss2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,	/* 0BC0: O$#s */
	0xF1,0x72,0x27,0x20,0x2F,0x4E,0xF2,0xE0,	/* 0BC8: r' .N */
	0x73,0x87,0xF1,0x43,0x24,0xF6,0x72,0x27,	/* 0BD0: sC$r' */
	0x20,0x2D,0x40,0xF2,0xE0,0x72,0x27,0x20,	/* 0BD8:  -@r'  */
	0x20,0x4C,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 0BE0:  L0.O$ */
	0x44,0x24,0xFB,0x72,0x27,0x20,0x20,0x4C,	/* 0BE8: D$r'  L */
	0xF2,0xE0,0x41,0x73,0x22,0x89,0x23,0xFB,	/* 0BF0: As"# */
	0x71,0x21,0x40,0x24,0xF6,0x2F,0xA9,0x71,	/* 0BF8: q!@$.q */
	0x28,0x40,0x24,0xF6,0x25,0xA4,0x73,0x87,	/* 0C00: (@$%s */
	0xF1,0x73,0x32,0x27,0x2F,0x2F,0x4F,0x24,	/* 0C08: s2'..O$ */
	0xF6,0x89,0x23,0xFB,0x73,0x87,0xF1,0x72,	/* 0C10: #sr */
	0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x73,0x87,	/* 0C18: ' .Ns */
	0xF1,0x43,0x24,0xF6,0x72,0x27,0x20,0x2D,	/* 0C20: C$r' - */
	0x40,0xF2,0xE0,0x72,0x27,0x20,0x20,0x4A,	/* 0C28: @r'  J */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xC0,0x2B,	/* 0C30: 0.O$+ */
	0xAC,0x40,0xD0,0x21,0x20,0x40,0x73,0x77,	/* 0C38: @! @sw */
	0x2F,0x23,0x94,0x22,0x42,0x72,0x27,0x20,	/* 0C40: .#"Br'  */
	0x20,0x4A,0xF2,0xE0,0x71,0x22,0x40,0x24,	/* 0C48:  Jq"@$ */
	0xFB,0xD1,0x71,0x6C,0x4F,0x24,0xF6,0xD1,	/* 0C50: qlO$ */
	0x29,0x0B,0x24,0x40,0x73,0x8A,0xF1,0x73,	/* 0C58: ).$@ss */
	0x8B,0xF1,0xF4,0x2F,0x4F,0x24,0xF6,0xF9,	/* 0C60: .O$ */
	0x28,0xAB,0x73,0x87,0xF1,0x73,0x32,0x27,	/* 0C68: (ss2' */
	0x2F,0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,	/* 0C70: ..O$# */
	0x73,0x87,0xF1,0x72,0x27,0x20,0x2F,0x4E,	/* 0C78: sr' .N */
	0xF2,0xE0,0x73,0x87,0xF1,0x43,0x24,0xF6,	/* 0C80: sC$ */
	0x72,0x27,0x20,0x2D,0x40,0xF2,0xE0,0x72,	/* 0C88: r' -@r */
	0x27,0x20,0x20,0x4A,0xF2,0x30,0x2F,0x4F,	/* 0C90: '  J0.O */
	0x24,0xF6,0xC0,0x25,0xA8,0x73,0x23,0x80,	/* 0C98: $%s# */
	0xF1,0x48,0x24,0xF6,0x21,0xAB,0x21,0x20,	/* 0CA0: H$!!  */
	0x40,0xD0,0x21,0x20,0x40,0x73,0x77,0x2E,	/* 0CA8: @! @sw. */
	0x2C,0x95,0x22,0x41,0x72,0x27,0x20,0x20,	/* 0CB0: ,"Ar'   */
	0x4A,0xF2,0xE0,0x71,0x66,0x4F,0x24,0xF6,	/* 0CB8: JqfO$ */
	0xD1,0x73,0x23,0x81,0xF1,0x28,0x40,0x24,	/* 0CC0: s#(@$ */
	0xF6,0xAE,0x21,0x20,0x20,0x40,0xD0,0x21,	/* 0CC8: !  @! */
	0x20,0x20,0x40,0x73,0x77,0x2E,0x29,0x9F,	/* 0CD0:   @sw.) */
	0x73,0x23,0x80,0xF1,0x24,0x40,0x24,0xF6,	/* 0CD8: s#$@$ */
	0xAE,0x22,0x20,0x20,0x40,0xD0,0x22,0x20,	/* 0CE0: "  @"  */
	0x20,0x40,0x73,0x77,0x2E,0x28,0x98,0x71,	/* 0CE8:  @sw.(q */
	0x61,0x4F,0x24,0xF6,0xD1,0x71,0x73,0xE4,	/* 0CF0: aO$qs */
	0x73,0x24,0x80,0xF1,0x21,0x40,0x24,0xF6,	/* 0CF8: s$!@$ */
	0x22,0xAB,0x73,0x87,0xF1,0x73,0x32,0x27,	/* 0D00: "ss2' */
	0x2F,0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,	/* 0D08: ..O$# */
	0x73,0x87,0xF1,0x72,0x27,0x20,0x2F,0x4E,	/* 0D10: sr' .N */
	0xF2,0xE0,0x73,0x87,0xF1,0x43,0x24,0xF6,	/* 0D18: sC$ */
	0x72,0x27,0x20,0x2D,0x40,0xF2,0xE0,0x73,	/* 0D20: r' -@s */
	0x77,0x21,0x22,0x28,0x90,0x61,0x22,0x0E,	/* 0D28: w!"(a". */
	0x60,0xB4,0x7D,0x36,0x20,0xDB,0x7E,0x31,	/* 0D30: `}6 ~1 */
	0xD8,0x7E,0x34,0xD9,0x7E,0x24,0x85,0xF1,	/* 0D38: ~4~$ */
	0xC0,0xA7,0x2F,0x4F,0x7E,0x24,0x85,0x23,	/* 0D40: .O~$# */
	0xFB,0x7E,0x87,0xF1,0x7E,0x32,0x27,0x2F,	/* 0D48: ~~2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x7E,	/* 0D50: .O$#~ */
	0x87,0xF1,0x78,0x27,0x20,0x2F,0x4E,0xF2,	/* 0D58: x' .N */
	0xE0,0x7E,0x87,0xF1,0x43,0x24,0xF6,0x78,	/* 0D60: ~C$x */
	0x27,0x20,0x2D,0x40,0xF2,0xE0,0x7E,0x21,	/* 0D68: ' -@~! */
	0x8F,0xF1,0x23,0xAF,0x7E,0x32,0x27,0x2F,	/* 0D70: #~2'. */
	0x2F,0x4F,0x24,0xF6,0xD7,0x7E,0x87,0xF1,	/* 0D78: .O$~ */
	0x43,0xF9,0x21,0xA5,0x77,0x21,0x8D,0xF1,	/* 0D80: C!w! */
	0x81,0x77,0x21,0x8D,0x23,0xFB,0x22,0x44,	/* 0D88: w!#"D */
	0x78,0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x21,	/* 0D90: x' .N! */
	0x02,0x77,0x21,0x8C,0xF1,0x81,0x77,0x21,	/* 0D98: .w!w! */
	0x8C,0x23,0xFB,0x48,0x78,0x27,0x20,0x2F,	/* 0DA0: #Hx' . */
	0x4E,0xF2,0xE0,0x40,0x7E,0x21,0x8F,0x23,	/* 0DA8: N@~!# */
	0xFB,0x28,0x0D,0x7E,0x24,0x85,0xF1,0x22,	/* 0DB0: (.~$" */
	0x43,0x24,0xF6,0x28,0xA3,0x7E,0x23,0x80,	/* 0DB8: C$(~# */
	0xF1,0x42,0x24,0xF6,0xAD,0x78,0x27,0x20,	/* 0DC0: B$x'  */
	0x21,0x46,0xF2,0x30,0x44,0x24,0xF6,0xC0,	/* 0DC8: !F0D$ */
	0x26,0xA7,0x7E,0x23,0x82,0xF1,0x21,0x40,	/* 0DD0: &~#!@ */
	0x24,0xF6,0xAD,0x78,0x27,0x20,0x2D,0x48,	/* 0DD8: $x' -H */
	0xF2,0x30,0x24,0x40,0x24,0xF6,0x25,0xA1,	/* 0DE0: 0$@$% */
	0x7E,0x23,0x80,0xF1,0x21,0x40,0x24,0xF6,	/* 0DE8: ~#!@$ */
	0xAD,0x78,0x27,0x20,0x2D,0x48,0xF2,0x30,	/* 0DF0: x' -H0 */
	0x21,0x40,0x24,0xF6,0x23,0xAB,0x79,0x22,	/* 0DF8: !@$#y" */
	0x20,0x40,0x24,0xF6,0xC0,0x23,0xA2,0x7E,	/* 0E00:  @$#~ */
	0x22,0x85,0xF1,0xC0,0x22,0xAB,0x79,0x21,	/* 0E08: ""y! */
	0x20,0x40,0x24,0xFB,0xD9,0x79,0x41,0x24,	/* 0E10:  @$yA$ */
	0xFB,0xD9,0x79,0x7E,0xE4,0x7E,0x22,0x87,	/* 0E18: y~~" */
	0xF1,0xAA,0x28,0x44,0x78,0x27,0x20,0x20,	/* 0E20: (Dx'   */
	0x4C,0xF2,0xE0,0x09,0x29,0x42,0x78,0x27,	/* 0E28: L.)Bx' */
	0x20,0x20,0x4C,0xF2,0xE0,0x41,0xBC,0x22,	/* 0E30:   LA" */
	0xF0,0x79,0x62,0x2F,0x4F,0x24,0xF6,0xD9,	/* 0E38: yb.O$ */
	0x78,0x27,0x20,0x20,0x4A,0xF2,0x30,0x2F,	/* 0E40: x'  J0. */
	0x4F,0x24,0xF6,0xA4,0x40,0xBC,0x22,0xF0,	/* 0E48: O$@" */
	0x7E,0x22,0x85,0xF1,0xC0,0x25,0x28,0xA4,	/* 0E50: ~"%( */
	0x41,0x7E,0x22,0x85,0x23,0xFB,0x7E,0x22,	/* 0E58: A~"#~" */
	0x87,0xF1,0x23,0xA4,0x78,0x27,0x20,0x28,	/* 0E60: #x' ( */
	0x40,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x24,	/* 0E68: @0.O$$ */
	0xC2,0x21,0xA2,0x40,0x78,0x27,0x20,0x2E,	/* 0E70: !@x' . */
	0x4C,0xF2,0xE0,0x24,0x42,0x78,0x27,0x20,	/* 0E78: L$Bx'  */
	0x2E,0x44,0xF2,0xE0,0x09,0x21,0x4F,0x78,	/* 0E80: .D.!Ox */
	0x27,0x20,0x2E,0x44,0xF2,0xE0,0x22,0x40,	/* 0E88: ' .D"@ */
	0x7E,0x22,0x8A,0x23,0xFB,0x22,0x2A,0x09,	/* 0E90: ~"#"*. */
	0x78,0x27,0x20,0x28,0x40,0xF2,0x30,0x2F,	/* 0E98: x' (@0. */
	0x4F,0x24,0xF6,0x24,0xC2,0xAA,0x21,0x21,	/* 0EA0: O$$!! */
	0x20,0x45,0x21,0xFB,0xD6,0x4E,0xD7,0x0C,	/* 0EA8:  E!N. */
	0x21,0x20,0x2F,0x4B,0x21,0xFB,0x21,0x5C,	/* 0EB0: ! .K!!\ */
	0xD6,0x21,0x4E,0xD7,0x7E,0x24,0x85,0xF1,	/* 0EB8: !N~$ */
	0x41,0x24,0xF6,0x21,0x22,0xA1,0x7E,0x21,	/* 0EC0: A$!"~! */
	0x86,0xF1,0x4F,0x24,0xF6,0xD1,0x7E,0x86,	/* 0EC8: O$~ */
	0xF1,0x24,0xC8,0xA8,0x71,0xCF,0xA5,0x7E,	/* 0ED0: $q~ */
	0x23,0x83,0xF1,0xD1,0x7E,0x86,0xF1,0x24,	/* 0ED8: #~$ */
	0xC8,0xA8,0x41,0x71,0x21,0x4D,0x24,0xFF,	/* 0EE0: Aq!M$ */
	0xF0,0xAF,0x7E,0x86,0xF1,0x24,0x48,0xF4,	/* 0EE8: ~$H */
	0xAD,0x41,0x71,0x4D,0x24,0xFF,0xF0,0xC0,	/* 0EF0: AqM$ */
	0xA5,0x7E,0x23,0x86,0xF1,0xD1,0x41,0x21,	/* 0EF8: ~#A! */
	0x42,0x71,0x24,0xFF,0xF0,0x21,0xA4,0x71,	/* 0F00: Bq$!q */
	0x21,0xC2,0xC0,0x22,0xA6,0x71,0x21,0xC3,	/* 0F08: !"q! */
	0xC0,0x22,0xA0,0x71,0x21,0xC4,0xC0,0x21,	/* 0F10: "q!! */
	0xAA,0x21,0x0F,0x41,0x44,0x71,0x24,0xFF,	/* 0F18: !.ADq$ */
	0xF0,0xAA,0x71,0xC4,0xC0,0xAD,0x71,0x21,	/* 0F20: qq! */
	0xC1,0xC0,0xA8,0x0E,0x71,0xA5,0x71,0xC3,	/* 0F28: .qq */
	0xC0,0xA1,0x07,0x4C,0x7E,0x22,0x8A,0x23,	/* 0F30: .L~"# */
	0xFB,0x07,0x22,0x40,0x7E,0x22,0x8A,0x23,	/* 0F38: ."@~"# */
	0xFB,0x71,0x76,0x28,0xF1,0x30,0x78,0x27,	/* 0F40: qv(0x' */
	0x20,0x2E,0x44,0xF2,0xE0,0x71,0x76,0x28,	/* 0F48:  .Dqv( */
	0xF1,0x31,0x78,0x27,0x20,0x2E,0x4C,0xF2,	/* 0F50: 1x' .L */
	0xE0,0x7E,0x22,0x8D,0xF1,0x2F,0x40,0x24,	/* 0F58: ~".@$ */
	0xF6,0x7E,0x21,0x86,0xF1,0x4F,0x24,0xF6,	/* 0F60: ~!O$ */
	0x24,0xFB,0x7E,0x22,0x8D,0x23,0xFB,0x7E,	/* 0F68: $~"#~ */
	0x23,0x83,0xF1,0x7E,0x23,0x86,0x23,0xFB,	/* 0F70: #~## */
	0x7E,0x21,0x86,0xF1,0x44,0x24,0xF0,0xD1,	/* 0F78: ~!D$ */
	0x7E,0x86,0xF1,0x24,0xC8,0xA8,0x71,0xCF,	/* 0F80: ~$q */
	0xA5,0x7E,0x23,0x84,0xF1,0xD1,0x7E,0x86,	/* 0F88: ~#~ */
	0xF1,0x24,0xC8,0xA8,0x41,0x71,0x21,0x4D,	/* 0F90: $Aq!M */
	0x24,0xFF,0xF0,0xAF,0x7E,0x86,0xF1,0x24,	/* 0F98: $~$ */
	0x48,0xF4,0xAD,0x41,0x71,0x4D,0x24,0xFF,	/* 0FA0: HAqM$ */
	0xF0,0xC0,0xA5,0x7E,0x23,0x87,0xF1,0xD1,	/* 0FA8: ~# */
	0x71,0x76,0x28,0xF1,0x30,0x78,0x27,0x20,	/* 0FB0: qv(0x'  */
	0x2F,0x40,0xF2,0xE0,0x71,0x76,0x28,0xF1,	/* 0FB8: .@qv( */
	0x31,0x78,0x27,0x20,0x2F,0x48,0xF2,0xE0,	/* 0FC0: 1x' .H */
	0x7E,0x22,0x8D,0xF1,0x4F,0x24,0xF6,0x7E,	/* 0FC8: ~"O$~ */
	0x21,0x86,0xF1,0x2F,0x40,0x24,0xF6,0x24,	/* 0FD0: !.@$$ */
	0xFB,0x7E,0x22,0x8D,0x23,0xFB,0x7E,0x23,	/* 0FD8: ~"#~# */
	0x84,0xF1,0x7E,0x23,0x87,0x23,0xFB,0x7E,	/* 0FE0: ~##~ */
	0x24,0x85,0xF1,0x42,0x24,0xF6,0x21,0x25,	/* 0FE8: $B$!% */
	0xA0,0x40,0x7E,0x21,0xEC,0x40,0x7E,0x21,	/* 0FF0: @~!@~! */
	0xED,0x40,0x7E,0x21,0xEE,0x40,0x7E,0x21,	/* 0FF8: @~!@~! */
	0xEF,0x7E,0x86,0xF1,0x24,0xC8,0xA8,0x22,	/* 1000: ~$" */
	0x40,0x7E,0x24,0x82,0x23,0xFB,0x06,0x4C,	/* 1008: @~$#.L */
	0x7E,0x24,0x82,0x23,0xFB,0x40,0x7E,0x24,	/* 1010: ~$#@~$ */
	0x83,0x23,0xFB,0x40,0x7E,0x24,0x84,0x23,	/* 1018: #@~$# */
	0xFB,0x7E,0x21,0x8D,0xF1,0x78,0x27,0x20,	/* 1020: ~!x'  */
	0x23,0x44,0xF2,0xE0,0x7E,0x21,0x8E,0xF1,	/* 1028: #D~! */
	0x78,0x27,0x20,0x23,0x46,0xF2,0xE0,0x7E,	/* 1030: x' #F~ */
	0x21,0x8B,0xF1,0x78,0x27,0x20,0x23,0x48,	/* 1038: !x' #H */
	0xF2,0xE0,0x7E,0x21,0x8C,0xF1,0x78,0x27,	/* 1040: ~!x' */
	0x20,0x23,0x4A,0xF2,0xE0,0x40,0x7E,0x21,	/* 1048:  #J@~! */
	0x89,0x23,0xFB,0x7E,0x21,0x84,0xF1,0x25,	/* 1050: #~!% */
	0xFA,0xD1,0x7E,0x23,0x81,0x23,0xFB,0x71,	/* 1058: ~##q */
	0x43,0x24,0xF6,0xD2,0x71,0x21,0x40,0x24,	/* 1060: C$q!@$ */
	0xF6,0xC0,0x21,0xAD,0x71,0x48,0x24,0xF6,	/* 1068: !qH$ */
	0xA7,0x72,0x22,0x40,0x24,0xFB,0xD2,0x06,	/* 1070: r"@$. */
	0x72,0x24,0x40,0x24,0xFB,0xD2,0x71,0x44,	/* 1078: r$@$qD */
	0x24,0xF6,0xA6,0x72,0x28,0x40,0x24,0xFB,	/* 1080: $r(@$ */
	0xD2,0x7E,0x21,0x8A,0xF1,0x28,0x40,0x24,	/* 1088: ~!(@$ */
	0xF6,0xA6,0x72,0x40,0x24,0xFB,0xD2,0x06,	/* 1090: r@$. */
	0x72,0x21,0x40,0x24,0xFB,0xD2,0x7E,0x21,	/* 1098: r!@$~! */
	0x85,0xF1,0x25,0xFA,0xD1,0x7E,0x23,0x82,	/* 10A0: %~# */
	0x23,0xFB,0x71,0x4F,0x24,0xF6,0xCF,0xA6,	/* 10A8: #qO$ */
	0x72,0x48,0x24,0xFB,0xD2,0x05,0x72,0x40,	/* 10B0: rH$.r@ */
	0x24,0xFB,0xD2,0x72,0x78,0x27,0x20,0x21,	/* 10B8: $rx' ! */
	0x40,0xF2,0xE0,0x40,0xD2,0x71,0x28,0x40,	/* 10C0: @@q(@ */
	0x24,0xF6,0xA6,0x72,0x21,0x40,0x24,0xFB,	/* 10C8: $r!@$ */
	0xD2,0x72,0x78,0x27,0x20,0x21,0x42,0xF2,	/* 10D0: rx' !B */
	0xE0,0x7E,0x86,0xF1,0x24,0xC8,0xAA,0x28,	/* 10D8: ~$( */
	0x44,0x78,0x27,0x20,0x21,0x44,0xF2,0xE0,	/* 10E0: Dx' !D */
	0x08,0x48,0x78,0x27,0x20,0x21,0x44,0xF2,	/* 10E8: .Hx' !D */
	0xE0,0x7E,0x22,0x80,0xF1,0x25,0xFA,0xD1,	/* 10F0: ~"% */
	0x7E,0x22,0x81,0x23,0xFB,0x7E,0x21,0x8A,	/* 10F8: ~"#~! */
	0xF1,0x7E,0x23,0x80,0x23,0xFB,0x71,0x28,	/* 1100: ~##q( */
	0x40,0x24,0xF6,0xA4,0x40,0xD2,0x21,0x02,	/* 1108: @$@!. */
	0x71,0x48,0x24,0xF6,0xA3,0x42,0xD2,0x0A,	/* 1110: qH$B. */
	0x71,0x44,0x24,0xF6,0xA3,0x44,0xD2,0x02,	/* 1118: qD$D. */
	0x43,0xD2,0x71,0x41,0x24,0xF6,0xA7,0x72,	/* 1120: CqA$r */
	0x21,0x48,0x24,0xFB,0xD2,0x0B,0x71,0x42,	/* 1128: !H$.qB */
	0x24,0xF6,0xC0,0xA5,0x72,0x48,0x24,0xFB,	/* 1130: $rH$ */
	0xD2,0x72,0x78,0x27,0x20,0x23,0x4C,0xF2,	/* 1138: rx' #L */
	0xE0,0x7E,0x24,0x85,0xF1,0x42,0x24,0xF6,	/* 1140: ~$B$ */
	0x25,0xA8,0x40,0xD2,0x7E,0x21,0x8A,0xF1,	/* 1148: %@~! */
	0x44,0x24,0xF6,0x22,0xAA,0x7E,0x22,0x87,	/* 1150: D$"~" */
	0xF1,0x21,0xA7,0x78,0x27,0x20,0x28,0x40,	/* 1158: !x' (@ */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x24,0xC2,	/* 1160: 0.O$$ */
	0xA9,0x79,0x24,0x20,0x40,0x24,0xFB,0xD9,	/* 1168: y$ @$ */
	0x21,0x04,0x79,0x64,0x2F,0x4F,0x24,0xF6,	/* 1170: !.yd.O$ */
	0xD9,0x72,0x42,0x24,0xFB,0xD2,0x07,0x79,	/* 1178: rB$.y */
	0x64,0x2F,0x4F,0x24,0xF6,0xD9,0x7E,0x22,	/* 1180: d.O$~" */
	0x82,0xF1,0x2F,0x4F,0xF4,0xAC,0x7E,0x22,	/* 1188: .O~" */
	0x87,0xF1,0xC0,0xA6,0x72,0x28,0x40,0x24,	/* 1190: r(@$ */
	0xFB,0xD2,0x72,0x78,0x27,0x20,0x23,0x4E,	/* 1198: rx' #N */
	0xF2,0xE0,0x7E,0x22,0x87,0xF1,0xC0,0x21,	/* 11A0: ~"! */
	0x2A,0xA0,0x40,0x25,0xFA,0xD4,0x25,0xFA,	/* 11A8: *@%% */
	0xD5,0xD3,0x7E,0x21,0x8A,0xF1,0x48,0x24,	/* 11B0: ~!H$ */
	0xF6,0xA7,0x73,0x21,0x20,0x40,0x24,0xFB,	/* 11B8: s! @$ */
	0xD3,0x7E,0x21,0x84,0xF1,0x28,0x40,0x24,	/* 11C0: ~!(@$ */
	0xF6,0xAA,0x73,0x21,0x20,0x20,0x40,0x24,	/* 11C8: s!  @$ */
	0xFB,0xD3,0x21,0x08,0x75,0x21,0x20,0x20,	/* 11D0: !.u!   */
	0x40,0x24,0xFB,0xD5,0x7E,0x21,0x87,0xF1,	/* 11D8: @$~! */
	0x41,0x24,0xF6,0xA8,0x74,0x21,0x20,0x20,	/* 11E0: A$t!   */
	0x40,0x24,0xFB,0xD4,0x7E,0x21,0x8A,0xF1,	/* 11E8: @$~! */
	0x24,0x40,0x24,0xF6,0xAA,0x73,0x22,0x20,	/* 11F0: $@$s"  */
	0x20,0x40,0x24,0xFB,0xD3,0x21,0x08,0x75,	/* 11F8:  @$!.u */
	0x22,0x20,0x20,0x40,0x24,0xFB,0xD5,0x7E,	/* 1200: "  @$~ */
	0x21,0x87,0xF1,0x42,0x24,0xF6,0xA8,0x74,	/* 1208: !B$t */
	0x22,0x20,0x20,0x40,0x24,0xFB,0xD4,0x7E,	/* 1210: "  @$~ */
	0x21,0x8A,0xF1,0x42,0x24,0xF6,0x21,0xA3,	/* 1218: !B$! */
	0x7E,0x21,0x8A,0xF1,0x41,0x24,0xF6,0xA6,	/* 1220: ~!A$ */
	0x73,0x42,0x24,0xFB,0xD3,0x05,0x73,0x41,	/* 1228: sB$.sA */
	0x24,0xFB,0xD3,0x7E,0x21,0x85,0xF1,0x21,	/* 1230: $~!! */
	0x40,0x24,0xF6,0xA6,0x73,0x21,0x40,0x24,	/* 1238: @$s!@$ */
	0xFB,0xD3,0x7E,0x21,0x8A,0xF1,0x21,0x40,	/* 1240: ~!!@ */
	0x24,0xF6,0xA6,0x73,0x22,0x40,0x24,0xFB,	/* 1248: $s"@$ */
	0xD3,0x7E,0x24,0x85,0xF1,0x22,0x40,0x24,	/* 1250: ~$"@$ */
	0xF6,0xAB,0x73,0xD0,0x23,0x21,0x23,0x43,	/* 1258: s#!#C */
	0x7E,0x7D,0x29,0x21,0x92,0x7E,0x24,0x85,	/* 1260: ~})!~$ */
	0xF1,0x21,0x40,0x24,0xF6,0xA8,0x74,0xD0,	/* 1268: !@$t */
	0x75,0x7E,0x7D,0x2C,0x27,0x96,0x7E,0x21,	/* 1270: u~},'~! */
	0x8A,0xF1,0x22,0x40,0x24,0xF6,0x23,0xA0,	/* 1278: "@$# */
	0x7E,0x7D,0x68,0x27,0x92,0x7E,0x22,0x86,	/* 1280: ~}h'~" */
	0xF1,0x2F,0x40,0x24,0xF6,0xD1,0x71,0x78,	/* 1288: .@$qx */
	0x27,0x20,0x22,0x4C,0xF2,0xE0,0x78,0x27,	/* 1290: ' "Lx' */
	0x20,0x22,0x4A,0xF2,0x30,0x4F,0x24,0xF6,	/* 1298:  "J0O$ */
	0x71,0x60,0x40,0x24,0xF6,0x24,0xFB,0x78,	/* 12A0: q`@$$x */
	0x27,0x20,0x22,0x4A,0xF2,0xE0,0x22,0x00,	/* 12A8: ' "J". */
	0x22,0x44,0x7E,0x21,0x88,0x23,0xFB,0x40,	/* 12B0: "D~!#@ */
	0x78,0x27,0x20,0x22,0x4C,0xF2,0xE0,0x78,	/* 12B8: x' "Lx */
	0x27,0x20,0x22,0x4A,0xF2,0x30,0x4F,0x24,	/* 12C0: ' "J0O$ */
	0xF6,0x78,0x27,0x20,0x22,0x4A,0xF2,0xE0,	/* 12C8: x' "J */
	0x79,0x62,0x2F,0x2F,0x4F,0x24,0xF6,0xD9,	/* 12D0: yb..O$ */
	0x7E,0x21,0x8A,0xF1,0x22,0x40,0x24,0xF6,	/* 12D8: ~!"@$ */
	0xA8,0x79,0x22,0x20,0x20,0x40,0x24,0xFB,	/* 12E0: y"  @$ */
	0xD9,0x7E,0x24,0x85,0xF1,0x22,0x40,0x24,	/* 12E8: ~$"@$ */
	0xF6,0x27,0xAB,0x79,0x60,0x44,0x24,0xF6,	/* 12F0: 'y`D$ */
	0xD9,0x7E,0x21,0x8A,0xF1,0x42,0x24,0xF6,	/* 12F8: ~!B$ */
	0xA5,0x79,0x42,0x24,0xFB,0xD9,0x7E,0x21,	/* 1300: yB$~! */
	0x8A,0xF1,0x48,0x24,0xF6,0xA5,0x79,0x48,	/* 1308: H$yH */
	0x24,0xFB,0xD9,0x7E,0x21,0x8A,0xF1,0x41,	/* 1310: $~!A */
	0x24,0xF6,0xA5,0x79,0x41,0x24,0xFB,0xD9,	/* 1318: $yA$ */
	0x7E,0x21,0x84,0xF1,0x28,0x40,0x24,0xF6,	/* 1320: ~!(@$ */
	0xA5,0x79,0x48,0x24,0xFB,0xD9,0x7E,0x21,	/* 1328: yH$~! */
	0x8A,0xF1,0x24,0x40,0x24,0xF6,0xA5,0x79,	/* 1330: $@$y */
	0x48,0x24,0xFB,0xD9,0x79,0x48,0x24,0xF6,	/* 1338: H$yH$ */
	0x22,0xAC,0x79,0x6F,0x4F,0x24,0xF6,0xD9,	/* 1340: "yoO$ */
	0x22,0x04,0x7E,0x22,0x87,0xF1,0x21,0xAE,	/* 1348: ".~"! */
	0x78,0x27,0x20,0x28,0x40,0xF2,0x30,0x2F,	/* 1350: x' (@0. */
	0x4F,0x24,0xF6,0x24,0x42,0xF4,0xAF,0x7E,	/* 1358: O$$B~ */
	0x21,0x8A,0xF1,0x44,0x24,0xF6,0xA7,0x79,	/* 1360: !D$y */
	0x24,0x20,0x40,0x24,0xFB,0xD9,0x7E,0x24,	/* 1368: $ @$~$ */
	0x85,0xF1,0x41,0x24,0xF6,0x25,0xA5,0x78,	/* 1370: A$%x */
	0x27,0x20,0x28,0x40,0xF2,0x30,0x2F,0x4F,	/* 1378: ' (@0.O */
	0x24,0xF6,0x24,0xC2,0xA6,0x7B,0x50,0xDA,	/* 1380: $${P */
	0x4E,0xD7,0x06,0x7B,0x5E,0xDA,0x21,0x4E,	/* 1388: N.{^!N */
	0xD7,0x7E,0x21,0x86,0xF1,0x44,0x24,0xF0,	/* 1390: ~!D$ */
	0xD1,0x7E,0x86,0xF1,0x24,0xC8,0xA9,0x41,	/* 1398: ~$A */
	0x71,0x21,0x4D,0x24,0xFF,0xF0,0x21,0xA0,	/* 13A0: q!M$! */
	0x7E,0x86,0xF1,0x24,0x48,0xF4,0x21,0xA1,	/* 13A8: ~$H! */
	0x41,0x71,0x4D,0x24,0xFF,0xF0,0xC0,0xA9,	/* 13B0: AqM$ */
	0x48,0x78,0x27,0x20,0x24,0x42,0xF2,0xE0,	/* 13B8: Hx' $B */
	0x0B,0x71,0x7A,0xFA,0x30,0x78,0x27,0x20,	/* 13C0: .qz0x'  */
	0x24,0x42,0xF2,0xE0,0x24,0x4E,0x78,0x27,	/* 13C8: $B$Nx' */
	0x20,0x20,0x4A,0xF2,0xE0,0x79,0x7E,0xE4,	/* 13D0:   Jy~ */
	0x40,0xBC,0x22,0xF0,0x7E,0x22,0x87,0xF1,	/* 13D8: @"~" */
	0x21,0xAA,0x40,0x78,0x27,0x20,0x22,0x4A,	/* 13E0: !@x' "J */
	0xF2,0xE0,0x40,0x78,0x27,0x20,0x22,0x4C,	/* 13E8: @x' "L */
	0xF2,0xE0,0x21,0x48,0x78,0x27,0x20,0x20,	/* 13F0: !Hx'   */
	0x4A,0xF2,0xE0,0x09,0x21,0x4A,0x78,0x27,	/* 13F8: J.!Jx' */
	0x20,0x20,0x4A,0xF2,0xE0,0x79,0x60,0x4E,	/* 1400:   Jy`N */
	0x24,0xF6,0xD9,0x79,0x7E,0xE4,0x29,0x40,	/* 1408: $y~)@ */
	0x78,0x27,0x20,0x20,0x4C,0xF2,0xE0,0x40,	/* 1410: x'  L@ */
	0x7E,0x22,0x85,0x23,0xFB,0x7E,0x8E,0xF1,	/* 1418: ~"#~ */
	0xC4,0xA5,0x7E,0x7D,0x21,0x98,0x05,0x40,	/* 1420: ~}!.@ */
	0x7E,0x8E,0x23,0xFB,0x41,0x7B,0x25,0x34,	/* 1428: ~#A{%4 */
	0xE0,0x40,0x7E,0x24,0x85,0x23,0xFB,0x40,	/* 1430: @~$#@ */
	0xBC,0x22,0xF0,0xBC,0x22,0xF0,0x60,0xBF,	/* 1438: ""` */
	0x73,0x31,0xD0,0x73,0x87,0xF1,0x73,0x32,	/* 1440: s1ss2 */
	0x27,0x2F,0x2F,0x4F,0x24,0xF6,0x89,0x23,	/* 1448: '..O$# */
	0xFB,0x73,0x87,0xF1,0x70,0x27,0x20,0x2F,	/* 1450: sp' . */
	0x4E,0xF2,0xE0,0x73,0x87,0xF1,0x43,0x24,	/* 1458: NsC$ */
	0xF6,0x70,0x27,0x20,0x2D,0x40,0xF2,0xE0,	/* 1460: p' -@ */
	0x70,0x27,0x20,0x2D,0x48,0xF2,0x30,0x28,	/* 1468: p' -H0( */
	0x40,0x24,0xF6,0xAC,0x40,0x73,0x8E,0x23,	/* 1470: @$@s# */
	0xFB,0x41,0x72,0x36,0x20,0x25,0x34,0xE0,	/* 1478: Ar6 %4 */
	0x40,0xB1,0x22,0xF0,0x60,0xBF,0x73,0x31,	/* 1480: @"`s1 */
	0xD0,0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,	/* 1488: ss2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,	/* 1490: .O$#s */
	0x87,0xF1,0x70,0x27,0x20,0x2F,0x4E,0xF2,	/* 1498: p' .N */
	0xE0,0x73,0x87,0xF1,0x43,0x24,0xF6,0x70,	/* 14A0: sC$p */
	0x27,0x20,0x2D,0x40,0xF2,0xE0,0x73,0x72,	/* 14A8: ' -@sr */
	0x22,0x2C,0x95,0xA4,0x40,0xB1,0x22,0xF0,	/* 14B0: ",@" */
	0x73,0x8D,0xF1,0x73,0x8C,0xF1,0xF4,0xA4,	/* 14B8: ss */
	0x41,0xB1,0x22,0xF0,0x73,0x21,0x8F,0xF1,	/* 14C0: A"s! */
	0xC0,0x25,0xA5,0x73,0x22,0x89,0xF1,0xC0,	/* 14C8: %s" */
	0xA9,0x73,0x34,0x22,0x20,0x40,0x24,0xFB,	/* 14D0: s4" @$ */
	0x73,0xE4,0x73,0x34,0x22,0x20,0x40,0x24,	/* 14D8: ss4" @$ */
	0xF6,0xA8,0x73,0x72,0x2E,0x91,0x40,0xB1,	/* 14E0: sr.@ */
	0x22,0xF0,0x73,0x34,0x21,0x20,0x40,0x24,	/* 14E8: "s4! @$ */
	0xFB,0x73,0xE4,0x73,0x22,0x87,0xF1,0xC0,	/* 14F0: ss" */
	0x21,0xA2,0x73,0x34,0x41,0x24,0xFB,0x73,	/* 14F8: !s4A$s */
	0xE4,0x29,0x42,0x70,0x27,0x20,0x20,0x4C,	/* 1500: )Bp'  L */
	0xF2,0xE0,0x21,0x00,0x73,0x34,0x41,0x24,	/* 1508: !.s4A$ */
	0xFB,0x73,0xE4,0x28,0x44,0x70,0x27,0x20,	/* 1510: s(Dp'  */
	0x20,0x4C,0xF2,0xE0,0x40,0xB1,0x22,0xF0,	/* 1518:  L@" */
	0x73,0x72,0x2A,0x93,0x40,0xB1,0x22,0xF0,	/* 1520: sr*@" */
	0x40,0xB1,0x22,0xF0,0x60,0xBE,0x74,0x31,	/* 1528: @"`t1 */
	0xD1,0x74,0x87,0xF1,0x74,0x32,0x27,0x2F,	/* 1530: tt2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x74,	/* 1538: .O$#t */
	0x87,0xF1,0x71,0x27,0x20,0x2F,0x4E,0xF2,	/* 1540: q' .N */
	0xE0,0x74,0x87,0xF1,0x43,0x24,0xF6,0x71,	/* 1548: tC$q */
	0x27,0x20,0x2D,0x40,0xF2,0xE0,0x74,0x23,	/* 1550: ' -@t# */
	0x85,0xF1,0xD0,0x43,0x70,0xF9,0xC0,0xAF,	/* 1558: Cp */
	0x70,0xC3,0xC0,0x21,0xA8,0x70,0xC4,0xC0,	/* 1560: p!p */
	0x22,0xA2,0x70,0xC5,0xC0,0x21,0x0D,0x70,	/* 1568: "p!.p */
	0x21,0xAA,0x70,0xC1,0xC0,0x21,0xAB,0x70,	/* 1570: !p!p */
	0xC2,0xC0,0x21,0xA6,0x0F,0x74,0x8E,0xF1,	/* 1578: !.t */
	0xCC,0xA6,0x21,0x42,0x74,0x8E,0x23,0xFB,	/* 1580: !Bt# */
	0x40,0xB2,0x22,0xF0,0x41,0x74,0x23,0x85,	/* 1588: @"At# */
	0x23,0xFB,0x74,0x34,0x41,0x24,0xFB,0x74,	/* 1590: #t4A$t */
	0xE4,0x71,0x27,0x20,0x20,0x4C,0xF2,0x30,	/* 1598: q'  L0 */
	0x2F,0x4F,0x24,0xF6,0x42,0x24,0xFB,0x71,	/* 15A0: .O$B$q */
	0x27,0x20,0x20,0x4C,0xF2,0xE0,0x40,0xB2,	/* 15A8: '  L@ */
	0x22,0xF0,0x72,0x71,0x21,0x2C,0x91,0xC0,	/* 15B0: "rq!, */
	0xA5,0x40,0x72,0x8E,0x23,0xFB,0x40,0x22,	/* 15B8: @r#@" */
	0xF0,0x40,0x22,0xF0,0x41,0x22,0xF0,0x60,	/* 15C0: @"A"` */
	0xBE,0x74,0x31,0xD1,0x74,0x87,0xF1,0x74,	/* 15C8: t1tt */
	0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,0x89,	/* 15D0: 2'..O$ */
	0x23,0xFB,0x74,0x87,0xF1,0x71,0x27,0x20,	/* 15D8: #tq'  */
	0x2F,0x4E,0xF2,0xE0,0x74,0x87,0xF1,0x43,	/* 15E0: .NtC */
	0x24,0xF6,0x71,0x27,0x20,0x2D,0x40,0xF2,	/* 15E8: $q' -@ */
	0xE0,0x74,0x73,0x21,0x28,0x92,0xA4,0x40,	/* 15F0: ts!(@ */
	0xB2,0x22,0xF0,0x71,0x27,0x20,0x20,0x4A,	/* 15F8: "q'  J */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xA4,0x40,	/* 1600: 0.O$@ */
	0xB2,0x22,0xF0,0x74,0x21,0x8F,0xF1,0xC0,	/* 1608: "t! */
	0x2D,0xAB,0x74,0x32,0x27,0x2F,0x2F,0x4F,	/* 1610: -t2'..O */
	0x24,0xF6,0xD0,0x74,0x34,0x22,0x20,0x40,	/* 1618: $t4" @ */
	0x24,0xF6,0x24,0xA5,0x74,0x87,0xF1,0x43,	/* 1620: $$tC */
	0xF9,0x21,0xAF,0x70,0x21,0x8D,0xF1,0x60,	/* 1628: !p!` */
	0x8F,0x2F,0x4F,0x24,0xF6,0x25,0xFA,0x70,	/* 1630: .O$%p */
	0x21,0x8D,0x23,0xFB,0xC0,0x2A,0xAE,0x24,	/* 1638: !#*$ */
	0x44,0x71,0x27,0x20,0x2F,0x4E,0xF2,0xE0,	/* 1640: Dq' .N */
	0x2A,0x03,0x70,0x21,0x8C,0xF1,0x60,0x8F,	/* 1648: *.p!` */
	0x2F,0x4F,0x24,0xF6,0x25,0xFA,0x70,0x21,	/* 1650: .O$%p! */
	0x8C,0x23,0xFB,0xC0,0x28,0xAF,0x21,0x40,	/* 1658: #(!@ */
	0x71,0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x28,	/* 1660: q' .N( */
	0x04,0x74,0x22,0x89,0xF1,0xC0,0xAB,0x74,	/* 1668: .t"t */
	0x34,0x22,0x20,0x40,0x24,0xFB,0x74,0xE4,	/* 1670: 4" @$t */
	0x26,0x0F,0x74,0x34,0x21,0x20,0x40,0x24,	/* 1678: &.t4! @$ */
	0xF6,0x22,0xA1,0x74,0x24,0x80,0xF1,0x41,	/* 1680: "t$A */
	0x24,0xF6,0x25,0xAD,0x21,0x48,0x71,0x27,	/* 1688: $%!Hq' */
	0x20,0x20,0x4A,0xF2,0xE0,0x74,0x24,0x80,	/* 1690:   Jt$ */
	0xF1,0x60,0x4E,0x24,0xF6,0x74,0x24,0x80,	/* 1698: `N$t$ */
	0x23,0xFB,0x24,0x05,0x74,0x34,0x21,0x20,	/* 16A0: #$.t4!  */
	0x40,0x24,0xFB,0x74,0xE4,0x40,0x74,0x8D,	/* 16A8: @$t@t */
	0x23,0xFB,0x40,0x74,0x8C,0x23,0xFB,0x74,	/* 16B0: #@t#t */
	0x22,0x87,0xF1,0xC0,0x21,0xA2,0x74,0x34,	/* 16B8: "!t4 */
	0x41,0x24,0xFB,0x74,0xE4,0x29,0x42,0x71,	/* 16C0: A$t)Bq */
	0x27,0x20,0x20,0x4C,0xF2,0xE0,0x21,0x00,	/* 16C8: '  L!. */
	0x74,0x34,0x41,0x24,0xFB,0x74,0xE4,0x28,	/* 16D0: t4A$t( */
	0x44,0x71,0x27,0x20,0x20,0x4C,0xF2,0xE0,	/* 16D8: Dq'  L */
	0x28,0x42,0x71,0x27,0x20,0x20,0x4A,0xF2,	/* 16E0: (Bq'  J */
	0xE0,0x40,0xB2,0x22,0xF0,0x40,0x74,0x8D,	/* 16E8: @"@t */
	0x23,0xFB,0x40,0x74,0x8A,0x23,0xFB,0x40,	/* 16F0: #@t#@ */
	0x74,0x8C,0x23,0xFB,0x40,0x74,0x8B,0x23,	/* 16F8: t#@t# */
	0xFB,0x40,0x74,0x22,0x89,0x23,0xFB,0x74,	/* 1700: @t"#t */
	0x34,0x62,0x2F,0x4F,0x24,0xF6,0x74,0xE4,	/* 1708: 4b.O$t */
	0x74,0x22,0x87,0xF1,0xAB,0x21,0x44,0x71,	/* 1710: t"!Dq */
	0x27,0x20,0x20,0x4A,0xF2,0xE0,0x23,0x01,	/* 1718: '  J#. */
	0x74,0x21,0x87,0xF1,0x41,0x24,0xF6,0xC0,	/* 1720: t!A$ */
	0xAB,0x40,0xD0,0x21,0x20,0x20,0x40,0x74,	/* 1728: @!  @t */
	0x73,0x27,0x2B,0x98,0x74,0x21,0x87,0xF1,	/* 1730: s'+t! */
	0x42,0x24,0xF6,0xC0,0xAB,0x40,0xD0,0x22,	/* 1738: B$@" */
	0x20,0x20,0x40,0x74,0x73,0x27,0x2A,0x94,	/* 1740:   @ts'* */
	0x28,0x40,0x71,0x27,0x20,0x20,0x4A,0xF2,	/* 1748: (@q'  J */
	0xE0,0x74,0x34,0x60,0x4E,0x24,0xF6,0x74,	/* 1750: t4`N$t */
	0xE4,0x40,0x71,0x27,0x20,0x20,0x4C,0xF2,	/* 1758: @q'  L */
	0xE0,0x41,0x74,0x21,0x8F,0x23,0xFB,0x21,	/* 1760: At!#! */
	0x40,0x74,0x8E,0x23,0xFB,0x41,0x73,0x36,	/* 1768: @t#As6 */
	0x20,0x25,0x34,0xE0,0x40,0xB2,0x22,0xF0,	/* 1770:  %4@" */
	0x60,0xBE,0x74,0x31,0xD1,0x74,0x87,0xF1,	/* 1778: `t1t */
	0x74,0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,	/* 1780: t2'..O$ */
	0x89,0x23,0xFB,0x74,0x87,0xF1,0x71,0x27,	/* 1788: #tq' */
	0x20,0x2F,0x4E,0xF2,0xE0,0x74,0x87,0xF1,	/* 1790:  .Nt */
	0x43,0x24,0xF6,0x71,0x27,0x20,0x2D,0x40,	/* 1798: C$q' -@ */
	0xF2,0xE0,0x74,0x23,0x85,0xF1,0xD0,0x43,	/* 17A0: t#C */
	0x70,0xF9,0xC0,0x21,0xA0,0x70,0xC3,0xC0,	/* 17A8: p!p */
	0x21,0xA9,0x70,0xC4,0xC0,0x23,0xA7,0x70,	/* 17B0: !p#p */
	0xC5,0xC0,0x23,0xA2,0x0E,0x70,0xA8,0x70,	/* 17B8: #.pp */
	0xC1,0xC0,0xA8,0x70,0xC2,0xC0,0x04,0x40,	/* 17C0: p.@ */
	0xB2,0x22,0xF0,0x74,0x86,0xF1,0x24,0xC8,	/* 17C8: "t$ */
	0x21,0xA6,0x71,0x27,0x20,0x20,0x4A,0xF2,	/* 17D0: !q'  J */
	0x30,0x2F,0x4F,0x24,0xF6,0xA1,0x0F,0x28,	/* 17D8: 0.O$.( */
	0x42,0x71,0x27,0x20,0x20,0x4A,0xF2,0xE0,	/* 17E0: Bq'  J */
	0x44,0x74,0x23,0x85,0x23,0xFB,0x74,0x34,	/* 17E8: Dt##t4 */
	0x41,0x24,0xFB,0x74,0xE4,0x71,0x27,0x20,	/* 17F0: A$tq'  */
	0x20,0x4C,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 17F8:  L0.O$ */
	0x42,0x24,0xFB,0x71,0x27,0x20,0x20,0x4C,	/* 1800: B$q'  L */
	0xF2,0xE0,0x41,0xB2,0x22,0xF0,0x60,0xBF,	/* 1808: A"` */
	0x73,0x31,0xD0,0x73,0x87,0xF1,0x73,0x32,	/* 1810: s1ss2 */
	0x27,0x2F,0x2F,0x4F,0x24,0xF6,0x89,0x23,	/* 1818: '..O$# */
	0xFB,0x73,0x87,0xF1,0x70,0x27,0x20,0x2F,	/* 1820: sp' . */
	0x4E,0xF2,0xE0,0x73,0x87,0xF1,0x43,0x24,	/* 1828: NsC$ */
	0xF6,0x70,0x27,0x20,0x2D,0x40,0xF2,0xE0,	/* 1830: p' -@ */
	0x73,0x22,0x87,0xF1,0xC0,0x21,0xA2,0x70,	/* 1838: s"!p */
	0x27,0x20,0x21,0x46,0xF2,0x30,0x2F,0x4B,	/* 1840: ' !F0.K */
	0x24,0xF6,0x70,0x27,0x20,0x21,0x46,0xF2,	/* 1848: $p' !F */
	0xE0,0x40,0x73,0x8E,0x23,0xFB,0x41,0x72,	/* 1850: @s#Ar */
	0x36,0x20,0x25,0x34,0xE0,0x40,0xB1,0x22,	/* 1858: 6 %4@" */
	0xF0,0x60,0xBF,0x73,0x31,0xD0,0x73,0x87,	/* 1860: `s1s */
	0xF1,0x73,0x32,0x27,0x2F,0x2F,0x4F,0x24,	/* 1868: s2'..O$ */
	0xF6,0x89,0x23,0xFB,0x73,0x87,0xF1,0x70,	/* 1870: #sp */
	0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x73,0x87,	/* 1878: ' .Ns */
	0xF1,0x43,0x24,0xF6,0x70,0x27,0x20,0x2D,	/* 1880: C$p' - */
	0x40,0xF2,0xE0,0x70,0x27,0x20,0x20,0x4A,	/* 1888: @p'  J */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xA4,0x40,	/* 1890: 0.O$@ */
	0xB1,0x22,0xF0,0x73,0x8D,0xF1,0x73,0x8C,	/* 1898: "ss */
	0x23,0xFB,0x28,0x42,0x70,0x27,0x20,0x20,	/* 18A0: #(Bp'   */
	0x4A,0xF2,0xE0,0x73,0x72,0x6A,0x9F,0x40,	/* 18A8: Jsrj@ */
	0xB1,0x22,0xF0,0x72,0x8B,0xF1,0x72,0x8A,	/* 18B0: "rr */
	0x23,0xFB,0x41,0x71,0x36,0x20,0x25,0x34,	/* 18B8: #Aq6 %4 */
	0xE0,0x40,0x72,0x8E,0x23,0xFB,0x40,0x22,	/* 18C0: @r#@" */
	0xF0,0x60,0xBF,0x73,0x31,0xD0,0x73,0x87,	/* 18C8: `s1s */
	0xF1,0x73,0x32,0x27,0x2F,0x2F,0x4F,0x24,	/* 18D0: s2'..O$ */
	0xF6,0x89,0x23,0xFB,0x73,0x87,0xF1,0x70,	/* 18D8: #sp */
	0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x73,0x87,	/* 18E0: ' .Ns */
	0xF1,0x43,0x24,0xF6,0x70,0x27,0x20,0x2D,	/* 18E8: C$p' - */
	0x40,0xF2,0xE0,0x73,0x22,0x87,0xF1,0xC0,	/* 18F0: @s" */
	0x21,0xA5,0x70,0x27,0x20,0x21,0x46,0xF2,	/* 18F8: !p' !F */
	0x30,0x2F,0x4F,0x24,0xF6,0x44,0x24,0xFB,	/* 1900: 0.O$D$ */
	0x70,0x27,0x20,0x21,0x46,0xF2,0xE0,0x41,	/* 1908: p' !FA */
	0x72,0x36,0x20,0x25,0x34,0xE0,0x40,0x73,	/* 1910: r6 %4@s */
	0x8E,0x23,0xFB,0x40,0xB1,0x22,0xF0,0x60,	/* 1918: #@"` */
	0xBE,0x74,0x31,0xD0,0x74,0x87,0xF1,0x74,	/* 1920: t1tt */
	0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,0x89,	/* 1928: 2'..O$ */
	0x23,0xFB,0x74,0x87,0xF1,0x70,0x27,0x20,	/* 1930: #tp'  */
	0x2F,0x4E,0xF2,0xE0,0x74,0x87,0xF1,0x43,	/* 1938: .NtC */
	0x24,0xF6,0x70,0x27,0x20,0x2D,0x40,0xF2,	/* 1940: $p' -@ */
	0xE0,0x40,0xD1,0x75,0x70,0x27,0x20,0x2D,	/* 1948: @up' - */
	0x4E,0xF2,0xE0,0x4F,0x73,0x26,0x24,0x9F,	/* 1950: NOs&$ */
	0x70,0x27,0x20,0x2D,0x4E,0xF2,0x30,0x2F,	/* 1958: p' -N0. */
	0x4F,0x24,0xF6,0x76,0x24,0xF6,0xC0,0xA4,	/* 1960: O$v$ */
	0x77,0xB2,0x22,0xF0,0x40,0x70,0x27,0x20,	/* 1968: w"@p'  */
	0x2D,0x4E,0xF2,0xE0,0x4F,0x73,0x26,0x22,	/* 1970: -NOs&" */
	0x9E,0x70,0x27,0x20,0x2D,0x4E,0xF2,0x30,	/* 1978: p' -N0 */
	0x2F,0x4F,0x24,0xF6,0x76,0x24,0xF6,0xA5,	/* 1980: .O$v$ */
	0x77,0x81,0xB2,0x22,0xF0,0x40,0xB2,0x22,	/* 1988: w"@" */
	0xF0,0x60,0xBA,0x78,0x31,0xD2,0x40,0xD4,	/* 1990: `x1@ */
	0x78,0x87,0xF1,0x78,0x32,0x27,0x2F,0x2F,	/* 1998: xx2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x78,0x87,	/* 19A0: O$#x */
	0xF1,0x72,0x27,0x20,0x2F,0x4E,0xF2,0xE0,	/* 19A8: r' .N */
	0x78,0x87,0xF1,0x43,0x24,0xF6,0x72,0x27,	/* 19B0: xC$r' */
	0x20,0x2D,0x40,0xF2,0xE0,0x78,0x22,0x87,	/* 19B8:  -@x" */
	0xF1,0xC0,0xA2,0x4E,0xD4,0x74,0xC0,0xAB,	/* 19C0: Nt */
	0x22,0x40,0xD0,0x49,0xD1,0x41,0x78,0x77,	/* 19C8: "@IAxw */
	0x6B,0x9D,0xD4,0x74,0xC0,0xAB,0x21,0x40,	/* 19D0: kt!@ */
	0xD0,0x4B,0xD1,0x44,0x78,0x77,0x6C,0x9F,	/* 19D8: KDxwl */
	0xD4,0x72,0x27,0x20,0x2D,0x4E,0xF2,0x30,	/* 19E0: r' -N0 */
	0x28,0x40,0x24,0xF6,0x25,0xFA,0xD5,0xC0,	/* 19E8: (@$% */
	0xA8,0x4E,0xD4,0x75,0x78,0x21,0x88,0x23,	/* 19F0: Nux!# */
	0xFB,0x74,0xC0,0x23,0xAF,0x48,0xD3,0x73,	/* 19F8: t#Hs */
	0x23,0xAA,0x42,0x72,0x27,0x20,0x2D,0x4E,	/* 1A00: #Br' -N */
	0xF2,0xE0,0x4F,0x77,0x25,0x29,0x98,0x40,	/* 1A08: Ow%)@ */
	0x72,0x27,0x20,0x2D,0x4E,0xF2,0xE0,0x4F,	/* 1A10: r' -NO */
	0x77,0x25,0x28,0x9B,0x72,0x27,0x20,0x2D,	/* 1A18: w%(r' - */
	0x4E,0xF2,0x30,0x28,0x40,0x24,0xF6,0x25,	/* 1A20: N0(@$% */
	0xFA,0xD5,0xAB,0x74,0xC0,0xA2,0x73,0xD4,	/* 1A28: ts */
	0x75,0x78,0x21,0x88,0x23,0xFB,0x73,0x60,	/* 1A30: ux!#s` */
	0x8F,0xD3,0x63,0x03,0x74,0xC0,0x24,0xA2,	/* 1A38: c.t$ */
	0x42,0x72,0x27,0x20,0x2D,0x4E,0xF2,0xE0,	/* 1A40: Br' -N */
	0x4F,0x77,0x25,0x25,0x9A,0x40,0x72,0x27,	/* 1A48: Ow%%@r' */
	0x20,0x2D,0x4E,0xF2,0xE0,0x22,0x27,0x21,	/* 1A50:  -N"'! */
	0x40,0xD3,0x73,0x21,0xAA,0x72,0x27,0x20,	/* 1A58: @s!r'  */
	0x2D,0x4E,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 1A60: -N0.O$ */
	0x25,0xFA,0xD5,0x24,0x40,0x24,0xF6,0xA1,	/* 1A68: %$@$ */
	0x06,0x73,0x60,0x8F,0xD3,0x61,0x03,0x73,	/* 1A70: .s`a.s */
	0xC0,0xA8,0x75,0x78,0x21,0x88,0x23,0xFB,	/* 1A78: ux!# */
	0x4D,0xD4,0x4F,0x77,0x25,0x22,0x90,0x42,	/* 1A80: MOw%"B */
	0x72,0x27,0x20,0x2D,0x4E,0xF2,0xE0,0x4F,	/* 1A88: r' -NO */
	0x77,0x25,0x21,0x93,0x40,0x72,0x27,0x20,	/* 1A90: w%!@r'  */
	0x2D,0x4E,0xF2,0xE0,0x28,0x42,0x72,0x27,	/* 1A98: -N(Br' */
	0x20,0x20,0x4A,0xF2,0xE0,0x74,0x78,0x22,	/* 1AA0:   Jtx" */
	0x88,0x23,0xFB,0x74,0xA8,0x45,0x72,0x27,	/* 1AA8: #tEr' */
	0x20,0x2D,0x4E,0xF2,0xE0,0x40,0x78,0x8E,	/* 1AB0:  -N@x */
	0x23,0xFB,0x40,0xB6,0x22,0xF0,0x21,0x40,	/* 1AB8: #@"!@ */
	0x72,0x71,0x9F,0x22,0xF0,0x42,0x72,0x71,	/* 1AC0: rq"Brq */
	0x99,0x22,0xF0,0x28,0x40,0x72,0x71,0x92,	/* 1AC8: "(@rq */
	0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,0x73,	/* 1AD0: "`s1s */
	0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,0x4F,	/* 1AD8: s2'..O */
	0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,0xF1,	/* 1AE0: $#s */
	0x70,0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x73,	/* 1AE8: p' .Ns */
	0x87,0xF1,0x43,0x24,0xF6,0x70,0x27,0x20,	/* 1AF0: C$p'  */
	0x2D,0x40,0xF2,0xE0,0x74,0x46,0x24,0xF6,	/* 1AF8: -@tF$ */
	0xA7,0x73,0x34,0x41,0x24,0xFB,0x73,0xE4,	/* 1B00: s4A$s */
	0x70,0x27,0x20,0x20,0x4C,0xF2,0x30,0x2F,	/* 1B08: p'  L0. */
	0x4F,0x24,0xF6,0x74,0x24,0xFB,0x70,0x27,	/* 1B10: O$t$p' */
	0x20,0x20,0x4C,0xF2,0xE0,0x41,0x72,0x36,	/* 1B18:   LAr6 */
	0x20,0x25,0x34,0xE0,0x40,0x73,0x8E,0x23,	/* 1B20:  %4@s# */
	0xFB,0x40,0xB1,0x22,0xF0,0x60,0xBF,0x73,	/* 1B28: @"`s */
	0x31,0xD0,0x73,0x87,0xF1,0x73,0x32,0x27,	/* 1B30: 1ss2' */
	0x2F,0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,	/* 1B38: ..O$# */
	0x73,0x87,0xF1,0x70,0x27,0x20,0x2F,0x4E,	/* 1B40: sp' .N */
	0xF2,0xE0,0x73,0x87,0xF1,0x43,0x24,0xF6,	/* 1B48: sC$ */
	0x70,0x27,0x20,0x2D,0x40,0xF2,0xE0,0x73,	/* 1B50: p' -@s */
	0x34,0x60,0x4E,0x24,0xF6,0x73,0xE4,0x40,	/* 1B58: 4`N$s@ */
	0x70,0x27,0x20,0x20,0x4C,0xF2,0xE0,0x41,	/* 1B60: p'  LA */
	0x72,0x36,0x20,0x25,0x34,0xE0,0x40,0x73,	/* 1B68: r6 %4@s */
	0x8E,0x23,0xFB,0x40,0xB1,0x22,0xF0,0x60,	/* 1B70: #@"` */
	0xBF,0x73,0x31,0xD0,0x73,0x87,0xF1,0x73,	/* 1B78: s1ss */
	0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,0x89,	/* 1B80: 2'..O$ */
	0x23,0xFB,0x73,0x87,0xF1,0x70,0x27,0x20,	/* 1B88: #sp'  */
	0x2F,0x4E,0xF2,0xE0,0x73,0x87,0xF1,0x43,	/* 1B90: .NsC */
	0x24,0xF6,0x70,0x27,0x20,0x2D,0x40,0xF2,	/* 1B98: $p' -@ */
	0xE0,0x74,0x41,0x24,0xF6,0x25,0xA8,0x75,	/* 1BA0: tA$%u */
	0x41,0x24,0xF6,0x22,0xAE,0x70,0x27,0x20,	/* 1BA8: A$"p'  */
	0x21,0x42,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 1BB0: !B0.O$ */
	0x24,0x40,0x24,0xFB,0x70,0x27,0x20,0x21,	/* 1BB8: $@$p' ! */
	0x42,0xF2,0xE0,0x70,0x27,0x20,0x21,0x44,	/* 1BC0: Bp' !D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x23,0x40,	/* 1BC8: 0.O$#@ */
	0x24,0xFB,0x70,0x27,0x20,0x21,0x44,0xF2,	/* 1BD0: $p' !D */
	0xE0,0x22,0x04,0x70,0x27,0x20,0x21,0x42,	/* 1BD8: ".p' !B */
	0xF2,0x30,0x2B,0x4F,0x24,0xF6,0x70,0x27,	/* 1BE0: 0+O$p' */
	0x20,0x21,0x42,0xF2,0xE0,0x70,0x27,0x20,	/* 1BE8:  !Bp'  */
	0x21,0x44,0xF2,0x30,0x2C,0x4F,0x24,0xF6,	/* 1BF0: !D0,O$ */
	0x70,0x27,0x20,0x21,0x44,0xF2,0xE0,0x74,	/* 1BF8: p' !Dt */
	0x42,0x24,0xF6,0x23,0xA0,0x75,0x42,0x24,	/* 1C00: B$#uB$ */
	0xF6,0x21,0xA8,0x70,0x27,0x20,0x21,0x42,	/* 1C08: !p' !B */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x28,0x40,	/* 1C10: 0.O$(@ */
	0x24,0xFB,0x70,0x27,0x20,0x21,0x42,0xF2,	/* 1C18: $p' !B */
	0xE0,0x21,0x02,0x70,0x27,0x20,0x21,0x42,	/* 1C20: !.p' !B */
	0xF2,0x30,0x27,0x4F,0x24,0xF6,0x70,0x27,	/* 1C28: 0'O$p' */
	0x20,0x21,0x42,0xF2,0xE0,0x74,0x21,0x40,	/* 1C30:  !Bt!@ */
	0x24,0xF6,0x23,0xA0,0x75,0x21,0x40,0x24,	/* 1C38: $#u!@$ */
	0xF6,0x21,0xA7,0x70,0x27,0x20,0x21,0x42,	/* 1C40: !p' !B */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x42,0x24,	/* 1C48: 0.O$B$ */
	0xFB,0x70,0x27,0x20,0x21,0x42,0xF2,0xE0,	/* 1C50: p' !B */
	0x21,0x02,0x70,0x27,0x20,0x21,0x42,0xF2,	/* 1C58: !.p' !B */
	0x30,0x2F,0x4D,0x24,0xF6,0x70,0x27,0x20,	/* 1C60: 0.M$p'  */
	0x21,0x42,0xF2,0xE0,0x74,0x22,0x40,0x24,	/* 1C68: !Bt"@$ */
	0xF6,0xAD,0x73,0x24,0x80,0xF1,0x21,0x40,	/* 1C70: s$!@ */
	0x24,0xFB,0x73,0x24,0x80,0x23,0xFB,0x73,	/* 1C78: $s$#s */
	0x86,0xF1,0x24,0xC8,0x21,0x28,0xA3,0x70,	/* 1C80: $!(p */
	0x27,0x20,0x22,0x4A,0xF2,0x30,0x2F,0x40,	/* 1C88: ' "J0.@ */
	0x24,0xF6,0x4F,0x24,0xFB,0x70,0x27,0x20,	/* 1C90: $O$p'  */
	0x22,0x4A,0xF2,0xE0,0x74,0x21,0x20,0x40,	/* 1C98: "Jt! @ */
	0x24,0xF6,0x23,0xA1,0x75,0x21,0x20,0x40,	/* 1CA0: $#u! @ */
	0x24,0xF6,0x21,0xA7,0x70,0x27,0x20,0x23,	/* 1CA8: $!p' # */
	0x4E,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x48,	/* 1CB0: N0.O$H */
	0x24,0xFB,0x70,0x27,0x20,0x23,0x4E,0xF2,	/* 1CB8: $p' #N */
	0xE0,0x21,0x02,0x70,0x27,0x20,0x23,0x4E,	/* 1CC0: !.p' #N */
	0xF2,0x30,0x2F,0x47,0x24,0xF6,0x70,0x27,	/* 1CC8: 0.G$p' */
	0x20,0x23,0x4E,0xF2,0xE0,0x74,0x21,0x20,	/* 1CD0:  #Nt!  */
	0x20,0x40,0x24,0xF6,0x28,0xAF,0x73,0x22,	/* 1CD8:  @$(s" */
	0x84,0xF1,0x48,0x24,0xF6,0x24,0xA4,0x75,	/* 1CE0: H$$u */
	0x21,0x20,0x20,0x40,0x24,0xF6,0x21,0xAC,	/* 1CE8: !  @$! */
	0x70,0x27,0x20,0x23,0x4E,0xF2,0x30,0x2F,	/* 1CF0: p' #N0. */
	0x4B,0x24,0xF6,0x70,0x27,0x20,0x23,0x4E,	/* 1CF8: K$p' #N */
	0xF2,0xE0,0x42,0x70,0x27,0x20,0x2D,0x4A,	/* 1D00: Bp' -J */
	0xF2,0xE0,0x26,0x01,0x70,0x27,0x20,0x23,	/* 1D08: &.p' # */
	0x4E,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x44,	/* 1D10: N0.O$D */
	0x24,0xFB,0x70,0x27,0x20,0x23,0x4E,0xF2,	/* 1D18: $p' #N */
	0xE0,0x40,0x70,0x27,0x20,0x2D,0x4A,0xF2,	/* 1D20: @p' -J */
	0xE0,0x24,0x02,0x75,0x21,0x20,0x20,0x40,	/* 1D28: $.u!  @ */
	0x24,0xF6,0x21,0xAF,0x70,0x27,0x20,0x21,	/* 1D30: $!p' ! */
	0x42,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x44,	/* 1D38: B0.O$D */
	0x24,0xFB,0x70,0x27,0x20,0x21,0x42,0xF2,	/* 1D40: $p' !B */
	0xE0,0x41,0x70,0x27,0x20,0x2D,0x48,0xF2,	/* 1D48: Ap' -H */
	0xE0,0x21,0x0A,0x70,0x27,0x20,0x21,0x42,	/* 1D50: !.p' !B */
	0xF2,0x30,0x2F,0x4B,0x24,0xF6,0x70,0x27,	/* 1D58: 0.K$p' */
	0x20,0x21,0x42,0xF2,0xE0,0x40,0x70,0x27,	/* 1D60:  !B@p' */
	0x20,0x2D,0x48,0xF2,0xE0,0x74,0x22,0x20,	/* 1D68:  -Ht"  */
	0x20,0x40,0x24,0xF6,0x21,0x27,0xA2,0x73,	/* 1D70:  @$!'s */
	0x22,0x84,0xF1,0x48,0x24,0xF6,0x24,0xA6,	/* 1D78: "H$$ */
	0x75,0x22,0x20,0x20,0x40,0x24,0xF6,0x22,	/* 1D80: u"  @$" */
	0xA0,0x70,0x27,0x20,0x21,0x42,0xF2,0x30,	/* 1D88: p' !B0 */
	0x2F,0x4F,0x24,0xF6,0x44,0x24,0xFB,0x70,	/* 1D90: .O$D$p */
	0x27,0x20,0x21,0x42,0xF2,0xE0,0x41,0x70,	/* 1D98: ' !BAp */
	0x27,0x20,0x2D,0x48,0xF2,0xE0,0x21,0x24,	/* 1DA0: ' -H!$ */
	0x00,0x70,0x27,0x20,0x21,0x42,0xF2,0x30,	/* 1DA8: .p' !B0 */
	0x2F,0x4B,0x24,0xF6,0x70,0x27,0x20,0x21,	/* 1DB0: .K$p' ! */
	0x42,0xF2,0xE0,0x40,0x70,0x27,0x20,0x2D,	/* 1DB8: B@p' - */
	0x48,0xF2,0xE0,0x21,0x22,0x03,0x75,0x22,	/* 1DC0: H!".u" */
	0x20,0x20,0x40,0x24,0xF6,0x21,0xAC,0x70,	/* 1DC8:   @$!p */
	0x27,0x20,0x23,0x4E,0xF2,0x30,0x2F,0x4B,	/* 1DD0: ' #N0.K */
	0x24,0xF6,0x70,0x27,0x20,0x23,0x4E,0xF2,	/* 1DD8: $p' #N */
	0xE0,0x42,0x70,0x27,0x20,0x2D,0x4A,0xF2,	/* 1DE0: Bp' -J */
	0xE0,0x2F,0x0E,0x70,0x27,0x20,0x23,0x4E,	/* 1DE8: ..p' #N */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x44,0x24,	/* 1DF0: 0.O$D$ */
	0xFB,0x70,0x27,0x20,0x23,0x4E,0xF2,0xE0,	/* 1DF8: p' #N */
	0x40,0x70,0x27,0x20,0x2D,0x4A,0xF2,0xE0,	/* 1E00: @p' -J */
	0x2D,0x0F,0x74,0x21,0x20,0x20,0x40,0x24,	/* 1E08: -.t!  @$ */
	0xF6,0x26,0xA6,0x73,0x22,0x84,0xF1,0x48,	/* 1E10: &s"H */
	0x24,0xF6,0x24,0xA4,0x75,0x21,0x20,0x20,	/* 1E18: $$u!   */
	0x40,0x24,0xF6,0x21,0xAF,0x70,0x27,0x20,	/* 1E20: @$!p'  */
	0x22,0x4A,0xF2,0x30,0x2F,0x40,0x24,0xF6,	/* 1E28: "J0.@$ */
	0x49,0x24,0xFB,0x70,0x27,0x20,0x22,0x4A,	/* 1E30: I$p' "J */
	0xF2,0xE0,0x42,0x70,0x27,0x20,0x2D,0x4A,	/* 1E38: Bp' -J */
	0xF2,0xE0,0x23,0x05,0x70,0x27,0x20,0x22,	/* 1E40: #.p' " */
	0x4A,0xF2,0x30,0x2F,0x40,0x24,0xF6,0x70,	/* 1E48: J0.@$p */
	0x27,0x20,0x22,0x4A,0xF2,0xE0,0x40,0x70,	/* 1E50: ' "J@p */
	0x27,0x20,0x2D,0x4A,0xF2,0xE0,0x21,0x09,	/* 1E58: ' -J!. */
	0x75,0x21,0x20,0x20,0x40,0x24,0xF6,0xA9,	/* 1E60: u!  @$ */
	0x41,0x70,0x27,0x20,0x2D,0x48,0xF2,0xE0,	/* 1E68: Ap' -H */
	0x08,0x40,0x70,0x27,0x20,0x2D,0x48,0xF2,	/* 1E70: .@p' -H */
	0xE0,0x74,0x22,0x20,0x20,0x40,0x24,0xF6,	/* 1E78: t"  @$ */
	0x26,0xA7,0x73,0x22,0x84,0xF1,0x48,0x24,	/* 1E80: &s"H$ */
	0xF6,0x21,0xAC,0x75,0x22,0x20,0x20,0x40,	/* 1E88: !u"  @ */
	0x24,0xF6,0xAA,0x41,0x70,0x27,0x20,0x2D,	/* 1E90: $Ap' - */
	0x48,0xF2,0xE0,0x24,0x0C,0x40,0x70,0x27,	/* 1E98: H$.@p' */
	0x20,0x2D,0x48,0xF2,0xE0,0x24,0x02,0x75,	/* 1EA0:  -H$.u */
	0x22,0x20,0x20,0x40,0x24,0xF6,0x21,0xAF,	/* 1EA8: "  @$! */
	0x70,0x27,0x20,0x22,0x4A,0xF2,0x30,0x2F,	/* 1EB0: p' "J0. */
	0x40,0x24,0xF6,0x49,0x24,0xFB,0x70,0x27,	/* 1EB8: @$I$p' */
	0x20,0x22,0x4A,0xF2,0xE0,0x42,0x70,0x27,	/* 1EC0:  "JBp' */
	0x20,0x2D,0x4A,0xF2,0xE0,0x21,0x0A,0x70,	/* 1EC8:  -J!.p */
	0x27,0x20,0x22,0x4A,0xF2,0x30,0x2F,0x40,	/* 1ED0: ' "J0.@ */
	0x24,0xF6,0x70,0x27,0x20,0x22,0x4A,0xF2,	/* 1ED8: $p' "J */
	0xE0,0x40,0x70,0x27,0x20,0x2D,0x4A,0xF2,	/* 1EE0: @p' -J */
	0xE0,0xB1,0x22,0xF0,0x60,0xBF,0x73,0x31,	/* 1EE8: "`s1 */
	0xD0,0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,	/* 1EF0: ss2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,	/* 1EF8: .O$#s */
	0x87,0xF1,0x70,0x27,0x20,0x2F,0x4E,0xF2,	/* 1F00: p' .N */
	0xE0,0x73,0x87,0xF1,0x43,0x24,0xF6,0x70,	/* 1F08: sC$p */
	0x27,0x20,0x2D,0x40,0xF2,0xE0,0x74,0x21,	/* 1F10: ' -@t! */
	0x20,0x20,0x40,0x24,0xF6,0x23,0xAE,0x73,	/* 1F18:   @$#s */
	0x22,0x84,0xF1,0x48,0x24,0xF6,0x21,0xAC,	/* 1F20: "H$! */
	0x75,0x21,0x20,0x20,0x40,0x24,0xF6,0xAA,	/* 1F28: u!  @$ */
	0x42,0x70,0x27,0x20,0x2D,0x4A,0xF2,0xE0,	/* 1F30: Bp' -J */
	0x22,0x03,0x40,0x70,0x27,0x20,0x2D,0x4A,	/* 1F38: ".@p' -J */
	0xF2,0xE0,0x21,0x09,0x75,0x21,0x20,0x20,	/* 1F40: !.u!   */
	0x40,0x24,0xF6,0xA9,0x41,0x70,0x27,0x20,	/* 1F48: @$Ap'  */
	0x2D,0x48,0xF2,0xE0,0x08,0x40,0x70,0x27,	/* 1F50: -H.@p' */
	0x20,0x2D,0x48,0xF2,0xE0,0x74,0x22,0x20,	/* 1F58:  -Ht"  */
	0x20,0x40,0x24,0xF6,0x23,0xAE,0x73,0x22,	/* 1F60:  @$#s" */
	0x84,0xF1,0x48,0x24,0xF6,0x21,0xAC,0x75,	/* 1F68: H$!u */
	0x22,0x20,0x20,0x40,0x24,0xF6,0xAA,0x41,	/* 1F70: "  @$A */
	0x70,0x27,0x20,0x2D,0x48,0xF2,0xE0,0x22,	/* 1F78: p' -H" */
	0x03,0x40,0x70,0x27,0x20,0x2D,0x48,0xF2,	/* 1F80: .@p' -H */
	0xE0,0x21,0x09,0x75,0x22,0x20,0x20,0x40,	/* 1F88: !.u"  @ */
	0x24,0xF6,0xA9,0x42,0x70,0x27,0x20,0x2D,	/* 1F90: $Bp' - */
	0x4A,0xF2,0xE0,0x08,0x40,0x70,0x27,0x20,	/* 1F98: J.@p'  */
	0x2D,0x4A,0xF2,0xE0,0xB1,0x22,0xF0,0x23,	/* 1FA0: -J"# */
	0x20,0x27,0x09,0x76,0xF6,0x22,0x2C,0x24,	/* 1FA8:  '.v",$ */
	0x08,0x82,0x00,0x04,0x00,0x16,0x00,0x00,	/* 1FB0: ....... */
	0x00,0x41,0x00,0x00,0x00,0x41,0x00,0x04,	/* 1FB8: .A...A.. */
	0x00,0x82,0x00,0x03,0x00,0x41,0x00,0x03,	/* 1FC0: ....A.. */
	0x00,0x82,0x00,0x02,0x00,0x4E,0x00,0x02,	/* 1FC8: ....N.. */
	0x00,0x41,0x00,0x02,0x00,0x82,0x00,0x01,	/* 1FD0: .A..... */
	0x00,0x57,0x00,0x02,0x00,0x41,0x00,0x01,	/* 1FD8: .W...A.. */
	0x00,0x82,0x00,0x00,0x00,0x2B,0x00,0x00,	/* 1FE0: ....+.. */
	0x00,0xA3,0x00,0x04,0x00,0x1B,0x00,0x00,	/* 1FE8: ....... */
	0x00,0x51,0x00,0x00,0x00,0x51,0x00,0x04,	/* 1FF0: .Q...Q.. */
	0x00,0xA3,0x00,0x03,0x00,0x51,0x00,0x03,	/* 1FF8: ....Q.. */
	0x00,0xA3,0x00,0x02,0x00,0x62,0x00,0x02,	/* 2000: ....b.. */
	0x00,0x51,0x00,0x02,0x00,0xA3,0x00,0x01,	/* 2008: .Q..... */
	0x00,0x6D,0x00,0x02,0x00,0x51,0x00,0x01,	/* 2010: .m...Q.. */
	0x00,0xA3,0x00,0x00,0x00,0x36,0x00,0x00,	/* 2018: ....6.. */
	0x00,0x36,0x00,0x05,0x00,0x1B,0x00,0x05,	/* 2020: .6...... */
	0x00,0x0D,0x00,0x05,0x00,0xF4,0x00,0x04,	/* 2028: ....... */
	0x00,0x6F,0x00,0x04,0x00,0x5B,0x00,0x04,	/* 2030: .o...[.. */
	0x00,0xF4,0x00,0x03,0x00,0x6D,0x00,0x01,	/* 2038: ....m.. */
	0x00,0x38,0x00,0x00,0x00,0x31,0x00,0x00,	/* 2040: .8...1.. */
	0x00,0x29,0x00,0x00,0x00,0x62,0x00,0x05,	/* 2048: .)...b.. */
	0x00,0x53,0x00,0x05,0x00,0xD9,0x00,0x00,	/* 2050: .S..... */
	0x00,0x30,0x00,0x05,0x00,0x6D,0x00,0x00,	/* 2058: .0...m.. */
	0x00,0xF0,0x00,0x01,0x00,0x01,0x00,0x0A,	/* 2060: ....... */
	0x00,0x0A,0x00,0x0A,0x00,0x0A,0x00,0x09,	/* 2068: ........ */
	0x00,0x08,0x00,0x06,0x00,0x0A,0x00,0x03,	/* 2070: ........ */
	0x00,0x02,0x00,0x01,0x00,0xF0,0x00,0x01,	/* 2078: ....... */
	0x00,0x01,0x00,0x0A,0x00,0x0A,0x00,0x0A,	/* 2080: ........ */
	0x00,0x0A,0x00,0x09,0x00,0x08,0x00,0x06,	/* 2088: ........ */
	0x00,0x0A,0x00,0x03,0x00,0x02,0x00,0x01,	/* 2090: ........ */
	0x00,0x01,0x00,0x01,0x00,0x01,0x00,0xF0,	/* 2098: ....... */
	0x00,0x0A,0x00,0x0A,0x00,0x0A,0x00,0x06,	/* 20A0: ........ */
	0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,	/* 20A8: ........ */
	0x00,0x01,0x00,0x03,0x00,0x01,0x00,0x02,	/* 20B0: ........ */
	0x20,0x51,0x00,0x4F,0x00,0x4D,0x00,0x4B,	/* 20B8:  Q.O.M.K */
	0x00,0x49,0x00,0x47,0x00,0x45,0x00,0x43,	/* 20C0: .I.G.E.C */
	0x00,0x41,0x00,0x3F,0x00,0x3D,0x00,0x3B,	/* 20C8: .A.?.=.; */
	0x00,0x39,0x00,0x37,0x00,0x35,0x00,0x33,	/* 20D0: .9.7.5.3 */
	0x00,0x31,0x00,0x2F,0x00,0x2D,0x00,0x2C,	/* 20D8: .1...-., */
	0x00,0xE4,0x0D,0x60,0xBF,0x72,0x23,0x57,	/* 20E0: ..`r#W */
	0x20,0x20,0xD0,0x70,0x72,0xE6,0x20,0x69,	/* 20E8:   pr i */
	0x4E,0x21,0xFB,0x70,0x25,0x47,0x24,0xFA,	/* 20F0: N!p%G$ */
	0x65,0x23,0x40,0x21,0xFB,0x70,0x25,0xE2,	/* 20F8: e#@!p% */
	0x66,0x2C,0x46,0x21,0xFB,0x70,0x25,0xE0,	/* 2100: f,F!p% */
	0x66,0x2B,0x48,0x21,0xFB,0x70,0x24,0xEE,	/* 2108: f+H!p$ */
	0x66,0x2A,0x49,0x21,0xFB,0x70,0x24,0xEC,	/* 2110: f*I!p$ */
	0x67,0x27,0x44,0x21,0xFB,0x70,0x24,0xEA,	/* 2118: g'D!p$ */
	0x68,0x2A,0x44,0x21,0xFB,0x70,0x24,0xE8,	/* 2120: h*D!p$ */
	0x68,0x28,0x46,0x21,0xFB,0x70,0x24,0xE6,	/* 2128: h(F!p$ */
	0x68,0x22,0x4C,0x21,0xFB,0x70,0x24,0xE4,	/* 2130: h"L!p$ */
	0x69,0x2D,0x41,0x21,0xFB,0x70,0x24,0xE2,	/* 2138: i-A!p$ */
	0x6B,0x28,0x42,0x21,0xFB,0x70,0x24,0xE0,	/* 2140: k(B!p$ */
	0x6B,0x27,0x47,0x21,0xFB,0x70,0x23,0xEE,	/* 2148: k'G!p# */
	0x6B,0x26,0x4C,0x21,0xFB,0x70,0x23,0xEC,	/* 2150: k&L!p# */
	0x6B,0x25,0x45,0x21,0xFB,0x70,0x23,0xEA,	/* 2158: k%E!p# */
	0x6C,0x2C,0x47,0x21,0xFB,0x70,0x23,0xE8,	/* 2160: l,G!p# */
	0x6C,0x21,0x47,0x21,0xFB,0x70,0x23,0xE6,	/* 2168: l!G!p# */
	0x61,0x2B,0x2B,0x4A,0x21,0xFB,0x70,0x23,	/* 2170: a++J!p# */
	0xE4,0x6D,0x2C,0x40,0x21,0xFB,0x70,0x23,	/* 2178: m,@!p# */
	0xE2,0x61,0x2B,0x2A,0x49,0x21,0xFB,0x70,	/* 2180: a+*I!p */
	0x23,0xE0,0x61,0x2B,0x2A,0x40,0x21,0xFB,	/* 2188: #a+*@! */
	0x70,0x22,0xEE,0x70,0x27,0x5F,0x20,0x20,	/* 2190: p"p'_   */
	0x70,0x25,0xE4,0x70,0x60,0x59,0x20,0x20,	/* 2198: p%p`Y   */
	0x70,0x25,0xE3,0x70,0x6E,0x41,0x21,0xFB,	/* 21A0: p%pnA! */
	0x21,0x44,0x23,0x23,0x2E,0x9F,0xB1,0x22,	/* 21A8: !D##." */
	0xF0,0x07,0x00,0x00,0x00,0x60,0xBC,0x75,	/* 21B0: ....`u */
	0x37,0x20,0xD3,0x21,0x28,0x40,0xD1,0x73,	/* 21B8: 7 !(@s */
	0x30,0x30,0x87,0xF1,0x81,0x73,0x30,0x30,	/* 21C0: 00s00 */
	0x87,0x23,0xFB,0x75,0x2C,0x9A,0x71,0x8E,	/* 21C8: #u,q */
	0xF1,0x25,0xFA,0xD2,0x40,0xF4,0xAD,0x72,	/* 21D0: %@r */
	0x73,0x31,0xFA,0x30,0xD0,0x71,0x75,0x2C,	/* 21D8: s10qu, */
	0x2D,0x94,0x2A,0xAE,0x71,0x31,0xD0,0x71,	/* 21E0: -*q1q */
	0x34,0x41,0x24,0xF6,0xC0,0x25,0xA0,0x71,	/* 21E8: 4A$%q */
	0x8D,0xF1,0x71,0x8C,0xF1,0xF4,0x24,0xA7,	/* 21F0: q$ */
	0x71,0x34,0x41,0x24,0xFB,0x71,0xE4,0x71,	/* 21F8: q4A$qq */
	0x87,0xF1,0x71,0x32,0x27,0x2F,0x2F,0x4F,	/* 2200: q2'..O */
	0x24,0xF6,0x89,0x23,0xFB,0x71,0x87,0xF1,	/* 2208: $#q */
	0x70,0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x71,	/* 2210: p' .Nq */
	0x87,0xF1,0x43,0x24,0xF6,0x70,0x27,0x20,	/* 2218: C$p'  */
	0x2D,0x40,0xF2,0xE0,0x70,0x27,0x20,0x20,	/* 2220: -@p'   */
	0x4C,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x44,	/* 2228: L0.O$D */
	0x24,0xFB,0x70,0x27,0x20,0x20,0x4C,0xF2,	/* 2230: $p'  L */
	0xE0,0x41,0x71,0x22,0x89,0x23,0xFB,0x71,	/* 2238: Aq"#q */
	0x34,0x21,0x40,0x24,0xF6,0x21,0xA7,0x22,	/* 2240: 4!@$!" */
	0x40,0x71,0x8A,0xF1,0x71,0x8B,0xF1,0xF4,	/* 2248: @qq */
	0x2F,0x4F,0x24,0xF6,0xF9,0xA8,0x71,0x34,	/* 2250: .O$q4 */
	0x61,0x4F,0x24,0xF6,0x71,0xE4,0x71,0x24,	/* 2258: aO$qq$ */
	0x80,0xF1,0x21,0x40,0x24,0xF6,0x22,0xAA,	/* 2260: !@$" */
	0x71,0x87,0xF1,0x71,0x32,0x27,0x2F,0x2F,	/* 2268: qq2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x71,0x87,	/* 2270: O$#q */
	0xF1,0x70,0x27,0x20,0x2F,0x4E,0xF2,0xE0,	/* 2278: p' .N */
	0x71,0x87,0xF1,0x43,0x24,0xF6,0x70,0x27,	/* 2280: qC$p' */
	0x20,0x2D,0x40,0xF2,0xE0,0x71,0x75,0x2C,	/* 2288:  -@qu, */
	0x22,0x96,0x71,0x21,0x37,0xD1,0x6D,0x07,	/* 2290: "q!7m. */
	0x61,0xBE,0x21,0x73,0x37,0x20,0x21,0xD1,	/* 2298: a!s7 ! */
	0x40,0x21,0xD0,0x40,0xDF,0x40,0xDD,0x21,	/* 22A0: @!@@! */
	0x71,0x32,0xDE,0x21,0x71,0x33,0xDF,0x21,	/* 22A8: q2!q3! */
	0x05,0x21,0x70,0xC0,0x2B,0x2F,0xA3,0x7E,	/* 22B0: .!p+.~ */
	0x21,0x71,0x32,0xF4,0xC0,0xA8,0x7F,0x21,	/* 22B8: !q2! */
	0x71,0x33,0xF4,0x2B,0x2E,0xA4,0x7E,0x33,	/* 22C0: q3+.~3 */
	0xDC,0x7F,0x23,0xF4,0x23,0xF4,0x7C,0x27,	/* 22C8: ##|' */
	0x20,0x2F,0x4E,0xF2,0xE0,0x7C,0x27,0x20,	/* 22D0:  .N|'  */
	0x2C,0x4E,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 22D8: ,N0.O$ */
	0x21,0xD0,0x21,0x70,0x41,0x24,0xF6,0x26,	/* 22E0: !!pA$& */
	0x21,0xA6,0x40,0xDB,0x40,0xDA,0x40,0xD9,	/* 22E8: !@@@ */
	0x40,0xD8,0x40,0xD7,0x40,0xD6,0x40,0xD4,	/* 22F0: @@@@ */
	0x7C,0x27,0x20,0x2D,0x46,0xF2,0x30,0x2F,	/* 22F8: |' -F0. */
	0x4F,0x24,0xF6,0xDD,0x7D,0x43,0x24,0xF6,	/* 2300: O$}C$ */
	0x7C,0x27,0x20,0x2D,0x40,0xF2,0xE0,0x7F,	/* 2308: |' -@ */
	0x7D,0x43,0x24,0xF6,0x28,0xF1,0x7E,0x55,	/* 2310: }C$(~U */
	0xFA,0x30,0xD5,0x7C,0x27,0x20,0x28,0x46,	/* 2318: 0|' (F */
	0xF2,0x30,0x47,0x24,0xF6,0xC3,0x24,0x2E,	/* 2320: 0G$$. */
	0xAC,0x75,0x34,0x21,0x40,0x24,0xF6,0xC0,	/* 2328: u4!@$ */
	0x24,0x2C,0xAF,0x75,0x22,0x87,0xF1,0xC0,	/* 2330: $,u" */
	0xAC,0x75,0x22,0x88,0xF1,0x41,0x24,0xFB,	/* 2338: u"A$ */
	0x75,0x22,0x88,0x23,0xFB,0x75,0x8A,0xF1,	/* 2340: u"#u */
	0xD4,0x75,0x8B,0xF1,0xD9,0x79,0x74,0x81,	/* 2348: uyt */
	0xF4,0x2F,0x4F,0x24,0xF6,0xD8,0x78,0x7C,	/* 2350: .O$x| */
	0x27,0x20,0x21,0x4C,0xF2,0x30,0x2F,0x4F,	/* 2358: ' !L0.O */
	0x24,0xF6,0x25,0xFA,0xD6,0xF9,0xA3,0x76,	/* 2360: $%v */
	0x40,0xA2,0x78,0x40,0xF4,0x2F,0x4F,0x24,	/* 2368: @x@.O$ */
	0xF6,0xDB,0x76,0x7B,0xF4,0x2F,0x4F,0x24,	/* 2370: v{.O$ */
	0xF6,0xD6,0x7B,0xD3,0x41,0x73,0xF9,0xC0,	/* 2378: {As */
	0x24,0x23,0xA4,0x73,0x22,0x40,0xF9,0xC0,	/* 2380: $#s"@ */
	0x24,0x22,0xAC,0x73,0x60,0x8F,0x23,0xF4,	/* 2388: $"s`# */
	0x23,0xF4,0x42,0x21,0xFB,0xF2,0xF6,0x24,	/* 2390: #B!$ */
	0x20,0x00,0x20,0x23,0x2D,0x0F,0x20,0x23,	/* 2398:  . #-. # */
	0x2B,0x0E,0x20,0x23,0x29,0x0D,0x20,0x23,	/* 23A0: +. #). # */
	0x27,0x0C,0x20,0x23,0x25,0x0B,0x20,0x23,	/* 23A8: '. #%. # */
	0x23,0x0A,0x20,0x23,0x21,0x09,0x20,0x22,	/* 23B0: #. #!. " */
	0x2F,0x08,0x20,0x22,0x2D,0x07,0x20,0x22,	/* 23B8: .. "-. " */
	0x2B,0x06,0x20,0x22,0x29,0x05,0x20,0x22,	/* 23C0: +. "). " */
	0x27,0x04,0x20,0x22,0x25,0x03,0x20,0x22,	/* 23C8: '. "%. " */
	0x23,0x02,0x20,0x22,0x21,0x01,0x20,0x21,	/* 23D0: #. "!. ! */
	0x2F,0x00,0x20,0x21,0x2C,0x0F,0x20,0x21,	/* 23D8: .. !,. ! */
	0x2A,0x0E,0x20,0x21,0x28,0x0D,0x20,0x21,	/* 23E0: *. !(. ! */
	0x26,0x0C,0x20,0x21,0x24,0x0B,0x20,0x21,	/* 23E8: &. !$. ! */
	0x22,0x0A,0x20,0x21,0x20,0x09,0x20,0x2E,	/* 23F0: ". ! . . */
	0x09,0x20,0x20,0x2C,0x08,0x20,0x20,0x2A,	/* 23F8: .  ,.  * */
	0x07,0x20,0x20,0x28,0x06,0x20,0x20,0x26,	/* 2400: .  (.  & */
	0x05,0x20,0x20,0x24,0x04,0x20,0x20,0x22,	/* 2408: .  $.  " */
	0x03,0x20,0x20,0x03,0x20,0x20,0x20,0x7C,	/* 2410: .  .   | */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 2418: ' ,D0.O */
	0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,	/* 2420: $@tt */
	0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,	/* 2428: .O$su+ */
	0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,	/* 2430: P#|' , */
	0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,	/* 2438: D0.O$@ */
	0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,	/* 2440: tt.O$ */
	0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,	/* 2448: su+P# */
	0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,	/* 2450: |' ,D0 */
	0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,	/* 2458: .O$@t */
	0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,	/* 2460: t.O$s */
	0x75,0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,	/* 2468: u+P#|' */
	0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,	/* 2470:  ,D0.O$ */
	0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,	/* 2478: @tt. */
	0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,	/* 2480: O$su+P */
	0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,	/* 2488: #|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,	/* 2490: 0.O$@ */
	0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,	/* 2498: tt.O$ */
	0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,	/* 24A0: su+P# */
	0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,	/* 24A8: |' ,D0. */
	0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,	/* 24B0: O$@tt */
	0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,	/* 24B8: .O$su */
	0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,	/* 24C0: +P#|'  */
	0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 24C8: ,D0.O$ */
	0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,	/* 24D0: @tt.O */
	0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,	/* 24D8: $su+P */
	0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,	/* 24E0: #|' ,D */
	0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,	/* 24E8: 0.O$@t */
	0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,	/* 24F0: t.O$ */
	0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,0x7C,	/* 24F8: su+P#| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 2500: ' ,D0.O */
	0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,	/* 2508: $@tt */
	0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,	/* 2510: .O$su+ */
	0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,	/* 2518: P#|' , */
	0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,	/* 2520: D0.O$@ */
	0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,	/* 2528: tt.O$ */
	0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,	/* 2530: su+P# */
	0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,	/* 2538: |' ,D0 */
	0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,	/* 2540: .O$@t */
	0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,	/* 2548: t.O$s */
	0x75,0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,	/* 2550: u+P#|' */
	0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,	/* 2558:  ,D0.O$ */
	0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,	/* 2560: @tt. */
	0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,	/* 2568: O$su+P */
	0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,	/* 2570: #|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,	/* 2578: 0.O$@ */
	0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,	/* 2580: tt.O$ */
	0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,	/* 2588: su+P# */
	0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,	/* 2590: |' ,D0. */
	0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,	/* 2598: O$@tt */
	0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,	/* 25A0: .O$su */
	0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,	/* 25A8: +P#|'  */
	0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 25B0: ,D0.O$ */
	0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,	/* 25B8: @tt.O */
	0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,	/* 25C0: $su+P */
	0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,	/* 25C8: #|' ,D */
	0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,	/* 25D0: 0.O$@t */
	0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,	/* 25D8: t.O$ */
	0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,0x7C,	/* 25E0: su+P#| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 25E8: ' ,D0.O */
	0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,	/* 25F0: $@tt */
	0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,	/* 25F8: .O$su+ */
	0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,	/* 2600: P#|' , */
	0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,	/* 2608: D0.O$@ */
	0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,	/* 2610: tt.O$ */
	0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,	/* 2618: su+P# */
	0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,	/* 2620: |' ,D0 */
	0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,	/* 2628: .O$@t */
	0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,	/* 2630: t.O$s */
	0x75,0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,	/* 2638: u+P#|' */
	0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,	/* 2640:  ,D0.O$ */
	0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,	/* 2648: @tt. */
	0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,	/* 2650: O$su+P */
	0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,	/* 2658: #|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,	/* 2660: 0.O$@ */
	0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,	/* 2668: tt.O$ */
	0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,	/* 2670: su+P# */
	0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,	/* 2678: |' ,D0. */
	0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,	/* 2680: O$@tt */
	0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,	/* 2688: .O$su */
	0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,	/* 2690: +P#|'  */
	0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 2698: ,D0.O$ */
	0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,	/* 26A0: @tt.O */
	0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,	/* 26A8: $su+P */
	0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,	/* 26B0: #|' ,D */
	0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,	/* 26B8: 0.O$@t */
	0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,	/* 26C0: t.O$ */
	0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,0x7C,	/* 26C8: su+P#| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 26D0: ' ,D0.O */
	0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,	/* 26D8: $@tt */
	0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,	/* 26E0: .O$su+ */
	0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,	/* 26E8: P#|' , */
	0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,	/* 26F0: D0.O$@ */
	0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,	/* 26F8: tt.O$ */
	0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,	/* 2700: su+P# */
	0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,	/* 2708: |' ,D0 */
	0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,	/* 2710: .O$@t */
	0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,	/* 2718: t.O$s */
	0x75,0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,	/* 2720: u+P#|' */
	0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,	/* 2728:  ,D0.O$ */
	0xF6,0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,	/* 2730: @tt. */
	0x4F,0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,	/* 2738: O$su+P */
	0xF5,0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,	/* 2740: #|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,	/* 2748: 0.O$@ */
	0x74,0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,	/* 2750: tt.O$ */
	0xD4,0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,	/* 2758: su+P# */
	0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,	/* 2760: |' ,D0. */
	0x4F,0x24,0xF6,0x40,0xD3,0x74,0xD3,0x74,	/* 2768: O$@tt */
	0x81,0x2F,0x4F,0x24,0xF6,0xD4,0x73,0x75,	/* 2770: .O$su */
	0x2B,0x50,0xF5,0x23,0xFB,0x7C,0x27,0x20,	/* 2778: +P#|'  */
	0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 2780: ,D0.O$ */
	0x40,0xD3,0x74,0xD3,0x74,0x81,0x2F,0x4F,	/* 2788: @tt.O */
	0x24,0xF6,0xD4,0x73,0x75,0x2B,0x50,0xF5,	/* 2790: $su+P */
	0x23,0xFB,0x7C,0x27,0x20,0x2C,0x44,0xF2,	/* 2798: #|' ,D */
	0x30,0x2F,0x4F,0x24,0xF6,0x40,0xD3,0x74,	/* 27A0: 0.O$@t */
	0xD3,0x74,0x81,0x2F,0x4F,0x24,0xF6,0xD4,	/* 27A8: t.O$ */
	0x73,0x75,0x2B,0x50,0xF5,0x23,0xFB,0x74,	/* 27B0: su+P#t */
	0x75,0x8A,0x23,0xFB,0x75,0x21,0x3F,0x76,	/* 27B8: u#u!?v */
	0xF2,0x75,0x21,0xEF,0x40,0xD3,0x76,0xD3,	/* 27C0: u!@v */
	0x76,0x60,0x8F,0x2F,0x4F,0x24,0xF6,0xD6,	/* 27C8: v`.O$ */
	0x73,0xAE,0x7C,0x27,0x20,0x2C,0x44,0xF2,	/* 27D0: s|' ,D */
	0x30,0x2F,0x4F,0x24,0xF6,0xD7,0x61,0x04,	/* 27D8: 0.O$a. */
	0x79,0x74,0x81,0xF4,0x2F,0x4F,0x24,0xF6,	/* 27E0: yt.O$ */
	0xDA,0x75,0x34,0x48,0x24,0xF6,0x21,0xA2,	/* 27E8: u4H$! */
	0x78,0x21,0x4F,0xF9,0xAD,0x22,0x40,0x7A,	/* 27F0: x!O"@z */
	0xF9,0xA8,0x75,0x34,0x21,0x40,0x24,0xFB,	/* 27F8: u4!@$ */
	0x75,0xE4,0x41,0x21,0x71,0x34,0xE0,0x7D,	/* 2800: uA!q4} */
	0x23,0x4F,0x24,0xF6,0x7C,0x27,0x20,0x2D,	/* 2808: #O$|' - */
	0x46,0xF2,0xE0,0x2E,0x0B,0x40,0xD3,0x40,	/* 2810: F..@@ */
	0xD2,0x40,0xD1,0x40,0xD2,0x7C,0x27,0x20,	/* 2818: @@|'  */
	0x2C,0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 2820: ,D0.O$ */
	0xD1,0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,	/* 2828: |' ,D0 */
	0x2F,0x4F,0x24,0xF6,0xD3,0x71,0x48,0x24,	/* 2830: .O$qH$ */
	0xF6,0x21,0xA1,0x75,0x21,0x89,0xF1,0x41,	/* 2838: !u!A */
	0x24,0xFB,0x75,0x21,0x89,0x23,0xFB,0x41,	/* 2840: $u!#A */
	0x21,0x71,0x35,0xE0,0x71,0x47,0x24,0xF6,	/* 2848: !q5qG$ */
	0xAE,0x75,0x22,0x80,0xF1,0x28,0x40,0x24,	/* 2850: u"(@$ */
	0xF6,0xA5,0x41,0x21,0x71,0x35,0xE0,0x71,	/* 2858: A!q5q */
	0x41,0x24,0xF6,0xA8,0x75,0x21,0x3E,0x41,	/* 2860: A$u!>A */
	0xF2,0x75,0x21,0xEE,0x71,0x42,0x24,0xF6,	/* 2868: u!qB$ */
	0xAA,0x75,0x21,0x3C,0x41,0xF2,0x75,0x21,	/* 2870: u!<Au! */
	0xEC,0x41,0xD2,0x71,0x44,0x24,0xF6,0xAA,	/* 2878: AqD$ */
	0x75,0x21,0x3D,0x41,0xF2,0x75,0x21,0xED,	/* 2880: u!=Au! */
	0x41,0xD2,0x72,0x26,0xA7,0x75,0x22,0x80,	/* 2888: Ar&u" */
	0xF1,0x24,0x40,0x24,0xF6,0xA5,0x75,0x22,	/* 2890: $@$u" */
	0x8B,0xF1,0xD3,0x75,0x8A,0xF1,0xD4,0x75,	/* 2898: uu */
	0x8B,0xF1,0xD9,0x79,0x74,0x81,0xF4,0x2F,	/* 28A0: yt. */
	0x4F,0x24,0xF6,0xD8,0x78,0x23,0xAD,0x73,	/* 28A8: O$x#s */
	0x40,0xD0,0x74,0xD0,0x74,0x81,0x2F,0x4F,	/* 28B0: @tt.O */
	0x24,0xF6,0xD4,0x70,0x75,0x2B,0x50,0xF5,	/* 28B8: $pu+P */
	0x23,0xFB,0x74,0x75,0x8A,0x23,0xFB,0x79,	/* 28C0: #tu#y */
	0x74,0x81,0xF4,0x2F,0x4F,0x24,0xF6,0xDA,	/* 28C8: t.O$ */
	0x75,0x34,0x48,0x24,0xF6,0x21,0xAD,0x78,	/* 28D0: u4H$!x */
	0x21,0x4F,0xF9,0x21,0xA7,0x22,0x40,0x7A,	/* 28D8: !O!"@z */
	0xF9,0x21,0xA1,0x75,0x34,0x21,0x40,0x24,	/* 28E0: !u4!@$ */
	0xFB,0x75,0xE4,0x08,0x75,0x21,0x3F,0x76,	/* 28E8: u.u!?v */
	0xF2,0x75,0x21,0xEF,0x7D,0x23,0x4F,0x24,	/* 28F0: u!}#O$ */
	0xF6,0x7C,0x27,0x20,0x2D,0x46,0xF2,0xE0,	/* 28F8: |' -F */
	0x21,0x70,0x42,0x24,0xF6,0x25,0x21,0xAA,	/* 2900: !pB$%! */
	0x40,0xDB,0x40,0xDA,0x40,0xD9,0x40,0xD8,	/* 2908: @@@@ */
	0x40,0xD6,0x7C,0x27,0x20,0x2D,0x44,0xF2,	/* 2910: @|' -D */
	0x30,0x2F,0x4F,0x24,0xF6,0xDD,0x7D,0x43,	/* 2918: 0.O$}C */
	0x24,0xF6,0x7C,0x27,0x20,0x2D,0x40,0xF2,	/* 2920: $|' -@ */
	0xE0,0x7F,0x7D,0x43,0x24,0xF6,0x28,0xF1,	/* 2928: }C$( */
	0x7E,0x55,0xFA,0x30,0xD7,0x77,0x22,0x87,	/* 2930: ~U0w" */
	0xF1,0xC0,0xAC,0x77,0x22,0x88,0xF1,0x42,	/* 2938: w"B */
	0x24,0xFB,0x77,0x22,0x88,0x23,0xFB,0x77,	/* 2940: $w"#w */
	0x23,0x85,0xF1,0xA9,0x77,0x21,0x73,0x25,	/* 2948: #w!s% */
	0x26,0x9A,0x24,0x2C,0x01,0x77,0x8D,0xF1,	/* 2950: &$,.w */
	0xDB,0x77,0x8C,0xF1,0xD6,0x77,0x34,0x21,	/* 2958: ww4! */
	0x20,0x40,0x24,0xF6,0x22,0xAC,0x77,0x34,	/* 2960:  @$"w4 */
	0x61,0x2F,0x4F,0x24,0xF6,0x77,0xE4,0x77,	/* 2968: a.O$ww */
	0x34,0x22,0x20,0x40,0x24,0xFB,0x77,0xE4,	/* 2970: 4" @$w */
	0x77,0x34,0x60,0x4E,0x24,0xF6,0x77,0xE4,	/* 2978: w4`N$w */
	0x7C,0x27,0x20,0x20,0x4C,0xF2,0x30,0x2F,	/* 2980: |'  L0. */
	0x49,0x24,0xF6,0x7C,0x27,0x20,0x20,0x4C,	/* 2988: I$|'  L */
	0xF2,0xE0,0x7B,0x76,0xF4,0x2F,0x4F,0x24,	/* 2990: {v.O$ */
	0xF6,0xD8,0x78,0x77,0x22,0x8A,0xF1,0xF9,	/* 2998: xw" */
	0xA6,0x77,0x22,0x8A,0xF1,0x40,0xA2,0x78,	/* 29A0: w"@x */
	0x40,0xF4,0x2F,0x4F,0x24,0xF6,0xD9,0x79,	/* 29A8: @.O$y */
	0xC0,0x21,0xA2,0x7C,0x27,0x20,0x20,0x4C,	/* 29B0: !|'  L */
	0xF2,0x30,0x44,0x24,0xF6,0xA7,0x42,0x77,	/* 29B8: 0D$Bw */
	0x24,0x84,0x23,0xFB,0x06,0x79,0x77,0x24,	/* 29C0: $#.yw$ */
	0x84,0x23,0xFB,0x79,0xD5,0x41,0x75,0xF9,	/* 29C8: #yAu */
	0xC0,0x23,0x29,0xA4,0x75,0x22,0x40,0xF9,	/* 29D0: #)u"@ */
	0xC0,0x23,0x28,0xAC,0x75,0x60,0x8F,0x23,	/* 29D8: #(u`# */
	0xF4,0x23,0xF4,0x42,0x21,0xFB,0xF2,0xF6,	/* 29E0: #B! */
	0x23,0x26,0x05,0x20,0x23,0x24,0x09,0x20,	/* 29E8: #&. #$.  */
	0x23,0x22,0x0D,0x20,0x23,0x21,0x01,0x20,	/* 29F0: #". #!.  */
	0x22,0x2F,0x05,0x20,0x22,0x2D,0x09,0x20,	/* 29F8: ".. "-.  */
	0x22,0x2B,0x0D,0x20,0x22,0x2A,0x01,0x20,	/* 2A00: "+. "*.  */
	0x22,0x28,0x05,0x20,0x22,0x26,0x09,0x20,	/* 2A08: "(. "&.  */
	0x22,0x24,0x0D,0x20,0x22,0x23,0x01,0x20,	/* 2A10: "$. "#.  */
	0x22,0x21,0x05,0x20,0x21,0x2F,0x09,0x20,	/* 2A18: "!. !..  */
	0x21,0x2D,0x0D,0x20,0x21,0x2C,0x01,0x20,	/* 2A20: !-. !,.  */
	0x21,0x2A,0x05,0x20,0x21,0x28,0x09,0x20,	/* 2A28: !*. !(.  */
	0x21,0x26,0x0D,0x20,0x21,0x25,0x01,0x20,	/* 2A30: !&. !%.  */
	0x21,0x23,0x05,0x20,0x21,0x21,0x09,0x20,	/* 2A38: !#. !!.  */
	0x2F,0x0E,0x20,0x20,0x2E,0x02,0x20,0x20,	/* 2A40: ..  ..   */
	0x2C,0x06,0x20,0x20,0x2A,0x0A,0x20,0x20,	/* 2A48: ,.  *.   */
	0x28,0x0E,0x20,0x20,0x27,0x02,0x20,0x20,	/* 2A50: (.  '.   */
	0x25,0x06,0x20,0x20,0x23,0x0A,0x20,0x20,	/* 2A58: %.  #.   */
	0x21,0x0E,0x20,0x20,0x03,0x20,0x20,0x20,	/* 2A60: !.  .    */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2A68: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2A70: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2A78: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2A80: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2A88: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2A90: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2A98: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2AA0: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2AA8: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2AB0: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2AB8: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2AC0: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2AC8: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2AD0: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2AD8: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2AE0: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2AE8: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2AF0: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2AF8: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2B00: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2B08: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2B10: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2B18: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2B20: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2B28: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2B30: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2B38: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2B40: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2B48: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2B50: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2B58: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2B60: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2B68: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2B70: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2B78: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2B80: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2B88: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2B90: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2B98: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2BA0: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2BA8: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2BB0: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2BB8: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2BC0: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2BC8: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2BD0: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2BD8: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2BE0: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2BE8: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2BF0: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2BF8: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2C00: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2C08: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2C10: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2C18: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2C20: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2C28: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2C30: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2C38: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2C40: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2C48: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2C50: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2C58: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2C60: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2C68: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2C70: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2C78: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2C80: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2C88: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2C90: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2C98: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2CA0: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2CA8: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2CB0: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2CB8: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2CC0: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2CC8: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2CD0: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2CD8: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2CE0: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2CE8: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2CF0: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2CF8: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2D00: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2D08: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2D10: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2D18: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2D20: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2D28: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2D30: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2D38: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2D40: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2D48: |' ,F */
	0x40,0xD5,0x76,0xD5,0x76,0x81,0x2F,0x4F,	/* 2D50: @vv.O */
	0x24,0xF6,0xD6,0x75,0x77,0x23,0x50,0xF5,	/* 2D58: $uw#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 2D60: |' ,F */
	0x7B,0x76,0xF4,0x2F,0x4F,0x24,0xF6,0xDA,	/* 2D68: {v.O$ */
	0x76,0x77,0x8C,0x23,0xFB,0x78,0x2C,0x40,	/* 2D70: vw#x,@ */
	0xF9,0x21,0xA0,0x2C,0x41,0x7A,0xF9,0xAB,	/* 2D78: !,Az */
	0x77,0x34,0x28,0x20,0x40,0x24,0xFB,0x77,	/* 2D80: w4( @$w */
	0xE4,0x22,0x02,0x78,0x24,0x40,0xF9,0x21,	/* 2D88: ".x$@! */
	0xAC,0x24,0x41,0x7A,0xF9,0x21,0xA6,0x77,	/* 2D90: $Az!w */
	0x34,0x28,0x20,0x40,0x24,0xF6,0xAE,0x77,	/* 2D98: 4( @$w */
	0x34,0x68,0x2F,0x4F,0x24,0xF6,0x77,0xE4,	/* 2DA0: 4h.O$w */
	0x41,0x21,0x71,0x35,0xE0,0x7A,0xC0,0x25,	/* 2DA8: A!q5z% */
	0xA9,0x7C,0x27,0x20,0x20,0x4C,0xF2,0x30,	/* 2DB0: |'  L0 */
	0x44,0x24,0xF6,0x21,0xA7,0x7C,0x27,0x20,	/* 2DB8: D$!|'  */
	0x20,0x4C,0xF2,0x30,0x2F,0x4B,0x24,0xF6,	/* 2DC0:  L0.K$ */
	0x42,0x24,0xFB,0x7C,0x27,0x20,0x20,0x4C,	/* 2DC8: B$|'  L */
	0xF2,0xE0,0x24,0x02,0x77,0x34,0x60,0x4E,	/* 2DD0: $.w4`N */
	0x24,0xF6,0x77,0xE4,0x7C,0x27,0x20,0x20,	/* 2DD8: $w|'   */
	0x4C,0xF2,0x30,0x2F,0x49,0x24,0xF6,0x7C,	/* 2DE0: L0.I$| */
	0x27,0x20,0x20,0x4C,0xF2,0xE0,0x77,0x24,	/* 2DE8: '  Lw$ */
	0x81,0xF1,0x41,0x24,0xF6,0x21,0xAF,0x41,	/* 2DF0: A$!A */
	0x21,0x71,0x35,0xE0,0x77,0x24,0x81,0xF1,	/* 2DF8: !q5w$ */
	0x60,0x4E,0x24,0xF6,0x77,0x24,0x81,0x23,	/* 2E00: `N$w$# */
	0xFB,0x0C,0x77,0x24,0x81,0xF1,0x41,0x24,	/* 2E08: .w$A$ */
	0xFB,0x77,0x24,0x81,0x23,0xFB,0x7D,0x23,	/* 2E10: w$#}# */
	0x4F,0x24,0xF6,0x7C,0x27,0x20,0x2D,0x44,	/* 2E18: O$|' -D */
	0xF2,0xE0,0x21,0x70,0x44,0x24,0xF6,0x25,	/* 2E20: !pD$% */
	0xAC,0x7C,0x27,0x20,0x2D,0x42,0xF2,0x30,	/* 2E28: |' -B0 */
	0x2F,0x4F,0x24,0xF6,0xDD,0x7D,0x43,0x24,	/* 2E30: .O$}C$ */
	0xF6,0x7C,0x27,0x20,0x2D,0x40,0xF2,0xE0,	/* 2E38: |' -@ */
	0x7F,0x7D,0x43,0x24,0xF6,0x28,0xF1,0x7E,	/* 2E40: }C$(~ */
	0x55,0xFA,0x30,0xDB,0x7B,0x21,0x73,0x26,	/* 2E48: U0{!s& */
	0x97,0x7B,0x21,0x73,0x26,0x9A,0x7B,0x22,	/* 2E50: {!s&{" */
	0x87,0xF1,0xC0,0xAC,0x7B,0x22,0x88,0xF1,	/* 2E58: {" */
	0x44,0x24,0xFB,0x7B,0x22,0x88,0x23,0xFB,	/* 2E60: D${"# */
	0x41,0x21,0x71,0x35,0xE0,0x7B,0x21,0x89,	/* 2E68: A!q5{! */
	0xF1,0x42,0x24,0xFB,0x7B,0x21,0x89,0x23,	/* 2E70: B${!# */
	0xFB,0x7D,0x23,0x4F,0x24,0xF6,0x7C,0x27,	/* 2E78: }#O$|' */
	0x20,0x2D,0x42,0xF2,0xE0,0x7F,0x81,0x2F,	/* 2E80:  -B. */
	0x4F,0x24,0xF6,0x25,0xFA,0xDF,0x41,0xF9,	/* 2E88: O$%A */
	0x6B,0x21,0xAE,0x40,0xDF,0x7E,0x30,0xAC,	/* 2E90: k!@~0 */
	0x7E,0x30,0x27,0x2F,0x2F,0x4F,0x24,0xF6,	/* 2E98: ~0'..O$ */
	0xDE,0x6B,0x20,0x0D,0x28,0x40,0xDE,0x6B,	/* 2EA0: k .(@k */
	0x20,0x07,0x7E,0x21,0x71,0xE2,0x7F,0x21,	/* 2EA8:  .~!q! */
	0x71,0xE3,0x21,0xB2,0x22,0xF0,0x74,0xF6,	/* 2EB0: q!"t */
	0x21,0x2D,0x23,0x0D,0x21,0x2B,0x2F,0x09,	/* 2EB8: !-#.!+.. */
	0x62,0x2B,0x23,0x03,0x80,0x5E,0x09,0x60,	/* 2EC0: b+#.^.` */
	0xBF,0x72,0x28,0x5C,0x20,0x20,0xD0,0x70,	/* 2EC8: r(\  p */
	0x72,0xE7,0x20,0x61,0x4D,0x21,0xFB,0x70,	/* 2ED0: r aM!p */
	0x84,0x41,0x24,0xFA,0x70,0x22,0x5A,0x20,	/* 2ED8: A$p"Z  */
	0x20,0x70,0xE5,0x70,0x22,0x5B,0x20,0x20,	/* 2EE0:  pp"[   */
	0x70,0xE4,0x70,0x62,0x57,0x20,0x20,0x70,	/* 2EE8: ppbW  p */
	0xE1,0x70,0x65,0x54,0x20,0x20,0x70,0xE0,	/* 2EF0: peT  p */
	0xB1,0x22,0xF0,0x08,0x00,0x00,0x00,0x60,	/* 2EF8: "....` */
	0xBF,0x73,0x31,0xD0,0x70,0x21,0x40,0x24,	/* 2F00: s1p!@$ */
	0xF6,0x21,0xA7,0x70,0x61,0x4F,0x24,0xF6,	/* 2F08: !paO$ */
	0x27,0x20,0x21,0x4A,0xF2,0x30,0x2F,0x4F,	/* 2F10: ' !J0.O */
	0x24,0xF6,0x23,0xF2,0x41,0x24,0xF0,0xB1,	/* 2F18: $#A$ */
	0x22,0xF0,0x70,0x61,0x4F,0x24,0xF6,0x27,	/* 2F20: "paO$' */
	0x20,0x21,0x4A,0xF2,0x30,0x2F,0x4F,0x24,	/* 2F28:  !J0.O$ */
	0xF6,0x23,0xF2,0x41,0x24,0xF1,0xB1,0x22,	/* 2F30: #A$" */
	0xF0,0xB1,0x22,0xF0,0x60,0xBE,0x74,0x31,	/* 2F38: "`t1 */
	0xD1,0x74,0x32,0x27,0x2F,0x2F,0x4F,0x24,	/* 2F40: t2'..O$ */
	0xF6,0xD0,0x75,0xC1,0xAD,0x70,0x84,0xF1,	/* 2F48: up */
	0x74,0x8F,0xF1,0x24,0xFB,0x70,0x84,0x23,	/* 2F50: t$p# */
	0xFB,0x0E,0x70,0x84,0xF1,0x74,0x8F,0xF1,	/* 2F58: .pt */
	0x23,0xF2,0x24,0xF6,0x70,0x84,0x23,0xFB,	/* 2F60: #$p# */
	0x70,0x84,0xF1,0x23,0xF2,0x71,0x6F,0x40,	/* 2F68: p#qo@ */
	0x24,0xF6,0x28,0x40,0x24,0xFB,0x27,0x20,	/* 2F70: $(@$'  */
	0x20,0x40,0xF2,0xE0,0xB2,0x22,0xF0,0x60,	/* 2F78:  @"` */
	0xB6,0x7B,0x38,0x20,0x21,0x5F,0xD9,0x40,	/* 2F80: {8 !_@ */
	0xD8,0x40,0xD7,0x40,0xD2,0x7C,0x31,0xD6,	/* 2F88: @@|1 */
	0x7C,0x8A,0xF1,0xD2,0x7C,0x8B,0xF1,0xD7,	/* 2F90: || */
	0x72,0x77,0xF4,0x2F,0x4F,0x24,0xF6,0xD8,	/* 2F98: rw.O$ */
	0x7E,0x30,0xD4,0x7C,0x22,0x81,0xF1,0xD5,	/* 2FA0: ~0|" */
	0x07,0x7D,0x41,0x24,0xF6,0x21,0x2A,0xA2,	/* 2FA8: .}A$!* */
	0x40,0xD1,0x24,0x40,0x76,0x27,0x20,0x20,	/* 2FB0: @$@v'   */
	0x44,0xF2,0xE0,0x76,0x27,0x20,0x20,0x46,	/* 2FB8: Dv'  F */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x7C,0x22,	/* 2FC0: 0.O$|" */
	0x83,0xF1,0x24,0xF6,0xD3,0x73,0xC0,0x23,	/* 2FC8: $s# */
	0xAF,0x7D,0x28,0x40,0x24,0xF6,0x23,0xA8,	/* 2FD0: }(@$# */
	0x75,0x41,0x24,0xF6,0xA4,0x41,0xD1,0x22,	/* 2FD8: uA$A" */
	0x0F,0x75,0x42,0x24,0xF6,0x21,0xA4,0x7C,	/* 2FE0: .uB$!| */
	0x21,0x89,0xF1,0x41,0x24,0xFB,0x7C,0x21,	/* 2FE8: !A$|! */
	0x89,0x23,0xFB,0x41,0x79,0x30,0xE0,0x41,	/* 2FF0: #Ay0A */
	0xD1,0x21,0x05,0x40,0x40,0xD0,0x72,0xD0,	/* 2FF8: !.@@r */
	0x72,0x81,0x2F,0x4F,0x24,0xF6,0xD2,0x70,	/* 3000: r.O$p */
	0x7C,0x2B,0x50,0xF5,0x23,0xFB,0x41,0xD1,	/* 3008: |+P#A */
	0x74,0x42,0x24,0xF6,0x25,0xA9,0x74,0x44,	/* 3010: tB$%tD */
	0x24,0xF6,0x23,0xA0,0x74,0x41,0x24,0xF6,	/* 3018: $#tA$ */
	0xC0,0xA9,0x73,0x7C,0x21,0x80,0xF1,0xF4,	/* 3020: s|! */
	0xC0,0x22,0xA1,0x74,0x60,0x4B,0x24,0xF6,	/* 3028: "t`K$ */
	0xD4,0x74,0x24,0x25,0x40,0x24,0xF6,0xC0,	/* 3030: t$%@$ */
	0x73,0x7C,0x21,0x80,0xF1,0xF4,0xA9,0x73,	/* 3038: s|!s */
	0x7C,0x21,0x81,0xF1,0xF4,0xC0,0x21,0xA5,	/* 3040: |!! */
	0x41,0xD1,0x21,0x01,0x73,0x7C,0x21,0x80,	/* 3048: A!.s|! */
	0xF1,0xF4,0xC0,0xA9,0x73,0x7C,0x21,0x81,	/* 3050: s|! */
	0xF1,0xF4,0xA2,0x41,0xD1,0x7C,0x21,0x81,	/* 3058: A|! */
	0xF1,0x73,0xF4,0xC0,0xAA,0x71,0xC0,0xA7,	/* 3060: sq */
	0x74,0x44,0x24,0xFB,0xD4,0x41,0xD1,0x7D,	/* 3068: tD$A} */
	0x27,0x40,0x24,0xF6,0x27,0xA1,0x71,0xC0,	/* 3070: '@$'q */
	0x26,0xAD,0x74,0x67,0x20,0x20,0x40,0x24,	/* 3078: &tg  @$ */
	0xF6,0x26,0xA4,0x75,0x48,0x24,0xF6,0xA4,	/* 3080: &uH$ */
	0x41,0xD1,0x29,0x00,0x75,0x44,0x24,0xF6,	/* 3088: A).uD$ */
	0x23,0xAE,0x2F,0x4F,0x40,0xD0,0x72,0xD0,	/* 3090: #.O@r */
	0x72,0x81,0x2F,0x4F,0x24,0xF6,0xD2,0x70,	/* 3098: r.O$p */
	0x7C,0x2B,0x50,0xF5,0x23,0xFB,0x40,0x40,	/* 30A0: |+P#@@ */
	0xD0,0x72,0xD0,0x72,0x81,0x2F,0x4F,0x24,	/* 30A8: rr.O$ */
	0xF6,0xD2,0x70,0x7C,0x2B,0x50,0xF5,0x23,	/* 30B0: p|+P# */
	0xFB,0x73,0x40,0xD0,0x72,0xD0,0x72,0x81,	/* 30B8: s@rr */
	0x2F,0x4F,0x24,0xF6,0xD2,0x70,0x7C,0x2B,	/* 30C0: .O$p|+ */
	0x50,0xF5,0x23,0xFB,0x41,0xD1,0x24,0x0C,	/* 30C8: P#A$. */
	0x40,0x40,0xD0,0x72,0xD0,0x72,0x81,0x2F,	/* 30D0: @@rr. */
	0x4F,0x24,0xF6,0xD2,0x70,0x7C,0x2B,0x50,	/* 30D8: O$p|+P */
	0xF5,0x23,0xFB,0x41,0xD1,0x23,0x05,0x73,	/* 30E0: #A#.s */
	0x2F,0xCF,0x23,0xA0,0x75,0x44,0x24,0xF6,	/* 30E8: .#uD$ */
	0x22,0xAA,0x2F,0x4F,0x40,0xD0,0x72,0xD0,	/* 30F0: ".O@r */
	0x72,0x81,0x2F,0x4F,0x24,0xF6,0xD2,0x70,	/* 30F8: r.O$p */
	0x7C,0x2B,0x50,0xF5,0x23,0xFB,0x2F,0x4F,	/* 3100: |+P#.O */
	0x40,0xD0,0x72,0xD0,0x72,0x81,0x2F,0x4F,	/* 3108: @rr.O */
	0x24,0xF6,0xD2,0x70,0x7C,0x2B,0x50,0xF5,	/* 3110: $p|+P */
	0x23,0xFB,0x41,0xD1,0x71,0xC0,0x22,0xA3,	/* 3118: #Aq" */
	0x2F,0x4E,0x72,0x77,0xF4,0x2F,0x4F,0x24,	/* 3120: .Nrw.O$ */
	0xF6,0xF9,0x21,0xA7,0x73,0x40,0xD0,0x72,	/* 3128: !s@r */
	0xD0,0x72,0x81,0x2F,0x4F,0x24,0xF6,0xD2,	/* 3130: r.O$ */
	0x70,0x7C,0x2B,0x50,0xF5,0x23,0xFB,0x41,	/* 3138: p|+P#A */
	0x79,0x31,0xE0,0x76,0x27,0x20,0x20,0x42,	/* 3140: y1v'  B */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xDD,0x61,	/* 3148: 0.O$a */
	0x25,0x07,0x2C,0x40,0x78,0xF9,0x24,0xA7,	/* 3150: %.,@x$ */
	0x72,0x77,0xF4,0x2F,0x4F,0x24,0xF6,0x2B,	/* 3158: rw.O$+ */
	0x4F,0xF9,0x23,0xAB,0x74,0x48,0x24,0xF6,	/* 3160: O#tH$ */
	0x23,0xA5,0x7C,0x23,0x80,0xF1,0x48,0x24,	/* 3168: #|#H$ */
	0xF6,0x21,0xA4,0x74,0x22,0x40,0x24,0xF6,	/* 3170: !t"@$ */
	0xC0,0xA7,0x74,0x2D,0x40,0x24,0xFB,0xD4,	/* 3178: t-@$ */
	0x06,0x74,0x64,0x4F,0x24,0xF6,0xD4,0x7C,	/* 3180: .tdO$| */
	0x23,0x81,0xF1,0x28,0x40,0x24,0xF6,0xAF,	/* 3188: #(@$ */
	0x29,0x40,0x76,0x27,0x20,0x20,0x44,0xF2,	/* 3190: )@v'  D */
	0xE0,0x74,0x21,0x40,0x24,0xFB,0xD4,0x72,	/* 3198: t!@$r */
	0x7C,0x8A,0x23,0xFB,0x74,0x7E,0xE0,0xBA,	/* 31A0: |#t~ */
	0x22,0xF0,0x60,0xB5,0x7C,0x38,0x20,0xDA,	/* 31A8: "`|8  */
	0x21,0x28,0x40,0xD7,0x77,0x21,0x37,0xD7,	/* 31B0: !(@w!7 */
	0x77,0x8E,0xF1,0x25,0xFA,0xD8,0xAE,0x78,	/* 31B8: w%x */
	0x7A,0x50,0xFA,0x30,0xD6,0x77,0x7C,0x26,	/* 31C0: zP0w|& */
	0x23,0x96,0x22,0x27,0xA1,0x77,0x31,0xD5,	/* 31C8: #"'w1 */
	0x75,0x21,0x20,0x20,0x40,0x24,0xF6,0x2C,	/* 31D0: u!  @$, */
	0xA2,0x75,0x27,0x20,0x20,0x42,0xF2,0x30,	/* 31D8: u'  B0 */
	0x2F,0x4F,0x24,0xF6,0xD6,0x76,0x44,0x24,	/* 31E0: .O$vD$ */
	0xF6,0x29,0xA8,0x40,0xD4,0x40,0xD3,0x40,	/* 31E8: )@@@ */
	0xD2,0x77,0x8D,0xF1,0xD4,0x77,0x8C,0xF1,	/* 31F0: ww */
	0xD2,0x74,0x72,0xF4,0x2F,0x4F,0x24,0xF6,	/* 31F8: tr.O$ */
	0x25,0xFA,0xD3,0x25,0xAD,0x40,0xD1,0x72,	/* 3200: %%@r */
	0xD1,0x72,0x81,0x2F,0x4F,0x24,0xF6,0xD2,	/* 3208: r.O$ */
	0x71,0x77,0x23,0x50,0xF5,0xF1,0x75,0x27,	/* 3210: qw#Pu' */
	0x20,0x20,0x46,0xF2,0xE0,0x41,0x77,0x24,	/* 3218:   FAw$ */
	0x84,0x23,0xFB,0x72,0x77,0x8C,0x23,0xFB,	/* 3220: #rw# */
	0x77,0x34,0x28,0x20,0x40,0x24,0xF6,0x21,	/* 3228: w4( @$! */
	0xA5,0x24,0x41,0x73,0xF9,0x21,0xAD,0x77,	/* 3230: $As!w */
	0x34,0x68,0x2F,0x4F,0x24,0xF6,0x77,0xE4,	/* 3238: 4h.O$w */
	0x41,0x7A,0x21,0x3F,0xE0,0x0E,0x73,0x2B,	/* 3240: Az!?.s+ */
	0x4F,0xF9,0xA9,0x77,0x34,0x28,0x20,0x40,	/* 3248: Ow4( @ */
	0x24,0xFB,0x77,0xE4,0x77,0x24,0x81,0xF1,	/* 3250: $ww$ */
	0x41,0x24,0xFB,0x77,0x24,0x81,0x23,0xFB,	/* 3258: A$w$# */
	0x22,0x01,0x77,0x24,0x81,0xF1,0x41,0x24,	/* 3260: ".w$A$ */
	0xF6,0x21,0xA2,0x41,0x7A,0x21,0x3F,0xE0,	/* 3268: !Az!? */
	0x77,0x24,0x81,0xF1,0x60,0x4E,0x24,0xF6,	/* 3270: w$`N$ */
	0x77,0x24,0x81,0x23,0xFB,0x40,0x77,0x24,	/* 3278: w$#@w$ */
	0x84,0x23,0xFB,0x76,0x41,0x24,0xF6,0x21,	/* 3280: #vA$! */
	0x2B,0xA4,0x77,0x34,0xD9,0x19,0xD0,0x76,	/* 3288: +w4.v */
	0x77,0x7C,0x63,0x2E,0x9A,0x79,0x77,0xE4,	/* 3290: w|c.yw */
	0x21,0x2A,0x03,0x77,0x34,0xD4,0x75,0x27,	/* 3298: !*.w4u' */
	0x20,0x20,0x42,0xF2,0x30,0x2F,0x4F,0x24,	/* 32A0:   B0.O$ */
	0xF6,0xD6,0x76,0x44,0x24,0xF6,0x21,0x22,	/* 32A8: vD$!" */
	0xAF,0x74,0x24,0x40,0x24,0xF6,0x24,0xA0,	/* 32B0: t$@$$ */
	0x74,0x28,0x40,0x24,0xF6,0x22,0xA0,0x77,	/* 32B8: t(@$"w */
	0x21,0x83,0xF1,0x75,0x27,0x20,0x20,0x46,	/* 32C0: !u'  F */
	0xF2,0xE0,0x41,0x77,0x24,0x84,0x23,0xFB,	/* 32C8: Aw$# */
	0x74,0x22,0x40,0x24,0xFB,0xD4,0x74,0x6C,	/* 32D0: t"@$tl */
	0x4F,0x24,0xF6,0xD4,0x21,0x20,0x01,0x77,	/* 32D8: O$! .w */
	0x21,0x82,0xF1,0x75,0x27,0x20,0x20,0x46,	/* 32E0: !u'  F */
	0xF2,0xE0,0x41,0x77,0x24,0x84,0x23,0xFB,	/* 32E8: Aw$# */
	0x74,0x67,0x4F,0x24,0xF6,0xD4,0x2E,0x08,	/* 32F0: tgO$.. */
	0x74,0x44,0x24,0xF6,0xC0,0x2E,0xA1,0x40,	/* 32F8: tD$.@ */
	0xD3,0x40,0xD2,0x40,0xD1,0x40,0xD0,0x77,	/* 3300: @@@w */
	0x8D,0xF1,0xD3,0x77,0x8C,0xF1,0xD0,0x73,	/* 3308: ws */
	0x70,0xF4,0x2F,0x4F,0x24,0xF6,0x25,0xFA,	/* 3310: p.O$% */
	0xD2,0x2A,0xA4,0x77,0x23,0x50,0x70,0xF5,	/* 3318: *w#Pp */
	0xF1,0xD1,0x71,0xCA,0x24,0xA5,0x74,0x24,	/* 3320: q$t$ */
	0x20,0x40,0x24,0xF6,0x23,0xAD,0x74,0x21,	/* 3328:  @$#t! */
	0x20,0x40,0x24,0xF6,0x21,0xAE,0x71,0x75,	/* 3330:  @$!qu */
	0x27,0x20,0x20,0x46,0xF2,0xE0,0x41,0x77,	/* 3338: '  FAw */
	0x24,0x84,0x23,0xFB,0x74,0x61,0x2F,0x4F,	/* 3340: $#ta.O */
	0x24,0xF6,0xD4,0x70,0x81,0x2F,0x4F,0x24,	/* 3348: $p.O$ */
	0xF6,0xD0,0x22,0x0C,0x4D,0x75,0x27,0x20,	/* 3350: ".Mu'  */
	0x20,0x46,0xF2,0xE0,0x41,0x77,0x24,0x84,	/* 3358:  FAw$ */
	0x23,0xFB,0x74,0x21,0x20,0x40,0x24,0xFB,	/* 3360: #t! @$ */
	0xD4,0x21,0x05,0x71,0x75,0x27,0x20,0x20,	/* 3368: !.qu'   */
	0x46,0xF2,0xE0,0x41,0x77,0x24,0x84,0x23,	/* 3370: FAw$# */
	0xFB,0x70,0x81,0x2F,0x4F,0x24,0xF6,0xD0,	/* 3378: p.O$ */
	0x70,0x77,0x8C,0x23,0xFB,0x77,0x34,0x28,	/* 3380: pw#w4( */
	0x20,0x40,0x24,0xF6,0x21,0xA5,0x24,0x41,	/* 3388:  @$!$A */
	0x72,0xF9,0x21,0xAD,0x77,0x34,0x68,0x2F,	/* 3390: r!w4h. */
	0x4F,0x24,0xF6,0x77,0xE4,0x41,0x7A,0x21,	/* 3398: O$wAz! */
	0x3F,0xE0,0x0E,0x72,0x2B,0x4F,0xF9,0xA9,	/* 33A0: ?.r+O */
	0x77,0x34,0x28,0x20,0x40,0x24,0xFB,0x77,	/* 33A8: w4( @$w */
	0xE4,0x77,0x24,0x81,0xF1,0x41,0x24,0xFB,	/* 33B0: w$A$ */
	0x77,0x24,0x81,0x23,0xFB,0x22,0x01,0x77,	/* 33B8: w$#".w */
	0x24,0x81,0xF1,0x41,0x24,0xF6,0x21,0xA2,	/* 33C0: $A$! */
	0x41,0x7A,0x21,0x3F,0xE0,0x77,0x24,0x81,	/* 33C8: Az!?w$ */
	0xF1,0x60,0x4E,0x24,0xF6,0x77,0x24,0x81,	/* 33D0: `N$w$ */
	0x23,0xFB,0x40,0x77,0x24,0x84,0x23,0xFB,	/* 33D8: #@w$# */
	0x76,0x41,0x24,0xF6,0xA8,0x14,0xD0,0x76,	/* 33E0: vA$.v */
	0x77,0x7C,0x64,0x29,0x92,0x74,0x21,0x40,	/* 33E8: w|d)t!@ */
	0x24,0xF6,0x24,0xA7,0x24,0x40,0x77,0x8A,	/* 33F0: $$$@w */
	0xF1,0x77,0x8B,0xF1,0xF4,0x2F,0x4F,0x24,	/* 33F8: w.O$ */
	0xF6,0xF9,0x23,0xA7,0x74,0x28,0x40,0x24,	/* 3400: #t(@$ */
	0xF6,0xA6,0x74,0x6C,0x4F,0x24,0xF6,0xD4,	/* 3408: tlO$ */
	0x74,0x22,0x40,0x24,0xF6,0xA6,0x74,0x24,	/* 3410: t"@$t$ */
	0x40,0x24,0xFB,0xD4,0x77,0x23,0x81,0xF1,	/* 3418: @$w# */
	0x28,0x40,0x24,0xF6,0xA9,0x28,0x40,0x75,	/* 3420: (@$(@u */
	0x27,0x20,0x20,0x44,0xF2,0xE0,0x74,0x61,	/* 3428: '  Dta */
	0x4F,0x24,0xF6,0xD4,0x74,0x24,0x24,0x44,	/* 3430: O$t$$D */
	0x24,0xF6,0xC0,0x74,0x77,0xE4,0x62,0x27,	/* 3438: $twb' */
	0x03,0x60,0xBB,0x77,0x31,0xD2,0x77,0x34,	/* 3440: .`w1w4 */
	0xD3,0x73,0xD1,0x43,0xD4,0x77,0x21,0x8F,	/* 3448: sCw! */
	0xF1,0xC0,0xA1,0x06,0x40,0x77,0x21,0x8F,	/* 3450: .@w! */
	0x23,0xFB,0x77,0x8E,0xF1,0xC8,0x22,0xA2,	/* 3458: #w" */
	0x77,0x21,0x84,0xF1,0x77,0x23,0x81,0xF1,	/* 3460: w!w# */
	0xF4,0xC0,0x21,0xA6,0x77,0x21,0x85,0xF1,	/* 3468: !w! */
	0x77,0x23,0x82,0xF1,0xF4,0xC0,0xAB,0x77,	/* 3470: w#w */
	0x21,0x86,0xF1,0x77,0x22,0x8D,0xF1,0xF4,	/* 3478: !w" */
	0x24,0xAD,0x21,0x4A,0x72,0x27,0x20,0x20,	/* 3480: $!Jr'   */
	0x44,0xF2,0xE0,0x77,0x21,0x84,0xF1,0x72,	/* 3488: Dw!r */
	0x27,0x20,0x20,0x40,0xF2,0xE0,0x77,0x21,	/* 3490: '  @w! */
	0x85,0xF1,0x72,0x27,0x20,0x20,0x40,0xF2,	/* 3498: r'  @ */
	0xE0,0x77,0x21,0x86,0xF1,0x72,0x27,0x20,	/* 34A0: w!r'  */
	0x20,0x42,0xF2,0xE0,0x77,0x21,0x84,0xF1,	/* 34A8:  Bw! */
	0x77,0x23,0x81,0x23,0xFB,0x77,0x21,0x85,	/* 34B0: w##w! */
	0xF1,0x77,0x23,0x82,0x23,0xFB,0x77,0x21,	/* 34B8: w##w! */
	0x86,0xF1,0x77,0x22,0x8D,0x23,0xFB,0x45,	/* 34C0: w"#E */
	0x72,0x27,0x20,0x20,0x44,0xF2,0xE0,0x77,	/* 34C8: r'  Dw */
	0x21,0x87,0xF1,0x41,0x24,0xF6,0x21,0xA4,	/* 34D0: !A$! */
	0x77,0x21,0x84,0xF1,0x28,0x40,0x24,0xF6,	/* 34D8: w!(@$ */
	0xC0,0xAA,0x28,0x40,0x72,0x27,0x20,0x20,	/* 34E0: (@r'   */
	0x44,0xF2,0xE0,0x09,0x29,0x40,0x72,0x27,	/* 34E8: D.)@r' */
	0x20,0x20,0x44,0xF2,0xE0,0x77,0x21,0x87,	/* 34F0:   Dw! */
	0xF1,0x42,0x24,0xF6,0xA7,0x41,0x77,0x76,	/* 34F8: B$Awv */
	0x65,0x23,0x99,0x06,0x40,0x77,0x76,0x65,	/* 3500: e#.@wve */
	0x23,0x92,0x40,0x77,0x21,0x89,0x23,0xFB,	/* 3508: #@w!# */
	0x77,0x21,0x8B,0xF1,0x77,0x21,0x80,0x23,	/* 3510: w!w!# */
	0xFB,0x77,0x21,0x8D,0xF1,0x77,0x21,0x82,	/* 3518: w!w! */
	0x23,0xFB,0x77,0x21,0x8C,0xF1,0x77,0x21,	/* 3520: #w!w! */
	0x81,0x23,0xFB,0x77,0x21,0x8E,0xF1,0x77,	/* 3528: #w!w */
	0x21,0x83,0x23,0xFB,0x77,0x22,0x80,0xF1,	/* 3530: !#w" */
	0x77,0x22,0x81,0x23,0xFB,0x77,0x22,0x82,	/* 3538: w"#w" */
	0xF1,0x77,0x22,0x83,0x23,0xFB,0x77,0x21,	/* 3540: w"#w! */
	0x8A,0xF1,0x77,0x23,0x80,0x23,0xFB,0x41,	/* 3548: w##A */
	0x77,0x24,0x82,0x23,0xFB,0x40,0x77,0x24,	/* 3550: w$#@w$ */
	0x83,0x23,0xFB,0x40,0x77,0x24,0x84,0x23,	/* 3558: #@w$# */
	0xFB,0x71,0x60,0x44,0x24,0xF6,0xD1,0x77,	/* 3560: q`D$w */
	0x21,0x8A,0xF1,0x42,0x24,0xF6,0xA5,0x71,	/* 3568: !B$q */
	0x42,0x24,0xFB,0xD1,0x77,0x21,0x8A,0xF1,	/* 3570: B$w! */
	0x48,0x24,0xF6,0xA5,0x71,0x48,0x24,0xFB,	/* 3578: H$qH$ */
	0xD1,0x77,0x21,0x8A,0xF1,0x41,0x24,0xF6,	/* 3580: w!A$ */
	0xA5,0x71,0x41,0x24,0xFB,0xD1,0x71,0x25,	/* 3588: qA$q% */
	0x2B,0x2F,0x4F,0x24,0xF6,0xD1,0x77,0x21,	/* 3590: +.O$w! */
	0x8A,0xF1,0x44,0x24,0xF6,0xA7,0x71,0x24,	/* 3598: D$q$ */
	0x20,0x40,0x24,0xFB,0xD1,0x77,0x21,0x8A,	/* 35A0:  @$w! */
	0xF1,0x22,0x40,0x24,0xF6,0xA8,0x71,0x22,	/* 35A8: "@$q" */
	0x20,0x20,0x40,0x24,0xFB,0xD1,0x77,0x21,	/* 35B0:   @$w! */
	0x8A,0xF1,0x28,0x40,0x24,0xF6,0xA8,0x71,	/* 35B8: (@$q */
	0x67,0x20,0x20,0x40,0x24,0xFB,0xD1,0x77,	/* 35C0: g  @$w */
	0x21,0x84,0xF1,0x28,0x40,0x24,0xF6,0xA5,	/* 35C8: !(@$ */
	0x71,0x48,0x24,0xFB,0xD1,0x77,0x21,0x8A,	/* 35D0: qH$w! */
	0xF1,0x24,0x40,0x24,0xF6,0xA5,0x71,0x48,	/* 35D8: $@$qH */
	0x24,0xFB,0xD1,0x73,0x24,0x20,0x40,0x24,	/* 35E0: $s$ @$ */
	0xF6,0xAF,0x71,0x24,0x20,0x40,0x24,0xF6,	/* 35E8: q$ @$ */
	0xC0,0xA7,0x71,0x61,0x2F,0x4F,0x24,0xF6,	/* 35F0: qa.O$ */
	0xD1,0x73,0x42,0x24,0xF6,0xAC,0x71,0x42,	/* 35F8: sB$qB */
	0x24,0xF6,0xC0,0xA6,0x71,0x60,0x4B,0x24,	/* 3600: $q`K$ */
	0xF6,0xD1,0x77,0x23,0x81,0xF1,0x28,0x40,	/* 3608: w#(@ */
	0x24,0xF6,0xA5,0x71,0x48,0x24,0xFB,0xD1,	/* 3610: $qH$ */
	0x71,0x22,0x20,0x20,0x40,0x24,0xF6,0xAD,	/* 3618: q"  @$ */
	0x77,0x76,0x67,0x2D,0x9A,0xD0,0x70,0x77,	/* 3620: wvg-pw */
	0x21,0x88,0x23,0xFB,0x07,0x22,0x44,0x77,	/* 3628: !#."Dw */
	0x21,0x88,0x23,0xFB,0x77,0x8E,0xF1,0xC4,	/* 3630: !#w */
	0xA5,0x77,0x76,0x21,0x94,0x05,0x40,0x77,	/* 3638: wv!.@w */
	0x8E,0x23,0xFB,0x71,0x77,0xE4,0x41,0x76,	/* 3640: #qwAv */
	0x38,0x20,0x21,0x3F,0xE0,0x40,0xB5,0x22,	/* 3648: 8 !?@" */
	0xF0,0x72,0x71,0x67,0x2A,0x99,0x44,0x24,	/* 3650: rqg*D$ */
	0xF6,0xAD,0x40,0x72,0x8E,0x23,0xFB,0x41,	/* 3658: @r#A */
	0x71,0x38,0x20,0x21,0x3F,0xE0,0x05,0x46,	/* 3660: q8 !?.F */
	0x72,0x8E,0x23,0xFB,0x40,0x22,0xF0,0x60,	/* 3668: r#@"` */
	0xBF,0x73,0x31,0xD0,0x73,0x8D,0xF1,0x73,	/* 3670: s1ss */
	0x8C,0xF1,0xF4,0xC0,0xAD,0x70,0x27,0x20,	/* 3678: p'  */
	0x20,0x40,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 3680:  @0.O$ */
	0xC0,0xA4,0x41,0xB1,0x22,0xF0,0x73,0x72,	/* 3688: A"sr */
	0x23,0x9C,0x40,0xB1,0x22,0xF0,0xB1,0x22,	/* 3690: #@"" */
	0xF0,0x60,0xBF,0x73,0x31,0xD0,0x26,0x40,	/* 3698: `s1&@ */
	0x70,0x27,0x20,0x20,0x44,0xF2,0xE0,0x21,	/* 36A0: p'  D! */
	0x42,0x73,0x8E,0x23,0xFB,0x40,0xB1,0x22,	/* 36A8: Bs#@" */
	0xF0,0x60,0xBF,0x73,0x31,0xD0,0x27,0x45,	/* 36B0: `s1'E */
	0x70,0x27,0x20,0x20,0x44,0xF2,0xE0,0x40,	/* 36B8: p'  D@ */
	0x73,0x8E,0x23,0xFB,0x40,0xB1,0x22,0xF0,	/* 36C0: s#@" */
	0x40,0x22,0xF0,0x40,0x22,0xF0,0x60,0xBF,	/* 36C8: @"@"` */
	0x73,0x31,0xD0,0x40,0x73,0x8C,0x23,0xFB,	/* 36D0: s1@s# */
	0x40,0x73,0x8D,0x23,0xFB,0x40,0x73,0x8B,	/* 36D8: @s#@s */
	0x23,0xFB,0x40,0x73,0x8A,0x23,0xFB,0x73,	/* 36E0: #@s#s */
	0x23,0x82,0xF1,0x21,0x40,0x24,0xF6,0xAF,	/* 36E8: #!@$ */
	0x73,0x23,0x82,0xF1,0x61,0x4F,0x24,0xF6,	/* 36F0: s#aO$ */
	0x70,0x27,0x20,0x20,0x40,0xF2,0xE0,0x70,	/* 36F8: p'  @p */
	0x27,0x20,0x20,0x42,0xF2,0x30,0x48,0x24,	/* 3700: '  B0H$ */
	0xF6,0xC0,0xA4,0x40,0xB1,0x22,0xF0,0x73,	/* 3708: @"s */
	0x21,0x87,0xF1,0x41,0x24,0xF6,0xC0,0xA9,	/* 3710: !A$ */
	0x29,0x40,0x70,0x27,0x20,0x20,0x44,0xF2,	/* 3718: )@p'  D */
	0xE0,0x73,0x21,0x87,0xF1,0x42,0x24,0xF6,	/* 3720: s!B$ */
	0xC0,0xA6,0x40,0x73,0x72,0x67,0x20,0x9C,	/* 3728: @srg  */
	0x40,0x73,0xE4,0x23,0x40,0x70,0x27,0x20,	/* 3730: @s#@p'  */
	0x20,0x44,0xF2,0xE0,0x22,0x40,0x70,0x27,	/* 3738:  D"@p' */
	0x20,0x20,0x44,0xF2,0xE0,0x41,0x73,0x21,	/* 3740:   DAs! */
	0x8F,0x23,0xFB,0x21,0x40,0x73,0x8E,0x23,	/* 3748: #!@s# */
	0xFB,0x41,0x72,0x38,0x20,0x21,0x3F,0xE0,	/* 3750: Ar8 !? */
	0x40,0xB1,0x22,0xF0,0x72,0x34,0x46,0x24,	/* 3758: @"r4F$ */
	0xF6,0xC6,0x21,0xA0,0x72,0x34,0x60,0x4B,	/* 3760: !r4`K */
	0x24,0xF6,0x72,0xE4,0x72,0x34,0x24,0x25,	/* 3768: $rr4$% */
	0x40,0x24,0xF6,0xC0,0x40,0x72,0x8E,0x23,	/* 3770: @$@r# */
	0xFB,0x41,0x71,0x38,0x20,0x21,0x3F,0xE0,	/* 3778: Aq8 !? */
	0x40,0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,	/* 3780: @"`s1 */
	0x73,0x8D,0xF1,0x73,0x8C,0x23,0xFB,0x73,	/* 3788: ss#s */
	0x34,0x68,0x2F,0x4F,0x24,0xF6,0x73,0xE4,	/* 3790: 4h.O$s */
	0x73,0x23,0x82,0xF1,0x21,0x40,0x24,0xF6,	/* 3798: s#!@$ */
	0x21,0xAC,0x73,0x72,0x68,0x25,0x98,0x42,	/* 37A0: !srh%B */
	0x24,0xF6,0xC0,0x21,0xA1,0x23,0x40,0x70,	/* 37A8: $!#@p */
	0x27,0x20,0x20,0x44,0xF2,0xE0,0x44,0x70,	/* 37B0: '  DDp */
	0x27,0x20,0x20,0x44,0xF2,0xE0,0x73,0x72,	/* 37B8: '  Dsr */
	0x66,0x9A,0x40,0xB1,0x22,0xF0,0x72,0x8B,	/* 37C0: f@"r */
	0xF1,0x72,0x8A,0x23,0xFB,0x40,0x72,0x8E,	/* 37C8: r#@r */
	0x23,0xFB,0x41,0x71,0x38,0x20,0x21,0x3F,	/* 37D0: #Aq8 !? */
	0xE0,0x40,0x22,0xF0,0x72,0x34,0x42,0x24,	/* 37D8: @"r4B$ */
	0xF6,0xA7,0x72,0x34,0x44,0x24,0xFB,0x72,	/* 37E0: r4D$r */
	0xE4,0x40,0x72,0x8E,0x23,0xFB,0x41,0x71,	/* 37E8: @r#Aq */
	0x38,0x20,0x21,0x3F,0xE0,0x40,0x22,0xF0,	/* 37F0: 8 !?@" */
	0x40,0x72,0x8E,0x23,0xFB,0x40,0x22,0xF0,	/* 37F8: @r#@" */
	0x7A,0xF6,0x20,0x1D,0x00,0x1B,0x00,0x19,	/* 3800: z ..... */
	0x00,0x17,0x00,0x15,0x00,0x13,0x00,0x11,	/* 3808: ........ */
	0x00,0x0F,0x00,0x0D,0x00,0x0B,0x00,0x09,	/* 3810: ........ */
	0x00,0x07,0x00,0x05,0x00,0x03,0x00,0x01,	/* 3818: ........ */
	0x00,0x00,0x00,0x5E,0x04,0x60,0xBF,0x72,	/* 3820: ...^.`r */
	0x29,0x52,0x20,0x20,0xD0,0x70,0x72,0xE8,	/* 3828: )R  pr */
	0x20,0x63,0x43,0x21,0xFB,0x70,0x21,0xEE,	/* 3830:  cC!p! */
	0x65,0x40,0x21,0xFB,0x70,0x21,0xEC,0x67,	/* 3838: e@!p!g */
	0x43,0x21,0xFB,0x70,0x21,0xEA,0x6C,0x49,	/* 3840: C!p!lI */
	0x21,0xFB,0x70,0x21,0xE8,0x6F,0x4B,0x21,	/* 3848: !p!oK! */
	0xFB,0x70,0x21,0xE6,0x61,0x27,0x45,0x21,	/* 3850: p!a'E! */
	0xFB,0x70,0x21,0xE4,0x61,0x26,0x4A,0x21,	/* 3858: p!a&J! */
	0xFB,0x70,0x21,0xE2,0x61,0x25,0x4F,0x21,	/* 3860: p!a%O! */
	0xFB,0x70,0x21,0xE0,0x61,0x24,0x40,0x21,	/* 3868: p!a$@! */
	0xFB,0x70,0xEE,0x61,0x22,0x41,0x21,0xFB,	/* 3870: pa"A! */
	0x70,0xEC,0x62,0x2F,0x40,0x21,0xFB,0x70,	/* 3878: pb.@!p */
	0xEA,0x64,0x2B,0x4B,0x21,0xFB,0x70,0xE8,	/* 3880: d+K!p */
	0x62,0x2C,0x44,0x21,0xFB,0x70,0xE6,0x64,	/* 3888: b,D!pd */
	0x2A,0x4D,0x21,0xFB,0x70,0xE4,0x64,0x2A,	/* 3890: *M!pd* */
	0x46,0x21,0xFB,0x70,0xE2,0x70,0x22,0x55,	/* 3898: F!pp"U */
	0x20,0x20,0x70,0x22,0xE0,0x70,0x22,0x54,	/* 38A0:   p"p"T */
	0x20,0x20,0x70,0x21,0xEF,0x70,0x6A,0x41,	/* 38A8:   p!pjA */
	0x21,0xFB,0x21,0x40,0x21,0x2C,0x2E,0x95,	/* 38B0: !!@!,. */
	0xB1,0x22,0xF0,0x09,0x00,0x00,0x00,0x61,	/* 38B8: "....a */
	0xBB,0x21,0x76,0x39,0x20,0x21,0xD4,0x40,	/* 38C0: !v9 !@ */
	0x21,0xD3,0x40,0x21,0xD0,0x28,0x40,0x21,	/* 38C8: !@!(@! */
	0xD2,0x21,0x72,0xDE,0x40,0x21,0xD1,0x41,	/* 38D0: !r@!A */
	0x44,0x21,0x71,0x24,0xFF,0xF0,0xC0,0x23,	/* 38D8: D!q$# */
	0x27,0xA2,0x21,0x71,0x21,0x20,0x40,0xF8,	/* 38E0: '!q! @ */
	0xD9,0x40,0xDB,0x40,0xDA,0x41,0x44,0x7A,	/* 38E8: @@ADz */
	0x24,0xFF,0xF0,0xC0,0x23,0xA1,0x21,0x71,	/* 38F0: $#!q */
	0x28,0x40,0xF8,0x7A,0x22,0x40,0xF8,0xFA,	/* 38F8: (@z"@ */
	0xD8,0x78,0x27,0x20,0x21,0x4A,0xF2,0x30,	/* 3900: x' !J0 */
	0x2A,0x40,0x24,0xF6,0x2A,0x40,0xF4,0x21,	/* 3908: *@$*@! */
	0xA0,0x41,0x25,0xFA,0x21,0xD0,0xDB,0x21,	/* 3910: A%!! */
	0x73,0xC1,0xAC,0x2F,0x4F,0x21,0xB5,0x22,	/* 3918: s.O!" */
	0xF0,0x7A,0x41,0xF2,0xDA,0x63,0x06,0x7B,	/* 3920: zAc.{ */
	0xC0,0x23,0xAC,0x79,0x27,0x20,0x20,0x42,	/* 3928: #y'  B */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x2F,0x4F,	/* 3930: 0.O$.O */
	0xF4,0xAE,0x41,0x21,0xD3,0x21,0x70,0xC1,	/* 3938: A!!p */
	0x22,0xA5,0x2F,0x4F,0x21,0xB5,0x22,0xF0,	/* 3940: ".O!" */
	0x21,0x70,0xC0,0xAA,0x21,0x73,0xC0,0xA6,	/* 3948: !p!s */
	0x2F,0x4F,0x21,0xB5,0x22,0xF0,0x67,0x21,	/* 3950: .O!"g! */
	0x2E,0x40,0x7C,0xE0,0x21,0x28,0x40,0x7C,	/* 3958: .@|!(@| */
	0x21,0xE7,0x41,0x21,0xB5,0x22,0xF0,0x21,	/* 3960: !A!"! */
	0x71,0x21,0xAD,0x7E,0x82,0xF1,0x21,0x28,	/* 3968: q!~!( */
	0x40,0xF8,0x21,0x72,0x21,0x20,0x40,0xF2,	/* 3970: @!r! @ */
	0xFA,0x21,0xD2,0x21,0x72,0x67,0x20,0x20,	/* 3978: !!rg   */
	0x40,0x24,0xFB,0x7E,0xE0,0x21,0x72,0xDE,	/* 3980: @$~!r */
	0x21,0x71,0x21,0x20,0x40,0xF8,0xD9,0x40,	/* 3988: !q! @@ */
	0x7E,0xE0,0x21,0x71,0x7E,0x83,0x23,0xFB,	/* 3990: ~!q~# */
	0x79,0x7E,0xE3,0x21,0x70,0x2C,0xA0,0x48,	/* 3998: y~!p,H */
	0x7E,0x82,0x23,0xFB,0x40,0x79,0x27,0x20,	/* 39A0: ~#@y'  */
	0x2F,0x4E,0xF2,0xE0,0x40,0x79,0x27,0x20,	/* 39A8: .N@y'  */
	0x2D,0x40,0xF2,0xE0,0x40,0x79,0x27,0x20,	/* 39B0: -@@y'  */
	0x23,0x40,0xF2,0xE0,0x44,0x79,0x27,0x20,	/* 39B8: #@Dy'  */
	0x2F,0x4E,0xF2,0xE0,0x40,0x79,0x27,0x20,	/* 39C0: .N@y'  */
	0x2D,0x40,0xF2,0xE0,0x25,0x45,0x79,0x27,	/* 39C8: -@%Ey' */
	0x20,0x23,0x40,0xF2,0xE0,0x40,0x79,0x27,	/* 39D0:  #@@y' */
	0x20,0x2F,0x4E,0xF2,0xE0,0x79,0x27,0x20,	/* 39D8:  .Ny'  */
	0x23,0x40,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 39E0: #@0.O$ */
	0x25,0xC5,0xA4,0x24,0x48,0x40,0xA3,0x22,	/* 39E8: %$H@" */
	0x48,0x40,0xF4,0x7E,0x88,0x23,0xFB,0x79,	/* 39F0: H@~#y */
	0x27,0x20,0x2F,0x4E,0xF2,0x30,0x2F,0x4F,	/* 39F8: ' .N0.O */
	0x24,0xF6,0x7E,0x21,0x8E,0x23,0xFB,0x79,	/* 3A00: $~!#y */
	0x27,0x20,0x28,0x40,0xF2,0x30,0x2F,0x4F,	/* 3A08: ' (@0.O */
	0x24,0xF6,0x7E,0x21,0x8F,0x23,0xFB,0x44,	/* 3A10: $~!#D */
	0x79,0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x79,	/* 3A18: y' .Ny */
	0x27,0x20,0x28,0x40,0xF2,0x30,0x2F,0x4F,	/* 3A20: ' (@0.O */
	0x24,0xF6,0x7E,0x22,0x80,0x23,0xFB,0x7E,	/* 3A28: $~"#~ */
	0x88,0xF1,0x24,0xC8,0x21,0xA9,0x79,0x27,	/* 3A30: $!y' */
	0x20,0x27,0x42,0xF2,0x30,0x43,0x24,0xF6,	/* 3A38:  'B0C$ */
	0x81,0x7E,0x22,0x81,0x23,0xFB,0x21,0x74,	/* 3A40: ~"#!t */
	0x32,0x41,0xF2,0x21,0x74,0xE2,0x08,0x21,	/* 3A48: 2A!t.! */
	0x74,0x31,0x41,0xF2,0x21,0x74,0xE1,0x79,	/* 3A50: t1A!ty */
	0x21,0x76,0x22,0x20,0x98,0x25,0x05,0x40,	/* 3A58: !v" %.@ */
	0xD8,0x79,0x27,0x20,0x28,0x40,0xF2,0x30,	/* 3A60: y' (@0 */
	0x2F,0x4F,0x24,0xF6,0xD8,0x21,0x74,0x30,	/* 3A68: .O$!t0 */
	0x41,0xF2,0x21,0x74,0xE0,0x78,0x41,0x24,	/* 3A70: A!txA$ */
	0xF6,0x21,0xA5,0x78,0x2A,0xCB,0xA3,0x4A,	/* 3A78: !x*J */
	0x40,0xA2,0x44,0x40,0xF4,0x7E,0x88,0x23,	/* 3A80: @D@~# */
	0xFB,0x44,0x7E,0x82,0x23,0xFB,0x21,0x03,	/* 3A88: D~#!. */
	0x78,0x2A,0xCA,0xA3,0x4B,0x40,0xA2,0x48,	/* 3A90: x*K@H */
	0x40,0xF4,0x7E,0x88,0x23,0xFB,0x48,0x7E,	/* 3A98: @~#H~ */
	0x82,0x23,0xFB,0x2F,0x4F,0x79,0x6F,0x40,	/* 3AA0: #.Oyo@ */
	0x24,0xF6,0x28,0x40,0x24,0xFB,0x27,0x20,	/* 3AA8: $(@$'  */
	0x20,0x40,0xF2,0xE0,0x21,0x72,0x21,0x20,	/* 3AB0:  @!r!  */
	0x40,0xF2,0xDF,0x21,0x71,0x21,0xA0,0x7F,	/* 3AB8: @!q! */
	0x26,0x40,0xF2,0x67,0x20,0x20,0x40,0x24,	/* 3AC0: &@g  @$ */
	0xFB,0x7C,0xE0,0x7F,0x7C,0x21,0xE7,0x40,	/* 3AC8: ||!@ */
	0xDD,0x41,0x7E,0x82,0xF1,0x7D,0x24,0xFF,	/* 3AD0: A~}$ */
	0xF0,0xC0,0x21,0x26,0xAE,0x7F,0xDC,0x7F,	/* 3AD8: !& */
	0x7D,0x7E,0x55,0xFA,0xE0,0x7E,0x88,0xF1,	/* 3AE0: }~U~ */
	0x7C,0x86,0x23,0xFB,0x21,0x40,0x7C,0x8E,	/* 3AE8: |#!@| */
	0x23,0xFB,0x41,0x7C,0x21,0x8F,0x23,0xFB,	/* 3AF0: #A|!# */
	0x7D,0x7C,0x87,0x23,0xFB,0x2F,0x4F,0x7C,	/* 3AF8: }|#.O| */
	0x22,0x82,0x23,0xFB,0x40,0x7C,0x24,0x85,	/* 3B00: "#@|$ */
	0x23,0xFB,0x21,0x70,0x26,0xAD,0x40,0xD0,	/* 3B08: #!p&@ */
	0x40,0xD0,0x21,0x25,0x42,0x21,0xFB,0x11,	/* 3B10: @!%B!. */
	0x21,0x40,0x24,0xFA,0x79,0x7C,0xE1,0x41,	/* 3B18: !@$y|A */
	0x7D,0x43,0x24,0xFF,0xF0,0xC0,0x21,0xA0,	/* 3B20: }C$! */
	0x79,0x27,0x20,0x2F,0x4E,0xF2,0x30,0x2F,	/* 3B28: y' .N0. */
	0x4F,0x24,0xF6,0x44,0x24,0xF0,0x40,0xAB,	/* 3B30: O$D$@ */
	0x79,0x27,0x20,0x2F,0x4E,0xF2,0x30,0x4F,	/* 3B38: y' .N0O */
	0x24,0xF6,0x40,0xF4,0x2F,0x4F,0x24,0xF6,	/* 3B40: $@.O$ */
	0xD0,0x70,0x7C,0x22,0x84,0x23,0xFB,0x11,	/* 3B48: p|"#. */
	0x70,0xF5,0xF1,0x7C,0x22,0x86,0x23,0xFB,	/* 3B50: p|"# */
	0x70,0x47,0x24,0xF6,0xC5,0xAF,0x7D,0x40,	/* 3B58: pG$}@ */
	0xF4,0xA5,0x7D,0x44,0xF4,0xC0,0xA6,0x41,	/* 3B60: }DA */
	0x7C,0x22,0x87,0x23,0xFB,0x4B,0x7C,0x23,	/* 3B68: |"#K|# */
	0x86,0x23,0xFB,0x4B,0x7C,0x23,0x87,0x23,	/* 3B70: #K|## */
	0xFB,0x2A,0x09,0x2E,0x4A,0x21,0xFB,0x58,	/* 3B78: *..J!X */
	0x15,0x48,0x24,0xFA,0x7E,0x88,0xF1,0x48,	/* 3B80: .H$~H */
	0xF4,0xA8,0x7E,0x88,0xF1,0x4B,0xF4,0xC0,	/* 3B88: ~K */
	0x21,0xA5,0x7D,0x23,0xF4,0x23,0xF4,0x23,	/* 3B90: !}### */
	0xF4,0x79,0xFA,0x7C,0xE1,0x41,0x7D,0x24,	/* 3B98: y|A}$ */
	0xF1,0x7C,0x8F,0x23,0xFB,0x21,0x09,0x7D,	/* 3BA0: |#!.} */
	0x15,0xFA,0x30,0x23,0xF4,0x23,0xF4,0x23,	/* 3BA8: .0### */
	0xF4,0x79,0xFA,0x7C,0xE1,0x41,0x7D,0x15,	/* 3BB0: y|A}. */
	0xFA,0x30,0x24,0xF1,0x7C,0x8F,0x23,0xFB,	/* 3BB8: 0$|# */
	0x7D,0x41,0x24,0xF6,0xC0,0xAE,0x7E,0x88,	/* 3BC0: }A$~ */
	0xF1,0x44,0xF4,0xA8,0x7E,0x88,0xF1,0x4A,	/* 3BC8: D~J */
	0xF4,0xC0,0x25,0xA0,0x7C,0x31,0xD3,0x2E,	/* 3BD0: %|1. */
	0x40,0x73,0x61,0x4F,0x24,0xF6,0x27,0x20,	/* 3BD8: @saO$'  */
	0x20,0x48,0xF2,0xE0,0x40,0x73,0x61,0x4F,	/* 3BE0:  H@saO */
	0x24,0xF6,0x27,0x20,0x20,0x4A,0xF2,0xE0,	/* 3BE8: $'  J */
	0x40,0x73,0x61,0x4F,0x24,0xF6,0x27,0x20,	/* 3BF0: @saO$'  */
	0x20,0x4C,0xF2,0xE0,0x42,0x73,0x61,0x4F,	/* 3BF8:  LBsaO */
	0x24,0xF6,0x27,0x20,0x20,0x4E,0xF2,0xE0,	/* 3C00: $'  N */
	0x73,0x61,0x4F,0x24,0xF6,0x27,0x20,0x21,	/* 3C08: saO$' ! */
	0x4C,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xD4,	/* 3C10: L0.O$ */
	0x40,0x73,0x61,0x4F,0x24,0xF6,0x27,0x20,	/* 3C18: @saO$'  */
	0x21,0x4A,0xF2,0xE0,0x21,0x72,0x67,0x20,	/* 3C20: !J!rg  */
	0x20,0x40,0x24,0xFB,0x7C,0xE2,0x7F,0x23,	/* 3C28:  @$|# */
	0x20,0x40,0xF2,0xDF,0x7F,0x26,0x40,0xF2,	/* 3C30:  @&@ */
	0x67,0x20,0x20,0x40,0x24,0xFB,0x7C,0xE0,	/* 3C38: g  @$| */
	0x7F,0x7C,0x21,0xE7,0x7D,0x41,0xF2,0xDD,	/* 3C40: |!}A */
	0x61,0x28,0x06,0x21,0x71,0x41,0xF2,0x21,	/* 3C48: a(.!qA! */
	0xD1,0x63,0x28,0x03,0x67,0x21,0x2E,0x40,	/* 3C50: c(.g!.@ */
	0x7C,0xE0,0x21,0x28,0x40,0x7C,0x21,0xE7,	/* 3C58: |!(@|! */
	0x41,0x21,0xB5,0x22,0xF0,0x63,0x2E,0x20,	/* 3C60: A!"c.  */
	0x03,0xF0,0xD0,0x00,0xF0,0x00,0xC0,0x00,	/* 3C68: .... */
	0x00,0xF0,0xD0,0xF0,0xF0,0x00,0xC0,0x00,	/* 3C70: ... */
	0x00,0x00,0x00,0x03,0x00,0x04,0x00,0x07,	/* 3C78: ........ */
	0x00,0xAC,0x00,0x60,0xBF,0x72,0x2B,0x53,	/* 3C80: ..`r+S */
	0x20,0x20,0xD0,0x70,0x72,0xE9,0x20,0xB1,	/* 3C88:   pr  */
	0x22,0xF0,0x20,0x0A,0x00,0x00,0x00,0x60,	/* 3C90: " ....` */
	0xBC,0x75,0x3A,0x20,0xD3,0x73,0x32,0x30,	/* 3C98: u: s20 */
	0x35,0x41,0xF2,0x73,0x32,0x30,0xE5,0x21,	/* 3CA0: 5As20! */
	0x28,0x40,0xD2,0x72,0x86,0xF1,0x2F,0x40,	/* 3CA8: (@r.@ */
	0x24,0xF6,0xC0,0x24,0xAB,0x0C,0x72,0x21,	/* 3CB0: $$.r! */
	0x37,0x25,0xFA,0xD2,0x21,0x28,0x40,0xF4,	/* 3CB8: 7%!(@ */
	0x23,0xAE,0x72,0x8E,0xF1,0xC0,0x61,0xAE,	/* 3CC0: #ra */
	0x72,0x34,0x22,0x20,0x20,0x40,0x24,0xF6,	/* 3CC8: r4"  @$ */
	0x61,0xA4,0x40,0xD1,0x40,0xD0,0x72,0x21,	/* 3CD0: a@@r! */
	0x88,0xF1,0xD1,0x72,0x75,0x24,0x9A,0x2F,	/* 3CD8: ru$. */
	0x4F,0x24,0xF6,0xD0,0x70,0x71,0xF4,0x21,	/* 3CE0: O$pq! */
	0xA5,0x70,0x72,0x21,0x88,0x23,0xFB,0x72,	/* 3CE8: pr!#r */
	0x21,0x89,0xF1,0x42,0x24,0xFB,0x72,0x21,	/* 3CF0: !B$r! */
	0x89,0x23,0xFB,0x41,0x73,0xE0,0x64,0x06,	/* 3CF8: #Asd. */
	0x73,0x30,0x73,0x31,0x24,0xFB,0x21,0xAE,	/* 3D00: s0s1$! */
	0x41,0x73,0x32,0x30,0xE4,0x73,0x30,0x27,	/* 3D08: As20s0' */
	0x2C,0x28,0x40,0xE0,0x73,0x32,0x30,0x8C,	/* 3D10: ,(@s20 */
	0xF1,0x81,0x73,0x32,0x30,0x8C,0x23,0xFB,	/* 3D18: s20# */
	0x40,0x73,0xE0,0x40,0x73,0xE1,0xB4,0x22,	/* 3D20: @s@s" */
	0xF0,0x6E,0x2D,0x03,0x20,0x80,0x0F,0x60,	/* 3D28: n-. .` */
	0xBF,0x72,0x2B,0x56,0x20,0x20,0xD0,0x70,	/* 3D30: r+V  p */
	0x72,0xEA,0x20,0x70,0x68,0x5A,0x20,0x20,	/* 3D38: r phZ   */
	0x70,0xE2,0xB1,0x22,0xF0,0x0B,0x00,0x00,	/* 3D40: p"... */
	0x00,0x61,0xB9,0x21,0x78,0x3B,0x20,0x21,	/* 3D48: .a!x; ! */
	0xD6,0x28,0x40,0xDE,0x40,0xDF,0x21,0x76,	/* 3D50: (@@!v */
	0x30,0x30,0x86,0xF1,0x81,0x21,0x76,0x30,	/* 3D58: 00!v0 */
	0x30,0x86,0x23,0xFB,0x7E,0x21,0xD5,0x7F,	/* 3D60: 0#~! */
	0x21,0xD4,0x21,0x03,0x21,0x72,0xC0,0x2D,	/* 3D68: !!.!r- */
	0x24,0xA3,0x7E,0x21,0x75,0xF4,0xC0,0xA7,	/* 3D70: $~!u */
	0x7F,0x21,0x74,0xF4,0x2D,0x23,0xA6,0x7E,	/* 3D78: !t-#~ */
	0x33,0xDC,0x7F,0x23,0xF4,0x23,0xF4,0x7C,	/* 3D80: 3##| */
	0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x7C,0x27,	/* 3D88: ' .N|' */
	0x20,0x2C,0x4E,0xF2,0x30,0x2F,0x4F,0x24,	/* 3D90:  ,N0.O$ */
	0xF6,0x21,0xD2,0x21,0x72,0x41,0x24,0xF6,	/* 3D98: !!rA$ */
	0x27,0x20,0xA1,0x7C,0x27,0x20,0x2D,0x46,	/* 3DA0: ' |' -F */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xDD,0x7C,	/* 3DA8: 0.O$| */
	0x27,0x20,0x2D,0x40,0xF2,0x30,0x2F,0x4F,	/* 3DB0: ' -@0.O */
	0x24,0xF6,0x21,0xD1,0x7D,0x43,0x24,0xF6,	/* 3DB8: $!}C$ */
	0x7C,0x27,0x20,0x2D,0x40,0xF2,0xE0,0x7C,	/* 3DC0: |' -@| */
	0x27,0x20,0x28,0x46,0xF2,0x30,0x47,0x24,	/* 3DC8: ' (F0G$ */
	0xF6,0x21,0xD3,0x21,0x73,0xC3,0xC0,0xAA,	/* 3DD0: !!s */
	0x21,0x73,0xC7,0xC0,0x25,0x25,0xA1,0x26,	/* 3DD8: !s%%& */
	0x2C,0x02,0x7F,0x7D,0x43,0x24,0xF6,0x28,	/* 3DE0: ,.}C$( */
	0xF1,0x7E,0x55,0xFA,0x30,0xD4,0x74,0x22,	/* 3DE8: ~U0t" */
	0x87,0xF1,0xC0,0xAC,0x74,0x22,0x88,0xF1,	/* 3DF0: t" */
	0x41,0x24,0xFB,0x74,0x22,0x88,0x23,0xFB,	/* 3DF8: A$t"# */
	0x74,0x8A,0xF1,0xD5,0x74,0x8B,0xF1,0xD9,	/* 3E00: tt */
	0x74,0x34,0xD6,0x79,0x75,0x41,0xF2,0xF4,	/* 3E08: t4yuA */
	0x2F,0x4F,0x24,0xF6,0xD8,0x41,0x21,0x76,	/* 3E10: .O$A!v */
	0x31,0xE0,0x41,0x7C,0x27,0x20,0x21,0x4C,	/* 3E18: 1A|' !L */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0x25,0xFA,	/* 3E20: 0.O$% */
	0xD7,0x78,0xF0,0x24,0xFF,0xF0,0xC0,0xA3,	/* 3E28: x$ */
	0x77,0xDB,0x02,0x78,0xDB,0x7B,0x24,0x22,	/* 3E30: w.x{$" */
	0xA9,0x77,0x7B,0xF4,0xD7,0x41,0x41,0x7B,	/* 3E38: w{AA{ */
	0x24,0xFF,0xF0,0x24,0x21,0xA7,0x41,0x7B,	/* 3E40: $$!A{ */
	0x22,0x40,0x24,0xFF,0xF0,0x24,0x20,0xAD,	/* 3E48: "@$$  */
	0x7B,0x60,0x4F,0xF2,0x23,0xF4,0x23,0xF4,	/* 3E50: {`O## */
	0x42,0x21,0xFB,0xF2,0xF6,0x23,0x2E,0x01,	/* 3E58: B!#.. */
	0x20,0x23,0x2C,0x01,0x20,0x23,0x2A,0x01,	/* 3E60:  #,. #*. */
	0x20,0x23,0x28,0x01,0x20,0x23,0x26,0x01,	/* 3E68:  #(. #&. */
	0x20,0x23,0x24,0x01,0x20,0x23,0x22,0x01,	/* 3E70:  #$. #". */
	0x20,0x23,0x20,0x01,0x20,0x22,0x2E,0x01,	/* 3E78:  # . ".. */
	0x20,0x22,0x2C,0x01,0x20,0x22,0x2A,0x01,	/* 3E80:  ",. "*. */
	0x20,0x22,0x28,0x01,0x20,0x22,0x26,0x01,	/* 3E88:  "(. "&. */
	0x20,0x22,0x24,0x01,0x20,0x22,0x22,0x01,	/* 3E90:  "$. "". */
	0x20,0x22,0x20,0x01,0x20,0x21,0x2E,0x01,	/* 3E98:  " . !.. */
	0x20,0x21,0x2C,0x01,0x20,0x21,0x2A,0x01,	/* 3EA0:  !,. !*. */
	0x20,0x21,0x28,0x01,0x20,0x21,0x26,0x01,	/* 3EA8:  !(. !&. */
	0x20,0x21,0x24,0x01,0x20,0x21,0x22,0x01,	/* 3EB0:  !$. !". */
	0x20,0x21,0x20,0x01,0x20,0x2E,0x02,0x20,	/* 3EB8:  ! . ..  */
	0x20,0x2C,0x02,0x20,0x20,0x2A,0x02,0x20,	/* 3EC0:  ,.  *.  */
	0x20,0x28,0x02,0x20,0x20,0x26,0x02,0x20,	/* 3EC8:  (.  &.  */
	0x20,0x24,0x02,0x20,0x20,0x22,0x02,0x20,	/* 3ED0:  $.  ".  */
	0x20,0x03,0x20,0x20,0x20,0x75,0x25,0xFA,	/* 3ED8:  .   u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 3EE0: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 3EE8: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 3EF0: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 3EF8: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 3F00: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 3F08: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 3F10: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 3F18: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 3F20: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 3F28: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 3F30: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 3F38: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 3F40: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 3F48: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 3F50: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 3F58: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 3F60: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 3F68: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 3F70: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 3F78: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 3F80: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 3F88: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 3F90: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 3F98: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 3FA0: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 3FA8: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 3FB0: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 3FB8: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 3FC0: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 3FC8: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 3FD0: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 3FD8: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 3FE0: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 3FE8: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 3FF0: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 3FF8: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 4000: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4008: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4010: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 4018: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4020: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 4028: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 4030: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 4038: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4040: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4048: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 4050: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4058: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 4060: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 4068: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 4070: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4078: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4080: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 4088: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4090: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 4098: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 40A0: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 40A8: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 40B0: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 40B8: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 40C0: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 40C8: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 40D0: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 40D8: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 40E0: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 40E8: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 40F0: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 40F8: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4100: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 4108: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 4110: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 4118: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4120: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4128: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 4130: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4138: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 4140: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 4148: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 4150: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4158: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4160: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 4168: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4170: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 4178: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 4180: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 4188: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4190: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4198: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 41A0: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 41A8: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 41B0: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 41B8: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 41C0: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 41C8: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 41D0: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 41D8: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 41E0: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 41E8: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 41F0: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 41F8: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4200: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4208: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 4210: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4218: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x25,0xFA,	/* 4220: $#u% */
	0x41,0xF2,0xD5,0x2F,0x4F,0x24,0xF6,0x74,	/* 4228: A.O$t */
	0x2B,0x50,0xF2,0x7C,0x27,0x20,0x2C,0x44,	/* 4230: +P|' ,D */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xF0,0x23,	/* 4238: 0.O$# */
	0xFB,0x75,0x25,0xFA,0x41,0xF2,0xD5,0x2F,	/* 4240: u%A. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x7C,	/* 4248: O$t+P| */
	0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,0x4F,	/* 4250: ' ,D0.O */
	0x24,0xF6,0xF0,0x23,0xFB,0x75,0x74,0x8A,	/* 4258: $#ut */
	0x23,0xFB,0x74,0x21,0x3F,0x77,0xF2,0x74,	/* 4260: #t!?wt */
	0x21,0xEF,0x77,0x25,0xFA,0x60,0x4F,0xF2,	/* 4268: !w%`O */
	0xD7,0xAF,0x7C,0x27,0x20,0x2C,0x44,0xF2,	/* 4270: |' ,D */
	0x30,0x2F,0x4F,0x24,0xF6,0x21,0xD0,0x61,	/* 4278: 0.O$!a */
	0x09,0x79,0x75,0x41,0xF2,0xF4,0x2F,0x4F,	/* 4280: .yuA.O */
	0x24,0xF6,0xDA,0x76,0x48,0x24,0xF6,0x28,	/* 4288: $vH$( */
	0xA4,0x41,0x78,0x23,0x4F,0x24,0xFF,0xF0,	/* 4290: Ax#O$ */
	0xC0,0x27,0xAA,0x41,0x24,0x40,0x7A,0x24,	/* 4298: 'A$@z$ */
	0xFF,0xF0,0xC0,0x27,0xA0,0x76,0x21,0x40,	/* 42A0: 'v!@ */
	0x24,0xFB,0xD6,0x74,0x23,0x80,0xF1,0x48,	/* 42A8: $t#H */
	0x24,0xF6,0x23,0xA7,0x76,0x22,0x40,0x24,	/* 42B0: $#v"@$ */
	0xF6,0xC0,0x22,0xAF,0x7C,0x27,0x20,0x20,	/* 42B8: "|'   */
	0x4A,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xC0,	/* 42C0: J0.O$ */
	0x21,0xAB,0x40,0xD0,0x21,0x20,0x40,0x74,	/* 42C8: !@! @t */
	0x21,0x78,0x29,0x2C,0x9F,0x22,0x42,0x7C,	/* 42D0: !x),"B| */
	0x27,0x20,0x20,0x4A,0xF2,0xE0,0x76,0x22,	/* 42D8: '  Jv" */
	0x40,0x24,0xFB,0xD6,0x06,0x76,0x2C,0x40,	/* 42E0: @$.v,@ */
	0x24,0xFB,0xD6,0x74,0x23,0x81,0xF1,0x28,	/* 42E8: $t#( */
	0x40,0x24,0xF6,0xAC,0x40,0xD0,0x21,0x20,	/* 42F0: @$@!  */
	0x20,0x40,0x74,0x21,0x78,0x29,0x2A,0x94,	/* 42F8:  @t!x)* */
	0x74,0x23,0x80,0xF1,0x24,0x40,0x24,0xF6,	/* 4300: t#$@$ */
	0xAC,0x40,0xD0,0x22,0x20,0x20,0x40,0x74,	/* 4308: @"  @t */
	0x21,0x78,0x29,0x28,0x9F,0x7D,0x23,0x4F,	/* 4310: !x)(}#O */
	0x24,0xF6,0x7C,0x27,0x20,0x2D,0x46,0xF2,	/* 4318: $|' -F */
	0xE0,0x21,0x71,0x7C,0x27,0x20,0x2D,0x40,	/* 4320: !q|' -@ */
	0xF2,0xE0,0x76,0x74,0xE4,0x21,0x27,0x04,	/* 4328: vt!'. */
	0x40,0xD3,0x40,0xD2,0x40,0xD1,0x40,0xD2,	/* 4330: @@@@ */
	0x7F,0x7D,0x43,0x24,0xF6,0x28,0xF1,0x7E,	/* 4338: }C$(~ */
	0x55,0xFA,0x30,0xD4,0x7C,0x27,0x20,0x2C,	/* 4340: U0|' , */
	0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xD1,	/* 4348: D0.O$ */
	0x7C,0x27,0x20,0x2C,0x44,0xF2,0x30,0x2F,	/* 4350: |' ,D0. */
	0x4F,0x24,0xF6,0xD3,0x71,0x48,0x24,0xF6,	/* 4358: O$qH$ */
	0x21,0xA1,0x74,0x21,0x89,0xF1,0x41,0x24,	/* 4360: !t!A$ */
	0xFB,0x74,0x21,0x89,0x23,0xFB,0x41,0x21,	/* 4368: t!#A! */
	0x76,0x32,0xE0,0x71,0x47,0x24,0xF6,0xAE,	/* 4370: v2qG$ */
	0x74,0x22,0x80,0xF1,0x28,0x40,0x24,0xF6,	/* 4378: t"(@$ */
	0xA5,0x41,0x21,0x76,0x32,0xE0,0x71,0x41,	/* 4380: A!v2qA */
	0x24,0xF6,0xA8,0x74,0x21,0x3E,0x41,0xF2,	/* 4388: $t!>A */
	0x74,0x21,0xEE,0x71,0x42,0x24,0xF6,0xAA,	/* 4390: t!qB$ */
	0x74,0x21,0x3C,0x41,0xF2,0x74,0x21,0xEC,	/* 4398: t!<At! */
	0x41,0xD2,0x71,0x44,0x24,0xF6,0xAA,0x74,	/* 43A0: AqD$t */
	0x21,0x3D,0x41,0xF2,0x74,0x21,0xED,0x41,	/* 43A8: !=At!A */
	0xD2,0x72,0x2D,0xAB,0x74,0x22,0x80,0xF1,	/* 43B0: r-t" */
	0x24,0x40,0x24,0xF6,0xA5,0x74,0x22,0x8B,	/* 43B8: $@$t" */
	0xF1,0xD3,0x74,0x8A,0xF1,0xD5,0x74,0x8B,	/* 43C0: tt */
	0xF1,0xD9,0x74,0x34,0xD6,0x79,0x75,0x41,	/* 43C8: t4yuA */
	0xF2,0xF4,0x2F,0x4F,0x24,0xF6,0xD8,0x78,	/* 43D0: .O$x */
	0x2A,0xAD,0x75,0x25,0xFA,0x41,0xF2,0xD5,	/* 43D8: *u%A */
	0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,	/* 43E0: .O$t+P */
	0x73,0xF0,0x23,0xFB,0x75,0x74,0x8A,0x23,	/* 43E8: s#ut# */
	0xFB,0x79,0x75,0x41,0xF2,0xF4,0x2F,0x4F,	/* 43F0: yuA.O */
	0x24,0xF6,0xDA,0x76,0x48,0x24,0xF6,0x28,	/* 43F8: $vH$( */
	0xAE,0x41,0x78,0x23,0x4F,0x24,0xFF,0xF0,	/* 4400: Ax#O$ */
	0xC0,0x28,0xA4,0x41,0x24,0x40,0x7A,0x24,	/* 4408: (A$@z$ */
	0xFF,0xF0,0xC0,0x27,0xAA,0x76,0x21,0x40,	/* 4410: 'v!@ */
	0x24,0xFB,0xD6,0x74,0x23,0x80,0xF1,0x48,	/* 4418: $t#H */
	0x24,0xF6,0x23,0xA7,0x76,0x22,0x40,0x24,	/* 4420: $#v"@$ */
	0xF6,0xC0,0x22,0xAF,0x7C,0x27,0x20,0x20,	/* 4428: "|'   */
	0x4A,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xC0,	/* 4430: J0.O$ */
	0x21,0xAB,0x40,0xD0,0x21,0x20,0x40,0x74,	/* 4438: !@! @t */
	0x21,0x78,0x28,0x25,0x9F,0x22,0x42,0x7C,	/* 4440: !x(%"B| */
	0x27,0x20,0x20,0x4A,0xF2,0xE0,0x76,0x22,	/* 4448: '  Jv" */
	0x40,0x24,0xFB,0xD6,0x06,0x76,0x2C,0x40,	/* 4450: @$.v,@ */
	0x24,0xFB,0xD6,0x74,0x23,0x81,0xF1,0x28,	/* 4458: $t#( */
	0x40,0x24,0xF6,0xAC,0x40,0xD0,0x21,0x20,	/* 4460: @$@!  */
	0x20,0x40,0x74,0x21,0x78,0x28,0x23,0x94,	/* 4468:  @t!x(# */
	0x74,0x23,0x80,0xF1,0x24,0x40,0x24,0xF6,	/* 4470: t#$@$ */
	0x21,0xA5,0x40,0xD0,0x22,0x20,0x20,0x40,	/* 4478: !@"  @ */
	0x74,0x21,0x78,0x28,0x21,0x9E,0x08,0x74,	/* 4480: t!x(!.t */
	0x21,0x3F,0x77,0xF2,0x74,0x21,0xEF,0x7D,	/* 4488: !?wt!} */
	0x23,0x4F,0x24,0xF6,0x7C,0x27,0x20,0x2D,	/* 4490: #O$|' - */
	0x46,0xF2,0xE0,0x21,0x71,0x7C,0x27,0x20,	/* 4498: F!q|'  */
	0x2D,0x40,0xF2,0xE0,0x21,0x72,0x42,0x24,	/* 44A0: -@!rB$ */
	0xF6,0x25,0x25,0xAE,0x7C,0x27,0x20,0x2D,	/* 44A8: %%|' - */
	0x44,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xDD,	/* 44B0: D0.O$ */
	0x7C,0x27,0x20,0x2D,0x40,0xF2,0x30,0x2F,	/* 44B8: |' -@0. */
	0x4F,0x24,0xF6,0x21,0xD1,0x7D,0x43,0x24,	/* 44C0: O$!}C$ */
	0xF6,0x7C,0x27,0x20,0x2D,0x40,0xF2,0xE0,	/* 44C8: |' -@ */
	0x7F,0x7D,0x43,0x24,0xF6,0x28,0xF1,0x7E,	/* 44D0: }C$(~ */
	0x55,0xFA,0x30,0xD5,0x75,0x22,0x87,0xF1,	/* 44D8: U0u" */
	0xC0,0xAC,0x75,0x22,0x88,0xF1,0x42,0x24,	/* 44E0: u"B$ */
	0xFB,0x75,0x22,0x88,0x23,0xFB,0x75,0x23,	/* 44E8: u"#u# */
	0x85,0xF1,0xAC,0x75,0x21,0x78,0x25,0x2C,	/* 44F0: u!x%, */
	0x90,0x75,0x34,0xD8,0x24,0x2F,0x03,0x75,	/* 44F8: u4$..u */
	0x8D,0xF1,0xDB,0x75,0x8C,0xF1,0xD4,0x75,	/* 4500: uu */
	0x34,0xD8,0x78,0x21,0x20,0x40,0x24,0xF6,	/* 4508: 4x! @$ */
	0x22,0xA6,0x78,0x61,0x2F,0x4F,0x24,0xF6,	/* 4510: "xa.O$ */
	0xD8,0x78,0x22,0x20,0x40,0x24,0xFB,0xD8,	/* 4518: x" @$ */
	0x78,0x60,0x4E,0x24,0xF6,0xD8,0x7C,0x27,	/* 4520: x`N$|' */
	0x20,0x20,0x4C,0xF2,0x30,0x2F,0x49,0x24,	/* 4528:   L0.I$ */
	0xF6,0x7C,0x27,0x20,0x20,0x4C,0xF2,0xE0,	/* 4530: |'  L */
	0x7B,0x74,0xF4,0x2F,0x4F,0x24,0xF6,0x25,	/* 4538: {t.O$% */
	0xFA,0xD9,0x24,0x24,0xAB,0x75,0x86,0xF1,	/* 4540: $$u */
	0x24,0xC8,0xA4,0x22,0x40,0x40,0xA2,0x4C,	/* 4548: $"@@L */
	0x40,0xF4,0xD6,0x41,0x79,0x76,0x24,0xFF,	/* 4550: @Ayv$ */
	0xF0,0xC0,0xA3,0x76,0xD7,0x02,0x79,0xD7,	/* 4558: v.y */
	0x77,0x75,0x24,0x84,0x23,0xFB,0x78,0x24,	/* 4560: wu$#x$ */
	0x20,0x40,0x24,0xF6,0x25,0xAE,0x77,0x23,	/* 4568:  @$%w# */
	0x2B,0xAA,0x74,0x2F,0x4F,0x24,0xF6,0x75,	/* 4570: +t.O$u */
	0x23,0x50,0xF2,0xF1,0xCA,0x22,0xAB,0x41,	/* 4578: #P"A */
	0x42,0x76,0x24,0xFF,0xF0,0xC0,0xA3,0x23,	/* 4580: Bv$# */
	0x2A,0x02,0x4D,0x7C,0x27,0x20,0x2C,0x46,	/* 4588: *.M|' ,F */
	0xF2,0xE0,0x4A,0x7C,0x27,0x20,0x2C,0x46,	/* 4590: J|' ,F */
	0xF2,0xE0,0x74,0x41,0xF2,0xD4,0x77,0x60,	/* 4598: tAw` */
	0x4F,0xF2,0xD7,0x76,0x60,0x4E,0xF2,0xD6,	/* 45A0: Ov`N */
	0x63,0x04,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 45A8: c.t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 45B0: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 45B8: |' ,F */
	0x77,0x60,0x4F,0xF2,0xD7,0x76,0x60,0x4F,	/* 45C0: w`Ov`O */
	0xF2,0xD6,0x65,0x02,0x41,0x41,0x77,0x24,	/* 45C8: e.AAw$ */
	0xFF,0xF0,0x23,0x25,0xA7,0x41,0x77,0x22,	/* 45D0: #%Aw" */
	0x40,0x24,0xFF,0xF0,0x23,0x24,0xAD,0x77,	/* 45D8: @$#$w */
	0x60,0x4F,0xF2,0x23,0xF4,0x23,0xF4,0x42,	/* 45E0: `O##B */
	0x21,0xFB,0xF2,0xF6,0x23,0x22,0x07,0x20,	/* 45E8: !#".  */
	0x23,0x20,0x0D,0x20,0x22,0x2F,0x03,0x20,	/* 45F0: # . "..  */
	0x22,0x2D,0x09,0x20,0x22,0x2B,0x0F,0x20,	/* 45F8: "-. "+.  */
	0x22,0x2A,0x05,0x20,0x22,0x28,0x0B,0x20,	/* 4600: "*. "(.  */
	0x22,0x27,0x01,0x20,0x22,0x25,0x07,0x20,	/* 4608: "'. "%.  */
	0x22,0x23,0x0D,0x20,0x22,0x22,0x03,0x20,	/* 4610: "#. "".  */
	0x22,0x20,0x09,0x20,0x21,0x2E,0x0F,0x20,	/* 4618: " . !..  */
	0x21,0x2D,0x05,0x20,0x21,0x2B,0x0B,0x20,	/* 4620: !-. !+.  */
	0x21,0x2A,0x01,0x20,0x21,0x28,0x07,0x20,	/* 4628: !*. !(.  */
	0x21,0x26,0x0D,0x20,0x21,0x25,0x03,0x20,	/* 4630: !&. !%.  */
	0x21,0x23,0x09,0x20,0x21,0x21,0x0F,0x20,	/* 4638: !#. !!.  */
	0x21,0x20,0x05,0x20,0x2E,0x0C,0x20,0x20,	/* 4640: ! . ..   */
	0x2D,0x02,0x20,0x20,0x2B,0x08,0x20,0x20,	/* 4648: -.  +.   */
	0x29,0x0E,0x20,0x20,0x28,0x04,0x20,0x20,	/* 4650: ).  (.   */
	0x26,0x0A,0x20,0x20,0x25,0x00,0x20,0x20,	/* 4658: &.  %.   */
	0x23,0x06,0x20,0x20,0x21,0x0C,0x20,0x20,	/* 4660: #.  !.   */
	0x03,0x20,0x20,0x20,0x74,0x25,0xFA,0x41,	/* 4668: .   t%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 4670: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 4678: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 4680: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 4688: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 4690: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 4698: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 46A0: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 46A8: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 46B0: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 46B8: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x25,0xFA,0x41,	/* 46C0: ,Ft%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 46C8: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 46D0: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 46D8: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 46E0: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 46E8: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 46F0: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 46F8: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 4700: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 4708: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 4710: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x25,0xFA,0x41,	/* 4718: ,Ft%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 4720: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 4728: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 4730: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 4738: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 4740: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 4748: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 4750: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 4758: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 4760: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 4768: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x25,0xFA,0x41,	/* 4770: ,Ft%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 4778: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 4780: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 4788: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 4790: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 4798: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 47A0: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 47A8: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 47B0: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 47B8: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 47C0: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x25,0xFA,0x41,	/* 47C8: ,Ft%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 47D0: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 47D8: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 47E0: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 47E8: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 47F0: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 47F8: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 4800: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 4808: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 4810: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 4818: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x25,0xFA,0x41,	/* 4820: ,Ft%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 4828: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 4830: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 4838: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 4840: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 4848: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 4850: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 4858: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 4860: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 4868: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 4870: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x25,0xFA,0x41,	/* 4878: ,Ft%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 4880: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 4888: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 4890: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 4898: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 48A0: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 48A8: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 48B0: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 48B8: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 48C0: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 48C8: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x25,0xFA,0x41,	/* 48D0: ,Ft%A */
	0xF2,0xD4,0x2F,0x4F,0x24,0xF6,0x75,0x23,	/* 48D8: .O$u# */
	0x50,0xF2,0xF1,0x7C,0x27,0x20,0x2C,0x46,	/* 48E0: P|' ,F */
	0xF2,0xE0,0x74,0x25,0xFA,0x41,0xF2,0xD4,	/* 48E8: t%A */
	0x2F,0x4F,0x24,0xF6,0x75,0x23,0x50,0xF2,	/* 48F0: .O$u#P */
	0xF1,0x7C,0x27,0x20,0x2C,0x46,0xF2,0xE0,	/* 48F8: |' ,F */
	0x74,0x25,0xFA,0x41,0xF2,0xD4,0x2F,0x4F,	/* 4900: t%A.O */
	0x24,0xF6,0x75,0x23,0x50,0xF2,0xF1,0x7C,	/* 4908: $u#P| */
	0x27,0x20,0x2C,0x46,0xF2,0xE0,0x74,0x25,	/* 4910: ' ,Ft% */
	0xFA,0x41,0xF2,0xD4,0x2F,0x4F,0x24,0xF6,	/* 4918: A.O$ */
	0x75,0x23,0x50,0xF2,0xF1,0x7C,0x27,0x20,	/* 4920: u#P|'  */
	0x2C,0x46,0xF2,0xE0,0x74,0x2F,0x4F,0x24,	/* 4928: ,Ft.O$ */
	0xF6,0xD4,0x7B,0x74,0xF4,0x2F,0x4F,0x24,	/* 4930: {t.O$ */
	0xF6,0xDA,0x74,0x75,0x8C,0x23,0xFB,0x41,	/* 4938: tu#A */
	0x79,0x2C,0x40,0x24,0xFF,0xF0,0xC0,0x21,	/* 4940: y,@$! */
	0xA2,0x41,0x2C,0x41,0x7A,0x24,0xFF,0xF0,	/* 4948: A,Az$ */
	0xC0,0xA9,0x78,0x28,0x20,0x40,0x24,0xFB,	/* 4950: x( @$ */
	0xD8,0x22,0x07,0x41,0x79,0x24,0x40,0x24,	/* 4958: ".Ay$@$ */
	0xFF,0xF0,0xC0,0x21,0xAD,0x41,0x24,0x41,	/* 4960: !A$A */
	0x7A,0x24,0xFF,0xF0,0xC0,0x21,0xA3,0x78,	/* 4968: z$!x */
	0x28,0x20,0x40,0x24,0xF6,0xAC,0x78,0x68,	/* 4970: ( @$xh */
	0x2F,0x4F,0x24,0xF6,0xD8,0x41,0x21,0x76,	/* 4978: .O$A!v */
	0x32,0xE0,0x75,0x24,0x81,0xF1,0x41,0x24,	/* 4980: 2u$A$ */
	0xFB,0x75,0x24,0x81,0x23,0xFB,0x26,0x02,	/* 4988: u$#&. */
	0x7C,0x27,0x20,0x20,0x4C,0xF2,0x30,0x44,	/* 4990: |'  L0D */
	0x24,0xF6,0x21,0xAD,0x42,0x75,0x24,0x84,	/* 4998: $!Bu$ */
	0x23,0xFB,0x7C,0x27,0x20,0x20,0x4C,0xF2,	/* 49A0: #|'  L */
	0x30,0x2F,0x4B,0x24,0xF6,0x42,0x24,0xFB,	/* 49A8: 0.K$B$ */
	0x7C,0x27,0x20,0x20,0x4C,0xF2,0xE0,0x23,	/* 49B0: |'  L# */
	0x09,0x40,0x75,0x24,0x84,0x23,0xFB,0x78,	/* 49B8: .@u$#x */
	0x60,0x4E,0x24,0xF6,0xD8,0x7C,0x27,0x20,	/* 49C0: `N$|'  */
	0x20,0x4C,0xF2,0x30,0x2F,0x49,0x24,0xF6,	/* 49C8:  L0.I$ */
	0x7C,0x27,0x20,0x20,0x4C,0xF2,0xE0,0x75,	/* 49D0: |'  Lu */
	0x24,0x81,0xF1,0x41,0x24,0xF6,0x21,0xA2,	/* 49D8: $A$! */
	0x41,0x21,0x76,0x32,0xE0,0x75,0x24,0x81,	/* 49E0: A!v2u$ */
	0xF1,0x60,0x4E,0x24,0xF6,0x75,0x24,0x81,	/* 49E8: `N$u$ */
	0x23,0xFB,0x7D,0x23,0x4F,0x24,0xF6,0x7C,	/* 49F0: #}#O$| */
	0x27,0x20,0x2D,0x44,0xF2,0xE0,0x21,0x71,	/* 49F8: ' -D!q */
	0x7C,0x27,0x20,0x2D,0x40,0xF2,0xE0,0x78,	/* 4A00: |' -@x */
	0x75,0xE4,0x21,0x72,0x44,0x24,0xF6,0x27,	/* 4A08: u!rD$' */
	0xA4,0x7C,0x27,0x20,0x2D,0x42,0xF2,0x30,	/* 4A10: |' -B0 */
	0x2F,0x4F,0x24,0xF6,0xDD,0x7C,0x27,0x20,	/* 4A18: .O$|'  */
	0x2D,0x40,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 4A20: -@0.O$ */
	0x21,0xD1,0x7D,0x43,0x24,0xF6,0x7C,0x27,	/* 4A28: !}C$|' */
	0x20,0x2D,0x40,0xF2,0xE0,0x7F,0x7D,0x43,	/* 4A30:  -@}C */
	0x24,0xF6,0x28,0xF1,0x7E,0x55,0xFA,0x30,	/* 4A38: $(~U0 */
	0xDB,0x7B,0x21,0x78,0x21,0x2B,0x92,0x7B,	/* 4A40: {!x!+{ */
	0x21,0x78,0x22,0x25,0x9B,0x7B,0x22,0x87,	/* 4A48: !x"%{" */
	0xF1,0xC0,0xAC,0x7B,0x22,0x88,0xF1,0x44,	/* 4A50: {"D */
	0x24,0xFB,0x7B,0x22,0x88,0x23,0xFB,0x41,	/* 4A58: ${"#A */
	0x21,0x76,0x32,0xE0,0x7B,0x21,0x89,0xF1,	/* 4A60: !v2{! */
	0x42,0x24,0xFB,0x7B,0x21,0x89,0x23,0xFB,	/* 4A68: B${!# */
	0x7D,0x23,0x4F,0x24,0xF6,0x7C,0x27,0x20,	/* 4A70: }#O$|'  */
	0x2D,0x42,0xF2,0xE0,0x21,0x71,0x7C,0x27,	/* 4A78: -B!q|' */
	0x20,0x2D,0x40,0xF2,0xE0,0x7E,0x89,0xF1,	/* 4A80:  -@~ */
	0x7C,0x27,0x20,0x2F,0x4E,0xF2,0xE0,0x41,	/* 4A88: |' .NA */
	0x7F,0x41,0xF2,0x25,0xFA,0xDF,0x41,0x24,	/* 4A90: A%A$ */
	0xFF,0xF0,0xC0,0x6D,0x2C,0xAE,0x40,0xDF,	/* 4A98: m,@ */
	0x7E,0x30,0xAC,0x7E,0x30,0x27,0x2F,0x2F,	/* 4AA0: ~0~0'.. */
	0x4F,0x24,0xF6,0xDE,0x6D,0x2B,0x0D,0x28,	/* 4AA8: O$m+.( */
	0x40,0xDE,0x6D,0x2B,0x07,0x21,0xB7,0x22,	/* 4AB0: @m+.!" */
	0xF0,0x60,0xBE,0x74,0x32,0x27,0x2F,0x2F,	/* 4AB8: `t2'.. */
	0x4F,0x24,0xF6,0x33,0xD1,0x74,0x23,0x85,	/* 4AC0: O$3t# */
	0xF1,0xD0,0x43,0x70,0xF9,0xC0,0x21,0xA3,	/* 4AC8: Cp! */
	0x70,0xC3,0xC0,0x21,0x22,0xA0,0x70,0xC4,	/* 4AD0: p!"p */
	0xC0,0x29,0xAA,0x70,0xC5,0xC0,0x2D,0xA6,	/* 4AD8: )p- */
	0x21,0x21,0x03,0x70,0x21,0x20,0xAF,0x70,	/* 4AE0: !!.p! p */
	0xC1,0xC0,0xA8,0x70,0xC2,0xC0,0x24,0xA4,	/* 4AE8: p$ */
	0x21,0x20,0x03,0x71,0x27,0x20,0x20,0x4A,	/* 4AF0: ! .q'  J */
	0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xA2,0x2F,	/* 4AF8: 0.O$. */
	0x05,0x71,0x27,0x20,0x21,0x42,0xF2,0x30,	/* 4B00: .q' !B0 */
	0x22,0x40,0x24,0xF6,0xC0,0x21,0xAF,0x71,	/* 4B08: "@$!q */
	0x27,0x20,0x21,0x42,0xF2,0x30,0x2F,0x4F,	/* 4B10: ' !B0.O */
	0x24,0xF6,0x22,0x40,0x24,0xFB,0x71,0x27,	/* 4B18: $"@$q' */
	0x20,0x21,0x42,0xF2,0xE0,0x24,0x4E,0x71,	/* 4B20:  !B$Nq */
	0x27,0x20,0x20,0x4A,0xF2,0xE0,0x42,0x74,	/* 4B28: '  JBt */
	0x23,0x85,0x23,0xFB,0x71,0x27,0x20,0x20,	/* 4B30: ##q'   */
	0x4A,0xF2,0x30,0x2F,0x4F,0x24,0xF6,0xA2,	/* 4B38: J0.O$ */
	0x2B,0x04,0x40,0x71,0x27,0x20,0x2C,0x46,	/* 4B40: +.@q' ,F */
	0xF2,0xE0,0x28,0x41,0x71,0x27,0x20,0x2C,	/* 4B48: (Aq' , */
	0x46,0xF2,0xE0,0x74,0x34,0x60,0x4E,0x24,	/* 4B50: Ft4`N$ */
	0xF6,0x74,0xE4,0x71,0x27,0x20,0x20,0x4C,	/* 4B58: tq'  L */
	0xF2,0x30,0x2F,0x49,0x24,0xF6,0x71,0x27,	/* 4B60: 0.I$q' */
	0x20,0x20,0x4C,0xF2,0xE0,0x43,0x74,0x23,	/* 4B68:   LCt# */
	0x85,0x23,0xFB,0x28,0x01,0x71,0x27,0x20,	/* 4B70: #(.q'  */
	0x20,0x4A,0xF2,0x30,0x2F,0x4F,0x24,0xF6,	/* 4B78:  J0.O$ */
	0xA2,0x27,0x03,0x71,0x27,0x20,0x21,0x42,	/* 4B80: '.q' !B */
	0xF2,0x30,0x22,0x40,0x24,0xF6,0xC0,0x21,	/* 4B88: 0"@$! */
	0xAF,0x71,0x27,0x20,0x21,0x42,0xF2,0x30,	/* 4B90: q' !B0 */
	0x2F,0x4F,0x24,0xF6,0x22,0x40,0x24,0xFB,	/* 4B98: .O$"@$ */
	0x71,0x27,0x20,0x21,0x42,0xF2,0xE0,0x24,	/* 4BA0: q' !B$ */
	0x4E,0x71,0x27,0x20,0x20,0x4A,0xF2,0xE0,	/* 4BA8: Nq'  J */
	0x45,0x74,0x23,0x85,0x23,0xFB,0x71,0x27,	/* 4BB0: Et##q' */
	0x20,0x20,0x4A,0xF2,0x30,0x2F,0x4F,0x24,	/* 4BB8:   J0.O$ */
	0xF6,0xA2,0x23,0x02,0x40,0x71,0x27,0x20,	/* 4BC0: #.@q'  */
	0x2C,0x46,0xF2,0xE0,0x28,0x43,0x71,0x27,	/* 4BC8: ,F(Cq' */
	0x20,0x2C,0x46,0xF2,0xE0,0x71,0x27,0x20,	/* 4BD0:  ,Fq'  */
	0x21,0x42,0xF2,0x30,0x2D,0x4F,0x24,0xF6,	/* 4BD8: !B0-O$ */
	0x71,0x27,0x20,0x21,0x42,0xF2,0xE0,0x24,	/* 4BE0: q' !B$ */
	0x4E,0x71,0x27,0x20,0x20,0x4A,0xF2,0xE0,	/* 4BE8: Nq'  J */
	0x40,0x74,0x23,0x85,0x23,0xFB,0xB2,0x22,	/* 4BF0: @t##" */
	0xF0,0x60,0xBF,0x73,0x31,0xD0,0x70,0x27,	/* 4BF8: `s1p' */
	0x20,0x20,0x4A,0xF2,0x30,0x2F,0x4F,0x24,	/* 4C00:   J0.O$ */
	0xF6,0x21,0xA0,0x73,0x24,0x80,0xF1,0x21,	/* 4C08: !s$! */
	0x40,0x24,0xFB,0x73,0x24,0x80,0x23,0xFB,	/* 4C10: @$s$# */
	0xB1,0x22,0xF0,0x73,0x24,0x80,0xF1,0x61,	/* 4C18: "s$a */
	0x4F,0x24,0xF6,0x73,0x24,0x80,0x23,0xFB,	/* 4C20: O$s$# */
	0x73,0x23,0x80,0xF1,0x21,0x40,0x24,0xF6,	/* 4C28: s#!@$ */
	0x25,0xA0,0x70,0x27,0x20,0x2D,0x48,0xF2,	/* 4C30: %p' -H */
	0x30,0x21,0x40,0x24,0xF6,0x22,0xA1,0x73,	/* 4C38: 0!@$"s */
	0x24,0x80,0xF1,0x41,0x24,0xF6,0x25,0xA9,	/* 4C40: $A$% */
	0x21,0x48,0x70,0x27,0x20,0x20,0x4A,0xF2,	/* 4C48: !Hp'  J */
	0xE0,0x73,0x24,0x80,0xF1,0x60,0x4E,0x24,	/* 4C50: s$`N$ */
	0xF6,0x73,0x24,0x80,0x23,0xFB,0x24,0x01,	/* 4C58: s$#$. */
	0x73,0x24,0x80,0xF1,0x41,0x24,0xF6,0x23,	/* 4C60: s$A$# */
	0xF2,0x23,0xA6,0x21,0x44,0x70,0x27,0x20,	/* 4C68: #!Dp'  */
	0x20,0x4A,0xF2,0xE0,0x73,0x24,0x80,0xF1,	/* 4C70:  Js$ */
	0x41,0x24,0xFB,0x73,0x24,0x80,0x23,0xFB,	/* 4C78: A$s$# */
	0x21,0x0F,0x73,0x24,0x80,0xF1,0x41,0x24,	/* 4C80: !.s$A$ */
	0xF6,0x21,0xA6,0x21,0x48,0x70,0x27,0x20,	/* 4C88: !!Hp'  */
	0x20,0x4A,0xF2,0xE0,0x73,0x24,0x80,0xF1,	/* 4C90:  Js$ */
	0x60,0x4E,0x24,0xF6,0x73,0x24,0x80,0x23,	/* 4C98: `N$s$# */
	0xFB,0xB1,0x22,0xF0,0x63,0x2E,0x2C,0x0F,	/* 4CA0: "c.,. */
	0x64,0x2D,0x24,0x0B,0x20,0xB4,0x00,0x60,	/* 4CA8: d-$. .` */
	0xBF,0x72,0x2B,0x59,0x20,0x20,0xD0,0x70,	/* 4CB0: r+Y  p */
	0x72,0xEB,0x20,0x70,0x60,0x5D,0x20,0x20,	/* 4CB8: r p`]   */
	0x70,0xE2,0x70,0x60,0x5E,0x20,0x20,0x70,	/* 4CC0: pp`^  p */
	0xE1,0x70,0x68,0x57,0x20,0x20,0x70,0xE0,	/* 4CC8: phW  p */
	0xB1,0x22,0xF0,0x0C,0x00,0x00,0x00,0x60,	/* 4CD0: "....` */
	0xBF,0x72,0x3A,0xD0,0x72,0x3A,0x72,0x3B,	/* 4CD8: r:r:r; */
	0x72,0x3B,0x28,0x26,0x9A,0x20,0x72,0x72,	/* 4CE0: r;(& rr */
	0x3B,0x9B,0x20,0x20,0x20,0xB1,0x22,0xF0,	/* 4CE8: ;   " */
	0x20,0x0D,0x00,0x00,0x00,0x60,0xB7,0x7A,	/* 4CF0:  ....`z */
	0x3D,0x20,0xD8,0x7B,0x37,0x7B,0x35,0xF4,	/* 4CF8: = {7{5 */
	0x78,0x32,0xE0,0x7B,0x37,0x78,0x33,0xE0,	/* 4D00: x2{7x3 */
	0x7B,0x3D,0x78,0x34,0xE0,0x7B,0x3C,0x78,	/* 4D08: {=x4{<x */
	0x35,0xE0,0x41,0x78,0x36,0xE0,0x24,0x20,	/* 4D10: 5Ax6$  */
	0x40,0x78,0x37,0xE0,0x7B,0x78,0x38,0xE0,	/* 4D18: @x7{x8 */
	0x78,0x39,0x7A,0x22,0x9B,0xC0,0x22,0xA5,	/* 4D20: x9z"" */
	0x21,0xFE,0x78,0x3A,0xE0,0x22,0xF2,0x78,	/* 4D28: !x:"x */
	0x3B,0xE0,0x78,0x50,0x16,0x44,0x24,0xFA,	/* 4D30: ;xP.D$ */
	0x24,0xF2,0xD0,0x24,0xF2,0xD1,0x40,0xD2,	/* 4D38: $$@ */
	0x24,0xF2,0xD3,0x40,0xD4,0x16,0x41,0x7A,	/* 4D40: $@.Az */
	0x9B,0xD5,0x75,0x7A,0x9B,0xB9,0x22,0xF0,	/* 4D48: uz" */
	0x2D,0x29,0x04,0x20,0x64,0x27,0x2A,0x0F,	/* 4D50: -). d'*. */
	0x2E,0x28,0x0B,0x20,0x20,0x00,0x20,0x01,	/* 4D58: .(.  . . */
	0x00,0x46,0x02,0x60,0xBF,0x72,0x2B,0x5C,	/* 4D60: .F.`r+\ */
	0x20,0x20,0xD0,0x70,0x72,0xED,0x20,0x61,	/* 4D68:   pr a */
	0x4A,0x21,0xFB,0x70,0xE0,0x70,0x21,0x5F,	/* 4D70: J!pp!_ */
	0x20,0x20,0x70,0xEB,0x70,0x22,0x50,0x20,	/* 4D78:   pp"P  */
	0x20,0x70,0xEA,0x70,0x22,0x57,0x20,0x20,	/* 4D80:  pp"W   */
	0x70,0xE9,0x70,0x23,0x50,0x20,0x20,0x70,	/* 4D88: pp#P  p */
	0xE8,0x70,0x23,0x56,0x20,0x20,0x70,0xE7,	/* 4D90: p#V  p */
	0x70,0x23,0x55,0x20,0x20,0x70,0xE6,0x70,	/* 4D98: p#U  pp */
	0x23,0x52,0x20,0x20,0x70,0xE5,0x70,0x23,	/* 4DA0: #R  pp# */
	0x51,0x20,0x20,0x70,0xE4,0x70,0x22,0x5E,	/* 4DA8: Q  pp"^ */
	0x20,0x20,0x70,0xE3,0x70,0x22,0x5D,0x20,	/* 4DB0:   pp"]  */
	0x20,0x70,0xE2,0x70,0x66,0x4F,0x21,0xFB,	/* 4DB8:  ppfO! */
	0x41,0x27,0x2D,0x99,0x20,0xB1,0x22,0xF0,	/* 4DC0: A'- " */
	0x20,0x0E,0x00,0x00,0x00,0x73,0x72,0x74,	/* 4DC8:  ....srt */
	0x24,0x2A,0x97,0x20,0x22,0xF0,0x73,0x72,	/* 4DD0: $* "sr */
	0x74,0x24,0x2C,0x9B,0x20,0x22,0xF0,0x60,	/* 4DD8: t$, "` */
	0xBF,0x10,0x73,0x42,0x24,0x29,0x93,0x20,	/* 4DE0: .sB$)  */
	0x70,0xB1,0x22,0xF0,0x60,0xBF,0x40,0xD0,	/* 4DE8: p"`@ */
	0x10,0x73,0x41,0x24,0x28,0x94,0x20,0x70,	/* 4DF0: .sA$( p */
	0x2F,0x4F,0x24,0xF6,0xB1,0x22,0xF0,0x13,	/* 4DF8: .O$". */
	0x72,0x42,0x24,0x2A,0x92,0x20,0x22,0xF0,	/* 4E00: rB$* " */
	0x13,0x72,0x41,0x24,0x29,0x99,0x20,0x22,	/* 4E08: .rA$) " */
	0xF0,0x0F,0x00,0x00,0x00,0x60,0xBD,0x74,	/* 4E10: ....`t */
	0x3F,0x20,0xD2,0x72,0x30,0x30,0xD0,0x40,	/* 4E18: ? r00@ */
	0xD1,0x72,0x31,0x30,0x24,0xF2,0xF4,0x21,	/* 4E20: r10$! */
	0xA4,0x72,0x31,0x30,0x75,0xF9,0xC0,0xAD,	/* 4E28: r10u */
	0x75,0x72,0x32,0x30,0xF9,0xC0,0xA6,0x41,	/* 4E30: ur20A */
	0x47,0x74,0x21,0x23,0x9B,0x70,0x24,0xF2,	/* 4E38: Gt!#p$ */
	0xF4,0x21,0xA6,0x70,0x32,0x75,0xF9,0xC0,	/* 4E40: !p2u */
	0xAB,0x70,0x32,0x70,0x33,0xF5,0x75,0xF9,	/* 4E48: p2p3u */
	0xA3,0x41,0xD1,0x05,0x70,0x30,0xD0,0x61,	/* 4E50: A.p0a */
	0x04,0x71,0xA6,0x41,0x47,0x74,0x21,0x21,	/* 4E58: .qAGt!! */
	0x97,0xB3,0x22,0xF0,0x60,0xBB,0x76,0x3F,	/* 4E60: "`v? */
	0x20,0xD4,0x15,0xD2,0x1B,0x42,0xF2,0xD1,	/* 4E68:  ..B */
	0x74,0x30,0x30,0x67,0x20,0x20,0xC0,0xAC,	/* 4E70: t00g   */
	0x74,0x21,0x30,0x74,0x3E,0xE0,0x74,0x21,	/* 4E78: t!0t>t! */
	0x31,0x74,0x3F,0xE0,0x79,0x76,0x67,0x9D,	/* 4E80: 1t?yvg */
	0x7A,0x40,0xF4,0xA8,0x7B,0x23,0xF4,0x22,	/* 4E88: z@{#" */
	0x80,0x7A,0xF9,0xA4,0x41,0xB5,0x22,0xF0,	/* 4E90: zA" */
	0x74,0x21,0x32,0xD3,0x7B,0x81,0xDB,0x77,	/* 4E98: t!2{w */
	0x24,0xF2,0xF4,0x25,0xAB,0x79,0x77,0xE2,	/* 4EA0: $%yw */
	0x7A,0x77,0xE3,0x77,0x32,0x7A,0xF5,0x60,	/* 4EA8: zww2z` */
	0x8A,0x7B,0x23,0xF4,0xF4,0x77,0xE4,0x78,	/* 4EB0: {#wx */
	0x77,0x34,0x60,0xEF,0x78,0x77,0xE6,0x73,	/* 4EB8: w4`xws */
	0x77,0x34,0xE0,0x72,0x31,0x77,0x34,0xE1,	/* 4EC0: w4r1w4 */
	0x77,0x77,0x34,0xE2,0x40,0xD0,0x7B,0x70,	/* 4EC8: ww4@{p */
	0xF9,0xAF,0x70,0x71,0xFA,0x30,0x70,0x83,	/* 4ED0: pq0p */
	0x77,0x34,0xFA,0xE0,0x70,0x81,0xD0,0x61,	/* 4ED8: w4pa */
	0x0D,0x7B,0x77,0xE5,0x24,0xF2,0x81,0x77,	/* 4EE0: .{w$w */
	0xE7,0x74,0x53,0x76,0x28,0x9E,0x74,0x30,	/* 4EE8: tSv(t0 */
	0x30,0x77,0xE0,0x77,0x74,0x30,0xE0,0x74,	/* 4EF0: 0wwt0t */
	0x53,0x76,0x28,0x94,0x40,0xB5,0x22,0xF0,	/* 4EF8: Sv(@" */
	0x41,0xB5,0x22,0xF0,0x60,0xBE,0x73,0x3F,	/* 4F00: A"`s? */
	0x20,0xD1,0x71,0x53,0x73,0x26,0x9D,0x74,	/* 4F08:  qSs&t */
	0x71,0x30,0x30,0xF4,0xC0,0x21,0xA0,0x71,	/* 4F10: q00!q */
	0x30,0x30,0x30,0x71,0x30,0xE0,0x71,0x53,	/* 4F18: 000q0qS */
	0x73,0x25,0x9D,0x40,0xB2,0x22,0xF0,0x71,	/* 4F20: s%@"q */
	0x30,0x30,0xD0,0x70,0x30,0x24,0xF2,0xF4,	/* 4F28: 00p0$ */
	0xAC,0x70,0x30,0x74,0xF4,0xC0,0xA1,0x05,	/* 4F30: p0t. */
	0x70,0x30,0xD0,0x61,0x0E,0x70,0x30,0x67,	/* 4F38: p0a.p0g */
	0x20,0x20,0xC0,0xA9,0x71,0x53,0x73,0x23,	/* 4F40:   qSs# */
	0x97,0x41,0xB2,0x22,0xF0,0x74,0x30,0x70,	/* 4F48: A"t0p */
	0xE0,0x71,0x53,0x73,0x22,0x9A,0x40,0xB2,	/* 4F50: qSs"@ */
	0x22,0xF0,0xB2,0x22,0xF0,0x72,0x71,0x65,	/* 4F58: ""rqe */
	0x93,0xA5,0x41,0x48,0x71,0x21,0x91,0x22,	/* 4F60: AHq!" */
	0xF0,0x72,0x71,0x66,0x97,0xA4,0x41,0x48,	/* 4F68: rqfAH */
	0x71,0x96,0x72,0x71,0x21,0x92,0x22,0xF0,	/* 4F70: qrq!" */
	0x2C,0x2C,0x00,0x20,0x2D,0x05,0x20,0x20,	/* 4F78: ,,. -.   */
	0x21,0x2F,0x09,0x20,0x2B,0x29,0x06,0x20,	/* 4F80: !.. +).  */
	0x24,0x2A,0x09,0x20,0x01,0x00,0x00,0x00,	/* 4F88: $*. .... */
	0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,	/* 4F90: ........ */
	0x01,0x0D,0x00,0x0B,0x00,0x0A,0x00,0x08,	/* 4F98: ........ */
	0x00,0x07,0x00,0x05,0x00,0x04,0x00,0x46,	/* 4FA0: .......F */
	0x03,0x60,0xBF,0x72,0x2C,0x58,0x20,0x20,	/* 4FA8: .`r,X   */
	0xD0,0x70,0x72,0xEF,0x20,0x62,0x43,0x21,	/* 4FB0: pr bC! */
	0xFB,0x70,0x86,0x4D,0x24,0xFA,0x25,0x47,	/* 4FB8: pM$%G */
	0x21,0xFB,0x25,0x43,0x21,0xFB,0x30,0xF2,	/* 4FC0: !%C!0 */
	0x70,0x21,0xE2,0x24,0x48,0x21,0xFB,0x24,	/* 4FC8: p!$H!$ */
	0x44,0x21,0xFB,0x30,0xF2,0x70,0x21,0xE1,	/* 4FD0: D!0p! */
	0x23,0x49,0x21,0xFB,0x23,0x45,0x21,0xFB,	/* 4FD8: #I!#E! */
	0x30,0xF2,0x70,0x21,0xE0,0x70,0x22,0x5C,	/* 4FE0: 0p!p"\ */
	0x20,0x20,0x70,0xEF,0x70,0x22,0x5B,0x20,	/* 4FE8:   pp"[  */
	0x20,0x70,0xEE,0x70,0x22,0x52,0x20,0x20,	/* 4FF0:  pp"R   */
	0x70,0xE2,0x70,0x22,0x51,0x20,0x20,0x70,	/* 4FF8: pp"Q  p */
	0xE1,0x70,0x21,0x59,0x20,0x20,0x70,0xE0,	/* 5000: p!Y  p */
	0x70,0x67,0x4C,0x21,0xFB,0x47,0x25,0x28,	/* 5008: pgL!G%( */
	0x9C,0x20,0xB1,0x22,0xF0,0x3E,0x00,0x65,	/* 5010:  ">.e */
	0x01,0x04,0x0B,0x10,0x00,0x00,0x00,0x72,	/* 5018: .......r */
	0x22,0xFB,0x22,0xF0,0x22,0xF2,0x72,0xF0,	/* 5020: """r */
	0x71,0x9A,0xD2,0x72,0x22,0xFB,0x22,0xF0,	/* 5028: qr"" */
	0x21,0xF5,0x22,0xF0,0x08,0x20,0x20,0x20,	/* 5030: !".    */
	0x20,0x11,0x00,0x00,0x00,0x73,0x72,0x25,	/* 5038:  ....sr% */
	0xF2,0x22,0xF0,0x72,0x73,0xF4,0x22,0xF0,	/* 5040: "rs" */
	0x72,0x73,0xF4,0x40,0xF9,0x22,0xF0,0x12,	/* 5048: rs@". */
	0x00,0x00,0x00,0x60,0xB6,0x40,0xD7,0x24,	/* 5050: ...`@$ */
	0xF2,0xD5,0x24,0xF2,0xD6,0x21,0xFE,0xD8,	/* 5058: $! */
	0x78,0xC1,0x28,0xAE,0x41,0xD4,0x40,0xD2,	/* 5060: x(A@ */
	0x7C,0x33,0xC1,0xA5,0x40,0x7C,0xE3,0x41,	/* 5068: |3@|A */
	0xD2,0x72,0xC0,0x22,0xA3,0x24,0xF2,0xD0,	/* 5070: r"$ */
	0x24,0xF2,0xD1,0x7C,0x34,0x67,0x20,0x20,	/* 5078: $|4g   */
	0xC0,0xA8,0x10,0x7C,0xE4,0x10,0x7C,0xE5,	/* 5080: .|.| */
	0x41,0xD2,0x72,0xC0,0xA7,0x10,0x7C,0x35,	/* 5088: Ar.|5 */
	0xE1,0x10,0x7C,0xE5,0x13,0x10,0x42,0xF7,	/* 5090: .|..B */
	0x41,0x7C,0xE9,0x41,0x7C,0x30,0x40,0x24,	/* 5098: A|A|0@$ */
	0xFF,0xF0,0xC0,0xA9,0x7C,0x30,0x60,0x4F,	/* 50A0: |0`O */
	0xF2,0x7C,0xE0,0x21,0x07,0x41,0xD7,0x7C,	/* 50A8: |!.A| */
	0x31,0x67,0x20,0x20,0xC0,0xA7,0x15,0x7C,	/* 50B0: 1g  .| */
	0xE1,0x15,0x7C,0xE2,0x07,0x15,0x7C,0x32,	/* 50B8: .|..|2 */
	0xE1,0x15,0x7C,0xE2,0x40,0x7C,0xE9,0x7C,	/* 50C0: .|@|| */
	0x3A,0x24,0xF2,0xF4,0xA5,0x14,0x7C,0x5A,	/* 50C8: :$.|Z */
	0x42,0xFB,0x41,0xD3,0x7C,0x34,0x67,0x20,	/* 50D0: BA|4g  */
	0x20,0xC0,0xA3,0x41,0x7C,0xE3,0x7C,0x34,	/* 50D8:  A||4 */
	0x24,0xF2,0xF4,0xAC,0x7C,0x34,0xD2,0x7C,	/* 50E0: $|4| */
	0x34,0x31,0x7C,0xE4,0x13,0x72,0x42,0xFB,	/* 50E8: 41|.rB */
	0x28,0x01,0x40,0xD2,0x7C,0x36,0xC1,0xA5,	/* 50F0: (.@|6 */
	0x40,0x7C,0xE6,0x41,0xD2,0x72,0xC0,0x22,	/* 50F8: @|Ar" */
	0xA3,0x24,0xF2,0xD0,0x24,0xF2,0xD1,0x7C,	/* 5100: $$| */
	0x37,0x67,0x20,0x20,0xC0,0xA8,0x10,0x7C,	/* 5108: 7g  .| */
	0xE7,0x10,0x7C,0xE8,0x41,0xD2,0x72,0xC0,	/* 5110: .|Ar */
	0xA7,0x10,0x7C,0x38,0xE1,0x10,0x7C,0xE8,	/* 5118: .|8.| */
	0x13,0x10,0x42,0xF7,0x7C,0x39,0xA5,0x14,	/* 5120: ..B|9. */
	0x7C,0x5A,0x42,0xF7,0x41,0x7C,0x30,0x40,	/* 5128: |ZBA|0@ */
	0x24,0xFF,0xF0,0xC0,0xA9,0x7C,0x30,0x60,	/* 5130: $|0` */
	0x4F,0xF2,0x7C,0xE0,0x21,0x07,0x41,0xD7,	/* 5138: O|!.A */
	0x7C,0x31,0x67,0x20,0x20,0xC0,0xA7,0x15,	/* 5140: |1g  . */
	0x7C,0xE1,0x15,0x7C,0xE2,0x07,0x15,0x7C,	/* 5148: |.|..| */
	0x32,0xE1,0x15,0x7C,0xE2,0x41,0xD3,0x7C,	/* 5150: 2.|A| */
	0x37,0x67,0x20,0x20,0xC0,0xA3,0x41,0x7C,	/* 5158: 7g  A| */
	0xE6,0x7C,0x37,0x24,0xF2,0xF4,0xAC,0x7C,	/* 5160: |7$| */
	0x37,0xD2,0x7C,0x37,0x31,0x7C,0xE7,0x13,	/* 5168: 7|71|. */
	0x72,0x42,0xFB,0x77,0xA4,0x19,0x15,0x42,	/* 5170: rBw..B */
	0xF7,0xBA,0x22,0xF0,0x60,0xB9,0x41,0xD5,	/* 5178: "`A */
	0x21,0xFE,0xD6,0x76,0xC1,0x27,0xAD,0x40,	/* 5180: !v'@ */
	0xD3,0x79,0x33,0xC1,0xA5,0x40,0x79,0xE3,	/* 5188: y3@y */
	0x41,0xD3,0x73,0xC0,0x22,0xA3,0x24,0xF2,	/* 5190: As"$ */
	0xD1,0x24,0xF2,0xD2,0x79,0x34,0x67,0x20,	/* 5198: $y4g  */
	0x20,0xC0,0xA8,0x11,0x79,0xE4,0x11,0x79,	/* 51A0:  .y.y */
	0xE5,0x41,0xD3,0x73,0xC0,0xA7,0x11,0x79,	/* 51A8: As.y */
	0x35,0xE1,0x11,0x79,0xE5,0x14,0x11,0x42,	/* 51B0: 5.y..B */
	0xF7,0x41,0x79,0xE9,0x79,0x31,0x67,0x20,	/* 51B8: Ayy1g  */
	0x20,0xC0,0xA7,0x79,0x30,0x41,0xF2,0x79,	/* 51C0:  y0Ay */
	0xE0,0x0C,0x79,0x31,0xD4,0x79,0x31,0x31,	/* 51C8: .y1y11 */
	0x79,0xE1,0x15,0x74,0x42,0xFB,0x40,0x79,	/* 51D0: y.tB@y */
	0xE9,0x79,0x3A,0x24,0xF2,0xF4,0xA5,0x15,	/* 51D8: y:$. */
	0x79,0x5A,0x42,0xFB,0x41,0xD4,0x79,0x34,	/* 51E0: yZBAy4 */
	0x67,0x20,0x20,0xC0,0xA3,0x41,0x79,0xE3,	/* 51E8: g  Ay */
	0x79,0x34,0x24,0xF2,0xF4,0xAC,0x79,0x34,	/* 51F0: y4$y4 */
	0xD3,0x79,0x34,0x31,0x79,0xE4,0x14,0x73,	/* 51F8: y41y.s */
	0x42,0xFB,0x27,0x02,0x40,0xD2,0x79,0x36,	/* 5200: B'.@y6 */
	0xC1,0xA5,0x40,0x79,0xE6,0x41,0xD2,0x72,	/* 5208: @yAr */
	0xC0,0x22,0xA3,0x24,0xF2,0xD0,0x24,0xF2,	/* 5210: "$$ */
	0xD1,0x79,0x37,0x67,0x20,0x20,0xC0,0xA8,	/* 5218: y7g   */
	0x10,0x79,0xE7,0x10,0x79,0xE8,0x41,0xD2,	/* 5220: .y.yA */
	0x72,0xC0,0xA7,0x10,0x79,0x38,0xE1,0x10,	/* 5228: r.y8. */
	0x79,0xE8,0x13,0x10,0x42,0xF7,0x79,0x39,	/* 5230: y..By9 */
	0xA5,0x14,0x79,0x5A,0x42,0xF7,0x79,0x31,	/* 5238: .yZBy1 */
	0x67,0x20,0x20,0xC0,0xA7,0x79,0x30,0x41,	/* 5240: g  y0A */
	0xF2,0x79,0xE0,0x0C,0x79,0x31,0xD3,0x79,	/* 5248: y.y1y */
	0x31,0x31,0x79,0xE1,0x15,0x73,0x42,0xFB,	/* 5250: 11y.sB */
	0x41,0xD3,0x79,0x37,0x67,0x20,0x20,0xC0,	/* 5258: Ay7g   */
	0xA3,0x41,0x79,0xE6,0x79,0x37,0x24,0xF2,	/* 5260: Ayy7$ */
	0xF4,0xAC,0x79,0x37,0xD2,0x79,0x37,0x31,	/* 5268: y7y71 */
	0x79,0xE7,0x13,0x72,0x42,0xFB,0xB7,0x22,	/* 5270: y.rB" */
	0xF0,0x20,0x60,0xBF,0x22,0xF9,0x73,0x41,	/* 5278:  `"sA */
	0x24,0xF6,0x21,0xA6,0x72,0xD0,0x74,0x73,	/* 5280: $!rts */
	0x60,0x8F,0x10,0x25,0xF5,0x21,0x94,0x70,	/* 5288: `.%!p */
	0x72,0xF4,0xA4,0x21,0xF0,0x21,0xF5,0x22,	/* 5290: r!!" */
	0xF9,0x04,0x74,0x73,0x72,0xF7,0x22,0xF9,	/* 5298: .tsr" */
	0xB1,0x22,0xF0,0x28,0x26,0x0E,0x20,0x22,	/* 52A0: "(&. " */
	0xF9,0x72,0x41,0x24,0xF6,0xA9,0x73,0x72,	/* 52A8: rA$sr */
	0x60,0x8F,0x71,0x25,0xF5,0x99,0x04,0x73,	/* 52B0: `q%.s */
	0x72,0x71,0xFB,0x22,0xF9,0x22,0xF0,0x28,	/* 52B8: rq""( */
	0x24,0x0B,0x20,0x13,0x00,0x00,0x00,0xFF,	/* 52C0: $. .... */
	0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x7F,0x00,	/* 52C8: . */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,	/* 52D0: ........ */
	0x27,0x02,0x04,0x15,0x00,0x14,0x00,0x12,	/* 52D8: '....... */
	0x00,0x11,0x00,0x10,0x00,0x0F,0x00,0x0E,	/* 52E0: ........ */
	0x00,0x0C,0x00,0x06,0x00,0x6C,0x00,0x60,	/* 52E8: .....l.` */
	0xBF,0x72,0x2D,0x5B,0x20,0x20,0xD0,0x70,	/* 52F0: r-[  p */
	0x72,0x21,0xE3,0x62,0x4B,0x21,0xFB,0x70,	/* 52F8: r!bK!p */
	0x22,0x8F,0x41,0x24,0xFA,0x64,0x4E,0x21,	/* 5300: "A$dN! */
	0xFB,0x70,0x84,0x21,0x43,0x24,0xFA,0x70,	/* 5308: p!C$p */
	0x63,0x47,0x21,0xFB,0x49,0x22,0x28,0x95,	/* 5310: cG!I"( */
	0x20,0xB1,0x22,0xF0,0x20,0x14,0x00,0x00,	/* 5318:  " ... */
	0x00,0x73,0x72,0xE0,0x24,0xF2,0x72,0xE1,	/* 5320: .sr$r */
	0x41,0x72,0xE3,0x24,0xF2,0x72,0xE4,0x41,	/* 5328: Ar$rA */
	0x72,0xE6,0x24,0xF2,0x72,0xE7,0x40,0x72,	/* 5330: r$r@r */
	0xE9,0x24,0xF2,0x72,0xEA,0x22,0xF0,0x41,	/* 5338: $r"A */
	0x72,0x30,0x40,0x24,0xFF,0xF0,0xC0,0xA7,	/* 5340: r0@$ */
	0x72,0x30,0x60,0x4F,0xF2,0x72,0xE0,0x22,	/* 5348: r0`Or" */
	0xF0,0x72,0x30,0x41,0xF2,0x72,0xE0,0x22,	/* 5350: r0Ar" */
	0xF0,0x08,0x01,0x60,0xBF,0x72,0x2F,0x53,	/* 5358: ..`r.S */
	0x20,0x20,0xD0,0x70,0x72,0x21,0xE4,0x61,	/* 5360:   pr!a */
	0x46,0x21,0xFB,0x70,0xE1,0x63,0x4E,0x21,	/* 5368: F!pcN! */
	0xFB,0x70,0xE0,0xB1,0x22,0xF0,0x20,0x15,	/* 5370: p" . */
	0x00,0x00,0x00,0x60,0xBD,0x74,0x21,0x35,	/* 5378: ...`t!5 */
	0xD2,0x75,0x67,0x20,0x20,0xC0,0xA3,0xB3,	/* 5380: ug   */
	0x22,0xF0,0x75,0x60,0x5E,0xD1,0x75,0x41,	/* 5388: "u`^uA */
	0x24,0xF6,0xC0,0x22,0xA0,0x72,0x30,0x30,	/* 5390: $"r00 */
	0x71,0xF9,0xC0,0x21,0xA8,0x72,0x31,0x30,	/* 5398: q!r10 */
	0x71,0xF9,0x21,0xA1,0x71,0x30,0x67,0x20,	/* 53A0: q!q0g  */
	0x20,0xC1,0xAA,0x71,0x31,0x60,0x4C,0x24,	/* 53A8:  q1`L$ */
	0xF6,0x71,0x31,0xF4,0xA5,0x41,0x44,0x74,	/* 53B0: q1ADt */
	0x2A,0x90,0x72,0x32,0x30,0xD0,0x70,0x72,	/* 53B8: *r20pr */
	0x32,0x31,0xF4,0xAA,0x71,0x70,0x30,0xF9,	/* 53C0: 21qp0 */
	0xA5,0x70,0x30,0xD0,0x60,0x00,0x70,0x30,	/* 53C8: p0`.p0 */
	0x72,0x32,0x30,0xF4,0x22,0xA5,0x71,0x25,	/* 53D0: r20"q% */
	0xFA,0x31,0xF2,0x70,0x30,0xF4,0xC0,0x21,	/* 53D8: 1p0! */
	0xAA,0x70,0x30,0x72,0x32,0x31,0xF4,0xC0,	/* 53E0: p0r21 */
	0xA4,0x71,0x72,0x32,0xE1,0x71,0x31,0x70,	/* 53E8: qr2q1p */
	0x30,0x31,0xF2,0x71,0xE1,0x70,0x30,0x30,	/* 53F0: 01qp00 */
	0x71,0xE0,0x04,0x70,0x30,0x71,0xE0,0x70,	/* 53F8: q.p0qp */
	0x25,0xFA,0x31,0xF2,0x71,0xF4,0xC0,0x21,	/* 5400: %1q! */
	0xA9,0x70,0x31,0x71,0x31,0xF2,0x70,0xE1,	/* 5408: p1q1p */
	0x71,0x30,0x70,0xE0,0x70,0x30,0x72,0x32,	/* 5410: q0pp0r2 */
	0x30,0xF4,0xC0,0x21,0xA4,0x70,0x72,0x32,	/* 5418: 0!pr2 */
	0xE1,0x0F,0x71,0x70,0xE0,0x71,0x30,0x72,	/* 5420: .qpq0r */
	0x32,0x30,0xF4,0xC0,0xA4,0x71,0x72,0x32,	/* 5428: 20qr2 */
	0xE1,0xB3,0x22,0xF0,0x60,0xBE,0x73,0x21,	/* 5430: "`s! */
	0x35,0xD1,0x71,0x33,0x30,0xC0,0xA3,0xB2,	/* 5438: 5q30 */
	0x22,0xF0,0x71,0x35,0x30,0xD0,0x71,0x34,	/* 5440: "q50q4 */
	0x73,0x21,0x93,0x74,0x73,0x6D,0x9C,0x71,	/* 5448: s!tsmq */
	0x36,0x30,0xD0,0x71,0x34,0x73,0x97,0xB2,	/* 5450: 60q4s */
	0x22,0xF0,0x27,0x2D,0x0E,0x20,0x74,0xF6,	/* 5458: "'-. t */
	0x20,0x9E,0x00,0x60,0xBF,0x72,0x2F,0x55,	/* 5460:  .`r.U */
	0x20,0x20,0xD0,0x70,0x72,0x21,0xE5,0x70,	/* 5468:   pr!p */
	0x60,0x5F,0x20,0x20,0x70,0xE6,0x70,0x60,	/* 5470: `_  pp` */
	0x5E,0x20,0x20,0x70,0xE5,0x70,0x5A,0x20,	/* 5478: ^  ppZ  */
	0x20,0x20,0x70,0xE4,0x70,0x59,0x20,0x20,	/* 5480:   ppY   */
	0x20,0x70,0xE3,0x70,0x57,0x20,0x20,0x20,	/* 5488:  ppW    */
	0x70,0xE2,0x70,0x60,0x5A,0x20,0x20,0x70,	/* 5490: pp`Z  p */
	0xE1,0x70,0x60,0x58,0x20,0x20,0x70,0xE0,	/* 5498: p`X  p */
	0xB1,0x22,0xF0,0x16,0x00,0x00,0x00,0x60,	/* 54A0: "....` */
	0xBF,0x72,0x21,0x36,0xD0,0x70,0x5E,0x70,	/* 54A8: r!6p^p */
	0xEE,0x70,0x5E,0x70,0xE0,0x70,0x5E,0x70,	/* 54B0: p^pp^p */
	0xE1,0x40,0x70,0xEF,0x41,0x70,0x53,0x72,	/* 54B8: @pApSr */
	0x22,0x95,0x73,0x70,0x21,0x30,0xE0,0x73,	/* 54C0: "sp!0s */
	0x74,0xF2,0x70,0x21,0x31,0xE0,0x41,0x70,	/* 54C8: tp!1Ap */
	0xE2,0x75,0xAA,0x40,0x70,0x21,0x32,0xE0,	/* 54D0: u@p!2 */
	0x73,0x70,0x21,0x33,0xE0,0xB1,0x22,0xF0,	/* 54D8: sp!3" */
	0x40,0x71,0x21,0x36,0xE2,0x22,0xF0,0x61,	/* 54E0: @q!6"a */
	0x23,0x07,0x20,0x0E,0x00,0x0D,0x00,0x0B,	/* 54E8: #. ..... */
	0x00,0x0A,0x00,0x08,0x00,0x07,0x00,0x05,	/* 54F0: ........ */
	0x00,0x04,0x00,0x01,0x00,0x00,0x00,0x96,	/* 54F8: ....... */
	0x00,0x60,0xBF,0x72,0x2F,0x5C,0x20,0x20,	/* 5500: .`r.\   */
	0xD0,0x70,0x72,0x21,0xE6,0x70,0x60,0x51,	/* 5508: pr!p`Q */
	0x20,0x20,0x70,0x21,0xE3,0x70,0x61,0x5C,	/* 5510:   p!pa\ */
	0x20,0x20,0x70,0x21,0xE2,0x70,0x60,0x54,	/* 5518:   p!p`T */
	0x20,0x20,0x70,0x21,0xE1,0x70,0x60,0x53,	/* 5520:   p!p`S */
	0x20,0x20,0x70,0x21,0xE0,0x70,0x64,0x49,	/* 5528:   p!pdI */
	0x21,0xFB,0x4A,0x26,0x98,0x20,0x20,0xB1,	/* 5530: !J&   */
	0x22,0xF0,0x20,0x00,0x00,0x00,0x00,0x04,	/* 5538: " ..... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 5540: ........ */
	0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x60,	/* 5548: .......` */
	0xBD,0x41,0x76,0x77,0x24,0xFF,0xF0,0xC0,	/* 5550: Avw$ */
	0xA4,0x41,0xB3,0x22,0xF0,0x75,0xD0,0x75,	/* 5558: A"uu */
	0x76,0xF2,0x70,0xF9,0xA8,0x40,0x70,0xE0,	/* 5560: vp@p */
	0x70,0x51,0xD0,0x60,0x02,0x74,0x21,0x96,	/* 5568: pQ`.t! */
	0xD1,0x71,0x30,0xAE,0x71,0x71,0x30,0xF2,	/* 5570: q0qq0 */
	0xD1,0x71,0x51,0xD2,0x72,0xD0,0x74,0x9A,	/* 5578: qQrt */
	0x61,0x0F,0x40,0xB3,0x22,0xF0,0x08,0x20,	/* 5580: a.@".  */
	0x20,0x20,0x74,0xF6,0x20,0x02,0xB0,0x60,	/* 5588:   t .` */
	0x4A,0x21,0xFB,0x22,0xF0,0xB0,0x02,0x22,	/* 5590: J!"." */
	0xF0,0x18,0x00,0x00,0x00,0x71,0x60,0x8F,	/* 5598: ....q` */
	0xD1,0x71,0x60,0x4F,0xF9,0xAF,0x24,0xF2,	/* 55A0: q`O$ */
	0x71,0x72,0xFA,0x30,0x73,0xFA,0xE0,0x71,	/* 55A8: qr0sq */
	0x60,0x8F,0xD1,0x61,0x0C,0x22,0xF0,0x19,	/* 55B0: `a.". */
	0x00,0x00,0x00,0x60,0xB5,0x7C,0x21,0x39,	/* 55B8: ...`|!9 */
	0xDA,0x21,0x20,0x4D,0x21,0xFB,0xD9,0x7D,	/* 55C0: ! M!} */
	0x7E,0x24,0xFB,0xC0,0xA6,0x7A,0x3B,0x30,	/* 55C8: ~$z;0 */
	0xBB,0x22,0xF0,0x40,0x7E,0xF9,0xA5,0x60,	/* 55D0: "@~` */
	0x4F,0xBB,0x22,0xF0,0x40,0x7D,0x41,0x23,	/* 55D8: O"@}A# */
	0xF7,0xD2,0x7E,0x40,0x23,0xF7,0xD3,0x72,	/* 55E0: ~@#r */
	0x60,0x4E,0x24,0xF6,0xD2,0x73,0xD3,0x79,	/* 55E8: `N$sy */
	0x12,0x16,0x22,0x2F,0x99,0x20,0x7A,0x3C,	/* 55F0: ..". z< */
	0x30,0xD3,0x7A,0x50,0x7C,0x22,0x22,0x91,	/* 55F8: 0zP|"" */
	0x10,0xD5,0x7A,0x3D,0x30,0x21,0xA9,0x7A,	/* 5600: .z=0!z */
	0x3E,0x30,0x75,0xF9,0xC0,0xA6,0x75,0x7A,	/* 5608: >0uuz */
	0x3F,0x30,0xF9,0xA6,0x7A,0x21,0x30,0x30,	/* 5610: ?0z!00 */
	0xD4,0x02,0x75,0xD4,0x74,0x69,0x5A,0xD4,	/* 5618: .utiZ */
	0x7A,0x3B,0x30,0xD8,0x7A,0x3B,0x30,0x21,	/* 5620: z;0z;0! */
	0xFD,0xD0,0xD1,0x7A,0x21,0x31,0x30,0x21,	/* 5628: z!10! */
	0xFD,0xD2,0xD3,0x40,0x72,0x70,0x24,0xFF,	/* 5630: @rp$ */
	0xD2,0x73,0x71,0x24,0xFF,0xD3,0x7E,0x73,	/* 5638: sq$~s */
	0xF9,0xC0,0xAB,0x7E,0x73,0xF4,0xC0,0xA7,	/* 5640: ~s */
	0x41,0x7D,0x72,0x24,0xFF,0xF0,0xC0,0xC0,	/* 5648: A}r$ */
	0x23,0xA8,0x7A,0x21,0x31,0x30,0x24,0xF2,	/* 5650: #z!10$ */
	0xF4,0x22,0xAF,0x7A,0x3D,0x30,0x23,0xAA,	/* 5658: "z=0# */
	0x7A,0x3B,0x30,0x21,0xFD,0xD0,0xD1,0x74,	/* 5660: z;0!t */
	0x21,0xFD,0xD2,0xD3,0x40,0x72,0x70,0x24,	/* 5668: !@rp$ */
	0xFF,0xD2,0x73,0x71,0x24,0xFF,0xD3,0x7E,	/* 5670: sq$~ */
	0x73,0xF9,0xC0,0xAB,0x7E,0x73,0xF4,0xC0,	/* 5678: s~s */
	0xA7,0x41,0x7D,0x72,0x24,0xFF,0xF0,0xC0,	/* 5680: A}r$ */
	0x21,0xA0,0x7A,0x21,0x32,0x30,0xD3,0x7A,	/* 5688: !z!20z */
	0x50,0x7C,0x21,0x28,0x9C,0x60,0x4F,0xBB,	/* 5690: P|!(`O */
	0x22,0xF0,0x79,0x16,0x10,0x23,0x2C,0x93,	/* 5698: "y..#, */
	0x20,0x7A,0x3B,0x30,0x21,0xFD,0xD2,0xD3,	/* 56A0:  z;0! */
	0x40,0x72,0x70,0x23,0xF7,0xD2,0x73,0x71,	/* 56A8: @rp#sq */
	0x23,0xF7,0xD3,0x72,0x7A,0x3B,0xE0,0x7A,	/* 56B0: #rz;z */
	0x3D,0x30,0xA6,0x7A,0x3B,0x30,0x7A,0x3E,	/* 56B8: =0z;0z> */
	0xE0,0x7A,0x21,0x32,0x30,0xD3,0x7A,0x50,	/* 56C0: z!20zP */
	0x7C,0x21,0x25,0x95,0x78,0xBB,0x22,0xF0,	/* 56C8: |!%x" */
	0xBB,0x22,0xF0,0x02,0x00,0x00,0x00,0x60,	/* 56D0: "....` */
	0xBA,0x77,0x21,0x39,0x21,0x53,0xD5,0x78,	/* 56D8: w!9!Sx */
	0xD3,0x41,0x75,0x30,0x30,0x78,0x24,0xFF,	/* 56E0: Au00x$ */
	0xF0,0xC0,0xA4,0x75,0x30,0x30,0xD8,0x78,	/* 56E8: u00x */
	0xD0,0x40,0xD1,0x71,0x70,0x77,0x61,0x2C,	/* 56F0: @qpwa, */
	0x92,0x25,0xFA,0xD4,0x60,0xCF,0x22,0xA5,	/* 56F8: %`" */
	0x41,0x78,0x73,0x24,0xFF,0xF0,0xC0,0x21,	/* 5700: Axs$! */
	0xA7,0x73,0xD8,0x78,0xD0,0x40,0xD1,0x71,	/* 5708: sx@q */
	0x70,0x77,0x61,0x2A,0x96,0x25,0xFA,0xD4,	/* 5710: pwa*% */
	0x60,0xCF,0xAA,0x24,0xF2,0xB6,0x22,0xF0,	/* 5718: `$" */
	0x24,0xF2,0xB6,0x22,0xF0,0x74,0xD2,0x78,	/* 5720: $"tx */
	0x72,0xE1,0x75,0x31,0x31,0x75,0x31,0x31,	/* 5728: ru11u11 */
	0x31,0xF2,0x72,0xF4,0xC0,0x21,0xA0,0x75,	/* 5730: 1r!u */
	0x31,0x31,0x31,0x78,0xF2,0x75,0x31,0x31,	/* 5738: 111xu11 */
	0xE1,0x75,0x31,0x31,0xD2,0x21,0x00,0x72,	/* 5740: u11!.r */
	0x75,0x31,0x31,0xE0,0x72,0x75,0x31,0xE1,	/* 5748: u11ru1 */
	0x75,0x31,0x30,0x75,0x31,0x31,0xE0,0x72,	/* 5750: u10u11r */
	0xB6,0x22,0xF0,0x60,0xBB,0x76,0x21,0x39,	/* 5758: "`v!9 */
	0x21,0x54,0xD4,0x40,0xD2,0x77,0xC0,0xA5,	/* 5760: !T@w */
	0x24,0xF2,0xB5,0x22,0xF0,0x77,0x44,0xF2,	/* 5768: $"wD */
	0xD7,0x77,0x44,0xF2,0x60,0x4F,0xF2,0x60,	/* 5770: wD`O` */
	0x4C,0x24,0xF6,0xD7,0x74,0x30,0x30,0xD1,	/* 5778: L$t00 */
	0x74,0x30,0x30,0x30,0xD0,0x72,0xC0,0x25,	/* 5780: t000r% */
	0xA8,0x70,0x74,0x30,0x30,0xF4,0x23,0xAF,	/* 5788: pt00# */
	0x41,0x77,0x70,0x31,0x24,0xFF,0xF0,0x22,	/* 5790: Awp1$" */
	0xAF,0x70,0x31,0x77,0xF4,0xC0,0xA5,0x70,	/* 5798: p1wp */
	0x30,0x71,0xE0,0x0F,0x70,0x31,0x77,0xF4,	/* 57A0: 0q.p1w */
	0x70,0xE1,0x70,0x25,0xFA,0x31,0xF2,0xD0,	/* 57A8: pp%1 */
	0x77,0x70,0xE1,0x24,0xF2,0x81,0x70,0xE0,	/* 57B0: wp$p */
	0x70,0x74,0x30,0x31,0xF4,0xC0,0xA4,0x71,	/* 57B8: pt01q */
	0x74,0x30,0xE1,0x70,0x52,0xD3,0x41,0xD2,	/* 57C0: t0pRA */
	0x70,0xD1,0x70,0x30,0xD0,0x64,0x06,0x77,	/* 57C8: pp0d.w */
	0x76,0x6F,0x94,0x25,0xFA,0xD0,0x67,0x20,	/* 57D0: vo%g  */
	0x20,0xC0,0x65,0xA9,0x24,0xF2,0xB5,0x22,	/* 57D8:  e$" */
	0xF0,0x73,0xB5,0x22,0xF0,0x60,0xBD,0x74,	/* 57E0: s"`t */
	0x21,0x39,0x5C,0xD2,0x72,0x39,0x30,0xC0,	/* 57E8: !9\r90 */
	0x21,0xA5,0x72,0x3A,0x30,0xC0,0xA5,0x24,	/* 57F0: !r:0$ */
	0xF2,0xB3,0x22,0xF0,0x40,0xD0,0x72,0x3C,	/* 57F8: "@r< */
	0x30,0x72,0x3B,0x30,0x74,0x21,0x9C,0x72,	/* 5800: 0r;0t!r */
	0x30,0x30,0xD0,0x72,0x3D,0x74,0x21,0x97,	/* 5808: 00r=t! */
	0x75,0x74,0x6B,0x97,0xD1,0x72,0x36,0x30,	/* 5810: utkr60 */
	0xD0,0x72,0x3D,0x74,0x9A,0x71,0xB3,0x22,	/* 5818: r=tq" */
	0xF0,0x77,0xF6,0x63,0x28,0x01,0x20,0x74,	/* 5820: wc(. t */
	0xF6,0x01,0x00,0x00,0x00,0x00,0x00,0x01,	/* 5828: ....... */
	0x00,0x00,0x00,0x00,0x00,0x01,0x20,0x0A,	/* 5830: ...... . */
	0x00,0x08,0x00,0x07,0x00,0x05,0x00,0x04,	/* 5838: ........ */
	0x00,0x02,0x00,0x01,0x00,0x62,0x03,0x60,	/* 5840: .....b.` */
	0xBF,0x72,0x21,0x21,0x50,0x20,0xD0,0x70,	/* 5848: r!!P p */
	0x72,0x21,0xE9,0x62,0x42,0x21,0xFB,0x70,	/* 5850: r!bB!p */
	0x4D,0x24,0xFA,0x70,0x61,0x5F,0x20,0x20,	/* 5858: M$pa_   */
	0x70,0x21,0xE9,0x70,0x62,0x5E,0x20,0x20,	/* 5860: p!pb^   */
	0x70,0x21,0xE8,0x70,0x62,0x5D,0x20,0x20,	/* 5868: p!pb]   */
	0x70,0x21,0xE7,0x70,0x61,0x51,0x20,0x20,	/* 5870: p!paQ   */
	0x70,0x21,0xE6,0x70,0x61,0x5E,0x20,0x20,	/* 5878: p!pa^   */
	0x70,0x21,0xE5,0x70,0x61,0x5C,0x20,0x20,	/* 5880: p!pa\   */
	0x70,0x21,0xE4,0x70,0x61,0x52,0x20,0x20,	/* 5888: p!paR   */
	0x70,0x21,0xE3,0x70,0x61,0x54,0x20,0x20,	/* 5890: p!paT   */
	0x70,0x21,0xE2,0x70,0x61,0x50,0x20,0x20,	/* 5898: p!paP   */
	0x70,0x21,0xE1,0x70,0x62,0x57,0x20,0x20,	/* 58A0: p!pbW   */
	0x70,0x21,0xE0,0x70,0x62,0x5A,0x20,0x20,	/* 58A8: p!pbZ   */
	0x70,0xEF,0x70,0x62,0x59,0x20,0x20,0x70,	/* 58B0: ppbY  p */
	0xEE,0x70,0x62,0x58,0x20,0x20,0x70,0xED,	/* 58B8: pbX  p */
	0x70,0x61,0x53,0x20,0x20,0x70,0xEC,0x70,	/* 58C0: paS  pp */
	0x62,0x5F,0x20,0x20,0x70,0xEB,0x70,0x69,	/* 58C8: b_  ppi */
	0x44,0x21,0xFB,0x47,0x63,0x2C,0x96,0x20,	/* 58D0: D!Gc,  */
	0xB1,0x22,0xF0,0x20,0x60,0xBB,0x78,0xD0,	/* 58D8: " `x */
	0x77,0x11,0x13,0x21,0x9A,0x71,0x76,0xE0,	/* 58E0: w..!qv */
	0x72,0x76,0xE1,0xB5,0x22,0xF0,0x60,0xBB,	/* 58E8: rv"` */
	0x78,0xD0,0x77,0x13,0x11,0x99,0x71,0x76,	/* 58F0: xw..qv */
	0xE0,0x72,0x76,0xE1,0xB5,0x22,0xF0,0x60,	/* 58F8: rv"` */
	0xB2,0x21,0x71,0xDC,0x21,0x72,0xDB,0x40,	/* 5900: !q!r@ */
	0xDA,0x40,0xDD,0x7C,0x31,0x24,0xF2,0x24,	/* 5908: @|1$$ */
	0xF6,0x21,0xA3,0x41,0xDA,0x40,0x40,0x7C,	/* 5910: !A@@| */
	0x30,0x24,0xFF,0xD4,0xD5,0x75,0x40,0x7C,	/* 5918: 0$u@| */
	0x31,0x24,0xFF,0xD5,0xD1,0x08,0x40,0xDA,	/* 5920: 1$.@ */
	0x7C,0x30,0xD4,0x7C,0x31,0xD5,0x7B,0x31,	/* 5928: |0|1{1 */
	0x24,0xF2,0x24,0xF6,0x21,0xA4,0x7A,0xC0,	/* 5930: $$!z */
	0xDD,0x40,0x40,0x7B,0x30,0x24,0xFF,0xD2,	/* 5938: @@{0$ */
	0xD3,0x73,0x40,0x7B,0x31,0x24,0xFF,0xD3,	/* 5940: s@{1$ */
	0xD1,0x08,0x7A,0xDD,0x7B,0x30,0xD2,0x7B,	/* 5948: .z{0{ */
	0x31,0xD3,0x12,0xD0,0x14,0x18,0x16,0x23,	/* 5950: 1....# */
	0x9C,0x77,0x24,0xF2,0x24,0xF6,0xA5,0x7D,	/* 5958: w$$} */
	0xC0,0xA2,0x21,0xF0,0x7D,0xAE,0x40,0x40,	/* 5960: !}@@ */
	0x76,0x24,0xFF,0xD6,0xD1,0x71,0x40,0x77,	/* 5968: v$q@w */
	0x24,0xFF,0xD7,0xD1,0x7A,0xAE,0x40,0x40,	/* 5970: $z@@ */
	0x78,0x24,0xFF,0xD8,0xD1,0x71,0x40,0x79,	/* 5978: x$q@y */
	0x24,0xFF,0xD9,0xD1,0x76,0x7F,0xE0,0x77,	/* 5980: $vw */
	0x7F,0xE1,0x78,0x21,0x70,0xE0,0x79,0x21,	/* 5988: x!py! */
	0x70,0xE1,0xBE,0x22,0xF0,0x60,0xB5,0x7F,	/* 5990: p"` */
	0x30,0xC0,0xA8,0x7F,0x31,0xC0,0xA4,0x21,	/* 5998: 01! */
	0xF0,0x2B,0x0D,0x7F,0x31,0xC0,0x21,0xAA,	/* 59A0: +.1! */
	0x40,0x7E,0x31,0x7F,0x30,0x21,0xFA,0x7C,	/* 59A8: @~10!| */
	0xE1,0xD2,0x72,0x7E,0x30,0x7F,0x30,0x21,	/* 59B0: r~00! */
	0xFA,0x7C,0xE0,0x7D,0xE0,0x40,0x7D,0xE1,	/* 59B8: |}@} */
	0x29,0x0E,0x7F,0x31,0x7F,0x30,0x21,0xF9,	/* 59C0: ).10! */
	0xD7,0xD5,0xD6,0x77,0xD4,0x76,0xC0,0xAA,	/* 59C8: wv */
	0x40,0xD3,0x7E,0x31,0xD2,0x7E,0x30,0xD1,	/* 59D0: @~1~0 */
	0x21,0x01,0x40,0x7E,0x31,0x76,0x23,0xF6,	/* 59D8: !.@~1v# */
	0xD0,0xD3,0x7E,0x31,0x7E,0x30,0x76,0x23,	/* 59E0: ~1~0v# */
	0xF6,0xD1,0xD2,0x40,0x7C,0xE1,0x73,0x75,	/* 59E8: @|su */
	0xF4,0xC0,0xA5,0x60,0x4F,0x7C,0xE0,0x08,	/* 59F0: `O|. */
	0x73,0x72,0x75,0x21,0xFA,0x7C,0xE0,0xD0,	/* 59F8: sru!| */
	0x7C,0x30,0x24,0xA9,0x40,0x74,0x7C,0x30,	/* 5A00: |0$@t|0 */
	0x23,0xF1,0xD8,0xD9,0x79,0x75,0x7C,0x30,	/* 5A08: #yu|0 */
	0x23,0xF1,0xD9,0xDA,0x40,0x71,0x78,0x24,	/* 5A10: #@qx$ */
	0xFF,0xD1,0xD0,0x70,0x72,0x79,0x24,0xFF,	/* 5A18: pry$ */
	0xD2,0xD0,0x70,0x73,0x7A,0x24,0xFF,0xD3,	/* 5A20: psz$ */
	0xD0,0x73,0x24,0xF2,0x24,0xF6,0x21,0xAD,	/* 5A28: s$$! */
	0x7C,0x30,0x60,0x8F,0x7C,0xE0,0x40,0x74,	/* 5A30: |0`|@t */
	0x71,0x23,0xF7,0xD1,0xD0,0x70,0x75,0x72,	/* 5A38: q#pur */
	0x23,0xF7,0xD2,0xD0,0x70,0x40,0x73,0x23,	/* 5A40: #p@s# */
	0xF7,0xD3,0xD0,0x62,0x0C,0x76,0xC0,0xA7,	/* 5A48: b.v */
	0x71,0x7D,0xE0,0x72,0x7D,0xE1,0x09,0x72,	/* 5A50: q}r}.r */
	0x71,0x76,0x23,0xF5,0x7D,0xE0,0x7D,0xE1,	/* 5A58: qv#}} */
	0xBB,0x22,0xF0,0x60,0xBB,0x77,0xD4,0x78,	/* 5A60: "`wx */
	0xD3,0x40,0x73,0x30,0x74,0x30,0x23,0xF1,	/* 5A68: @s0t0# */
	0xD0,0xD2,0x72,0x73,0x30,0x74,0x31,0x23,	/* 5A70: rs0t1# */
	0xF1,0xD1,0xD2,0x71,0x73,0x31,0x74,0x30,	/* 5A78: qs1t0 */
	0x23,0xF1,0xD1,0xD2,0x70,0x76,0xE0,0x71,	/* 5A80: #pvq */
	0x76,0xE1,0xB5,0x22,0xF0,0x1A,0x00,0x00,	/* 5A88: v"... */
	0x00,0x60,0xBC,0x76,0xD3,0x78,0x24,0xAB,	/* 5A90: .`vx$ */
	0x41,0x21,0x40,0x78,0x24,0xFF,0xF0,0xC0,	/* 5A98: A!@x$ */
	0xA3,0x78,0x40,0xA3,0x21,0x40,0x40,0xF4,	/* 5AA0: x@!@@ */
	0xD0,0x40,0xD2,0x70,0x72,0xF9,0xAB,0x77,	/* 5AA8: @prw */
	0x76,0x72,0xF5,0x23,0xFB,0x72,0x81,0xD2,	/* 5AB0: vr#r */
	0x60,0x01,0x70,0xD1,0x78,0x70,0xF4,0xD8,	/* 5AB8: `.pxp */
	0x78,0x22,0xA0,0x41,0x71,0x78,0x24,0xFF,	/* 5AC0: x"Aqx$ */
	0xF0,0xC0,0xA3,0x78,0x40,0xA2,0x71,0x40,	/* 5AC8: x@q@ */
	0xF4,0xD0,0x76,0x76,0x71,0xF5,0x70,0x24,	/* 5AD0: vvqp$ */
	0xFA,0x71,0x70,0xF5,0xD1,0x78,0x70,0xF4,	/* 5AD8: qpxp */
	0xD8,0x62,0x0D,0x73,0xB4,0x22,0xF0,0x70,	/* 5AE0: b.s"p */
	0x72,0xE0,0x10,0x72,0xE1,0x40,0x22,0xF0,	/* 5AE8: r.r@" */
	0x72,0x30,0x72,0x31,0xE0,0x73,0xC0,0xA2,	/* 5AF0: r0r1s */
	0x41,0xD3,0x73,0x72,0x31,0xE1,0x72,0x31,	/* 5AF8: Asr1r1 */
	0x23,0xFC,0x71,0x22,0xF0,0x20,0x22,0xF9,	/* 5B00: #q" " */
	0x71,0x32,0xF6,0x22,0xF0,0x22,0xF9,0x72,	/* 5B08: q2""r */
	0x31,0xF6,0x22,0xF0,0x22,0xF9,0x72,0x31,	/* 5B10: 1""r1 */
	0xF6,0x22,0xF0,0x40,0x40,0x60,0xBB,0x73,	/* 5B18: "@@`s */
	0x36,0x73,0x34,0x60,0xEF,0x10,0x73,0x57,	/* 5B20: 6s4`.sW */
	0x41,0xFB,0x21,0xF5,0x20,0x1B,0x00,0x00,	/* 5B28: A! ... */
	0x00,0x60,0xBF,0x73,0x57,0x21,0xF2,0xD0,	/* 5B30: .`sW! */
	0x70,0x67,0x20,0x20,0xC0,0xA4,0x41,0xB1,	/* 5B38: pg  A */
	0x22,0xF0,0x40,0xB1,0x22,0xF0,0x72,0x71,	/* 5B40: "@"rq */
	0x61,0x97,0xA5,0x41,0x4B,0x71,0x24,0x9F,	/* 5B48: aAKq$ */
	0x71,0x21,0x3B,0x30,0x72,0x34,0xE0,0x70,	/* 5B50: q!;0r4p */
	0x72,0xE1,0x72,0x34,0x21,0xFE,0x24,0xFB,	/* 5B58: rr4!$ */
	0x23,0xF9,0x22,0xF0,0x72,0x71,0x63,0x99,	/* 5B60: #"rqc */
	0xA5,0x41,0x4B,0x71,0x23,0x91,0x71,0x21,	/* 5B68: AKq#q! */
	0x3B,0x30,0x72,0x34,0xE0,0x70,0x72,0xE1,	/* 5B70: ;0r4pr */
	0x72,0x34,0x60,0x4E,0x24,0xF6,0x23,0xF9,	/* 5B78: r4`N$# */
	0x22,0xF0,0x72,0x71,0x65,0x9B,0xA5,0x41,	/* 5B80: "rqeA */
	0x4B,0x71,0x21,0x93,0x71,0x21,0x3B,0x30,	/* 5B88: Kq!q!;0 */
	0x72,0x34,0xE0,0x70,0x72,0xE1,0x72,0x34,	/* 5B90: r4prr4 */
	0x41,0x24,0xFB,0x23,0xF9,0x22,0xF0,0x29,	/* 5B98: A$#") */
	0x0A,0x20,0x20,0x68,0x08,0x20,0x20,0x60,	/* 5BA0: .  h.  ` */
	0x00,0x60,0xBF,0x72,0x21,0x22,0x5A,0x20,	/* 5BA8: .`r!"Z  */
	0xD0,0x70,0x72,0x21,0xEB,0x4B,0x21,0xFB,	/* 5BB0: pr!K! */
	0x48,0x21,0xFB,0x30,0xF2,0x70,0xE0,0xB1,	/* 5BB8: H!0p */
	0x22,0xF0,0x20,0x5A,0xFF,0x1C,0x00,0x00,	/* 5BC0: " Z... */
	0x00,0x60,0xBF,0x72,0x21,0x3C,0xD0,0x73,	/* 5BC8: .`r!<s */
	0xA5,0x73,0x70,0x31,0xE0,0x07,0x22,0x27,	/* 5BD0: sp1."' */
	0x20,0x4F,0x70,0x31,0xE0,0x73,0x70,0x32,	/* 5BD8:  Op1sp2 */
	0x72,0x21,0x9B,0xB1,0x22,0xF0,0x60,0xBD,	/* 5BE0: r!"` */
	0x74,0x21,0x3C,0xD2,0x72,0x30,0x24,0xF2,	/* 5BE8: t!<r0$ */
	0xF4,0xA5,0x72,0x30,0xD0,0x74,0x9B,0x75,	/* 5BF0: r0tu */
	0x74,0x63,0x9E,0xB3,0x22,0xF0,0x61,0x2E,	/* 5BF8: tc"a. */
	0x0F,0x20,0x74,0xF6,0x20,0x00,0x00,0x00,	/* 5C00: . t ... */
	0x00,0x60,0xBF,0x72,0x21,0x22,0x5B,0x20,	/* 5C08: .`r!"[  */
	0xD0,0x70,0x72,0x21,0xEC,0x70,0x64,0x58,	/* 5C10: pr!pdX */
	0x20,0x20,0x70,0xE2,0x70,0x64,0x5A,0x20,	/* 5C18:   ppdZ  */
	0x20,0x70,0xE1,0x70,0x62,0x4D,0x21,0xFB,	/* 5C20:  ppbM! */
	0x41,0x66,0x27,0x91,0x20,0xB1,0x22,0xF0,	/* 5C28: Af' " */
	0x20,0x1D,0x00,0x00,0x00,0x21,0x9A,0x20,	/* 5C30:  ....!  */
	0x20,0x22,0xF0,0x60,0xBE,0x24,0xF2,0xD0,	/* 5C38:  "`$ */
	0x75,0xD1,0x24,0xF2,0x24,0xF2,0x73,0x61,	/* 5C40: u$$sa */
	0x9C,0xB2,0x22,0xF0,0x20,0x1E,0x00,0x00,	/* 5C48: " ... */
	0x00,0x25,0xF8,0x21,0xF0,0x22,0xF0,0x20,	/* 5C50: .%!"  */
	0x60,0xBB,0x21,0xFE,0x21,0xAC,0x24,0xF2,	/* 5C58: `!!$ */
	0xD4,0x10,0xD1,0x48,0x21,0xFB,0xD2,0x13,	/* 5C60: .H!. */
	0x23,0xF9,0x10,0x14,0x41,0xFB,0x24,0xF3,	/* 5C68: #..A$ */
	0x11,0x41,0x24,0xF8,0x24,0xF4,0x60,0x7E,	/* 5C70: .A$$`~ */
	0x23,0xFC,0x78,0x7B,0x33,0xF2,0x7B,0xE3,	/* 5C78: #x{3{ */
	0x76,0x7B,0xE6,0x77,0x7B,0xE7,0x40,0xD3,	/* 5C80: v{w{@ */
	0x42,0xD4,0x73,0xC0,0xA4,0x7B,0x39,0xD1,	/* 5C88: Bs{9 */
	0x03,0x7B,0x3A,0xD1,0x71,0x79,0xF9,0x24,	/* 5C90: .{:qy$ */
	0xAE,0x71,0x24,0xF2,0x23,0xF3,0x41,0x24,	/* 5C98: q$#A$ */
	0xF0,0x24,0xF2,0xFA,0xD0,0x78,0x70,0x33,	/* 5CA0: $xp3 */
	0xF2,0x70,0xE3,0x78,0x70,0x34,0xF2,0x70,	/* 5CA8: pxp4p */
	0xE4,0x73,0x22,0xAC,0x70,0x31,0x42,0x24,	/* 5CB0: s"p1B$ */
	0xF6,0x21,0xA4,0x70,0x37,0x4A,0x21,0xFB,	/* 5CB8: !p7J! */
	0xF0,0xE0,0x70,0x34,0x70,0x37,0x23,0xFC,	/* 5CC0: p4p7# */
	0xD4,0xF6,0x70,0x23,0xFC,0x21,0x01,0x70,	/* 5CC8: p#!.p */
	0x34,0x70,0x37,0x60,0xEF,0x70,0x37,0x70,	/* 5CD0: 4p7`p7p */
	0x31,0x41,0x24,0xF6,0xC0,0xF5,0x23,0xF9,	/* 5CD8: 1A$# */
	0x70,0x3E,0xD2,0x72,0xD1,0x65,0x0D,0x13,	/* 5CE0: p>re.. */
	0x26,0x42,0x22,0xF1,0x21,0xF5,0xB5,0x22,	/* 5CE8: &B"!" */
	0xF0,0x60,0xBC,0x75,0x3F,0xD0,0x70,0x24,	/* 5CF0: `u?p$ */
	0xF2,0x23,0xF3,0x41,0x24,0xF0,0x24,0xF2,	/* 5CF8: #A$$ */
	0xFA,0xD3,0x73,0x39,0xD1,0x71,0x73,0x34,	/* 5D00: s9qs4 */
	0xF9,0x23,0xAF,0x71,0x24,0xF2,0x23,0xF3,	/* 5D08: #q$# */
	0x41,0x24,0xF0,0x24,0xF2,0xFA,0xD0,0x70,	/* 5D10: A$$p */
	0x31,0x42,0x24,0xF6,0x21,0xA4,0x70,0x37,	/* 5D18: 1B$!p7 */
	0x4A,0x21,0xFB,0xF0,0xE0,0x70,0x34,0x70,	/* 5D20: J!p4p */
	0x37,0x23,0xFC,0xD4,0xF6,0x70,0x23,0xFC,	/* 5D28: 7#p# */
	0x21,0x01,0x70,0x34,0x70,0x37,0x60,0xEF,	/* 5D30: !.p4p7` */
	0x70,0x37,0x70,0x31,0x41,0x24,0xF6,0xC0,	/* 5D38: p7p1A$ */
	0xF5,0x23,0xF9,0x70,0x3E,0xD2,0x72,0xD1,	/* 5D40: #p>r */
	0x64,0x0B,0xB4,0x22,0xF0,0x65,0x23,0x20,	/* 5D48: d."e#  */
	0x0E,0x20,0x20,0x00,0x00,0x60,0x06      	/* 5D50: .  ..`.  */

};
int si3_t225_dsize = sizeof(si3_t225_download);		/* 0x5D57 (23895) */

unsigned short si3_t225_downloadaddr = 0x0000;

/* End of SI3_T225.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\qsfile.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    qsfile.c

Abstract:

    This module contains the code that is very specific to query/set file
    operations in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is returned with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialQueryInformationFile dispatch entry for: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
        
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    if(IrpSp->Parameters.QueryFile.FileInformationClass == FileStandardInformation)
	{

        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize = RtlConvertUlongToLargeInteger(0ul);
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } 
	else
	{
		if(IrpSp->Parameters.QueryFile.FileInformationClass == FilePositionInformation)
		{
			((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset 
				= RtlConvertUlongToLargeInteger(0ul);

			Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

		} 
		else 
		{
			Status = STATUS_INVALID_PARAMETER;
		}
	}

	Irp->IoStatus.Status = Status;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,9);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;
}

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened serial port.  Any other file information request
    is returned with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialSetInformationFile dispatch entry for: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
    
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    if((IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation) 
		|| (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileAllocationInformation)) 
	{
        Status = STATUS_SUCCESS;
    } 
	else 
	{
        Status = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = Status;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,10);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\read.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to read
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    );

ULONG
SerialGetCharsFromIntBuffer(
    PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    );

NTSTATUS
SerialResizeBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

ULONG
SerialMoveToNewIntBuffer(
    PPORT_DEVICE_EXTENSION pPort,
    PUCHAR NewBuffer
    );

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    );


NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialRead dispatch entry for: %x\n",Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
       
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length read.  If it is zero length
    // then we are already done!
    //

    SpxDbgMsg(SERDIAG1,("Read length: %d\n",IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length));
        
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) 
	{

        //
        // Well it looks like we actually have to do some
        // work.  Put the read on the queue so that we can
        // process it when our previous reads are done.
        //

        return SerialStartOrQueue(
                   pPort,
                   Irp,
                   &pPort->ReadQueue,
                   &pPort->CurrentReadIrp,
                   SerialStartRead
                   );

    } 
	else 
	{

        Irp->IoStatus.Status = STATUS_SUCCESS;
        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,11);
#endif

		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
		IoCompleteRequest(Irp, 0);

        return STATUS_SUCCESS;

    }

}

NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

Arguments:

    pPort - Simply a pointer to the serial device extension.

Return Value:

    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.

--*/

{

    SERIAL_UPDATE_CHAR updateChar;

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;


    updateChar.pPort = pPort;

    do {

        //
        // Check to see if this is a resize request.  If it is
        // then go to a routine that specializes in that.
        //

        if (IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)
            ->MajorFunction != IRP_MJ_READ) {

            NTSTATUS localStatus = SerialResizeBuffer(pPort);

            if (!setFirstStatus) {

                firstStatus = localStatus;
                setFirstStatus = TRUE;

            }

        } else {

            pPort->NumberNeededForRead =
                IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)
                    ->Parameters.Read.Length;

            //
            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.
            //

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            os2ssreturn = FALSE;
            crunchDownToOne = FALSE;
            useIntervalTimer = FALSE;


            //
            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been set.
            //

            KeInitializeTimer(&pPort->ReadRequestTotalTimer);
            KeInitializeTimer(&pPort->ReadRequestIntervalTimer);

            //
            // We get the *current* timeout values to use for timing
            // this read.
            //

            KeAcquireSpinLock(
                &pPort->ControlLock,
                &controlIrql
                );

            timeoutsForIrp = pPort->Timeouts;

            KeReleaseSpinLock(
                &pPort->ControlLock,
                controlIrql
                );

            //
            // Calculate the interval timeout for the read.
            //

            if (timeoutsForIrp.ReadIntervalTimeout &&
                (timeoutsForIrp.ReadIntervalTimeout !=
                 MAXULONG)) {

                useIntervalTimer = TRUE;

                pPort->IntervalTime = RtlEnlargedUnsignedMultiply(
                                             timeoutsForIrp.ReadIntervalTimeout,
                                             10000
                                             );


                if (RtlLargeIntegerGreaterThanOrEqualTo(
                        pPort->IntervalTime,
                        pPort->CutOverAmount
                        )) {

                    pPort->IntervalTimeToUse =
                        &pPort->LongIntervalAmount;

                } else {

                    pPort->IntervalTimeToUse =
                        &pPort->ShortIntervalAmount;

                }

            }

            if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {

                //
                // We need to do special return quickly stuff here.
                //
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                //
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                //
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.
                //

                if (!timeoutsForIrp.ReadTotalTimeoutConstant &&
                    !timeoutsForIrp.ReadTotalTimeoutMultiplier) {

                    returnWithWhatsPresent = TRUE;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            != MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            == MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            } else {

                //
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.
                //

                if (timeoutsForIrp.ReadTotalTimeoutMultiplier ||
                    timeoutsForIrp.ReadTotalTimeoutConstant) {

                    //
                    // We have some timer values to calculate.
                    //

                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            }

            if (useTotalTimer) {

                totalTime = RtlEnlargedUnsignedMultiply(
                                pPort->NumberNeededForRead,
                                multiplierVal
                                );

                totalTime = RtlLargeIntegerAdd(
                                totalTime,
                                RtlConvertUlongToLargeInteger(
                                    constantVal
                                    )
                                );

                totalTime = RtlExtendedIntegerMultiply(
                                totalTime,
                                -10000
                                );

            }


            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //

            KeAcquireSpinLock(
                &pPort->ControlLock,
                &controlIrql
                );

            updateChar.CharsCopied = SerialGetCharsFromIntBuffer(pPort);

            //
            // See if we have any cause to return immediately.
            //

            if (returnWithWhatsPresent || (!pPort->NumberNeededForRead) ||
                (os2ssreturn &&
                 pPort->CurrentReadIrp->IoStatus.Information)) {

                //
                // We got all we needed for this read.
                // Update the number of characters in the
                // interrupt read buffer.
                //

		Slxos_SyncExec(pPort,SerialUpdateInterruptBuffer,&updateChar,0x18);

                KeReleaseSpinLock(
                    &pPort->ControlLock,
                    controlIrql
                    );

                pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                if (!setFirstStatus) {

                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;

                }

            } else {

                //
                // The irp might go under control of the isr.  It
                // won't hurt to initialize the reference count
                // right now.
                //

                SERIAL_INIT_REFERENCE(pPort->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be cancelled.
                //

                if (pPort->CurrentReadIrp->Cancel) {

                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(
                        &pPort->ControlLock,
                        controlIrql
                        );
                    pPort->CurrentReadIrp->IoStatus.Status =
                        STATUS_CANCELLED;
                    pPort->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus) {

                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;

                    }

                } else {

                    //
                    // If we are supposed to crunch the read down to
                    // one character, then update the read length
                    // in the irp and truncate the number needed for
                    // read down to one. Note that if we are doing
                    // this crunching, then the information must be
                    // zero (or we would have completed above) and
                    // the number needed for the read must still be
                    // equal to the read length.
                    //

                    if (crunchDownToOne) {

                        ASSERT(
                            (!pPort->CurrentReadIrp->IoStatus.Information)
                            &&
                            (pPort->NumberNeededForRead ==
                                IoGetCurrentIrpStackLocation(
                                    pPort->CurrentReadIrp
                                    )->Parameters.Read.Length)
                            );

                        pPort->NumberNeededForRead = 1;
                        IoGetCurrentIrpStackLocation(
                            pPort->CurrentReadIrp
                            )->Parameters.Read.Length = 1;

                    }

                    //
                    // We still need to get more characters for this read.
                    // Synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the user's buffer.
                    //

		Slxos_SyncExec(pPort,SerialUpdateAndSwitchToUser,&updateChar,0x19);

		if (!updateChar.Completed) {

                        //
                        // The irp still isn't complete.  The
                        // completion routines will end up reinvoking
                        // this routine.  So we simply leave.
                        //
                        // First though we should start off the total
                        // timer for the read and increment the reference
                        // count that the total timer has on the current
                        // irp.  Note that this is safe, because even if
                        // the io has been satisfied by the isr it can't
                        // complete yet because we still own the cancel
                        // spinlock.
                        //

                        if (useTotalTimer) {

                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeSetTimer(
                                &pPort->ReadRequestTotalTimer,
                                totalTime,
                                &pPort->TotalReadTimeoutDpc
                                );

                        }

                        if (useIntervalTimer) {

                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeQuerySystemTime(
                                &pPort->LastReadTime
                                );
                            KeSetTimer(
                                &pPort->ReadRequestIntervalTimer,
                                *pPort->IntervalTimeToUse,
                                &pPort->IntervalReadTimeoutDpc
                                );

                        }

                        IoMarkIrpPending(pPort->CurrentReadIrp);
                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &pPort->ControlLock,
                            controlIrql
                            );
                        if (!setFirstStatus) {

                            firstStatus = STATUS_PENDING;

                        }
                        return firstStatus;

                    } else {

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &pPort->ControlLock,
                            controlIrql
                            );
                        pPort->CurrentReadIrp->IoStatus.Status =
                            STATUS_SUCCESS;

                        if (!setFirstStatus) {

                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;

                        }

                    }

                }

            }

        }

        //
        // Well the operation is complete.
        //

        SerialGetNextIrp(pPort, &pPort->CurrentReadIrp, &pPort->ReadQueue, &newIrp, TRUE);
            
    } while (newIrp);

    return firstStatus;

}

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    isr.  If it finds that the isr still owns the irp it grabs
    the irp away (updating the number of characters copied into the
    user's buffer).  If it grabs it away it also decrements the
    reference count on the irp since it no longer belongs to the
    isr (and the dpc that would complete it).

    NOTE: This routine assumes that if the current buffer that the
          ISR is copying characters into is the interrupt buffer then
          the dpc has already been queued.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->ReadBufferBase !=
        pPort->InterruptReadBuffer) {

        //
        // We need to set the information to the number of characters
        // that the read wanted minus the number of characters that
        // didn't get read into the interrupt buffer.
        //

        pPort->CurrentReadIrp->IoStatus.Information =
            IoGetCurrentIrpStackLocation(
                pPort->CurrentReadIrp
                )->Parameters.Read.Length -
            ((pPort->LastCharSlot - pPort->CurrentCharSlot) + 1);

        //
        // Switch back to the interrupt buffer.
        //

        pPort->ReadBufferBase = pPort->InterruptReadBuffer;
        pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
        pPort->FirstReadableChar = pPort->InterruptReadBuffer;
        pPort->LastCharSlot = pPort->InterruptReadBuffer +
                                      (pPort->BufferSize - 1);
    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
        pPort->CharsInInterruptBuffer = 0;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

        SERIAL_DEC_REFERENCE(pPort->CurrentReadIrp);

    }

    return FALSE;

}

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the count of characters read
    by the isr since the last interval timer experation.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->CountOnLastRead = pPort->ReadByIsr;
    pPort->ReadByIsr = 0;

    return FALSE;

}

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last time this routine was invoked (this dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    if (pPort->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) {

        //
        // This value is only set by the total
        // timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } else if (pPort->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) {

        //
        // This value is only set by the regular
        // completion routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } else if (pPort->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) {

        //
        // This value is only set by the cancel
        // read routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } else if (pPort->CountOnLastRead || pPort->ReadByIsr) {

        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if (pPort->ReadByIsr) {

	    Slxos_SyncExec(pPort,SerialUpdateReadByIsr,pPort,0x1A);

            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(
                &pPort->LastReadTime
                );

            KeSetTimer(
                &pPort->ReadRequestIntervalTimer,
                *pPort->IntervalTimeToUse,
                &pPort->IntervalReadTimeoutDpc
                );

            IoReleaseCancelSpinLock(oldIrql);

        } else {

            //
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(
                &currentTime
                );

            if (RtlLargeIntegerGreaterThanOrEqualTo(
                    RtlLargeIntegerSubtract(
                        currentTime,
                        pPort->LastReadTime
                        ),
                    pPort->IntervalTime
                    )) {

                SerialTryToCompleteCurrent(
                    pPort,
                    SerialGrabReadFromIsr,
                    oldIrql,
                    STATUS_TIMEOUT,
                    &pPort->CurrentReadIrp,
                    &pPort->ReadQueue,
                    &pPort->ReadRequestIntervalTimer,
                    &pPort->ReadRequestTotalTimer,
                    SerialStartRead,
                    SerialGetNextIrp
                    );

            } else {

                KeSetTimer(
                    &pPort->ReadRequestIntervalTimer,
                    *pPort->IntervalTimeToUse,
                    &pPort->IntervalReadTimeoutDpc
                    );
                IoReleaseCancelSpinLock(oldIrql);

            }


        }

    } else {

        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

        KeSetTimer(
            &pPort->ReadRequestIntervalTimer,
            *pPort->IntervalTimeToUse,
            &pPort->IntervalReadTimeoutDpc
            );

        IoReleaseCancelSpinLock(oldIrql);

    }


}

ULONG
SerialGetCharsFromIntBuffer(
    PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the user's buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    //
    // This value will be the number of characters that this
    // routine returns.  It will be the minimum of the number
    // of characters currently in the buffer or the number of
    // characters required for the read.
    //
    ULONG numberOfCharsToGet;

    //
    // This holds the number of characters between the first
    // readable character and the last character we will read or
    // the real physical end of the buffer (not the last readable
    // character).
    //
    ULONG firstTryNumberToGet;


    //
    // The minimum of the number of characters we need and
    // the number of characters available
    //

    numberOfCharsToGet = pPort->CharsInInterruptBuffer;

    if (numberOfCharsToGet > pPort->NumberNeededForRead) {

        numberOfCharsToGet = pPort->NumberNeededForRead;

    }

    if (numberOfCharsToGet) {

        //
        // This will hold the number of characters between the
        // first available character and the end of the buffer.
        // Note that the buffer could wrap around but for the
        // purposes of the first copy we don't care about that.
        //

        firstTryNumberToGet = (pPort->LastCharSlot -
                               pPort->FirstReadableChar) + 1;

        if (firstTryNumberToGet > numberOfCharsToGet) {

            //
            // The characters don't wrap. Actually they may wrap but
            // we don't care for the purposes of this read since the
            // characters we need are available before the wrap.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                numberOfCharsToGet
                );

            pPort->NumberNeededForRead -= numberOfCharsToGet;

            //
            // We now will move the pointer to the first character after
            // what we just copied into the user's buffer.
            //
            // We need to check if the stream of readable characters
            // is wrapping around to the beginning of the buffer.
            //
            // Note that we may have just taken the last characters
            // at the end of the buffer.
            //

            if ((pPort->FirstReadableChar + (numberOfCharsToGet - 1)) ==
                pPort->LastCharSlot) {

                pPort->FirstReadableChar = pPort->InterruptReadBuffer;

            } else {

                pPort->FirstReadableChar += numberOfCharsToGet;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                firstTryNumberToGet
                );

            pPort->NumberNeededForRead -= firstTryNumberToGet;

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->InterruptReadBuffer,
                numberOfCharsToGet - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                           (numberOfCharsToGet -
                                            firstTryNumberToGet);

            pPort->NumberNeededForRead -= (numberOfCharsToGet -
                                               firstTryNumberToGet);

        }

    }

    pPort->CurrentReadIrp->IoStatus.Information += numberOfCharsToGet;
    return numberOfCharsToGet;

}

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the number of characters that
    remain in the interrupt buffer.  We need to use this routine
    since the count could be updated during the update by execution
    of the ISR.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension and count of the number of characters
              that we previously copied into the user's buffer.  The
              structure actually has a third field that we don't
              use in this routine.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR update = Context;
    PPORT_DEVICE_EXTENSION pPort = update->pPort;

    ASSERT(pPort->CharsInInterruptBuffer >= update->CharsCopied);
    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
	pPort->CharsInInterruptBuffer -= update->CharsCopied;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    //
    // Deal with flow control if necessary.
    //

    SerialHandleReducedIntBuffer(pPort);


    return FALSE;

}

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the user's buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the user's buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR updateChar = Context;
    PPORT_DEVICE_EXTENSION pPort = updateChar->pPort;

    SerialUpdateInterruptBuffer(Context);

    //
    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got
    // the last batch.
    //

    updateChar->CharsCopied = SerialGetCharsFromIntBuffer(pPort);

    SerialUpdateInterruptBuffer(Context);

    //
    // No more new characters will be "received" until we exit
    // this routine.  We again check to make sure that we
    // haven't satisfied this read, and if we haven't we set things
    // up so that the ISR copies into the user buffer.
    //

    if (pPort->NumberNeededForRead) {

        //
        // We shouldn't be switching unless there are no
        // characters left.
        //

        ASSERT(!pPort->CharsInInterruptBuffer);

        //
        // We use the following two values to do interval timing.
        //
        // CountOnLastRead is mostly used to simply prevent
        // the interval timer from timing out before any characters
        // are read.  (Interval timing should only be effective
        // after the first character is read.)
        //
        // After the first time the interval timer fires and
        // characters have be read we will simply update with
        // the value of ReadByIsr and then set ReadByIsr to zero.
        // (We do that in a synchronization routine.)
        //
        // If the interval timer dpc routine ever encounters
        // ReadByIsr == 0 when CountOnLastRead is non-zero it
        // will timeout the read.
        //
        // (Note that we have a special case of CountOnLastRead
        // < 0.  This is done by the read completion routines other
        // than the total timeout dpc to indicate that the total
        // timeout has expired.)
        //

        pPort->CountOnLastRead =
            pPort->CurrentReadIrp->IoStatus.Information;

        pPort->ReadByIsr = 0;

        //
        // By comparing the read buffer base address to the
        // the base address of the interrupt buffer the ISR
        // can determine whether we are using the interrupt
        // buffer or the user buffer.
        //

        pPort->ReadBufferBase =
            pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;

        //
        // The current char slot is after the last copied in
        // character.  We know there is always room since we
        // we wouldn't have gotten here if there wasn't.
        //

        pPort->CurrentCharSlot = pPort->ReadBufferBase +
            pPort->CurrentReadIrp->IoStatus.Information;

        //
        // The last position that a character can go is on the
        // last byte of user buffer.  While the actual allocated
        // buffer space may be bigger, we know that there is at
        // least as much as the read length.
        //

        pPort->LastCharSlot = pPort->ReadBufferBase +
                                      (IoGetCurrentIrpStackLocation(
                                          pPort->CurrentReadIrp
                                          )->Parameters.Read.Length
                                       - 1);

        //
        // Mark the irp as being in a cancellable state.
        //

        IoSetCancelRoutine(
            pPort->CurrentReadIrp,
            SerialCancelCurrentRead
            );

        //
        // Increment the reference count twice.
        //
        // Once for the Isr owning the irp and once
        // because the cancel routine has a reference
        // to it.
        //

        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);
        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

        updateChar->Completed = FALSE;

    } else {

        updateChar->Completed = TRUE;

    }

    return FALSE;

}
//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS {
    PPORT_DEVICE_EXTENSION pPort;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;
    } SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;

NTSTATUS
SerialResizeBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    pPort - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

--*/

{

    PSERIAL_QUEUE_SIZE rs = pPort->CurrentReadIrp->AssociatedIrp
                                                       .SystemBuffer;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(
                                   pPort->CurrentReadIrp
                                   );
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    pPort->CurrentReadIrp->IoStatus.Information = 0L;
    pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if (rs->InSize <= pPort->BufferSize) {

        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //

        SpxFreeMem(newBuffer);

    } else {

        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.pPort = pPort;
        rp.OldBuffer = pPort->InterruptReadBuffer;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(
            &pPort->ControlLock,
            &controlIrql
            );

        rp.NumberMoved = SerialMoveToNewIntBuffer(
                             pPort,
                             newBuffer
                             );

	Slxos_SyncExec(pPort,SerialUpdateAndSwitchToNew,&rp,0x1C);

        KeReleaseSpinLock(
            &pPort->ControlLock,
            controlIrql
            );

        //
        // Free up the memory that the old buffer consumed.
        //

        SpxFreeMem(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}

ULONG
SerialMoveToNewIntBuffer(
    PPORT_DEVICE_EXTENSION pPort,
    PUCHAR NewBuffer
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the "new" buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.
    NewBuffer - Where the characters are to be move to.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    ULONG numberOfCharsMoved = pPort->CharsInInterruptBuffer;

    if (numberOfCharsMoved) {

        //
        // This holds the number of characters between the first
        // readable character and the last character we will read or
        // the real physical end of the buffer (not the last readable
        // character).
        //
        ULONG firstTryNumberToGet = (pPort->LastCharSlot -
                                     pPort->FirstReadableChar) + 1;

        if (firstTryNumberToGet >= numberOfCharsMoved) {

            //
            // The characters don't wrap.
            //

            RtlMoveMemory(
                NewBuffer,
                pPort->FirstReadableChar,
                numberOfCharsMoved
                );

            if ((pPort->FirstReadableChar+(numberOfCharsMoved-1)) ==
                pPort->LastCharSlot) {

                pPort->FirstReadableChar = pPort->InterruptReadBuffer;

            } else {

                pPort->FirstReadableChar += numberOfCharsMoved;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                NewBuffer,
                pPort->FirstReadableChar,
                firstTryNumberToGet
                );

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                NewBuffer+firstTryNumberToGet,
                pPort->InterruptReadBuffer,
                numberOfCharsMoved - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                   numberOfCharsMoved - firstTryNumberToGet;

        }

    }

    return numberOfCharsMoved;

}

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_RESIZE_PARAMS params = Context;
    PPORT_DEVICE_EXTENSION pPort = params->pPort;
    ULONG tempCharsInInterruptBuffer = pPort->CharsInInterruptBuffer;

    ASSERT(pPort->CharsInInterruptBuffer >= params->NumberMoved);

    //
    // We temporarily reduce the chars in interrupt buffer to
    // "fool" the move routine.  We will restore it after the
    // move.
    //

    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
	pPort->CharsInInterruptBuffer -= params->NumberMoved;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    if (pPort->CharsInInterruptBuffer) {

        SerialMoveToNewIntBuffer(
            pPort,
            params->NewBuffer + params->NumberMoved
            );

    }

    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
	pPort->CharsInInterruptBuffer = tempCharsInInterruptBuffer;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    pPort->LastCharSlot = params->NewBuffer + (params->NewBufferSize - 1);
    pPort->FirstReadableChar = params->NewBuffer;
    pPort->ReadBufferBase = params->NewBuffer;
    pPort->InterruptReadBuffer = params->NewBuffer;
    pPort->BufferSize = params->NewBufferSize;

    //
    // We *KNOW* that the new interrupt buffer is larger than the
    // old buffer.  We don't need to worry about it being full.
    //

    pPort->CurrentCharSlot = pPort->InterruptReadBuffer +
                                 pPort->CharsInInterruptBuffer;

    //
    // We set up the default xon/xoff limits.
    //

    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2))+
                                   (pPort->BufferSize>>4));

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif                                 

    //
    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    //

    SerialHandleReducedIntBuffer(pPort);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\slxos_nt.c ===
/*

    #########     ##              ##        ##      ########        #########
   ##########     ##              ##        ##     ##########      ##########
  ##              ##                ##    ##      ##        ##    ##
  ##              ##                ##    ##      ##        ##    ##
   #########      ##                  ####        ##        ##     #########
    #########     ##                  ####        ##        ##      #########
            ##    ##                  ####        ##        ##              ##
            ##    ##                  ####        ##        ##              ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
   ##########     ############    ##        ##     ##########      ##########
    ########      ############    ##        ##      ########        ########

      SI Intelligent I/O Board driver
      Copyright (c) Specialix International 1993
*/

#include "precomp.h"			/* Precompiled Headers */

//
// The SI family of serial controllers claim to provide the functionality
// of a Data Communications Equipment (DCE).  Unfortunately, the serial
// chips used in the Terminal Adapters (TAs) are designed for use as Data
// Terminal Equipments (DTEs).  In practice, this means that the board is
// really a DTE with three pairs of signals swapped - Rx/Tx, DTR/DSR, and
// CTS/RTS.  The NT serial driver is for a DTE, so it can be supported.
// The only problem is that the names of the control functions for the SI
// board assume that the board is a DCE, so top-level calls which try to
// set (say) DTR must set bits in the hardware which claim to set DSR (but
// which really set DTR anyway).
//

/*************************************************************************\
*                                                                         *
* Internal Functions                                                      *
*                                                                         *
\*************************************************************************/

int		slxos_init(IN PCARD_DEVICE_EXTENSION pCard);
BOOLEAN slxos_txint(IN PPORT_DEVICE_EXTENSION pPort);
void	slxos_rxint(IN PPORT_DEVICE_EXTENSION pPort);
void	slxos_mint(IN PPORT_DEVICE_EXTENSION pPort);

BOOLEAN SendTxChar(IN PPORT_DEVICE_EXTENSION pPort);
VOID	PutReceivedChar(IN PPORT_DEVICE_EXTENSION pPort);
BOOLEAN	ExceptionHandle(IN PPORT_DEVICE_EXTENSION pPort, IN UCHAR State);

ULONG	CopyCharsToTxBuffer(IN PPORT_DEVICE_EXTENSION pPort, 
							IN PUCHAR InputBuffer, 
							IN ULONG InputBufferLength);




/*************************************************************************\
*                                                                         *
* BOOLEAN Slxos_Present(IN PVOID Context)                                 *
*                                                                         *
* Check for an SI family board at given address                           *
\*************************************************************************/
BOOLEAN Slxos_Present(IN PVOID Context)
{
    PCARD_DEVICE_EXTENSION pCard = Context;
    PUCHAR addr = pCard->Controller;
    USHORT offset;
    UCHAR pos;
    ULONG Si_2BaseAddress[] = {
        0xc0000,
        0xc8000,
        0xd0000,
        0xd8000,
        0xdc0000,
        0xdc8000,
        0xdd0000,
        0xdd8000
        };

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_Present: CardType: %d\n", PRODUCT_NAME, pCard->CardType));
        

    switch (pCard->CardType) 
	{
    case SiHost_1:
		{
			addr[0x8000] = 0;
            
			for (offset = 0; offset < 0x8000; offset++) 
				addr[offset] = 0;

            
			for (offset = 0; offset < 0x8000; offset++) 
			{
				if (addr[offset] != 0) 
					return FALSE;
			}
            
			for (offset = 0; offset < 0x8000; offset++) 
				addr[offset] = 0xff;

            
			for (offset = 0; offset < 0x8000; offset++) 
			{
				if (addr[offset] != 0xff) 
					return FALSE;
			}
            
			return TRUE;
		}

	case SiHost_2:
		{
			BOOLEAN FoundBoard;
			PUCHAR	cp;

/* Host2 ISA board... */

			FoundBoard = TRUE;		/* Assume TRUE */
			
			for(offset=SI2_ISA_ID_BASE; offset<SI2_ISA_ID_BASE+8; offset++)
			{
				if((addr[offset]&0x7) != ((UCHAR)(~offset)&0x7)) 
					FoundBoard = FALSE;
			}

			if(FoundBoard) 
				return(TRUE);

/* Jet ISA board... */

			FoundBoard = TRUE;			/* Assume TRUE */
			offset = SX_VPD_ROM+0x20;	/* Address of ROM message */

			for(cp = "JET HOST BY KEV#";*cp != '\0';++cp)
			{
				if(addr[offset] != *cp) FoundBoard = FALSE;
				offset += 2;
			}

			if((addr[SX_VPD_ROM+0x0E]&0xF0) != 0x20) 
				FoundBoard = FALSE;

			if(FoundBoard)
			{
				pCard->CardType = Si3Isa;		/* Alter controller type */
				return(TRUE);
			}

			break;
		}

	case Si_2:
		{
            SpxDbgMsg(SERDIAG1, ("Si_2 card at slot %d?\n", pCard->SlotNumber));
                
                
            WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));

            if (READ_PORT_UCHAR((PUCHAR)0x101) == 0x6b 
			&& READ_PORT_UCHAR((PUCHAR)0x100) == 0x9b) 
			{
                pos = READ_PORT_UCHAR((PUCHAR)0x102);
                pCard->PhysAddr.LowPart = Si_2BaseAddress[(pos >> 4) & 7];
                pCard->OriginalVector = (pos & 0x80) == 0 ? 5 : 9;
                WRITE_PORT_UCHAR((PUCHAR)0x96, 0);

                return TRUE;
            }

            WRITE_PORT_UCHAR((PUCHAR)0x96, 0);

            return FALSE;
		}

#define INBZ(port) \
    READ_PORT_UCHAR((PUCHAR)((pCard->SlotNumber << 12) | port))
        
	case SiEisa:
	case Si3Eisa:
		{
			unsigned int id, rev;
			BOOLEAN	FoundBoard;
			PUCHAR	cp;

			id = INBZ(SI2_EISA_ID_HI) << 16;			/* Read board ID and revision */
			id |= INBZ(SI2_EISA_ID_MI) << 8;
			id |= INBZ(SI2_EISA_ID_LO);
			rev = INBZ(SI2_EISA_ID_REV);

			if(id == SI2_EISA_ID)
			{
				pCard->PhysAddr.LowPart = (INBZ(SI2_EISA_ADDR_HI)<<24) + (INBZ(SI2_EISA_ADDR_LO)<<16);
				pCard->OriginalVector = ((INBZ(SI2_EISA_IVEC)&SI2_EISA_IVEC_MASK)>>4);

				if(rev < 0x20) 
					return(TRUE);		/* Found SiEisa board */

				pCard->CardType = Si3Eisa;	/* Assume Si3Eisa board */
				FoundBoard = TRUE;			/* Assume TRUE */

				if(addr)				/* Check if address valid */
				{
					offset = SX_VPD_ROM+0x20;	/* Address of ROM message */

					for(cp = "JET HOST BY KEV#";*cp != '\0';++cp)
					{
						if(addr[offset] != *cp) 
							FoundBoard = FALSE;

						offset += 2;
					}

					if((addr[SX_VPD_ROM+0x0E]&0xF0) != 0x70) 
						FoundBoard = FALSE;
				}

				if(FoundBoard) 
					return(TRUE);		/* Found Si3Eisa board */
			}

			break;
		}
#undef INBZ

	case Si3Pci:
		{
			BOOLEAN	FoundBoard;
			PUCHAR	cp;

			FoundBoard = TRUE;			/* Assume TRUE */

			if(addr)				/* Check if address valid */
			{
				offset = SX_VPD_ROM+0x20;	/* Address of ROM message */

				for(cp = "JET HOST BY KEV#";*cp != '\0';++cp)
				{
					if(addr[offset] != *cp) 
						FoundBoard = FALSE;

					offset += 2;
				}

				if((addr[SX_VPD_ROM+0x0E]&0xF0) != 0x50) 
					FoundBoard = FALSE;
			}

			if(FoundBoard) 
				return(TRUE);		/* Found Si3Pci board */

			break;
		}

        
	case SiPCI:
	case SxPlusPci:
		return TRUE;			/* Already found by NT */

	default:
		break;
    }

    return FALSE;

}

/*************************************************************************\
*                                                                         *
* BOOLEAN Slxos_ResetBoard(IN PVOID Context)                              *
*                                                                         *
* Set interrupt vector for card and initialize.                           *
*                                                                         *
\*************************************************************************/
int Slxos_ResetBoard(IN PVOID Context)
{
    PCARD_DEVICE_EXTENSION pCard = Context;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_ResetBoard for %x.\n", PRODUCT_NAME, pCard->Controller));
 
	return(slxos_init(pCard));
}

/***************************************************************************\
*                                                                           *
* VOID slxos_init(IN PCARD_DEVICE_EXTENSION pCard)                       *
*                                                                           *
* Initialise routine, called once at system startup.                        *
*                                                                           *
\***************************************************************************/
int slxos_init(IN PCARD_DEVICE_EXTENSION pCard)
{
    volatile PUCHAR addr = pCard->Controller;
    USHORT offset;
    UCHAR c;
    ULONG numberOfPorts;
    ULONG numberOfPortsThisModule;
    BOOLEAN lastModule;
    ULONG channel;
    ULONG port;
    LARGE_INTEGER delay;
    
	int SXDCs=0;
	int OTHERs=0;

    SpxDbgMsg(SERDIAG1, ("%s: slxos_init for %x.\n", PRODUCT_NAME, pCard->Controller));
        
    switch (pCard->CardType) 
	{
        
	case SiHost_1:
		{
            addr[0x8000] = 0;
            addr[0xa000] = 0;

            for (offset = 0; offset < si2_z280_dsize; offset++) 
                addr[offset] = si2_z280_download[offset];

            addr[0xc000] = 0;
            addr[0xe000] = 0;
            break;
		}
    
	case SiHost_2:
		{
            addr[0x7ff8] = 0;
            addr[0x7ffd] = 0;
            addr[0x7ffc] = 0x10;

            for (offset = 0; offset < si2_z280_dsize; offset++) 
                addr[offset] = si2_z280_download[offset];

			addr[0x7ff8] = 0x10;

			if(!(pCard->PolledMode))
			{
				switch (pCard->OriginalVector) 
				{
					case 11:
						addr[0x7ff9] = 0x10;
						break;

					case 12:
						addr[0x7ffa] = 0x10;
						break;

					case 15:
						addr[0x7ffb] = 0x10;
						break;
				}
			}

            addr[0x7ffd] = 0x10;
            break;
		}
    
	case Si_2:
		{
            WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));
            c = READ_PORT_UCHAR((PUCHAR)0x102);
            c |= 0x04;          /* Reset card */
            WRITE_PORT_UCHAR((PUCHAR)0x102, c);
            c |= 0x07;          /* Enable access to card */
            WRITE_PORT_UCHAR((PUCHAR)0x102, c);

            for (offset = 0; offset < si2_z280_dsize; offset++)
                addr[offset] = si2_z280_download[offset];

            c &= 0xF0;
            c |= 0x0B;              /* enable card */
            WRITE_PORT_UCHAR((PUCHAR)0x102, c);
            WRITE_PORT_UCHAR((PUCHAR)0x96, 0);
            break;
		}

        
	case SiEisa:
		{
            port = (pCard->SlotNumber << 12) | 0xc02;
            c = (UCHAR)pCard->OriginalVector << 4;

			if(pCard->PolledMode)
				WRITE_PORT_UCHAR((PUCHAR)port,0x00);/* Select NO Interrupt + Set RESET */
			else
				WRITE_PORT_UCHAR((PUCHAR)port, c);
				
			for (offset = 0; offset < si2_z280_dsize; offset++) 
				addr[offset] = si2_z280_download[offset];

			addr[0x42] = 1;
			c = (UCHAR) ((pCard->OriginalVector << 4) | 4);

			if(pCard->PolledMode)
				WRITE_PORT_UCHAR((PUCHAR)port,0x04);/* Select NO Interrupt +  Clear RESET */
			else
				WRITE_PORT_UCHAR((PUCHAR)port, c);
				
			c = READ_PORT_UCHAR((PUCHAR)(port + 1));

            break;
		}

        
	case SiPCI:
		{
			int	loop;
			addr[SI2_PCI_SET_IRQ] = 0;			/* clear any interrupts */
			addr[SI2_PCI_RESET] = 0;			/* put z280 into reset */
			loop = 0;

			for(offset = 0;offset < si2_z280_dsize;offset++)	/* Load the TA/MTA code */
				addr[offset] = si2_z280_download[offset];

			addr[SI2_EISA_OFF] = SI2_EISA_VAL;	/* Set byte to indicate EISA/PCI */
			addr[SI2_PCI_SET_IRQ] = 0;			/* clear any interrupts */
			addr[SI2_PCI_RESET] = 1;			/* remove reset from z280 */
			break;
		}

	case Si3Isa:
	case Si3Eisa:
	case Si3Pci:
		{
			int		loop;

/* First, halt the card... */

			addr[SX_CONFIG] = 0;
			addr[SX_RESET] = 0;
			loop = 0;
			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET] & 1)!=0 && loop++<10000)	/* spin 'til done */
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */

/* Copy across the Si3 TA/MTA download code... */

			for(offset = 0;offset < si3_t225_dsize;offset++)	/* Load the Si3 TA/MTA code */
				addr[si3_t225_downloadaddr+offset] = si3_t225_download[offset];

/* Install bootstrap and start the card up... */

			for(loop=0;loop<si3_t225_bsize;loop++)		/* Install bootstrap */
				addr[si3_t225_bootloadaddr+loop] = si3_t225_bootstrap[loop];

			addr[SX_RESET] = 0;				/* Reset card again */

/* Wait for board to come out of reset... */

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET]&1)!=0 && loop++<10000)	/* spin 'til reset */
			{
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */
				SpxDbgMsg(SERDIAG1,("%s[Si3]: slxos_init for %x.  Waiting for board reset to end\n",
					PRODUCT_NAME, pCard->Controller));
			}

			SpxDbgMsg(SERDIAG1,("%s[Si3]: slxos_init for %x.  Board Reset ended: %d\n",
				PRODUCT_NAME, pCard->Controller, addr[SX_RESET]));
				
			if((addr[SX_RESET]&1) != 0) 
				return(CARD_RESET_ERROR);		/* Board not reset */

			if(pCard->PolledMode)
				addr[SX_CONFIG] = SX_CONF_BUSEN;	/* Poll only, no interrupt */
			else
			{
				if(pCard->CardType == Si3Pci)		/* Don't set IRQ level for PCI */
					addr[SX_CONFIG] = SX_CONF_BUSEN+SX_CONF_HOSTIRQ;
				else						/* Set IRQ level for ISA/EISA */
					addr[SX_CONFIG] = SX_CONF_BUSEN+SX_CONF_HOSTIRQ+(UCHAR)(pCard->OriginalVector<<4);
			}

			break;
		}

	case SxPlusPci:
		{
			int	loop;

/* First, halt the card... */

			addr[SX_CONFIG] = 0;
			addr[SX_RESET] = 0;
			loop = 0;
			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET] & 1)!=0 && loop++<10000)	/* spin 'til done */
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */

/* Copy across the SX+ TA/MTA download code... */

			for(offset = 0; offset < si4_cf_dsize; offset++)	/* Load the SX+ TA/MTA code */
				pCard->BaseController[si4_cf_downloadaddr+offset] = si4_cf_download[offset];

/* Start the card up... */

			addr[SX_RESET] = 0;			/* Reset card again */

/* Wait for board to come out of reset... */

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET]&1)!=0 && loop++<10000)	/* spin 'til reset */
			{
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */
				SpxDbgMsg(SERDIAG1,("%s[SX+]: slxos_init for %x.  Waiting for board reset to end\n",
					PRODUCT_NAME, pCard->Controller));
			}

			SpxDbgMsg(SERDIAG1,("%s[SX+]: slxos_init for %x.  Board Reset ended: %d\n",
				PRODUCT_NAME, pCard->Controller,addr[SX_RESET]));

			if((addr[SX_RESET]&1) != 0) 
				return(CARD_RESET_ERROR);		/* Board not reset */

			if(pCard->PolledMode)
				addr[SX_CONFIG] = SX_CONF_BUSEN;	/* Poll only, no interrupt */
			else
				addr[SX_CONFIG] = SX_CONF_BUSEN + SX_CONF_HOSTIRQ;

			break;
		}

	default:
		break;

    }


    SpxDbgMsg(SERDIAG1,("%s: slxos_init for %x.  Done reset\n", PRODUCT_NAME, pCard->Controller));
        
    numberOfPorts = 0;
    //
    // Set delay for 0.1 second.
    //
    delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));

    do
    {
        KeDelayExecutionThread(KernelMode,FALSE,&delay);
        SpxDbgMsg(SERDIAG1,("%s: slxos_init for %x.  Waiting for reset to end\n",
            PRODUCT_NAME, pCard->Controller));

        if(++numberOfPorts > 10)
            break;

    } while(addr[0] == 0);

    SpxDbgMsg(SERDIAG1, ("%s: slxos_init for %x.  Reset ended: %d\n", PRODUCT_NAME, pCard->Controller, addr[0]));
       
        
    if (addr[0] == 0xff || addr[0] == 0) 
		return (DCODE_OR_NO_MODULES_ERROR);


    numberOfPorts = 0;
    addr += sizeof(SXCARD);
    lastModule = FALSE;
    
    
    for (offset = 0; offset < 4 && !lastModule; offset++) 
	{

		if ( ((PMOD)addr)->mc_chip == SXDC )	/* Test for SXDC */
			SXDCs++;  /* Increment SXDC counter */
		else
			OTHERs++;  /* Increment OTHER counter */

        numberOfPortsThisModule = ((PMOD)addr)->mc_type & 31;
        lastModule = (((PMOD)addr)->mc_next & 0x7fff) == 0;
        addr += sizeof(SXMODULE);

        for (channel = 0; channel < numberOfPortsThisModule; channel++) 
		{

#ifndef	ESIL_XXX0				/* ESIL_XXX0 23/09/98 */
			if (numberOfPorts < pCard->ConfiguredNumberOfPorts)
                pCard->PortExtTable[numberOfPorts]->pChannel = addr;
#endif							/* ESIL_XXX0 23/09/98 */
			numberOfPorts++;
            addr += sizeof(SXCHANNEL);
        }

    }


	if (SXDCs > 0)
	{ 	
		if (pCard->CardType==SiHost_1 || pCard->CardType==SiHost_2 
		||	pCard->CardType==Si_2 || pCard->CardType==SiEisa   
		||	pCard->CardType==SiPCI)
		{
			pCard->NumberOfPorts = 0;
			return(NON_SX_HOST_CARD_ERROR);
		}	      

		if (OTHERs > 0)
		{
			pCard->NumberOfPorts = 0;
	        return(MODULE_MIXTURE_ERROR);
		}
       
	}		     

    pCard->NumberOfPorts = numberOfPorts;

	return(SUCCESS);
}


/*************************************************************************\
*                                                                         *
* BOOLEAN Slxos_ResetChannel(IN PVOID Context)                            *
*                                                                         *
* Initialize Channel.                                                     *
* SRER Interrupts will be enabled in EnableAllInterrupts().               *
*                                                                         *
* Return Value:                                                           *
*           Always FALSE.                                                 *
*                                                                         *
\*************************************************************************/
BOOLEAN Slxos_ResetChannel(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_ResetChannel for %x\n", PRODUCT_NAME, pPort->pChannel));

    // Set Xon/Xoff chars.
    Slxos_SetChars(pPort);

    //
    // Now we set the line control, modem control, and the
    // baud to what they should be.
    //
    Slxos_SetLineControl(pPort);
    SerialSetupNewHandFlow(pPort, &pPort->HandFlow);
//    pPort->LastModemStatus = 0;
    SerialHandleModemUpdate(pPort);
    Slxos_SetBaud(pPort);

    return FALSE;
}


/*****************************************************************************
****************************                     *****************************
****************************   Slxos_CheckBaud   *****************************
****************************                     *****************************
******************************************************************************

Prototype:	BOOLEAN	Slxos_CheckBaud(PPORT_DEVICE_EXTENSION pPort,ULONG BaudRate)

Description:	Checks the supplied baud rate against the supported range.

Parameters:	pPort is a pointer to the device extension
		BaudRate is the baud rate as an integer

Returns:	TRUE if baud is supported,
		FALSE if not

*/

BOOLEAN	Slxos_CheckBaud(PPORT_DEVICE_EXTENSION pPort,ULONG BaudRate)
{
	PCHAN channelControl = (PCHAN)pPort->pChannel;

	switch(BaudRate)
	{
	case 75:
	case 110:
	case 150:
	case 300:
	case 600:
	case 1200:
	case 1800:
	case 2000:
	case 2400:
	case 4800:
	case 9600:
	case 19200:
	case 38400:
	case 57600:
		return(TRUE);

	case 115200:		   /* 115200 is only available to MTAs and SXDCs */
        if((channelControl->type != MTA_CD1400) && (channelControl->type != SXDC)) 
			break;

		return(TRUE);

	case 50:
	case 134:
	case 200:
	case 7200:
	case 14400:
	case 28800:
	case 56000:
	case 64000:
	case 76800:
	case 128000:
	case 150000:
	case 230400:
	case 256000:
	case 460800:
	case 921600:
		if(channelControl->type == SXDC)
			return(TRUE);
			
	default:
		break;
	}
	return(FALSE);

} /* Slxos_CheckBaud */

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetBaud(IN PVOID Context)                                   *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the Baud Rate of the device.                                       *
*                                                                           *
* Context - Pointer to a structure that contains a pointer to               *
*           the device extension and what should be the current             *
*           baud rate.                                                      *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetBaud(IN PVOID Context)
{

    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR index2 = 0;
    UCHAR index = CSR_9600;

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_SetBaud for %x, changing to %d baud.\n",
        PRODUCT_NAME, pPort->pChannel, pPort->CurrentBaud));
        
    switch (pPort->CurrentBaud) 
	{
	case 75:
		index = CSR_75;
		break;

    case 150:
        index = CSR_150;
        break;

    case 300:
        index = CSR_300;
        break;

    case 600:
        index = CSR_600;
        break;

    case 1200:
        index = CSR_1200;
        break;

    case 1800:
        index = CSR_1800;
        break;

    case 2000:
        index = CSR_2000;
        break;

    case 2400:
        index = CSR_2400;
        break;

    case 4800:
        index = CSR_4800;
        break;

    case 9600:
        index = CSR_9600;
        break;

    case 19200:
        index = CSR_19200;
        break;

    case 38400:
        index = CSR_38400;
        break;

    case 57600:
        index = CSR_57600;
        break;

    case 115200:			
		index = CSR_110;
		break;

	case 50:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
		index2 = BAUD_50;
		break;

	case 110:
		if(channelControl->type != SXDC)
		{
			index = CSR_110;
			break;
		}
		else
		{	
	    	index = CSR_EXTBAUD;
	    	index2 = BAUD_110;
	    	break;
		}
		break;

	case 134:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
	   	index2 = BAUD_134_5;
       	break;

	case 200:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_200;
		break;

	case 7200:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_7200;
		break;

	case 14400:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_14400;
		break;

	case 56000:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_56000;
		break;

	case 64000:
		if(channelControl->type != SXDC) 
			break;
	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_64000;
       	break;

	case 76800:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_76800;
       	break;

	case 128000:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	    index2 = BAUD_128000;
        break;

	case 150000:
		if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_150000;
   		break;

   	case 256000:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
	    index2 = BAUD_256000;
   		break;

	case 28800:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
	    index2 = BAUD_28800;
   		break;

	case 230400:
	    if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_230400;
	    break;

	case 460800:
	    if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_460800;
	    break;

	case 921600:
	    if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_921600;
	    break;

    default:
        index = CSR_9600;

        SpxDbgMsg(SERDIAG1, ("%s: Invalid BaudRate: %ld\n", PRODUCT_NAME, pPort->CurrentBaud));
		break;
    }

    channelControl->hi_csr = index + (index << 4);
    channelControl->hi_txbaud = index2;		/* Set extended transmit baud rate */
    channelControl->hi_rxbaud = index2;		/* Set extended receive baud rate */

	// Set mask so only the baud rate is configured.
	channelControl->hs_config_mask |= CFGMASK_BAUD;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetLineControl(IN PVOID Context)                            *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the Line Control of the device.                                    *
*                                                                           *
* Context - Pointer to a structure that contains a pointer to               *
*           the device extension.                                           *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetLineControl(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN) pPort->pChannel;
    UCHAR mr1 = 0;
    UCHAR mr2 = 0;
    BOOLEAN needParityDetection = FALSE;

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_SetLineControl for %x.\n", PRODUCT_NAME, pPort->pChannel));

    switch (pPort->LineControl & SERIAL_DATA_MASK) 
	{
	case SERIAL_5_DATA:
        mr1 |= MR1_5_BITS;
        break;

    case SERIAL_6_DATA:
        mr1 |= MR1_6_BITS;
        break;

    case SERIAL_7_DATA:
		mr1 |= MR1_7_BITS;
		break;

    case SERIAL_8_DATA:
        mr1 |= MR1_8_BITS;
        break;
    }

    switch (pPort->LineControl & SERIAL_STOP_MASK) 
	{
    case SERIAL_1_STOP:
        mr2 = MR2_1_STOP;
        break;

    case SERIAL_2_STOP:
        mr2 = MR2_2_STOP;
        break;
    }

    switch (pPort->LineControl & SERIAL_PARITY_MASK) 
	{
    case SERIAL_NONE_PARITY:
        mr1 |= MR1_NONE;
        break;

    case SERIAL_ODD_PARITY:
        mr1 |= MR1_ODD | MR1_WITH;
        needParityDetection = TRUE;
        break;

    case SERIAL_EVEN_PARITY:
        mr1 |= MR1_EVEN | MR1_WITH;
        needParityDetection = TRUE;
        break;

    case SERIAL_MARK_PARITY:
        mr1 |= MR1_ODD | MR1_FORCE;
        needParityDetection = TRUE;
        break;

    case SERIAL_SPACE_PARITY:
        mr1 |= MR1_EVEN | MR1_FORCE;
        needParityDetection = TRUE;
        break;
    }

    channelControl->hi_mr1 = mr1;
    channelControl->hi_mr2 = mr2;

    if (needParityDetection)
        channelControl->hi_prtcl |= SP_PAEN;
	else 
        channelControl->hi_prtcl &= ~SP_PAEN;


    //
    // received breaks should cause interrupts
    //
    channelControl->hi_break |= BR_INT;
    channelControl->hi_break |= BR_ERRINT;		/* Treat parity/overrun/framing errors as exceptions */


	// Set mask so only the line control is configured.
	channelControl->hs_config_mask |= CFGMASK_LINE;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* VOID Slxos_SetChars(IN PVOID Context)                                     *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set Special Chars.                                                     *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_SetChars(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_SetChars for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    channelControl->hi_txon = pPort->SpecialChars.XonChar;
    channelControl->hi_txoff = pPort->SpecialChars.XoffChar;
    channelControl->hi_rxon = pPort->SpecialChars.XonChar;
    channelControl->hi_rxoff = pPort->SpecialChars.XoffChar;
    channelControl->hi_err_replace = pPort->SpecialChars.ErrorChar;

	// Set mask so only the special chars are configured.
	channelControl->hs_config_mask |= CFGMASK_LINE;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetDTR(IN PVOID Context)                                    *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the DTR in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetDTR(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Setting DTR for %x.\n", PRODUCT_NAME, pPort->pChannel));

    //
    // Set DTR (usual nomenclature problem).
    //
    channelControl->hi_op |= OP_DTR;

    if(channelControl->hi_prtcl&SP_DTR_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */

	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_ClearDTR(IN PVOID Context)                                  *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the DTR in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_ClearDTR(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl =  (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Clearing DTR for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    //
    // Clear DTR (usual nomenclature problem).
    //
    channelControl->hi_op &= ~OP_DTR;

    if(channelControl->hi_prtcl&SP_DTR_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */

	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetRTS (IN PVOID Context)                                   *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the RTS in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetRTS(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Setting RTS for %x.\n", PRODUCT_NAME, channelControl));
        
    //
    // Set RTS (usual nomenclature problem).
    //
    channelControl->hi_op |= OP_RTS;

    if(channelControl->hi_mr1 & MR1_RTS_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */


	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_ClearRTS (IN PVOID Context)                                 *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the RTS in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_ClearRTS(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Clearing RTS for %x.\n", PRODUCT_NAME, channelControl));

    //
    // Clear RTS (usual nomenclature problem).
    //
    channelControl->hi_op &= ~OP_RTS;

    if(channelControl->hi_mr1 & MR1_RTS_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */

	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;
}


/*****************************************************************************
***************************                       ****************************
***************************   Slxos_FlushTxBuff   ****************************
***************************                       ****************************
******************************************************************************

Prototype:	BOOLEAN	Slxos_FlushTxBuff(IN PVOID Context)

Description:	Flushes the transmit buffer by setting the pointers equal.

Parameters:	Context is a pointer to the device extension

Returns:	FALSE

*/
BOOLEAN	Slxos_FlushTxBuff(IN PVOID Context)
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	PCHAN channelControl = (PCHAN)pPort->pChannel;

	SpxDbgMsg(SERDIAG1,("%s: Flushing Transmit Buffer for channel %x.\n",PRODUCT_NAME,channelControl));
	channelControl->hi_txipos = channelControl->hi_txopos;	/* Set in = out */
	

/* ESIL_0925 08/11/99 */
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_OPEN:
        channelControl->hi_hstat = HS_WFLUSH;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_LOPEN:
    case HS_MOPEN:
    case HS_IDLE_MPEND:	
    case HS_CONFIG:
    case HS_STOP:	
    case HS_RESUME:	
    case HS_WFLUSH:
    case HS_RFLUSH:
    case HS_SUSPEND:
    case HS_CLOSE:	
        pPort->PendingOperation = HS_WFLUSH;
        break;

    default:
        break;
    }

/* ESIL_0925 08/11/99 */

    return FALSE;

} /* Slxos_FlushTxBuff */

  
/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SendXon(IN PVOID Context)                                   *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to send an Xon Character.                                                 *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SendXon(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_SendXon for %x.\n", PRODUCT_NAME, channelControl));

    //
    // Empty the receive buffers.  This will provoke the hardware into sending an XON if necessary.
    //
    channelControl->hi_rxopos = channelControl->hi_rxipos;

    //
    // If we send an xon, by definition we can't be holding by Xoff.
    //
    pPort->TXHolding &= ~SERIAL_TX_XOFF;

    //
    // If we are sending an xon char then by definition 
	// we can't be "holding" up reception by Xoff.
    //
    pPort->RXHolding &= ~SERIAL_RX_XOFF;

    SpxDbgMsg(SERDIAG1, ("%s: Sending Xon for %x. RXHolding = %d, TXHolding = %d\n",
         PRODUCT_NAME, pPort->pChannel, pPort->RXHolding, pPort->TXHolding));
       
    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetFlowControl(IN PVOID Context)                            *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set Flow Control                                                       *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetFlowControl(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    BOOLEAN needHardwareFlowControl = FALSE;

    SpxDbgMsg(SERDIAG1, ("%s: Setting Flow Control for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    if (pPort->HandFlow.ControlHandShake & SERIAL_OUT_HANDSHAKEMASK) 
        needHardwareFlowControl = TRUE;


    if (pPort->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting CTS Flow Control.\n",PRODUCT_NAME));

        //
        // This looks wrong, too, for the same reason.
        //
        channelControl->hi_mr2 |= MR2_CTS_TXFLOW;
        needHardwareFlowControl = TRUE;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing CTS Flow Control.\n",PRODUCT_NAME));

        //
        // This looks wrong, too, for the same reason.
        //
        channelControl->hi_mr2 &= ~MR2_CTS_TXFLOW;
    }

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting RTS Flow Control.\n",PRODUCT_NAME));

        //
        // Set flow control in the hardware (usual nomenclature problem).
        //
        channelControl->hi_mr1 |= MR1_RTS_RXFLOW;
        needHardwareFlowControl = TRUE;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing RTS Flow Control.\n",PRODUCT_NAME));

        //
        // Clear flow control in the hardware (usual nomenclature problem).
        //
        channelControl->hi_mr1 &= ~MR1_RTS_RXFLOW;
    }

/* DSR Transmit Flow Control... */
    
    if(pPort->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
    {
		SpxDbgMsg(SERDIAG1,("%s: Setting DSR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl = SP_DSR_TXFLOW;		/* Enable DSR Transmit Flow Control */
        needHardwareFlowControl = TRUE;
    }
    else
    {
		SpxDbgMsg(SERDIAG1,("%s: Clearing DSR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl &= ~SP_DSR_TXFLOW;		/* Disable DSR Transmit Flow Control */
    }

/* DTR Receive Flow Control... */

    if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
    {
		SpxDbgMsg(SERDIAG1,("%s: Setting DTR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl |= SP_DTR_RXFLOW;		/* Enable DTR Receive Flow Control */
        needHardwareFlowControl = TRUE;
    }
    else
    {
		SpxDbgMsg(SERDIAG1,("%s: Clearing DTR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl &= ~SP_DTR_RXFLOW;		/* Disable DTR Receive Flow Control */
    }

    if (pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting Receive Xon/Xoff Flow Control.\n",PRODUCT_NAME));

        channelControl->hi_prtcl |= SP_RXEN;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing Receive Xon/Xoff Flow Control.\n",PRODUCT_NAME));
            
        channelControl->hi_prtcl &= ~SP_RXEN;
    }

    if (pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting Transmit Xon/Xoff Flow Control.\n",PRODUCT_NAME));

        channelControl->hi_prtcl |= SP_TXEN;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing Transmit Xon/Xoff Flow Control.\n",PRODUCT_NAME));

        channelControl->hi_prtcl &= ~SP_TXEN;
    }

/* Enable error character replacement... */

	if(pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)	/* Replace "bad" error characters ? */
		channelControl->hi_break |= BR_ERR_REPLACE;	/* Yes */
	else	
		channelControl->hi_break &= ~BR_ERR_REPLACE;	/* No */

    //
    // Enable detection of modem signal transitions if needed
    //
    if (needHardwareFlowControl) 
        channelControl->hi_prtcl |= SP_DCEN;
	else 
        channelControl->hi_prtcl &= ~SP_DCEN;

    //
    // permanently enable input pin checking
    //
    channelControl->hi_prtcl |= SP_DCEN;


	// Set mask so only the flow control is configured.
	channelControl->hs_config_mask |= CFGMASK_FLOW;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* VOID Slxos_Resume(IN PVOID Context)                                       *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to simulate Xon received.                                                 *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_Resume(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_Resume for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_OPEN:
        channelControl->hi_hstat = HS_RESUME;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_LOPEN:
    case HS_MOPEN:
    case HS_IDLE_MPEND:	
    case HS_CONFIG:
    case HS_STOP:	
    case HS_RESUME:	
    case HS_WFLUSH:
    case HS_RFLUSH:
    case HS_SUSPEND:
    case HS_CLOSE:	
        pPort->PendingOperation = HS_RESUME;
        break;

    default:
        break;
    }
 
}

/***************************************************************************\
*                                                                           *
* UCHAR Slxos_GetModemStatus(IN PVOID Context)                              *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Get Modem Status in UART style.                                        *
*                                                                           *
* This routine suffers particularly badly from the SI's attempt to be       *
* a DCE, effectively meaning that it swaps CTS/RTS and DSR/DTR.             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           MSR Register - UART Style.                                      *
*                                                                           *
\***************************************************************************/
UCHAR Slxos_GetModemStatus(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR ModemStatus = 0, Status, ModemDeltas;

    SpxDbgMsg( SERDIAG1, ("%s: Slxos_GetModemStatus for %x.\n",	PRODUCT_NAME, channelControl));

    //
    // Modify modem status only if signals have changed.
    // Note that it is possible that a signal transition may have been missed
    //
    if((Status = channelControl->hi_ip) != pPort->LastStatus)
	{
        if (Status & IP_DSR)
            ModemStatus |= SERIAL_MSR_DSR;

        if (Status & IP_DCD)
            ModemStatus |= SERIAL_MSR_DCD;

        if (Status & IP_CTS)
            ModemStatus |= SERIAL_MSR_CTS;

        if (Status & IP_RI)
            ModemStatus |= SERIAL_MSR_RI;

        pPort->LastModemStatus = ModemStatus;/* Store modem status without deltas */

        ModemDeltas = Status ^ pPort->LastStatus;
        pPort->LastStatus = Status;

        if (ModemDeltas & IP_DSR)
            ModemStatus |= SERIAL_MSR_DDSR;

        if (ModemDeltas & IP_DCD)
            ModemStatus |= SERIAL_MSR_DDCD;

        if (ModemDeltas & IP_CTS)
            ModemStatus |= SERIAL_MSR_DCTS;

        if (ModemDeltas & IP_RI)
            ModemStatus |= SERIAL_MSR_TERI;

		SpxDbgMsg( SERDIAG1, ("%s: Get New Modem Status for 0x%x, Status = 0x%x hi_ip 0x%x\n",
			PRODUCT_NAME, pPort->pChannel, ModemStatus, Status));

		return ModemStatus;

    }

    SpxDbgMsg( SERDIAG1, ("%s: Get Last Modem Status for 0x%x, Status = 0x%x hi_ip 0x%x\n",
            PRODUCT_NAME, pPort->pChannel, pPort->LastModemStatus, channelControl->hi_ip));
        
    return pPort->LastModemStatus;
}

/***************************************************************************\
*                                                                           *
* UCHAR Slxos_GetModemControl(IN PVOID Context)                             *
*                                                                           *
* This routine which is not only called at interrupt level is used          *
* to Get Modem Control - RTS/DTR in UART style. RTS is a DTR output.        *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           MCR Register - UART Style.                                      *
*                                                                           *
\***************************************************************************/
ULONG Slxos_GetModemControl(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    ULONG ModemControl = 0;
    UCHAR Status;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_GetModemControl for %x.\n", PRODUCT_NAME, channelControl));
        
    // Get Signal States
    Status = channelControl->hi_op;

    if(Status & OP_RTS) 
        ModemControl |= SERIAL_MCR_RTS;

    if(Status & OP_DTR) 
        ModemControl |= SERIAL_MCR_DTR;

    return ModemControl;
}

/***************************************************************************\
*                                                                           *
* VOID Slxos_EnableAllInterrupts(IN PVOID Context)                          *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Enable All Interrupts.                                                 *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_EnableAllInterrupts(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1,("%s: EnableAllInterrupts for %x.\n", PRODUCT_NAME, pPort->pChannel));
   
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_CLOSED:
        channelControl->hi_hstat = HS_LOPEN;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_CLOSE:
	case HS_FORCE_CLOSED:
        pPort->PendingOperation = HS_LOPEN;
		break;

    default:
        break;
    }

   
}

/***************************************************************************\
*                                                                           *
* VOID Slxos_DisableAllInterrupts(IN PVOID Context)                         *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Disable All Interrupts.                                                *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_DisableAllInterrupts(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
	int	timeout = 100;
       

    SpxDbgMsg(SERDIAG1, ("%s: DisableAllInterrupts for %x.\n", PRODUCT_NAME, pPort->pChannel));

/* ESIL_0925 08/11/99 */
	// Whilst the firmware is in a transitory state then wait for time out period.
	while(((channelControl->hi_hstat != HS_IDLE_OPEN)
	&& (channelControl->hi_hstat != HS_IDLE_CLOSED)
	&& (channelControl->hi_hstat != HS_IDLE_BREAK))
	&& (--timeout))
	{
		LARGE_INTEGER delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(10000000));/* 10mS */
		KeDelayExecutionThread(KernelMode,FALSE,&delay);	/* Wait */
	}
/* ESIL_0925 08/11/99 */


    channelControl->hi_hstat = HS_FORCE_CLOSED;
    pPort->PendingOperation = HS_IDLE_CLOSED;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_TurnOnBreak(IN PVOID Context)                               *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Turn Break On.                                                         *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_TurnOnBreak(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
       

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_TurnOnBreak for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_OPEN:
        channelControl->hi_hstat = HS_START;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_LOPEN:
    case HS_MOPEN:
    case HS_IDLE_MPEND:	
    case HS_CONFIG:
    case HS_STOP:	
    case HS_RESUME:	
    case HS_WFLUSH:
    case HS_RFLUSH:
    case HS_SUSPEND:
    case HS_CLOSE:	
        pPort->PendingOperation = HS_START;
        break;

    default:
        break;
    }

    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_TurnOffBreak(IN PVOID Context)                              *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Turn Break Off.                                                        *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_TurnOffBreak(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
        

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_TurnOffBreak for %x.\n", PRODUCT_NAME, pPort->pChannel));
    
    // If we were about to start breaking then lets forget about it??
    if (pPort->PendingOperation == HS_START)
	{
        pPort->PendingOperation = HS_IDLE_OPEN;
	}
	else
	{
		switch (channelControl->hi_hstat) 
		{	
		case HS_IDLE_BREAK:		// If we are in the HS_IDLE_BREAK state we go to HS_STOP now.
			channelControl->hi_hstat = HS_STOP;
			pPort->PendingOperation = HS_IDLE_OPEN;
			break;

		case HS_START:			// If we are in the HS_START state we go to HS_STOP soon.	
			pPort->PendingOperation = HS_STOP;
			break;

		default:				// Otherwise we are unable to do anything.
			break;
		}

	}


    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_Interrupt(IN PVOID Context)                                 *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_Interrupt(IN PVOID Context)
{
    PCARD_DEVICE_EXTENSION pCard = Context;
    BOOLEAN ServicedAnInterrupt = FALSE;
    UCHAR c;

    SpxDbgMsg(SERDIAG5, ("%s: In Slxos_Interrupt: Context: %x; CardType: %d\n",
        PRODUCT_NAME, Context, pCard->CardType));

    switch (pCard->CardType) 
	{
	case SiHost_1:
		pCard->Controller[0xa000] = 0;
		pCard->Controller[0xe000] = 0;
		break;
        
	case Si_2:
		WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));
		c = READ_PORT_UCHAR((PUCHAR)0x102);
		c &= ~0x08;
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);
		c |= 0x08;
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);
		WRITE_PORT_UCHAR((PUCHAR)0x96, 0);            /* De-select slot */
		break;

    case SiHost_2:
		pCard->Controller[0x7FFD] = 0x00;
		pCard->Controller[0x7FFD] = 0x10;
		break;

	case SiEisa:
		READ_PORT_UCHAR((PUCHAR)((pCard->SlotNumber << 12) | 0xc03));
		break;

    case SiPCI:
		pCard->Controller[SI2_PCI_SET_IRQ] = 0;/* Reset interrupts */
        break;

	case Si3Isa:
	case Si3Eisa:
	case Si3Pci:
	case SxPlusPci:
	    if(pCard->Controller[SX_IRQ_STATUS]&1)
			return(FALSE);
	    
		pCard->Controller[SX_RESET_IRQ]=0;	/* Reset interrupts */

	default:
		break;
    }

    ((PSXCARD)pCard->Controller)->cc_int_pending = 0;

	IoRequestDpc(pCard->DeviceObject,NULL,pCard);	/* Request DPC to handle interrupt */

	return(TRUE);				/* Interrupt acknowledged */
}

/*****************************************************************************
******************************                  ******************************
******************************   Slxos_IsrDpc   ******************************
******************************                  ******************************
******************************************************************************

Prototype:	VOID	Slxos_IsrDpc
			(
				IN PKDPC 		Dpc,
				IN PDEVICE_OBJECT	DeviceObject,
				IN PIRP 		Irp,
				IN PVOID 		Context
			)

Description:	Polls the board for work to do.

Parameters:	Context is a pointer to the device extension

Returns:	FALSE

*/

VOID	Slxos_IsrDpc
(
	IN PKDPC 		Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP 		Irp,
	IN PVOID 		Context
)
{
	PCARD_DEVICE_EXTENSION	pCard = Context;

	KeAcquireSpinLockAtDpcLevel(&pCard->DpcLock);	/* Protect Dpc for this board */
	Slxos_PollForInterrupt(pCard,FALSE);			/* Service the board */
	KeReleaseSpinLockFromDpcLevel(&pCard->DpcLock);	/* Free the Dpc lock */

} /* Slxos_IsrDpc */

/*****************************************************************************
****************************                     *****************************
****************************   Slxos_PolledDpc   *****************************
****************************                     *****************************
******************************************************************************

Prototype:	VOID	Slxos_PolledDpc(IN PKDPC Dpc,IN PVOID Context,IN PVOID SysArg1,IN PVOID SysArg2)

Description:	Polls the board for work to do.

Parameters:	Context is a pointer to the device extension

Returns:	FALSE

*/

VOID Slxos_PolledDpc(IN PKDPC Dpc,IN PVOID Context,IN PVOID SysArg1,IN PVOID SysArg2)
{
	PCARD_DEVICE_EXTENSION	pCard = Context;
	LARGE_INTEGER			PolledPeriod;

	KeAcquireSpinLockAtDpcLevel(&pCard->DpcLock);	/* Protect Dpc for this board */
	Slxos_PollForInterrupt(pCard,FALSE);			/* Service the board */
	KeReleaseSpinLockFromDpcLevel(&pCard->DpcLock);	/* Free the Dpc lock */
	PolledPeriod.QuadPart = -100000;				/* 100,000*100nS = 10mS */
	KeSetTimer(&pCard->PolledModeTimer,PolledPeriod,&pCard->PolledModeDpc);

} /* Slxos_PolledDpc */

/*****************************************************************************
*****************************                    *****************************
*****************************   Slxos_SyncExec   *****************************
*****************************                    *****************************
******************************************************************************

Prototype:	VOID	Slxos_SyncExec(PPORT_DEVICE_EXTENSION pPort,PKSYNCHRONIZE_ROUTINE SyncRoutine,PVOID SyncContext)

Description:	Synchronizes execution between driver threads and the DPC.

Parameters:	pPort points to the serial device extension.
			SyncRoutine is the function to call in synchronization.
			SyncContext is the data to call the function with.

Returns:	None

*/

VOID Slxos_SyncExec(PPORT_DEVICE_EXTENSION pPort,PKSYNCHRONIZE_ROUTINE SyncRoutine,PVOID SyncContext,int index)
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	KIRQL	OldIrql;

	KeAcquireSpinLock(&pCard->DpcLock,&OldIrql);	/* Protect Dpc for this board */
	(SyncRoutine)(SyncContext);						/* Call the synchronized function */
	KeReleaseSpinLock(&pCard->DpcLock,OldIrql);		/* Free the Dpc lock */

} /* SlxosSyncExec */

/*****************************************************************************
*************************                            *************************
*************************   Slxos_PollForInterrupt   *************************
*************************                            *************************
******************************************************************************

Prototype:		BOOLEAN	Slxos_PollForInterrupt(IN PVOID Context,IN BOOLEAN Obsolete)

Description:	Checks the specified card and performs read, write and control servicing as necessary.

Parameters:		Context specifies the context of the call, this is casted to a "pCard" structure.
				Obsolete is a variable no longer used in this function

Returns:		TRUE (always)

NOTE:			Slxos_PollForInterrupt is protected by a DpcLock associated with a given board.
				This function ASSUMES that the lock has been obtained before being called.

*/

BOOLEAN	Slxos_PollForInterrupt(IN PVOID Context,IN BOOLEAN Obsolete)
{
	PCARD_DEVICE_EXTENSION	pCard = Context;
	PPORT_DEVICE_EXTENSION	pPort;
	UCHAR			nChan;
	PCHAN			pChan;
#if	DBG
	ULONG			SavedDebugLevel = SpxDebugLevel;
#endif

/* Check to see if Dpc is already running to prevent being called recursively... */

	if(pCard->DpcFlag) 
		return(FALSE);			/* Dpc is already running */
	
	pCard->DpcFlag = TRUE;		/* Mark Dpc as running */

#if	DBG
	if(!(SpxDebugLevel & SERINTERRUPT))	/* If interrupt flag not set */
		SpxDebugLevel = 0;				/* disable messages */
#endif

/* Check each channel on the card for servicing... */

	for(nChan = 0; nChan < pCard->NumberOfPorts; nChan++)
	{
#ifdef ESIL_XXX0					/* ESIL_XXX0 24/09/98 */
		if(!(pCard->AttachedPDO[nChan]))		/* Get PDO for this channel */
			continue;				/* NULL, skip to next */

		if(!(pPort = (PPORT_DEVICE_EXTENSION)pCard->AttachedPDO[nChan]->DeviceExtension))
			continue;				/* NULL, skip to next */

#ifndef	BUILD_SPXMINIPORT
		if(!(pPort->PnpPowerFlags & PPF_POWERED))	/* Is port powered ? */
			continue;								/* No, skip */
#endif
#else						/* ESIL_XXX0 24/09/98 */
		if(!(pPort = pCard->PortExtTable[nChan]))	/* Get extension structure for this channel */
			continue;								/* NULL, skip to next */
#endif						/* ESIL_XXX0 24/09/98 */

        if(!(pChan = (PCHAN)pPort->pChannel))		/* Get channel structure on card */
        	continue;								/* NULL, skip to next */


		switch(pChan->hi_hstat)		// Check current state of channel
		{
		case HS_IDLE_OPEN:
			{
				// We can move from the IDLE_OPEN state to any of the following states.
				switch(pPort->PendingOperation)
				{
				case HS_FORCE_CLOSED:
				case HS_CLOSE:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_CLOSED;	// Wait for IDLE_CLOSED 
					break;

				case HS_CONFIG:
				case HS_RESUME:
				case HS_WFLUSH:
				case HS_RFLUSH:
				case HS_SUSPEND:
				case HS_START:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_OPEN;		// Wait for IDLE_OPEN 
					break;

				default:
					break;	// We cannot move to any other states from here.

				}

				break;
			}

		case HS_IDLE_BREAK:
			{
				// We can move from the HS_IDLE_BREAK state to any of the following states.
				switch(pPort->PendingOperation)
				{
				case HS_FORCE_CLOSED:
				case HS_CLOSE:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_CLOSED;	// Wait for IDLE_CLOSED 
					break;

				case HS_STOP:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_OPEN;		// Wait for IDLE_OPEN 
					break;

				default:
					break;	// We cannot move to any other states from here.
				}

				break;
			}

		case HS_IDLE_CLOSED:
			{
				// We can move from the HS_IDLE_CLOSED state to any of the following states.
				switch(pPort->PendingOperation)
				{
				case HS_FORCE_CLOSED:
				case HS_CLOSE:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_CLOSED;	// Wait for IDLE_CLOSED 
					break;

				case HS_LOPEN:
				case HS_MOPEN:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_OPEN;		// Wait for IDLE_OPEN 
					break;

				default:
					break;	// We cannot move to any other states from here.
				}

				break;

			}


		default:
			break;	// We are not in a state that is under the driver's control.
		
		}	


		switch(pChan->hi_hstat)		// Check current state of channel now
		{
		case HS_LOPEN:				
		case HS_MOPEN:
		case HS_IDLE_MPEND:
		case HS_CONFIG:
		case HS_CLOSE:
		case HS_IDLE_CLOSED:
			break;

		default:
			{
				if(pPort->DeviceIsOpen)							// If Port is open
				{
					slxos_mint(pPort);							// Service modem changes 
					ExceptionHandle(pPort, pChan->hi_state);	// Service exceptions 

					if(pChan->hi_state & ST_BREAK)				// If break received
						pChan->hi_state &= ~ST_BREAK;			// Clear break status 

					slxos_rxint(pPort);							// Service Receive Data 
					slxos_txint(pPort);							// Service Transmit Data 
				}

				break;
			}
		}



	} /* for(nChan... */

	pCard->DpcFlag = FALSE;					/* No longer running the Dpc */
#if	DBG
	SpxDebugLevel = SavedDebugLevel;
#endif
	return(TRUE);						/* Done */

} /* Slxos_PollForInterrupt */

/***************************************************************************\
*                                                                           *
* BOOLEAN ExceptionHandle(                                                  *
*    IN PPORT_DEVICE_EXTENSION pPort,										*
*    IN UCHAR State)                                                        *
*                                                                           *
\***************************************************************************/
BOOLEAN ExceptionHandle(IN PPORT_DEVICE_EXTENSION pPort, IN UCHAR State)
{
    UCHAR lineStatus = 0;
	PCHAN pChan = (PCHAN)pPort->pChannel;

    SpxDbgMsg( SERDIAG1, ("%s: exception, state 0x%x\n", PRODUCT_NAME, State));

    if(State & ST_BREAK) 
	{
        SpxDbgMsg( SERDIAG1, ("ST_BREAK\n"));
        lineStatus |= SERIAL_LSR_BI;
    }


	if(pChan->err_framing)	lineStatus |= SERIAL_LSR_FE;	/* Framing Errors */
	if(pChan->err_parity)	lineStatus |= SERIAL_LSR_PE;	/* Parity Errors */
	if(pChan->err_overrun)	lineStatus |= SERIAL_LSR_OE;	/* Overrun Errors */
	if(pChan->err_overflow)	lineStatus |= SERIAL_LSR_OE;	/* Overflow Errors */

	pChan->err_framing	= 0;								/* Reset errros */
	pChan->err_parity	= 0;
	pChan->err_overrun	= 0;
	pChan->err_overflow = 0;

    if(lineStatus != 0) 
	{
        SerialProcessLSR(pPort, lineStatus);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN slxos_txint(IN PPORT_DEVICE_EXTENSION pPort)						*
*                                                                           *
\***************************************************************************/
BOOLEAN slxos_txint(IN PPORT_DEVICE_EXTENSION pPort)
{
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR nchars;
    BOOLEAN ServicedAnInterrupt = FALSE;

    SpxDbgMsg(SERDIAG2, ("%s: slxos_txint for %x.\n", PRODUCT_NAME, pPort->pChannel));


#if USE_NEW_TX_BUFFER_EMPTY_DETECT
	// Only on cards that we can detect a Tx buffer empty event. 
	if(pPort->DetectEmptyTxBuffer && pPort->DataInTxBuffer)
	{	// If there was some data in Tx buffer...
		if(!Slxos_GetCharsInTxBuffer(pPort) && !((PCHAN)pPort->pChannel)->tx_fifo_count)	// ... and now it is empty then...
		{
			pPort->DataInTxBuffer = FALSE;		// Reset flag now that buffer is empty.

			pPort->EmptiedTransmit = TRUE;		// set flag to indicate we have done some transmission
												// since a Tx Empty event was asked for.

			if(!pPort->WriteLength && !pPort->TransmitImmediate)
				SerialProcessEmptyTransmit(pPort);	// See if we need to signal the Tx empty event.	
		}
	}
#endif

    for (;;) 
	{
		// If we have nothing at all remaining to send then exit.
		if(!pPort->WriteLength && !pPort->TransmitImmediate)
			break;

		// Calculate out how much space we have remaining in the card buffer.
        nchars = 255 - ((CHAR)channelControl->hi_txipos - (CHAR)channelControl->hi_txopos);

		// If we have no space left in the buffer then exit as we can't send anything.
        if(nchars == 0)
            break;
  

		// If we have no immediate chars to send & we are flowed off for any reason
		// then exit because we will not be able to send anything. 
		if(!pPort->TransmitImmediate && pPort->TXHolding)
            break;

		// Try to send some data...
		ServicedAnInterrupt = TRUE;
        SendTxChar(pPort);


		// If we have no ordinary data to send or we are flowed 
		// off for any reason at all then break out or we will hang!
 		if(!pPort->WriteLength || pPort->TXHolding)
            break;
    }

    return ServicedAnInterrupt;
}

/***************************************************************************\
*                                                                           *
* ULONG CopyCharsToTxBuffer(IN PPORT_DEVICE_EXTENSION pPort)				*
*                                                                           *
* This routine which is only called at interrupt level is used to fill the  *
* transmit buffer of the device, or empty the list of queued characters to  *
* transmit if there are fewer characters available than that.               *
*                                                                           *
* pPort - The current device extension.										*
*                                                                           *
* InputBuffer - Source of characters to transfer to the queue.              *
*                                                                           *
* InputBufferLength - Maximum number of characters to transfer.             *
*                                                                           *
* Return Value:                                                             *
*           This routine returns the number of characters copied to the     *
*           transmit buffer.                                                *
*                                                                           *
\***************************************************************************/
ULONG CopyCharsToTxBuffer(IN PPORT_DEVICE_EXTENSION pPort, IN PUCHAR InputBuffer, IN ULONG InputBufferLength)
{
	PCHAN channelControl = (PCHAN)pPort->pChannel;
	UCHAR nchars;

    nchars = (CHAR)channelControl->hi_txipos - (CHAR)channelControl->hi_txopos;
    nchars = 255 - nchars;

    if(InputBufferLength < nchars) 
	{
		nchars = (UCHAR)InputBufferLength;
    }

    SpxDbgMsg(SERDIAG1, ("%s: Copying %d/%d characters to Tx buffer\n", PRODUCT_NAME, nchars, InputBufferLength));

    if(nchars) 
	{
        if(channelControl->hi_txipos + nchars <= 256) 
		{
			if(pPort->pParentCardExt->CardType == SiPCI)
			{
				SpxCopyBytes(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								nchars);
			}
			else
			{
				RtlMoveMemory(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								nchars);
			}
		} 
		else 
		{
            UCHAR sizeOfFirstMove = 256 - channelControl->hi_txipos;

			if(pPort->pParentCardExt->CardType == SiPCI)
			{
				SpxCopyBytes(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								sizeOfFirstMove);
			}
			else
			{
				RtlMoveMemory(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								sizeOfFirstMove);
			}

			if(pPort->pParentCardExt->CardType == SiPCI)
			{
				SpxCopyBytes(	&channelControl->hi_txbuf[0],
								InputBuffer + sizeOfFirstMove,
								nchars - sizeOfFirstMove);
			}
			else
			{
				RtlMoveMemory(	&channelControl->hi_txbuf[0],
								InputBuffer + sizeOfFirstMove,
								nchars - sizeOfFirstMove);
			}
        }

		pPort->DataInTxBuffer = TRUE;	// Set flag to indicate we have placed data in Tx buffer on card.

        channelControl->hi_txipos += nchars;
		pPort->PerfStats.TransmittedCount += nchars;	// Increment counter for performance stats.

#ifdef WMI_SUPPORT 
		pPort->WmiPerfData.TransmittedCount += nchars;
#endif
    }

    return nchars;
}


void	SpxCopyBytes(PUCHAR To, PUCHAR From,ULONG Count)
{
	while(Count--) *To++ = *From++;

} /* SpxCopyBytes */

/***************************************************************************\
*                                                                           *
* ULONG Slxos_GetCharsInTxBuffer(IN PVOID Context)                          *
*                                                                           *
* This routine is used to return the number of characters stored in the     *
* hardware transmit buffer.                                                 *
*                                                                           *
* Context - really the current device extension.                            *
*                                                                           *
* Return Value:                                                             *
*           This routine returns the number of characters in the            *
*           transmit buffer.                                                *
*                                                                           *
\***************************************************************************/
ULONG Slxos_GetCharsInTxBuffer(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR nchars;

    nchars = (CHAR)channelControl->hi_txipos - (CHAR)channelControl->hi_txopos;

    return nchars;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN SendTxChar(IN PPORT_DEVICE_EXTENSION pPort)						*
*                                                                           *
\***************************************************************************/
BOOLEAN SendTxChar(IN PPORT_DEVICE_EXTENSION pPort)
{
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    ULONG nchars;

    if(pPort->WriteLength || pPort->TransmitImmediate) 
	{

        //
        // Even though all of the characters being
        // sent haven't all been sent, this variable
        // will be checked when the transmit queue is
        // empty.  If it is still true and there is a
        // wait on the transmit queue being empty then
        // we know we finished transmitting all characters
        // following the initiation of the wait since
        // the code that initiates the wait will set
        // this variable to false.
        //
        // One reason it could be false is that
        // the writes were cancelled before they
        // actually started, or that the writes
        // failed due to timeouts.  This variable
        // basically says a character was written
        // by the isr at some point following the
        // initiation of the wait.
        //

        pPort->EmptiedTransmit = TRUE;

        //
        // If we have output flow control based on
        // the modem status lines, then we have to do
        // all the modem work before we output each
        // character. (Otherwise we might miss a
        // status line change.)
        //

        if(pPort->TransmitImmediate && (!pPort->TXHolding || (pPort->TXHolding == SERIAL_TX_XOFF))) 
		{

            //
            // Even if transmission is being held
            // up, we should still transmit an immediate
            // character if all that is holding us
            // up is xon/xoff (OS/2 rules).
            //
            SpxDbgMsg(SERDIAG1, ("%s: slxos_txint. TransmitImmediate.\n",PRODUCT_NAME));

            if(CopyCharsToTxBuffer(pPort, &pPort->ImmediateChar, 1) != 0) 
			{
				pPort->TransmitImmediate = FALSE;

				KeInsertQueueDpc(&pPort->CompleteImmediateDpc, NULL, NULL);
            }
        } 
		else if(!pPort->TXHolding) 
		{

            nchars = CopyCharsToTxBuffer(pPort, pPort->WriteCurrentChar, pPort->WriteLength);

            pPort->WriteCurrentChar += nchars;
            pPort->WriteLength -= nchars;

            if(!pPort->WriteLength) 
			{
                PIO_STACK_LOCATION IrpSp;

                //
                // No more characters left.  This write is complete.  
                // Take care when updating the information field, 
                // we could have an xoff counter masquerading as a write irp.
                //

                IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

                pPort->CurrentWriteIrp->IoStatus.Information
                     = (IrpSp->MajorFunction == IRP_MJ_WRITE) 
					 ? (IrpSp->Parameters.Write.Length) : (1);

				KeInsertQueueDpc(&pPort->CompleteWriteDpc, NULL, NULL);
	                   
            }

        }
    }

    return TRUE;
}

/*****************************************************************************
******************************                 *******************************
******************************   slxos_rxint   *******************************
******************************                 *******************************
******************************************************************************

Prototype:	void	slxos_rxint(IN PPORT_DEVICE_EXTENSION pPort)

Description:	Check for and transfer receive data for the specified device

Parameters:	pPort points to the extension structure for the device

Returns:	None

NOTE:		This routine is only called at device level.

*/

void slxos_rxint(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCHAN	pChan = (PCHAN)pPort->pChannel;
	UCHAR	out = pChan->hi_rxopos;
	UCHAR	in;
#ifdef	ESIL_XXX0				/* ESIL_XXX0 15/20/98 */
	UCHAR	svout = pPort->saved_hi_rxopos;
	UCHAR	svin;
#endif						/* ESIL_XXX0 15/20/98 */
	int	len;

#ifdef	ESIL_XXX0				/* ESIL_XXX0 15/20/98 */
	while((svin = pPort->saved_hi_rxipos) != svout)
	{
		if(pPort->RXHolding & (SERIAL_RX_XOFF|SERIAL_RX_RTS|SERIAL_RX_DTR)) 
			break;/* Flowed off */
		
		if(svout <= svin)	
			len = svin - svout;		/* Length of block to copy */
		else			
			len = 0x100 - svout;	/* Length of block to end of buffer */
		
		if(len == 0)	
			break;					/* Buffer is empty, done */

		svout += SerialPutBlock(pPort, &pPort->saved_hi_rxbuf[svout], (UCHAR)len, TRUE);
		pPort->saved_hi_rxopos = svout;						/* Update output pointer on card */
	}
#endif						/* ESIL_XXX0 15/20/98 */

	while((in = pChan->hi_rxipos) != out)
	{
		if(pPort->RXHolding & (SERIAL_RX_XOFF|SERIAL_RX_RTS|SERIAL_RX_DTR)) 
			break;	/* Flowed off */
		
		if(out <= in)	
			len = in - out;			/* Length of block to copy */
		else		
			len = 0x100 - out;		/* Length of block to end of buffer */
		
		if(len == 0)	
			break;					/* Buffer is empty, done */

		out += SerialPutBlock(pPort, &pChan->hi_rxbuf[out], (UCHAR)len, TRUE);/* Copy block & update output pointer (and wrap) */
	}

	pChan->hi_rxopos = out;			/* Update output pointer on card */

} /* slxos_rxint */

/*****************************************************************************
*******************************                *******************************
*******************************   slxos_mint   *******************************
*******************************                *******************************
******************************************************************************

Prototype:	void	slxos_mint(IN PPORT_DEVICE_EXTENSION pPort)

Description:	Check for and report changes in input modem signals

Parameters:	pPort points to the extension structure for the device

Returns:	None

NOTE:		This routine is only called at device level.

*/

void slxos_mint(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCHAN pChan = (PCHAN)pPort->pChannel;

	SerialHandleModemUpdate(pPort);

} /* slxos_mint */



/************************************************
*
*	DisplayCompletedIrp((PIRP Irp,int index))
*
*************************************************/
#ifdef	CHECK_COMPLETED
void	DisplayCompletedIrp(PIRP Irp,int index)
{
	PIO_STACK_LOCATION	IrpSp;

	IrpSp = IoGetCurrentIrpStackLocation(Irp);

	if(IrpSp->MajorFunction == IRP_MJ_WRITE)
	{
		SpxDbgMsg(SERDEBUG,("Complete WRITE Irp %lX at %d\n",Irp,index));
	}

	if(IrpSp->MajorFunction == IRP_MJ_READ)
	{
		int	loop, len;

		SpxDbgMsg(SERDEBUG,("Complete READ Irp %lX at %d, requested %d, returned %d [",
			Irp, index, IrpSp->Parameters.Read.Length, Irp->IoStatus.Information));

		len = Irp->IoStatus.Information;

		if(len > 10) 
			len = 10;

		for(loop=0; loop<len; loop++)
			SpxDbgMsg(SERDEBUG,("%02X ", ((PUCHAR)Irp->AssociatedIrp.SystemBuffer)[loop]));

		SpxDbgMsg(SERDEBUG,("]\n"));
	}

} /* DisplayCompletedIrp */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\si4_cf.c ===
/* SI4_CF.C Version, Bootstrap and Download Code Arrays... */

char *si4_cf_ident = "%W%";

/* SI4_CF embedded version... 

	Copyright (c) Perle Systems Ltd 1996-2000.
	JETCF.BIN Version 4.0.4 Created Sep 18 2000 @ 14:56:11

*/

unsigned char si4_cf_download[] =
{
	0x05,0x00,0x1F,0xFC,0x00,0x00,0x04,0x08,	/* 0000: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0008: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0010: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0018: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0020: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0028: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0030: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0038: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0040: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0048: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0050: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0058: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0060: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0068: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0070: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0078: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0080: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0088: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0090: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0098: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0100: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0108: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0110: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0118: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0120: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0128: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0130: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0138: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0140: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0148: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0150: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0158: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0160: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0168: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0170: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0178: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0180: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0188: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0190: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0198: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0200: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0208: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0210: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0218: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0220: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0228: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0230: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0238: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0240: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0248: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0250: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0258: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0260: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0268: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0270: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0278: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0280: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0288: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0290: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0298: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0300: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0308: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0310: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0318: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0320: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0328: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0330: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0338: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0340: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0348: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0350: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0358: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0360: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0368: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0370: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0378: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0380: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0388: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0390: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0398: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0400: ........ */
	0x4E,0xF9,0x00,0x00,0x05,0xFC,0x2E,0x7C,	/* 0408: N....| */
	0x05,0x00,0x1F,0xFC,0x4E,0xB9,0x00,0x00,	/* 0410: ...N.. */
	0x04,0xAC,0x2F,0x00,0x4E,0xB9,0x00,0x00,	/* 0418: ...N.. */
	0x04,0x28,0x4E,0xB9,0x00,0x00,0x06,0x60,	/* 0420: .(N...` */
	0x2F,0x0D,0x2A,0x7C,0x05,0x00,0x00,0x00,	/* 0428: ..*|.... */
	0x20,0x7C,0x05,0x00,0x00,0x00,0xB1,0xCD,	/* 0430:  |.... */
	0x67,0x18,0x20,0x3C,0x05,0x00,0x00,0x00,	/* 0438: g. <.... */
	0x90,0x8D,0x2F,0x00,0x2F,0x0D,0x2F,0x08,	/* 0440: ...... */
	0x4E,0xB9,0x00,0x00,0x60,0xE8,0x4F,0xEF,	/* 0448: N..`O */
	0x00,0x0C,0x20,0x7C,0x00,0x00,0x61,0xDC,	/* 0450: .. |..a */
	0x2A,0x7C,0x00,0x00,0x61,0xDC,0xB1,0xCD,	/* 0458: *|..a */
	0x67,0x18,0x20,0x3C,0x00,0x00,0x63,0xD0,	/* 0460: g. <..c */
	0x90,0x8D,0x2F,0x00,0x2F,0x08,0x2F,0x0D,	/* 0468: ...... */
	0x4E,0xB9,0x00,0x00,0x60,0xE8,0x4F,0xEF,	/* 0470: N..`O */
	0x00,0x0C,0x20,0x7C,0x00,0x00,0x63,0xF0,	/* 0478: .. |..c */
	0x2A,0x7C,0x00,0x00,0x63,0xD0,0xBB,0xC8,	/* 0480: *|..c */
	0x67,0x14,0x20,0x08,0x90,0x8D,0x2F,0x00,	/* 0488: g. ... */
	0x42,0xA7,0x2F,0x0D,0x4E,0xB9,0x00,0x00,	/* 0490: B..N.. */
	0x61,0x5C,0x4F,0xEF,0x00,0x0C,0x4E,0xB9,	/* 0498: a\O..N */
	0x00,0x00,0x61,0xD8,0x70,0x01,0x2A,0x5F,	/* 04A0: ..ap.*_ */
	0x4E,0x75,0x4E,0x71,0x61,0x00,0xFF,0x7A,	/* 04A8: NuNqa.z */
	0x4E,0xB9,0x00,0x00,0x06,0x60,0x4E,0x75,	/* 04B0: N...`Nu */
	0x70,0x04,0x13,0xC0,0x10,0x00,0x00,0x41,	/* 04B8: p.....A */
	0x70,0xC0,0x13,0xC0,0x10,0x00,0x00,0x03,	/* 04C0: p..... */
	0x30,0x3C,0xFF,0xFE,0x33,0xC0,0x10,0x00,	/* 04C8: 0<3.. */
	0x00,0x36,0x20,0x7C,0x10,0x00,0x00,0xCA,	/* 04D0: .6 |... */
	0x30,0xBC,0x00,0xB0,0x70,0x84,0x13,0xC0,	/* 04D8: 0.p. */
	0x10,0x00,0x00,0x14,0x72,0x88,0x13,0xC1,	/* 04E0: ....r. */
	0x10,0x00,0x00,0x15,0x70,0x8C,0x13,0xC0,	/* 04E8: ....p. */
	0x10,0x00,0x00,0x16,0x70,0x90,0x13,0xC0,	/* 04F0: ....p. */
	0x10,0x00,0x00,0x17,0x70,0x94,0x13,0xC0,	/* 04F8: ....p. */
	0x10,0x00,0x00,0x18,0x70,0x98,0x13,0xC0,	/* 0500: ....p. */
	0x10,0x00,0x00,0x19,0x70,0x9C,0x13,0xC0,	/* 0508: ....p. */
	0x10,0x00,0x00,0x1A,0x70,0x1E,0x13,0xC0,	/* 0510: ....p.. */
	0x10,0x00,0x00,0x1B,0x13,0xC1,0x10,0x00,	/* 0518: ....... */
	0x00,0x1C,0x70,0x96,0x13,0xC0,0x10,0x00,	/* 0520: ..p... */
	0x00,0x1D,0x70,0x97,0x13,0xC0,0x10,0x00,	/* 0528: ..p... */
	0x00,0x1E,0x70,0x8F,0x13,0xC0,0x10,0x00,	/* 0530: ..p... */
	0x00,0x1F,0x70,0x8E,0x13,0xC0,0x10,0x00,	/* 0538: ..p... */
	0x00,0x20,0x08,0xA8,0x00,0x06,0x00,0x01,	/* 0540: . ..... */
	0x20,0x7C,0x10,0x00,0x01,0x00,0x72,0x01,	/* 0548:  |....r. */
	0x30,0x81,0x70,0x03,0x13,0xC0,0x10,0x00,	/* 0550: 0p.... */
	0x01,0x11,0x33,0xC1,0x10,0x00,0x01,0x20,	/* 0558: ..3...  */
	0x13,0xC0,0x10,0x00,0x01,0x31,0x42,0x79,	/* 0560: ....1By */
	0x10,0x00,0x00,0x64,0x20,0x3C,0x01,0xFF,	/* 0568: ...d <. */
	0x00,0x00,0x23,0xC0,0x10,0x00,0x00,0x68,	/* 0570: ..#...h */
	0x30,0x3C,0x05,0x83,0x33,0xC0,0x10,0x00,	/* 0578: 0<.3.. */
	0x00,0x6E,0x30,0x3C,0x04,0x00,0x33,0xC0,	/* 0580: .n0<..3 */
	0x10,0x00,0x00,0x70,0x22,0x3C,0x00,0x01,	/* 0588: ...p"<.. */
	0x00,0x00,0x23,0xC1,0x10,0x00,0x00,0x74,	/* 0590: ..#...t */
	0x30,0x3C,0x00,0xA3,0x33,0xC0,0x10,0x00,	/* 0598: 0<.3.. */
	0x00,0x7A,0x30,0x3C,0x02,0x00,0x33,0xC0,	/* 05A0: .z0<..3 */
	0x10,0x00,0x00,0x7C,0x20,0x3C,0x00,0x07,	/* 05A8: ...| <.. */
	0x00,0x00,0x23,0xC0,0x10,0x00,0x00,0x80,	/* 05B0: ..#... */
	0x30,0x3C,0x19,0x43,0x33,0xC0,0x10,0x00,	/* 05B8: 0<.C3.. */
	0x00,0x86,0x30,0x3C,0x03,0x00,0x33,0xC0,	/* 05C0: .0<..3 */
	0x10,0x00,0x00,0x88,0x23,0xC1,0x10,0x00,	/* 05C8: ...#.. */
	0x00,0x8C,0x30,0x3C,0x09,0x83,0x33,0xC0,	/* 05D0: .0<.3 */
	0x10,0x00,0x00,0x92,0x42,0x79,0x10,0x00,	/* 05D8: ...By.. */
	0x00,0x94,0x42,0x79,0x10,0x00,0x00,0xA0,	/* 05E0: .By... */
	0x42,0x79,0x10,0x00,0x00,0xAC,0x42,0x79,	/* 05E8: By...By */
	0x10,0x00,0x00,0xB8,0x42,0x79,0x10,0x00,	/* 05F0: ...By.. */
	0x00,0xC6,0x4E,0x75,0x46,0xFC,0x21,0x00,	/* 05F8: .NuF!. */
	0x22,0x0F,0x2E,0x7C,0x00,0x00,0x00,0x00,	/* 0600: "..|.... */
	0x4E,0x7B,0xF8,0x01,0x2E,0x41,0x70,0x00,	/* 0608: N{..Ap. */
	0x4E,0x7B,0x00,0x04,0x4E,0x7B,0x00,0x05,	/* 0610: N{..N{.. */
	0x20,0x3C,0x05,0x00,0x00,0x01,0x4E,0x7B,	/* 0618:  <....N{ */
	0x0C,0x04,0x20,0x3C,0x10,0x00,0x00,0x01,	/* 0620: .. <.... */
	0x4E,0x7B,0x0C,0x0F,0x4E,0xB9,0x00,0x00,	/* 0628: N{..N.. */
	0x04,0xB8,0x2E,0x79,0x05,0x00,0x1F,0xFC,	/* 0630: ..y... */
	0x2C,0x78,0x00,0x00,0x20,0x3C,0x00,0x00,	/* 0638: ,x.. <.. */
	0xC0,0x00,0x4E,0x7B,0x00,0x04,0x20,0x3C,	/* 0640: .N{.. < */
	0x01,0x00,0x00,0x00,0x4E,0x7B,0x00,0x02,	/* 0648: ....N{.. */
	0x20,0x3C,0x80,0x00,0x03,0x00,0x4E,0x7B,	/* 0650:  <...N{ */
	0x00,0x02,0x4E,0xF9,0x00,0x00,0x04,0x0E,	/* 0658: ..N.... */
	0x4E,0xB9,0x00,0x00,0x06,0x6C,0x70,0x00,	/* 0660: N...lp. */
	0x4E,0x75,0x00,0x00,0x2F,0x0D,0x22,0x3C,	/* 0668: Nu...."< */
	0x01,0x01,0x80,0x00,0x2A,0x7C,0x00,0x00,	/* 0670: ...*|.. */
	0x63,0xD0,0x2A,0x81,0x2F,0x0C,0x48,0x78,	/* 0678: c*..Hx */
	0x70,0x00,0x42,0xA7,0x2F,0x01,0x4E,0xB9,	/* 0680: p.B..N */
	0x00,0x00,0x61,0x5C,0x28,0x55,0x72,0x00,	/* 0688: ..a\(Ur. */
	0x70,0x80,0x19,0x40,0x00,0x01,0x32,0x39,	/* 0690: p.@..29 */
	0x00,0x00,0x40,0xF0,0x58,0x8C,0x20,0x01,	/* 0698: ..@X . */
	0x18,0x81,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 06A0: ..@.. */
	0x28,0x55,0x54,0x8C,0x42,0x2C,0x00,0x01,	/* 06A8: (UTB,.. */
	0x70,0x64,0x18,0x80,0x30,0x7C,0x00,0x60,	/* 06B0: pd.0|.` */
	0x2B,0x48,0x00,0x04,0x28,0x7C,0x10,0x00,	/* 06B8: +H..(|.. */
	0x00,0x00,0x2B,0x4C,0x00,0x08,0x20,0xBC,	/* 06C0: ..+L..  */
	0x00,0x00,0x07,0x70,0x4E,0xB9,0x00,0x00,	/* 06C8: ...pN.. */
	0x07,0x74,0x20,0x55,0x10,0x80,0x4E,0xB9,	/* 06D0: .t U.N */
	0x00,0x00,0x0D,0x20,0x30,0x7C,0x00,0x68,	/* 06D8: ... 0|.h */
	0x4F,0xEF,0x00,0x0C,0x2B,0x48,0x00,0x04,	/* 06E0: O..+H.. */
	0x70,0x00,0x20,0xBC,0x00,0x00,0x0D,0xA8,	/* 06E8: p. ... */
	0x20,0x55,0x10,0x10,0x53,0x80,0x66,0x00,	/* 06F0:  U..Sf. */
	0x00,0x6A,0x10,0x39,0x01,0x01,0x80,0x88,	/* 06F8: .j.9.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF0,0x4A,0x00,	/* 0700: ...J. */
	0x66,0x14,0x20,0x6D,0x00,0x08,0x30,0x3C,	/* 0708: f. m..0< */
	0xFD,0xFE,0x31,0x40,0x00,0x36,0x4E,0xB9,	/* 0710: 1@.6N */
	0x00,0x00,0x44,0xD4,0x60,0x44,0x70,0x00,	/* 0718: ..D`Dp. */
	0x30,0x39,0x00,0x00,0x61,0xE0,0x4A,0x80,	/* 0720: 09..aJ */
	0x6F,0x20,0x70,0x00,0x30,0x39,0x00,0x00,	/* 0728: o p.09.. */
	0x61,0xDE,0x4A,0x80,0x66,0x14,0x20,0x6D,	/* 0730: aJf. m */
	0x00,0x08,0x30,0x3C,0xFD,0xFE,0x31,0x40,	/* 0738: ..0<1@ */
	0x00,0x36,0x4E,0xB9,0x00,0x00,0x3E,0xEC,	/* 0740: .6N..> */
	0x60,0x18,0x2B,0x4C,0x00,0x08,0x38,0x7C,	/* 0748: `.+L..8| */
	0x00,0x70,0x2B,0x4C,0x00,0x0C,0x28,0xBC,	/* 0750: .p+L..( */
	0x00,0x00,0x40,0xD0,0x4E,0xB9,0x00,0x00,	/* 0758: ..@N.. */
	0x2D,0x04,0x3A,0x7C,0x01,0x00,0x30,0x15,	/* 0760: -.:|..0. */
	0x52,0x80,0x3A,0x80,0x60,0xF4,0x4E,0x71,	/* 0768: R:`Nq */
	0x4E,0x73,0x00,0x00,0x4E,0x56,0xFF,0xD8,	/* 0770: Ns..NV */
	0x4F,0xEF,0xFF,0xE0,0x48,0xD7,0x30,0xFC,	/* 0778: OH0 */
	0x70,0x00,0x2D,0x40,0xFF,0xD8,0x28,0x7C,	/* 0780: p.-@(| */
	0x01,0x01,0x80,0x80,0x70,0x00,0x26,0x00,	/* 0788: ..p.&. */
	0x20,0x3C,0x00,0x00,0x00,0x80,0x2D,0x40,	/* 0790:  <...-@ */
	0xFF,0xE4,0x70,0x00,0x2D,0x40,0xFF,0xE0,	/* 0798: p.-@ */
	0x22,0x2E,0xFF,0xE0,0x7A,0x00,0x78,0x00,	/* 07A0: ".z.x. */
	0x2C,0x3C,0x04,0x01,0xF0,0x1A,0xE1,0x89,	/* 07A8: ,<... */
	0x24,0x01,0x2E,0x01,0x22,0x04,0xEB,0x89,	/* 07B0: $...". */
	0xD2,0x87,0xC2,0xBC,0x00,0x00,0xFF,0xFF,	/* 07B8: .. */
	0x20,0x41,0xD1,0xC6,0x10,0x10,0xC0,0xBC,	/* 07C0:  A.. */
	0x00,0x00,0x00,0xA0,0xB0,0xBC,0x00,0x00,	/* 07C8: ..... */
	0x00,0xA0,0x67,0x14,0x70,0x01,0x26,0x00,	/* 07D0: .g.p.&. */
	0x7A,0x01,0x20,0x2E,0xFF,0xD8,0x53,0x80,	/* 07D8: z. .S */
	0x66,0x14,0x70,0xFF,0x60,0x00,0x05,0x14,	/* 07E0: f.p`... */
	0x20,0x04,0x78,0x00,0x52,0x80,0x38,0x00,	/* 07E8:  .x.R8. */
	0x70,0x04,0xB0,0x84,0x6E,0xBE,0xCA,0xBC,	/* 07F0: p.n */
	0x00,0x00,0xFF,0xFF,0x66,0x00,0x00,0x60,	/* 07F8: ..f..` */
	0xC4,0xBC,0x00,0x00,0xFF,0xFF,0x20,0x42,	/* 0800: .. B */
	0xD1,0xFC,0x04,0x01,0xF0,0x02,0x10,0x10,	/* 0808: ..... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0xB0,0xBC,	/* 0810: ... */
	0x00,0x00,0x00,0xFF,0x67,0x12,0x70,0x01,	/* 0818: ...g.p. */
	0x2D,0x40,0xFF,0xD8,0x20,0x03,0x53,0x80,	/* 0820: -@ .S */
	0x66,0x34,0x70,0xFF,0x60,0x00,0x04,0xCC,	/* 0828: f4p`.. */
	0x4A,0x83,0x66,0x0C,0x4A,0xAE,0xFF,0xD8,	/* 0830: Jf.J */
	0x66,0x06,0x70,0xFF,0x60,0x00,0x04,0xBC,	/* 0838: f.p`.. */
	0x70,0x81,0x43,0xED,0x00,0x2E,0x1B,0x40,	/* 0840: pC...@ */
	0x00,0x01,0x70,0xE0,0x1A,0x80,0x70,0x01,	/* 0848: ..p.p. */
	0x13,0x40,0x00,0x01,0x70,0x80,0x12,0x80,	/* 0850: .@..p. */
	0x70,0x01,0x60,0x00,0x04,0x9E,0x4A,0xAE,	/* 0858: p.`..J */
	0xFF,0xE0,0x67,0x40,0x20,0x2E,0xFF,0xE4,	/* 0860: g@ . */
	0x72,0x00,0x12,0x2C,0x00,0x02,0xC3,0xFC,	/* 0868: r..,.. */
	0x03,0x00,0xD0,0x81,0xD0,0xBC,0x00,0x00,	/* 0870: .... */
	0x01,0x00,0x72,0x00,0x32,0x00,0x78,0x00,	/* 0878: ..r.2.x. */
	0x2D,0x41,0xFF,0xE4,0x20,0x2E,0xFF,0xE4,	/* 0880: -A . */
	0x80,0xBC,0x00,0x00,0x80,0x00,0x38,0x00,	/* 0888: ...8. */
	0x20,0x04,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 0890:  ..@.. */
	0x18,0x84,0x28,0x6E,0xFF,0xE4,0xD9,0xFC,	/* 0898: .(n */
	0x01,0x01,0x80,0x00,0x28,0x2E,0xFF,0xE0,	/* 08A0: ...(. */
	0x42,0x2C,0x00,0x01,0x42,0x14,0x20,0x2E,	/* 08A8: B,..B. . */
	0xFF,0xE0,0x43,0xEC,0x00,0x06,0xE1,0x8C,	/* 08B0: C.. */
	0x19,0x40,0x00,0x03,0xC8,0xBC,0x00,0x00,	/* 08B8: .@.... */
	0xFF,0xFF,0x2A,0x04,0x20,0x05,0xE0,0x80,	/* 08C0: *. . */
	0x13,0x40,0x00,0x01,0x12,0x85,0x4A,0x83,	/* 08C8: .@...J */
	0x67,0x00,0x01,0x14,0x70,0x08,0x2A,0x3C,	/* 08D0: g...p.*< */
	0x04,0x01,0xF0,0xFE,0xC8,0xBC,0x00,0x00,	/* 08D8: .... */
	0xFF,0xFF,0x2E,0x3C,0x04,0x01,0xF0,0xD0,	/* 08E0: .<.. */
	0x24,0x3C,0x04,0x01,0xF0,0x30,0x19,0x40,	/* 08E8: $<..0.@ */
	0x00,0x02,0x2C,0x04,0x20,0x46,0x70,0x04,	/* 08F0: ..,. Fp. */
	0xD1,0xC5,0x42,0x10,0x20,0x46,0xD1,0xC7,	/* 08F8: B. F */
	0x42,0x10,0x20,0x46,0xD1,0xC2,0x42,0x10,	/* 0900: B. FB. */
	0x20,0x46,0xD1,0xC5,0x10,0x80,0x20,0x46,	/* 0908:  F. F */
	0x70,0x55,0xD1,0xC7,0x42,0x10,0x20,0x46,	/* 0910: pUB. F */
	0xD1,0xC2,0x10,0x80,0x20,0x46,0xD1,0xC5,	/* 0918: . F */
	0x42,0x10,0x20,0x46,0xD1,0xC2,0x10,0x10,	/* 0920: B. F.. */
	0x72,0x55,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 0928: rU... */
	0xB2,0x80,0x66,0x08,0x70,0x48,0x19,0x40,	/* 0930: f.pH.@ */
	0x00,0x08,0x60,0x06,0x70,0x28,0x19,0x40,	/* 0938: ..`.p(.@ */
	0x00,0x08,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 0940: .... */
	0x24,0x3C,0x04,0x01,0xF0,0x80,0x2C,0x04,	/* 0948: $<..,. */
	0x20,0x46,0xD1,0xC5,0x10,0x10,0x20,0x46,	/* 0950:  F.. F */
	0xD1,0xC2,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 0958: ... */
	0x19,0x40,0x00,0x1E,0x10,0x10,0x20,0x46,	/* 0960: .@.... F */
	0xD1,0xC5,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 0968: ... */
	0x19,0x40,0x00,0x1F,0x70,0x04,0x10,0x80,	/* 0970: .@..p.. */
	0x20,0x46,0xD1,0xC2,0x10,0x10,0xC0,0xBC,	/* 0978:  F.. */
	0x00,0x00,0x00,0xFF,0x19,0x40,0x00,0x20,	/* 0980: ....@.  */
	0x70,0x00,0x10,0x2C,0x00,0x08,0x72,0x48,	/* 0988: p..,..rH */
	0xB2,0x80,0x66,0x2E,0xC8,0xBC,0x00,0x00,	/* 0990: f... */
	0xFF,0xFF,0x22,0x7C,0x00,0x00,0x61,0xDC,	/* 0998: "|..a */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0x72,	/* 09A0:  D..r */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 09A8: ...... */
	0x52,0x80,0x19,0x40,0x00,0x21,0x30,0x29,	/* 09B0: R.@.!0) */
	0x00,0x04,0x52,0x80,0x33,0x40,0x00,0x04,	/* 09B8: ..R3@.. */
	0x60,0x10,0x22,0x7C,0x00,0x00,0x61,0xDC,	/* 09C0: `."|..a */
	0x30,0x29,0x00,0x02,0x52,0x80,0x33,0x40,	/* 09C8: 0)..R3@ */
	0x00,0x02,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 09D0: .... */
	0x2F,0x04,0x4E,0xB9,0x00,0x00,0x2B,0xB0,	/* 09D8: ..N..+ */
	0x58,0x8F,0x60,0x00,0x00,0x7E,0xC8,0xBC,	/* 09E0: X`..~ */
	0x00,0x00,0xFF,0xFF,0x22,0x7C,0x00,0x00,	/* 09E8: .."|.. */
	0x61,0xDC,0x20,0x44,0x30,0x11,0xD1,0xFC,	/* 09F0: a D0. */
	0x04,0x01,0xF0,0x80,0x1A,0x10,0x52,0x80,	/* 09F8: ....R */
	0x32,0x80,0xCA,0xBC,0x00,0x00,0x00,0xFF,	/* 0A00: 2... */
	0x08,0x05,0x00,0x00,0x67,0x1E,0xBA,0xBC,	/* 0A08: ....g. */
	0x00,0x00,0x00,0xAB,0x66,0x08,0x70,0x0A,	/* 0A10: ...f.p. */
	0x19,0x40,0x00,0x08,0x60,0x06,0x70,0x04,	/* 0A18: .@..`.p. */
	0x19,0x40,0x00,0x08,0x70,0x04,0x19,0x40,	/* 0A20: .@..p..@ */
	0x00,0x02,0x60,0x1C,0xBA,0xBC,0x00,0x00,	/* 0A28: ..`... */
	0x00,0xAA,0x66,0x08,0x70,0x0B,0x19,0x40,	/* 0A30: .f.p..@ */
	0x00,0x08,0x60,0x06,0x70,0x08,0x19,0x40,	/* 0A38: ..`.p..@ */
	0x00,0x08,0x70,0x08,0x19,0x40,0x00,0x02,	/* 0A40: ..p..@.. */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0xFF,0x00,	/* 0A48: 0.... */
	0x80,0xBC,0x00,0x00,0x00,0x80,0x20,0x40,	/* 0A50: ... @ */
	0xD1,0xFC,0x04,0x01,0xF0,0x00,0x70,0xFF,	/* 0A58: ...p */
	0x10,0x80,0x20,0x2E,0xFF,0xE4,0xD0,0xBC,	/* 0A60: . . */
	0x00,0x00,0x01,0x00,0x7A,0x00,0x3A,0x00,	/* 0A68: ....z.:. */
	0x4A,0xAE,0xFF,0xE0,0x67,0x2A,0x20,0x05,	/* 0A70: Jg* . */
	0x7C,0x00,0xD0,0xBC,0x00,0x00,0x00,0x60,	/* 0A78: |....` */
	0x80,0xBC,0x00,0x00,0x80,0x00,0x3C,0x00,	/* 0A80: ...<. */
	0x20,0x06,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 0A88:  ..@.. */
	0x43,0xED,0x00,0x2E,0x1A,0x86,0x20,0x05,	/* 0A90: C... . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x85,	/* 0A98: .@... */
	0x7C,0x00,0x70,0x00,0x10,0x2C,0x00,0x02,	/* 0AA0: |.p..,.. */
	0x4A,0x80,0x6F,0x00,0x02,0x1C,0x20,0x2E,	/* 0AA8: Jo... . */
	0xFF,0xE4,0x80,0xBC,0x00,0x00,0x80,0x00,	/* 0AB0: ... */
	0x74,0x00,0x34,0x00,0x2A,0x45,0x43,0xF4,	/* 0AB8: t.4.*EC */
	0x6A,0x0A,0x20,0x05,0xE0,0x80,0x13,0x40,	/* 0AC0: j. ..@ */
	0x00,0x01,0xDB,0xFC,0x01,0x01,0x80,0x00,	/* 0AC8: ..... */
	0x12,0x85,0x1B,0x6C,0x00,0x08,0x00,0x06,	/* 0AD0: ..l.... */
	0x70,0x10,0x1B,0x40,0x00,0x0E,0x70,0x01,	/* 0AD8: p..@..p. */
	0x1B,0x40,0x00,0x1F,0x1B,0x46,0x00,0x07,	/* 0AE0: .@...F.. */
	0x70,0xFF,0x1B,0x40,0x00,0x22,0x42,0x2D,	/* 0AE8: p.@."B- */
	0x00,0x45,0x4A,0x83,0x67,0x00,0x00,0x9C,	/* 0AF0: .EJg.. */
	0x41,0xEE,0xFF,0xE8,0x22,0x7C,0x00,0x00,	/* 0AF8: A"|.. */
	0x0D,0x08,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 0B00: .... */
	0x2E,0x04,0x20,0x07,0x20,0xD9,0xE0,0x80,	/* 0B08: .. .  */
	0x20,0xD9,0x20,0xD9,0x20,0xD9,0x43,0xED,	/* 0B10:    C */
	0x00,0x02,0x13,0x40,0x00,0x01,0x12,0x87,	/* 0B18: ...@... */
	0x70,0x04,0xB0,0x86,0x6E,0x1A,0xC8,0xBC,	/* 0B20: p.n. */
	0x00,0x00,0xFF,0xFF,0x20,0x44,0xD1,0xFC,	/* 0B28: .. D */
	0x04,0x01,0xF0,0xFE,0x1E,0x10,0xCE,0xBC,	/* 0B30: .... */
	0x00,0x00,0x00,0xFF,0xE8,0x87,0x60,0x16,	/* 0B38: ...`. */
	0xC8,0xBC,0x00,0x00,0xFF,0xFF,0x20,0x44,	/* 0B40: .. D */
	0xD1,0xFC,0x04,0x01,0xF0,0xFE,0x1E,0x10,	/* 0B48: .... */
	0xCE,0xBC,0x00,0x00,0x00,0x0F,0x1B,0x47,	/* 0B50: .....G */
	0x00,0x24,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 0B58: .$... */
	0x10,0x36,0x78,0xE8,0x1B,0x40,0x00,0x26,	/* 0B60: .6x.@.& */
	0x10,0x07,0xC0,0xBC,0x00,0x00,0x00,0x07,	/* 0B68: ...... */
	0x5B,0x80,0x66,0x10,0x4A,0x86,0x67,0x06,	/* 0B70: [f.Jg. */
	0x70,0x04,0xB0,0x86,0x66,0x06,0x70,0x01,	/* 0B78: p.f.p. */
	0x1B,0x40,0x00,0x27,0x7E,0x0B,0x1B,0x47,	/* 0B80: .@.'~..G */
	0x00,0x36,0x1B,0x47,0x00,0x37,0x60,0x00,	/* 0B88: .6.G.7`. */
	0x00,0xE0,0x41,0xEE,0xFF,0xF8,0x22,0x7C,	/* 0B90: .A"| */
	0x00,0x00,0x0D,0x18,0x7E,0x00,0x70,0x08,	/* 0B98: ....~.p. */
	0x20,0xD9,0x20,0xD9,0x1E,0x2C,0x00,0x08,	/* 0BA0:   .,.. */
	0xB0,0x87,0x67,0x06,0x70,0x0B,0xB0,0x87,	/* 0BA8: g.p. */
	0x66,0x22,0x43,0xED,0x00,0x02,0x20,0x06,	/* 0BB0: f"C.. . */
	0x7E,0x00,0xE9,0x88,0xD0,0x84,0x3E,0x00,	/* 0BB8: ~.>. */
	0x20,0x07,0xE0,0x80,0x13,0x40,0x00,0x01,	/* 0BC0:  ..@.. */
	0x12,0x87,0x70,0x01,0xED,0xA8,0x1B,0x40,	/* 0BC8: .p..@ */
	0x00,0x0F,0x60,0x26,0x43,0xED,0x00,0x02,	/* 0BD0: ..`&C.. */
	0x41,0xF6,0x6A,0xF8,0x7E,0x00,0x30,0x10,	/* 0BD8: Aj~.0. */
	0xE9,0x88,0xD0,0x84,0x3E,0x00,0x20,0x07,	/* 0BE0: >. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x87,	/* 0BE8: .@... */
	0x70,0x01,0x32,0x10,0xE3,0xA8,0x1B,0x40,	/* 0BF0: p.2..@ */
	0x00,0x0F,0x20,0x06,0xC0,0xBC,0x00,0x00,	/* 0BF8: .. ... */
	0x00,0x01,0x66,0x12,0x7E,0x00,0x1E,0x2C,	/* 0C00: ..f.~.., */
	0x00,0x08,0x70,0x04,0xB0,0x87,0x67,0x06,	/* 0C08: ..p.g. */
	0x70,0x0A,0xB0,0x87,0x66,0x5A,0x43,0xED,	/* 0C10: p.fZC */
	0x00,0x02,0x70,0x00,0x10,0x29,0x00,0x01,	/* 0C18: ..p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 0C20: ..r.2. */
	0x2E,0x01,0x70,0xE0,0xCE,0xBC,0xFF,0xFF,	/* 0C28: ..p */
	0xFF,0xEF,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 0C30:  G.. */
	0xF0,0x08,0x10,0x80,0x20,0x47,0x70,0x02,	/* 0C38: .. Gp. */
	0xD1,0xFC,0x04,0x01,0xF0,0x0A,0x42,0x10,	/* 0C40: ...B. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x0C,	/* 0C48:  G... */
	0x42,0x10,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 0C50: B. G.. */
	0xF0,0x0E,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 0C58: .. G */
	0x04,0x01,0xF0,0x1C,0x10,0x10,0x20,0x47,	/* 0C60: ..... G */
	0xD1,0xFC,0x04,0x01,0xF0,0x1A,0x42,0x10,	/* 0C68: ...B. */
	0x43,0xED,0x00,0x04,0x20,0x02,0xE0,0x80,	/* 0C70: C.. . */
	0x13,0x40,0x00,0x01,0x7E,0x00,0x12,0x82,	/* 0C78: .@..~.. */
	0x20,0x05,0xD0,0xBC,0x00,0x00,0x03,0x00,	/* 0C80:  ..... */
	0x7A,0x00,0x3A,0x00,0x20,0x05,0xD0,0xBC,	/* 0C88: z.:. . */
	0x00,0x00,0x00,0x60,0x80,0xBC,0x00,0x00,	/* 0C90: ...`.. */
	0x80,0x00,0x3E,0x00,0x20,0x07,0xE0,0x80,	/* 0C98: .>. . */
	0x1B,0x40,0x00,0x01,0x43,0xED,0x00,0x2E,	/* 0CA0: .@..C.. */
	0x1A,0x87,0x20,0x05,0xE0,0x80,0x13,0x40,	/* 0CA8: . ..@ */
	0x00,0x01,0x12,0x85,0x20,0x06,0x52,0x80,	/* 0CB0: ... .R */
	0x7C,0x00,0x3C,0x00,0x70,0x00,0x10,0x2C,	/* 0CB8: |.<.p.., */
	0x00,0x02,0xBC,0x80,0x6D,0x00,0xFD,0xF6,	/* 0CC0: ..m. */
	0x20,0x2E,0xFF,0xE0,0x72,0x00,0x52,0x80,	/* 0CC8:  .r.R */
	0x32,0x00,0x2D,0x41,0xFF,0xE0,0x20,0x2E,	/* 0CD0: 2.-A . */
	0xFF,0xE0,0x59,0x80,0x6D,0x00,0xFA,0xC2,	/* 0CD8: Ym. */
	0x70,0x81,0x43,0xED,0x00,0x2E,0x1B,0x40,	/* 0CE0: pC...@ */
	0x00,0x01,0x70,0xE0,0x1A,0x80,0x70,0x01,	/* 0CE8: ..p.p. */
	0x13,0x40,0x00,0x01,0x70,0x80,0x12,0x80,	/* 0CF0: .@..p. */
	0x70,0x01,0x4C,0xD7,0x30,0xFC,0x4F,0xEF,	/* 0CF8: p.L0O */
	0x00,0x20,0x4E,0x5E,0x4E,0x75,0x4E,0x71,	/* 0D00: . N^NuNq */
	0xF0,0xD0,0x00,0xF0,0x00,0xC0,0x00,0x00,	/* 0D08: .... */
	0xF0,0xD0,0xF0,0xF0,0x00,0xC0,0x00,0x00,	/* 0D10: ... */
	0x00,0x00,0x00,0x03,0x00,0x04,0x00,0x07,	/* 0D18: ........ */
	0x22,0x79,0x00,0x00,0x61,0xF0,0x30,0x11,	/* 0D20: "y..a0. */
	0x80,0xBC,0x00,0x00,0x00,0x01,0x32,0x80,	/* 0D28: ....2 */
	0x30,0x11,0xC0,0xBC,0x00,0x00,0xFF,0xFE,	/* 0D30: 0... */
	0x32,0x80,0x20,0x79,0x00,0x00,0x63,0xD0,	/* 0D38: 2 y..c */
	0x70,0x00,0x54,0x88,0x10,0x28,0x00,0x01,	/* 0D40: p.T.(.. */
	0xE1,0x88,0x10,0x10,0x72,0x00,0x32,0x00,	/* 0D48: ..r.2. */
	0x70,0x0A,0xB0,0x81,0x6C,0x36,0x70,0x00,	/* 0D50: p.l6p. */
	0x10,0x28,0x00,0x01,0xE1,0x88,0x10,0x10,	/* 0D58: .(.... */
	0x72,0x00,0x32,0x00,0xB2,0xBC,0x00,0x00,	/* 0D60: r.2... */
	0x03,0xE8,0x6C,0x20,0x72,0x00,0x70,0x00,	/* 0D68: .l r.p. */
	0x12,0x28,0x00,0x01,0xE1,0x89,0x12,0x10,	/* 0D70: .(.... */
	0x30,0x01,0x22,0x00,0x20,0x3C,0x00,0x00,	/* 0D78: 0.". <.. */
	0x26,0x25,0x4C,0x41,0x08,0x00,0x33,0x40,	/* 0D80: &%LA..3@ */
	0x00,0x04,0x60,0x06,0x70,0x61,0x33,0x40,	/* 0D88: ..`.pa3@ */
	0x00,0x04,0x32,0xBC,0xFF,0x1C,0x42,0x69,	/* 0D90: ..2.Bi */
	0x00,0x0C,0x30,0x11,0x80,0xBC,0x00,0x00,	/* 0D98: ..0... */
	0x00,0x01,0x32,0x80,0x4E,0x75,0x4E,0x71,	/* 0DA0: ..2NuNq */
	0x4F,0xEF,0xFF,0xEC,0x48,0xD7,0x23,0x03,	/* 0DA8: OH#. */
	0x2A,0x79,0x00,0x00,0x63,0xD0,0x20,0x7C,	/* 0DB0: *y..c | */
	0x00,0x00,0x61,0xEC,0x70,0x00,0x22,0x68,	/* 0DB8: ..ap."h */
	0x00,0x04,0x54,0x8D,0x10,0x2D,0x00,0x01,	/* 0DC0: ..T.-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 0DC8: ..r.2. */
	0x4A,0x81,0x67,0x00,0x00,0x76,0x70,0x00,	/* 0DD0: Jg..vp. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 0DD8: .-.... */
	0x72,0x00,0x32,0x00,0x20,0x01,0x22,0x3C,	/* 0DE0: r.2. ."< */
	0x00,0x00,0x26,0x25,0x4C,0x40,0x18,0x01,	/* 0DE8: ..&%L@.. */
	0x70,0x00,0x30,0x29,0x00,0x04,0xB0,0x81,	/* 0DF0: p.0).. */
	0x67,0x50,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 0DF8: gPp..-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 0E00: ..r.2. */
	0x70,0x0A,0xB0,0x81,0x6C,0x36,0x70,0x00,	/* 0E08: p.l6p. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 0E10: .-.... */
	0x72,0x00,0x32,0x00,0xB2,0xBC,0x00,0x00,	/* 0E18: r.2... */
	0x03,0xE8,0x6C,0x20,0x72,0x00,0x70,0x00,	/* 0E20: .l r.p. */
	0x12,0x2D,0x00,0x01,0xE1,0x89,0x12,0x15,	/* 0E28: .-.... */
	0x30,0x01,0x22,0x00,0x20,0x3C,0x00,0x00,	/* 0E30: 0.". <.. */
	0x26,0x25,0x4C,0x41,0x08,0x00,0x33,0x40,	/* 0E38: &%LA..3@ */
	0x00,0x04,0x60,0x06,0x70,0x61,0x33,0x40,	/* 0E40: ..`.pa3@ */
	0x00,0x04,0x70,0x02,0x13,0x40,0x00,0x11,	/* 0E48: ..p..@.. */
	0x70,0x01,0x10,0x80,0x4C,0xD7,0x23,0x03,	/* 0E50: p..L#. */
	0x4F,0xEF,0x00,0x14,0x4E,0x73,0x4E,0x71,	/* 0E58: O..NsNq */
	0x20,0x79,0x00,0x00,0x63,0xD0,0x70,0x00,	/* 0E60:  y..cp. */
	0x72,0x00,0x43,0xE8,0x00,0x0A,0x10,0x29,	/* 0E68: r.C...) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x52,0x80,	/* 0E70: ....R */
	0x32,0x00,0x20,0x01,0xE0,0x80,0x13,0x40,	/* 0E78: 2. ..@ */
	0x00,0x01,0x12,0x81,0x4E,0xB9,0x00,0x00,	/* 0E80: ...N.. */
	0x0E,0x94,0x42,0x39,0x00,0x00,0x61,0xEC,	/* 0E88: .B9..a */
	0x4E,0x75,0x00,0x00,0x4F,0xEF,0xFF,0xF4,	/* 0E90: Nu..O */
	0x20,0x79,0x00,0x00,0x63,0xD0,0x70,0x00,	/* 0E98:  y..cp. */
	0x48,0xD7,0x28,0x40,0x43,0xE8,0x00,0x0A,	/* 0EA0: H(@C.. */
	0x7C,0x00,0x2A,0x7C,0x01,0x01,0x81,0x80,	/* 0EA8: |.*|.. */
	0x26,0x7C,0x00,0x00,0x61,0xF4,0x10,0x29,	/* 0EB0: &|..a.) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x52,0x80,	/* 0EB8: ....R */
	0x3C,0x00,0x20,0x06,0x12,0x86,0xE0,0x80,	/* 0EC0: <. .. */
	0x13,0x40,0x00,0x01,0x10,0x39,0x01,0x01,	/* 0EC8: .@...9.. */
	0x81,0x86,0xC0,0xBC,0x00,0x00,0x00,0xF0,	/* 0ED0: ... */
	0x4A,0x00,0x66,0x00,0x00,0x7C,0x4F,0xEF,	/* 0ED8: J.f..|O */
	0xFF,0xF4,0x48,0xD7,0x14,0x80,0x24,0x7C,	/* 0EE0: H.$| */
	0x01,0x01,0x81,0x80,0x2C,0x3C,0x01,0x01,	/* 0EE8: ..,<.. */
	0x80,0x00,0x4A,0x2D,0x00,0x0E,0x66,0x3E,	/* 0EF0: .J-..f> */
	0x43,0xED,0x00,0x08,0x70,0x00,0x10,0x29,	/* 0EF8: C..p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0xC0,0xBC,	/* 0F00: .... */
	0x00,0x00,0x20,0x00,0x67,0x28,0x7E,0x00,	/* 0F08: .. .g(~. */
	0x1E,0x2D,0x00,0x18,0x2F,0x0D,0x4E,0xB9,	/* 0F10: .-....N */
	0x00,0x00,0x41,0x58,0x58,0x8F,0xC0,0xBC,	/* 0F18: ..AXX */
	0x00,0x00,0x00,0xFF,0xBE,0x80,0x67,0x0E,	/* 0F20: ...g. */
	0x1B,0x40,0x00,0x18,0x08,0xED,0x00,0x01,	/* 0F28: .@..... */
	0x00,0x19,0x70,0x01,0x36,0x80,0x43,0xED,	/* 0F30: ..p.6C */
	0x00,0x2E,0x70,0x00,0x72,0x00,0x10,0x29,	/* 0F38: ..p.r..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x32,0x00,	/* 0F40: ....2. */
	0x2A,0x41,0xDB,0xC6,0xBB,0xCA,0x66,0xA2,	/* 0F48: *Af */
	0x4C,0xD7,0x14,0x80,0x4F,0xEF,0x00,0x0C,	/* 0F50: L.O.. */
	0x70,0x00,0x30,0x13,0x4A,0x80,0x66,0x0A,	/* 0F58: p.0.Jf. */
	0x70,0x00,0x30,0x2B,0x00,0x02,0x4A,0x80,	/* 0F60: p.0+..J */
	0x67,0x2E,0x22,0x79,0x00,0x00,0x63,0xD0,	/* 0F68: g."y..c */
	0x50,0x89,0x42,0x29,0x00,0x01,0x70,0x01,	/* 0F70: PB)..p. */
	0x12,0x80,0x30,0x13,0x13,0xC0,0x03,0x01,	/* 0F78: .0.... */
	0xFC,0x80,0x20,0x79,0x00,0x00,0x63,0xD0,	/* 0F80:  y..c */
	0x10,0x28,0x00,0x0C,0x52,0x80,0x11,0x40,	/* 0F88: .(..R.@ */
	0x00,0x0C,0x42,0x53,0x42,0x6B,0x00,0x02,	/* 0F90: ..BSBk.. */
	0x4C,0xD7,0x28,0x40,0x4F,0xEF,0x00,0x0C,	/* 0F98: L(@O.. */
	0x4E,0x75,0x00,0x00,0x4E,0x56,0xFF,0xF8,	/* 0FA0: Nu..NV */
	0x70,0x00,0x4F,0xEF,0xFF,0xE0,0x48,0xD7,	/* 0FA8: p.OH */
	0x30,0xFC,0x2A,0x6E,0x00,0x08,0x7E,0x00,	/* 0FB0: 0*n..~. */
	0x7C,0x00,0x49,0xED,0x00,0x02,0x10,0x2C,	/* 0FB8: |.I..., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x49,0xED,	/* 0FC0: ....I */
	0x00,0x08,0x3E,0x00,0x1C,0x2C,0x00,0x01,	/* 0FC8: ..>..,.. */
	0xE1,0x8E,0x1C,0x14,0x4A,0x2D,0x00,0x45,	/* 0FD0: ..J-.E */
	0x66,0x06,0x70,0xFF,0x1B,0x40,0x00,0x45,	/* 0FD8: f.p.@.E */
	0x49,0xED,0x00,0x04,0x70,0x00,0x26,0x3C,	/* 0FE0: I..p.&< */
	0x04,0x01,0xF0,0xFE,0x10,0x2C,0x00,0x01,	/* 0FE8: ...,.. */
	0xE1,0x88,0x10,0x14,0x72,0x00,0x32,0x00,	/* 0FF0: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 0FF8:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 1000: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 1008: .. G.- */
	0x00,0x07,0xD1,0xC3,0x10,0x80,0x20,0x47,	/* 1010: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 1018: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 1020: .... */
	0x10,0x80,0x4A,0x2D,0x00,0x1F,0x67,0x58,	/* 1028: .J-..gX */
	0x49,0xED,0x00,0x04,0x70,0x00,0x10,0x2C,	/* 1030: I..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 1038: ....r. */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 1040: 2. */
	0x70,0x00,0x28,0x41,0x10,0x2D,0x00,0x07,	/* 1048: p.(A.-.. */
	0xD9,0xFC,0x01,0x01,0x80,0x00,0x59,0x80,	/* 1050: ...Y */
	0x6D,0x14,0x10,0x2C,0x00,0x1D,0x20,0x47,	/* 1058: m..,.. G */
	0xD1,0xC3,0x52,0x80,0x19,0x40,0x00,0x1D,	/* 1060: R.@.. */
	0x70,0x24,0x10,0x80,0x60,0x12,0x10,0x2C,	/* 1068: p$.`.., */
	0x00,0x1C,0x20,0x47,0xD1,0xC3,0x52,0x80,	/* 1070: .. GR */
	0x19,0x40,0x00,0x1C,0x70,0x08,0x10,0x80,	/* 1078: .@..p.. */
	0x42,0x2D,0x00,0x1F,0x60,0x00,0x00,0xBA,	/* 1080: B-..`.. */
	0x70,0x00,0x10,0x2D,0x00,0x45,0x72,0x23,	/* 1088: p..-.Er# */
	0xC2,0x80,0x67,0x00,0x00,0xAC,0x16,0x2D,	/* 1090: g...- */
	0x00,0x30,0x08,0x03,0x00,0x01,0x67,0x12,	/* 1098: .0....g. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x16,	/* 10A0:  G... */
	0x10,0x10,0x08,0x00,0x00,0x02,0x66,0x00,	/* 10A8: ......f. */
	0x00,0x8A,0x08,0x2D,0x00,0x04,0x00,0x32,	/* 10B0: ..-...2 */
	0x67,0x12,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 10B8: g. G.. */
	0xF0,0xD8,0x10,0x10,0x08,0x00,0x00,0x06,	/* 10C0: ...... */
	0x67,0x00,0x00,0x70,0x08,0x03,0x00,0x04,	/* 10C8: g..p.... */
	0x67,0x10,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 10D0: g. G.. */
	0xF0,0xD8,0x10,0x10,0x08,0x00,0x00,0x04,	/* 10D8: ...... */
	0x67,0x58,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 10E0: gX0... */
	0x02,0x00,0x66,0x4E,0x4A,0x2D,0x00,0x25,	/* 10E8: ..fNJ-.% */
	0x66,0x48,0x8C,0xBC,0x00,0x00,0x01,0x00,	/* 10F0: fH.... */
	0x49,0xED,0x00,0x08,0x8C,0xBC,0x00,0x00,	/* 10F8: I.... */
	0x00,0x01,0xCC,0xBC,0x00,0x00,0xFF,0xFF,	/* 1100: .... */
	0x26,0x06,0x20,0x03,0xE0,0x80,0x19,0x40,	/* 1108: &. ..@ */
	0x00,0x01,0x18,0x83,0x4A,0x2D,0x00,0x27,	/* 1110: ...J-.' */
	0x67,0x0E,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 1118: g. G.. */
	0xF0,0x0C,0x70,0x84,0x10,0x80,0x60,0x0C,	/* 1120: .p.`. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x0C,	/* 1128:  G... */
	0x70,0x92,0x10,0x80,0x70,0x01,0x60,0x00,	/* 1130: p.p.`. */
	0x07,0x20,0xCC,0xBC,0x00,0x00,0xFD,0xFF,	/* 1138: . .. */
	0x26,0x3C,0x04,0x01,0xF0,0x0A,0x20,0x47,	/* 1140: &<... G */
	0xD1,0xC3,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 1148: .... */
	0x00,0xFF,0x4A,0x00,0x67,0x06,0x70,0x00,	/* 1150: .J.g.p. */
	0x60,0x00,0x06,0xFE,0x4A,0x2D,0x00,0x25,	/* 1158: `..J-.% */
	0x66,0x00,0x06,0x78,0x70,0x01,0x1B,0x40,	/* 1160: f..xp..@ */
	0x00,0x25,0x4A,0x2D,0x00,0x27,0x67,0x44,	/* 1168: .%J-.'gD */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x80,	/* 1170:  G.. */
	0x10,0x10,0x72,0x42,0xC0,0xBC,0x00,0x00,	/* 1178: ..rB.. */
	0x00,0xFF,0xB2,0x80,0x66,0x18,0x20,0x47,	/* 1180: .f. G */
	0x70,0x42,0xD1,0xFC,0x04,0x01,0xF0,0xEC,	/* 1188: pB.. */
	0x42,0x10,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 1190: B. G.. */
	0xF0,0xE4,0x10,0x80,0x60,0x0C,0x20,0x47,	/* 1198: .`. G */
	0xD1,0xFC,0x04,0x01,0xF0,0xE4,0x70,0x1F,	/* 11A0: ..p. */
	0x10,0x80,0x70,0x20,0x1B,0x40,0x00,0x2A,	/* 11A8: .p .@.* */
	0x60,0x00,0x03,0x32,0x20,0x47,0xD1,0xFC,	/* 11B0: `..2 G */
	0x04,0x01,0xF0,0x80,0x10,0x10,0x72,0x42,	/* 11B8: ....rB */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0xB2,0x80,	/* 11C0: ... */
	0x66,0x08,0x28,0x7C,0x00,0x00,0x31,0xFC,	/* 11C8: f.(|..1 */
	0x60,0x06,0x28,0x7C,0x00,0x00,0x32,0x34,	/* 11D0: `.(|..24 */
	0x08,0x2D,0x00,0x00,0x00,0x45,0x67,0x00,	/* 11D8: .-...Eg. */
	0x01,0x54,0x1A,0x2D,0x00,0x16,0x78,0x00,	/* 11E0: .T.-..x. */
	0x70,0x48,0x18,0x2D,0x00,0x06,0xCA,0xBC,	/* 11E8: pH.-.. */
	0x00,0x00,0x00,0x0F,0xB0,0x84,0x66,0x2A,	/* 11F0: ....f* */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x70,0x0F,	/* 11F8: ..p. */
	0xB0,0x85,0x66,0x06,0x7A,0x00,0x1A,0x2D,	/* 1200: f.z..- */
	0x00,0x33,0x70,0x48,0xB0,0x84,0x66,0x12,	/* 1208: .3pHf. */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x70,0x1E,	/* 1210: ..p. */
	0xB0,0x85,0x63,0x12,0x70,0x48,0xB0,0x84,	/* 1218: c.pH */
	0x67,0x12,0xCA,0xBC,0x00,0x00,0xFF,0xFF,	/* 1220: g... */
	0x70,0x0E,0xB0,0x85,0x6E,0x06,0x7A,0x00,	/* 1228: p.n.z. */
	0x1A,0x2D,0x00,0x36,0xCA,0xBC,0x00,0x00,	/* 1230: .-.6.. */
	0xFF,0xFF,0x70,0x14,0xB0,0x85,0x65,0x16,	/* 1238: p.e. */
	0x20,0x7C,0x00,0x00,0x32,0xAC,0xCA,0xBC,	/* 1240:  |..2 */
	0x00,0x00,0xFF,0xFF,0xD1,0xC5,0x10,0x10,	/* 1248: .... */
	0x1B,0x40,0x00,0x2A,0x60,0x06,0x70,0x20,	/* 1250: .@.*`.p  */
	0x1B,0x40,0x00,0x2A,0xCA,0xBC,0x00,0x00,	/* 1258: .@.*.. */
	0xFF,0xFF,0x20,0x47,0x43,0xF4,0x5C,0x00,	/* 1260:  GC\. */
	0xD1,0xFC,0x04,0x01,0xF0,0xE4,0x7A,0x00,	/* 1268: ..z. */
	0x30,0x11,0x10,0x80,0x20,0x47,0x30,0x29,	/* 1270: 0.. G0) */
	0x00,0x02,0xD1,0xFC,0x04,0x01,0xF0,0xEC,	/* 1278: .... */
	0x10,0x80,0x18,0x2D,0x00,0x16,0x10,0x2D,	/* 1280: ..-...- */
	0x00,0x2D,0xC0,0xBC,0x00,0x00,0x00,0xF0,	/* 1288: .-... */
	0x12,0x04,0x1A,0x04,0xC2,0xBC,0x00,0x00,	/* 1290: ...... */
	0x00,0x0F,0xE8,0x85,0x78,0x00,0x80,0x81,	/* 1298: ..x. */
	0x1B,0x40,0x00,0x2D,0x1B,0x6D,0x00,0x33,	/* 12A0: .@.-.m.3 */
	0x00,0x36,0x70,0x48,0x18,0x2D,0x00,0x06,	/* 12A8: .6pH.-.. */
	0xB0,0x84,0x66,0x2A,0xCA,0xBC,0x00,0x00,	/* 12B0: f*.. */
	0xFF,0xFF,0x70,0x0F,0xB0,0x85,0x66,0x06,	/* 12B8: p.f. */
	0x7A,0x00,0x1A,0x2D,0x00,0x34,0x70,0x48,	/* 12C0: z..-.4pH */
	0xB0,0x84,0x66,0x12,0xCA,0xBC,0x00,0x00,	/* 12C8: f... */
	0xFF,0xFF,0x70,0x1E,0xB0,0x85,0x63,0x12,	/* 12D0: p.c. */
	0x70,0x48,0xB0,0x84,0x67,0x12,0xCA,0xBC,	/* 12D8: pHg. */
	0x00,0x00,0xFF,0xFF,0x70,0x0E,0xB0,0x85,	/* 12E0: ..p. */
	0x6E,0x06,0x7A,0x00,0x1A,0x2D,0x00,0x37,	/* 12E8: n.z..-.7 */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x20,0x47,	/* 12F0: .. G */
	0x43,0xF4,0x5C,0x00,0xD1,0xFC,0x04,0x01,	/* 12F8: C\... */
	0xF0,0xF0,0x30,0x11,0x10,0x80,0x20,0x47,	/* 1300: 0.. G */
	0x30,0x29,0x00,0x02,0xD1,0xFC,0x04,0x01,	/* 1308: 0).... */
	0xF0,0xF8,0x10,0x80,0x10,0x2D,0x00,0x2D,	/* 1310: ..-.- */
	0x12,0x2D,0x00,0x16,0xC0,0xBC,0x00,0x00,	/* 1318: .-.... */
	0x00,0x0F,0xC2,0xBC,0x00,0x00,0x00,0xF0,	/* 1320: ..... */
	0x80,0x81,0x1B,0x40,0x00,0x2D,0x1B,0x6D,	/* 1328: .@.-.m */
	0x00,0x34,0x00,0x37,0x08,0x2D,0x00,0x01,	/* 1330: .4.7.-.. */
	0x00,0x45,0x67,0x00,0x02,0x14,0x49,0xED,	/* 1338: .Eg...I */
	0x00,0x38,0x42,0x2C,0x00,0x01,0x42,0x14,	/* 1340: .8B,..B. */
	0x49,0xED,0x00,0x3A,0x42,0x2C,0x00,0x01,	/* 1348: I.:B,.. */
	0x42,0x14,0x49,0xED,0x00,0x3C,0x42,0x2C,	/* 1350: B.I.<B, */
	0x00,0x01,0x42,0x14,0x49,0xED,0x00,0x3E,	/* 1358: ..B.I.> */
	0x42,0x2C,0x00,0x01,0x70,0x00,0x42,0x14,	/* 1360: B,..p.B. */
	0x10,0x2D,0x00,0x06,0x72,0x48,0xB2,0x80,	/* 1368: .-..rH */
	0x66,0x08,0x70,0x20,0x1B,0x40,0x00,0x42,	/* 1370: f.p .@.B */
	0x60,0x06,0x70,0x0C,0x1B,0x40,0x00,0x42,	/* 1378: `.p..@.B */
	0x42,0x2D,0x00,0x43,0x42,0x2D,0x00,0x44,	/* 1380: B-.CB-.D */
	0x20,0x47,0x10,0x2D,0x00,0x1D,0xD1,0xFC,	/* 1388:  G.-.. */
	0x04,0x01,0xF0,0x34,0x10,0x80,0x20,0x47,	/* 1390: ..4. G */
	0x10,0x2D,0x00,0x1E,0xD1,0xFC,0x04,0x01,	/* 1398: .-.... */
	0xF0,0x36,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 13A0: 6. G.- */
	0x00,0x1B,0xD1,0xFC,0x04,0x01,0xF0,0x38,	/* 13A8: ....8 */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x1C,	/* 13B0: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0x3A,0x10,0x80,	/* 13B8: ..:. */
	0x78,0x00,0x42,0x2D,0x00,0x19,0x18,0x2D,	/* 13C0: x.B-...- */
	0x00,0x14,0x1B,0x44,0x00,0x31,0x3A,0x04,	/* 13C8: ...D.1:. */
	0x30,0x04,0xCA,0xBC,0x00,0x00,0x00,0x03,	/* 13D0: 0..... */
	0xC0,0xBC,0x00,0x00,0x00,0x10,0x66,0x28,	/* 13D8: ....f( */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x08,	/* 13E0: 0..... */
	0x67,0x08,0x8A,0xBC,0x00,0x00,0x00,0x20,	/* 13E8: g....  */
	0x60,0x06,0x8A,0xBC,0x00,0x00,0x00,0x40,	/* 13F0: `....@ */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x04,	/* 13F8: 0..... */
	0x67,0x06,0x8A,0xBC,0x00,0x00,0x00,0x80,	/* 1400: g.... */
	0x08,0x2D,0x00,0x07,0x00,0x1A,0x66,0x06,	/* 1408: .-....f. */
	0x8A,0xBC,0x00,0x00,0x00,0x10,0x78,0x00,	/* 1410: ....x. */
	0x18,0x2D,0x00,0x15,0x1B,0x44,0x00,0x32,	/* 1418: .-...D.2 */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x0F,	/* 1420: 0..... */
	0x72,0x0F,0xB2,0x80,0x66,0x06,0x8A,0xBC,	/* 1428: r.f. */
	0x00,0x00,0x00,0x08,0x20,0x47,0x30,0x04,	/* 1430: .... G0. */
	0xD1,0xFC,0x04,0x01,0xF0,0x10,0x10,0x85,	/* 1438: .... */
	0x7A,0x00,0xC0,0xBC,0x00,0x00,0x00,0x80,	/* 1440: z.... */
	0x67,0x02,0x7A,0x10,0x20,0x47,0x70,0x00,	/* 1448: g.z. Gp. */
	0xD1,0xFC,0x04,0x01,0xF0,0x12,0x10,0x85,	/* 1450: .... */
	0x10,0x2D,0x00,0x06,0x72,0x48,0xB2,0x80,	/* 1458: .-..rH */
	0x66,0x0E,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 1460: f. G.. */
	0xF0,0x14,0x70,0x84,0x10,0x80,0x60,0x0C,	/* 1468: .p.`. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x14,	/* 1470:  G... */
	0x70,0x08,0x10,0x80,0x78,0x00,0x18,0x2D,	/* 1478: p..x..- */
	0x00,0x20,0x1B,0x44,0x00,0x21,0x30,0x04,	/* 1480: . .D.!0. */
	0x1B,0x6D,0x00,0x1A,0x00,0x30,0xC0,0xBC,	/* 1488: .m...0 */
	0x00,0x00,0x00,0x80,0x67,0x04,0x7A,0x00,	/* 1490: ...g.z. */
	0x60,0x1E,0x30,0x04,0xC0,0xBC,0x00,0x00,	/* 1498: `.0... */
	0x00,0x08,0x67,0x04,0x7A,0x02,0x60,0x10,	/* 14A0: ..g.z.`. */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x04,	/* 14A8: 0..... */
	0x67,0x04,0x7A,0x04,0x60,0x02,0x7A,0x03,	/* 14B0: g.z.`.z. */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x01,	/* 14B8: 0..... */
	0x67,0x08,0x8A,0xBC,0x00,0x00,0x00,0x18,	/* 14C0: g..... */
	0x60,0x10,0x30,0x04,0xC0,0xBC,0x00,0x00,	/* 14C8: `.0... */
	0x00,0x02,0x66,0x06,0x8A,0xBC,0x00,0x00,	/* 14D0: ..f... */
	0x00,0x08,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 14D8: .. G.. */
	0xF0,0x3C,0x10,0x85,0x08,0x2D,0x00,0x01,	/* 14E0: <..-.. */
	0x00,0x45,0x67,0x00,0x00,0x64,0x7A,0x00,	/* 14E8: .Eg..dz. */
	0x08,0x2D,0x00,0x02,0x00,0x1A,0x67,0x2E,	/* 14F0: .-....g. */
	0x4A,0x2D,0x00,0x27,0x67,0x1E,0x20,0x47,	/* 14F8: J-.'g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x80,0x10,0x10,	/* 1500: .... */
	0x72,0x42,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 1508: rB... */
	0xB2,0x80,0x66,0x08,0x8C,0xBC,0x00,0x00,	/* 1510: f... */
	0x04,0x00,0x60,0x10,0xCC,0xBC,0x00,0x00,	/* 1518: ..`... */
	0xFB,0xFF,0x7A,0x02,0x60,0x06,0xCC,0xBC,	/* 1520: z.`. */
	0x00,0x00,0xFB,0xFF,0x70,0x00,0x10,0x2D,	/* 1528: ..p..- */
	0x00,0x22,0xB0,0xBC,0x00,0x00,0x00,0xFF,	/* 1530: ."... */
	0x67,0x0C,0x4A,0x2D,0x00,0x27,0x66,0x06,	/* 1538: g.J-.'f. */
	0x8A,0xBC,0x00,0x00,0x00,0x80,0x20,0x47,	/* 1540: ... G */
	0xD1,0xFC,0x04,0x01,0xF0,0x3E,0x10,0x85,	/* 1548: ..>. */
	0x4A,0x2D,0x00,0x27,0x66,0x00,0x01,0xBA,	/* 1550: J-.'f.. */
	0x70,0x00,0x78,0x00,0x7A,0x00,0x12,0x2D,	/* 1558: p.x.z..- */
	0x00,0x1A,0x34,0x00,0x08,0x01,0x00,0x03,	/* 1560: ..4..... */
	0x67,0x04,0x3A,0x3C,0x01,0x00,0x08,0x2D,	/* 1568: g.:<...- */
	0x00,0x07,0x00,0x14,0x67,0x08,0x8A,0xBC,	/* 1570: ....g. */
	0x00,0x00,0x10,0x00,0x60,0x12,0x38,0x3C,	/* 1578: ....`.8< */
	0x10,0x00,0x08,0x2D,0x00,0x00,0x00,0x17,	/* 1580: ...-.... */
	0x67,0x06,0x30,0x3C,0x10,0x00,0x34,0x00,	/* 1588: g.0<..4. */
	0x08,0x01,0x00,0x06,0x67,0x08,0x8A,0xBC,	/* 1590: ....g. */
	0x00,0x00,0x20,0x00,0x60,0x18,0x88,0xBC,	/* 1598: .. .`. */
	0x00,0x00,0x20,0x00,0x08,0x2D,0x00,0x01,	/* 15A0: .. ..-.. */
	0x00,0x17,0x67,0x0A,0x30,0x02,0x80,0xBC,	/* 15A8: ..g.0. */
	0x00,0x00,0x20,0x00,0x34,0x00,0x08,0x01,	/* 15B0: .. .4... */
	0x00,0x01,0x67,0x14,0x08,0x01,0x00,0x00,	/* 15B8: ..g..... */
	0x67,0x08,0x8A,0xBC,0x00,0x00,0x00,0x02,	/* 15C0: g..... */
	0x60,0x06,0x8A,0xBC,0x00,0x00,0x00,0x01,	/* 15C8: `..... */
	0x08,0x2D,0x00,0x04,0x00,0x15,0x67,0x06,	/* 15D0: .-....g. */
	0x8A,0xBC,0x00,0x00,0x00,0x10,0x08,0x01,	/* 15D8: ...... */
	0x00,0x04,0x67,0x06,0x8A,0xBC,0x00,0x00,	/* 15E0: ..g... */
	0x00,0x20,0x08,0x2D,0x00,0x05,0x00,0x45,	/* 15E8: . .-...E */
	0x67,0x16,0xCA,0xBC,0x00,0x00,0xFF,0xFF,	/* 15F0: g... */
	0x2F,0x05,0x48,0x78,0x31,0x33,0x2F,0x0D,	/* 15F8: ..Hx13.. */
	0x61,0x00,0x0D,0x46,0x4F,0xEF,0x00,0x0C,	/* 1600: a..FO.. */
	0x08,0x2D,0x00,0x04,0x00,0x45,0x67,0x18,	/* 1608: .-...Eg. */
	0x70,0x00,0x30,0x02,0x2F,0x00,0xC8,0xBC,	/* 1610: p.0... */
	0x00,0x00,0xFF,0xFF,0x2F,0x04,0x2F,0x0D,	/* 1618: ...... */
	0x61,0x00,0x11,0xF2,0x4F,0xEF,0x00,0x0C,	/* 1620: a..O.. */
	0x08,0x2D,0x00,0x05,0x00,0x1A,0x67,0x42,	/* 1628: .-....gB */
	0x2F,0x0D,0x61,0x00,0x14,0xC4,0x78,0x00,	/* 1630: ..a..x. */
	0x20,0x47,0x2A,0x3C,0x04,0x01,0xF0,0x2A,	/* 1638:  G*<..* */
	0x22,0x47,0x58,0x8F,0x18,0x2D,0x00,0x26,	/* 1640: "GX.-.& */
	0xD1,0xFC,0x04,0x01,0xF0,0x2C,0xD3,0xC5,	/* 1648: .., */
	0xC8,0xBC,0x00,0x00,0x00,0xF0,0x10,0x84,	/* 1650: .... */
	0x20,0x47,0x10,0x11,0xD1,0xC5,0x32,0x04,	/* 1658:  G..2. */
	0xC2,0xBC,0x00,0x00,0x00,0xF0,0xC0,0xBC,	/* 1660: ... */
	0x00,0x00,0x00,0x0F,0x80,0x81,0x10,0x80,	/* 1668: ..... */
	0x60,0x28,0x70,0x24,0x20,0x47,0x2A,0x3C,	/* 1670: `(p$ G*< */
	0x04,0x01,0xF0,0x2A,0x22,0x47,0x1B,0x40,	/* 1678: ..*"G.@ */
	0x00,0x18,0xD1,0xFC,0x04,0x01,0xF0,0x2C,	/* 1680: ...., */
	0xD3,0xC5,0x42,0x10,0x10,0x11,0x20,0x47,	/* 1688: B... G */
	0xD1,0xC5,0xC0,0xBC,0x00,0x00,0x00,0x0F,	/* 1690: .... */
	0x10,0x80,0xCC,0xBC,0x00,0x00,0xDF,0xFF,	/* 1698: ... */
	0x1A,0x2D,0x00,0x1A,0x08,0x05,0x00,0x05,	/* 16A0: .-...... */
	0x67,0x06,0x8C,0xBC,0x00,0x00,0x20,0x00,	/* 16A8: g... . */
	0x08,0x2D,0x00,0x05,0x00,0x45,0x67,0x00,	/* 16B0: .-...Eg. */
	0x00,0x7C,0xCC,0xBC,0x00,0x00,0xFF,0xF4,	/* 16B8: .|.. */
	0x08,0x05,0x00,0x01,0x67,0x06,0x8C,0xBC,	/* 16C0: ....g. */
	0x00,0x00,0x00,0x02,0x08,0x05,0x00,0x03,	/* 16C8: ........ */
	0x67,0x06,0x8C,0xBC,0x00,0x00,0x00,0x08,	/* 16D0: g..... */
	0x08,0x05,0x00,0x00,0x67,0x06,0x8C,0xBC,	/* 16D8: ....g. */
	0x00,0x00,0x00,0x01,0x08,0x2D,0x00,0x07,	/* 16E0: .....-.. */
	0x00,0x14,0x67,0x06,0x8C,0xBC,0x00,0x00,	/* 16E8: ..g... */
	0x00,0x08,0x08,0x05,0x00,0x06,0x67,0x06,	/* 16F0: ......g. */
	0x8C,0xBC,0x00,0x00,0x00,0x08,0x30,0x06,	/* 16F8: ....0. */
	0xC0,0xBC,0x00,0x00,0x00,0x08,0x67,0x2C,	/* 1700: ....g, */
	0xCC,0xBC,0x00,0x00,0xFF,0x0F,0x60,0x24,	/* 1708: ...`$ */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x80,	/* 1710:  G.. */
	0x10,0x10,0x72,0x42,0xC0,0xBC,0x00,0x00,	/* 1718: ..rB.. */
	0x00,0xFF,0xB2,0x80,0x67,0x0E,0x08,0x2D,	/* 1720: .g..- */
	0x00,0x02,0x00,0x1A,0x67,0x06,0x8C,0xBC,	/* 1728: ....g. */
	0x00,0x00,0x04,0x00,0x08,0x2D,0x00,0x00,	/* 1730: .....-.. */
	0x00,0x45,0x67,0x00,0x00,0x7A,0x20,0x47,	/* 1738: .Eg..z G */
	0xD1,0xFC,0x04,0x01,0xF0,0x80,0x10,0x10,	/* 1740: .... */
	0x72,0x42,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 1748: rB... */
	0xB2,0x80,0x66,0x08,0x28,0x7C,0x00,0x00,	/* 1750: f.(|.. */
	0x61,0xF8,0x60,0x06,0x28,0x7C,0x00,0x00,	/* 1758: a`.(|.. */
	0x62,0x30,0x78,0x00,0x7A,0x00,0x70,0x48,	/* 1760: b0x.z.pH */
	0x18,0x2D,0x00,0x16,0x1A,0x2D,0x00,0x06,	/* 1768: .-...-.. */
	0xE8,0x84,0xB0,0x85,0x66,0x12,0xC8,0xBC,	/* 1770: f. */
	0x00,0x00,0xFF,0xFF,0x70,0x1E,0xB0,0x84,	/* 1778: ..p. */
	0x63,0x12,0x70,0x48,0xB0,0x85,0x67,0x1A,	/* 1780: c.pHg. */
	0xC8,0xBC,0x00,0x00,0xFF,0xFF,0x70,0x0E,	/* 1788: ..p. */
	0xB0,0x84,0x6E,0x0E,0x20,0x47,0xD1,0xFC,	/* 1790: n. G */
	0x04,0x01,0xF0,0x42,0x70,0x08,0x10,0x80,	/* 1798: ..Bp.. */
	0x60,0x14,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 17A0: `. G.. */
	0xF0,0x42,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 17A8: B.. */
	0x20,0x34,0x4C,0x00,0x10,0x80,0x20,0x47,	/* 17B0:  4L.. G */
	0x70,0x4E,0x49,0xED,0x00,0x08,0xCC,0xBC,	/* 17B8: pNI.. */
	0x00,0x00,0xFF,0xFF,0xD1,0xC3,0x2E,0x06,	/* 17C0: .... */
	0x10,0x80,0x20,0x07,0xE0,0x80,0x19,0x40,	/* 17C8: . ..@ */
	0x00,0x01,0x18,0x87,0x70,0x00,0x60,0x00,	/* 17D0: ...p.`. */
	0x00,0x80,0x4A,0x2D,0x00,0x27,0x67,0x1E,	/* 17D8: .J-.'g. */
	0x20,0x47,0x70,0x18,0xD1,0xFC,0x04,0x01,	/* 17E0:  Gp... */
	0xF0,0x2A,0x42,0x10,0x20,0x47,0xD1,0xFC,	/* 17E8: *B. G */
	0x04,0x01,0xF0,0x2C,0x42,0x10,0x20,0x47,	/* 17F0: ..,B. G */
	0xD1,0xC3,0x10,0x80,0x60,0x08,0x20,0x47,	/* 17F8: .`. G */
	0xD1,0xC3,0x70,0x1A,0x10,0x80,0xCC,0xBC,	/* 1800: p.. */
	0x00,0x00,0xFF,0xFE,0x49,0xED,0x00,0x08,	/* 1808: ..I.. */
	0x20,0x47,0xCC,0xBC,0x00,0x00,0xFF,0xFF,	/* 1810:  G.. */
	0x26,0x06,0x20,0x03,0xE0,0x80,0x19,0x40,	/* 1818: &. ..@ */
	0x00,0x01,0xD1,0xFC,0x04,0x01,0xF0,0x0C,	/* 1820: ..... */
	0x18,0x83,0x70,0x90,0x10,0x80,0x42,0x2D,	/* 1828: .p.B- */
	0x00,0x25,0x70,0x00,0x10,0x2D,0x00,0x0E,	/* 1830: .%p..-.. */
	0x59,0x80,0x66,0x0A,0x2F,0x0D,0x61,0x00,	/* 1838: Yf...a. */
	0x18,0x34,0x58,0x8F,0x60,0x04,0x42,0x2D,	/* 1840: .4X`.B- */
	0x00,0x0E,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 1848: ..p.3.. */
	0x61,0xF4,0x42,0x2D,0x00,0x45,0x70,0x00,	/* 1850: aB-.Ep. */
	0x4C,0xD7,0x30,0xFC,0x4F,0xEF,0x00,0x20,	/* 1858: L0O.  */
	0x4E,0x5E,0x4E,0x75,0x2F,0x0D,0x70,0x00,	/* 1860: N^Nu..p. */
	0x2F,0x07,0x7E,0x00,0x2A,0x6F,0x00,0x0C,	/* 1868: ..~.*o.. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 1870: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 1878: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 1880: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 1888: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 1890:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 1898: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 18A0: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 18A8: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 18B0: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 18B8: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x2F,0x0D,	/* 18C0: ....... */
	0x61,0x00,0x03,0xE2,0x58,0x8F,0x72,0x00,	/* 18C8: a..Xr. */
	0x32,0x00,0x4A,0x81,0x67,0x06,0x70,0x00,	/* 18D0: 2.Jg.p. */
	0x60,0x00,0x00,0xF8,0x10,0x2D,0x00,0x0D,	/* 18D8: `...-.. */
	0x12,0x2D,0x00,0x0C,0x90,0x81,0x4A,0x00,	/* 18E0: .-..J. */
	0x67,0x06,0x70,0x01,0x60,0x00,0x00,0xE4,	/* 18E8: g.p.`.. */
	0x4A,0x2D,0x00,0x1F,0x66,0x00,0x00,0xD4,	/* 18F0: J-..f.. */
	0x4A,0x2D,0x00,0x29,0x66,0x22,0x43,0xED,	/* 18F8: J-.)f"C */
	0x00,0x08,0x70,0x00,0x10,0x29,0x00,0x01,	/* 1900: ..p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x80,0xBC,	/* 1908: ..r. */
	0x00,0x00,0x02,0x00,0x32,0x00,0x20,0x01,	/* 1910: ....2. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x81,	/* 1918: .@... */
	0x43,0xED,0x00,0x08,0x70,0x00,0x10,0x29,	/* 1920: C..p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0xC0,0xBC,	/* 1928: .... */
	0x00,0x00,0x02,0x00,0x67,0x0E,0x2F,0x0D,	/* 1930: ....g... */
	0x61,0x00,0x00,0x9E,0x70,0x00,0x58,0x8F,	/* 1938: a..p.X */
	0x60,0x00,0x00,0x90,0x43,0xED,0x00,0x08,	/* 1940: `..C.. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 1948: p..).. */
	0x10,0x11,0x72,0x00,0x80,0xBC,0x00,0x00,	/* 1950: ..r... */
	0x01,0x00,0x32,0x00,0x20,0x01,0xE0,0x80,	/* 1958: ..2. . */
	0x13,0x40,0x00,0x01,0x12,0x81,0x4A,0x2D,	/* 1960: .@...J- */
	0x00,0x27,0x66,0x2E,0x50,0x8D,0x70,0x00,	/* 1968: .'f.Pp. */
	0x20,0x47,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 1970:  G.-.. */
	0x10,0x15,0x72,0x00,0x80,0xBC,0x00,0x00,	/* 1978: ..r... */
	0x00,0x01,0x32,0x00,0x20,0x01,0xE0,0x80,	/* 1980: ..2. . */
	0x1B,0x40,0x00,0x01,0xD1,0xFC,0x04,0x01,	/* 1988: .@.... */
	0xF0,0x0C,0x1A,0x81,0x70,0x92,0x10,0x80,	/* 1990: ..p. */
	0x60,0x2C,0x50,0x8D,0x70,0x00,0x20,0x47,	/* 1998: `,Pp. G */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 19A0: .-.... */
	0x72,0x00,0x80,0xBC,0x00,0x00,0x00,0x01,	/* 19A8: r..... */
	0x32,0x00,0x20,0x01,0xE0,0x80,0x1B,0x40,	/* 19B0: 2. ..@ */
	0x00,0x01,0xD1,0xFC,0x04,0x01,0xF0,0x0C,	/* 19B8: ..... */
	0x1A,0x81,0x70,0x84,0x10,0x80,0x70,0x00,	/* 19C0: .p.p. */
	0x60,0x08,0x2F,0x0D,0x61,0x0A,0x70,0x00,	/* 19C8: `...a.p. */
	0x58,0x8F,0x2E,0x1F,0x2A,0x5F,0x4E,0x75,	/* 19D0: X..*_Nu */
	0x4F,0xEF,0xFF,0xF0,0x70,0x00,0x48,0xD7,	/* 19D8: Op.H */
	0x20,0xE0,0x2A,0x6F,0x00,0x14,0x7E,0x00,	/* 19E0:  *o..~. */
	0x2C,0x3C,0x04,0x01,0xF0,0xFE,0x43,0xED,	/* 19E8: ,<..C */
	0x00,0x02,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 19F0: ...).. */
	0x10,0x11,0x43,0xED,0x00,0x04,0x3E,0x00,	/* 19F8: ..C..>. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 1A00: p..).. */
	0x10,0x11,0x72,0x00,0x32,0x00,0xC2,0xBC,	/* 1A08: ..r.2. */
	0xFF,0xFF,0x7F,0xFF,0x20,0x41,0x10,0x2D,	/* 1A10:  A.- */
	0x00,0x07,0xD1,0xFC,0x01,0x01,0x80,0x09,	/* 1A18: ..... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 1A20: . G.-.. */
	0xD1,0xC6,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 1A28: . G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 1A30: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 1A38: ..... */
	0x2F,0x0D,0x61,0x00,0x02,0x68,0x58,0x8F,	/* 1A40: ..a..hX */
	0x72,0x00,0x32,0x00,0x4A,0x81,0x67,0x06,	/* 1A48: r.2.Jg. */
	0x70,0x00,0x60,0x00,0x02,0x4E,0x2A,0x3C,	/* 1A50: p.`..N*< */
	0x04,0x01,0xF0,0x0A,0x20,0x47,0xD1,0xC5,	/* 1A58: ... G */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 1A60: ..... */
	0x4A,0x00,0x67,0x06,0x70,0x00,0x60,0x00,	/* 1A68: J.g.p.`. */
	0x02,0x32,0x4A,0x2D,0x00,0x1F,0x66,0x00,	/* 1A70: .2J-..f. */
	0x01,0x72,0x43,0xED,0x00,0x04,0x70,0x00,	/* 1A78: .rC..p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1A80: .).... */
	0x72,0x00,0x43,0xED,0x00,0x08,0x32,0x00,	/* 1A88: r.C..2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x70,0x00,	/* 1A90: p. */
	0x20,0x41,0x10,0x29,0x00,0x01,0xD1,0xFC,	/* 1A98:  A.).. */
	0x01,0x01,0x80,0x00,0xE1,0x88,0x10,0x11,	/* 1AA0: ..... */
	0xC0,0xBC,0x00,0x00,0x02,0x00,0x67,0x46,	/* 1AA8: ....gF */
	0x70,0x00,0x10,0x2D,0x00,0x07,0x59,0x80,	/* 1AB0: p..-..Y */
	0x6D,0x1E,0x12,0x28,0x00,0x1D,0xD2,0xBC,	/* 1AB8: m..(.. */
	0x00,0x00,0x00,0xFF,0x11,0x41,0x00,0x1D,	/* 1AC0: ....A.. */
	0x66,0x00,0x01,0x20,0x20,0x47,0xD1,0xC6,	/* 1AC8: f..  G */
	0x70,0x44,0x10,0x80,0x60,0x00,0x01,0x14,	/* 1AD0: pD.`... */
	0x12,0x28,0x00,0x1C,0xD2,0xBC,0x00,0x00,	/* 1AD8: .(.... */
	0x00,0xFF,0x11,0x41,0x00,0x1C,0x66,0x00,	/* 1AE0: ..A..f. */
	0x01,0x02,0x20,0x47,0xD1,0xC6,0x70,0x10,	/* 1AE8: .. Gp. */
	0x10,0x80,0x60,0x00,0x00,0xF6,0x4A,0x2D,	/* 1AF0: .`..J- */
	0x00,0x29,0x66,0x24,0x50,0x8D,0x70,0x00,	/* 1AF8: .)f$Pp. */
	0x7E,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 1B00: ~..-.. */
	0x10,0x15,0x80,0xBC,0x00,0x00,0x02,0x00,	/* 1B08: ...... */
	0x3E,0x00,0x20,0x07,0xE0,0x80,0x1B,0x40,	/* 1B10: >. ..@ */
	0x00,0x01,0x1A,0x87,0x60,0x00,0x00,0xC6,	/* 1B18: ...`.. */
	0x41,0xED,0x00,0x08,0x70,0x00,0x10,0x28,	/* 1B20: A..p..( */
	0x00,0x01,0xE1,0x88,0x10,0x10,0xC0,0xBC,	/* 1B28: .... */
	0x00,0x00,0x01,0x00,0x67,0x1C,0x08,0x2D,	/* 1B30: ....g..- */
	0x00,0x00,0x00,0x40,0x67,0x00,0x00,0xA6,	/* 1B38: ...@g.. */
	0x20,0x47,0xD1,0xC5,0x70,0x18,0x10,0x80,	/* 1B40:  Gp.. */
	0x08,0xAD,0x00,0x00,0x00,0x40,0x60,0x00,	/* 1B48: ....@`. */
	0x00,0x94,0x41,0xED,0x00,0x08,0x70,0x00,	/* 1B50: .A..p. */
	0x7C,0x00,0x10,0x28,0x00,0x01,0xE1,0x88,	/* 1B58: |..(.. */
	0x10,0x10,0x80,0xBC,0x00,0x00,0x01,0x00,	/* 1B60: ...... */
	0x3C,0x00,0x20,0x06,0xE0,0x80,0x11,0x40,	/* 1B68: <. ..@ */
	0x00,0x01,0x10,0x86,0x42,0x2D,0x00,0x0D,	/* 1B70: ...B-.. */
	0x42,0x2D,0x00,0x0C,0x4A,0x2D,0x00,0x27,	/* 1B78: B-..J-.' */
	0x66,0x2E,0x50,0x8D,0x70,0x00,0x7C,0x00,	/* 1B80: f.Pp.|. */
	0x20,0x47,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 1B88:  G.-.. */
	0x10,0x15,0x80,0xBC,0x00,0x00,0x00,0x01,	/* 1B90: ...... */
	0x3C,0x00,0x20,0x06,0xE0,0x80,0x1B,0x40,	/* 1B98: <. ..@ */
	0x00,0x01,0xD1,0xFC,0x04,0x01,0xF0,0x0C,	/* 1BA0: ..... */
	0x1A,0x86,0x70,0x92,0x10,0x80,0x60,0x2C,	/* 1BA8: .p.`, */
	0x50,0x8D,0x70,0x00,0x7C,0x00,0x20,0x47,	/* 1BB0: Pp.|. G */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 1BB8: .-.... */
	0x80,0xBC,0x00,0x00,0x00,0x01,0x3C,0x00,	/* 1BC0: ....<. */
	0x20,0x06,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 1BC8:  ..@.. */
	0xD1,0xFC,0x04,0x01,0xF0,0x0C,0x1A,0x86,	/* 1BD0: .... */
	0x70,0x84,0x10,0x80,0x20,0x47,0xD1,0xC5,	/* 1BD8: p. G */
	0x70,0x82,0x10,0x80,0x70,0x00,0x60,0x00,	/* 1BE0: p.p.`. */
	0x00,0xBA,0x42,0x2D,0x00,0x0D,0x42,0x2D,	/* 1BE8: .B-..B- */
	0x00,0x0A,0x42,0x2D,0x00,0x0C,0x42,0x2D,	/* 1BF0: ..B-..B- */
	0x00,0x0B,0x42,0x2D,0x00,0x29,0x41,0xED,	/* 1BF8: ..B-.)A */
	0x00,0x08,0x7C,0x00,0x1C,0x28,0x00,0x01,	/* 1C00: ..|..(.. */
	0xE1,0x8E,0x1C,0x10,0xCC,0xBC,0x00,0x00,	/* 1C08: .... */
	0xFD,0xFF,0x20,0x06,0xE0,0x80,0x11,0x40,	/* 1C10:  ..@ */
	0x00,0x01,0x10,0x86,0x4A,0x2D,0x00,0x27,	/* 1C18: ...J-.' */
	0x67,0x0A,0x20,0x47,0xD1,0xC5,0x70,0x14,	/* 1C20: g. Gp. */
	0x10,0x80,0x60,0x38,0x08,0x2D,0x00,0x00,	/* 1C28: .`8.-.. */
	0x00,0x17,0x66,0x10,0x42,0xA7,0x48,0x78,	/* 1C30: ..f.BHx */
	0x10,0x00,0x2F,0x0D,0x61,0x00,0x0B,0xD6,	/* 1C38: ....a.. */
	0x4F,0xEF,0x00,0x0C,0x08,0x2D,0x00,0x01,	/* 1C40: O...-.. */
	0x00,0x17,0x66,0x10,0x42,0xA7,0x48,0x78,	/* 1C48: ..f.BHx */
	0x20,0x00,0x2F,0x0D,0x61,0x00,0x0B,0xBE,	/* 1C50:  ...a.. */
	0x4F,0xEF,0x00,0x0C,0x20,0x47,0xD1,0xC5,	/* 1C58: O.. G */
	0x70,0x80,0x10,0x80,0x41,0xED,0x00,0x08,	/* 1C60: p.A.. */
	0x7A,0x00,0x1A,0x28,0x00,0x01,0xE1,0x8D,	/* 1C68: z..(.. */
	0x1A,0x10,0xCA,0xBC,0x00,0x00,0xFF,0xFE,	/* 1C70: .... */
	0x20,0x05,0xE0,0x80,0x11,0x40,0x00,0x01,	/* 1C78:  ..@.. */
	0x10,0x85,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 1C80: . G.. */
	0xF0,0x0C,0x42,0x10,0x70,0x01,0x1B,0x40,	/* 1C88: .B.p..@ */
	0x00,0x1F,0x70,0x10,0x1B,0x40,0x00,0x0E,	/* 1C90: ..p..@.. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x61,0xF4,	/* 1C98: p.3..a */
	0x70,0x00,0x4C,0xD7,0x20,0xE0,0x4F,0xEF,	/* 1CA0: p.L O */
	0x00,0x10,0x4E,0x75,0x2F,0x0D,0x70,0x00,	/* 1CA8: ..Nu..p. */
	0x2F,0x07,0x7E,0x00,0x2A,0x6F,0x00,0x0C,	/* 1CB0: ..~.*o.. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 1CB8: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 1CC0: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 1CC8: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 1CD0: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 1CD8:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 1CE0: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 1CE8: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 1CF0: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 1CF8: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 1D00: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x70,0x00,	/* 1D08: .....p. */
	0x10,0x2D,0x00,0x35,0x4A,0x80,0x67,0x0A,	/* 1D10: .-.5Jg. */
	0x59,0x80,0x67,0x3C,0x53,0x80,0x67,0x38,	/* 1D18: Yg<Sg8 */
	0x60,0x06,0x70,0x00,0x60,0x00,0x00,0x72,	/* 1D20: `.p.`..r */
	0x70,0x00,0x10,0x2D,0x00,0x06,0x72,0x48,	/* 1D28: p..-..rH */
	0xB2,0x80,0x66,0x1E,0x22,0x3C,0x04,0x01,	/* 1D30: f."<.. */
	0xF0,0x0A,0x20,0x47,0xD1,0xC1,0x10,0x10,	/* 1D38: . G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x4A,0x00,	/* 1D40: ...J. */
	0x66,0x0E,0x20,0x47,0xD1,0xC1,0x70,0x82,	/* 1D48: f. Gp */
	0x10,0x80,0x70,0x04,0x1B,0x40,0x00,0x35,	/* 1D50: .p..@.5 */
	0x50,0x8D,0x70,0x00,0x20,0x47,0x10,0x2D,	/* 1D58: Pp. G.- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x72,0x00,	/* 1D60: ....r. */
	0x80,0xBC,0x00,0x00,0x00,0x01,0x32,0x00,	/* 1D68: ....2. */
	0x20,0x01,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 1D70:  ..@.. */
	0x22,0x47,0x1A,0x81,0x22,0x3C,0x04,0x01,	/* 1D78: "G."<.. */
	0xF0,0x0C,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 1D80: ... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0xBC,	/* 1D88: ... */
	0x00,0x00,0x00,0x02,0x10,0x80,0x70,0x01,	/* 1D90: .....p. */
	0x2E,0x1F,0x2A,0x5F,0x4E,0x75,0x4E,0x71,	/* 1D98: ..*_NuNq */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x7E,0x00,	/* 1DA0: ..p...~. */
	0x2A,0x6F,0x00,0x0C,0x43,0xED,0x00,0x02,	/* 1DA8: *o..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1DB0: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 1DB8: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1DC0: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 1DC8: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 1DD0:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 1DD8: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 1DE0:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 1DE8: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 1DF0: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 1DF8: .... */
	0x10,0x80,0x4A,0x2D,0x00,0x27,0x66,0x18,	/* 1E00: .J-.'f. */
	0x22,0x3C,0x04,0x01,0xF0,0x16,0x20,0x47,	/* 1E08: "<... G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 1E10: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFB,0x10,0x80,	/* 1E18: .... */
	0x42,0x2D,0x00,0x0E,0x70,0x01,0x2E,0x1F,	/* 1E20: B-..p... */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x70,0x00,	/* 1E28: 3..ap. */
	0x2A,0x5F,0x4E,0x75,0x2F,0x0D,0x70,0x00,	/* 1E30: *_Nu..p. */
	0x2F,0x07,0x7E,0x00,0x2A,0x6F,0x00,0x0C,	/* 1E38: ..~.*o.. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 1E40: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 1E48: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 1E50: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 1E58: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 1E60:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 1E68: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 1E70: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 1E78: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 1E80: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 1E88: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x22,0x3C,	/* 1E90: ....."< */
	0x04,0x01,0xF0,0x0A,0x20,0x47,0xD1,0xC1,	/* 1E98: ... G */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 1EA0: ..... */
	0x4A,0x00,0x67,0x04,0x70,0x00,0x60,0x18,	/* 1EA8: J.g.p.`. */
	0x1B,0x6D,0x00,0x0D,0x00,0x0C,0x20,0x47,	/* 1EB0: .m.... G */
	0x70,0x82,0xD1,0xC1,0x10,0x80,0x2F,0x0D,	/* 1EB8: p... */
	0x61,0x00,0xFE,0xDE,0x70,0x00,0x58,0x8F,	/* 1EC0: a.p.X */
	0x2E,0x1F,0x2A,0x5F,0x4E,0x75,0x4E,0x71,	/* 1EC8: ..*_NuNq */
	0x20,0x6F,0x00,0x04,0x11,0x68,0x00,0x0B,	/* 1ED0:  o...h.. */
	0x00,0x0A,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 1ED8: ..p.3.. */
	0x61,0xF4,0x70,0x00,0x42,0x28,0x00,0x0E,	/* 1EE0: ap.B(.. */
	0x4E,0x75,0x4E,0x71,0x2F,0x0D,0x70,0x00,	/* 1EE8: NuNq..p. */
	0x2F,0x07,0x7E,0x00,0x2A,0x6F,0x00,0x0C,	/* 1EF0: ..~.*o.. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 1EF8: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 1F00: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 1F08: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 1F10: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 1F18:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 1F20: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 1F28: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 1F30: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 1F38: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 1F40: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x4A,0x2D,	/* 1F48: .....J- */
	0x00,0x27,0x66,0x1E,0x22,0x3C,0x04,0x01,	/* 1F50: .'f."<.. */
	0xF0,0x16,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 1F58: . G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 1F60: .... */
	0x00,0xFF,0x80,0xBC,0x00,0x00,0x00,0x04,	/* 1F68: ..... */
	0x10,0x80,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 1F70: .p.3.. */
	0x61,0xF4,0x42,0x2D,0x00,0x0E,0x70,0x00,	/* 1F78: aB-..p. */
	0x2E,0x1F,0x2A,0x5F,0x4E,0x75,0x4E,0x71,	/* 1F80: ..*_NuNq */
	0x4F,0xEF,0xFF,0xF0,0x48,0xD7,0x20,0xE0,	/* 1F88: OH  */
	0x22,0x6F,0x00,0x14,0x2C,0x2F,0x00,0x1C,	/* 1F90: "o..,... */
	0x2A,0x2F,0x00,0x20,0x4B,0xE9,0x00,0x02,	/* 1F98: *.. K.. */
	0x70,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 1FA0: p..-.. */
	0x10,0x15,0x7E,0x00,0x3E,0x00,0x4B,0xE9,	/* 1FA8: ..~.>.K */
	0x00,0x04,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 1FB0: ..p..-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 1FB8: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 1FC0:  A */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x29,	/* 1FC8: ....) */
	0x00,0x07,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 1FD0: ... G */
	0x04,0x01,0xF0,0xFE,0x10,0x29,0x00,0x07,	/* 1FD8: ...).. */
	0x10,0x80,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 1FE0: . G.. */
	0xF0,0xD0,0x10,0x29,0x00,0x07,0xC0,0xBC,	/* 1FE8: .).. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x22,0x3C,	/* 1FF0: ....."< */
	0x04,0x01,0xF0,0xDE,0x20,0x47,0xD1,0xC1,	/* 1FF8: .. G */
	0x20,0x2F,0x00,0x18,0x10,0x80,0x20,0x47,	/* 2000:  .... G */
	0xD1,0xC1,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 2008: .... */
	0x00,0xFF,0xC0,0x86,0x66,0x04,0x20,0x05,	/* 2010: .f. . */
	0x60,0x1E,0x20,0x47,0xD1,0xC1,0x42,0x10,	/* 2018: `. GB. */
	0x20,0x47,0xD1,0xC1,0x10,0x10,0xC0,0xBC,	/* 2020:  G.. */
	0x00,0x00,0x00,0xFF,0xC0,0x86,0x67,0x06,	/* 2028: ...g. */
	0x20,0x05,0x52,0x80,0x60,0x02,0x70,0x00,	/* 2030:  .R`.p. */
	0x4C,0xD7,0x20,0xE0,0x4F,0xEF,0x00,0x10,	/* 2038: L O.. */
	0x4E,0x75,0x4E,0x71,0x4F,0xEF,0xFF,0xF0,	/* 2040: NuNqO */
	0x70,0x00,0x48,0xD7,0x20,0xD0,0x2A,0x6F,	/* 2048: p.H *o */
	0x00,0x14,0x7E,0x00,0x43,0xED,0x00,0x02,	/* 2050: ..~.C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 2058: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 2060: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 2068: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 2070: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 2078:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 2080: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2088:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 2090: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 2098: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 20A0: .... */
	0x10,0x80,0x4A,0x2D,0x00,0x27,0x66,0x04,	/* 20A8: .J-.'f. */
	0x78,0x0E,0x60,0x32,0x48,0x78,0x00,0x09,	/* 20B0: x.`2Hx.. */
	0x48,0x78,0x00,0x20,0x48,0x78,0x00,0x01,	/* 20B8: Hx. Hx.. */
	0x2F,0x0D,0x61,0x00,0xFE,0xC4,0x4F,0xEF,	/* 20C0: ..a.O */
	0x00,0x10,0x28,0x00,0x66,0x18,0x48,0x78,	/* 20C8: ..(.f.Hx */
	0x00,0x0B,0x48,0x78,0x00,0x10,0x48,0x78,	/* 20D0: ..Hx..Hx */
	0x00,0x04,0x2F,0x0D,0x61,0x00,0xFE,0xAA,	/* 20D8: ....a. */
	0x28,0x00,0x4F,0xEF,0x00,0x10,0x22,0x7C,	/* 20E0: (.O.."| */
	0x04,0x01,0xF0,0xDE,0x20,0x47,0xD1,0xC9,	/* 20E8: .. G */
	0x1C,0x10,0xCC,0xBC,0x00,0x00,0x00,0x80,	/* 20F0: ..... */
	0x66,0x06,0x78,0x0E,0x1B,0x46,0x00,0x18,	/* 20F8: f.x..F.. */
	0x4A,0x84,0x66,0x00,0x00,0x6E,0x2F,0x05,	/* 2100: Jf..n.. */
	0x72,0x08,0x70,0x02,0x2A,0x09,0x20,0x47,	/* 2108: r.p.*. G */
	0xD1,0xC5,0x10,0x80,0x20,0x47,0xD1,0xC5,	/* 2110: . G */
	0x42,0x10,0x20,0x47,0xD1,0xC5,0x1C,0x10,	/* 2118: B. G.. */
	0xCC,0xBC,0x00,0x00,0x00,0x80,0x67,0x0A,	/* 2120: ...g. */
	0x4A,0x84,0x66,0x02,0x28,0x01,0x1B,0x46,	/* 2128: Jf.(..F */
	0x00,0x18,0x53,0x81,0x66,0xD8,0x4A,0x84,	/* 2130: ..SfJ */
	0x66,0x36,0x20,0x47,0x70,0x02,0xD1,0xC9,	/* 2138: f6 Gp. */
	0x10,0x80,0x20,0x47,0xD1,0xC9,0x42,0x10,	/* 2140: . GB. */
	0x22,0x3C,0x00,0x00,0x27,0x10,0x2A,0x09,	/* 2148: "<..'.*. */
	0x20,0x47,0xD1,0xC5,0x1C,0x10,0xCC,0xBC,	/* 2150:  G.. */
	0x00,0x00,0x00,0xFF,0x08,0x06,0x00,0x06,	/* 2158: ....... */
	0x66,0x04,0x53,0x81,0x66,0xEA,0x4A,0x81,	/* 2160: f.SfJ */
	0x66,0x06,0x1B,0x46,0x00,0x18,0x78,0x0D,	/* 2168: f..F..x. */
	0x2A,0x1F,0x20,0x47,0x70,0x02,0xD1,0xC9,	/* 2170: *. Gp. */
	0x10,0x80,0x20,0x47,0x70,0x82,0xD1,0xC9,	/* 2178: . Gp */
	0x42,0x10,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 2180: B. G.. */
	0xF0,0x0A,0x10,0x80,0x1B,0x44,0x00,0x28,	/* 2188: ...D.( */
	0x4A,0x84,0x67,0x08,0x20,0x47,0xD1,0xC9,	/* 2190: Jg. G */
	0x70,0x05,0x10,0x80,0x42,0x2D,0x00,0x0E,	/* 2198: p..B-.. */
	0x70,0x00,0x4C,0xD7,0x20,0xD0,0x4F,0xEF,	/* 21A0: p.L O */
	0x00,0x10,0x4E,0x75,0x20,0x6F,0x00,0x04,	/* 21A8: ..Nu o.. */
	0x48,0x78,0x00,0x10,0x2F,0x08,0x61,0x24,	/* 21B0: Hx....a$ */
	0x50,0x8F,0x4E,0x75,0x20,0x6F,0x00,0x04,	/* 21B8: PNu o.. */
	0x48,0x78,0x00,0x02,0x2F,0x08,0x61,0x14,	/* 21C0: Hx....a. */
	0x50,0x8F,0x4E,0x75,0x20,0x6F,0x00,0x04,	/* 21C8: PNu o.. */
	0x48,0x78,0x00,0x80,0x2F,0x08,0x61,0x04,	/* 21D0: Hx...a. */
	0x50,0x8F,0x4E,0x75,0x4F,0xEF,0xFF,0xF4,	/* 21D8: PNuO */
	0x70,0x00,0x48,0xD7,0x20,0xC0,0x2A,0x6F,	/* 21E0: p.H *o */
	0x00,0x10,0x1C,0x2F,0x00,0x17,0x7E,0x00,	/* 21E8: ......~. */
	0x43,0xED,0x00,0x02,0xCC,0xBC,0x00,0x00,	/* 21F0: C.... */
	0x00,0xFF,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 21F8: ..).. */
	0x10,0x11,0x43,0xED,0x00,0x04,0x3E,0x00,	/* 2200: ..C..>. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 2208: p..).. */
	0x10,0x11,0x72,0x00,0x32,0x00,0xC2,0xBC,	/* 2210: ..r.2. */
	0xFF,0xFF,0x7F,0xFF,0x20,0x41,0x10,0x2D,	/* 2218:  A.- */
	0x00,0x07,0xD1,0xFC,0x01,0x01,0x80,0x09,	/* 2220: ..... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 2228: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xFE,0x10,0x80,	/* 2230: ... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2238:  G.-.. */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 2240: .... */
	0x00,0x03,0x10,0x80,0x70,0x06,0xC0,0x86,	/* 2248: ...p. */
	0x67,0x22,0x43,0xED,0x00,0x08,0x70,0x00,	/* 2250: g"C..p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 2258: .).... */
	0x72,0x00,0x80,0xBC,0x00,0x00,0x00,0x01,	/* 2260: r..... */
	0x32,0x00,0x20,0x01,0xE0,0x80,0x13,0x40,	/* 2268: 2. ..@ */
	0x00,0x01,0x12,0x81,0x22,0x3C,0x04,0x01,	/* 2270: ..."<.. */
	0xF0,0x0C,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 2278: . G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 2280: .... */
	0x00,0xFF,0x80,0x86,0x10,0x80,0x70,0x01,	/* 2288: ..p. */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x42,0x2D,	/* 2290: 3..aB- */
	0x00,0x0E,0x70,0x00,0x4C,0xD7,0x20,0xC0,	/* 2298: ..p.L  */
	0x4F,0xEF,0x00,0x0C,0x4E,0x75,0x4E,0x71,	/* 22A0: O..NuNq */
	0x2F,0x0D,0x2F,0x07,0x22,0x6F,0x00,0x0C,	/* 22A8: ...."o.. */
	0x4B,0xE9,0x00,0x02,0x70,0x00,0x10,0x2D,	/* 22B0: K..p..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x7E,0x00,	/* 22B8: ....~. */
	0x3E,0x00,0x4B,0xE9,0x00,0x04,0x70,0x00,	/* 22C0: >.K..p. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 22C8: .-.... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 22D0: r.2. */
	0x7F,0xFF,0x20,0x41,0xD1,0xFC,0x01,0x01,	/* 22D8:  A.. */
	0x80,0x09,0x10,0x29,0x00,0x07,0x10,0x80,	/* 22E0: ..)... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 22E8:  G.. */
	0x10,0x29,0x00,0x07,0x10,0x80,0x20,0x47,	/* 22F0: .)... G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0x10,0x29,	/* 22F8: ...) */
	0x00,0x07,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 2300: ...... */
	0x10,0x80,0x4B,0xE9,0x00,0x08,0x72,0x00,	/* 2308: .K..r. */
	0x12,0x2D,0x00,0x01,0xE1,0x89,0x12,0x15,	/* 2310: .-.... */
	0xC2,0xBC,0x00,0x00,0xFF,0xFE,0x20,0x01,	/* 2318: .. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x81,	/* 2320: .@... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x0C,	/* 2328:  G... */
	0x42,0x10,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 2330: B.p.3.. */
	0x61,0xF4,0x42,0x29,0x00,0x0E,0x70,0x00,	/* 2338: aB)..p. */
	0x2E,0x1F,0x2A,0x5F,0x4E,0x75,0x4E,0x71,	/* 2340: ..*_NuNq */
	0x4F,0xEF,0xFF,0xF0,0x70,0x00,0x48,0xD7,	/* 2348: Op.H */
	0x20,0xE0,0x2A,0x6F,0x00,0x14,0x3A,0x2F,	/* 2350:  *o..:. */
	0x00,0x1A,0x3C,0x2F,0x00,0x1E,0x7E,0x00,	/* 2358: ..<...~. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 2360: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 2368: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 2370: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 2378: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 2380:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 2388: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 2390: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 2398: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 23A0: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 23A8: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x30,0x05,	/* 23B0: .....0. */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x67,0x00,	/* 23B8: ....g. */
	0x00,0x7A,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 23C0: .z0... */
	0x00,0x01,0x67,0x3E,0x22,0x3C,0x04,0x01,	/* 23C8: ..g>"<.. */
	0xF0,0x12,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 23D0: . G"G */
	0xD3,0xC1,0x10,0x11,0x22,0x47,0xC0,0xBC,	/* 23D8: .."G */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 23E0: ..... */
	0x00,0x40,0x10,0x80,0x22,0x3C,0x04,0x01,	/* 23E8: .@."<.. */
	0xF0,0x14,0x20,0x47,0xD1,0xC1,0xD3,0xC1,	/* 23F0: . G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 23F8: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x30,0x10,0x80,	/* 2400: ...0. */
	0x60,0x30,0x22,0x3C,0x04,0x01,0xF0,0x12,	/* 2408: `0"<... */
	0x20,0x47,0x22,0x47,0xD1,0xC1,0xD3,0xC1,	/* 2410:  G"G */
	0x10,0x11,0x22,0x47,0xC0,0xBC,0x00,0x00,	/* 2418: .."G.. */
	0x00,0xBF,0x10,0x80,0x22,0x3C,0x04,0x01,	/* 2420: .."<.. */
	0xF0,0x14,0x20,0x47,0xD1,0xC1,0xD3,0xC1,	/* 2428: . G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xCF,	/* 2430: ..... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 2438: .0... */
	0x00,0x02,0x67,0x42,0x30,0x06,0xC0,0xBC,	/* 2440: ..gB0. */
	0x00,0x00,0x00,0x02,0x67,0x20,0x22,0x3C,	/* 2448: ....g "< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0x22,0x47,	/* 2450: ... G"G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 2458: .. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 2460: ..... */
	0x00,0x80,0x10,0x80,0x60,0x18,0x22,0x3C,	/* 2468: ..`."< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0x22,0x47,	/* 2470: ... G"G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 2478: .. */
	0x00,0x00,0x00,0x7F,0x10,0x80,0x30,0x05,	/* 2480: ....0. */
	0xC0,0xBC,0x00,0x00,0x00,0x10,0x67,0x42,	/* 2488: ....gB */
	0x30,0x06,0xC0,0xBC,0x00,0x00,0x00,0x10,	/* 2490: 0..... */
	0x67,0x20,0x22,0x3C,0x04,0x01,0xF0,0x12,	/* 2498: g "<... */
	0x20,0x47,0x22,0x47,0xD1,0xC1,0xD3,0xC1,	/* 24A0:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 24A8: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x02,0x10,0x80,	/* 24B0: ..... */
	0x60,0x18,0x22,0x3C,0x04,0x01,0xF0,0x12,	/* 24B8: `."<... */
	0x20,0x47,0x22,0x47,0xD1,0xC1,0xD3,0xC1,	/* 24C0:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFD,	/* 24C8: ..... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 24D0: .0... */
	0x00,0x20,0x67,0x06,0x08,0xED,0x00,0x04,	/* 24D8: . g.... */
	0x00,0x40,0x70,0x00,0x10,0x2D,0x00,0x06,	/* 24E0: .@p..-.. */
	0x72,0x48,0xB2,0x80,0x66,0x00,0x02,0x04,	/* 24E8: rHf... */
	0x22,0x3C,0x04,0x01,0xF0,0x2A,0x20,0x47,	/* 24F0: "<..* G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 24F8: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF0,0x80,0xBC,	/* 2500: ... */
	0x00,0x00,0x00,0x0F,0x10,0x80,0x30,0x05,	/* 2508: .....0. */
	0xC0,0xBC,0x00,0x00,0x01,0x00,0x67,0x42,	/* 2510: ....gB */
	0x30,0x06,0xC0,0xBC,0x00,0x00,0x01,0x00,	/* 2518: 0..... */
	0x67,0x20,0x22,0x3C,0x04,0x01,0xF0,0x3E,	/* 2520: g "<..> */
	0x20,0x47,0x22,0x47,0xD1,0xC1,0xD3,0xC1,	/* 2528:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 2530: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x08,0x10,0x80,	/* 2538: ..... */
	0x60,0x18,0x22,0x3C,0x04,0x01,0xF0,0x3E,	/* 2540: `."<..> */
	0x20,0x47,0x22,0x47,0xD1,0xC1,0xD3,0xC1,	/* 2548:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xF7,	/* 2550: ..... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 2558: .0... */
	0x10,0x00,0x67,0x00,0x00,0xBE,0x08,0x2D,	/* 2560: ..g...- */
	0x00,0x03,0x00,0x24,0x67,0x5C,0x30,0x06,	/* 2568: ...$g\0. */
	0xC0,0xBC,0x00,0x00,0x10,0x00,0x67,0x28,	/* 2570: ....g( */
	0x22,0x3C,0x04,0x01,0xF0,0x3E,0x20,0x47,	/* 2578: "<..> G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 2580: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFB,0x10,0x80,	/* 2588: .... */
	0x20,0x47,0x70,0x02,0xD1,0xFC,0x04,0x01,	/* 2590:  Gp... */
	0xF0,0xDA,0x10,0x80,0x60,0x00,0x00,0x84,	/* 2598: .`.. */
	0x22,0x3C,0x04,0x01,0xF0,0x3E,0x20,0x47,	/* 25A0: "<..> G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 25A8: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0xBC,	/* 25B0: ... */
	0x00,0x00,0x00,0x04,0x10,0x80,0x20,0x47,	/* 25B8: ..... G */
	0xD1,0xFC,0x04,0x01,0xF0,0xDA,0x42,0x10,	/* 25C0: ..B. */
	0x60,0x58,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 25C8: `X0... */
	0x10,0x00,0x67,0x2C,0x22,0x3C,0x04,0x01,	/* 25D0: ..g,"<.. */
	0xF0,0x12,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 25D8: . G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 25E0: .... */
	0x00,0xFF,0x80,0xBC,0x00,0x00,0x00,0x04,	/* 25E8: ..... */
	0x10,0x80,0x20,0x47,0x70,0x01,0xD1,0xFC,	/* 25F0: . Gp. */
	0x04,0x01,0xF0,0xD8,0x10,0x80,0x60,0x22,	/* 25F8: ...`" */
	0x22,0x3C,0x04,0x01,0xF0,0x12,0x20,0x47,	/* 2600: "<... G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 2608: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFB,0x10,0x80,	/* 2610: .... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xD8,	/* 2618:  G.. */
	0x42,0x10,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 2620: B.0... */
	0x20,0x00,0x67,0x00,0x01,0xDE,0x08,0x2D,	/* 2628:  .g...- */
	0x00,0x03,0x00,0x24,0x67,0x5E,0x30,0x06,	/* 2630: ...$g^0. */
	0xC0,0xBC,0x00,0x00,0x20,0x00,0x67,0x2E,	/* 2638: .. .g. */
	0x2C,0x3C,0x04,0x01,0xF0,0x12,0x20,0x47,	/* 2640: ,<... G */
	0x22,0x47,0xD1,0xC6,0xD3,0xC6,0x10,0x11,	/* 2648: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0xBC,	/* 2650: ... */
	0x00,0x00,0x00,0x04,0x10,0x80,0x20,0x47,	/* 2658: ..... G */
	0x70,0x01,0xD1,0xFC,0x04,0x01,0xF0,0xD8,	/* 2660: p... */
	0x10,0x80,0x60,0x00,0x01,0x9E,0x2C,0x3C,	/* 2668: .`..,< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0x22,0x47,	/* 2670: ... G"G */
	0xD1,0xC6,0xD3,0xC6,0x10,0x11,0xC0,0xBC,	/* 2678: .. */
	0x00,0x00,0x00,0xFB,0x10,0x80,0x20,0x47,	/* 2680: .... G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0x42,0x10,	/* 2688: ..B. */
	0x60,0x00,0x01,0x78,0x30,0x06,0xC0,0xBC,	/* 2690: `..x0. */
	0x00,0x00,0x20,0x00,0x67,0x28,0x2C,0x3C,	/* 2698: .. .g(,< */
	0x04,0x01,0xF0,0x3E,0x20,0x47,0x22,0x47,	/* 26A0: ..> G"G */
	0xD1,0xC6,0xD3,0xC6,0x10,0x11,0xC0,0xBC,	/* 26A8: .. */
	0x00,0x00,0x00,0xFB,0x10,0x80,0x20,0x47,	/* 26B0: .... G */
	0x70,0x02,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 26B8: p... */
	0x10,0x80,0x60,0x00,0x01,0x46,0x2C,0x3C,	/* 26C0: .`..F,< */
	0x04,0x01,0xF0,0x3E,0x20,0x47,0x22,0x47,	/* 26C8: ..> G"G */
	0xD1,0xC6,0xD3,0xC6,0x10,0x11,0xC0,0xBC,	/* 26D0: .. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 26D8: ..... */
	0x00,0x04,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 26E0: ... G */
	0x04,0x01,0xF0,0xDA,0x42,0x10,0x60,0x00,	/* 26E8: ..B.`. */
	0x01,0x1A,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 26F0: ..0... */
	0x10,0x00,0x67,0x00,0x00,0x7E,0x08,0x2D,	/* 26F8: ..g..~.- */
	0x00,0x03,0x00,0x24,0x67,0x5A,0x30,0x06,	/* 2700: ...$gZ0. */
	0xC0,0xBC,0x00,0x00,0x10,0x00,0x67,0x2C,	/* 2708: ....g, */
	0x22,0x3C,0x04,0x01,0xF0,0x2A,0x20,0x47,	/* 2710: "<..* G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 2718: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF0,0x80,0xBC,	/* 2720: ... */
	0x00,0x00,0x00,0x09,0x10,0x80,0x20,0x47,	/* 2728: ..... G */
	0x70,0x02,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2730: p... */
	0x10,0x80,0x60,0x3E,0x22,0x3C,0x04,0x01,	/* 2738: .`>"<.. */
	0xF0,0x2A,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 2740: * G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 2748: .... */
	0x00,0xF0,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 2750: .. G */
	0x04,0x01,0xF0,0xDA,0x42,0x10,0x60,0x1A,	/* 2758: ..B.`. */
	0x20,0x47,0x30,0x06,0xD1,0xFC,0x04,0x01,	/* 2760:  G0... */
	0xF0,0xD8,0xC0,0xBC,0x00,0x00,0x10,0x00,	/* 2768: .... */
	0x56,0xC0,0xC0,0xBC,0x00,0x00,0x00,0x01,	/* 2770: V.... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 2778: .0... */
	0x20,0x00,0x67,0x00,0x00,0x86,0x08,0x2D,	/* 2780:  .g...- */
	0x00,0x03,0x00,0x24,0x67,0x24,0x30,0x06,	/* 2788: ...$g$0. */
	0xC0,0xBC,0x00,0x00,0x20,0x00,0x67,0x0E,	/* 2790: .. .g. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xD8,	/* 2798:  G.. */
	0x70,0x01,0x10,0x80,0x60,0x64,0x20,0x47,	/* 27A0: p..`d G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0x42,0x10,	/* 27A8: ..B. */
	0x60,0x58,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 27B0: `X0... */
	0x20,0x00,0x67,0x2C,0x2C,0x3C,0x04,0x01,	/* 27B8:  .g,,<.. */
	0xF0,0x2A,0x20,0x47,0x22,0x47,0xD1,0xC6,	/* 27C0: * G"G */
	0xD3,0xC6,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 27C8: .... */
	0x00,0xF0,0x80,0xBC,0x00,0x00,0x00,0x09,	/* 27D0: ..... */
	0x10,0x80,0x20,0x47,0x70,0x02,0xD1,0xFC,	/* 27D8: . Gp. */
	0x04,0x01,0xF0,0xDA,0x10,0x80,0x60,0x22,	/* 27E0: ...`" */
	0x2C,0x3C,0x04,0x01,0xF0,0x2A,0x20,0x47,	/* 27E8: ,<..* G */
	0x22,0x47,0xD1,0xC6,0xD3,0xC6,0x10,0x11,	/* 27F0: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF0,0x10,0x80,	/* 27F8: .... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2800:  G.. */
	0x42,0x10,0x4C,0xD7,0x20,0xE0,0x4F,0xEF,	/* 2808: B.L O */
	0x00,0x10,0x4E,0x75,0x4F,0xEF,0xFF,0xF0,	/* 2810: ..NuO */
	0x70,0x00,0x48,0xD7,0x20,0xE0,0x2A,0x6F,	/* 2818: p.H *o */
	0x00,0x14,0x3A,0x2F,0x00,0x1A,0x3C,0x2F,	/* 2820: ..:...<. */
	0x00,0x1E,0x7E,0x00,0x43,0xED,0x00,0x02,	/* 2828: ..~.C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 2830: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 2838: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 2840: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 2848: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 2850:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 2858: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2860:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 2868: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 2870: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 2878: .... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 2880: .0... */
	0x10,0x00,0x67,0x46,0x08,0x2D,0x00,0x03,	/* 2888: ..gF.-.. */
	0x00,0x24,0x67,0x24,0x30,0x06,0xC0,0xBC,	/* 2890: .$g$0. */
	0x00,0x00,0x10,0x00,0x67,0x0E,0x20,0x47,	/* 2898: ....g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0xDA,0x70,0x02,	/* 28A0: ..p. */
	0x10,0x80,0x60,0x26,0x20,0x47,0xD1,0xFC,	/* 28A8: .`& G */
	0x04,0x01,0xF0,0xDA,0x42,0x10,0x60,0x1A,	/* 28B0: ..B.`. */
	0x20,0x47,0x30,0x06,0xD1,0xFC,0x04,0x01,	/* 28B8:  G0... */
	0xF0,0xD8,0xC0,0xBC,0x00,0x00,0x10,0x00,	/* 28C0: .... */
	0x56,0xC0,0xC0,0xBC,0x00,0x00,0x00,0x01,	/* 28C8: V.... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 28D0: .0... */
	0x20,0x00,0x67,0x4E,0x08,0x2D,0x00,0x03,	/* 28D8:  .gN.-.. */
	0x00,0x24,0x67,0x24,0x30,0x06,0xC0,0xBC,	/* 28E0: .$g$0. */
	0x00,0x00,0x20,0x00,0x67,0x0E,0x20,0x47,	/* 28E8: .. .g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0x70,0x01,	/* 28F0: ..p. */
	0x10,0x80,0x60,0x2E,0x20,0x47,0xD1,0xFC,	/* 28F8: .`. G */
	0x04,0x01,0xF0,0xD8,0x42,0x10,0x60,0x22,	/* 2900: ..B.`" */
	0x30,0x06,0xC0,0xBC,0x00,0x00,0x20,0x00,	/* 2908: 0... . */
	0x67,0x0E,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 2910: g. G.. */
	0xF0,0xDA,0x70,0x02,0x10,0x80,0x60,0x0A,	/* 2918: p..`. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2920:  G.. */
	0x42,0x10,0x4C,0xD7,0x20,0xE0,0x4F,0xEF,	/* 2928: B.L O */
	0x00,0x10,0x4E,0x75,0x2F,0x07,0x7E,0x00,	/* 2930: ..Nu..~. */
	0x20,0x3C,0x00,0x00,0x4E,0x20,0x22,0x3C,	/* 2938:  <..N "< */
	0x00,0x00,0x4A,0x38,0x52,0x87,0xBE,0x81,	/* 2940: ..J8R */
	0x67,0x04,0xBE,0x80,0x6D,0xF6,0x2E,0x1F,	/* 2948: g.m.. */
	0x4E,0x75,0x4E,0x71,0x4E,0x56,0xFF,0xF8,	/* 2950: NuNqNV */
	0x4F,0xEF,0xFF,0xDC,0x48,0xD7,0x38,0xFC,	/* 2958: OH8 */
	0x34,0x2E,0x00,0x0A,0x7C,0x01,0x26,0x3C,	/* 2960: 4...|.&< */
	0x04,0x01,0xF0,0xCC,0x7E,0x00,0x3E,0x02,	/* 2968: ..~.>. */
	0x20,0x47,0xD1,0xC3,0x10,0x86,0x78,0x03,	/* 2970:  G.x. */
	0x2A,0x7C,0x04,0x01,0xF0,0xD0,0x20,0x47,	/* 2978: *|.. G */
	0xD1,0xCD,0x10,0x84,0x22,0x3C,0x04,0x01,	/* 2980: ."<.. */
	0xF0,0xE8,0x20,0x47,0xD1,0xC1,0x42,0x10,	/* 2988:  GB. */
	0x20,0x47,0xD1,0xCD,0x70,0x02,0x10,0x80,	/* 2990:  Gp.. */
	0x20,0x47,0xD1,0xC1,0x42,0x10,0x20,0x47,	/* 2998:  GB. G */
	0xD1,0xCD,0x10,0x86,0x20,0x47,0xD1,0xC1,	/* 29A0: . G */
	0x42,0x10,0x20,0x47,0xD1,0xCD,0x42,0x10,	/* 29A8: B. GB. */
	0x20,0x47,0xD1,0xC1,0x42,0x10,0x20,0x47,	/* 29B0:  GB. G */
	0xD1,0xCD,0x10,0x84,0x22,0x3C,0x04,0x01,	/* 29B8: ."<.. */
	0xF0,0xF4,0x20,0x47,0xD1,0xC1,0x42,0x10,	/* 29C0:  GB. */
	0x20,0x47,0xD1,0xCD,0x70,0x02,0x10,0x80,	/* 29C8:  Gp.. */
	0x20,0x47,0xD1,0xC1,0x42,0x10,0x20,0x47,	/* 29D0:  GB. G */
	0xD1,0xCD,0x10,0x86,0x20,0x47,0xD1,0xC1,	/* 29D8: . G */
	0x42,0x10,0x20,0x47,0xD1,0xCD,0x42,0x10,	/* 29E0: B. GB. */
	0x20,0x47,0xD1,0xC1,0x42,0x10,0x7A,0x04,	/* 29E8:  GB.z. */
	0x20,0x47,0xD1,0xCD,0x10,0x85,0x26,0x7C,	/* 29F0:  G.&| */
	0x04,0x01,0xF0,0xDA,0x20,0x47,0xD1,0xCB,	/* 29F8: .. G */
	0x70,0xA8,0x10,0x80,0x22,0x7C,0x04,0x01,	/* 2A00: p."|.. */
	0xF0,0xDC,0x20,0x47,0xD1,0xC9,0x42,0x10,	/* 2A08:  GB. */
	0x22,0x3C,0x04,0x01,0xF0,0xDE,0x20,0x47,	/* 2A10: "<.. G */
	0xD1,0xC1,0x42,0x10,0x28,0x7C,0x04,0x01,	/* 2A18: B.(|.. */
	0xF0,0xD8,0x20,0x47,0xD1,0xCC,0x10,0x86,	/* 2A20:  G. */
	0x20,0x47,0xD1,0xC3,0x10,0x84,0x20,0x47,	/* 2A28:  G. G */
	0xD1,0xC3,0x10,0x84,0x20,0x47,0xD1,0xC3,	/* 2A30: . G */
	0x10,0x84,0x20,0x47,0xD1,0xCD,0x10,0x85,	/* 2A38: . G. */
	0x20,0x47,0xD1,0xCB,0x70,0xA8,0x10,0x80,	/* 2A40:  Gp. */
	0x20,0x47,0xD1,0xC9,0x70,0x20,0x10,0x80,	/* 2A48:  Gp . */
	0x20,0x47,0xD1,0xC1,0x42,0x10,0x20,0x47,	/* 2A50:  GB. G */
	0xD1,0xC3,0x10,0x84,0x20,0x47,0xD1,0xC3,	/* 2A58: . G */
	0x10,0x84,0x20,0x47,0xD1,0xC3,0x10,0x84,	/* 2A60: . G. */
	0x20,0x47,0xD1,0xCC,0x42,0x10,0x78,0x10,	/* 2A68:  GB.x. */
	0x7A,0x03,0x2C,0x03,0xE2,0x8C,0x20,0x47,	/* 2A70: z.,. G */
	0xD1,0xC6,0x10,0x85,0x20,0x47,0xD1,0xC6,	/* 2A78: . G */
	0x10,0x85,0x53,0x84,0x66,0xF0,0x7E,0x00,	/* 2A80: .Sf~. */
	0x3E,0x02,0x20,0x47,0xD1,0xCD,0x70,0x04,	/* 2A88: >. Gp. */
	0x10,0x80,0x20,0x47,0xD1,0xCB,0x42,0x10,	/* 2A90: . GB. */
	0x20,0x47,0xD1,0xC9,0x70,0x20,0x10,0x80,	/* 2A98:  Gp . */
	0x20,0x47,0xD1,0xC1,0x70,0x03,0x10,0x80,	/* 2AA0:  Gp.. */
	0x20,0x47,0xD1,0xCC,0x70,0x01,0x10,0x80,	/* 2AA8:  Gp.. */
	0x20,0x47,0xD1,0xC3,0x70,0x03,0x10,0x80,	/* 2AB0:  Gp.. */
	0x20,0x47,0xD1,0xC3,0x70,0x03,0x10,0x80,	/* 2AB8:  Gp.. */
	0x20,0x47,0xD1,0xC3,0x70,0x03,0x10,0x80,	/* 2AC0:  Gp.. */
	0x20,0x47,0xD1,0xC3,0x70,0x03,0x10,0x80,	/* 2AC8:  Gp.. */
	0x20,0x47,0xD1,0xCC,0x42,0x10,0x20,0x47,	/* 2AD0:  GB. G */
	0xD1,0xC3,0x42,0x10,0x20,0x47,0xD1,0xCD,	/* 2AD8: B. G */
	0x42,0x10,0x48,0x78,0x00,0x64,0x61,0x00,	/* 2AE0: B.Hx.da. */
	0xFE,0x4C,0x58,0x8F,0x4C,0xD7,0x38,0xFC,	/* 2AE8: LXL8 */
	0x4F,0xEF,0x00,0x24,0x4E,0x5E,0x4E,0x75,	/* 2AF0: O.$N^Nu */
	0x4F,0xEF,0xFF,0xF4,0x70,0x00,0x48,0xD7,	/* 2AF8: Op.H */
	0x20,0xC0,0x2A,0x6F,0x00,0x10,0x7E,0x00,	/* 2B00:  *o..~. */
	0x7C,0x00,0x43,0xED,0x00,0x02,0x10,0x29,	/* 2B08: |.C...) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x43,0xED,	/* 2B10: ....C */
	0x00,0x04,0x3E,0x00,0x70,0x00,0x10,0x29,	/* 2B18: ..>.p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x72,0x00,	/* 2B20: ....r. */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 2B28: 2. */
	0x20,0x41,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2B30:  A.-.. */
	0x01,0x01,0x80,0x09,0x10,0x80,0x20,0x47,	/* 2B38: .... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 2B40: .-.... */
	0xF0,0xFE,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 2B48: . G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 2B50: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 2B58: ..... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xD8,	/* 2B60:  G.. */
	0x1E,0x10,0x12,0x2D,0x00,0x26,0xCE,0x81,	/* 2B68: ...-.& */
	0xCE,0xBC,0x00,0x00,0x00,0xFF,0x4A,0x07,	/* 2B70: ...J. */
	0x6A,0x02,0x7C,0x04,0x08,0x07,0x00,0x05,	/* 2B78: j.|..... */
	0x67,0x06,0x8C,0xBC,0x00,0x00,0x00,0x40,	/* 2B80: g....@ */
	0x08,0x07,0x00,0x04,0x67,0x06,0x8C,0xBC,	/* 2B88: ....g. */
	0x00,0x00,0x00,0x20,0x08,0x07,0x00,0x06,	/* 2B90: ... .... */
	0x67,0x06,0x8C,0xBC,0x00,0x00,0x00,0x02,	/* 2B98: g..... */
	0x1B,0x46,0x00,0x18,0x4C,0xD7,0x20,0xC0,	/* 2BA0: .F..L  */
	0x4F,0xEF,0x00,0x0C,0x4E,0x75,0x4E,0x71,	/* 2BA8: O..NuNq */
	0x4E,0x56,0x00,0x00,0x4F,0xEF,0xFF,0xE8,	/* 2BB0: NV..O */
	0x48,0xD7,0x00,0xFC,0x78,0x00,0x2E,0x3C,	/* 2BB8: H.x..< */
	0x04,0x01,0xF0,0xFE,0x70,0x00,0x30,0x2E,	/* 2BC0: ..p.0. */
	0x00,0x0A,0x20,0x40,0xD1,0xC7,0x20,0x04,	/* 2BC8: .. @ . */
	0xE5,0x88,0x10,0x80,0x30,0x2E,0x00,0x0A,	/* 2BD0: .0... */
	0x2F,0x00,0x61,0x00,0xFD,0x78,0x58,0x8F,	/* 2BD8: ..a.xX */
	0x4A,0x84,0x66,0x1A,0x7C,0x00,0x3C,0x2E,	/* 2BE0: Jf.|.<. */
	0x00,0x0A,0x20,0x46,0xD1,0xC7,0x1A,0x10,	/* 2BE8: .. F.. */
	0x20,0x46,0xD1,0xC7,0xCA,0xBC,0x00,0x00,	/* 2BF0:  F.. */
	0x00,0x07,0x10,0x10,0x60,0x1A,0x7C,0x00,	/* 2BF8: ....`.|. */
	0x3C,0x2E,0x00,0x0A,0x20,0x46,0xD1,0xC7,	/* 2C00: <... F */
	0x1A,0x10,0x20,0x46,0xD1,0xC7,0xCA,0xBC,	/* 2C08: .. F */
	0x00,0x00,0x00,0xFF,0xE8,0x85,0x10,0x10,	/* 2C10: ..... */
	0x30,0x05,0x48,0xC0,0x5B,0x80,0x66,0x14,	/* 2C18: 0.H[f. */
	0x70,0x00,0x30,0x2E,0x00,0x0A,0x20,0x40,	/* 2C20: p.0... @ */
	0xD1,0xFC,0x04,0x01,0xF0,0x96,0x70,0x80,	/* 2C28: ..p */
	0x10,0x80,0x60,0x10,0x70,0x00,0x30,0x2E,	/* 2C30: .`.p.0. */
	0x00,0x0A,0x20,0x40,0xD1,0xFC,0x04,0x01,	/* 2C38: .. @.. */
	0xF0,0x96,0x42,0x10,0x7C,0x00,0x70,0x27,	/* 2C40: B.|.p' */
	0x7E,0x00,0x74,0x04,0x3C,0x2E,0x00,0x0A,	/* 2C48: ~.t.<... */
	0x20,0x46,0xD1,0xFC,0x04,0x01,0xF0,0xFC,	/* 2C50:  F.. */
	0x10,0x80,0x26,0x3C,0x04,0x01,0xF0,0xD0,	/* 2C58: .&<.. */
	0x20,0x46,0xD1,0xC3,0x10,0x87,0x4A,0x87,	/* 2C60:  F.J */
	0x66,0x42,0x30,0x05,0x48,0xC0,0x5B,0x80,	/* 2C68: fB0.H[ */
	0x66,0x3A,0x20,0x46,0xD1,0xFC,0x04,0x01,	/* 2C70: f: F.. */
	0xF0,0xEC,0x42,0x10,0x20,0x46,0xD1,0xFC,	/* 2C78: B. F */
	0x04,0x01,0xF0,0x80,0x10,0x10,0x72,0x44,	/* 2C80: ....rD */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0xB2,0x80,	/* 2C88: ... */
	0x6F,0x0E,0x20,0x46,0xD1,0xFC,0x04,0x01,	/* 2C90: o. F.. */
	0xF0,0xE4,0x70,0x42,0x10,0x80,0x60,0x0C,	/* 2C98: pB.`. */
	0x20,0x46,0xD1,0xFC,0x04,0x01,0xF0,0xE4,	/* 2CA0:  F.. */
	0x70,0x1F,0x10,0x80,0x52,0x87,0xBE,0x82,	/* 2CA8: p..R */
	0x6D,0xAE,0x7A,0x00,0x3A,0x2E,0x00,0x0A,	/* 2CB0: mz.:... */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0x30,	/* 2CB8:  E..0 */
	0x42,0x10,0x20,0x45,0xD1,0xFC,0x04,0x01,	/* 2CC0: B. E.. */
	0xF0,0xD8,0x42,0x10,0x20,0x45,0xD1,0xFC,	/* 2CC8: B. E */
	0x04,0x01,0xF0,0xDA,0x42,0x10,0x2E,0x3C,	/* 2CD0: ..B..< */
	0x04,0x01,0xF0,0x0A,0x20,0x45,0xD1,0xC7,	/* 2CD8: ... E */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 2CE0: ..... */
	0x4A,0x00,0x66,0xF0,0x52,0x84,0x70,0x02,	/* 2CE8: J.fRp. */
	0xB0,0x84,0x6E,0x00,0xFE,0xCA,0x4C,0xD7,	/* 2CF0: n.L */
	0x00,0xFC,0x4F,0xEF,0x00,0x18,0x4E,0x5E,	/* 2CF8: .O..N^ */
	0x4E,0x75,0x4E,0x71,0x4E,0x56,0xFF,0xF8,	/* 2D00: NuNqNV */
	0x70,0x01,0x13,0xC0,0x03,0x01,0xF8,0x80,	/* 2D08: p.... */
	0x4F,0xEF,0xFF,0xDC,0x20,0x3C,0x00,0x00,	/* 2D10: O <.. */
	0x63,0xE0,0x48,0xD7,0x3C,0xF8,0x2A,0x7C,	/* 2D18: cH<*| */
	0x01,0x01,0x81,0x80,0x2D,0x40,0xFF,0xFC,	/* 2D20: ..-@ */
	0x20,0x6E,0xFF,0xFC,0x20,0xBC,0x10,0x00,	/* 2D28:  n .. */
	0x00,0x00,0x38,0x3C,0xFF,0xFE,0x2C,0x3C,	/* 2D30: ..8<,< */
	0x01,0x01,0x80,0x00,0x3A,0x3C,0xFD,0xEE,	/* 2D38: ...:< */
	0x26,0x3C,0x00,0x00,0x62,0xA8,0x24,0x7C,	/* 2D40: &<..b$| */
	0x00,0x00,0x61,0xEC,0x4A,0x12,0x67,0x06,	/* 2D48: ..aJ.g. */
	0x4E,0xB9,0x00,0x00,0x0E,0x60,0x20,0x79,	/* 2D50: N...` y */
	0x00,0x00,0x63,0xD0,0x49,0xED,0x00,0x2E,	/* 2D58: ..cI.. */
	0x10,0x28,0x00,0x07,0x52,0x80,0x11,0x40,	/* 2D60: .(..R.@ */
	0x00,0x07,0x20,0x6E,0xFF,0xFC,0x70,0x00,	/* 2D68: .. np. */
	0x22,0x50,0x33,0x45,0x00,0x36,0x10,0x2C,	/* 2D70: "P3E.6., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 2D78: ....r. */
	0x28,0x49,0x32,0x00,0x2A,0x41,0xDB,0xC6,	/* 2D80: (I2.*A */
	0x70,0x00,0x30,0x2C,0x00,0x3A,0x4A,0x80,	/* 2D88: p.0,.:J */
	0x66,0xF6,0x33,0x44,0x00,0x36,0x70,0x00,	/* 2D90: f3D.6p. */
	0x7E,0x00,0x10,0x2D,0x00,0x0E,0x3E,0x00,	/* 2D98: ~..-..>. */
	0x4A,0x87,0x67,0x14,0x20,0x43,0x20,0x70,	/* 2DA0: Jg. C p */
	0x7C,0x00,0x2F,0x0D,0x4E,0x90,0x58,0x8F,	/* 2DA8: |...NX */
	0x72,0x00,0x32,0x00,0x4A,0x81,0x67,0x94,	/* 2DB0: r.2.Jg */
	0x49,0xED,0x00,0x02,0x70,0x00,0x7A,0x00,	/* 2DB8: I..p.z. */
	0x7C,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 2DC0: |..,.. */
	0x10,0x14,0x49,0xED,0x00,0x08,0x3A,0x00,	/* 2DC8: ..I..:. */
	0x1C,0x2C,0x00,0x01,0xE1,0x8E,0x1C,0x14,	/* 2DD0: .,.... */
	0x4A,0x87,0x66,0x00,0x00,0xA6,0x30,0x06,	/* 2DD8: Jf..0. */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x66,0x00,	/* 2DE0: ....f. */
	0x00,0x9A,0x10,0x2D,0x00,0x0D,0x12,0x2D,	/* 2DE8: ..-...- */
	0x00,0x0C,0x90,0x81,0x4A,0x00,0x67,0x00,	/* 2DF0: ..J.g. */
	0x00,0x8A,0x8C,0xBC,0x00,0x00,0x00,0x01,	/* 2DF8: ..... */
	0x49,0xED,0x00,0x08,0xCC,0xBC,0x00,0x00,	/* 2E00: I.... */
	0xFF,0xFF,0x2E,0x06,0x20,0x07,0xE0,0x80,	/* 2E08: .. . */
	0x19,0x40,0x00,0x01,0x18,0x87,0x49,0xED,	/* 2E10: .@...I */
	0x00,0x04,0x70,0x00,0x10,0x2C,0x00,0x01,	/* 2E18: ..p..,.. */
	0xE1,0x88,0x10,0x14,0x72,0x00,0x32,0x00,	/* 2E20: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 2E28:  A */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x2D,	/* 2E30: ....- */
	0x00,0x07,0x10,0x80,0x20,0x45,0xD1,0xFC,	/* 2E38: ... E */
	0x04,0x01,0xF0,0xFE,0x10,0x2D,0x00,0x07,	/* 2E40: ...-.. */
	0x10,0x80,0x20,0x45,0xD1,0xFC,0x04,0x01,	/* 2E48: . E.. */
	0xF0,0xD0,0x10,0x2D,0x00,0x07,0xC0,0xBC,	/* 2E50: .-.. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x2E,0x3C,	/* 2E58: ......< */
	0x04,0x01,0xF0,0x0C,0x20,0x45,0xD1,0xC7,	/* 2E60: ... E */
	0x22,0x45,0xD3,0xC7,0x10,0x11,0xC0,0xBC,	/* 2E68: "E.. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 2E70: ..... */
	0x00,0x04,0x10,0x80,0x70,0x01,0x1B,0x40,	/* 2E78: ...p..@ */
	0x00,0x29,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 2E80: .)0... */
	0x00,0x10,0x67,0x00,0x01,0x88,0x30,0x06,	/* 2E88: ..g..0. */
	0xC0,0xBC,0x00,0x00,0x00,0x80,0x67,0x00,	/* 2E90: ...g. */
	0x00,0x8A,0x49,0xED,0x00,0x04,0x70,0x00,	/* 2E98: .I..p. */
	0x2E,0x3C,0x04,0x01,0xF0,0x0A,0x10,0x2C,	/* 2EA0: .<...., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 2EA8: ....r. */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 2EB0: 2. */
	0x20,0x41,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2EB8:  A.-.. */
	0x01,0x01,0x80,0x09,0x10,0x80,0x20,0x45,	/* 2EC0: .... E */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 2EC8: .-.... */
	0xF0,0xFE,0x10,0x80,0x20,0x45,0x10,0x2D,	/* 2ED0: . E.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 2ED8: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 2EE0: ..... */
	0x20,0x45,0xD1,0xC7,0x10,0x10,0xC0,0xBC,	/* 2EE8:  E.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x66,0x00,	/* 2EF0: ...J.f. */
	0x01,0x08,0x42,0xA7,0x48,0x78,0x01,0x00,	/* 2EF8: ..BHx.. */
	0x2F,0x0D,0x61,0x00,0xF4,0x44,0x20,0x45,	/* 2F00: ..a.D E */
	0x70,0x22,0x8C,0xBC,0x00,0x00,0x00,0x20,	/* 2F08: p"...  */
	0x4F,0xEF,0x00,0x0C,0xD1,0xC7,0x10,0x80,	/* 2F10: O... */
	0xCC,0xBC,0x00,0x00,0xFF,0x3F,0x60,0x00,	/* 2F18: ..?`. */
	0x00,0xE0,0x10,0x2D,0x00,0x0A,0x12,0x2D,	/* 2F20: ..-...- */
	0x00,0x0B,0x90,0x81,0x72,0x00,0x12,0x00,	/* 2F28: ..r... */
	0x70,0x40,0xB0,0x81,0x6F,0x00,0x00,0xCA,	/* 2F30: p@o.. */
	0x49,0xED,0x00,0x04,0x70,0x00,0x2E,0x3C,	/* 2F38: I..p..< */
	0x04,0x01,0xF0,0x0A,0x10,0x2C,0x00,0x01,	/* 2F40: ....,.. */
	0xE1,0x88,0x10,0x14,0x72,0x00,0x32,0x00,	/* 2F48: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 2F50:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 2F58: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x45,0x10,0x2D,	/* 2F60: .. E.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 2F68: .... */
	0x10,0x80,0x20,0x45,0x10,0x2D,0x00,0x07,	/* 2F70: . E.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 2F78: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x20,0x45,	/* 2F80: ..... E */
	0xD1,0xC7,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 2F88: .... */
	0x00,0xFF,0x4A,0x00,0x66,0x00,0x00,0x6A,	/* 2F90: .J.f..j */
	0x08,0x2D,0x00,0x03,0x00,0x30,0x67,0x22,	/* 2F98: .-...0g" */
	0x28,0x3C,0x00,0x00,0x01,0x00,0x2F,0x04,	/* 2FA0: (<...... */
	0x2F,0x04,0x2F,0x0D,0x61,0x00,0xF3,0x9A,	/* 2FA8: ....a. */
	0x20,0x45,0x70,0x21,0x4F,0xEF,0x00,0x0C,	/* 2FB0:  Ep!O.. */
	0xD1,0xC7,0x10,0x80,0xCC,0xBC,0x00,0x00,	/* 2FB8: ... */
	0xFF,0x9F,0x08,0x2D,0x00,0x07,0x00,0x31,	/* 2FC0: .-...1 */
	0x67,0x14,0x2E,0x3C,0x00,0x00,0x10,0x00,	/* 2FC8: g..<.... */
	0x2F,0x07,0x2F,0x07,0x2F,0x0D,0x61,0x00,	/* 2FD0: ......a. */
	0xF3,0x70,0x4F,0xEF,0x00,0x0C,0x08,0x2D,	/* 2FD8: pO...- */
	0x00,0x06,0x00,0x30,0x67,0x14,0x2E,0x3C,	/* 2FE0: ...0g..< */
	0x00,0x00,0x20,0x00,0x2F,0x07,0x2F,0x07,	/* 2FE8: .. ..... */
	0x2F,0x0D,0x61,0x00,0xF3,0x54,0x4F,0xEF,	/* 2FF0: ..a.TO */
	0x00,0x0C,0xCC,0xBC,0x00,0x00,0xFF,0xEF,	/* 2FF8: .... */
	0x49,0xED,0x00,0x08,0xCC,0xBC,0x00,0x00,	/* 3000: I.... */
	0xFF,0xFF,0x20,0x06,0xE0,0x80,0x19,0x40,	/* 3008:  ..@ */
	0x00,0x01,0x18,0x86,0x08,0x2D,0x00,0x04,	/* 3010: ....-.. */
	0x00,0x40,0x67,0x00,0xFD,0x16,0x49,0xED,	/* 3018: .@g..I */
	0x00,0x04,0x70,0x00,0x10,0x2C,0x00,0x01,	/* 3020: ..p..,.. */
	0xE1,0x88,0x10,0x14,0x72,0x00,0x32,0x00,	/* 3028: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 3030:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 3038: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x45,0x10,0x2D,	/* 3040: .. E.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 3048: .... */
	0x10,0x80,0x20,0x45,0x10,0x2D,0x00,0x07,	/* 3050: . E.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 3058: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x2F,0x0D,	/* 3060: ....... */
	0x4E,0xB9,0x00,0x00,0x4F,0xA4,0x58,0x8F,	/* 3068: N..OX */
	0x60,0x00,0xFC,0xC0,0x2F,0x0D,0x70,0x00,	/* 3070: `...p. */
	0x2F,0x07,0x7E,0x00,0x2A,0x6F,0x00,0x0C,	/* 3078: ..~.*o.. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 3080: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 3088: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 3090: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 3098: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 30A0:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 30A8: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 30B0: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 30B8: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 30C0: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 30C8: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x20,0x47,	/* 30D0: ..... G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0x10,0x10,	/* 30D8: .... */
	0x08,0x00,0x00,0x07,0x67,0x0C,0x42,0x2D,	/* 30E0: ....g.B- */
	0x00,0x0E,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 30E8: ..p.3.. */
	0x61,0xF4,0x70,0x00,0x2E,0x1F,0x2A,0x5F,	/* 30F0: ap...*_ */
	0x4E,0x75,0x4E,0x71,0x2F,0x0D,0x70,0x00,	/* 30F8: NuNq..p. */
	0x2F,0x07,0x7E,0x00,0x2A,0x6F,0x00,0x0C,	/* 3100: ..~.*o.. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 3108: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 3110: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 3118: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 3120: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 3128:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 3130: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 3138: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 3140: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 3148: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 3150: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x70,0x00,	/* 3158: .....p. */
	0x10,0x2D,0x00,0x35,0x53,0x80,0x67,0x26,	/* 3160: .-.5Sg& */
	0x53,0x80,0x67,0x22,0x53,0x80,0x67,0x02,	/* 3168: Sg"Sg. */
	0x60,0x16,0x70,0x00,0x10,0x2D,0x00,0x0E,	/* 3170: `.p..-.. */
	0x72,0x0C,0xB2,0x80,0x66,0x06,0x70,0x12,	/* 3178: r.f.p. */
	0x1B,0x40,0x00,0x0E,0x70,0x00,0x60,0x46,	/* 3180: .@..p.`F */
	0x70,0x01,0x1B,0x40,0x00,0x35,0x50,0x8D,	/* 3188: p..@.5P */
	0x70,0x00,0x20,0x47,0x10,0x2D,0x00,0x01,	/* 3190: p. G.-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x80,0xBC,	/* 3198: ..r. */
	0x00,0x00,0x00,0x01,0x32,0x00,0x20,0x01,	/* 31A0: ....2. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x22,0x47,	/* 31A8: .@.."G */
	0x1A,0x81,0x22,0x3C,0x04,0x01,0xF0,0x0C,	/* 31B0: ."<... */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 31B8: .. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 31C0: ..... */
	0x00,0x02,0x10,0x80,0x70,0x00,0x2E,0x1F,	/* 31C8: ...p... */
	0x2A,0x5F,0x4E,0x75,0x2F,0x0D,0x2A,0x6F,	/* 31D0: *_Nu..*o */
	0x00,0x08,0x2F,0x0D,0x61,0x00,0xEA,0xCE,	/* 31D8: ....a. */
	0x58,0x8F,0x72,0x00,0x32,0x00,0x4A,0x81,	/* 31E0: Xr.2.J */
	0x66,0x04,0x42,0x2D,0x00,0x0E,0x70,0x00,	/* 31E8: f.B-..p. */
	0x2A,0x5F,0x4E,0x75,0x70,0x00,0x4E,0x75,	/* 31F0: *_Nup.Nu */
	0x70,0x01,0x4E,0x75,0x00,0x82,0x00,0x04,	/* 31F8: p.Nu... */
	0x00,0x16,0x00,0x00,0x00,0x41,0x00,0x00,	/* 3200: .....A.. */
	0x00,0x41,0x00,0x04,0x00,0x82,0x00,0x03,	/* 3208: .A..... */
	0x00,0x41,0x00,0x03,0x00,0x82,0x00,0x02,	/* 3210: .A..... */
	0x00,0x4E,0x00,0x02,0x00,0x41,0x00,0x02,	/* 3218: .N...A.. */
	0x00,0x82,0x00,0x01,0x00,0x57,0x00,0x02,	/* 3220: ....W.. */
	0x00,0x41,0x00,0x01,0x00,0x82,0x00,0x00,	/* 3228: .A..... */
	0x00,0x2B,0x00,0x00,0x00,0xA3,0x00,0x04,	/* 3230: .+..... */
	0x00,0x1B,0x00,0x00,0x00,0x51,0x00,0x00,	/* 3238: .....Q.. */
	0x00,0x51,0x00,0x04,0x00,0xA3,0x00,0x03,	/* 3240: .Q..... */
	0x00,0x51,0x00,0x03,0x00,0xA3,0x00,0x02,	/* 3248: .Q..... */
	0x00,0x62,0x00,0x02,0x00,0x51,0x00,0x02,	/* 3250: .b...Q.. */
	0x00,0xA3,0x00,0x01,0x00,0x6D,0x00,0x02,	/* 3258: ....m.. */
	0x00,0x51,0x00,0x01,0x00,0xA3,0x00,0x00,	/* 3260: .Q..... */
	0x00,0x36,0x00,0x00,0x00,0x36,0x00,0x05,	/* 3268: .6...6.. */
	0x00,0x1B,0x00,0x05,0x00,0x0D,0x00,0x05,	/* 3270: ........ */
	0x00,0xF4,0x00,0x04,0x00,0x6F,0x00,0x04,	/* 3278: ....o.. */
	0x00,0x5B,0x00,0x04,0x00,0xF4,0x00,0x03,	/* 3280: .[..... */
	0x00,0x6D,0x00,0x01,0x00,0x38,0x00,0x00,	/* 3288: .m...8.. */
	0x00,0x31,0x00,0x00,0x00,0x29,0x00,0x00,	/* 3290: .1...).. */
	0x00,0x62,0x00,0x05,0x00,0x53,0x00,0x05,	/* 3298: .b...S.. */
	0x00,0xD9,0x00,0x00,0x00,0x30,0x00,0x05,	/* 32A0: ....0.. */
	0x00,0x6D,0x00,0x00,0x0C,0x20,0x20,0x0C,	/* 32A8: .m...  . */
	0x0C,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 32B0: .        */
	0x20,0x20,0x20,0x20,0x20,0x0C,0x0C,0x0C,	/* 32B8:      ... */
	0x0C,0x00,0x00,0x00,0x4E,0x56,0xFF,0xF0,	/* 32C0: ....NV */
	0x70,0x00,0x4F,0xEF,0xFF,0xD8,0x48,0xD7,	/* 32C8: p.OH */
	0x3C,0xFC,0x26,0x7C,0x00,0x00,0x63,0x44,	/* 32D0: <&|..cD */
	0x24,0x6B,0x00,0x08,0x10,0x13,0x2D,0x40,	/* 32D8: $k....-@ */
	0xFF,0xF4,0x4B,0xEA,0x00,0x06,0x70,0x00,	/* 32E0: K..p. */
	0x7A,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 32E8: z..-.. */
	0x10,0x15,0x3A,0x00,0x20,0x45,0x20,0x2E,	/* 32F0: ..:. E . */
	0xFF,0xF4,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 32F8: .. */
	0xE5,0x88,0x10,0x80,0x20,0x45,0xD1,0xFC,	/* 3300: . E */
	0x04,0x01,0xF0,0xCE,0x10,0x10,0xC0,0xBC,	/* 3308: .... */
	0x00,0x00,0x00,0xFF,0x1D,0x40,0xFF,0xFA,	/* 3310: ....@ */
	0x10,0x2E,0xFF,0xFA,0x08,0x00,0x00,0x00,	/* 3318: ...... */
	0x67,0x00,0x05,0xB2,0x20,0x45,0xD1,0xFC,	/* 3320: g.. E */
	0x04,0x01,0xF0,0xD6,0x10,0x10,0x20,0x45,	/* 3328: .... E */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 3330: .. */
	0x00,0x00,0x00,0xFF,0x1D,0x40,0xFF,0xFB,	/* 3338: ....@ */
	0x10,0x2E,0xFF,0xFB,0xC0,0xBC,0x00,0x00,	/* 3340: .... */
	0x00,0x03,0x10,0x80,0x10,0x2E,0xFF,0xFB,	/* 3348: ..... */
	0x20,0x45,0x22,0x2E,0xFF,0xF4,0xD1,0xFC,	/* 3350:  E". */
	0x04,0x01,0xF0,0x86,0xC0,0xBC,0x00,0x00,	/* 3358: .... */
	0x00,0x03,0xE5,0x89,0xD0,0x81,0x4B,0xF2,	/* 3360: ..K */
	0x0A,0x0A,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 3368: ..p..-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 3370: ..r.2. */
	0x28,0x41,0x10,0x10,0xD9,0xFC,0x01,0x01,	/* 3378: (A.... */
	0x80,0x00,0xC0,0xBC,0x00,0x00,0x00,0x07,	/* 3380: ..... */
	0x57,0x80,0x66,0x00,0x03,0xBC,0x4B,0xEC,	/* 3388: Wf..K */
	0x00,0x08,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 3390: ..p..-.. */
	0xE1,0x88,0x10,0x15,0xC0,0xBC,0x00,0x00,	/* 3398: .... */
	0x00,0x10,0x66,0x00,0x03,0x84,0x4A,0x2C,	/* 33A0: ..f..J, */
	0x00,0x27,0x66,0x06,0x08,0xEC,0x00,0x00,	/* 33A8: .'f.... */
	0x00,0x28,0x1C,0x2C,0x00,0x0A,0x1E,0x2C,	/* 33B0: .(.,..., */
	0x00,0x0B,0x74,0x00,0x20,0x45,0xD1,0xFC,	/* 33B8: ..t. E */
	0x04,0x01,0xF0,0x1C,0x10,0x07,0x12,0x06,	/* 33C0: ....... */
	0x52,0x81,0x90,0x81,0x18,0x10,0x14,0x00,	/* 33C8: R.... */
	0xC8,0xBC,0x00,0x00,0x00,0xFF,0xC8,0xBC,	/* 33D0: ... */
	0x00,0x00,0x00,0xFF,0xB4,0x84,0x6F,0x04,	/* 33D8: ...o. */
	0x26,0x04,0x60,0x02,0x26,0x02,0x98,0x83,	/* 33E0: &.`.&. */
	0x2A,0x45,0xC6,0xBC,0x00,0x00,0x00,0xFF,	/* 33E8: *E... */
	0xDB,0xFC,0x04,0x01,0xF0,0xC4,0x20,0x03,	/* 33F0: .. . */
	0x27,0x4D,0x00,0x04,0xB0,0xBC,0x00,0x00,	/* 33F8: 'M.... */
	0x00,0x20,0x62,0x00,0x02,0x8C,0x20,0x7B,	/* 3400: . b.. { */
	0x0C,0x04,0x4E,0xD0,0x00,0x00,0x36,0x90,	/* 3408: ..N..6 */
	0x00,0x00,0x36,0x80,0x00,0x00,0x36,0x70,	/* 3410: ..6..6p */
	0x00,0x00,0x36,0x60,0x00,0x00,0x36,0x50,	/* 3418: ..6`..6P */
	0x00,0x00,0x36,0x40,0x00,0x00,0x36,0x30,	/* 3420: ..6@..60 */
	0x00,0x00,0x36,0x20,0x00,0x00,0x36,0x10,	/* 3428: ..6 ..6. */
	0x00,0x00,0x36,0x00,0x00,0x00,0x35,0xF0,	/* 3430: ..6...5 */
	0x00,0x00,0x35,0xE0,0x00,0x00,0x35,0xD0,	/* 3438: ..5..5 */
	0x00,0x00,0x35,0xC0,0x00,0x00,0x35,0xB0,	/* 3440: ..5..5 */
	0x00,0x00,0x35,0xA0,0x00,0x00,0x35,0x90,	/* 3448: ..5..5 */
	0x00,0x00,0x35,0x80,0x00,0x00,0x35,0x70,	/* 3450: ..5..5p */
	0x00,0x00,0x35,0x60,0x00,0x00,0x35,0x50,	/* 3458: ..5`..5P */
	0x00,0x00,0x35,0x40,0x00,0x00,0x35,0x30,	/* 3460: ..5@..50 */
	0x00,0x00,0x35,0x20,0x00,0x00,0x35,0x10,	/* 3468: ..5 ..5. */
	0x00,0x00,0x35,0x00,0x00,0x00,0x34,0xF0,	/* 3470: ..5...4 */
	0x00,0x00,0x34,0xE0,0x00,0x00,0x34,0xD0,	/* 3478: ..4..4 */
	0x00,0x00,0x34,0xC0,0x00,0x00,0x34,0xB0,	/* 3480: ..4..4 */
	0x00,0x00,0x34,0xA0,0x00,0x00,0x34,0x90,	/* 3488: ..4..4 */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3490:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3498: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 34A0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 34A8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 34B0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 34B8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 34C0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 34C8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 34D0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 34D8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 34E0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 34E8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 34F0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 34F8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3500:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3508: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3510:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3518: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3520:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3528: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3530:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3538: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3540:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3548: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3550:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3558: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3560:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3568: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3570:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3578: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3580:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3588: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3590:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3598: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 35A0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 35A8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 35B0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 35B8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 35C0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 35C8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 35D0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 35D8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 35E0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 35E8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 35F0:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 35F8: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3600:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3608: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3610:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3618: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3620:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3628: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3630:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3638: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3640:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3648: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3650:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3658: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3660:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3668: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3670:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3678: .U.`R */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 3680:  L... */
	0xD1,0xC6,0x11,0x55,0x01,0x60,0x52,0x86,	/* 3688: .U.`R */
	0x19,0x46,0x00,0x0A,0x4B,0xEC,0x00,0x3E,	/* 3690: .F..K.> */
	0x70,0x00,0xC8,0xBC,0x00,0x00,0x00,0xFF,	/* 3698: p.... */
	0x76,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 36A0: v..-.. */
	0x10,0x15,0xD0,0x84,0x36,0x00,0x20,0x03,	/* 36A8: ..6. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x83,	/* 36B0: .@... */
	0x4A,0x04,0x67,0x16,0x26,0x3C,0x04,0x01,	/* 36B8: J.g.&<.. */
	0xF0,0xC4,0xD8,0xBC,0x00,0x00,0x00,0xFF,	/* 36C0: ... */
	0x20,0x45,0xD1,0xC3,0x10,0x10,0x4A,0x04,	/* 36C8:  E..J. */
	0x66,0xF0,0xD8,0xBC,0x00,0x00,0x00,0xFF,	/* 36D0: f... */
	0x12,0x06,0x4B,0xEC,0x00,0x08,0x70,0x00,	/* 36D8: ..K..p. */
	0x52,0x81,0x9E,0x81,0x10,0x2D,0x00,0x01,	/* 36E0: R.-.. */
	0xE1,0x88,0x10,0x15,0xC0,0xBC,0x00,0x00,	/* 36E8: .... */
	0x00,0x08,0x67,0x34,0x70,0x20,0xB0,0x82,	/* 36F0: ..g4p  */
	0x6E,0x2E,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 36F8: n.... */
	0x70,0x20,0xB0,0x87,0x6F,0x22,0x4B,0xEC,	/* 3700: p o"K */
	0x00,0x08,0x70,0x00,0x7E,0x00,0x10,0x2D,	/* 3708: ..p.~..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x80,0xBC,	/* 3710: .... */
	0x00,0x00,0x00,0x10,0x3E,0x00,0x20,0x07,	/* 3718: ....>. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x87,	/* 3720: .@... */
	0x70,0x01,0x20,0x45,0x33,0xC0,0x00,0x00,	/* 3728: p. E3.. */
	0x61,0xF6,0xD1,0xFC,0x04,0x01,0xF0,0xD6,	/* 3730: a.. */
	0x10,0x2E,0xFF,0xFB,0xC0,0xBC,0x00,0x00,	/* 3738: .... */
	0x00,0x3F,0x10,0x80,0x60,0x00,0x01,0x8E,	/* 3740: .?.`.. */
	0x7C,0x00,0x2E,0x3C,0x04,0x01,0xF0,0xC4,	/* 3748: |..<.. */
	0x20,0x45,0xD1,0xC7,0x14,0x10,0x20,0x45,	/* 3750:  E.. E */
	0xD1,0xC7,0xC4,0xBC,0x00,0x00,0x00,0xFF,	/* 3758: ... */
	0x1E,0x10,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3760: ..... */
	0x08,0x02,0x00,0x03,0x67,0x0E,0x08,0xEC,	/* 3768: ....g.. */
	0x00,0x00,0x00,0x19,0x70,0x01,0x33,0xC0,	/* 3770: ....p.3 */
	0x00,0x00,0x61,0xF4,0xC4,0xBC,0x00,0x00,	/* 3778: ..a.. */
	0x00,0xFF,0x70,0x07,0xC0,0x82,0x67,0x10,	/* 3780: .p.g. */
	0x08,0x2C,0x00,0x07,0x00,0x20,0x67,0x08,	/* 3788: .,... g. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x61,0xF4,	/* 3790: p.3..a */
	0x08,0x02,0x00,0x00,0x67,0x1E,0x4B,0xEC,	/* 3798: ....g.K */
	0x00,0x3C,0x70,0x00,0x76,0x00,0x10,0x2D,	/* 37A0: .<p.v..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x52,0x80,	/* 37A8: ....R */
	0x36,0x00,0x20,0x03,0xE0,0x80,0x1B,0x40,	/* 37B0: 6. ..@ */
	0x00,0x01,0x1A,0x83,0x08,0x02,0x00,0x01,	/* 37B8: ....... */
	0x67,0x20,0x4B,0xEC,0x00,0x38,0x70,0x00,	/* 37C0: g K.8p. */
	0x7C,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 37C8: |..-.. */
	0x10,0x15,0x52,0x80,0x3C,0x00,0x20,0x06,	/* 37D0: ..R<. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x86,	/* 37D8: .@... */
	0x7C,0x01,0x08,0x02,0x00,0x02,0x67,0x20,	/* 37E0: |.....g  */
	0x4B,0xEC,0x00,0x3A,0x70,0x00,0x74,0x00,	/* 37E8: K.:p.t. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 37F0: .-.... */
	0x52,0x80,0x34,0x00,0x20,0x02,0xE0,0x80,	/* 37F8: R4. . */
	0x1B,0x40,0x00,0x01,0x1A,0x82,0x7C,0x01,	/* 3800: .@...|. */
	0x4A,0x86,0x67,0x00,0x00,0xB4,0x08,0x2C,	/* 3808: Jg..., */
	0x00,0x06,0x00,0x20,0x67,0x04,0x1E,0x2C,	/* 3810: ... g.., */
	0x00,0x2B,0x1C,0x2C,0x00,0x0A,0x16,0x2C,	/* 3818: .+.,..., */
	0x00,0x0B,0x74,0x00,0x10,0x03,0x12,0x06,	/* 3820: ..t..... */
	0x52,0x81,0x90,0x81,0x14,0x00,0x4A,0x82,	/* 3828: R..J */
	0x67,0x00,0x00,0x6A,0x20,0x4C,0xCC,0xBC,	/* 3830: g..j L */
	0x00,0x00,0x00,0xFF,0x4B,0xEC,0x00,0x08,	/* 3838: ...K.. */
	0x70,0x00,0xD1,0xC6,0x11,0x47,0x01,0x60,	/* 3840: p..G.` */
	0x52,0x86,0x19,0x46,0x00,0x0A,0x1E,0x03,	/* 3848: R.F.... */
	0x12,0x06,0x52,0x81,0x10,0x2D,0x00,0x01,	/* 3850: ..R.-.. */
	0x9E,0x81,0xE1,0x88,0x10,0x15,0xC0,0xBC,	/* 3858: .. */
	0x00,0x00,0x00,0x08,0x67,0x5A,0x70,0x20,	/* 3860: ....gZp  */
	0xB0,0x82,0x6E,0x54,0xCE,0xBC,0x00,0x00,	/* 3868: nT.. */
	0x00,0xFF,0x70,0x20,0xB0,0x87,0x6F,0x48,	/* 3870: .p oH */
	0x4B,0xEC,0x00,0x08,0x70,0x00,0x7E,0x00,	/* 3878: K..p.~. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 3880: .-.... */
	0x80,0xBC,0x00,0x00,0x00,0x10,0x3E,0x00,	/* 3888: ....>. */
	0x20,0x07,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 3890:  ..@.. */
	0x1A,0x87,0x60,0x24,0x4B,0xEC,0x00,0x3E,	/* 3898: .`$K.> */
	0x70,0x00,0xC8,0xBC,0x00,0x00,0x00,0xFF,	/* 38A0: p.... */
	0x7E,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 38A8: ~..-.. */
	0x10,0x15,0xD0,0x84,0x3E,0x00,0x20,0x07,	/* 38B0: ..>. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x87,	/* 38B8: .@... */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xD6,	/* 38C0:  E.. */
	0x10,0x2E,0xFF,0xFB,0xC0,0xBC,0x00,0x00,	/* 38C8: .... */
	0x00,0x3F,0x10,0x80,0x10,0x2E,0xFF,0xFA,	/* 38D0: .?... */
	0x08,0x00,0x00,0x01,0x67,0x00,0x04,0xFA,	/* 38D8: ....g.. */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xD4,	/* 38E0:  E.. */
	0x10,0x10,0x20,0x45,0xD1,0xFC,0x04,0x01,	/* 38E8: .. E.. */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 38F0: ... */
	0x1D,0x40,0xFF,0xFB,0x10,0x2E,0xFF,0xFB,	/* 38F8: .@.. */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 3900: ..... */
	0x10,0x2E,0xFF,0xFB,0x22,0x2E,0xFF,0xF4,	/* 3908: ..". */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0xE5,0x89,	/* 3910: .... */
	0xD0,0x81,0x4B,0xF2,0x0A,0x0A,0x70,0x00,	/* 3918: K..p. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 3920: .-.... */
	0x72,0x00,0x32,0x00,0x28,0x41,0xD9,0xFC,	/* 3928: r.2.(A */
	0x01,0x01,0x80,0x00,0x4A,0x2C,0x00,0x27,	/* 3930: ...J,.' */
	0x66,0x06,0x08,0xEC,0x00,0x01,0x00,0x28,	/* 3938: f.....( */
	0x4A,0x2C,0x00,0x35,0x67,0x0E,0x2F,0x0C,	/* 3940: J,.5g... */
	0x4E,0xB9,0x00,0x00,0x4D,0xEC,0x58,0x8F,	/* 3948: N..MX */
	0x60,0x00,0x04,0x72,0x14,0x2C,0x00,0x0D,	/* 3950: `..r.,.. */
	0x1E,0x2C,0x00,0x0C,0x4B,0xEC,0x00,0x08,	/* 3958: .,..K.. */
	0x70,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 3960: p..-.. */
	0x10,0x15,0xC0,0xBC,0x00,0x00,0x01,0x00,	/* 3968: ...... */
	0x67,0x6E,0x4B,0xEC,0x00,0x08,0x7C,0x00,	/* 3970: gnK..|. */
	0x1C,0x2D,0x00,0x01,0xE1,0x8E,0x1C,0x15,	/* 3978: .-.... */
	0xCC,0xBC,0x00,0x00,0xFE,0xFF,0x20,0x06,	/* 3980: .. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x86,	/* 3988: .@... */
	0x70,0x00,0x10,0x2D,0x00,0x01,0x7C,0x00,	/* 3990: p..-..|. */
	0xE1,0x88,0x10,0x15,0x80,0xBC,0x00,0x00,	/* 3998: .... */
	0x02,0x00,0x3C,0x00,0x20,0x06,0xE0,0x80,	/* 39A0: ..<. . */
	0x1B,0x40,0x00,0x01,0x20,0x45,0x1A,0x86,	/* 39A8: .@.. E. */
	0x7C,0x00,0x1C,0x2D,0x00,0x01,0xE1,0x8E,	/* 39B0: |..-.. */
	0x1C,0x15,0xCC,0xBC,0x00,0x00,0xFF,0xFE,	/* 39B8: .... */
	0x20,0x06,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 39C0:  ..@.. */
	0x22,0x45,0x1A,0x86,0x2C,0x3C,0x04,0x01,	/* 39C8: "E.,<.. */
	0xF0,0x0C,0xD1,0xC6,0xD3,0xC6,0x10,0x11,	/* 39D0: ... */
	0xC0,0xBC,0x00,0x00,0x00,0xF9,0x10,0x80,	/* 39D8: .... */
	0x10,0x02,0x7C,0x00,0x76,0x00,0x90,0x87,	/* 39E0: ..|.v. */
	0x16,0x2C,0x00,0x2A,0x1C,0x00,0xBC,0x83,	/* 39E8: .,.*.. */
	0x6F,0x02,0x60,0x04,0x76,0x00,0x16,0x06,	/* 39F0: o.`.v... */
	0x4A,0x83,0x66,0x18,0x20,0x45,0xD1,0xFC,	/* 39F8: Jf. E */
	0x04,0x01,0xF0,0x0C,0x10,0x10,0x08,0x00,	/* 3A00: ....... */
	0x00,0x02,0x67,0x08,0x70,0x02,0x19,0x40,	/* 3A08: ..g.p..@ */
	0x00,0x44,0x60,0x04,0x19,0x43,0x00,0x44,	/* 3A10: .D`..C.D */
	0x2A,0x45,0xDB,0xFC,0x04,0x01,0xF0,0xC6,	/* 3A18: *E.. */
	0x27,0x4D,0x00,0x04,0x20,0x03,0xB0,0xBC,	/* 3A20: 'M.. . */
	0x00,0x00,0x00,0x20,0x62,0x00,0x02,0x88,	/* 3A28: ... b.. */
	0x20,0x7B,0x0C,0x04,0x4E,0xD0,0x00,0x00,	/* 3A30:  {..N.. */
	0x3C,0xB6,0x00,0x00,0x3C,0xA6,0x00,0x00,	/* 3A38: <..<.. */
	0x3C,0x96,0x00,0x00,0x3C,0x86,0x00,0x00,	/* 3A40: <..<.. */
	0x3C,0x76,0x00,0x00,0x3C,0x66,0x00,0x00,	/* 3A48: <v..<f.. */
	0x3C,0x56,0x00,0x00,0x3C,0x46,0x00,0x00,	/* 3A50: <V..<F.. */
	0x3C,0x36,0x00,0x00,0x3C,0x26,0x00,0x00,	/* 3A58: <6..<&.. */
	0x3C,0x16,0x00,0x00,0x3C,0x06,0x00,0x00,	/* 3A60: <...<... */
	0x3B,0xF6,0x00,0x00,0x3B,0xE6,0x00,0x00,	/* 3A68: ;..;.. */
	0x3B,0xD6,0x00,0x00,0x3B,0xC6,0x00,0x00,	/* 3A70: ;..;.. */
	0x3B,0xB6,0x00,0x00,0x3B,0xA6,0x00,0x00,	/* 3A78: ;..;.. */
	0x3B,0x96,0x00,0x00,0x3B,0x86,0x00,0x00,	/* 3A80: ;..;.. */
	0x3B,0x76,0x00,0x00,0x3B,0x66,0x00,0x00,	/* 3A88: ;v..;f.. */
	0x3B,0x56,0x00,0x00,0x3B,0x46,0x00,0x00,	/* 3A90: ;V..;F.. */
	0x3B,0x36,0x00,0x00,0x3B,0x26,0x00,0x00,	/* 3A98: ;6..;&.. */
	0x3B,0x16,0x00,0x00,0x3B,0x06,0x00,0x00,	/* 3AA0: ;...;... */
	0x3A,0xF6,0x00,0x00,0x3A,0xE6,0x00,0x00,	/* 3AA8: :..:.. */
	0x3A,0xD6,0x00,0x00,0x3A,0xC6,0x00,0x00,	/* 3AB0: :..:.. */
	0x3A,0xBA,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3AB8: :... */
	0x1A,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3AC0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3AC8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3AD0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3AD8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3AE0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3AE8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3AF0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3AF8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B00: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B08: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B10: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B18: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B20: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B28: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B30: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B38: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B40: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B48: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B50: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B58: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B60: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B68: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B70: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B78: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B80: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B88: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3B90: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3B98: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3BA0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3BA8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3BB0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3BB8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3BC0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3BC8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3BD0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3BD8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3BE0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3BE8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3BF0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3BF8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C00: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C08: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C10: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C18: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C20: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C28: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C30: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C38: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C40: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C48: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C50: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C58: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C60: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C68: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C70: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C78: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C80: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C88: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3C90: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3C98: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x20,0x6B,	/* 3CA0: .x`R k */
	0x00,0x04,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 3CA8: ..... */
	0x10,0xB4,0x78,0x60,0x52,0x87,0x10,0x02,	/* 3CB0: .x`R.. */
	0x74,0x00,0x19,0x47,0x00,0x0C,0x90,0x87,	/* 3CB8: t..G.. */
	0x14,0x00,0x2E,0x3C,0x00,0x00,0x00,0xC0,	/* 3CC0: ...<... */
	0xBC,0x87,0x6F,0x28,0xB4,0x87,0x6E,0x2A,	/* 3CC8: o(n* */
	0x4B,0xEC,0x00,0x08,0x70,0x00,0x7E,0x00,	/* 3CD0: K..p.~. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 3CD8: .-.... */
	0x80,0xBC,0x00,0x00,0x08,0x00,0x3E,0x00,	/* 3CE0: ....>. */
	0x20,0x07,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 3CE8:  ..@.. */
	0x1A,0x87,0x60,0x48,0x70,0x40,0xB0,0x86,	/* 3CF0: .`Hp@ */
	0x6C,0x42,0x70,0x40,0xB0,0x82,0x6D,0x3C,	/* 3CF8: lBp@m< */
	0x4B,0xEC,0x00,0x08,0x70,0x00,0x10,0x2D,	/* 3D00: K..p..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0xC0,0xBC,	/* 3D08: .... */
	0x00,0x00,0x08,0x00,0x67,0x26,0x4B,0xEC,	/* 3D10: ....g&K */
	0x00,0x08,0x7E,0x00,0x1E,0x2D,0x00,0x01,	/* 3D18: ..~..-.. */
	0xE1,0x8F,0x1E,0x15,0xCE,0xBC,0x00,0x00,	/* 3D20: .... */
	0xF7,0xFF,0x20,0x07,0xE0,0x80,0x1B,0x40,	/* 3D28:  ..@ */
	0x00,0x01,0x1A,0x87,0x70,0x01,0x33,0xC0,	/* 3D30: ...p.3 */
	0x00,0x00,0x61,0xF4,0x4A,0x82,0x66,0x00,	/* 3D38: ..aJf. */
	0x00,0x7E,0x24,0x3C,0x04,0x01,0xF0,0x0C,	/* 3D40: .~$<... */
	0x20,0x45,0xD1,0xC2,0x10,0x10,0x08,0x00,	/* 3D48:  E.... */
	0x00,0x02,0x67,0x1A,0x20,0x45,0x22,0x45,	/* 3D50: ..g. E"E */
	0xD1,0xC2,0xD3,0xC2,0x10,0x11,0xC0,0xBC,	/* 3D58: .. */
	0x00,0x00,0x00,0xFB,0x80,0xBC,0x00,0x00,	/* 3D60: ..... */
	0x00,0x02,0x10,0x80,0x60,0x56,0x4B,0xEC,	/* 3D68: ...`VK */
	0x00,0x08,0x7E,0x00,0x20,0x45,0x22,0x45,	/* 3D70: ..~. E"E */
	0xD1,0xC2,0x1E,0x2D,0x00,0x01,0xE1,0x8F,	/* 3D78: .-.. */
	0x1E,0x15,0xCE,0xBC,0x00,0x00,0xFF,0xFE,	/* 3D80: .... */
	0x20,0x07,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 3D88:  ..@.. */
	0xD3,0xC2,0x1A,0x87,0x10,0x11,0xC0,0xBC,	/* 3D90: ... */
	0x00,0x00,0x00,0xF9,0x10,0x80,0x1E,0x2C,	/* 3D98: ....., */
	0x00,0x41,0x08,0x07,0x00,0x00,0x67,0x1C,	/* 3DA0: .A....g. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x61,0xF4,	/* 3DA8: p.3..a */
	0x10,0x07,0xC0,0xBC,0x00,0x00,0x00,0xFE,	/* 3DB0: ..... */
	0x19,0x40,0x00,0x41,0x60,0x06,0x08,0xEC,	/* 3DB8: .@.A`.. */
	0x00,0x00,0x00,0x41,0x20,0x45,0xD1,0xFC,	/* 3DC0: ...A E */
	0x04,0x01,0xF0,0xD4,0x10,0x2E,0xFF,0xFB,	/* 3DC8: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x3F,0x10,0x80,	/* 3DD0: ...?. */
	0x10,0x2E,0xFF,0xFA,0x08,0x00,0x00,0x02,	/* 3DD8: ...... */
	0x67,0x00,0x00,0x94,0x2A,0x7C,0x04,0x01,	/* 3DE0: g..*|.. */
	0xF0,0xD2,0x20,0x45,0xD1,0xCD,0x10,0x10,	/* 3DE8:  E.. */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 3DF0:  E.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x1D,0x40,	/* 3DF8: ....@ */
	0xFF,0xFB,0x10,0x2E,0xFF,0xFB,0xC0,0xBC,	/* 3E00: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x10,0x2E,	/* 3E08: ....... */
	0xFF,0xFB,0x22,0x2E,0xFF,0xF4,0xC0,0xBC,	/* 3E10: ". */
	0x00,0x00,0x00,0x03,0xE5,0x89,0xD0,0x81,	/* 3E18: .... */
	0x49,0xF2,0x0A,0x0A,0x70,0x00,0x10,0x2C,	/* 3E20: I..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 3E28: ....r. */
	0x32,0x00,0x28,0x41,0xD9,0xFC,0x01,0x01,	/* 3E30: 2.(A.. */
	0x80,0x00,0x2F,0x0C,0x4E,0xB9,0x00,0x00,	/* 3E38: ...N.. */
	0x4F,0xA4,0x2F,0x0C,0x4E,0xB9,0x00,0x00,	/* 3E40: O..N.. */
	0x2A,0xF8,0x50,0x8F,0x4A,0x2C,0x00,0x27,	/* 3E48: *PJ,.' */
	0x66,0x06,0x08,0xEC,0x00,0x02,0x00,0x28,	/* 3E50: f.....( */
	0x70,0x01,0x20,0x45,0x33,0xC0,0x00,0x00,	/* 3E58: p. E3.. */
	0x61,0xF4,0xD1,0xCD,0x08,0xEC,0x00,0x01,	/* 3E60: a... */
	0x00,0x19,0x10,0x2E,0xFF,0xFB,0xC0,0xBC,	/* 3E68: .... */
	0x00,0x00,0x00,0x3F,0x10,0x80,0x20,0x2E,	/* 3E70: ...?. . */
	0xFF,0xF4,0x72,0x00,0x52,0x80,0x12,0x00,	/* 3E78: r.R.. */
	0x2D,0x41,0xFF,0xF4,0x20,0x2E,0xFF,0xF4,	/* 3E80: -A . */
	0x55,0x80,0x6D,0x30,0x70,0x00,0x7A,0x00,	/* 3E88: Um0p.z. */
	0x2D,0x40,0xFF,0xF4,0x70,0x00,0x10,0x2A,	/* 3E90: -@p..* */
	0x00,0x01,0xE1,0x88,0x10,0x12,0x3A,0x00,	/* 3E98: ....:. */
	0x4A,0x85,0x67,0x12,0x20,0x3C,0xFF,0xFF,	/* 3EA0: Jg. < */
	0x7F,0xFF,0xC0,0x85,0x24,0x40,0xD5,0xFC,	/* 3EA8: $@ */
	0x01,0x01,0x80,0x00,0x60,0x06,0x24,0x7C,	/* 3EB0: ...`.$| */
	0x01,0x01,0x80,0x80,0x4A,0x2E,0xFF,0xFA,	/* 3EB8: ..J. */
	0x66,0x14,0xB5,0xEB,0x00,0x08,0x66,0x00,	/* 3EC0: f...f. */
	0xF4,0x1A,0x70,0x00,0x10,0x13,0xB0,0xAE,	/* 3EC8: .p... */
	0xFF,0xF4,0x66,0x00,0xF4,0x0E,0x27,0x4A,	/* 3ED0: f..'J */
	0x00,0x08,0x20,0x2E,0xFF,0xF4,0x16,0x80,	/* 3ED8: .. .. */
	0x4C,0xD7,0x3C,0xFC,0x4F,0xEF,0x00,0x28,	/* 3EE0: L<O.( */
	0x4E,0x5E,0x4E,0x75,0x4F,0xEF,0xFF,0xF0,	/* 3EE8: N^NuO */
	0x48,0xD7,0x38,0x80,0x2A,0x7C,0x01,0x01,	/* 3EF0: H8*|.. */
	0x81,0x80,0x26,0x7C,0x00,0x00,0x63,0xD0,	/* 3EF8: &|..c */
	0x28,0x7C,0x00,0x00,0x61,0xEC,0x4A,0x14,	/* 3F00: (|..aJ. */
	0x67,0x06,0x4E,0xB9,0x00,0x00,0x0E,0x60,	/* 3F08: g.N...` */
	0x20,0x53,0x10,0x28,0x00,0x07,0x52,0x80,	/* 3F10:  S.(..R */
	0x11,0x40,0x00,0x07,0x61,0x00,0xF3,0xA6,	/* 3F18: .@..a. */
	0x70,0x00,0x10,0x2D,0x00,0x0E,0x7E,0x00,	/* 3F20: p..-..~. */
	0x3E,0x00,0x4A,0x87,0x67,0x1A,0x20,0x7C,	/* 3F28: >.Jg. | */
	0x00,0x00,0x62,0xA8,0x20,0x70,0x7C,0x00,	/* 3F30: ..b p|. */
	0x2F,0x0D,0x4E,0x90,0x58,0x8F,0x72,0x00,	/* 3F38: ..NXr. */
	0x32,0x00,0x4A,0x81,0x67,0x00,0x01,0x6C,	/* 3F40: 2.Jg..l */
	0x43,0xED,0x00,0x02,0x70,0x00,0x7E,0x00,	/* 3F48: C..p.~. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 3F50: .).... */
	0x43,0xED,0x00,0x08,0x3E,0x00,0x70,0x00,	/* 3F58: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 3F60: .).... */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x66,0x00,	/* 3F68: ....f. */
	0x00,0xA0,0x10,0x2D,0x00,0x0D,0x12,0x2D,	/* 3F70: ..-...- */
	0x00,0x0C,0x90,0x81,0x4A,0x00,0x67,0x00,	/* 3F78: ..J.g. */
	0x00,0x90,0x43,0xED,0x00,0x08,0x70,0x00,	/* 3F80: .C..p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 3F88: .).... */
	0x80,0xBC,0x00,0x00,0x00,0x01,0x72,0x00,	/* 3F90: ....r. */
	0x32,0x00,0x20,0x01,0xE0,0x80,0x13,0x40,	/* 3F98: 2. ..@ */
	0x00,0x01,0x12,0x81,0x43,0xED,0x00,0x04,	/* 3FA0: ...C.. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 3FA8: p..).. */
	0x10,0x11,0x72,0x00,0x32,0x00,0xC2,0xBC,	/* 3FB0: ..r.2. */
	0xFF,0xFF,0x7F,0xFF,0x20,0x41,0xD1,0xFC,	/* 3FB8:  A */
	0x01,0x01,0x80,0x09,0x10,0x2D,0x00,0x07,	/* 3FC0: ....-.. */
	0x10,0x80,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 3FC8: . G.. */
	0xF0,0xFE,0x10,0x2D,0x00,0x07,0x10,0x80,	/* 3FD0: .-... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 3FD8:  G.. */
	0x10,0x2D,0x00,0x07,0xC0,0xBC,0x00,0x00,	/* 3FE0: .-.... */
	0x00,0x03,0x10,0x80,0x22,0x3C,0x04,0x01,	/* 3FE8: ..."<.. */
	0xF0,0x0C,0x20,0x47,0xD1,0xC1,0x22,0x47,	/* 3FF0: . G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 3FF8: .... */
	0x00,0xFF,0x80,0xBC,0x00,0x00,0x00,0x04,	/* 4000: ..... */
	0x10,0x80,0x70,0x01,0x1B,0x40,0x00,0x29,	/* 4008: .p..@.) */
	0x43,0xED,0x00,0x08,0x70,0x00,0x10,0x29,	/* 4010: C..p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0xC0,0xBC,	/* 4018: .... */
	0x00,0x00,0x00,0x10,0x67,0x32,0x10,0x2D,	/* 4020: ....g2.- */
	0x00,0x0A,0x12,0x2D,0x00,0x0B,0x90,0x81,	/* 4028: ...-.. */
	0x72,0x00,0x12,0x00,0x70,0x20,0xB0,0x81,	/* 4030: r...p  */
	0x6F,0x1E,0x43,0xED,0x00,0x08,0x72,0x00,	/* 4038: o.C..r. */
	0x12,0x29,0x00,0x01,0xE1,0x89,0x12,0x11,	/* 4040: .).... */
	0xC2,0xBC,0x00,0x00,0xFF,0xEF,0x20,0x01,	/* 4048: .. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x81,	/* 4050: .@... */
	0x08,0x2D,0x00,0x04,0x00,0x40,0x67,0x52,	/* 4058: .-...@gR */
	0x43,0xED,0x00,0x04,0x70,0x00,0x10,0x29,	/* 4060: C..p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x72,0x00,	/* 4068: ....r. */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 4070: 2. */
	0x20,0x41,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 4078:  A.-.. */
	0x01,0x01,0x80,0x09,0x10,0x80,0x20,0x47,	/* 4080: .... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 4088: .-.... */
	0xF0,0xFE,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 4090: . G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 4098: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 40A0: ..... */
	0x2F,0x0D,0x4E,0xB9,0x00,0x00,0x4F,0xA4,	/* 40A8: ..N..O */
	0x58,0x8F,0x43,0xED,0x00,0x2E,0x70,0x00,	/* 40B0: XC..p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 40B8: .).... */
	0x72,0x00,0x32,0x00,0x2A,0x41,0xDB,0xFC,	/* 40C0: r.2.*A */
	0x01,0x01,0x80,0x00,0x60,0x00,0xFE,0x38,	/* 40C8: ...`.8 */
	0x4F,0xEF,0xFF,0xF0,0x48,0xD7,0x03,0x03,	/* 40D0: OH.. */
	0x4E,0xB9,0x00,0x00,0x50,0x50,0x42,0x39,	/* 40D8: N..PPB9 */
	0x03,0x01,0xF8,0x00,0x4C,0xD7,0x03,0x03,	/* 40E0: ...L.. */
	0x4F,0xEF,0x00,0x10,0x4E,0x73,0x00,0x00,	/* 40E8: O..Ns.. */
	0x30,0x45,0x4E,0x71,0x43,0x6F,0x70,0x79,	/* 40F0: 0ENqCopy */
	0x72,0x69,0x67,0x68,0x74,0x20,0x28,0x63,	/* 40F8: right (c */
	0x29,0x20,0x50,0x65,0x72,0x6C,0x65,0x20,	/* 4100: ) Perle  */
	0x53,0x79,0x73,0x74,0x65,0x6D,0x73,0x20,	/* 4108: Systems  */
	0x4C,0x74,0x64,0x20,0x31,0x39,0x39,0x36,	/* 4110: Ltd 1996 */
	0x2D,0x32,0x30,0x30,0x30,0x2E,0x0D,0x0A,	/* 4118: -2000... */
	0x4A,0x45,0x54,0x43,0x46,0x2E,0x42,0x49,	/* 4120: JETCF.BI */
	0x4E,0x20,0x56,0x65,0x72,0x73,0x69,0x6F,	/* 4128: N Versio */
	0x6E,0x20,0x34,0x2E,0x30,0x2E,0x34,0x20,	/* 4130: n 4.0.4  */
	0x43,0x72,0x65,0x61,0x74,0x65,0x64,0x20,	/* 4138: Created  */
	0x53,0x65,0x70,0x20,0x31,0x38,0x20,0x32,	/* 4140: Sep 18 2 */
	0x30,0x30,0x30,0x20,0x40,0x20,0x31,0x34,	/* 4148: 000 @ 14 */
	0x3A,0x35,0x36,0x3A,0x31,0x31,0x00,0x00,	/* 4150: :56:11.. */
	0x20,0x6F,0x00,0x04,0x70,0x00,0x54,0x88,	/* 4158:  o..p.T */
	0x10,0x28,0x00,0x01,0xE1,0x88,0x10,0x10,	/* 4160: .(.... */
	0x72,0x00,0x32,0x00,0x20,0x01,0xC0,0xBC,	/* 4168: r.2. . */
	0x00,0x00,0x00,0x10,0x67,0x1E,0x20,0x01,	/* 4170: ....g. . */
	0xC0,0xBC,0xFF,0xFF,0xFF,0xEF,0x20,0x40,	/* 4178:  @ */
	0xD1,0xFC,0x04,0x01,0xF0,0x1A,0x10,0x10,	/* 4180: ..... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x46,0x80,	/* 4188: ...F */
	0xE2,0x80,0x4E,0x75,0x20,0x01,0xC0,0xBC,	/* 4190: Nu . */
	0xFF,0xFF,0xFF,0xEF,0x20,0x40,0xD1,0xFC,	/* 4198:  @ */
	0x04,0x01,0xF0,0x1A,0x10,0x10,0xC0,0xBC,	/* 41A0: ..... */
	0x00,0x00,0x00,0xFF,0x46,0x80,0xD0,0x80,	/* 41A8: ...F */
	0x4E,0x75,0x4E,0x71,0x2F,0x07,0x7E,0x00,	/* 41B0: NuNq..~. */
	0x70,0x00,0x72,0x00,0x20,0x6F,0x00,0x08,	/* 41B8: p.r. o.. */
	0x43,0xE8,0x00,0x02,0x1E,0x29,0x00,0x01,	/* 41C0: C...).. */
	0xE1,0x8F,0x1E,0x11,0x43,0xE8,0x00,0x04,	/* 41C8: ..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 41D0: .).... */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 41D8: 2. */
	0x70,0x00,0x22,0x41,0x30,0x2F,0x00,0x0E,	/* 41E0: p."A0... */
	0xD3,0xFC,0x01,0x01,0x80,0x00,0x53,0x80,	/* 41E8: ...S */
	0x66,0x10,0x10,0x28,0x00,0x0F,0x12,0x29,	/* 41F0: f..(...) */
	0x00,0x04,0x82,0x80,0x13,0x41,0x00,0x04,	/* 41F8: ...A.. */
	0x60,0x10,0x10,0x28,0x00,0x0F,0x46,0x80,	/* 4200: `..(..F */
	0x12,0x29,0x00,0x04,0xC2,0x80,0x13,0x41,	/* 4208: .)...A */
	0x00,0x04,0x30,0x07,0x2E,0x1F,0xC0,0xBC,	/* 4210: ..0... */
	0x00,0x00,0xFF,0x00,0x80,0xBC,0x00,0x00,	/* 4218: ..... */
	0x00,0x80,0x20,0x40,0xD1,0xFC,0x04,0x01,	/* 4220: . @.. */
	0xF0,0x00,0x10,0x29,0x00,0x04,0x46,0x80,	/* 4228: ..)..F */
	0x10,0x80,0x4E,0x75,0x4E,0x56,0xFF,0xF0,	/* 4230: .NuNV */
	0x70,0x00,0x4F,0xEF,0xFF,0xDC,0x48,0xD7,	/* 4238: p.OH */
	0x38,0xFC,0x2A,0x6E,0x00,0x08,0x36,0x2E,	/* 4240: 8*n..6. */
	0x00,0x0E,0x26,0x6E,0x00,0x10,0x7E,0x00,	/* 4248: ..&n..~. */
	0x74,0x00,0x49,0xED,0x00,0x02,0x10,0x2C,	/* 4250: t.I..., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 4258: ....r. */
	0x32,0x00,0x22,0x41,0x1E,0x2D,0x00,0x0A,	/* 4260: 2."A.-.. */
	0x1D,0x6D,0x00,0x0B,0xFF,0xF6,0x12,0x2E,	/* 4268: .m.... */
	0xFF,0xF6,0x20,0x07,0x90,0x81,0x1D,0x40,	/* 4270:  ..@ */
	0xFF,0xF7,0x38,0x13,0x14,0x2D,0x00,0x21,	/* 4278: 8..-.! */
	0x7C,0x00,0x28,0x7C,0x04,0x01,0xF0,0x04,	/* 4280: |.(|... */
	0x20,0x49,0x70,0x40,0x7A,0x00,0xD1,0xCC,	/* 4288:  Ip@z. */
	0x10,0x80,0x20,0x49,0xD1,0xFC,0x04,0x01,	/* 4290: . I.. */
	0xF0,0x06,0x10,0x10,0x12,0x2D,0x00,0x23,	/* 4298: ....-.# */
	0xC0,0x81,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 42A0: ... */
	0x3A,0x00,0x4A,0x85,0x66,0x46,0x30,0x03,	/* 42A8: :.JfF0. */
	0xC0,0xBC,0x00,0x00,0x00,0x80,0x67,0x3C,	/* 42B0: ...g< */
	0x30,0x02,0xC0,0xBC,0x00,0x00,0x00,0x01,	/* 42B8: 0..... */
	0x67,0x04,0x7C,0x01,0x60,0x2E,0x30,0x02,	/* 42C0: g.|.`.0. */
	0xC0,0xBC,0x00,0x00,0x00,0x02,0x67,0x12,	/* 42C8: ....g. */
	0x08,0xED,0x00,0x00,0x00,0x19,0x70,0x01,	/* 42D0: .....p. */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x7C,0x01,	/* 42D8: 3..a|. */
	0x60,0x12,0x20,0x4D,0x20,0x07,0xD1,0xC7,	/* 42E0: `. M . */
	0x52,0x80,0x42,0x28,0x01,0x60,0x7E,0x00,	/* 42E8: RB(.`~. */
	0x1E,0x00,0x7C,0x01,0x30,0x04,0xC0,0xBC,	/* 42F0: ..|.0. */
	0x00,0x00,0x00,0x02,0x67,0x00,0x00,0x6C,	/* 42F8: ....g..l */
	0x1D,0x6D,0x00,0x11,0xFF,0xFF,0x70,0x00,	/* 4300: .m..p. */
	0x10,0x2E,0xFF,0xFF,0x22,0x00,0x30,0x04,	/* 4308: ..".0. */
	0xC0,0xBC,0x00,0x00,0x00,0x04,0x67,0x2C,	/* 4310: ....g, */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x01,	/* 4318: 0..... */
	0x66,0x0A,0x70,0x00,0x10,0x2D,0x00,0x10,	/* 4320: f.p..-.. */
	0xBA,0x80,0x66,0x2E,0xC8,0xBC,0x00,0x00,	/* 4328: f... */
	0xFF,0xFB,0x70,0x00,0x10,0x2D,0x00,0x10,	/* 4330: p..-.. */
	0xBA,0x80,0x67,0x04,0xBA,0x81,0x66,0x1A,	/* 4338: g.f. */
	0x7C,0x01,0x60,0x16,0x70,0x00,0x10,0x2D,	/* 4340: |.`.p..- */
	0x00,0x10,0xBA,0x80,0x66,0x0C,0x70,0x00,	/* 4348: ..f.p. */
	0x10,0x2E,0xFF,0xFF,0xBA,0x80,0x67,0x02,	/* 4350: ..g. */
	0x7C,0x01,0xBA,0x81,0x66,0x0C,0x4A,0x86,	/* 4358: |.f.J */
	0x66,0x08,0x88,0xBC,0x00,0x00,0x00,0x04,	/* 4360: f..... */
	0x7C,0x01,0xC6,0xBC,0x00,0x00,0xFF,0xFF,	/* 4368: |... */
	0x70,0x70,0xC0,0x83,0x67,0x00,0x00,0x6A,	/* 4370: ppg..j */
	0x4A,0x86,0x66,0x00,0x00,0x64,0x30,0x04,	/* 4378: Jf..d0. */
	0xC0,0xBC,0x00,0x00,0x80,0x00,0x67,0x58,	/* 4380: ...gX */
	0x30,0x02,0xC0,0xBC,0x00,0x00,0x00,0x08,	/* 4388: 0..... */
	0x67,0x04,0x60,0x00,0x00,0xB2,0x30,0x02,	/* 4390: g.`..0. */
	0xC0,0xBC,0x00,0x00,0x00,0x04,0x67,0x36,	/* 4398: ....g6 */
	0x20,0x4D,0x70,0xFF,0xD1,0xC7,0x11,0x40,	/* 43A0:  Mp.@ */
	0x01,0x60,0x20,0x07,0x20,0x4D,0x52,0x80,	/* 43A8: .` . MR */
	0x7E,0x00,0x1E,0x00,0xD1,0xC7,0x20,0x07,	/* 43B0: ~... . */
	0x42,0x28,0x01,0x60,0x52,0x80,0x7E,0x00,	/* 43B8: B(.`R~. */
	0x1E,0x00,0x20,0x4D,0xD1,0xC7,0x20,0x07,	/* 43C0: .. M . */
	0x11,0x45,0x01,0x60,0x52,0x80,0x7E,0x00,	/* 43C8: .E.`R~. */
	0x1E,0x00,0x60,0x00,0x00,0x72,0x20,0x4D,	/* 43D0: ..`..r M */
	0xD1,0xC7,0x42,0x28,0x01,0x60,0x60,0x2C,	/* 43D8: B(.``, */
	0xBA,0xBC,0x00,0x00,0x00,0xFF,0x66,0x2E,	/* 43E0: ...f. */
	0x30,0x02,0xC0,0xBC,0x00,0x00,0x00,0x04,	/* 43E8: 0..... */
	0x67,0x24,0x76,0xFF,0x20,0x4D,0x20,0x07,	/* 43F0: g$v M . */
	0xD1,0xC7,0x52,0x80,0x11,0x43,0x01,0x60,	/* 43F8: R.C.` */
	0x7E,0x00,0x1E,0x00,0x20,0x4D,0xD1,0xC7,	/* 4400: ~... M */
	0x11,0x43,0x01,0x60,0x20,0x07,0x52,0x80,	/* 4408: .C.` .R */
	0x7E,0x00,0x1E,0x00,0x7C,0x01,0x4A,0x86,	/* 4410: ~...|.J */
	0x66,0x2C,0x20,0x07,0x12,0x2E,0xFF,0xF6,	/* 4418: f, ... */
	0x90,0x81,0x72,0x00,0x12,0x00,0xB2,0xBC,	/* 4420: r... */
	0x00,0x00,0x00,0xFE,0x6C,0x18,0x20,0x4D,	/* 4428: ...l. M */
	0x20,0x07,0xD1,0xC7,0x52,0x80,0x11,0x45,	/* 4430:  .R.E */
	0x01,0x60,0x7E,0x00,0x1E,0x00,0x70,0x01,	/* 4438: .`~...p. */
	0x33,0xC0,0x00,0x00,0x61,0xF6,0x20,0x49,	/* 4440: 3..a I */
	0xD1,0xFC,0x04,0x01,0xF0,0x02,0x16,0x10,	/* 4448: ..... */
	0xC6,0xBC,0x00,0x00,0x00,0xFF,0x30,0x03,	/* 4450: ...0. */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x66,0x00,	/* 4458: ....f. */
	0xFE,0x20,0x70,0x00,0x10,0x2E,0xFF,0xF7,	/* 4460:  p... */
	0xB0,0xBC,0x00,0x00,0x00,0xC0,0x6C,0x52,	/* 4468: ...lR */
	0x20,0x07,0x12,0x2E,0xFF,0xF6,0x90,0x81,	/* 4470:  ... */
	0x72,0x00,0x12,0x00,0xB2,0xBC,0x00,0x00,	/* 4478: r..... */
	0x00,0xC0,0x6D,0x3E,0x30,0x04,0xC0,0xBC,	/* 4480: .m>0. */
	0x00,0x00,0x00,0x08,0x67,0x34,0x08,0x2D,	/* 4488: ....g4.- */
	0x00,0x03,0x00,0x30,0x67,0x18,0x30,0x04,	/* 4490: ...0g.0. */
	0xC0,0xBC,0x00,0x00,0x00,0x20,0x66,0x08,	/* 4498: ... f. */
	0x88,0xBC,0x00,0x00,0x00,0xD0,0x60,0x06,	/* 44A0: ...`. */
	0xC8,0xBC,0x00,0x00,0xFF,0xBF,0x08,0x2D,	/* 44A8: ...- */
	0x00,0x07,0x00,0x31,0x67,0x0C,0xD3,0xCC,	/* 44B0: ...1g. */
	0x70,0x90,0x12,0x80,0x88,0xBC,0x00,0x00,	/* 44B8: p... */
	0x00,0x10,0x1B,0x47,0x00,0x0A,0x36,0x84,	/* 44C0: ...G..6 */
	0x4C,0xD7,0x38,0xFC,0x4F,0xEF,0x00,0x24,	/* 44C8: L8O.$ */
	0x4E,0x5E,0x4E,0x75,0x4E,0x56,0xFF,0xF8,	/* 44D0: N^NuNV */
	0x4F,0xEF,0xFF,0xDC,0x48,0xD7,0x3C,0xF8,	/* 44D8: OH< */
	0x2A,0x7C,0x01,0x01,0x81,0x80,0x2C,0x3C,	/* 44E0: *|..,< */
	0x01,0x01,0x80,0x00,0x24,0x7C,0x00,0x00,	/* 44E8: ...$|.. */
	0x63,0x54,0x26,0x7C,0x00,0x00,0x61,0xEC,	/* 44F0: cT&|..a */
	0x4A,0x13,0x67,0x06,0x4E,0xB9,0x00,0x00,	/* 44F8: J.g.N.. */
	0x0E,0x60,0x49,0xED,0x00,0x2E,0x70,0x00,	/* 4500: .`I..p. */
	0x7E,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 4508: ~..,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0x2A,0x41,	/* 4510: ..r.2.*A */
	0x70,0x00,0xDB,0xC6,0x10,0x2D,0x00,0x0E,	/* 4518: p..-.. */
	0x3E,0x00,0x4A,0x87,0x67,0x12,0x20,0x72,	/* 4520: >.Jg. r */
	0x7C,0x00,0x2F,0x0D,0x4E,0x90,0x58,0x8F,	/* 4528: |...NX */
	0x72,0x00,0x32,0x00,0x4A,0x81,0x67,0xC0,	/* 4530: r.2.Jg */
	0x49,0xED,0x00,0x02,0x70,0x00,0x7C,0x00,	/* 4538: I..p.|. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 4540: .,.... */
	0x3C,0x00,0x20,0x06,0xC0,0xBC,0x00,0x00,	/* 4548: <. ... */
	0x10,0x00,0x67,0x00,0x01,0x2E,0x20,0x46,	/* 4550: ..g... F */
	0xD1,0xFC,0x04,0x01,0xF0,0x02,0x1E,0x10,	/* 4558: ..... */
	0xCE,0xBC,0x00,0x00,0x00,0xFF,0x30,0x07,	/* 4560: ...0. */
	0xC0,0xBC,0x00,0x00,0x00,0x04,0x67,0x00,	/* 4568: ....g. */
	0x00,0xD0,0x18,0x2D,0x00,0x0D,0x1A,0x2D,	/* 4570: ..-...- */
	0x00,0x0C,0x72,0x00,0x10,0x04,0x90,0x85,	/* 4578: ..r... */
	0x12,0x00,0x4A,0x81,0x67,0x00,0x00,0x98,	/* 4580: ..Jg.. */
	0x20,0x46,0xCA,0xBC,0x00,0x00,0x00,0xFF,	/* 4588:  F... */
	0x49,0xED,0x00,0x08,0xD1,0xFC,0x04,0x01,	/* 4590: I.... */
	0xF0,0x06,0x10,0x35,0x58,0x60,0x10,0x80,	/* 4598: ..5X`. */
	0x70,0x01,0x1B,0x40,0x00,0x44,0x52,0x85,	/* 45A0: p..@.DR */
	0x1B,0x45,0x00,0x0C,0x70,0x00,0x10,0x2C,	/* 45A8: .E..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0xC0,0xBC,	/* 45B0: .... */
	0x00,0x00,0x08,0x00,0x67,0x2E,0x70,0x40,	/* 45B8: ....g.p@ */
	0xB0,0x81,0x6D,0x52,0x49,0xED,0x00,0x08,	/* 45C0: mRI.. */
	0x7C,0x00,0x1C,0x2C,0x00,0x01,0xE1,0x8E,	/* 45C8: |..,.. */
	0x1C,0x14,0xCC,0xBC,0x00,0x00,0xF7,0xFF,	/* 45D0: .... */
	0x20,0x06,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 45D8:  ..@.. */
	0x18,0x86,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 45E0: .p.3.. */
	0x61,0xF4,0x60,0x2A,0xB2,0xBC,0x00,0x00,	/* 45E8: a`*.. */
	0x00,0xC0,0x6D,0x22,0x49,0xED,0x00,0x08,	/* 45F0: .m"I.. */
	0x70,0x00,0x7C,0x00,0x10,0x2C,0x00,0x01,	/* 45F8: p.|..,.. */
	0xE1,0x88,0x10,0x14,0x80,0xBC,0x00,0x00,	/* 4600: .... */
	0x08,0x00,0x3C,0x00,0x20,0x06,0xE0,0x80,	/* 4608: ..<. . */
	0x19,0x40,0x00,0x01,0x18,0x86,0x08,0xED,	/* 4610: .@.... */
	0x00,0x00,0x00,0x41,0x60,0x22,0x1C,0x2D,	/* 4618: ...A`".- */
	0x00,0x41,0x08,0x06,0x00,0x00,0x67,0x14,	/* 4620: .A....g. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x61,0xF4,	/* 4628: p.3..a */
	0x10,0x06,0xC0,0xBC,0x00,0x00,0x00,0xFE,	/* 4630: ..... */
	0x1B,0x40,0x00,0x41,0x42,0x2D,0x00,0x44,	/* 4638: .@.AB-.D */
	0x30,0x07,0xC0,0xBC,0x00,0x00,0x00,0x01,	/* 4640: 0..... */
	0x67,0x00,0xFE,0x9C,0x49,0xED,0x00,0x08,	/* 4648: g.I.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 4650: p..,.. */
	0x10,0x14,0x3D,0x40,0xFF,0xFC,0x48,0x6E,	/* 4658: ..=@Hn */
	0xFF,0xFC,0x2F,0x07,0x2F,0x0D,0x61,0x00,	/* 4660: ....a. */
	0xFB,0xCC,0x7C,0x00,0x3C,0x2E,0xFF,0xFC,	/* 4668: |.<. */
	0x20,0x06,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 4670:  ..@.. */
	0x4F,0xEF,0x00,0x0C,0x18,0x86,0x60,0x00,	/* 4678: O...`. */
	0xFE,0x66,0x49,0xED,0x00,0x08,0x7E,0x00,	/* 4680: fI..~. */
	0x20,0x46,0xD1,0xFC,0x04,0x01,0xF0,0x02,	/* 4688:  F... */
	0x1E,0x2C,0x00,0x01,0xE1,0x8F,0x1E,0x14,	/* 4690: .,.... */
	0x12,0x10,0xC2,0xBC,0x00,0x00,0x00,0xFF,	/* 4698: ..... */
	0x30,0x01,0xC0,0xBC,0x00,0x00,0x00,0x04,	/* 46A0: 0..... */
	0x67,0x00,0x01,0x82,0x30,0x07,0xC0,0xBC,	/* 46A8: g..0. */
	0x00,0x00,0x00,0x40,0x67,0x4C,0x30,0x07,	/* 46B0: ...@gL0. */
	0xC0,0xBC,0x00,0x00,0x00,0x80,0x67,0x24,	/* 46B8: ...g$ */
	0x20,0x46,0x10,0x2D,0x00,0x13,0x8E,0xBC,	/* 46C0:  F.-.. */
	0x00,0x00,0x00,0x20,0xD1,0xFC,0x04,0x01,	/* 46C8: ... .. */
	0xF0,0x06,0x10,0x80,0x70,0x01,0x1B,0x40,	/* 46D0: ..p..@ */
	0x00,0x44,0xCE,0xBC,0x00,0x00,0xFF,0x3F,	/* 46D8: .D..? */
	0x60,0x00,0x01,0x4A,0x20,0x46,0x10,0x2D,	/* 46E0: `..J F.- */
	0x00,0x12,0xD1,0xFC,0x04,0x01,0xF0,0x06,	/* 46E8: ..... */
	0x10,0x80,0x70,0x01,0x1B,0x40,0x00,0x44,	/* 46F0: .p..@.D */
	0xCE,0xBC,0x00,0x00,0xFF,0x8F,0x60,0x00,	/* 46F8: ..`. */
	0x01,0x2C,0x30,0x07,0xC0,0xBC,0x00,0x00,	/* 4700: .,0... */
	0x00,0x04,0x66,0x00,0x01,0x20,0x16,0x2D,	/* 4708: ..f.. .- */
	0x00,0x0D,0x1A,0x2D,0x00,0x0C,0x78,0x00,	/* 4710: ...-..x. */
	0x10,0x03,0x90,0x85,0x18,0x00,0x4A,0x84,	/* 4718: ....J */
	0x67,0x00,0x00,0xE8,0xCA,0xBC,0x00,0x00,	/* 4720: g.... */
	0x00,0xFF,0x76,0x00,0x16,0x35,0x58,0x60,	/* 4728: .v..5X` */
	0x70,0x0A,0xB0,0x83,0x66,0x48,0x30,0x07,	/* 4730: p.fH0. */
	0xC0,0xBC,0x00,0x00,0x04,0x00,0x67,0x3E,	/* 4738: ....g> */
	0x30,0x07,0xC0,0xBC,0x00,0x00,0x01,0x00,	/* 4740: 0..... */
	0x67,0x1A,0x20,0x46,0x70,0x01,0xD1,0xFC,	/* 4748: g. Fp. */
	0x04,0x01,0xF0,0x06,0x10,0x83,0xCE,0xBC,	/* 4750: .... */
	0x00,0x00,0xFE,0xFF,0x1B,0x40,0x00,0x44,	/* 4758: ...@.D */
	0x52,0x85,0x60,0x2C,0x20,0x46,0x70,0x0D,	/* 4760: R`, Fp. */
	0xD1,0xFC,0x04,0x01,0xF0,0x06,0x10,0x80,	/* 4768: .... */
	0x70,0x01,0x1B,0x40,0x00,0x44,0x8E,0xBC,	/* 4770: p..@.D */
	0x00,0x00,0x01,0x00,0x60,0x12,0x20,0x46,	/* 4778: ....`. F */
	0xD1,0xFC,0x04,0x01,0xF0,0x06,0x10,0x83,	/* 4780: .... */
	0x70,0x01,0x1B,0x40,0x00,0x44,0x52,0x85,	/* 4788: p..@.DR */
	0x1B,0x45,0x00,0x0C,0x49,0xED,0x00,0x08,	/* 4790: .E..I.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 4798: p..,.. */
	0x10,0x14,0xC0,0xBC,0x00,0x00,0x08,0x00,	/* 47A0: ...... */
	0x67,0x2E,0x70,0x40,0xB0,0x84,0x6D,0x52,	/* 47A8: g.p@mR */
	0x49,0xED,0x00,0x08,0x78,0x00,0x18,0x2C,	/* 47B0: I..x.., */
	0x00,0x01,0xE1,0x8C,0x18,0x14,0xC8,0xBC,	/* 47B8: .... */
	0x00,0x00,0xF7,0xFF,0x20,0x04,0xE0,0x80,	/* 47C0: .. . */
	0x19,0x40,0x00,0x01,0x18,0x84,0x70,0x01,	/* 47C8: .@...p. */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x60,0x2A,	/* 47D0: 3..a`* */
	0xB8,0xBC,0x00,0x00,0x00,0xC0,0x6D,0x22,	/* 47D8: ...m" */
	0x49,0xED,0x00,0x08,0x70,0x00,0x78,0x00,	/* 47E0: I..p.x. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 47E8: .,.... */
	0x80,0xBC,0x00,0x00,0x08,0x00,0x38,0x00,	/* 47F0: ....8. */
	0x20,0x04,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 47F8:  ..@.. */
	0x18,0x84,0x08,0xED,0x00,0x00,0x00,0x41,	/* 4800: .....A */
	0x60,0x22,0x18,0x2D,0x00,0x41,0x08,0x04,	/* 4808: `".-.A.. */
	0x00,0x00,0x67,0x14,0x70,0x01,0x33,0xC0,	/* 4810: ..g.p.3 */
	0x00,0x00,0x61,0xF4,0x10,0x04,0xC0,0xBC,	/* 4818: ..a.. */
	0x00,0x00,0x00,0xFE,0x1B,0x40,0x00,0x41,	/* 4820: ....@.A */
	0x42,0x2D,0x00,0x44,0x30,0x01,0xC0,0xBC,	/* 4828: B-.D0. */
	0x00,0x00,0x00,0x01,0x67,0x18,0x3D,0x47,	/* 4830: ....g.=G */
	0xFF,0xFE,0x48,0x6E,0xFF,0xFE,0x2F,0x01,	/* 4838: Hn.. */
	0x2F,0x0D,0x61,0x00,0xF9,0xF0,0x3E,0x2E,	/* 4840: ..a.>. */
	0xFF,0xFE,0x4F,0xEF,0x00,0x0C,0x30,0x07,	/* 4848: O..0. */
	0xC0,0xBC,0x00,0x00,0x00,0x10,0x67,0x4E,	/* 4850: ....gN */
	0x10,0x2D,0x00,0x0A,0x12,0x2D,0x00,0x0B,	/* 4858: .-...-.. */
	0x90,0x81,0x72,0x00,0x12,0x00,0x70,0x40,	/* 4860: r...p@ */
	0xB0,0x81,0x6F,0x3A,0x30,0x07,0xC0,0xBC,	/* 4868: o:0. */
	0x00,0x00,0x00,0x80,0x67,0x06,0xCE,0xBC,	/* 4870: ...g. */
	0x00,0x00,0xFF,0x3F,0x30,0x07,0xC0,0xBC,	/* 4878: ..?0. */
	0x00,0x00,0x00,0x20,0x67,0x06,0x8E,0xBC,	/* 4880: ... g. */
	0x00,0x00,0x00,0x40,0x08,0x2D,0x00,0x07,	/* 4888: ...@.-.. */
	0x00,0x31,0x67,0x0C,0x20,0x46,0xD1,0xFC,	/* 4890: .1g. F */
	0x04,0x01,0xF0,0x04,0x70,0x80,0x10,0x80,	/* 4898: ...p. */
	0xCE,0xBC,0x00,0x00,0xFF,0xEF,0x49,0xED,	/* 48A0: ..I */
	0x00,0x08,0xCE,0xBC,0x00,0x00,0xFF,0xFF,	/* 48A8: .... */
	0x2C,0x07,0x20,0x06,0xE0,0x80,0x19,0x40,	/* 48B0: ,. ..@ */
	0x00,0x01,0x18,0x86,0x60,0x00,0xFC,0x28,	/* 48B8: ...`.( */
	0x22,0x6F,0x00,0x04,0x2F,0x09,0x61,0x00,	/* 48C0: "o....a. */
	0xF8,0x90,0x58,0x8F,0xC0,0xBC,0x00,0x00,	/* 48C8: X.. */
	0x00,0x04,0x67,0x0E,0x42,0x29,0x00,0x0E,	/* 48D0: ..g.B).. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x61,0xF4,	/* 48D8: p.3..a */
	0x60,0x06,0x70,0x06,0x13,0x40,0x00,0x0E,	/* 48E0: `.p..@.. */
	0x70,0x00,0x4E,0x75,0x4F,0xEF,0xFF,0xF0,	/* 48E8: p.NuO */
	0x70,0x00,0x48,0xD7,0x20,0xE0,0x2A,0x6F,	/* 48F0: p.H *o */
	0x00,0x14,0x7E,0x00,0x7A,0x00,0x41,0xED,	/* 48F8: ..~.z.A */
	0x00,0x02,0x10,0x28,0x00,0x01,0xE1,0x88,	/* 4900: ...(.. */
	0x10,0x10,0x41,0xED,0x00,0x08,0x3E,0x00,	/* 4908: ..A..>. */
	0x1A,0x28,0x00,0x01,0xE1,0x8D,0x1A,0x10,	/* 4910: .(.... */
	0x4A,0x2D,0x00,0x1F,0x67,0x04,0x42,0x2D,	/* 4918: J-..g.B- */
	0x00,0x1F,0x70,0x00,0x10,0x2D,0x00,0x0E,	/* 4920: ..p..-.. */
	0x51,0x80,0x66,0x2A,0x10,0x2D,0x00,0x14,	/* 4928: Qf*.-.. */
	0x12,0x2D,0x00,0x31,0x90,0x81,0x4A,0x00,	/* 4930: .-.1J. */
	0x66,0x1C,0x10,0x2D,0x00,0x15,0x12,0x2D,	/* 4938: f..-...- */
	0x00,0x32,0x90,0x81,0x4A,0x00,0x66,0x0E,	/* 4940: .2J.f. */
	0x10,0x2D,0x00,0x16,0x12,0x2D,0x00,0x2D,	/* 4948: .-...-.- */
	0x90,0x81,0x4A,0x00,0x67,0x50,0x2C,0x3C,	/* 4950: J.gP,< */
	0x04,0x01,0xF0,0x04,0x20,0x47,0x70,0x1A,	/* 4958: ... Gp. */
	0xD1,0xC6,0x10,0x80,0x22,0x3C,0x04,0x01,	/* 4960: ."<.. */
	0xF0,0x00,0x20,0x47,0xD1,0xC1,0x10,0x2D,	/* 4968: . G.- */
	0x00,0x14,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 4970: ... G.- */
	0x00,0x15,0xD1,0xC1,0x10,0x80,0x20,0x47,	/* 4978: ... G */
	0x10,0x2D,0x00,0x16,0xD1,0xFC,0x04,0x01,	/* 4980: .-.... */
	0xF0,0x02,0x10,0x80,0x1B,0x6D,0x00,0x14,	/* 4988: ...m.. */
	0x00,0x31,0x20,0x47,0x70,0x05,0x1B,0x6D,	/* 4990: .1 Gp..m */
	0x00,0x15,0x00,0x32,0x1B,0x6D,0x00,0x16,	/* 4998: ...2.m.. */
	0x00,0x2D,0xD1,0xC6,0x10,0x80,0x08,0x2D,	/* 49A0: .-..- */
	0x00,0x00,0x00,0x17,0x67,0x16,0x08,0x2D,	/* 49A8: ....g..- */
	0x00,0x07,0x00,0x14,0x66,0x0E,0x20,0x47,	/* 49B0: ....f. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x04,0x70,0x80,	/* 49B8: ...p */
	0x10,0x80,0x60,0x0C,0x20,0x47,0xD1,0xFC,	/* 49C0: .`. G */
	0x04,0x01,0xF0,0x04,0x70,0x90,0x10,0x80,	/* 49C8: ...p. */
	0x08,0x2D,0x00,0x01,0x00,0x17,0x67,0x0E,	/* 49D0: .-....g. */
	0x48,0x78,0x00,0x01,0x2F,0x0D,0x61,0x00,	/* 49D8: Hx....a. */
	0xF7,0xD4,0x50,0x8F,0x60,0x0A,0x42,0xA7,	/* 49E0: P`.B */
	0x2F,0x0D,0x61,0x00,0xF7,0xC8,0x50,0x8F,	/* 49E8: ..a.P */
	0x42,0x2D,0x00,0x19,0x1B,0x6D,0x00,0x1B,	/* 49F0: B-...m.. */
	0x00,0x10,0x1B,0x6D,0x00,0x1D,0x00,0x12,	/* 49F8: ...m.... */
	0x1B,0x6D,0x00,0x1C,0x00,0x11,0x1B,0x6D,	/* 4A00: .m.....m */
	0x00,0x1E,0x00,0x13,0x1B,0x6D,0x00,0x20,	/* 4A08: .....m.  */
	0x00,0x21,0x1B,0x6D,0x00,0x22,0x00,0x23,	/* 4A10: .!.m.".# */
	0x1C,0x2D,0x00,0x1A,0x1B,0x46,0x00,0x30,	/* 4A18: .-...F.0 */
	0x70,0x01,0x1B,0x40,0x00,0x42,0x3E,0x05,	/* 4A20: p..@.B>. */
	0x42,0x2D,0x00,0x43,0xCE,0xBC,0x00,0x00,	/* 4A28: B-.C.. */
	0xFF,0xF4,0x42,0x2D,0x00,0x44,0x08,0x06,	/* 4A30: B-.D.. */
	0x00,0x01,0x67,0x06,0x8E,0xBC,0x00,0x00,	/* 4A38: ..g... */
	0x00,0x02,0x08,0x06,0x00,0x03,0x67,0x06,	/* 4A40: ......g. */
	0x8E,0xBC,0x00,0x00,0x00,0x08,0x08,0x06,	/* 4A48: ...... */
	0x00,0x00,0x67,0x06,0x8E,0xBC,0x00,0x00,	/* 4A50: ..g... */
	0x00,0x01,0xCE,0xBC,0x00,0x00,0x5B,0xFF,	/* 4A58: ....[ */
	0x08,0x06,0x00,0x02,0x67,0x06,0x8E,0xBC,	/* 4A60: ....g. */
	0x00,0x00,0x04,0x00,0x08,0x06,0x00,0x05,	/* 4A68: ........ */
	0x67,0x06,0x8E,0xBC,0x00,0x00,0x20,0x00,	/* 4A70: g... . */
	0x08,0x06,0x00,0x07,0x67,0x06,0x8E,0xBC,	/* 4A78: ....g. */
	0x00,0x00,0x80,0x00,0x08,0x2D,0x00,0x07,	/* 4A80: ....-.. */
	0x00,0x14,0x67,0x06,0x8E,0xBC,0x00,0x00,	/* 4A88: ..g... */
	0x00,0x08,0x08,0x06,0x00,0x06,0x67,0x06,	/* 4A90: ......g. */
	0x8E,0xBC,0x00,0x00,0x00,0x08,0x30,0x05,	/* 4A98: ....0. */
	0xC0,0xBC,0x00,0x00,0x04,0x00,0x67,0x10,	/* 4AA0: ....g. */
	0x30,0x07,0xC0,0xBC,0x00,0x00,0x04,0x00,	/* 4AA8: 0..... */
	0x66,0x06,0xCE,0xBC,0x00,0x00,0xFE,0xFF,	/* 4AB0: f... */
	0x30,0x05,0xC0,0xBC,0x00,0x00,0x00,0x02,	/* 4AB8: 0..... */
	0x67,0x10,0x30,0x07,0xC0,0xBC,0x00,0x00,	/* 4AC0: g.0... */
	0x00,0x02,0x66,0x06,0xCE,0xBC,0x00,0x00,	/* 4AC8: ..f... */
	0xFF,0xFB,0x08,0x2D,0x00,0x07,0x00,0x31,	/* 4AD0: .-...1 */
	0x67,0x06,0x8E,0xBC,0x00,0x00,0x00,0x08,	/* 4AD8: g..... */
	0x30,0x07,0xC0,0xBC,0x00,0x00,0x20,0x00,	/* 4AE0: 0... . */
	0x67,0x10,0x2F,0x0D,0x61,0x00,0xF6,0x6A,	/* 4AE8: g...a.j */
	0x2A,0x00,0x1B,0x45,0x00,0x18,0x58,0x8F,	/* 4AF0: *..E..X */
	0x60,0x06,0x70,0x24,0x1B,0x40,0x00,0x18,	/* 4AF8: `.p$.@.. */
	0x70,0x00,0x10,0x2D,0x00,0x0E,0x59,0x80,	/* 4B00: p..-..Y */
	0x66,0x0A,0x2F,0x0D,0x61,0x00,0xFD,0xB2,	/* 4B08: f...a. */
	0x58,0x8F,0x60,0x04,0x42,0x2D,0x00,0x0E,	/* 4B10: X`.B-.. */
	0x41,0xED,0x00,0x08,0xCE,0xBC,0x00,0x00,	/* 4B18: A.... */
	0xFF,0xFF,0x2A,0x07,0x20,0x05,0xE0,0x80,	/* 4B20: *. . */
	0x11,0x40,0x00,0x01,0x10,0x85,0x70,0x01,	/* 4B28: .@...p. */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x4C,0xD7,	/* 4B30: 3..aL */
	0x20,0xE0,0x70,0x00,0x4F,0xEF,0x00,0x10,	/* 4B38:  p.O.. */
	0x4E,0x75,0x4E,0x71,0x22,0x6F,0x00,0x04,	/* 4B40: NuNq"o.. */
	0x70,0x00,0x41,0xE9,0x00,0x02,0x10,0x28,	/* 4B48: p.A...( */
	0x00,0x01,0xE1,0x88,0x10,0x10,0xC0,0xBC,	/* 4B50: .... */
	0x00,0x00,0xFF,0xFF,0x20,0x40,0xD1,0xFC,	/* 4B58: .. @ */
	0x04,0x01,0xF0,0x04,0x70,0x60,0x10,0x80,	/* 4B60: ...p`. */
	0x70,0x12,0x13,0x40,0x00,0x0E,0x70,0x00,	/* 4B68: p..@..p. */
	0x4E,0x75,0x4E,0x71,0x22,0x6F,0x00,0x04,	/* 4B70: NuNq"o.. */
	0x70,0x00,0x41,0xE9,0x00,0x02,0x10,0x28,	/* 4B78: p.A...( */
	0x00,0x01,0xE1,0x88,0x10,0x10,0xC0,0xBC,	/* 4B80: .... */
	0x00,0x00,0xFF,0xFF,0x20,0x40,0xD1,0xFC,	/* 4B88: .. @ */
	0x04,0x01,0xF0,0x04,0x70,0x75,0x10,0x80,	/* 4B90: ...pu. */
	0x42,0x29,0x00,0x0E,0x70,0x00,0x4E,0x75,	/* 4B98: B)..p.Nu */
	0x70,0x00,0x4E,0x75,0x70,0x00,0x4E,0x75,	/* 4BA0: p.Nup.Nu */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x2A,0x6F,	/* 4BA8: ..p...*o */
	0x00,0x0C,0x41,0xED,0x00,0x02,0x10,0x28,	/* 4BB0: ..A...( */
	0x00,0x01,0xE1,0x88,0x10,0x10,0x42,0x2D,	/* 4BB8: ....B- */
	0x00,0x0C,0x42,0x2D,0x00,0x0D,0x7E,0x00,	/* 4BC0: ..B-..~. */
	0x42,0x2D,0x00,0x0B,0x3E,0x00,0x42,0x2D,	/* 4BC8: B-..>.B- */
	0x00,0x0A,0x08,0x2D,0x00,0x04,0x00,0x32,	/* 4BD0: ...-...2 */
	0x67,0x14,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 4BD8: g. G.. */
	0xF0,0x00,0x10,0x2D,0x00,0x32,0xC0,0xBC,	/* 4BE0: ..-.2 */
	0x00,0x00,0x00,0xEF,0x10,0x80,0x20,0x47,	/* 4BE8: .... G */
	0xD1,0xFC,0x04,0x01,0xF0,0x02,0x10,0x10,	/* 4BF0: ..... */
	0x08,0x00,0x00,0x03,0x66,0x04,0x70,0x00,	/* 4BF8: ....f.p. */
	0x60,0x5C,0x08,0x2D,0x00,0x00,0x00,0x17,	/* 4C00: `\.-.... */
	0x66,0x0C,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 4C08: f. G.. */
	0xF0,0x04,0x70,0x90,0x10,0x80,0x08,0x2D,	/* 4C10: .p..- */
	0x00,0x01,0x00,0x17,0x66,0x0A,0x42,0xA7,	/* 4C18: ....f.B */
	0x2F,0x0D,0x61,0x00,0xF5,0x90,0x50,0x8F,	/* 4C20: ..a.P */
	0x41,0xED,0x00,0x08,0x42,0x28,0x00,0x01,	/* 4C28: A..B(.. */
	0x70,0x30,0x42,0x10,0x22,0x3C,0x04,0x01,	/* 4C30: p0B."<.. */
	0xF0,0x04,0x20,0x47,0xD1,0xC1,0x10,0x80,	/* 4C38: . G. */
	0x20,0x47,0x70,0x20,0xD1,0xC1,0x10,0x80,	/* 4C40:  Gp . */
	0x70,0x01,0x1B,0x40,0x00,0x1F,0x70,0x10,	/* 4C48: p..@..p. */
	0x1B,0x40,0x00,0x0E,0x70,0x01,0x33,0xC0,	/* 4C50: .@..p.3 */
	0x00,0x00,0x61,0xF4,0x70,0x00,0x2E,0x1F,	/* 4C58: ..ap... */
	0x2A,0x5F,0x4E,0x75,0x2F,0x07,0x7E,0x00,	/* 4C60: *_Nu..~. */
	0x22,0x6F,0x00,0x08,0x41,0xE9,0x00,0x02,	/* 4C68: "o..A.. */
	0x10,0x29,0x00,0x0D,0x1E,0x28,0x00,0x01,	/* 4C70: .)...(.. */
	0xE1,0x8F,0x1E,0x10,0x12,0x29,0x00,0x0C,	/* 4C78: ...).. */
	0x90,0x81,0x4A,0x00,0x66,0x1A,0xCE,0xBC,	/* 4C80: J.f. */
	0x00,0x00,0xFF,0xFF,0x20,0x47,0xD1,0xFC,	/* 4C88: .. G */
	0x04,0x01,0xF0,0x00,0x10,0x10,0xC0,0xBC,	/* 4C90: ..... */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x66,0x04,	/* 4C98: ...J.f. */
	0x70,0x01,0x60,0x0A,0x2F,0x09,0x61,0x00,	/* 4CA0: p.`...a. */
	0xFF,0x00,0x70,0x00,0x58,0x8F,0x2E,0x1F,	/* 4CA8: .p.X.. */
	0x4E,0x75,0x4E,0x71,0x20,0x6F,0x00,0x04,	/* 4CB0: NuNq o.. */
	0x70,0x00,0x72,0x00,0x43,0xE8,0x00,0x08,	/* 4CB8: p.r.C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 4CC0: .).... */
	0x32,0x00,0x70,0x06,0xC0,0x81,0x5D,0x80,	/* 4CC8: 2.p.] */
	0x66,0x1E,0x43,0xE8,0x00,0x08,0x72,0x00,	/* 4CD0: f.C..r. */
	0x12,0x29,0x00,0x01,0xE1,0x89,0x12,0x11,	/* 4CD8: .).... */
	0xC2,0xBC,0x00,0x00,0xFF,0xFB,0x20,0x01,	/* 4CE0: .. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x81,	/* 4CE8: .@... */
	0x42,0x28,0x00,0x0E,0x70,0x01,0x33,0xC0,	/* 4CF0: B(..p.3 */
	0x00,0x00,0x61,0xF4,0x70,0x00,0x4E,0x75,	/* 4CF8: ..ap.Nu */
	0x2F,0x07,0x70,0x00,0x7E,0x00,0x22,0x6F,	/* 4D00: ..p.~."o */
	0x00,0x08,0x41,0xE9,0x00,0x02,0x10,0x28,	/* 4D08: ..A...( */
	0x00,0x01,0xE1,0x88,0x10,0x10,0x13,0x69,	/* 4D10: .....i */
	0x00,0x0D,0x00,0x0C,0x41,0xE9,0x00,0x08,	/* 4D18: ....A.. */
	0x72,0x00,0x3E,0x00,0x12,0x28,0x00,0x01,	/* 4D20: r.>..(.. */
	0xE1,0x89,0x12,0x10,0xC2,0xBC,0x00,0x00,	/* 4D28: .... */
	0xF7,0xFF,0x20,0x01,0xE0,0x80,0x11,0x40,	/* 4D30:  ..@ */
	0x00,0x01,0x10,0x81,0x08,0x29,0x00,0x04,	/* 4D38: ....).. */
	0x00,0x32,0x67,0x26,0x2F,0x09,0x61,0x00,	/* 4D40: .2g&..a. */
	0xF4,0x10,0x58,0x8F,0xC0,0xBC,0x00,0x00,	/* 4D48: .X.. */
	0x00,0x02,0x66,0x16,0x22,0x3C,0x04,0x01,	/* 4D50: ..f."<.. */
	0xF0,0x04,0x20,0x47,0x70,0x30,0xD1,0xC1,	/* 4D58: . Gp0 */
	0x10,0x80,0x20,0x47,0x70,0x04,0xD1,0xC1,	/* 4D60: . Gp. */
	0x10,0x80,0x2F,0x09,0x61,0x00,0xFF,0x46,	/* 4D68: ...a.F */
	0x70,0x00,0x58,0x8F,0x2E,0x1F,0x4E,0x75,	/* 4D70: p.X..Nu */
	0x20,0x6F,0x00,0x04,0x11,0x68,0x00,0x0B,	/* 4D78:  o...h.. */
	0x00,0x0A,0x42,0x28,0x00,0x0E,0x70,0x01,	/* 4D80: ..B(..p. */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x70,0x00,	/* 4D88: 3..ap. */
	0x4E,0x75,0x4E,0x71,0x20,0x6F,0x00,0x04,	/* 4D90: NuNq o.. */
	0x70,0x00,0x43,0xE8,0x00,0x08,0x10,0x29,	/* 4D98: p.C...) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0xC0,0xBC,	/* 4DA0: .... */
	0x00,0x00,0x00,0x02,0x67,0x22,0x43,0xE8,	/* 4DA8: ....g"C */
	0x00,0x08,0x70,0x00,0x72,0x00,0x10,0x29,	/* 4DB0: ..p.r..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x80,0xBC,	/* 4DB8: .... */
	0x00,0x00,0x00,0x04,0x32,0x00,0x20,0x01,	/* 4DC0: ....2. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x81,	/* 4DC8: .@... */
	0x42,0x28,0x00,0x0E,0x70,0x01,0x33,0xC0,	/* 4DD0: B(..p.3 */
	0x00,0x00,0x61,0xF4,0x70,0x00,0x4E,0x75,	/* 4DD8: ..ap.Nu */
	0x20,0x6F,0x00,0x04,0x42,0x28,0x00,0x0E,	/* 4DE0:  o..B(.. */
	0x70,0x00,0x4E,0x75,0x4F,0xEF,0xFF,0xF4,	/* 4DE8: p.NuO */
	0x70,0x00,0x48,0xD7,0x20,0xC0,0x2A,0x6F,	/* 4DF0: p.H *o */
	0x00,0x10,0x7E,0x00,0x41,0xED,0x00,0x04,	/* 4DF8: ..~.A.. */
	0x10,0x28,0x00,0x01,0xE1,0x88,0x10,0x10,	/* 4E00: .(.... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 4E08: r.2. */
	0x7F,0xFF,0x70,0x00,0x20,0x41,0x5C,0x88,	/* 4E10: p. A\ */
	0x10,0x28,0x00,0x01,0xE1,0x88,0x10,0x10,	/* 4E18: .(.... */
	0x3E,0x00,0x70,0x00,0x10,0x2D,0x00,0x35,	/* 4E20: >.p..-.5 */
	0x53,0x80,0x67,0x14,0x53,0x80,0x67,0x60,	/* 4E28: Sg.Sg` */
	0x55,0x80,0x67,0x00,0x00,0xC6,0x53,0x80,	/* 4E30: Ug..S */
	0x67,0x00,0x01,0x10,0x60,0x00,0x01,0x5A,	/* 4E38: g...`..Z */
	0x2C,0x3C,0x04,0x01,0xF0,0x0A,0x20,0x47,	/* 4E40: ,<... G */
	0xD1,0xC6,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 4E48: .... */
	0x00,0xFF,0x4A,0x00,0x66,0x00,0x01,0x42,	/* 4E50: .J.f..B */
	0x22,0x3C,0x04,0x01,0xF0,0x12,0x20,0x47,	/* 4E58: "<... G */
	0xD1,0xC1,0x10,0x10,0x08,0x00,0x00,0x05,	/* 4E60: ...... */
	0x66,0x20,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 4E68: f  G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 4E70: .... */
	0x00,0xFF,0x80,0xBC,0x00,0x00,0x00,0x20,	/* 4E78: ....  */
	0x10,0x80,0x20,0x47,0x70,0x4E,0xD1,0xC6,	/* 4E80: . GpN */
	0x10,0x80,0x70,0x02,0x1B,0x40,0x00,0x35,	/* 4E88: .p..@.5 */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x0A,	/* 4E90:  G... */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 4E98: ..... */
	0x4A,0x00,0x66,0x00,0x00,0xF4,0x2C,0x3C,	/* 4EA0: J.f..,< */
	0x04,0x01,0xF0,0xC6,0x20,0x47,0x70,0x81,	/* 4EA8: .. Gp */
	0xD1,0xC6,0x42,0x10,0x20,0x47,0xD1,0xC6,	/* 4EB0: B. G */
	0x10,0x80,0x7C,0x00,0x41,0xED,0x00,0x08,	/* 4EB8: .|.A.. */
	0x1C,0x28,0x00,0x01,0xE1,0x8E,0x1C,0x10,	/* 4EC0: .(.... */
	0xCC,0xBC,0x00,0x00,0xFF,0xFE,0x20,0x06,	/* 4EC8: .. . */
	0xE0,0x80,0x11,0x40,0x00,0x01,0x22,0x47,	/* 4ED0: .@.."G */
	0x10,0x86,0x2C,0x3C,0x04,0x01,0xF0,0x0C,	/* 4ED8: .,<... */
	0x20,0x47,0xD1,0xC6,0xD3,0xC6,0x10,0x11,	/* 4EE0:  G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF9,0x10,0x80,	/* 4EE8: .... */
	0x70,0x03,0x1B,0x40,0x00,0x35,0x60,0x00,	/* 4EF0: p..@.5`. */
	0x00,0xA0,0x22,0x3C,0x04,0x01,0xF0,0x0A,	/* 4EF8: ."<... */
	0x20,0x47,0xD1,0xC1,0x10,0x10,0xC0,0xBC,	/* 4F00:  G.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x66,0x00,	/* 4F08: ...J.f. */
	0x00,0x88,0x2C,0x3C,0x04,0x01,0xF0,0x12,	/* 4F10: .,<... */
	0x20,0x47,0xD1,0xC6,0x10,0x10,0x08,0x00,	/* 4F18:  G.... */
	0x00,0x05,0x66,0x20,0x20,0x47,0x22,0x47,	/* 4F20: ..f  G"G */
	0xD1,0xC6,0xD3,0xC6,0x10,0x11,0xC0,0xBC,	/* 4F28: .. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 4F30: ..... */
	0x00,0x20,0x10,0x80,0x20,0x47,0x70,0x4E,	/* 4F38: . . GpN */
	0xD1,0xC1,0x10,0x80,0x70,0x05,0x1B,0x40,	/* 4F40: .p..@ */
	0x00,0x35,0x2C,0x3C,0x04,0x01,0xF0,0x0A,	/* 4F48: .5,<... */
	0x20,0x47,0xD1,0xC6,0x10,0x10,0xC0,0xBC,	/* 4F50:  G.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x66,0x38,	/* 4F58: ...J.f8 */
	0x22,0x3C,0x04,0x01,0xF0,0xC6,0x20,0x47,	/* 4F60: "<.. G */
	0x70,0x83,0x22,0x47,0xD1,0xC1,0x42,0x10,	/* 4F68: p"GB. */
	0x20,0x47,0xD1,0xC1,0x10,0x80,0x22,0x3C,	/* 4F70:  G."< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0xD1,0xC1,	/* 4F78: ... G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 4F80: .... */
	0x00,0xDF,0x10,0x80,0x20,0x47,0x70,0x4E,	/* 4F88: .. GpN */
	0xD1,0xC6,0x10,0x80,0x42,0x2D,0x00,0x35,	/* 4F90: .B-.5 */
	0x4C,0xD7,0x20,0xC0,0x4F,0xEF,0x00,0x0C,	/* 4F98: L O.. */
	0x4E,0x75,0x4E,0x71,0x2F,0x07,0x70,0x00,	/* 4FA0: NuNq..p. */
	0x7E,0x00,0x2F,0x06,0x22,0x6F,0x00,0x0C,	/* 4FA8: ~..."o.. */
	0x41,0xE9,0x00,0x02,0x10,0x28,0x00,0x01,	/* 4FB0: A...(.. */
	0xE1,0x88,0x10,0x10,0x22,0x3C,0x04,0x01,	/* 4FB8: .."<.. */
	0xF0,0x0A,0x3E,0x00,0x20,0x47,0xD1,0xC1,	/* 4FC0: .>. G */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 4FC8: ..... */
	0x4A,0x00,0x67,0x0A,0x08,0xE9,0x00,0x04,	/* 4FD0: J.g.... */
	0x00,0x40,0x60,0x00,0x00,0x6E,0x1C,0x29,	/* 4FD8: .@`..n.) */
	0x00,0x40,0xCC,0xBC,0x00,0x00,0x00,0xEF,	/* 4FE0: .@... */
	0x13,0x46,0x00,0x40,0x08,0x29,0x00,0x04,	/* 4FE8: .F.@.).. */
	0x00,0x30,0x67,0x42,0x20,0x47,0xD1,0xFC,	/* 4FF0: .0gB G */
	0x04,0x01,0xF0,0xD8,0x10,0x10,0x08,0x00,	/* 4FF8: ...... */
	0x00,0x04,0x67,0x16,0x08,0x06,0x00,0x00,	/* 5000: ..g..... */
	0x67,0x40,0x20,0x47,0xD1,0xC1,0x70,0x18,	/* 5008: g@ Gp. */
	0x10,0x80,0x08,0xA9,0x00,0x00,0x00,0x40,	/* 5010: .....@ */
	0x60,0x30,0x10,0x06,0xC0,0xBC,0x00,0x00,	/* 5018: `0.... */
	0x00,0x01,0x46,0x80,0x67,0x24,0x20,0x47,	/* 5020: ..Fg$ G */
	0xD1,0xC1,0x70,0x14,0x10,0x80,0x08,0xE9,	/* 5028: p... */
	0x00,0x00,0x00,0x40,0x60,0x14,0x08,0x06,	/* 5030: ...@`... */
	0x00,0x00,0x67,0x0E,0x20,0x47,0xD1,0xC1,	/* 5038: ..g. G */
	0x70,0x18,0x10,0x80,0x08,0xA9,0x00,0x00,	/* 5040: p..... */
	0x00,0x40,0x2C,0x1F,0x2E,0x1F,0x4E,0x75,	/* 5048: .@,...Nu */
	0x4E,0x56,0xFF,0xD8,0x70,0x00,0x20,0x79,	/* 5050: NVp. y */
	0x00,0x00,0x63,0xD0,0x4F,0xEF,0xFF,0xD8,	/* 5058: ..cO */
	0x48,0xD7,0x3C,0xFC,0x2A,0x7C,0x01,0x01,	/* 5060: H<*|.. */
	0x80,0x80,0x2D,0x40,0xFF,0xE0,0x26,0x4D,	/* 5068: -@&M */
	0x10,0x28,0x00,0x06,0x52,0x80,0x11,0x40,	/* 5070: .(..R.@ */
	0x00,0x06,0x49,0xEB,0x00,0x06,0x70,0x00,	/* 5078: ..I..p. */
	0x78,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 5080: x..,.. */
	0x10,0x14,0x38,0x00,0x20,0x44,0x20,0x2E,	/* 5088: ..8. D . */
	0xFF,0xE0,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 5090: .. */
	0xE5,0x88,0x10,0x80,0x20,0x44,0xD1,0xFC,	/* 5098: . D */
	0x04,0x01,0xF0,0xCE,0x10,0x10,0xC0,0xBC,	/* 50A0: .... */
	0x00,0x00,0x00,0xFF,0x3D,0x40,0xFF,0xDE,	/* 50A8: ...=@ */
	0x30,0x2E,0xFF,0xDE,0xC0,0xBC,0x00,0x00,	/* 50B0: 0... */
	0x00,0x01,0x67,0x00,0x09,0x14,0x20,0x44,	/* 50B8: ..g... D */
	0xD1,0xFC,0x04,0x01,0xF0,0xD6,0x10,0x10,	/* 50C0: .... */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 50C8:  D.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x3D,0x40,	/* 50D0: ...=@ */
	0xFF,0xF0,0x10,0x10,0x20,0x44,0xD1,0xFC,	/* 50D8: .. D */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 50E0: .... */
	0x00,0xFF,0x3D,0x40,0xFF,0xF4,0x34,0x2E,	/* 50E8: .=@4. */
	0xFF,0xF0,0xC4,0xBC,0x00,0x00,0x00,0x03,	/* 50F0: .... */
	0x10,0x82,0x20,0x44,0xD1,0xFC,0x04,0x01,	/* 50F8: . D.. */
	0xF0,0x86,0x1E,0x10,0xCE,0xBC,0x00,0x00,	/* 5100: .... */
	0x00,0x07,0xCE,0xBC,0x00,0x00,0xFF,0xFF,	/* 5108: .... */
	0x20,0x07,0x57,0x80,0x67,0x0A,0x59,0x80,	/* 5110:  .Wg.Y */
	0x67,0x00,0x06,0x5E,0x60,0x00,0x08,0xB2,	/* 5118: g..^`.. */
	0x70,0x00,0x22,0x2E,0xFF,0xE0,0x30,0x02,	/* 5120: p.".0. */
	0xE5,0x89,0xD0,0x81,0x49,0xF3,0x0A,0x0A,	/* 5128: I.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 5130: p..,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0x2A,0x41,	/* 5138: ..r.2.*A */
	0xDB,0xFC,0x01,0x01,0x80,0x00,0x4A,0x2D,	/* 5140: ...J- */
	0x00,0x27,0x66,0x06,0x08,0xED,0x00,0x00,	/* 5148: .'f.... */
	0x00,0x28,0x7E,0x00,0x70,0x00,0x49,0xED,	/* 5150: .(~.p.I */
	0x00,0x08,0x74,0x00,0x20,0x44,0x1E,0x2D,	/* 5158: ..t. D.- */
	0x00,0x0A,0x10,0x2D,0x00,0x0B,0xD1,0xFC,	/* 5160: ...-.. */
	0x04,0x01,0xF0,0x1C,0x3D,0x40,0xFF,0xFE,	/* 5168: ...=@ */
	0x14,0x2C,0x00,0x01,0x30,0x2E,0xFF,0xFE,	/* 5170: .,..0. */
	0xE1,0x8A,0x14,0x14,0x32,0x07,0x52,0x81,	/* 5178: ..2.R */
	0x90,0x81,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5180: ... */
	0x24,0x40,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 5188: $@p.3.. */
	0x61,0xF6,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 5190: a.... */
	0x00,0xFF,0x3D,0x40,0xFF,0xFC,0x70,0x00,	/* 5198: .=@p. */
	0x30,0x2E,0xFF,0xFC,0xB5,0xC0,0x6F,0x06,	/* 51A0: 0.o. */
	0x3C,0x2E,0xFF,0xFC,0x60,0x02,0x2C,0x0A,	/* 51A8: <.`.,. */
	0xCC,0xBC,0x00,0x00,0xFF,0xFF,0x26,0x06,	/* 51B0: ..&. */
	0x67,0x00,0x04,0x66,0x30,0x2E,0xFF,0xFC,	/* 51B8: g..f0. */
	0x90,0x83,0x3D,0x40,0xFF,0xFC,0x20,0x03,	/* 51C0: =@ . */
	0xB0,0xBC,0x00,0x00,0x00,0x20,0x62,0x00,	/* 51C8: ... b. */
	0x04,0x4C,0x20,0x7B,0x0C,0x04,0x4E,0xD0,	/* 51D0: .L {..N */
	0x00,0x00,0x56,0x1C,0x00,0x00,0x55,0xFE,	/* 51D8: ..V...U */
	0x00,0x00,0x55,0xE0,0x00,0x00,0x55,0xC2,	/* 51E0: ..U..U */
	0x00,0x00,0x55,0xA4,0x00,0x00,0x55,0x86,	/* 51E8: ..U..U */
	0x00,0x00,0x55,0x68,0x00,0x00,0x55,0x4A,	/* 51F0: ..Uh..UJ */
	0x00,0x00,0x55,0x2C,0x00,0x00,0x55,0x0E,	/* 51F8: ..U,..U. */
	0x00,0x00,0x54,0xF0,0x00,0x00,0x54,0xD2,	/* 5200: ..T..T */
	0x00,0x00,0x54,0xB4,0x00,0x00,0x54,0x96,	/* 5208: ..T..T */
	0x00,0x00,0x54,0x78,0x00,0x00,0x54,0x5A,	/* 5210: ..Tx..TZ */
	0x00,0x00,0x54,0x3C,0x00,0x00,0x54,0x1E,	/* 5218: ..T<..T. */
	0x00,0x00,0x54,0x00,0x00,0x00,0x53,0xE2,	/* 5220: ..T...S */
	0x00,0x00,0x53,0xC4,0x00,0x00,0x53,0xA6,	/* 5228: ..S..S */
	0x00,0x00,0x53,0x88,0x00,0x00,0x53,0x6A,	/* 5230: ..S..Sj */
	0x00,0x00,0x53,0x4C,0x00,0x00,0x53,0x2E,	/* 5238: ..SL..S. */
	0x00,0x00,0x53,0x10,0x00,0x00,0x52,0xF2,	/* 5240: ..S...R */
	0x00,0x00,0x52,0xD4,0x00,0x00,0x52,0xB6,	/* 5248: ..R..R */
	0x00,0x00,0x52,0x98,0x00,0x00,0x52,0x7A,	/* 5250: ..R..Rz */
	0x00,0x00,0x52,0x5C,0x20,0x4D,0x70,0x00,	/* 5258: ..R\ Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5260: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5268: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5270: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5278: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5280: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5288: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5290: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5298:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 52A0: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 52A8: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 52B0: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 52B8: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 52C0: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 52C8: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 52D0: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 52D8: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 52E0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 52E8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 52F0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 52F8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5300: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5308: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5310:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5318: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5320: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5328: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5330: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5338: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5340: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5348: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5350: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5358: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5360: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5368: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5370: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5378: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5380: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5388:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5390: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5398: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 53A0: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 53A8: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 53B0: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 53B8: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 53C0: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 53C8: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 53D0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 53D8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 53E0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 53E8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 53F0: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 53F8: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5400:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5408: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5410: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5418: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5420: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5428: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5430: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5438: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5440: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5448: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5450: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5458: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5460: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5468: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5470: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5478:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5480: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5488: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5490: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5498: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 54A0: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 54A8: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 54B0: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 54B8: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 54C0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 54C8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 54D0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 54D8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 54E0: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 54E8: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 54F0:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 54F8: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5500: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5508: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5510: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5518: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5520: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5528: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5530: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5538: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5540: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5548: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5550: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5558: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5560: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5568:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5570: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5578: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5580: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5588: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5590: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5598: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 55A0: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 55A8: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 55B0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 55B8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 55C0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 55C8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 55D0: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 55D8: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 55E0:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 55E8: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 55F0: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 55F8: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5600: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5608: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5610: ....@ */
	0x01,0x60,0x52,0x87,0x1B,0x47,0x00,0x0A,	/* 5618: .`R.G.. */
	0x49,0xED,0x00,0x3E,0x70,0x00,0x7C,0x00,	/* 5620: I.>p.|. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 5628: .,.... */
	0x32,0x2E,0xFF,0xFC,0xD0,0x81,0x3C,0x00,	/* 5630: 2.<. */
	0x20,0x06,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 5638:  ..@.. */
	0x18,0x86,0x70,0x00,0x30,0x2E,0xFF,0xFC,	/* 5640: .p.0. */
	0x4A,0x80,0x67,0x24,0x2C,0x3C,0x04,0x01,	/* 5648: Jg$,<.. */
	0xF0,0xC4,0x30,0x2E,0xFF,0xFC,0x20,0x44,	/* 5650: 0. D */
	0xD1,0xC6,0xD0,0xBC,0x00,0x00,0xFF,0xFF,	/* 5658: .. */
	0x3D,0x40,0xFF,0xFC,0x10,0x10,0x70,0x00,	/* 5660: =@..p. */
	0x30,0x2E,0xFF,0xFC,0x4A,0x80,0x66,0xE2,	/* 5668: 0.Jf */
	0x30,0x2E,0xFF,0xFC,0xD0,0xBC,0x00,0x00,	/* 5670: 0... */
	0xFF,0xFF,0x3D,0x40,0xFF,0xFC,0x3C,0x2E,	/* 5678: =@<. */
	0xFF,0xFE,0x30,0x02,0x32,0x07,0x52,0x81,	/* 5680: 0.2.R */
	0x9C,0x81,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 5688: ... */
	0xC0,0xBC,0x00,0x00,0x00,0x08,0x67,0x00,	/* 5690: ....g. */
	0x00,0xA2,0x70,0x40,0xB0,0x8A,0x6E,0x00,	/* 5698: .p@n. */
	0x00,0x9A,0xCC,0xBC,0x00,0x00,0xFF,0xFF,	/* 56A0: ... */
	0x70,0x40,0xB0,0x86,0x6F,0x00,0x00,0x8C,	/* 56A8: p@o.. */
	0x84,0xBC,0x00,0x00,0x00,0x10,0x08,0x2D,	/* 56B0: .....- */
	0x00,0x03,0x00,0x30,0x67,0x48,0x30,0x02,	/* 56B8: ...0gH0. */
	0xC0,0xBC,0x00,0x00,0x00,0x20,0x66,0x3E,	/* 56C0: ... f> */
	0x2E,0x3C,0x04,0x01,0xF0,0x0A,0x20,0x44,	/* 56C8: .<... D */
	0xD1,0xC7,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 56D0: .... */
	0x00,0xFF,0x4A,0x00,0x66,0x22,0x42,0xA7,	/* 56D8: .J.f"B */
	0x48,0x78,0x01,0x00,0x2F,0x0D,0x4E,0xB9,	/* 56E0: Hx....N */
	0x00,0x00,0x23,0x48,0x20,0x44,0x70,0x22,	/* 56E8: ..#H Dp" */
	0x4F,0xEF,0x00,0x0C,0xD1,0xC7,0x10,0x80,	/* 56F0: O... */
	0x84,0xBC,0x00,0x00,0x00,0x20,0x60,0x06,	/* 56F8: ... `. */
	0x84,0xBC,0x00,0x00,0x00,0xC0,0x08,0x2D,	/* 5700: ....- */
	0x00,0x07,0x00,0x31,0x67,0x12,0x42,0xA7,	/* 5708: ...1g.B */
	0x48,0x78,0x10,0x00,0x2F,0x0D,0x4E,0xB9,	/* 5710: Hx....N */
	0x00,0x00,0x23,0x48,0x4F,0xEF,0x00,0x0C,	/* 5718: ..#HO.. */
	0x08,0x2D,0x00,0x06,0x00,0x30,0x67,0x12,	/* 5720: .-...0g. */
	0x42,0xA7,0x48,0x78,0x20,0x00,0x2F,0x0D,	/* 5728: BHx ... */
	0x4E,0xB9,0x00,0x00,0x23,0x48,0x4F,0xEF,	/* 5730: N..#HO */
	0x00,0x0C,0x20,0x44,0x30,0x2E,0xFF,0xF0,	/* 5738: .. D0. */
	0x49,0xED,0x00,0x08,0xC4,0xBC,0x00,0x00,	/* 5740: I.... */
	0xFF,0xFF,0xD1,0xFC,0x04,0x01,0xF0,0xD6,	/* 5748: .. */
	0x2A,0x42,0xC0,0xBC,0x00,0x00,0x00,0x3F,	/* 5750: *B...? */
	0x10,0x80,0x20,0x44,0x30,0x2E,0xFF,0xF4,	/* 5758: . D0. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0x10,0x80,	/* 5760: ... */
	0x20,0x0D,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 5768:  ..@.. */
	0x20,0x0D,0x18,0x80,0x60,0x00,0x02,0x5A,	/* 5770:  ..`..Z */
	0x7E,0x00,0x70,0x00,0x22,0x2E,0xFF,0xE0,	/* 5778: ~.p.". */
	0x20,0x44,0x30,0x02,0x24,0x3C,0x04,0x01,	/* 5780:  D0.$<.. */
	0xF0,0xC4,0xE5,0x89,0xD1,0xC2,0xD0,0x81,	/* 5788:  */
	0x49,0xF3,0x0A,0x0A,0x70,0x00,0x10,0x2C,	/* 5790: I..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 5798: ....r. */
	0x32,0x00,0x2A,0x41,0x10,0x10,0xDB,0xFC,	/* 57A0: 2.*A.. */
	0x01,0x01,0x80,0x00,0x20,0x44,0xD1,0xC2,	/* 57A8: ... D */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x1D,0x40,	/* 57B0: ....@ */
	0xFF,0xFE,0x14,0x10,0x10,0x2E,0xFF,0xFE,	/* 57B8: .... */
	0xC4,0xBC,0x00,0x00,0x00,0xFF,0x08,0x00,	/* 57C0: ..... */
	0x00,0x03,0x67,0x0E,0x08,0xED,0x00,0x00,	/* 57C8: ..g.... */
	0x00,0x19,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 57D0: ..p.3.. */
	0x61,0xF4,0x70,0x00,0x10,0x2E,0xFF,0xFE,	/* 57D8: ap... */
	0x72,0x07,0xC2,0x80,0x67,0x10,0x08,0x2D,	/* 57E0: r.g..- */
	0x00,0x07,0x00,0x20,0x67,0x08,0x70,0x01,	/* 57E8: ... g.p. */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x10,0x2E,	/* 57F0: 3..a.. */
	0xFF,0xFE,0x08,0x00,0x00,0x00,0x67,0x22,	/* 57F8: ....g" */
	0x49,0xED,0x00,0x3C,0x70,0x00,0x10,0x2C,	/* 5800: I.<p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 5808: ....r. */
	0x52,0x80,0x32,0x00,0x24,0x41,0x20,0x0A,	/* 5810: R2.$A . */
	0xE0,0x80,0x19,0x40,0x00,0x01,0x20,0x0A,	/* 5818: .@.. . */
	0x18,0x80,0x10,0x2E,0xFF,0xFE,0x08,0x00,	/* 5820: ..... */
	0x00,0x01,0x67,0x20,0x49,0xED,0x00,0x38,	/* 5828: ..g I.8 */
	0x70,0x00,0x7E,0x00,0x10,0x2C,0x00,0x01,	/* 5830: p.~..,.. */
	0xE1,0x88,0x10,0x14,0x52,0x80,0x3E,0x00,	/* 5838: ..R>. */
	0x20,0x07,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 5840:  ..@.. */
	0x18,0x87,0x7E,0x01,0x10,0x2E,0xFF,0xFE,	/* 5848: .~... */
	0x08,0x00,0x00,0x02,0x67,0x20,0x49,0xED,	/* 5850: ....g I */
	0x00,0x3A,0x70,0x00,0x7E,0x00,0x10,0x2C,	/* 5858: .:p.~.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x52,0x80,	/* 5860: ....R */
	0x3E,0x00,0x20,0x07,0xE0,0x80,0x19,0x40,	/* 5868: >. ..@ */
	0x00,0x01,0x18,0x87,0x7E,0x01,0x4A,0x87,	/* 5870: ...~.J */
	0x67,0x00,0x01,0x34,0x08,0x2D,0x00,0x06,	/* 5878: g..4.-.. */
	0x00,0x20,0x67,0x04,0x14,0x2D,0x00,0x2B,	/* 5880: . g..-.+ */
	0x7E,0x00,0x70,0x00,0x49,0xED,0x00,0x08,	/* 5888: ~.p.I.. */
	0x1E,0x2D,0x00,0x0A,0x10,0x2D,0x00,0x0B,	/* 5890: .-...-.. */
	0x3D,0x40,0xFF,0xE6,0x70,0x00,0x10,0x2C,	/* 5898: =@p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x3D,0x40,	/* 58A0: ....=@ */
	0xFF,0xFE,0x3C,0x2E,0xFF,0xE6,0x32,0x07,	/* 58A8: <.2. */
	0x52,0x81,0x9C,0x81,0xCC,0xBC,0x00,0x00,	/* 58B0: R.. */
	0x00,0xFF,0x67,0x00,0x00,0xD0,0x20,0x4D,	/* 58B8: .g.. M */
	0x70,0x00,0x10,0x07,0xD1,0xC0,0x11,0x42,	/* 58C0: p....B */
	0x01,0x60,0x52,0x87,0x1B,0x47,0x00,0x0A,	/* 58C8: .`R.G.. */
	0x34,0x2E,0xFF,0xE6,0x32,0x07,0x52,0x81,	/* 58D0: 4.2.R */
	0x94,0x81,0x30,0x2E,0xFF,0xFE,0xC4,0xBC,	/* 58D8: 0. */
	0x00,0x00,0x00,0xFF,0xC0,0xBC,0x00,0x00,	/* 58E0: ..... */
	0x00,0x08,0x67,0x00,0x00,0xC2,0x70,0x40,	/* 58E8: ..g..p@ */
	0xB0,0x86,0x6E,0x00,0x00,0xBA,0xC4,0xBC,	/* 58F0: n.. */
	0x00,0x00,0xFF,0xFF,0x70,0x40,0xB0,0x82,	/* 58F8: ..p@ */
	0x6F,0x00,0x00,0xAC,0x30,0x2E,0xFF,0xFE,	/* 5900: o..0. */
	0x80,0xBC,0x00,0x00,0x00,0x10,0x3D,0x40,	/* 5908: ....=@ */
	0xFF,0xFE,0x08,0x2D,0x00,0x03,0x00,0x30,	/* 5910: .-...0 */
	0x67,0x3C,0x30,0x2E,0xFF,0xFE,0xC0,0xBC,	/* 5918: g<0. */
	0x00,0x00,0x00,0x20,0x66,0x30,0x24,0x3C,	/* 5920: ... f0$< */
	0x04,0x01,0xF0,0x0A,0x20,0x44,0xD1,0xC2,	/* 5928: ... D */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5930: ..... */
	0x4A,0x00,0x66,0x1A,0x42,0xA7,0x48,0x78,	/* 5938: J.f.BHx */
	0x01,0x00,0x2F,0x0D,0x4E,0xB9,0x00,0x00,	/* 5940: ....N.. */
	0x23,0x48,0x20,0x44,0xD1,0xC2,0x70,0x22,	/* 5948: #H Dp" */
	0x10,0x80,0x4F,0xEF,0x00,0x0C,0x08,0x2D,	/* 5950: .O...- */
	0x00,0x07,0x00,0x31,0x67,0x12,0x42,0xA7,	/* 5958: ...1g.B */
	0x48,0x78,0x10,0x00,0x2F,0x0D,0x4E,0xB9,	/* 5960: Hx....N */
	0x00,0x00,0x23,0x48,0x4F,0xEF,0x00,0x0C,	/* 5968: ..#HO.. */
	0x08,0x2D,0x00,0x06,0x00,0x30,0x67,0x36,	/* 5970: .-...0g6 */
	0x42,0xA7,0x48,0x78,0x20,0x00,0x2F,0x0D,	/* 5978: BHx ... */
	0x4E,0xB9,0x00,0x00,0x23,0x48,0x4F,0xEF,	/* 5980: N..#HO */
	0x00,0x0C,0x60,0x22,0x49,0xED,0x00,0x3E,	/* 5988: ..`"I.> */
	0x70,0x00,0x74,0x00,0x10,0x2C,0x00,0x01,	/* 5990: p.t..,.. */
	0xE1,0x88,0x10,0x14,0x32,0x2E,0xFF,0xFC,	/* 5998: ..2. */
	0xD0,0x81,0x34,0x00,0x20,0x02,0xE0,0x80,	/* 59A0: 4. . */
	0x19,0x40,0x00,0x01,0x18,0x82,0x20,0x44,	/* 59A8: .@... D */
	0x30,0x2E,0xFF,0xF0,0xD1,0xFC,0x04,0x01,	/* 59B0: 0... */
	0xF0,0xD6,0xC0,0xBC,0x00,0x00,0x00,0x3F,	/* 59B8: ...? */
	0x10,0x80,0x20,0x44,0x30,0x2E,0xFF,0xF4,	/* 59C0: . D0. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0x10,0x80,	/* 59C8: ... */
	0x30,0x2E,0xFF,0xDE,0xC0,0xBC,0x00,0x00,	/* 59D0: 0... */
	0x00,0x02,0x67,0x00,0x05,0xD2,0x20,0x44,	/* 59D8: ..g.. D */
	0xD1,0xFC,0x04,0x01,0xF0,0xD4,0x10,0x10,	/* 59E0: .... */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 59E8:  D.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x3D,0x40,	/* 59F0: ...=@ */
	0xFF,0xF0,0x10,0x10,0x20,0x44,0xD1,0xFC,	/* 59F8: .. D */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 5A00: .... */
	0x00,0xFF,0x3D,0x40,0xFF,0xEC,0x34,0x2E,	/* 5A08: .=@4. */
	0xFF,0xF0,0x70,0x00,0xC4,0xBC,0x00,0x00,	/* 5A10: p... */
	0x00,0x03,0x10,0x82,0x30,0x02,0x22,0x2E,	/* 5A18: ...0.". */
	0xFF,0xE0,0xE5,0x89,0xD0,0x81,0x49,0xF3,	/* 5A20: I */
	0x0A,0x0A,0x70,0x00,0x10,0x2C,0x00,0x01,	/* 5A28: ..p..,.. */
	0xE1,0x88,0x10,0x14,0x72,0x00,0x32,0x00,	/* 5A30: ..r.2. */
	0x2A,0x41,0xDB,0xFC,0x01,0x01,0x80,0x00,	/* 5A38: *A... */
	0x4A,0x2D,0x00,0x27,0x66,0x06,0x08,0xED,	/* 5A40: J-.'f.. */
	0x00,0x01,0x00,0x28,0x4A,0x2D,0x00,0x35,	/* 5A48: ...(J-.5 */
	0x67,0x1A,0x2F,0x0D,0x61,0x00,0xF3,0x96,	/* 5A50: g...a. */
	0x49,0xED,0x00,0x08,0x74,0x00,0x58,0x8F,	/* 5A58: I..t.X */
	0x14,0x2C,0x00,0x01,0xE1,0x8A,0x14,0x14,	/* 5A60: .,.... */
	0x60,0x00,0x05,0x0A,0x70,0x00,0x7E,0x00,	/* 5A68: `...p.~. */
	0x49,0xED,0x00,0x08,0x74,0x00,0x10,0x2D,	/* 5A70: I..t..- */
	0x00,0x0D,0x3D,0x40,0xFF,0xFE,0x14,0x2C,	/* 5A78: ..=@., */
	0x00,0x01,0x1E,0x2D,0x00,0x0C,0xE1,0x8A,	/* 5A80: ...-.. */
	0x14,0x14,0x30,0x02,0xC0,0xBC,0x00,0x00,	/* 5A88: ..0... */
	0x01,0x00,0x67,0x2A,0xC4,0xBC,0x00,0x00,	/* 5A90: ..g*.. */
	0xFE,0xFF,0x28,0x7C,0x04,0x01,0xF0,0x0C,	/* 5A98: (|... */
	0x20,0x44,0x22,0x44,0x84,0xBC,0x00,0x00,	/* 5AA0:  D"D.. */
	0x02,0x00,0xD1,0xCC,0xD3,0xCC,0xC4,0xBC,	/* 5AA8: .. */
	0x00,0x00,0xFF,0xFE,0x10,0x11,0xC0,0xBC,	/* 5AB0: .... */
	0x00,0x00,0x00,0xF9,0x10,0x80,0x30,0x2E,	/* 5AB8: ....0. */
	0xFF,0xFE,0x90,0x87,0xC0,0xBC,0x00,0x00,	/* 5AC0: .. */
	0x00,0xFF,0x28,0x40,0x4A,0x8C,0x67,0x00,	/* 5AC8: .(@Jg. */
	0x04,0x38,0x70,0x00,0x10,0x2D,0x00,0x06,	/* 5AD0: .8p..-.. */
	0x72,0x48,0xB2,0x80,0x66,0x04,0x7C,0x20,	/* 5AD8: rHf.|  */
	0x60,0x02,0x7C,0x0C,0xCC,0xBC,0x00,0x00,	/* 5AE0: `.|... */
	0xFF,0xFF,0xB9,0xC6,0x6F,0x04,0x2A,0x06,	/* 5AE8: o.*. */
	0x60,0x02,0x2A,0x0C,0x1B,0x45,0x00,0x44,	/* 5AF0: `.*..E.D */
	0x30,0x02,0xC0,0xBC,0x00,0x00,0x04,0x00,	/* 5AF8: 0..... */
	0x67,0x00,0x00,0x8E,0xCA,0xBC,0x00,0x00,	/* 5B00: g.... */
	0xFF,0xFF,0x67,0x00,0x03,0xA0,0x26,0x3C,	/* 5B08: g..&< */
	0x04,0x01,0xF0,0xC6,0x70,0x00,0x72,0x00,	/* 5B10: ..p.r. */
	0x10,0x07,0x12,0x35,0x08,0x60,0x70,0x0A,	/* 5B18: ...5.`p. */
	0xB0,0x81,0x66,0x42,0x70,0x00,0x30,0x06,	/* 5B20: fBp.0. */
	0x55,0x80,0x6D,0x00,0x03,0x80,0x20,0x44,	/* 5B28: Um.. D */
	0x70,0x0D,0x52,0x87,0xDA,0xBC,0x00,0x00,	/* 5B30: p.R.. */
	0xFF,0xFF,0xDC,0xBC,0x00,0x00,0xFF,0xFE,	/* 5B38: .. */
	0xD1,0xC3,0x10,0x80,0x20,0x44,0x70,0x0A,	/* 5B40: . Dp. */
	0xD1,0xC3,0x10,0x80,0xCA,0xBC,0x00,0x00,	/* 5B48: ... */
	0xFF,0xFF,0x67,0x00,0x03,0x58,0x70,0x00,	/* 5B50: g..Xp. */
	0x72,0x00,0x10,0x07,0x12,0x35,0x08,0x60,	/* 5B58: r....5.` */
	0x70,0x0A,0xB0,0x81,0x67,0xBE,0x20,0x44,	/* 5B60: p.g D */
	0x70,0x00,0xDA,0xBC,0x00,0x00,0xFF,0xFF,	/* 5B68: p... */
	0xDC,0xBC,0x00,0x00,0xFF,0xFF,0xD1,0xC3,	/* 5B70: .. */
	0x10,0x07,0x10,0x35,0x08,0x60,0x52,0x87,	/* 5B78: ...5.`R */
	0x10,0x80,0xCA,0xBC,0x00,0x00,0xFF,0xFF,	/* 5B80: ... */
	0x66,0x00,0xFF,0x8A,0x60,0x00,0x03,0x1E,	/* 5B88: f.`... */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x20,0x05,	/* 5B90: .. . */
	0xB0,0xBC,0x00,0x00,0x00,0x20,0x62,0x00,	/* 5B98: ... b. */
	0x03,0x0C,0x20,0x7B,0x0C,0x04,0x4E,0xD0,	/* 5BA0: .. {..N */
	0x00,0x00,0x5E,0xAC,0x00,0x00,0x5E,0x98,	/* 5BA8: ..^..^ */
	0x00,0x00,0x5E,0x84,0x00,0x00,0x5E,0x70,	/* 5BB0: ..^..^p */
	0x00,0x00,0x5E,0x5C,0x00,0x00,0x5E,0x48,	/* 5BB8: ..^\..^H */
	0x00,0x00,0x5E,0x34,0x00,0x00,0x5E,0x20,	/* 5BC0: ..^4..^  */
	0x00,0x00,0x5E,0x0C,0x00,0x00,0x5D,0xF8,	/* 5BC8: ..^...] */
	0x00,0x00,0x5D,0xE4,0x00,0x00,0x5D,0xD0,	/* 5BD0: ..]..] */
	0x00,0x00,0x5D,0xBC,0x00,0x00,0x5D,0xA8,	/* 5BD8: ..]..] */
	0x00,0x00,0x5D,0x94,0x00,0x00,0x5D,0x80,	/* 5BE0: ..]..] */
	0x00,0x00,0x5D,0x6C,0x00,0x00,0x5D,0x58,	/* 5BE8: ..]l..]X */
	0x00,0x00,0x5D,0x44,0x00,0x00,0x5D,0x30,	/* 5BF0: ..]D..]0 */
	0x00,0x00,0x5D,0x1C,0x00,0x00,0x5D,0x08,	/* 5BF8: ..]...]. */
	0x00,0x00,0x5C,0xF4,0x00,0x00,0x5C,0xE0,	/* 5C00: ..\..\ */
	0x00,0x00,0x5C,0xCC,0x00,0x00,0x5C,0xB8,	/* 5C08: ..\..\ */
	0x00,0x00,0x5C,0xA4,0x00,0x00,0x5C,0x90,	/* 5C10: ..\..\ */
	0x00,0x00,0x5C,0x7C,0x00,0x00,0x5C,0x68,	/* 5C18: ..\|..\h */
	0x00,0x00,0x5C,0x54,0x00,0x00,0x5C,0x40,	/* 5C20: ..\T..\@ */
	0x00,0x00,0x5C,0x2C,0x20,0x44,0x70,0x00,	/* 5C28: ..\, Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5C30: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5C38: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5C40:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5C48: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5C50: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5C58: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5C60: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5C68:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5C70: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5C78: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5C80: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5C88: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5C90:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5C98: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5CA0: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5CA8: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5CB0: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5CB8:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5CC0: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5CC8: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5CD0: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5CD8: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5CE0:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5CE8: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5CF0: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5CF8: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D00: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D08:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D10: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D18: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D20: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D28: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D30:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D38: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D40: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D48: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D50: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D58:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D60: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D68: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D70: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D78: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D80:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D88: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D90: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D98: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5DA0: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5DA8:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5DB0: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5DB8: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5DC0: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5DC8: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5DD0:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5DD8: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5DE0: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5DE8: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5DF0: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5DF8:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E00: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E08: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E10: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E18: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E20:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E28: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E30: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E38: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E40: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E48:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E50: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E58: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E60: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E68: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E70:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E78: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E80: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E88: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E90: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E98:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5EA0: ...5.` */
	0x10,0x80,0x52,0x87,0xCE,0xBC,0x00,0x00,	/* 5EA8: .R.. */
	0x00,0xFF,0x30,0x2E,0xFF,0xFE,0x1B,0x47,	/* 5EB0: .0..G */
	0x00,0x0C,0x90,0x87,0xC0,0xBC,0x00,0x00,	/* 5EB8: .... */
	0x00,0xFF,0x2E,0x3C,0x00,0x00,0x00,0xC0,	/* 5EC0: ..<... */
	0x24,0x40,0xB9,0xC7,0x6F,0x0C,0xB5,0xC7,	/* 5EC8: $@o. */
	0x6E,0x0E,0x84,0xBC,0x00,0x00,0x08,0x00,	/* 5ED0: n..... */
	0x60,0x24,0x70,0x40,0xB0,0x8C,0x6C,0x1E,	/* 5ED8: `$p@l. */
	0x70,0x40,0xB0,0x8A,0x6D,0x18,0x30,0x02,	/* 5EE0: p@m.0. */
	0xC0,0xBC,0x00,0x00,0x08,0x00,0x67,0x0E,	/* 5EE8: ....g. */
	0xC4,0xBC,0x00,0x00,0xF7,0xFF,0x70,0x01,	/* 5EF0: ..p. */
	0x33,0xC0,0x00,0x00,0x61,0xF4,0x08,0xED,	/* 5EF8: 3..a. */
	0x00,0x00,0x00,0x41,0x60,0x00,0x00,0x6E,	/* 5F00: ...A`..n */
	0x2E,0x3C,0x04,0x01,0xF0,0x0C,0x20,0x44,	/* 5F08: .<... D */
	0xD1,0xC7,0x10,0x10,0x08,0x00,0x00,0x02,	/* 5F10: ...... */
	0x67,0x20,0x70,0x02,0x20,0x44,0x22,0x44,	/* 5F18: g p. D"D */
	0x1B,0x40,0x00,0x44,0xD1,0xC7,0xD3,0xC7,	/* 5F20: .@.D */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFB,	/* 5F28: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x02,0x10,0x80,	/* 5F30: ..... */
	0x60,0x3A,0x42,0x2D,0x00,0x44,0xC4,0xBC,	/* 5F38: `:B-.D */
	0x00,0x00,0xFF,0xFE,0x20,0x44,0x22,0x44,	/* 5F40: .. D"D */
	0xD1,0xC7,0xD3,0xC7,0x10,0x11,0xC0,0xBC,	/* 5F48: .. */
	0x00,0x00,0x00,0xF9,0x10,0x80,0x1E,0x2D,	/* 5F50: .....- */
	0x00,0x41,0x08,0x07,0x00,0x00,0x67,0x14,	/* 5F58: .A....g. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x61,0xF4,	/* 5F60: p.3..a */
	0x10,0x07,0xC0,0xBC,0x00,0x00,0x00,0xFE,	/* 5F68: ..... */
	0x1B,0x40,0x00,0x41,0x20,0x44,0x30,0x2E,	/* 5F70: .@.A D0. */
	0xFF,0xF0,0x49,0xED,0x00,0x08,0xC4,0xBC,	/* 5F78: I.. */
	0x00,0x00,0xFF,0xFF,0xD1,0xFC,0x04,0x01,	/* 5F80: .... */
	0xF0,0xD4,0x2A,0x42,0xC0,0xBC,0x00,0x00,	/* 5F88: *B.. */
	0x00,0x3F,0x10,0x80,0x20,0x44,0x30,0x2E,	/* 5F90: .?. D0. */
	0xFF,0xEC,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 5F98: .. */
	0x10,0x80,0x20,0x0D,0xE0,0x80,0x19,0x40,	/* 5FA0: . ..@ */
	0x00,0x01,0x20,0x0D,0x18,0x80,0x30,0x2E,	/* 5FA8: .. ..0. */
	0xFF,0xDE,0xC0,0xBC,0x00,0x00,0x00,0x04,	/* 5FB0: .... */
	0x67,0x00,0x00,0xB0,0x20,0x44,0xD1,0xFC,	/* 5FB8: g.. D */
	0x04,0x01,0xF0,0xD2,0x10,0x10,0x20,0x44,	/* 5FC0: .... D */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 5FC8: .. */
	0x00,0x00,0x00,0xFF,0x3D,0x40,0xFF,0xEC,	/* 5FD0: ...=@ */
	0x10,0x10,0x20,0x44,0xD1,0xFC,0x04,0x01,	/* 5FD8: .. D.. */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5FE0: ... */
	0x3D,0x40,0xFF,0xF4,0x34,0x2E,0xFF,0xEC,	/* 5FE8: =@4. */
	0x70,0x00,0xC4,0xBC,0x00,0x00,0x00,0x03,	/* 5FF0: p..... */
	0x10,0x82,0x30,0x02,0x22,0x2E,0xFF,0xE0,	/* 5FF8: .0.". */
	0xE5,0x89,0xD0,0x81,0x49,0xF3,0x0A,0x0A,	/* 6000: I.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 6008: p..,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0x2A,0x41,	/* 6010: ..r.2.*A */
	0xDB,0xFC,0x01,0x01,0x80,0x00,0x2F,0x0D,	/* 6018: ..... */
	0x61,0x00,0xEF,0x82,0x2F,0x0D,0x4E,0xB9,	/* 6020: a...N */
	0x00,0x00,0x2A,0xF8,0x50,0x8F,0x4A,0x2D,	/* 6028: ..*PJ- */
	0x00,0x27,0x66,0x06,0x08,0xED,0x00,0x02,	/* 6030: .'f.... */
	0x00,0x28,0x70,0x01,0x20,0x44,0x33,0xC0,	/* 6038: .(p. D3 */
	0x00,0x00,0x61,0xF4,0xD1,0xFC,0x04,0x01,	/* 6040: ..a.. */
	0xF0,0xD2,0x08,0xED,0x00,0x01,0x00,0x19,	/* 6048: ..... */
	0x30,0x2E,0xFF,0xEC,0xC0,0xBC,0x00,0x00,	/* 6050: 0... */
	0x00,0x3F,0x10,0x80,0x20,0x44,0x30,0x2E,	/* 6058: .?. D0. */
	0xFF,0xF4,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 6060: .. */
	0x10,0x80,0x20,0x44,0x10,0x2B,0x00,0x09,	/* 6068: . D.+.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xFE,0x10,0x80,	/* 6070: ... */
	0x20,0x2E,0xFF,0xE0,0x72,0x00,0x52,0x80,	/* 6078:  .r.R */
	0x32,0x00,0x2D,0x41,0xFF,0xE0,0x20,0x2E,	/* 6080: 2.-A . */
	0xFF,0xE0,0x55,0x80,0x6D,0x30,0x70,0x00,	/* 6088: Um0p. */
	0x78,0x00,0x2D,0x40,0xFF,0xE0,0x70,0x00,	/* 6090: x.-@p. */
	0x10,0x2B,0x00,0x01,0xE1,0x88,0x10,0x13,	/* 6098: .+.... */
	0x38,0x00,0x4A,0x84,0x67,0x12,0x20,0x3C,	/* 60A0: 8.Jg. < */
	0xFF,0xFF,0x7F,0xFF,0xC0,0x84,0x26,0x40,	/* 60A8: &@ */
	0xD7,0xFC,0x01,0x01,0x80,0x00,0x60,0x06,	/* 60B0: ...`. */
	0x26,0x7C,0x01,0x01,0x80,0x80,0x70,0x00,	/* 60B8: &|..p. */
	0x30,0x2E,0xFF,0xDE,0x4A,0x80,0x66,0x14,	/* 60C0: 0.Jf. */
	0x20,0x0B,0xB0,0xBC,0x01,0x01,0x80,0x80,	/* 60C8:  ... */
	0x66,0x00,0xEF,0xA8,0x4A,0xAE,0xFF,0xE0,	/* 60D0: f.J */
	0x66,0x00,0xEF,0xA0,0x4C,0xD7,0x3C,0xFC,	/* 60D8: f.L< */
	0x4F,0xEF,0x00,0x28,0x4E,0x5E,0x4E,0x75,	/* 60E0: O.(N^Nu */
	0x4F,0xEF,0xFF,0xF0,0x70,0x07,0x48,0xD7,	/* 60E8: Op.H */
	0x30,0xC0,0x2C,0x2F,0x00,0x14,0x2A,0x6F,	/* 60F0: 0,...*o */
	0x00,0x18,0x2E,0x2F,0x00,0x1C,0x28,0x46,	/* 60F8: ......(F */
	0xB0,0x87,0x64,0x42,0x70,0x04,0x72,0x03,	/* 6100: dBp.r. */
	0x90,0x86,0xC2,0x80,0x9E,0x81,0x4A,0x81,	/* 6108: J */
	0x67,0x06,0x18,0xDD,0x53,0x81,0x66,0xFA,	/* 6110: g..Sf */
	0x20,0x0D,0x72,0x03,0xC2,0x80,0x66,0x26,	/* 6118:  .r.f& */
	0x22,0x07,0xE4,0x89,0xCE,0xBC,0x00,0x00,	/* 6120: "... */
	0x00,0x03,0x4A,0x81,0x67,0x12,0x70,0x00,	/* 6128: ..Jg.p. */
	0x22,0x4C,0x20,0x4D,0xD3,0xC0,0xD1,0xC0,	/* 6130: "L M */
	0x20,0x01,0x22,0xD8,0x53,0x80,0x66,0xFA,	/* 6138:  ."Sf */
	0xE5,0x89,0xD9,0xC1,0xDB,0xC1,0x4A,0x87,	/* 6140: J */
	0x67,0x06,0x18,0xDD,0x53,0x87,0x66,0xFA,	/* 6148: g..Sf */
	0x20,0x06,0x4C,0xD7,0x30,0xC0,0x4F,0xEF,	/* 6150:  .L0O */
	0x00,0x10,0x4E,0x75,0x4F,0xEF,0xFF,0xF4,	/* 6158: ..NuO */
	0x70,0x00,0x48,0xD7,0x20,0xA0,0x20,0x6F,	/* 6160: p.H  o */
	0x00,0x10,0x2A,0x2F,0x00,0x14,0x2E,0x2F,	/* 6168: ..*..... */
	0x00,0x18,0x2A,0x48,0x10,0x05,0x2A,0x00,	/* 6170: ..*H..*. */
	0x70,0x07,0xB0,0x87,0x64,0x44,0x2F,0x06,	/* 6178: p.dD.. */
	0x22,0x05,0x70,0x04,0x7C,0x03,0xE1,0x89,	/* 6180: ".p.|. */
	0x90,0x88,0x82,0x85,0xCC,0x80,0xE1,0x89,	/* 6188:  */
	0x9E,0x86,0x82,0x85,0xE1,0x89,0x82,0x85,	/* 6190:  */
	0x4A,0x86,0x67,0x06,0x1A,0xC5,0x53,0x86,	/* 6198: Jg..S */
	0x66,0xFA,0x2C,0x07,0xE4,0x8E,0xCE,0xBC,	/* 61A0: f,. */
	0x00,0x00,0x00,0x03,0x4A,0x86,0x67,0x0A,	/* 61A8: ....Jg. */
	0x22,0x4D,0x20,0x06,0x22,0xC1,0x53,0x80,	/* 61B0: "M ."S */
	0x66,0xFA,0x20,0x06,0xE5,0x88,0xDB,0xC0,	/* 61B8: f . */
	0x2C,0x1F,0x4A,0x87,0x67,0x06,0x1A,0xC5,	/* 61C0: ,.Jg.. */
	0x53,0x87,0x66,0xFA,0x20,0x08,0x4C,0xD7,	/* 61C8: Sf .L */
	0x20,0xA0,0x4F,0xEF,0x00,0x0C,0x4E,0x75,	/* 61D0:  O..Nu */
	0x4E,0x75,0x4E,0x75,0x00,0x00,0x00,0x00,	/* 61D8: NuNu.... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 61E0: ........ */
	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 61E8: ........ */
	0x10,0x00,0x01,0x00,0x00,0x00,0x00,0x00,	/* 61F0: ........ */
	0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x01,	/* 61F8: ....... */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x0A,	/* 6200: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 6208: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x09,	/* 6210: ........ */
	0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x06,	/* 6218: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x03,	/* 6220: ........ */
	0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,	/* 6228: ........ */
	0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x01,	/* 6230: ....... */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x0A,	/* 6238: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 6240: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x09,	/* 6248: ........ */
	0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x06,	/* 6250: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x03,	/* 6258: ........ */
	0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,	/* 6260: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 6268: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xF0,	/* 6270: ....... */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 6278: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x06,	/* 6280: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 6288: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 6290: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,	/* 6298: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,	/* 62A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 62A8: ........ */
	0x00,0x00,0x0F,0xA4,0x00,0x00,0x00,0x00,	/* 62B0: ....... */
	0x00,0x00,0x0F,0xA4,0x00,0x00,0x00,0x00,	/* 62B8: ....... */
	0x00,0x00,0x30,0x74,0x00,0x00,0x00,0x00,	/* 62C0: ..0t.... */
	0x00,0x00,0x0F,0xA4,0x00,0x00,0x00,0x00,	/* 62C8: ....... */
	0x00,0x00,0x18,0x64,0x00,0x00,0x00,0x00,	/* 62D0: ...d.... */
	0x00,0x00,0x30,0xFC,0x00,0x00,0x00,0x00,	/* 62D8: ..0.... */
	0x00,0x00,0x31,0xD4,0x00,0x00,0x00,0x00,	/* 62E0: ..1.... */
	0x00,0x00,0x31,0xF4,0x00,0x00,0x00,0x00,	/* 62E8: ..1.... */
	0x00,0x00,0x31,0xF8,0x00,0x00,0x00,0x00,	/* 62F0: ..1.... */
	0x00,0x00,0x19,0xD8,0x00,0x00,0x00,0x00,	/* 62F8: ....... */
	0x00,0x00,0x1D,0xA0,0x00,0x00,0x00,0x00,	/* 6300: ....... */
	0x00,0x00,0x1E,0x34,0x00,0x00,0x00,0x00,	/* 6308: ...4.... */
	0x00,0x00,0x1E,0xD0,0x00,0x00,0x00,0x00,	/* 6310: ....... */
	0x00,0x00,0x1E,0xEC,0x00,0x00,0x00,0x00,	/* 6318: ....... */
	0x00,0x00,0x20,0x44,0x00,0x00,0x00,0x00,	/* 6320: .. D.... */
	0x00,0x00,0x21,0xAC,0x00,0x00,0x00,0x00,	/* 6328: ..!.... */
	0x00,0x00,0x21,0xBC,0x00,0x00,0x00,0x00,	/* 6330: ..!.... */
	0x00,0x00,0x21,0xCC,0x00,0x00,0x00,0x00,	/* 6338: ..!.... */
	0x00,0x00,0x22,0xA8,0x00,0x00,0x00,0x00,	/* 6340: ..".... */
	0x00,0x00,0x00,0x00,0x01,0x01,0x80,0x80,	/* 6348: ...... */
	0x00,0x00,0x40,0xF4,0x00,0x00,0x00,0x00,	/* 6350: ..@.... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x48,0xEC,	/* 6358: ......H */
	0x00,0x00,0x00,0x00,0x00,0x00,0x48,0xEC,	/* 6360: ......H */
	0x00,0x00,0x00,0x00,0x00,0x00,0x48,0xC0,	/* 6368: ......H */
	0x00,0x00,0x00,0x00,0x00,0x00,0x48,0xEC,	/* 6370: ......H */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4C,0x64,	/* 6378: ......Ld */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4B,0x44,	/* 6380: ......KD */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4B,0x74,	/* 6388: ......Kt */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4B,0xA0,	/* 6390: ......K */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4B,0xA4,	/* 6398: ......K */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4B,0xA8,	/* 63A0: ......K */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4C,0xB4,	/* 63A8: ......L */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4D,0x00,	/* 63B0: ......M. */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4D,0x78,	/* 63B8: ......Mx */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4D,0x94,	/* 63C0: ......M */
	0x00,0x00,0x00,0x00,0x00,0x00,0x4D,0xE0 	/* 63C8: ......M */

};
int si4_cf_dsize = sizeof(si4_cf_download);		/* 0x63D0 (25552) */

unsigned short si4_cf_downloadaddr = 0x0000;

/* End of SI4_CF.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\spx_iioc.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Dispatch Entry for INTERNAL IOCTLs					*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Internal IOCTLs support the SERENUM					*/
/*					attached serial device enumerator:					*/
/*					IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS				*/
/*					IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS				*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#define FILE_ID	SPX_IIOC_C		// File ID for Event Logging see SPX_DEFS.H for values.



/*****************************************************************************
**********************                                 ***********************
**********************   Spx_SerialInternalIoControl   ***********************
**********************                                 ***********************
******************************************************************************
	
prototype:		NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)

description:	Internal IOCTL dipatch routine.
				These IOCTLs are only issued from know trusted system components such as
				the SERENUM.SYS attached serial device enumerator and the mouse driver:

parameters:		pDevObj points to the device object structure
				pIrp points to the IOCTL Irp packet

returns:		STATUS_SUCCESS

*/

NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
	NTSTATUS				status;
	PIO_STACK_LOCATION		pIrpStack;
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	KIRQL					OldIrql;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Entry\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	if(SerialCompleteIfError(pDevObj, pIrp) != STATUS_SUCCESS)
		return(STATUS_CANCELLED);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0L;
	status = STATUS_SUCCESS;

	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
	case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
		{
			SERIAL_BASIC_SETTINGS	Basic;
			PSERIAL_BASIC_SETTINGS	pBasic;
			SERIAL_IOCTL_SYNC	S;

			if (pIrpStack->Parameters.DeviceIoControl.IoControlCode 
				== IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
			{
          
/* Check the buffer size... */

				if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength 
					< sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

/* Everything is 0 -- timeouts and flow control. */
/* If we add additional features, this zero memory method may not work. */

				RtlZeroMemory(&Basic,sizeof(SERIAL_BASIC_SETTINGS));
				pIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;

/* Save off the old settings... */

				RtlCopyMemory(&pBasic->Timeouts, &pPort->Timeouts, sizeof(SERIAL_TIMEOUTS));
				RtlCopyMemory(&pBasic->HandFlow, &pPort->HandFlow, sizeof(SERIAL_HANDFLOW));

/* Point to our new settings... */

				pBasic = &Basic;
			}
			else
			{
				if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;
			}

			KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

/* Set the timeouts...	*/

			RtlCopyMemory(&pPort->Timeouts, &pBasic->Timeouts, sizeof(SERIAL_TIMEOUTS));

/* Set flowcontrol... */

			S.pPort = pPort;
			S.Data = &pBasic->HandFlow;
			XXX_SetHandFlow(pPort, &S);		/* Set the handflow for specific hardware */

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

	default:
		status = STATUS_INVALID_PARAMETER;
		break;
	}

	pIrp->IoStatus.Status = status;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Complete\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	IoCompleteRequest(pIrp,0);

	return(status);

} /* Spx_SerialInternalIoControl */
                                                        
/* End of SPX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\spx_init.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_INIT.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	This module contains the code that load the driver.					*
*																						*
****************************************************************************************/


#define FILE_ID	SPX_INIT_C		// File ID for Event Logging see SPX_DEFS.H for values.


// Function Prototypes 
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
// End function prototypes.

// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#endif

// Gloabal Driver Data
UNICODE_STRING	SavedRegistryPath;

#if DBG
ULONG SpxDebugLevel = 0;		// Debug level for checked build
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//	DriverEntry - Load first and initialises entry points.								//
//////////////////////////////////////////////////////////////////////////////////////////
/*
Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    RegistryPath - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS 
*/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	// Holds status information return by various OS and driver initialization routines.
	NTSTATUS status;

	// We use this to query into the registry as to whether we should break at driver entry.
	RTL_QUERY_REGISTRY_TABLE paramTable[3];
	ULONG zero			= 0;
	ULONG debugLevel	= 0;
	ULONG shouldBreak	= 0;		
	PWCHAR path			= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	#if DBG
		DbgPrint( "%s: In DriverEntry\n", PRODUCT_NAME);
	#endif


	// Store Registry Path
	SavedRegistryPath.MaximumLength	= RegistryPath->MaximumLength;
	SavedRegistryPath.Length		= RegistryPath->Length;
	SavedRegistryPath.Buffer		= SpxAllocateMem(PagedPool, SavedRegistryPath.MaximumLength);

	if(SavedRegistryPath.Buffer)
	{
		RtlMoveMemory(SavedRegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
	
		RtlZeroMemory(&paramTable[0], sizeof(paramTable));
		paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[0].Name = L"BreakOnEntry";
		paramTable[0].EntryContext = &shouldBreak;
		paramTable[0].DefaultType = REG_DWORD;
		paramTable[0].DefaultData = &zero;
		paramTable[0].DefaultLength = sizeof(ULONG);
		paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[1].Name = L"DebugLevel";
		paramTable[1].EntryContext = &debugLevel;
		paramTable[1].DefaultType = REG_DWORD;
		paramTable[1].DefaultData = &zero;
		paramTable[1].DefaultLength = sizeof(ULONG);

		if(!SPX_SUCCESS(status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
														RegistryPath->Buffer, &paramTable[0], 
														NULL, NULL)))
		{
			shouldBreak = 0;
			debugLevel	= 0;
		}

	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;


 	#if DBG
		SpxDebugLevel = debugLevel;	
	//	SpxDebugLevel = (ULONG)-1;			// Prints all debug messages

	//	shouldBreak = 1;	// HARD CODED BREAKPOINT WITH CHECKED BUILD !!!
	#endif


	if(shouldBreak)
	{
		DbgBreakPoint();	// Break Debugger.
	}


	if(SPX_SUCCESS(status))
	{
		// Initialize the Driver Object with driver's entry points
		DriverObject->DriverUnload									= DriverUnload;
		DriverObject->DriverExtension->AddDevice					= Spx_AddDevice;
		DriverObject->MajorFunction[IRP_MJ_PNP]						= Spx_DispatchPnp;
		DriverObject->MajorFunction[IRP_MJ_POWER]					= Spx_DispatchPower;
		DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]			= Spx_Flush;
		DriverObject->MajorFunction[IRP_MJ_WRITE]					= Spx_Write;
		DriverObject->MajorFunction[IRP_MJ_READ]					= Spx_Read;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]			= Spx_IoControl;
		DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]	= Spx_InternalIoControl;
		DriverObject->MajorFunction[IRP_MJ_CREATE]					= Spx_CreateOpen;
		DriverObject->MajorFunction[IRP_MJ_CLOSE]					= Spx_Close;
		DriverObject->MajorFunction[IRP_MJ_CLEANUP]					= Spx_Cleanup;
		DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]		= Spx_QueryInformationFile;
		DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]			= Spx_SetInformationFile;
#ifdef WMI_SUPPORT
		DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]			= Spx_DispatchSystemControl;
#endif
		
	}
	else
	{
		// Free
		if(SavedRegistryPath.Buffer)
		{
			SpxFreeMem(SavedRegistryPath.Buffer);
			SavedRegistryPath.Buffer = NULL;
		}
	}


	return(status);

}	// DriverEntry 




//////////////////////////////////////////////////////////////////////////////////////////
//	DriverUnload - Called as driver unloads.											
//////////////////////////////////////////////////////////////////////////////////////////
VOID 
DriverUnload(IN PDRIVER_OBJECT pDriverObject)
/*++

Routine Description:

    This routine cleans up all of the resources allocated in DriverEntry.

Arguments:

    pDriverObject - Pointer to the driver object controling all of the
					devices.

Return Value:

    None.

--*/
{
	PAGED_CODE();
	
	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering DriverUnload\n", PRODUCT_NAME));

	// All Device Objects must have been deleted by now.
    ASSERT (pDriverObject->DeviceObject == NULL);

	// Free
	if(SavedRegistryPath.Buffer)
	{
		SpxFreeMem(SavedRegistryPath.Buffer);
		SavedRegistryPath.Buffer = NULL;
	}


	return;
}


// End of SPX_INIT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\spxutils.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_UTILS.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Utility functions.													*
*																						*
****************************************************************************************/

#define FILE_ID	SPX_UTILS_C		// File ID for Event Logging see SPX_DEFS.H for values.

// Paging...  
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_InitMultiString)
#pragma alloc_text (PAGE, Spx_GetRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_PutRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_LogMessage)
#pragma alloc_text (PAGE, Spx_LogError)
#pragma alloc_text (PAGE, Spx_MemCompare)
#endif


/////////////////////////////////////////////////////////////////////////////////////////
//	
//	Description:
//
//		This routine will take a null terminated list of ascii strings and combine
//		them together to generate a unicode multi-string block
//
//	Arguments:
//
//		Multi		- TRUE if a MULTI_SZ list is required, FALSE for a simple UNICODE
//
//		MultiString - a unicode structure in which a multi-string will be built
//		...         - a null terminated list of narrow strings which will be
//			       combined together. This list must contain at least a trailing NULL
//
//	Return Value:
//
//		NTSTATUS
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...)
{

	ANSI_STRING ansiString;
	NTSTATUS status;
	PCSTR rawString;
	PWSTR unicodeLocation;
	ULONG multiLength = 0;
	UNICODE_STRING unicodeString;
	va_list ap;
	ULONG i;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	va_start(ap,MultiString);
  
	// Make sure that we won't leak memory
	ASSERT(MultiString->Buffer == NULL);

	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{
		RtlInitAnsiString(&ansiString, rawString);
		multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
		rawString = va_arg(ap, PCSTR);
	}

	va_end( ap );

	if (multiLength == 0) 
	{
		// Done
		RtlInitUnicodeString(MultiString, NULL);
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (1)\n", PRODUCT_NAME));

		return STATUS_SUCCESS;
	}

	

	if(multi)
		multiLength += sizeof(WCHAR);	// We need an extra null if we want a MULTI_SZ list


	MultiString->MaximumLength = (USHORT)multiLength;
	MultiString->Buffer = SpxAllocateMem(PagedPool, multiLength);
	MultiString->Length = 0;

	if (MultiString->Buffer == NULL) 
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (2) - FAILURE\n", PRODUCT_NAME));

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	SpxDbgMsg(SPX_MISC_DBG, ("%s: Allocated %lu bytes for buffer\n", PRODUCT_NAME, multiLength));

#if DBG
	RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

	unicodeString.Buffer = MultiString->Buffer;
	unicodeString.MaximumLength = (USHORT) multiLength;

	va_start(ap, MultiString);
	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{

		RtlInitAnsiString(&ansiString,rawString);
		status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

		// We don't allocate memory, so if something goes wrong here,
		// its the function that's at fault
		ASSERT(SPX_SUCCESS(status));

		// Check for any commas and replace them with NULLs
		ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

		for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) 
		{
			if (unicodeString.Buffer[i] == L'\x2C' || unicodeString.Buffer[i] == L'\x0C' ) 
			{
				unicodeString.Buffer[i] = L'\0'; 
			}
		}


		SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer: %ws\n", PRODUCT_NAME, unicodeString.Buffer));

		// Move the buffers along
		unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
		unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
		unicodeString.Length = 0;

		// Next
		rawString = va_arg(ap, PCSTR);

	} // while

	va_end(ap);

	if(multi)
	{
		ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));
	}
	else
	{
		ASSERT(unicodeString.MaximumLength == 0);
	}


	// Stick the final null there
 	SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer last addr: 0x%X\n", PRODUCT_NAME, unicodeString.Buffer));

	if(multi)
		unicodeString.Buffer[0] = L'\0'; 		// We need an extra null if we want a MULTI_SZ list


	MultiString->Length = (USHORT)multiLength - sizeof(WCHAR);
	MultiString->MaximumLength = (USHORT)multiLength;

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (3) - SUCCESS\n", PRODUCT_NAME));

	return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:	
//		Reads a registry key value from an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		KeyNameString       ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//
//		Data                Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	)

{

	UNICODE_STRING              keyName;
	ULONG                       length;
	PKEY_VALUE_FULL_INFORMATION fullInfo;

	NTSTATUS                    status = STATUS_INSUFFICIENT_RESOURCES;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Enter Spx_GetRegistryKeyValue\n", PRODUCT_NAME));


	RtlInitUnicodeString (&keyName, KeyNameString);

	length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength + DataLength;
	fullInfo = SpxAllocateMem(PagedPool, length); 

	if(fullInfo) 
	{
		status = ZwQueryValueKey(	Handle,
									&keyName,
									KeyValueFullInformation,
									fullInfo,
									length,
									&length);

		if(SPX_SUCCESS(status)) 
		{
			// If there is enough room in the data buffer, copy the output
			if(DataLength >= fullInfo->DataLength) 
				RtlCopyMemory (Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, fullInfo->DataLength);
		}

		SpxFreeMem(fullInfo);
	}

	return status;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//
//		Writes a registry key value to an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		PKeyNameString      ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//    
//		Dtype				REG_XYZ value type
//
//		PData               Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	)
{

	NTSTATUS status;
	UNICODE_STRING keyname;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Enter Spx_PutRegistryKeyValue\n", PRODUCT_NAME));

	RtlInitUnicodeString(&keyname, NULL);
	keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
	keyname.Buffer = SpxAllocateMem(PagedPool, keyname.MaximumLength);

	if(keyname.Buffer == NULL) 
		  return STATUS_INSUFFICIENT_RESOURCES;

	RtlAppendUnicodeToString(&keyname, PKeyNameString);

	status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

	SpxFreeMem(keyname.Buffer);

	return status;
}




VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp)	// Limited to 51 characters + 1 null
{
	
	UNICODE_STRING ErrorMsg;

	ErrorMsg.Length = 0;
	ErrorMsg.Buffer = 0;
	Spx_InitMultiString(FALSE, &ErrorMsg, szTemp, NULL);


	switch(MessageSeverity)
	{
	case STATUS_SEVERITY_SUCCESS:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_SUCCESS,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;
	
	case STATUS_SEVERITY_INFORMATIONAL:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_INFORMATIONAL,			// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_WARNING:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_WARNING,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_ERROR:
	default:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_ERROR,					// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	}

	if(ErrorMsg.Buffer != NULL)
		SpxFreeMem(ErrorMsg.Buffer);

}

/////////////////////////////////////////////////////////////////////////////////////////
//																
//	Spx_LogError														
//															
/////////////////////////////////////////////////////////////////////////////////////////
/*
	Routine Description:

		This routine allocates an error log entry, copies the supplied data
		to it, and requests that it be written to the error log file.

	Arguments:

		DriverObject - A pointer to the driver object for the device.

		DeviceObject - A pointer to the device object associated with the
		device that had the error, early in initialization, one may not
		yet exist.

		P1,P2 - If phyical addresses for the controller ports involved
		with the error are available, put them through as dump data.

		SequenceNumber - A ulong value that is unique to an IRP over the
		life of the irp in this driver - 0 generally means an error not
		associated with an irp.

		MajorFunctionCode - If there is an error associated with the irp,
		this is the major function code of that irp.

		RetryCount - The number of times a particular operation has been retried.

		UniqueErrorValue - A unique long word that identifies the particular
		call to this function.

		FinalStatus - The final status given to the irp that was associated
		with this error.  If this log entry is being made during one of
		the retries this value will be STATUS_SUCCESS.

		SpecificIOStatus - The IO status for a particular error.

		LengthOfInsert1 - The length in bytes (including the terminating NULL)
						  of the first insertion string.

		Insert1 - The first insertion string.

		LengthOfInsert2 - The length in bytes (including the terminating NULL)
						  of the second insertion string.  NOTE, there must
						  be a first insertion string for their to be
						  a second insertion string.

		Insert2 - The second insertion string.

	Return Value:	None.
*/


VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	)
{

	PIO_ERROR_LOG_PACKET ErrorLogEntry;

	PVOID objectToUse;
	SHORT dumpToAllocate = 0;
	PUCHAR ptrToFirstInsert;
	PUCHAR ptrToSecondInsert;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(Insert1 == NULL) 
		LengthOfInsert1 = 0;

	if(Insert2 == NULL) 
		LengthOfInsert2 = 0;


	if(ARGUMENT_PRESENT(DeviceObject)) 
		objectToUse = DeviceObject;
	else 
		objectToUse = DriverObject;


	if(Spx_MemCompare(P1, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	if(Spx_MemCompare(P2, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	ErrorLogEntry = IoAllocateErrorLogEntry(objectToUse,
											(UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + dumpToAllocate 
											+ LengthOfInsert1 + LengthOfInsert2)	
											);

	if(ErrorLogEntry != NULL) 
	{
		ErrorLogEntry->ErrorCode			= SpecificIOStatus;
		ErrorLogEntry->SequenceNumber		= SequenceNumber;
		ErrorLogEntry->MajorFunctionCode	= MajorFunctionCode;
		ErrorLogEntry->RetryCount			= RetryCount;
		ErrorLogEntry->UniqueErrorValue		= UniqueErrorValue;
		ErrorLogEntry->FinalStatus			= FinalStatus;
		ErrorLogEntry->DumpDataSize			= dumpToAllocate;

		
		if(dumpToAllocate) 
		{
			RtlCopyMemory(&ErrorLogEntry->DumpData[0], &P1,	sizeof(PHYSICAL_ADDRESS));

			if(dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) 
			{
				RtlCopyMemory(	((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS),
								&P2,
								sizeof(PHYSICAL_ADDRESS)
								);

				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + (2*sizeof(PHYSICAL_ADDRESS));

			} 
			else 
			{
				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS);
			}

		} 
		else 
		{
			ptrToFirstInsert = (PUCHAR)&ErrorLogEntry->DumpData[0];
		}

		ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

		if(LengthOfInsert1) 
		{
			ErrorLogEntry->NumberOfStrings	= 1;
			ErrorLogEntry->StringOffset		= (USHORT)(ptrToFirstInsert - (PUCHAR)ErrorLogEntry);

			RtlCopyMemory(ptrToFirstInsert, Insert1, LengthOfInsert1);

			if(LengthOfInsert2) 
			{
				ErrorLogEntry->NumberOfStrings = 2;
				RtlCopyMemory(ptrToSecondInsert, Insert2, LengthOfInsert2);
			}
		}


		IoWriteErrorLogEntry(ErrorLogEntry);

	}

}



SPX_MEM_COMPARES
Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB)
/*++
Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.
--*/
{
	LARGE_INTEGER a;
	LARGE_INTEGER b;

	LARGE_INTEGER lower;
	ULONG lowerSpan;
	LARGE_INTEGER higher;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	a = A;
	b = B;

	if(a.QuadPart == b.QuadPart) 
	  return AddressesAreEqual;


	if(a.QuadPart > b.QuadPart) 
	{
		higher = a;
		lower = b;
		lowerSpan = SpanOfB;
	} 
	else 
	{
		higher = b;
		lower = a;
		lowerSpan = SpanOfA;
	}

	if((higher.QuadPart - lower.QuadPart) >= lowerSpan)
      return AddressesAreDisjoint;


	return AddressesOverlap;
}


NTSTATUS
PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard)
{
	/******************************************************** 
	* Setting bit 17 in the CNTRL register of the PLX 9050	* 
	* chip forces a retry on writes while a read is pending.*
	* This is to prevent the card locking up on Intel Xeon  *
	* multiprocessor systems with the NX chipset.			*
	********************************************************/

	#define CNTRL_REG_OFFSET	0x14	// DWORD Offset (BYTE Offset 0x50) 
	
	NTSTATUS	status = STATUS_SUCCESS;
	PULONG		pPCIConfigRegisters = NULL;			// Pointer to PCI Config Registers.
	CHAR		szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering PLX_9050_CNTRL_REG_FIX for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	pPCIConfigRegisters = MmMapIoSpace(pCard->PCIConfigRegisters, pCard->SpanOfPCIConfigRegisters, FALSE);

	if(pPCIConfigRegisters != NULL)
	{
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */

		if(pPCIConfigRegisters[CNTRL_REG_OFFSET] == 0)	// If bit 7 is set Config Registers are zero (unreadable) 
		{
			// We have to blindly write the value to the register.
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;	// Set bits 17 & 21 of PLX CNTRL register 
		}
		else
		{	
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 1] &= ~0x40;		// Clear bit 14 of PLX CNTRL register
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;		// Set bits 17 & 21 of PLX CNTRL register
		}

		MmUnmapIoSpace(pPCIConfigRegisters, pCard->SpanOfPCIConfigRegisters);
	}
	else
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Insufficient resources available for Card %d.\n", 
			PRODUCT_NAME, pCard->CardNumber));
	
		sprintf(szErrorMsg, "Card at %08lX: Insufficient resources.", pCard->PhysAddr);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	return status;
}


//
// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	

	if(Set) 
		pDevExt->PnpPowerFlags |= Value;			
	else 
		pDevExt->PnpPowerFlags &= ~Value;	

	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->StalledIrpLock, &oldIrql);	

	pDevExt->UnstallingFlag = Set;			

	KeReleaseSpinLock(&pDevExt->StalledIrpLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
BOOLEAN
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll)
{
	KIRQL oldIrql;
	BOOLEAN bRet = FALSE; 

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	
	
	if(bAll)
	{
		// If all the requested SetFlags are set
		// and if all of the requested ClearedFlags are cleared then return true.
		if(((ulSetFlags & pDevExt->PnpPowerFlags) == ulSetFlags) && !(ulClearedFlags & pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}
	else
	{
		// If any of the requested SetFlags are set 
		// or if any of the requested ClearedFlags are cleared then return true.
		if((ulSetFlags & pDevExt->PnpPowerFlags) || (ulClearedFlags & ~pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}


	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);
	
	return bRet;
}




PVOID 
SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 

	pRet = ExAllocatePoolWithTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


PVOID 
SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 
	
	pRet = ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


#ifndef BUILD_SPXMINIPORT
void
SpxFreeMem(PVOID pMem)
{
	ASSERT(pMem != NULL);	// Assert if the pointer is NULL.

	ExFreePool(pMem);
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////
// Must be called just before an IoCompleteRequest if IrpCondition == IRP_SUBMITTED
//
///////////////////////////////////////////////////////////////////////////////////////////
VOID
SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition)
{
	PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	switch(pIrpStack->MajorFunction)		// Don't filter Plug and Play IRPs 
	{

	case IRP_MJ_FLUSH_BUFFERS:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.FlushIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.FlushIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.FlushIrpsQueued);
				pPort->PerfStats.FlushIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.FlushIrpsQueued);
				if(pPort->PerfStats.FlushIrpsQueued) 
					pPort->PerfStats.FlushIrpsQueued--;		// Decrement counter for performance stats.

				break;


			default:
				break;
			}

			break;
		}


	case IRP_MJ_WRITE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.WriteIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.WriteIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.WriteIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.WriteIrpsQueued);
				pPort->PerfStats.WriteIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.WriteIrpsQueued);
				if(pPort->PerfStats.WriteIrpsQueued) 
					pPort->PerfStats.WriteIrpsQueued--;		// Decrement counter for performance stats.

				break;

			default:
				break;
			}

			break;
		}

	case IRP_MJ_READ:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.ReadIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.ReadIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.ReadIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.ReadIrpsQueued);
				pPort->PerfStats.ReadIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.ReadIrpsQueued);
				if(pPort->PerfStats.ReadIrpsQueued) 
					pPort->PerfStats.ReadIrpsQueued--;		// Decrement counter for performance stats.
				
				break;


			default:
				break;
			}

			break;
		}

	case IRP_MJ_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.IoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.IoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InternalIoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InternalIoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}


	case IRP_MJ_CREATE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CreateIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CreateIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLOSE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CloseIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CloseIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLEANUP:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CleanUpIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CleanUpIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_QUERY_INFORMATION:
	case IRP_MJ_SET_INFORMATION:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InfoIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InfoIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}
	
	default:
		break;

	}
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    pPort - Pointer to a the Port Device Extension.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
{
    RtlZeroMemory(&pPort->PerfStats, sizeof(PORT_PERFORMANCE_STATS));

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\spx_disp.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Specialix Generic Dispatch Functions.				*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	29th September 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Dispatch entry points are routed here				*/
/*					for PnP/Power filtering before being				*/
/*					passed to the main functions:						*/
/*						Spx_Flush										*/
/*						Spx_Write										*/
/*						Spx_Read										*/
/*						Spx_IoControl									*/
/*						Spx_InternalIoControl							*/
/*						Spx_CreateOpen									*/
/*						Spx_Close										*/
/*						Spx_Cleanup										*/
/*						Spx_QueryInformationFile						*/
/*						Spx_SetInformationFile							*/
/*																		*/
/*						Spx_UnstallIRPs									*/
/*						Spx_KillStalledIRPs								*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	29/09/98 NPV	Creation.

*/

#define FILE_ID	SPX_DISP_C		// File ID for Event Logging see SPX_DEFS.H for values.

/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp);



/*****************************************************************************
********************************   Spx_Flush   *******************************
*****************************************************************************/

NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialFlush(pDevObject,pIrp);

	return(status);

} // End Spx_Flush 

/*****************************************************************************
********************************   Spx_Write   *******************************
*****************************************************************************/

NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialWrite(pDevObject,pIrp);

	return(status);

} // End Spx_Write 

/*****************************************************************************
********************************   Spx_Read   ********************************
*****************************************************************************/

NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialRead(pDevObject,pIrp);

	return(status);

} // End Spx_Read 

/*****************************************************************************
******************************   Spx_IoControl   *****************************
*****************************************************************************/

NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialIoControl(pDevObject,pIrp);

	return(status);

} // End Spx_IoControl 

/*****************************************************************************
**************************   Spx_InternalIoControl   *************************
*****************************************************************************/

NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = Spx_SerialInternalIoControl(pDevObject,pIrp);

	return(status);

} // Spx_InternalIoControl 

/*****************************************************************************
*****************************   Spx_CreateOpen   *****************************
*****************************************************************************/

NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;

	// Lock out state Query stop and Query remove IRPs from changing the state 
	// of the port part way through openening the port.
	ExAcquireFastMutex(&pPort->OpenMutex);
	
	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		if(pPort->DeviceIsOpen)					// Is port already open? 
		{
			status = STATUS_ACCESS_DENIED;		// Yes, deny access 
			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
		}
		else
			status = SerialCreateOpen(pDevObject,pIrp);

	}

	ExReleaseFastMutex(&pPort->OpenMutex);

	return(status);

} // End Spx_CreateOpen 

/*****************************************************************************
********************************   Spx_Close   *******************************
*****************************************************************************/

NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)		// Successful close if device is removed 
		{
			pPort->BufferSize = 0;
			SpxFreeMem(pPort->InterruptReadBuffer);
			pPort->InterruptReadBuffer = NULL;
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialClose(pDevObject,pIrp);

	return(status);

} // End Spx_Close 

/*****************************************************************************
*******************************   Spx_Cleanup   ******************************
*****************************************************************************/

NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)
		{
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		Spx_KillStalledIRPs(pDevObject);
		status = SerialCleanup(pDevObject,pIrp);
	}

	return(status);

} // End Spx_Cleanup 

/*****************************************************************************
************************   Spx_QueryInformationFile   ************************
*****************************************************************************/

NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	status = SerialQueryInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_QueryInformationFile 

/*****************************************************************************
*************************   Spx_SetInformationFile   *************************
*****************************************************************************/

NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialSetInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_SetInformationFile 

/*****************************************************************************
*****************************                    *****************************
*****************************   Spx_FilterIRPs   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Filter incoming SERIAL IRPs (except PNP and POWER) to check
				the current PNP/POWER states and return an NT status code to
				just complete the IRP if device is blocked for the following reasons:

parameters:		pDevObject points to the device object for this IRP
				pIrp points to the IRP to filter

returns:		NT Status Code

*/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	KIRQL					oldIrqlFlags;
	KIRQL					StalledOldIrql;
	LARGE_INTEGER delay;

	if(pIrpStack->MajorFunction == IRP_MJ_PNP)			// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_POWER)		// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_SYSTEM_CONTROL)	// Don't filter WMI IRPs 
		return(STATUS_SUCCESS);


	if(pPort->IsFDO)									// Don't filter card IRPs	
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction != IRP_MJ_PNP)
	{
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
	}


	KeAcquireSpinLock(&pPort->PnpPowerFlagsLock, &oldIrqlFlags);

	if(pPort->PnpPowerFlags & PPF_REMOVED)				// Has this object been "removed"? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		return(STATUS_NO_SUCH_DEVICE);
	}

	if(pPort->PnpPowerFlags & PPF_REMOVE_PENDING)		// Removing the device? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_DELETE_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_DELETE_PENDING);
	}


	if((pPort->PnpPowerFlags & PPF_STOP_PENDING)		// Device stopping?
	||(!(pPort->PnpPowerFlags & PPF_POWERED))			// Device not powered?
	||(!(pPort->PnpPowerFlags & PPF_STARTED)))			// Device not started?
	{
		KIRQL	oldIrql;

		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);


		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		
		while(pPort->UnstallingFlag) // We do not wish to add any more IRPs to the queue if have started unstalling those currently queued.
		{
			KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
			
			KeDelayExecutionThread(KernelMode, FALSE, &delay);

			KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		}

		pPort->UnstallingFlag = TRUE;

		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	


		IoAcquireCancelSpinLock(&oldIrql);

		if(pIrp->Cancel)				// Has IRP been cancelled? 
		{								// Yes 
			IoReleaseCancelSpinLock(oldIrql);
			SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_CANCELLED\n",
				PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
				
			return(STATUS_CANCELLED);
		}

// Mark the IRP as pending and queue on the stalled list... 
		pIrp->IoStatus.Status = STATUS_PENDING;		// Mark IRP as pending 
		IoMarkIrpPending(pIrp);
		InsertTailList(&pPort->StalledIrpQueue,&pIrp->Tail.Overlay.ListEntry);
		IoSetCancelRoutine(pIrp,Spx_FilterCancelQueued);
		IoReleaseCancelSpinLock(oldIrql);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_PENDING);
	}

	KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

	return(STATUS_SUCCESS);

} // End Spx_FilterIRPs 

/*****************************************************************************
*****************************                     ****************************
*****************************   Spx_UnstallIRPs   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)

description:	Restart all IRPs stored on the temporary stalled list.

parameters:		pPort points to the device extension to unstall

returns:		None

*/

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)
{
	PLIST_ENTRY			pIrpLink;
	PIRP				pIrp;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		pDevObj;
	PDRIVER_OBJECT		pDrvObj;
	KIRQL				oldIrql;
	KIRQL				StalledOldIrql;
	LARGE_INTEGER		delay;

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Entry\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));


	KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	
	while(pPort->UnstallingFlag)	// We do not unstall any queued IRPs if some one is just about to be added to the queue.
	{
		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

		delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
		
		KeDelayExecutionThread(KernelMode, FALSE, &delay);

		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	}

	pPort->UnstallingFlag = TRUE;

	KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	





	IoAcquireCancelSpinLock(&oldIrql);
	pIrpLink = pPort->StalledIrpQueue.Flink;

// Restart each waiting IRP on the stalled list... 

	while(pIrpLink != &pPort->StalledIrpQueue)
	{
		pIrp = CONTAINING_RECORD(pIrpLink,IRP,Tail.Overlay.ListEntry);
		pIrpLink = pIrp->Tail.Overlay.ListEntry.Flink;
		RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
		pDevObj = pIrpStack->DeviceObject;
		pDrvObj = pDevObj->DriverObject;
		IoSetCancelRoutine(pIrp,NULL);
		IoReleaseCancelSpinLock(oldIrql);

		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Unstalling IRP 0x%X, Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,
			pIrp,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj,pIrp);
		IoAcquireCancelSpinLock(&oldIrql);
	}

	IoReleaseCancelSpinLock(oldIrql);

	ClearUnstallingFlag(pPort);

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Exit\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

} // End Spx_UnstallIRPs 

/*****************************************************************************
*************************                            *************************
*************************   Spx_FilterCancelQueued   *************************
*************************                            *************************
******************************************************************************

prototype:		VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)

description:	Routine to cancel IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue
				pIrp points to the IRP to cancel

returns:		None

*/

VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PIO_STACK_LOCATION		pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pIrp->IoStatus.Status = STATUS_CANCELLED;
	pIrp->IoStatus.Information = 0;

	RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
	IoReleaseCancelSpinLock(pIrp->CancelIrql);

} // End Spx_FilterCancelQueued 


/*****************************************************************************
***************************                         **************************
***************************   Spx_KillStalledIRPs   **************************
***************************                         **************************
******************************************************************************

prototype:		VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)

description:	Kill all IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue

returns:		None

*/

VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PDRIVER_CANCEL			cancelRoutine;
	KIRQL					cancelIrql;

	IoAcquireCancelSpinLock(&cancelIrql);

// Call the cancel routine of all IRPs queued on the stalled list... 

	while(!IsListEmpty(&pPort->StalledIrpQueue))
	{
		PIRP	pIrp = CONTAINING_RECORD(pPort->StalledIrpQueue.Blink, IRP, Tail.Overlay.ListEntry);

		RemoveEntryList(pPort->StalledIrpQueue.Blink);
		cancelRoutine = pIrp->CancelRoutine;		// Get the cancel routine for this IRP 
		pIrp->CancelIrql = cancelIrql;
		pIrp->CancelRoutine = NULL;
		pIrp->Cancel = TRUE;

		cancelRoutine(pDevObj,pIrp);				// Call the cancel routine 

		IoAcquireCancelSpinLock(&cancelIrql);
	}

	IoReleaseCancelSpinLock(cancelIrql);

} // End Spx_KillStalledIRPs 

// End of SPX_DISP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\spx_powr.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_POWER.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Handle all Power IRPS.												*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/
#define FILE_ID	SPX_POWR_C		// File ID for Event Logging see SPX_DEFS.H for values.

BOOLEAN	BREAK_ON_POWER_UP = FALSE;

// Prototypes
NTSTATUS Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp);
NTSTATUS Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp);
NTSTATUS Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp);
// End of prototypes


// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchPower)

#pragma alloc_text(PAGE, Spx_Card_FDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_CardSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_CardSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD3)

#pragma alloc_text(PAGE, Spx_Port_PDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_PortQuerySystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD3)

#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	Routine Description:
//		The power dispatch routine determine if the IRP is for a card or a port and 
//		then call the correct dispatch routine.
//
//	Arguments:
//		pDevObject	- pointer to a device object.
//		pIrp		- pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		CommonData	= (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO) 
        status = Spx_Card_FDO_DispatchPower(pDevObject, pIrp);
	else 
        status = Spx_Port_PDO_DispatchPower(pDevObject, pIrp);

    return status;
}	// Spx_DispatchPower


	
//////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//		The power dispatch routine to handle power IRPs for card devices.
//
//	Arguments:
//		pFDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pFDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:	// Driver MUST never fail this IRP.
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetSystemPowerState(pFDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetDevicePowerState(pFDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break; 
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
			
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			status = STATUS_NOT_SUPPORTED;
			break;

	}

	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_Card_FDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetSystemPowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetSystemPowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetSystemPowerState


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetDevicePowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetDevicePowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D0.\n", 
			PRODUCT_NAME, pCard->CardNumber));
		
		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D0.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D1.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D2.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D3.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D3.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}


	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetDevicePowerState




//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD0 -  Sets power state D0 for Card - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD0 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	status = Spx_PowerWaitForDriverBelow(pCard->LowerDeviceObject, pIrp);

	
#if DBG
	if(BREAK_ON_POWER_UP)
	{
		BREAK_ON_POWER_UP = FALSE;
	    KdPrint(("%s: Breaking debugger whilst powering up Card %d to debug after a hibernate\n", PRODUCT_NAME, pCard->CardNumber)); 
		DbgBreakPoint();
	}
#endif

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_CardPowerUp(pCard)))		// RESTORE HARDWARE STATE HERE & START CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD0;	// Store new power state.
		SetPnpPowerFlags(pCard, PPF_POWERED); 
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_SetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD3 -  Sets power state D3 for Card - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD3 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	ClearPnpPowerFlags(pCard, PPF_POWERED);		

	if(SPX_SUCCESS(pIrp->IoStatus.Status	= XXX_CardPowerDown(pCard))) // SAVE HARDWARE STATE HERE & STOP CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);						// Ready for next power IRP.
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);	// Pass IRP on down.

	return status;
}	// Spx_SetPowerStateD3







	
//////////////////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//	The power dispatch routine to handle power IRPs for port devices.
//
//	Arguments:
//		pPDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pPDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetSystemPowerState(pPDO, pIrp);
				
			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetDevicePowerState(pPDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
				
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortQuerySystemPowerState(pPDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));

				switch(pIrpStack->Parameters.Power.State.DeviceState)
				{
				case PowerDeviceD0:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to power state D0.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = STATUS_SUCCESS;
					break;

				case PowerDeviceD1:
				case PowerDeviceD2:
				case PowerDeviceD3:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to low power state D1, D2 or D3.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = XXX_PortQueryPowerDown(pPort);
					break;

				default:
					status = STATUS_SUCCESS;
					break;
					
				}

				break;
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));
				break;
			}

			pIrp->IoStatus.Status = status;
			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_SUPPORTED;
			break;
	}

	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_Port_PDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortSetSystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetSystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetSystemPowerState

//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortQuerySystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortQuerySystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortQuerySystemPowerState



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetDevicePowerState 
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetDevicePowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D0.\n", 
			PRODUCT_NAME, pPort->PortNumber));
		
		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D0.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D1.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D2.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D3.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D3.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetDevicePowerState 


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD0 -  Sets power state D0 for Port - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD0 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerUp(pPort)))		// RESTORE HARDWARE STATE HERE & START PORT
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pPort->DeviceState = PowerDeviceD0;	// Store new power state.
		SetPnpPowerFlags(pPort, PPF_POWERED); 
		Spx_UnstallIrps(pPort);				// Restart any queued IRPs (from a previous start)  
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD3 -  Sets power state D3 for Port - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD3 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	ClearPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerDown(pPort)))	// SAVE HARDWARE STATE HERE & STOP PORT
	{   
		// Inform Power Manager the of the new power state. 
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);
		pPort->DeviceState  = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD3



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PowerWaitForDriverBelow -  Waits for lower driver.
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp)
{
	KEVENT		EventWaitLowerDrivers;
	NTSTATUS	status;

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCopyCurrentIrpStackLocationToNext(pIrp);								// Copy parameters to the stack below 
	KeInitializeEvent(&EventWaitLowerDrivers, SynchronizationEvent, FALSE);	// Initialise event if need to wait 
	IoSetCompletionRoutine(pIrp, Spx_DispatchPnpPowerComplete, &EventWaitLowerDrivers, TRUE, TRUE, TRUE);

	if((status = PoCallDriver(pLowerDevObj, pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&EventWaitLowerDrivers, Executive, KernelMode, FALSE, NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} // Spx_PowerWaitForDriverBelow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\spx_pnp.c ===
#include "precomp.h"    // Precompiled header

/****************************************************************************************
*                                                                                       *
*   Module:         SPX_PNP.C                                                           *
*                                                                                       *
*   Creation:       27th September 1998                                                 *
*                                                                                       *
*   Author:         Paul Smith                                                          *
*                                                                                       *
*   Version:        1.0.0                                                               *
*                                                                                       *
*   Description:    Generic Plug and Play Functions to handle PnP IRPS.                 *
*                                                                                       *
****************************************************************************************/
/* History...

1.0.0   27/09/98 PBS    Creation.

*/

#define FILE_ID     SPX_PNP_C       // File ID for Event Logging see SPX_DEFS.H for values.

 
/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp);
NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard);
NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp);
NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort);
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject);


// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_AddDevice)
#pragma alloc_text (PAGE, Spx_DispatchPnp)

#pragma alloc_text (PAGE, Spx_Card_FDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Card_StartDevice)
#pragma alloc_text (PAGE, Spx_Card_StopDevice)
#pragma alloc_text (PAGE, Spx_Card_RemoveDevice)

#pragma alloc_text (PAGE, Spx_CallDriverBelow)

#pragma alloc_text (PAGE, Spx_Port_PDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Port_StartDevice)
#pragma alloc_text (PAGE, Spx_Port_StopDevice)
#pragma alloc_text (PAGE, Spx_Port_RemoveDevice)

#pragma alloc_text (PAGE, Spx_EnumPorts)
#pragma alloc_text (PAGE, Spx_DoExternalNaming)
#pragma alloc_text (PAGE, Spx_GetExternalName)
#pragma alloc_text (PAGE, Spx_RemoveExternalNaming)
#pragma alloc_text (PAGE, Spx_CreatePortInstanceID)
#endif


#include <initguid.h>
#include <ntddser.h>


/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_AddDevice   ******************************
*****************************                   ******************************
******************************************************************************

prototype:      NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)

description:    Create a functional device object (FDO) for the specified card physical device object.

parameters:     pDriver point to the driver object
                pPDO points to a card physical device object (PDO)

returns:        STATUS_SUCCESS
                STATUS_NO_MORE_ENTRIES
*/

NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          pDevObject = NULL;
    PCARD_DEVICE_EXTENSION  pCard = NULL;
    PDEVICE_OBJECT          pLowerDevObject = NULL;
    static ULONG            CardNumber = 0;
    ULONG                   i = 0;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_AddDevice.\n", PRODUCT_NAME));

    if(pPDO == NULL)
    {
        SpxDbgMsg(SPX_MISC_DBG, ("%s: In Spx_AddDevice - No more entries.\n", PRODUCT_NAME));
        return(STATUS_NO_MORE_ENTRIES);
    }

/* Create the device object... */

    status = IoCreateDevice(pDriverObject,
                            sizeof(CARD_DEVICE_EXTENSION),
                            NULL,                           // Doesn't need a name.
                            FILE_DEVICE_CONTROLLER, 
                            FILE_DEVICE_SECURE_OPEN, 
                            TRUE, 
                            &pDevObject);

    if(!SPX_SUCCESS(status))
    {
        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

        SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed for card %d. CardExt at 0x%X.\n",
            PRODUCT_NAME,CardNumber++,&pDevObject));

        sprintf(szErrorMsg, "Card %d: Failed IoCreateDevice.", CardNumber++);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pDriverObject,                  // Driver Object
                        NULL,                           // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        if(pDevObject)                  // Clean up Device Object
            IoDeleteDevice(pDevObject);

        SpxDbgMsg(SPX_ERRORS, ("%s: Leaving Spx_AddDevice - FAILURE.\n", PRODUCT_NAME));
        return(status);
    }


    ASSERT(pDevObject != NULL);

/* Initialise the device extension... */

    pCard = pDevObject->DeviceExtension;                            /* Point to card extension */
    RtlZeroMemory(pCard,sizeof(CARD_DEVICE_EXTENSION));             /* Zero extension structure */

    pDevObject->Flags |= DO_POWER_PAGABLE;              // Get power IRPs at IRQL PASSIVE_LEVEL 
    pDevObject->Flags &= ~DO_DEVICE_INITIALIZING;
    pLowerDevObject = IoAttachDeviceToDeviceStack(pDevObject,pPDO); /* Attach to device stack */
    ASSERT(pLowerDevObject != NULL);

    KeInitializeSpinLock(&pCard->PnpPowerFlagsLock);    /* Initialise the PNP flags lock */
    ClearPnpPowerFlags(pCard,PPF_STARTED);              /* Not started yet */
    ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);         /* Not pending a stop */
    ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);       /* Not pending a remove */

    pCard->IsFDO = TRUE;                                /* Card Object is a Functional Device Object (FDO) */
    pCard->CardNumber = CardNumber++;                   /* Enumerate card devices */
    pCard->DeviceObject = pDevObject;                   /* Back pointer to device object */
    pCard->LowerDeviceObject= pLowerDevObject;          /* Pointer to device below in device stack */
    pCard->DriverObject = pDriverObject;                /* Pointer to driver object */
    pCard->PDO = pPDO;                                  /* Pointer to card physical device object (PDO) */
    pCard->DeviceState = PowerDeviceD0;                 /* Initial power state */
    pCard->SystemState = PowerSystemWorking;            /* System in full power State */
    pCard->NumPDOs = 0;                                 /* Initialise attached port PDO pointers */

    for(i=0; i<PRODUCT_MAX_PORTS; i++)
        pCard->AttachedPDO[i] = NULL;

    SetPnpPowerFlags(pCard,PPF_POWERED);                /* Initially assumed we are powered */

    XXX_CardInit(pCard);                                /* Initialise non-hardware extension fields */

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Leaving Spx_AddDevice - SUCCESS.\n",PRODUCT_NAME));

    return(status);

} /* Spx_AddDevice */

/*****************************************************************************
****************************                     *****************************
****************************   Spx_DispatchPnp   *****************************
****************************                     *****************************
******************************************************************************

prototype:      NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:    The plug and play dispatch routine.
                Determines whether IRP is for a card or a port and calls other functions to handle it. 

parameters:     pDevObject points to a device object for this driver
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA     CommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS                status = STATUS_SUCCESS;
    
    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO)                                   /* Functional Device Object ? */
        status = Spx_Card_FDO_DispatchPnp(pDevObject,pIrp); /* Yes, must be card device */
    else    
        status = Spx_Port_PDO_DispatchPnp(pDevObject,pIrp); /* No, must be port device */

    return(status);

} /* Spx_DispatchPnp */

/*****************************************************************************
************************                              ************************
************************   Spx_Card_FDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)

description:    The plug and play dispatch routine to handle IRPs for card devices.

parameters:     pDevObject points to a card device object for this driver
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)
{
    PCARD_DEVICE_EXTENSION      pCard = pFDO->DeviceExtension;
    PDEVICE_OBJECT              pLowerDevObj = pCard->LowerDeviceObject;
    NTSTATUS                    status;
    PDEVICE_CAPABILITIES        pDevCaps = NULL;
    PIO_STACK_LOCATION          pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    PDEVICE_RELATIONS           pRelations = NULL;
    ULONG                       length = 0;
    ULONG                       i = 0;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 


    switch(pIrpStack->MinorFunction)
    {   

/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
    
    case    IRP_MN_START_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

            status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

/* If successful, then start the card... */

            if(NT_SUCCESS(status))
                status = Spx_Card_StartDevice(pFDO,pIrp);   /* Start the card */

            pIrp->IoStatus.Status = status;
            pIrp->IoStatus.Information = 0;
            IoCompleteRequest(pIrp,IO_NO_INCREMENT);
            break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

    case    IRP_MN_QUERY_DEVICE_RELATIONS:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));
            
            if(pIrpStack->Parameters.QueryDeviceRelations.Type != BusRelations) /* Only handle BusRelations */
            {
                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: IRP_MN_QUERY_DEVICE_RELATIONS for Card - Non bus.\n",PRODUCT_NAME));
                IoSkipCurrentIrpStackLocation(pIrp);
                status = IoCallDriver(pLowerDevObj,pIrp);
                break;
            }

/* Enumerate devices on the card... */

            Spx_EnumPorts(pFDO);                                /* Enumerate and create port device objects */

/* Tell the Plug and Play Manager any found ports... */

            i = 0;
            if(pIrp->IoStatus.Information)                      /* Get current device object count */
                i = ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Count;

            length = sizeof(DEVICE_RELATIONS)+((pCard->NumPDOs+i)*sizeof(PDEVICE_OBJECT));
            if(pRelations = SpxAllocateMem(NonPagedPool, length))/* Allocate new structure */
            {

/* Copy in the device objects so far... */

                if(i)
                    RtlCopyMemory
                    (
                        pRelations->Objects,
                        ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Objects,
                        i * sizeof (PDEVICE_OBJECT)
                    );

                pRelations->Count = i;                              /* Update device count */

/* Add specialix ports to the device relations... */

                if(pCard->NumPDOs)
                {
                    for(i=0; i<PRODUCT_MAX_PORTS; i++)
                    {
                        if(pCard->AttachedPDO[i])                   /* If object exists */
                        {                                           /* add to table */
                            pRelations->Objects[pRelations->Count++] = pCard->AttachedPDO[i];
                            ObReferenceObject(pCard->AttachedPDO[i]);
                        }
                    }
                }

                if(pIrp->IoStatus.Information != 0)                 /* If previous structure */
                    SpxFreeMem((PVOID)pIrp->IoStatus.Information);  /* then free */

                pIrp->IoStatus.Information = (ULONG_PTR)pRelations; /* Set new structure */

            }
            else
            {
                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                sprintf(szErrorMsg, "Card at %08lX: Insufficient resources.", pCard->PhysAddr);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                pCard->DriverObject,            // Driver Object
                                pCard->DeviceObject,            // Device Object (Optional)
                                PhysicalZero,                   // Physical Address 1
                                PhysicalZero,                   // Physical Address 2
                                0,                              // SequenceNumber
                                pIrpStack->MajorFunction,       // Major Function Code
                                0,                              // RetryCount
                                FILE_ID | __LINE__,             // UniqueErrorValue
                                STATUS_SUCCESS,                 // FinalStatus
                                szErrorMsg);                    // Error Message
            }

            pIrp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation(pIrp);                /* Copy parameters to next stack */
            status = IoCallDriver(pLowerDevObj,pIrp);           /* Call driver below */
            break;

/*****************************************************************************
**********************   IRP_MN_QUERY_PNP_DEVICE_STATE   *********************
*****************************************************************************/

    case    IRP_MN_QUERY_PNP_DEVICE_STATE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_PNP_DEVICE_STATE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_CAPABILITIES:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

    case    IRP_MN_QUERY_STOP_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));

            status = STATUS_SUCCESS;
            SetPnpPowerFlags(pCard,PPF_STOP_PENDING);   // We must now expect a STOP IRP

            if(SPX_SUCCESS(status))                     // If we can stop, pass IRP on down
            {
                pIrp->IoStatus.Status = status;
                IoSkipCurrentIrpStackLocation(pIrp);
                status = IoCallDriver(pLowerDevObj,pIrp);
            }
            else                                        // If we can't then complete
            {
                pIrp->IoStatus.Status = status;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            }
            break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

    case    IRP_MN_CANCEL_STOP_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Card %d.\n",
                PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

            status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

            if(SPX_SUCCESS(status))
            {
                // we return the device to its working state here.
                ClearPnpPowerFlags(pCard,PPF_STOP_PENDING); // We are no longer expecting a STOP IRP.
                status = STATUS_SUCCESS;
            }

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            break;

/*****************************************************************************
****************************   IRP_MN_STOP_DEVICE   **************************
*****************************************************************************/

    case    IRP_MN_STOP_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_STOP_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            Spx_Card_StopDevice(pCard);             /* Stop the card hardware */

            pIrp->IoStatus.Status = STATUS_SUCCESS; /* Cannot fail this request */
            IoSkipCurrentIrpStackLocation(pIrp);        
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
************************   IRP_MN_QUERY_REMOVE_DEVICE   **********************
*****************************************************************************/
                
    case    IRP_MN_QUERY_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            status = STATUS_SUCCESS;

            if(SPX_SUCCESS(status))                 // If we can stop, pass IRP on down
            {
                SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING); // We are now ready to remove the card
                pIrp->IoStatus.Status   = status;
                IoSkipCurrentIrpStackLocation(pIrp);
                status = IoCallDriver(pLowerDevObj,pIrp);
            }
            else                                    // If we can't then complete
            {
                pIrp->IoStatus.Status = status;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            }

            break;

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

    case    IRP_MN_CANCEL_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

/* Call driver below first... */

            status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

            if(SPX_SUCCESS(status))
            {
                ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);   // We are no longer expecting to remove the device.
            }

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp,IO_NO_INCREMENT);
            break;

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

    case    IRP_MN_SURPRISE_REMOVAL:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            status = Spx_Card_StopDevice(pCard);    // Lets stop the port ready for the REMOVE IRP if we are not already.

            SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING); // We are now ready to remove the card
            pIrp->IoStatus.Status = status;
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

    case IRP_MN_REMOVE_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_REMOVE_DEVICE Irp for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

            status = Spx_Card_RemoveDevice(pFDO);

            pIrp->IoStatus.Status = status;
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

    default:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Card %d.\n",
                PRODUCT_NAME,pIrpStack->MinorFunction,pCard->CardNumber));
            
            IoSkipCurrentIrpStackLocation(pIrp);
            status = IoCallDriver(pLowerDevObj,pIrp);
            break;

    }

    return(status);

} /* Spx_Card_FDO_DispatchPnp */

/*****************************************************************************
**************************                         ***************************
**************************   Spx_CallDriverBelow   ***************************
**************************                         ***************************
******************************************************************************

prototype:      NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)

description:    Pass the IRP to the driver below this first and wait for it to complete.

parameters:     pLowerDevObj points to a device object for the device below
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)
{
    KEVENT      eventWaitLowerDrivers;
    NTSTATUS    status;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    IoCopyCurrentIrpStackLocationToNext(pIrp);                              /* Copy parameters to the stack below */
    KeInitializeEvent(&eventWaitLowerDrivers,SynchronizationEvent,FALSE);   /* Initialise event if need to wait */
    IoSetCompletionRoutine(pIrp,Spx_DispatchPnpPowerComplete,&eventWaitLowerDrivers,TRUE,TRUE,TRUE);

    if((status = IoCallDriver(pLowerDevObj,pIrp)) == STATUS_PENDING)
    {
        KeWaitForSingleObject(&eventWaitLowerDrivers,Executive,KernelMode,FALSE,NULL);
        status = pIrp->IoStatus.Status;
    }

    return(status);

} /* Spx_CallDriverBelow */

/************************************************************************************
************************                                    *************************
************************   Spx_DispatchPnpPowerComplete     *************************
************************                                    *************************
*************************************************************************************

prototype:      NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)

description:    The PnP IRP was completed by the lower-level drivers.
                Signal this to whoever registered us.

parameters:     pDevObject point to the device completing the IRP
                pIrp points to the Plug and Play I/O Request (IRP) to be completed
                Context was set when the lower driver was called (actually event)

returns:        NT Status Code

*/

NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)
{

    PIO_STACK_LOCATION  stack = NULL;
    PKEVENT             event = (PKEVENT) Context;
    NTSTATUS            status;

    
    UNREFERENCED_PARAMETER(pDevObject);

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering DispatchPnpComplete.\n",PRODUCT_NAME));

    status = STATUS_SUCCESS;
    stack = IoGetCurrentIrpStackLocation(pIrp);

    switch(stack->MajorFunction) 
    {
        case IRP_MJ_PNP:

            switch(stack->MinorFunction) 
            {
                case IRP_MN_START_DEVICE:       // Codes which need processing after lower drivers 
                case IRP_MN_QUERY_CAPABILITIES:
                case IRP_MN_CANCEL_STOP_DEVICE:
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    KeSetEvent(event,0,FALSE);      // Wake up waiting process //
                    return(STATUS_MORE_PROCESSING_REQUIRED);

                default:
                    break;
            }
            break;

        case IRP_MJ_POWER:
                KeSetEvent(event, 0, FALSE);        // Wake up waiting process 
                return(STATUS_MORE_PROCESSING_REQUIRED);

        default:
            break;

    }

    return(status);

} /* Spx_DispatchPnpPowerComplete */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Card_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:    Start the card device:
                    Process resources (interrupt, I/O, memory)
                    Initialise and start the hardware

parameters:     pDevObject point to the card device to start
                pIrp points to the start I/O Request (IRP)

returns:        NT Status Code

*/

NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
    PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
    PIO_STACK_LOCATION      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StartDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

/* Translate the card resources... */

    status = XXX_CardGetResources(  pDevObject,
                                    pIrpStack->Parameters.StartDevice.AllocatedResources,
                                    pIrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
    
    if(!SPX_SUCCESS(status))
        return(status);


/* Start the hardware... */

    if(!SPX_SUCCESS(status = XXX_CardStart(pCard)))
        return(status);

    SetPnpPowerFlags(pCard,PPF_STARTED);    /* Card has been started */

    return(status);

} /* Spx_Card_StartDevice */

/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_EnumPorts   ******************************
*****************************                   ******************************
******************************************************************************

prototype:      NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)

description:    Enumerate port devices found on the card device:

parameters:     pDevObject point to the card device to enumerate

returns:        NT Status Code

*/

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)
{
    PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
    PPORT_DEVICE_EXTENSION  pPort = NULL;

    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          PortPDO = NULL;

    UNICODE_STRING          PortPDOName;
    static ULONG            CurrentInstance = 0;

    UNICODE_STRING          InstanceStr;
    WCHAR                   InstanceNumberBuffer[10];
    POWER_STATE             PowerState;
    USHORT                  PortNumber  = 0;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_EnumPorts for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

// Name and create device objects for each port on the card... 
    
    for(PortNumber=0;PortNumber<pCard->NumberOfPorts;PortNumber++)
    {

        if(pCard->AttachedPDO[PortNumber] == NULL)          // Only create if not already present 
        {

// Create the base port name ("XxPort")... 
        
            RtlZeroMemory(&PortPDOName, sizeof(UNICODE_STRING));
            PortPDOName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
            PortPDOName.Buffer = SpxAllocateMem(PagedPool, PortPDOName.MaximumLength+sizeof(WCHAR));
            if(PortPDOName.Buffer == NULL) continue;
            RtlZeroMemory(PortPDOName.Buffer, PortPDOName.MaximumLength+sizeof(WCHAR));
            RtlAppendUnicodeToString(&PortPDOName, PORT_PDO_NAME_BASE);

// Create the instance ("0")... 

            RtlInitUnicodeString(&InstanceStr,NULL);
            InstanceStr.MaximumLength = sizeof(InstanceNumberBuffer);
            InstanceStr.Buffer = InstanceNumberBuffer;
            RtlIntegerToUnicodeString(CurrentInstance++, 10, &InstanceStr);

// Append instance to the device name ("XxPort0")... 

            RtlAppendUnicodeStringToString(&PortPDOName, &InstanceStr);

// Create the port device object with this name... 

            status = IoCreateDevice(pDevObject->DriverObject, 
                                    sizeof(PORT_DEVICE_EXTENSION),
                                    &PortPDOName,               // Object Name 
                                    FILE_DEVICE_SERIAL_PORT, 
                                    FILE_DEVICE_SECURE_OPEN, 
                                    TRUE, 
                                    &PortPDO);

            if(!SPX_SUCCESS(status))
            {
                SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed = %wZ\n",PRODUCT_NAME,&PortPDOName));
                SpxFreeMem(PortPDOName.Buffer);
                continue;
            }

            ASSERT(PortPDO != NULL);

// Increment the pdo's stacksize so that it can pass irps through... 

            PortPDO->StackSize += pDevObject->StackSize;

// Keep a pointer to the device in the card structure... 

            pCard->NumPDOs++;
            pCard->AttachedPDO[PortNumber] = PortPDO;
            ObReferenceObject(PortPDO);

// Initialise port device object and extension... 

            pPort = PortPDO->DeviceExtension;
            RtlZeroMemory(pPort,sizeof(PORT_DEVICE_EXTENSION));     // Clear the device extension 

            pPort->DeviceName = PortPDOName;

            KeInitializeSpinLock(&pPort->PnpPowerFlagsLock);        // Initialise the PNP flags lock 
            ClearPnpPowerFlags(pPort,PPF_STARTED);                  // Not started yet 
            ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);             // Not pending a stop 
            ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);           // Not pending a remove 
            ClearPnpPowerFlags(pPort,PPF_REMOVED);                  // Not removed 
            SetPnpPowerFlags(pPort,PPF_POWERED);                    // Initially powered up 

            InitializeListHead(&pPort->StalledIrpQueue);            // Initialise the stalled IRP list 
            KeInitializeSpinLock(&pPort->StalledIrpLock);           // Initialise the StalledIrpLock flags lock 
            pPort->UnstallingFlag = FALSE;                          // Initialise UnstallingIrps Flag.

            pPort->IsFDO = FALSE;
            pPort->PortNumber = PortNumber;                         // system port number 
            pPort->UniqueInstanceID = FALSE;                        // Instance ID not unique by default.
            pPort->DeviceIsOpen = FALSE;                            // Port is closed to start with 
            pPort->DeviceObject = PortPDO;                          // Backpointer to device object 
            pPort->DeviceState = PowerDeviceD0;                     // Port device in full power state 
            pPort->SystemState = PowerSystemWorking;                // System in full power State 
            pPort->pParentCardExt = pCard;                          // Point to the parent card extension 
            ExInitializeFastMutex(&pPort->OpenMutex);

            if(!SPX_SUCCESS(status = XXX_PortInit(pPort)))          // Initialise hardware 
                continue;

            // Inform Power Manager the of the new power state.
            PowerState.DeviceState = pPort->DeviceState;
            PoSetPowerState(pPort->DeviceObject, DevicePowerState, PowerState);

            PortPDO->Flags &= ~DO_DEVICE_INITIALIZING;              // Finished Initialising 
            PortPDO->Flags |= DO_BUFFERED_IO;                       // Do Buffered IO 
            PortPDO->Flags |= DO_BUS_ENUMERATED_DEVICE;             // Bus enumerated 
            PortPDO->Flags |= DO_POWER_PAGABLE;                     // Get power IRPs at IRQL PASSIVE_LEVEL 

        }
        else
        {
            PortPDO = pCard->AttachedPDO[PortNumber];
            pPort = PortPDO->DeviceExtension;

            if(pPort->PnpPowerFlags & PPF_REMOVED)
                ClearPnpPowerFlags(pPort,PPF_REMOVED);
        }
    }

    return(status);

} // End Spx_EnumPorts 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Card_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:    Stop the card device:
                    Stop the hardware
                    Deinitialise card resources (interrupt, I/O, memory)

parameters:     pCard points to the card device to stop

returns:        NT Status Code

*/

NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)
{
    NTSTATUS    status = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StopDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

    if(pCard->PnpPowerFlags & PPF_STARTED)      /* If card is running */
    {
        XXX_CardStop(pCard);                    /* Stop the card */
    }

    ClearPnpPowerFlags(pCard,PPF_STARTED);      /* Indicate card is stopped */
    ClearPnpPowerFlags(pCard,PPF_STOP_PENDING); /* Clear stop pending flag */

    return(status);

} /* Spx_Card_StopDevice */

/*****************************************************************************
*************************                           **************************
*************************   Spx_Card_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:      NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:    Remove the card device:
                    Deallocate any resources
                    Delete device object

parameters:     pDevObject points to the card device object to remove

returns:        NT Status Code

*/


NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
    PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
    PDEVICE_OBJECT          pPortPdo;
    PPORT_DEVICE_EXTENSION  pPort;
    NTSTATUS                status = STATUS_SUCCESS;
    int                     loop;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_Card_RemoveDevice for Card %d.\n", 
        PRODUCT_NAME, pCard->CardNumber));

/* First remove all "removed" port device objects... */

    for(loop=0; loop<PRODUCT_MAX_PORTS; loop++)
    {
        if(pPortPdo = pCard->AttachedPDO[loop])         /* Enumerated port PDO ? */
        {
            pPort = pPortPdo->DeviceExtension;          /* Get the device extension */
            XXX_PortDeInit(pPort);                      /* Deinitialise port structure */
            if(pPort->DeviceName.Buffer)
            {
                SpxFreeMem(pPort->DeviceName.Buffer);   /* Free device name buffer */
                pPort->DeviceName.Buffer = NULL;
            }
            pCard->AttachedPDO[loop] = NULL;            /* Remove the port PDO pointer */
            pCard->NumPDOs--;                           /* One less port attached */
            IoDeleteDevice(pPortPdo);                   /* Delete the port device object */
            ObDereferenceObject(pPortPdo);              /* Dereference the object */
        }
    }

/* Now, remove the card device object... */

    Spx_Card_StopDevice(pCard);                         /* Stop the card and release resources */
    XXX_CardDeInit(pCard);                              /* Deinitialise non-hardware fields */
    IoDetachDevice(pCard->LowerDeviceObject);           /* Detach card device from the device stack. */
    IoDeleteDevice(pDevObject);                         /* Delete Card FDO from system. */

    return(status);

} /* Spx_Card_RemoveDevice */



/*****************************************************************************
************************                              ************************
************************   Spx_Port_PDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)

description:    The plug and play dispatch routine to handle IRPs for port devices.

parameters:     pDevObject points to a port device object for this driver
                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:        NT Status Code

*/

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)
{
    PPORT_DEVICE_EXTENSION  pPort = pPDO->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    PIO_STACK_LOCATION      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    NTSTATUS                status;
    PWCHAR                  ReturnBuffer = NULL;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    status = pIrp->IoStatus.Status;

    switch (pIrpStack->MinorFunction) 
    {
   
/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
    
    case    IRP_MN_START_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Port %d.\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_UNSUCCESSFUL;

            if(SPX_SUCCESS(status = Spx_Port_StartDevice(pPDO)))
                Spx_UnstallIrps(pPort);                 // Restart any queued IRPs (from a previous start) 

            break;

/*****************************************************************************
*****************************   IRP_MN_QUERY_ID   ****************************
*****************************************************************************/
    
    case    IRP_MN_QUERY_ID:
    {
        PUNICODE_STRING pId = NULL;
        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

        switch(pIrpStack->Parameters.QueryId.IdType)
        {
        case    BusQueryCompatibleIDs:
        case    BusQueryDeviceID:
        case    BusQueryInstanceID:
        case    BusQueryHardwareIDs:
            {
                status = STATUS_SUCCESS;

                switch(pIrpStack->Parameters.QueryId.IdType)
                {
                case    BusQueryDeviceID:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryDeviceID Irp for Port %d.\n",
                            PRODUCT_NAME,pPort->PortNumber));
                        SpxDbgMsg(SPX_MISC_DBG,("%s: Device ID %wZ.\n", PRODUCT_NAME,&pPort->DeviceID));
                        pId = &pPort->DeviceID;
                        break;

                case    BusQueryInstanceID:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryInstanceID Irp for Port %d.\n",
                            PRODUCT_NAME, pPort->PortNumber));
                        SpxDbgMsg(SPX_MISC_DBG,("%s: Instance ID %wZ.\n",PRODUCT_NAME,&pPort->InstanceID));
                        pId = &pPort->InstanceID;
                        break;

                case    BusQueryCompatibleIDs:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryCompatibleIDs Irp for Port %d.\n",
                            PRODUCT_NAME, pPort->PortNumber));
                        pId = &pPort->CompatibleIDs;
                        break;

                case    BusQueryHardwareIDs:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryHardwareIDs Irp for Port %d.\n",
                            PRODUCT_NAME, pPort->PortNumber));
                        pId = &pPort->HardwareIDs;
                        break;
                
                default:
                    break;
                }

                if(pId)
                {
                    if(pId->Buffer)
                    {
                        if(ReturnBuffer = SpxAllocateMem(PagedPool, pId->Length + sizeof(WCHAR)))
                                RtlCopyMemory(ReturnBuffer, pId->Buffer, pId->Length + sizeof(WCHAR));
                        else    
                        {
                            sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                    pPort->PortNumber+1, pCard->PhysAddr);

                            Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                            pPort->DriverObject,            // Driver Object
                                            pPort->DeviceObject,            // Device Object (Optional)
                                            PhysicalZero,                   // Physical Address 1
                                            PhysicalZero,                   // Physical Address 2
                                            0,                              // SequenceNumber
                                            pIrpStack->MajorFunction,       // Major Function Code
                                            0,                              // RetryCount
                                            FILE_ID | __LINE__,             // UniqueErrorValue
                                            STATUS_SUCCESS,                 // FinalStatus
                                            szErrorMsg);                    // Error Message

                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }

                    pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
                }
                break;
            }
        
        default:
            break;
        }
        break;

    }

/*****************************************************************************
*************************   IRP_MN_QUERY_DEVICE_TEXT   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_DEVICE_TEXT:
    {
        PUNICODE_STRING pText = NULL;
        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_TEXT Irp for Port %d.\n",
                PRODUCT_NAME,pPort->PortNumber));

            if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription)
                pText = &pPort->DevDesc;

            if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation)
                pText = &pPort->DevLocation;

            if((pText == NULL)||(pText->Buffer == NULL))
                break;

            if(!(ReturnBuffer = SpxAllocateMem(PagedPool, pText->Length + sizeof(WCHAR))))
            {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                        pPort->PortNumber+1, pCard->PhysAddr);

                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                pPort->DriverObject,            // Driver Object
                                pPort->DeviceObject,            // Device Object (Optional)
                                PhysicalZero,                   // Physical Address 1
                                PhysicalZero,                   // Physical Address 2
                                0,                              // SequenceNumber
                                pIrpStack->MajorFunction,       // Major Function Code
                                0,                              // RetryCount
                                FILE_ID | __LINE__,             // UniqueErrorValue
                                STATUS_SUCCESS,                 // FinalStatus
                                szErrorMsg);                    // Error Message

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = STATUS_SUCCESS;
            RtlCopyMemory(ReturnBuffer, pText->Buffer, pText->Length + sizeof(WCHAR));
            pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
            break;
    }

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_CAPABILITIES:
    {
            PDEVICE_CAPABILITIES    pDevCaps = NULL;

            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));
            
            // Get the packet
            pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

            // Set the capabilities.
            pDevCaps->Version = 1;
            pDevCaps->Size = sizeof(DEVICE_CAPABILITIES);

            // We cannot wake the system.
            pDevCaps->SystemWake = PowerSystemUnspecified;
            pDevCaps->DeviceWake = PowerSystemUnspecified;

            // Set device state mapping...

            pDevCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
            pDevCaps->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
            pDevCaps->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

            // We have no latencies.
            pDevCaps->D1Latency = 0;
            pDevCaps->D2Latency = 0;
            pDevCaps->D3Latency = 0;

            // No locking or ejection.
            pDevCaps->LockSupported = FALSE;
            pDevCaps->EjectSupported = FALSE;

            // Removable
            pDevCaps->Removable = FALSE;

            // Not a Docking device.
            pDevCaps->DockDevice = FALSE;

            // System wide unique ID.
            pDevCaps->UniqueID = pPort->UniqueInstanceID;

            //UINumber
            pDevCaps->UINumber = pPort->PortNumber+1;

            // Raw capable
            pDevCaps->RawDeviceOK = TRUE;

            // Silent Install
            pDevCaps->SilentInstall = FALSE;

            // Surprise Removal
            pDevCaps->SurpriseRemovalOK = FALSE;

            status = STATUS_SUCCESS;
            break;
    }

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

    case    IRP_MN_QUERY_STOP_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_UNSUCCESSFUL;

            if(pPort->PnpPowerFlags & PPF_STARTED)
            {
                ExAcquireFastMutex(&pPort->OpenMutex);

                if(pPort->DeviceIsOpen) 
                {
                    ExReleaseFastMutex(&pPort->OpenMutex);
                    status = STATUS_DEVICE_BUSY;

                    SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
                        PRODUCT_NAME, pPort->PortNumber));
                }
                else
                {
                    SetPnpPowerFlags(pPort,PPF_STOP_PENDING);
                    status = STATUS_SUCCESS;
                    ExReleaseFastMutex(&pPort->OpenMutex);
                }
            }
            break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

    case    IRP_MN_CANCEL_STOP_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;
            ClearPnpPowerFlags(pPort,PPF_STOP_PENDING); // Clear the stop pending flag 
            Spx_UnstallIrps(pPort);                     // Restart any queued IRPs 
            break;

/*****************************************************************************
***************************   IRP_MN_STOP_DEVICE   ***************************
*****************************************************************************/

    case    IRP_MN_STOP_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_STOP_DEVICE Irp for Port %d\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;        // we must never fail this IRP (if we do we will probably unload).
            status = Spx_Port_StopDevice(pPort);
            ClearPnpPowerFlags(pPort,PPF_STOP_PENDING); // Clear the stop pending flag 
            break;

/*****************************************************************************
***********************   IRP_MN_QUERY_REMOVE_DEVICE   ***********************
*****************************************************************************/

    case    IRP_MN_QUERY_REMOVE_DEVICE: 
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME,pPort->PortNumber));

            ExAcquireFastMutex(&pPort->OpenMutex);

            if(pPort->DeviceIsOpen) 
            {
                ExReleaseFastMutex(&pPort->OpenMutex);
                status = STATUS_DEVICE_BUSY;

                SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
                    PRODUCT_NAME, pPort->PortNumber));
            }
            else
            {
                SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING); // We are now ready to remove the port
                status = STATUS_SUCCESS;
                ExReleaseFastMutex(&pPort->OpenMutex);
            }

            break; 

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

    case    IRP_MN_CANCEL_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Port %d.\n", 
                PRODUCT_NAME, pPort->PortNumber));
            
            status = STATUS_SUCCESS;
            ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);   // We are no longer expecting to remove the device.
            break; 

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

    case    IRP_MN_SURPRISE_REMOVAL:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Port %d\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;        // we must never fail this IRP (if we do we will probably unload).
            status = Spx_Port_StopDevice(pPort);
            SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING); // We are now ready to remove the port
            break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

    case    IRP_MN_REMOVE_DEVICE:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_REMOVE_DEVICE Irp for Port %d\n",
                PRODUCT_NAME,pPort->PortNumber));

            status = STATUS_SUCCESS;        // we must never fail this IRP (if we do we will probably unload).
            Spx_KillStalledIRPs(pPDO);      // Kill off any waiting IRPS on the stalled list 
            status = Spx_Port_RemoveDevice(pPDO);
            ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);   // Clear the pending flag 
            break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

    case    IRP_MN_QUERY_DEVICE_RELATIONS:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Port %d.\n", 
                PRODUCT_NAME, pPort->PortNumber));

            switch(pIrpStack->Parameters.QueryDeviceRelations.Type)
            {
            case TargetDeviceRelation:
                {
                    PDEVICE_RELATIONS pDevRel = NULL;

                    if(pIrp->IoStatus.Information != 0)
                        break;

                    if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
                    {
                        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);

                        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                        pPort->DriverObject,            // Driver Object
                                        pPort->DeviceObject,            // Device Object (Optional)
                                        PhysicalZero,                   // Physical Address 1
                                        PhysicalZero,                   // Physical Address 2
                                        0,                              // SequenceNumber
                                        pIrpStack->MajorFunction,       // Major Function Code
                                        0,                              // RetryCount
                                        FILE_ID | __LINE__,             // UniqueErrorValue
                                        STATUS_SUCCESS,                 // FinalStatus
                                        szErrorMsg);                    // Error Message

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    pDevRel->Count = 1;
                    pDevRel->Objects[0] = pPDO;
                    ObReferenceObject(pPDO);

                    status = STATUS_SUCCESS;
                    pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
                    break;
                }

            case BusRelations:
                {
                    PDEVICE_RELATIONS pDevRel = NULL;

                    if(pIrp->IoStatus.Information != 0)
                        break;

                    if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
                    {
                        CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);
                        
                        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                        pPort->DriverObject,            // Driver Object
                                        pPort->DeviceObject,            // Device Object (Optional)
                                        PhysicalZero,                   // Physical Address 1
                                        PhysicalZero,                   // Physical Address 2
                                        0,                              // SequenceNumber
                                        pIrpStack->MajorFunction,       // Major Function Code
                                        0,                              // RetryCount
                                        FILE_ID | __LINE__,             // UniqueErrorValue
                                        STATUS_SUCCESS,                 // FinalStatus
                                        szErrorMsg);                    // Error Message

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    pDevRel->Count = 0;
                    status = STATUS_SUCCESS;
                    pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
                    break;

                }

            default:
                break;
            }
            break;


    default:
            SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Port %d.\n", 
                PRODUCT_NAME,pIrpStack->MinorFunction, pPort->PortNumber));
            break;
    }

    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return(status);

} /* Spx_Port_PDO_DispatchPnp */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Port_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)

description:    Start the port device:
                    Setup external naming
                    Initialise and start the hardware

parameters:     pDevObject point to the card device to start
                pIrp points to the start I/O Request (IRP)

returns:        NT Status Code

*/

NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)
{

    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;    
    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StartDevice for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

    if(!pPort->CreatedSymbolicLink)
    {
        if(!SPX_SUCCESS(status = Spx_DoExternalNaming(pDevObject)))     // Set up external name for device 
            return(status);
    }

    if(!SPX_SUCCESS(status = XXX_PortStart(pPort)))             // Start hardware. 
    {
        Spx_RemoveExternalNaming(pDevObject);                   // Remove external naming.
        return(status);
    }

    SetPnpPowerFlags(pPort,PPF_STARTED);                        // Port has been started.
    ClearPnpPowerFlags(pPort,PPF_REMOVED);                      // Port is not removed...yet. 
    ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);                 // Not pending a stop. 
    ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);               // Not pending a remove. 

    return(status);

} // Spx_Port_StartDevice 


/*****************************************************************************
**************************                          **************************
**************************   Spx_GetExternalName   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)

description:    Setup external naming for a port:
                    get Dos Name for port 
                    form symbolic link name

parameters:     pDevObject points to the device object for the port to be named

returns:        NT Status Code

*/
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS                status = STATUS_SUCCESS;
    HANDLE                  PnPKeyHandle;
    UNICODE_STRING          TmpLinkName;
    WCHAR                   *pRegName = NULL;
    ULONG                   BuffLen = 0;
    CHAR                    szErrorMsg[MAX_ERROR_LOG_INSERT];   // Limited to 51 characters + 1 null 
        
    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_GetExternalName for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

    status = IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle);

    if(!SPX_SUCCESS(status))
        return(status);

// Get the device name allocated by the PNP manager from the registry... 
    if(pRegName = SpxAllocateMem(PagedPool,SYMBOLIC_NAME_LENGTH * sizeof(WCHAR) + sizeof(WCHAR)))
    {
        status = Spx_GetRegistryKeyValue(   PnPKeyHandle,
                                            L"PortName",
                                            sizeof(L"PortName"),
                                            pRegName,
                                            SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ZwClose(PnPKeyHandle);

    if(!SPX_SUCCESS(status))
    {
        if(pRegName != NULL) 
            SpxFreeMem(pRegName);

        return(STATUS_SUCCESS);         // Port has not been given a name yet but we must not fail.
    }

    RtlZeroMemory(&TmpLinkName, sizeof(UNICODE_STRING));

    if(!SPX_SUCCESS(status))
        goto NamingError;
    
    TmpLinkName.MaximumLength   = SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
    TmpLinkName.Buffer          = SpxAllocateMem(PagedPool, TmpLinkName.MaximumLength + sizeof(WCHAR));
    
    if(!TmpLinkName.Buffer)
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);

        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto NamingError;
    }

    RtlZeroMemory(TmpLinkName.Buffer, TmpLinkName.MaximumLength + sizeof(WCHAR));

    // Create the "\\DosDevices\\<SymbolicName>" string.
    RtlAppendUnicodeToString(&TmpLinkName, L"\\");
    RtlAppendUnicodeToString(&TmpLinkName, DEFAULT_DIRECTORY);
    RtlAppendUnicodeToString(&TmpLinkName, L"\\");
    RtlAppendUnicodeToString(&TmpLinkName, pRegName);

    pPort->SymbolicLinkName.Length          = 0;
    pPort->SymbolicLinkName.MaximumLength   = TmpLinkName.Length + sizeof(WCHAR);
    pPort->SymbolicLinkName.Buffer          = SpxAllocateMem(PagedPool, pPort->SymbolicLinkName.MaximumLength);
    
    if(!pPort->SymbolicLinkName.Buffer)
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);

        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto NamingError;
    }

    RtlZeroMemory(pPort->SymbolicLinkName.Buffer, pPort->SymbolicLinkName.MaximumLength);
    RtlAppendUnicodeStringToString(&pPort->SymbolicLinkName, &TmpLinkName);


    pPort->DosName.Buffer = SpxAllocateMem(PagedPool, 64 + sizeof(WCHAR));

    if(!pPort->DosName.Buffer)
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto NamingError;
    }

    pPort->DosName.MaximumLength = 64 + sizeof(WCHAR);

    pPort->DosName.Length = 0;
    RtlZeroMemory(pPort->DosName.Buffer, pPort->DosName.MaximumLength);
    RtlAppendUnicodeToString(&pPort->DosName, pRegName);
    RtlZeroMemory(((PUCHAR) (&pPort->DosName.Buffer[0])) + pPort->DosName.Length, sizeof(WCHAR));

    SpxDbgMsg(SPX_MISC_DBG, ("%s: DeviceName is %wZ\n", PRODUCT_NAME, &pPort->DeviceName));
    SpxDbgMsg(SPX_MISC_DBG, ("%s: DosName is %wZ\n", PRODUCT_NAME, &pPort->DosName));
    SpxDbgMsg(SPX_MISC_DBG, ("%s: SymbolicName is %wZ\n", PRODUCT_NAME, &pPort->SymbolicLinkName));

    if(pRegName != NULL)
        SpxFreeMem(pRegName);   // Free pRegName

    if(TmpLinkName.Buffer != NULL)
        SpxFreeMem(TmpLinkName.Buffer); // Free TmpLinkName

    return(status);


NamingError:;

    if(TmpLinkName.Buffer != NULL)
        SpxFreeMem(TmpLinkName.Buffer);

    if(pRegName != NULL)
        SpxFreeMem(pRegName);

    return(status);
}

/*****************************************************************************
**************************                          **************************
**************************   Spx_DoExternalNaming   **************************
**************************                          **************************
******************************************************************************

prototype:      NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:    Setup external naming for a port:
                    create symbolic link
                    add to registry
                    register and enable interface

parameters:     pDevObject points to the device object for the port to be named

returns:        NT Status Code

*/
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS                status = STATUS_SUCCESS;
    CHAR                    szErrorMsg[MAX_ERROR_LOG_INSERT];   // Limited to 51 characters + 1 null 
        
    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DoExternalNaming for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

// Get external name...
    if( !SPX_SUCCESS(status = Spx_GetExternalName(pDevObject)) || (pPort->DosName.Buffer == NULL))
        return(status);


    status = IoCreateSymbolicLink(&pPort->SymbolicLinkName, &pPort->DeviceName);  // Create the symbolic link... 

    if(!SPX_SUCCESS(status))
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        goto ExternalNamingError;
    }

// Add mapping to "SERIALCOMM" section of registry... 
    pPort->CreatedSymbolicLink = TRUE;
    
    status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP,
                                    L"SERIALCOMM",
                                    pPort->DeviceName.Buffer,
                                    REG_SZ,
                                    pPort->DosName.Buffer,
                                    pPort->DosName.Length + sizeof(WCHAR));

    if(!SPX_SUCCESS(status))
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Registry error.", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        goto ExternalNamingError;
    }

    status = IoRegisterDeviceInterface( pDevObject, (LPGUID)&GUID_CLASS_COMPORT,
                                        NULL, &pPort->DeviceClassSymbolicName);

    if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Interface error.", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        pPort->DeviceClassSymbolicName.Buffer = NULL;
        
        goto ExternalNamingError;
    }

    // Enable the device interface.
    status = IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, TRUE);

    if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
    {
        sprintf(szErrorMsg, "Port %d on card at %08lX: Interface error.", 
                pPort->PortNumber+1, pCard->PhysAddr);
        
        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                        pPort->DriverObject,            // Driver Object
                        pPort->DeviceObject,            // Device Object (Optional)
                        PhysicalZero,                   // Physical Address 1
                        PhysicalZero,                   // Physical Address 2
                        0,                              // SequenceNumber
                        0,                              // Major Function Code
                        0,                              // RetryCount
                        FILE_ID | __LINE__,             // UniqueErrorValue
                        STATUS_SUCCESS,                 // FinalStatus
                        szErrorMsg);                    // Error Message

        
        goto ExternalNamingError;
    }



    pPort->CreatedSerialCommEntry = TRUE;               // Set flag.

    return(status);


ExternalNamingError:;

    if(!SPX_SUCCESS(status))
        Spx_RemoveExternalNaming(pDevObject);           // Remove and tidy up any allocations 


    return(status);

} // End Spx_DoExternalNaming 

/*****************************************************************************
************************                              ************************
************************   Spx_RemoveExternalNaming   ************************
************************                              ************************
******************************************************************************

prototype:      NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:    Remove external naming:
                    remove symbolic link
                    remove from registry
                    stop interface

parameters:     pDevObject points to the device object for the port to be named.

returns:        NT Status Code

*/
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(pPort->CreatedSymbolicLink)
    {
        if(pPort->DosName.Buffer)
        {
            SpxFreeMem(pPort->DosName.Buffer);                      // Free DOS name buffer. 
            pPort->DosName.Buffer = NULL;
        }

        if(pPort->SymbolicLinkName.Buffer)
        {
            SpxFreeMem(pPort->SymbolicLinkName.Buffer);             // Free symbolic link name buffer. 
            pPort->SymbolicLinkName.Buffer = NULL;
        }

        Spx_GetExternalName(pDevObject);    // Get external name..

        if(pPort->SymbolicLinkName.Buffer)
            status = IoDeleteSymbolicLink(&pPort->SymbolicLinkName);    // Delete Symbolic Link. 

        if(pPort->DeviceClassSymbolicName.Buffer)   // Device Interface name
            IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, FALSE);  // Disable Device Interface.


        pPort->CreatedSymbolicLink = FALSE;                                             // Reset created flag. 
    }

    if(pPort->DosName.Buffer)
    {
        SpxFreeMem(pPort->DosName.Buffer);                  // Free DOS name buffer. 
        pPort->DosName.Buffer = NULL;
    }

    if(pPort->SymbolicLinkName.Buffer)
    {
        SpxFreeMem(pPort->SymbolicLinkName.Buffer);         // Free symbolic link name buffer. 
        pPort->SymbolicLinkName.Buffer = NULL;
    }

    if(pPort->CreatedSerialCommEntry && pPort->DeviceName.Buffer)
    {
        RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP,     // Delete SERIALCOMM registry entry. 
                                SERIAL_DEVICE_MAP,
                                pPort->DeviceName.Buffer);

        pPort->CreatedSerialCommEntry = FALSE;              // Reset created flag.
    }

    if(pPort->DeviceClassSymbolicName.Buffer)   // Device Interface name
    {           
        SpxFreeMem(pPort->DeviceClassSymbolicName.Buffer);                  // Free Device Interface Name.
        pPort->DeviceClassSymbolicName.Buffer = NULL;
    }

    return(STATUS_SUCCESS);

} // End Spx_RemoveExternalNaming 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Port_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)

description:    Stop the port device:
                    Stop the hardware
                    Remove external naming

parameters:     pPort points to the port device extension to be stopped

returns:        NT Status Code

*/

NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)
{
    NTSTATUS    status  = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StopDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

    if(pPort->PnpPowerFlags & PPF_STARTED)
        XXX_PortStop(pPort);                                    // Stop the port hardware. 

    ClearPnpPowerFlags(pPort,PPF_STARTED);                      // Indicate card is stopped. 
    ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);                 // Clear stop pending flag.

    return(status);

} // End Spx_Port_StopDevice

/*****************************************************************************
*************************                           **************************
*************************   Spx_Port_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:      NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:    Remove the port device object:
                    Remove PDO pointer from card structure
                    Deinitialise port hardware
                    Delete the device object

parameters:     pDevObject points to the port device object to be stopped

returns:        NT Status Code

*/
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION  pPort   = pDevObject->DeviceExtension;
    PCARD_DEVICE_EXTENSION  pCard   = pPort->pParentCardExt;
    NTSTATUS                status  = STATUS_SUCCESS;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_RemoveDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

    if(pPort->PnpPowerFlags & PPF_REMOVED)                  // Has device been removed already?
        return(STATUS_SUCCESS);

    Spx_Port_StopDevice(pPort);                             // Stop the hardware.
    ClearPnpPowerFlags(pPort,PPF_STARTED);                  // Mark the PDO as stopped.

    Spx_RemoveExternalNaming(pDevObject);                   // Remove external naming. 


// Mark the port device as "removed", but don't delete the PDO until the card device is removed...
    SetPnpPowerFlags(pPort,PPF_REMOVED);                    // Mark the PDO as "removed".

    return(status);

} // End Spx_Port_RemoveDevice 




/////////////////////////////////////////////////////////////////////////////////////////////
// Create an Instance ID for the port and try to make it globally unique if possible.
//
NTSTATUS
Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort)
{
    PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
    NTSTATUS                status = STATUS_SUCCESS;
    CHAR                    szTemp[100];        // Space to hold string 
    int                     szTempPos = 0;
    HANDLE                  PnPKeyHandle;
    BOOLEAN                 UseBusWideInstanceID = FALSE;  // Try to create system wide unique instance IDs

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_CreatePortInstanceID for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

    status = IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_READ, &PnPKeyHandle);

    if(SPX_SUCCESS(status))
    {
        ULONG Data = 0;

        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, L"UseBusWideInstanceID", 
                            sizeof(L"UseBusWideInstanceID"), &Data, sizeof(ULONG))))
        {
            if(Data > 0)
                UseBusWideInstanceID = TRUE;  // Installer has told us to use a bus wide instance ID 
                                              // because child devices already exist with that type of ID.
        }
        

        ZwClose(PnPKeyHandle);
    }

    if(UseBusWideInstanceID)
    {
        pPort->UniqueInstanceID = FALSE;    // ID created is not unique system wide.
        status = STATUS_SUCCESS;
    }
    else
    {
        switch(pCard->InterfaceType)
        {
        case Isa:
            // Start Instance ID with ISA address
            szTempPos += sprintf(szTemp,"ISA&%08X%08X&", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
            pPort->UniqueInstanceID = TRUE; // ID created is unique system wide.
            status = STATUS_SUCCESS;
            break;

        case PCIBus:
            {
                ULONG PCI_BusNumber = 0;
                ULONG PCI_DeviceFunction = 0;
                ULONG ResultLength;

                // Try to get DevicePropertyBusNumber
                if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyBusNumber, 
                                            sizeof(PCI_BusNumber), &PCI_BusNumber, &ResultLength)))
                    break;


                // Start Instance ID with PCI bus number
                szTempPos += sprintf(szTemp,"PCI&%04X&", PCI_BusNumber);

                // Try to get DevicePropertyAddress
                if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyAddress, 
                                            sizeof(PCI_DeviceFunction), &PCI_DeviceFunction, &ResultLength)))
                    break;
                

                // Add on PCI Device and Function IDs
                szTempPos += sprintf(szTemp + szTempPos,"%08X&", PCI_DeviceFunction);
                pPort->UniqueInstanceID = TRUE; // ID created is unique system wide.

                status = STATUS_SUCCESS;
                break;
            }
        
        default:
            pPort->UniqueInstanceID = FALSE;    // ID created is not unique system wide.
            status = STATUS_SUCCESS;
            break;

        }

    }

    // Finish off the InstanceID with the port number on the card.
    sprintf(szTemp + szTempPos,"%04X", pPort->PortNumber);

    status = Spx_InitMultiString(FALSE, &pPort->InstanceID, szTemp, NULL);


    return status;
}



// End of SPX_PNP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\sx_iioc.c ===
/************************************************************************/
/*									*/
/*	Title		:	SX support functions for INTERNAL IOCTLs*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	14th October 1998			*/
/*									*/
/*	Version		:	1.0.0					*/
/*									*/
/*	Description	:	Support functions to support the	*/
/*				INTERNAL IOCTLs for specific hardware:	*/
/*					XXX_SetHandFlow			*/
/*									*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#include "precomp.h"

/*****************************************************************************
*****************************                     ****************************
*****************************   XXX_SetHandFlow   ****************************
*****************************                     ****************************
******************************************************************************

prototype:	void	XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort,IN SERIAL_IOCTL_SYNC *pS)

description:	Call to set the handshaking and flow control

parameters:	pPort points to the port device extension structure
		pS points to a serial ioctl synchronization structure

returns:	STATUS_SUCCESS

*/

void	XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort,IN PSERIAL_IOCTL_SYNC pS)
{
	Slxos_SyncExec(pPort,SerialSetHandFlow,pS,0x0E);

} /* XXX_SetHandFlow */
                                                        
/* End of SX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\sx_powr.c ===
/************************************************************************/
/*									*/
/*	Title		:	SX Power Management Functions		*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	14th October 1998			*/
/*									*/
/*	Version		:	1.0.0					*/
/*									*/
/*	Description	:	SX specfic Power Functions:		*/
/*					XXX_CardPowerDown()		*/
/*					XXX_CardPowerUp()		*/
/*					XXX_PortPowerDown()		*/
/*					XXX_PortPowerUp()		*/
/*									*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#include "precomp.h"

/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

void	CardStop(IN PCARD_DEVICE_EXTENSION pCard);

/*****************************************************************************
***************************                       ****************************
***************************   XXX_CardPowerDown   ****************************
***************************                       ****************************
******************************************************************************

prototype:	NTSTATUS XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard)

description:	Power is about to be removed from the device, do the following:
		-	save any card context not already contained in device extension
		-	switch off polling and interrupts
		-	set flag to prevent access the card memory (it may not be there)
		-	set card to a non-active state

assumptions:	Assume that all of the ports have been powered down and the
		PPF_POWERED flag cleared, so that IRPs are queued for the device

parameters:	pCard points to the card device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard)
{
	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d]: Entering XXX_CardPowerDown\n",
		PRODUCT_NAME,pCard->CardNumber));

/* Stop polling/interrupts... */

        if(pCard->PolledMode)
        {
		SpxDbgMsg(SPX_MISC_DBG,("%s: Extension is polled.  Cancelling.\n",PRODUCT_NAME));
		KeCancelTimer(&pCard->PolledModeTimer);
        }

/* Prevent driver from trying to access hardware... */

/* Set hardware to known, non-active state... */

	CardStop(pCard);			/* Stop the hardware */

	return(STATUS_SUCCESS);

} /* XXX_CardPowerDown */

/*****************************************************************************
****************************                     *****************************
****************************   XXX_CardPowerUp   *****************************
****************************                     *****************************
******************************************************************************

prototype:	NTSTATUS XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard)

description:	Power is about to be restored to the device, after a power down:
		-	re-allow access to the card memory
		-	reset card hardware and reload download code
		-	switch polling/interrupts back on
		-	restore port settings/context from current device extension values

assumptions:	calling code should reset the PPF_POWERED flag after calling this function
		and unstall any IRPs waiting on the queue

		assume this function is only called after an XXX_SavePowerState,
		i.e.	resources are still translated
			memory is still mapped in
			dpcs and timers initialized

parameters:	pCard points to the card device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d]: Entering XXX_CardPowerUp\n",
		PRODUCT_NAME,pCard->CardNumber));

/* Re-allow access to card hardware... */

/* reset card hardware and reload download code... */

	if(Slxos_ResetBoard(pCard) != SUCCESS)		/* Reset the card and start download */
		return(STATUS_DEVICE_NOT_READY);	/* Error */

/* Restart polled timer/interrupt... */

	if(pCard->PolledMode)				/* Set up polled mode */
	{
		LARGE_INTEGER	PolledPeriod;

		PolledPeriod.QuadPart = -100000;	/* 100,000*100nS = 10mS */
		KeSetTimer(&pCard->PolledModeTimer,PolledPeriod,&pCard->PolledModeDpc);
	}

	return(status);

} /* XXX_CardPowerUp */

/*****************************************************************************
*************************                            *************************
*************************   XXX_PortQueryPowerDown   *************************
*************************                            *************************
******************************************************************************

prototype:	NTSTATUS XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort)

description:	System is asking if its OK to power down the port, say NO if:
		-	port is open and data in the transmit buffer, and not flowed off

parameters:	pPort points to the port device extension structure

returns:	STATUS_SUCCESS
		STATUS_DEVICE_BUSY

*/

NTSTATUS XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d,port=%d]: Entering XXX_PortQueryPowerDown\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

	return(STATUS_SUCCESS);

} /* XXX_PortQueryPowerDown */

/*****************************************************************************
***************************                       ****************************
***************************   XXX_PortPowerDown   ****************************
***************************                       ****************************
******************************************************************************

prototype:	NTSTATUS XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort)

description:	Power is about to be removed from the port, do the following:
		-	save any port context not already contained in device extension
		-	actual powering off the port hardware occurs in XXX_CardPowerDown

assumptions:	Assume that PPF_POWERED flag cleared, so that IRPs are queued for the device

parameters:	pPort points to the port device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PCHAN			pChan = (PCHAN)pPort->pChannel;
	KIRQL			OldIrql;
	ULONG			loop;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d,port=%d]: Entering XXX_PortPowerDown\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

	if(pPort->DeviceIsOpen)			/* Was port opened before ? */
	{

/* Save the current modem signals... */

		pPort->SavedModemControl = Slxos_GetModemControl(pPort);

/* Save the current transmit & receive buffer contents... */

		KeAcquireSpinLock(&pCard->DpcLock,&OldIrql);	/* Protect Dpc for this board */

		for(loop = 0; loop < BUFFER_SIZE; loop++)	/* Save transmit buffer */
			pPort->saved_hi_txbuf[loop] = pChan->hi_txbuf[loop];
		pPort->saved_hi_txipos = pChan->hi_txipos;	/* Save transmit input pointer */
		pPort->saved_hi_txopos = pChan->hi_txopos;	/* Save transmit output pointer */

		for(loop = 0; loop < BUFFER_SIZE; loop++)	/* Save receive buffer */
			pPort->saved_hi_txbuf[loop] = pChan->hi_txbuf[loop];
		pPort->saved_hi_rxipos = pChan->hi_rxipos;	/* Save receive input pointer */
		pPort->saved_hi_rxopos = pChan->hi_rxopos;	/* Save receive output pointer */

		KeReleaseSpinLock(&pCard->DpcLock,OldIrql);	/* Free the Dpc lock */
	}

	return(STATUS_SUCCESS);

} /* XXX_PortPowerDown */

/*****************************************************************************
****************************                     *****************************
****************************   XXX_PortPowerUp   *****************************
****************************                     *****************************
******************************************************************************

prototype:	NTSTATUS XXX_PortPowerUp(IN PCARD_DEVICE_EXTENSION pCard)

description:	Power is about to be restored to the port, after a power down:
		-	restore port settings/context from current device extension values
		-	reopen the card port, if open in the extension

assumptions:	calling code should reset the PPF_POWERED flag after calling this function
		and unstall any IRPs waiting on the queue

		assume this function is only called after an XXX_SavePowerState,
		i.e.	resources are still translated
			memory is still mapped in
			dpcs and timers initialized

		assume that either the transmit buffer was empty or blocked by flow
		control when saving its contents.  can't fail the power down, but
		an earlier query would have been refused if actively sending data.

parameters:	pPort points to the port device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PCHAN			pChan = (PCHAN)pPort->pChannel;
	KIRQL			OldIrql;
	ULONG			loop;
	NTSTATUS		status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d,port=%d]: Entering XXX_PortPowerUp\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

	if(pPort->DeviceIsOpen)			/* Was port opened before ? */
	{
		Slxos_EnableAllInterrupts(pPort);	/* Yes, re-open */

		if(pPort->SavedModemControl & SERIAL_MCR_RTS)	/* RTS active ? */
			Slxos_SetRTS(pPort);			/* Yes */
		else
			Slxos_ClearRTS(pPort);			/* No */

		if(pPort->SavedModemControl & SERIAL_MCR_DTR)	/* DTR active ? */
			Slxos_SetDTR(pPort);			/* Yes */
		else
			Slxos_ClearDTR(pPort);			/* No */
	}

	Slxos_ResetChannel(pPort);			/* Apply initial port settings */
	
/* Restore saved transmit buffer contents... */

	if(pPort->DeviceIsOpen)			/* Was port opened before ? */
	{
		KeAcquireSpinLock(&pCard->DpcLock,&OldIrql);	/* Protect Dpc for this board */

		for(loop = 0; loop < BUFFER_SIZE; loop++)	/* Restore transmit buffer */
			pChan->hi_txbuf[loop] = pPort->saved_hi_txbuf[loop];
		pChan->hi_txipos = pPort->saved_hi_txipos;	/* Restore transmit input pointer */
		pChan->hi_txopos = pPort->saved_hi_txopos;	/* Restore transmit output pointer */

/* As port could be receiving data from open, restore saved rx buffer in Slxos_PollForInterrupt */

		KeReleaseSpinLock(&pCard->DpcLock,OldIrql);	/* Free the Dpc lock */
	}

	return(status);

} /* XXX_PortPowerUp */

/*****************************************************************************
********************************              ********************************
********************************   CardStop   ********************************
********************************              ********************************
******************************************************************************

prototype:	void	CardStop(IN PCARD_DEVICE_EXTENSION pCard)

description:	Stops the cards processor, placing card in known non-active state

parameters:	pCard points to the card extension structure

returns:	none

*/

void	CardStop(IN PCARD_DEVICE_EXTENSION pCard)
{
	LARGE_INTEGER	delay;
	ULONG		loop;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d]: Entering CardStop\n",
		PRODUCT_NAME,pCard->CardNumber));

	switch(pCard->CardType)
	{
	case	SiHost_2:
		pCard->Controller[SI2_ISA_RESET] = SI2_ISA_RESET_SET;	/* Put card in reset */
		pCard->Controller[SI2_ISA_IRQ11] = SI2_ISA_IRQ11_CLEAR;	/* Disable interrupt 11 */
		pCard->Controller[SI2_ISA_IRQ12] = SI2_ISA_IRQ12_CLEAR;	/* Disable interrupt 12 */
		pCard->Controller[SI2_ISA_IRQ15] = SI2_ISA_IRQ15_CLEAR;	/* Disable interrupt 15 */
		pCard->Controller[SI2_ISA_INTCLEAR] = SI2_ISA_INTCLEAR_CLEAR;/* Disable Z280 interrupts */
		pCard->Controller[SI2_ISA_IRQSET] = SI2_ISA_IRQSET_CLEAR;	/* Disable ISA interrupts */
		break;

	case	SiPCI:
		pCard->Controller[SI2_PCI_SET_IRQ] = 0;			/* clear any interrupts */
		pCard->Controller[SI2_PCI_RESET] = 0;			/* put z280 into reset */
		break;

	case	Si3Isa:
	case	Si3Pci:
		pCard->Controller[SX_CONFIG] = 0;
		pCard->Controller[SX_RESET] = 0;

		loop = 0;
		delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */
		while((pCard->Controller[SX_RESET]&1) && loop++<10000)	/* spin 'til done */
			KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */
		break;

	default:
		break;
	}

	return;						/* Stopped OK */

} /* CardStop */

/* End of SX_POWR.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\sx_pnp.c ===
/************************************************************************/
/*									*/
/*	Title		:	SX Plug and Play Functions		*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	21st September 1998			*/
/*									*/
/*	Version		:	1.0.0					*/
/*									*/
/*	Description	:	SX specfic Plug and Play Functions:	*/
/*					XXX_CardGetResources()		*/
/*					XXX_CardInit()			*/
/*					XXX_CardDeInit()		*/
/*					XXX_CardStart()			*/
/*					XXX_CardStop()			*/
/*					XXX_PortInit()			*/
/*					XXX_PortDeInit()		*/
/*					XXX_PortStart()			*/
/*					XXX_PortStop()			*/
/*									*/
/*					CardFindType()			*/
/*									*/
/************************************************************************/

/* History...

1.0.0	21/09/98 NPV	Creation.

*/

#include "precomp.h"


#define FILE_ID		SX_PNP_C		// File ID for Event Logging see SX_DEFS.H for values.


/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

BOOLEAN	CheckMemoryWindow(IN PCARD_DEVICE_EXTENSION pCard);

#ifdef	ALLOC_PRAGMA
#pragma alloc_text (PAGE, CheckMemoryWindow)
#endif

/*****************************************************************************
**************************                          **************************
**************************   XXX_CardGetResources   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS XXX_CardGetResources(	IN PDEVICE_OBJECT pDevObject, 
												IN PCM_RESOURCE_LIST pResList,
												IN PCM_RESOURCE_LIST pTrResList)

description:	Interpret the raw and translated resources and store in the device extension structure
				of the specified device object.

parameters:		pDevObject points to the card device object structure
				pResList points to the raw resource list
				pTrResList points to the translated resource list

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardGetResources(	IN PDEVICE_OBJECT pDevObject, 
								IN PCM_RESOURCE_LIST pResList,
								IN PCM_RESOURCE_LIST pTrResList)
{
	PCARD_DEVICE_EXTENSION			pCard = pDevObject->DeviceExtension;
	PCM_FULL_RESOURCE_DESCRIPTOR	pFullResourceDesc = NULL;
	PCM_PARTIAL_RESOURCE_LIST		pPartialResourceList;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR	pPartialResourceDesc;

	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	NTSTATUS	status = STATUS_NOT_IMPLEMENTED;
	ULONG		count, loop;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering CardGetResources\n", PRODUCT_NAME));
	SpxDbgMsg(SPX_MISC_DBG,("%s: Resource pointer is 0x%X\n", PRODUCT_NAME,pResList));
	SpxDbgMsg(SPX_MISC_DBG,("%s: Translated resource pointer is 0x%X\n", PRODUCT_NAME, pTrResList));

// Check that the resource lists are valid... 
	if((pResList == NULL)||(pTrResList == NULL))	// Do the resource lists exist?
	{	// No 					
		ASSERT(pResList != NULL);
		ASSERT(pTrResList != NULL);

		sprintf(szErrorMsg, "Card %d has been given no resources.", pCard->CardNumber);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,	// Driver Object
						pCard->DeviceObject,	// Device Object (Optional)
						PhysicalZero,			// Physical Address 1
						PhysicalZero,			// Physical Address 2
						0,						// SequenceNumber
						0,						// Major Function Code
						0,						// RetryCount
						FILE_ID | __LINE__,		// UniqueErrorValue
						STATUS_SUCCESS,			// FinalStatus
						szErrorMsg);			// Error Message

		return(STATUS_INSUFFICIENT_RESOURCES);
	}

	ASSERT(pResList->Count >= 1);			// Should be at least one resource
	ASSERT(pTrResList->Count >= 1);			// for raw and translated 

	// Find out the card type... 
	if((pCard->CardType = SpxGetNtCardType(pCard->DeviceObject)) == -1)
	{
		sprintf(szErrorMsg, "Card %d is unrecognised.", pCard->CardNumber);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message


		return(STATUS_DEVICE_DOES_NOT_EXIST);
	}


// Process the raw resource list...
	if(pFullResourceDesc = &pResList->List[0])	// Point to raw resource list
	{
		pPartialResourceList = &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc = pPartialResourceList->PartialDescriptors;
		count = pPartialResourceList->Count;	// number of partial resource descriptors 

		pCard->InterfaceType = pFullResourceDesc->InterfaceType;	// Bus type
		pCard->BusNumber = pFullResourceDesc->BusNumber;			// Bus number 

		for(loop = 0; loop < count; loop++, pPartialResourceDesc++)
		{
			switch(pPartialResourceDesc->Type)
			{
			case CmResourceTypeMemory:		// Memory resource
				pCard->RawPhysAddr = pPartialResourceDesc->u.Memory.Start;
				break;

			case CmResourceTypePort:		// I/O resource
				break;

			case CmResourceTypeInterrupt:
				pCard->OriginalIrql = pPartialResourceDesc->u.Interrupt.Level;
				pCard->OriginalVector = pPartialResourceDesc->u.Interrupt.Vector;
				pCard->ProcessorAffinity = pPartialResourceDesc->u.Interrupt.Affinity;
				break;

			default:
				break;
			}
		}

	} // Raw Descriptors 


// Process the translated resource list... 
	if(pFullResourceDesc = &pTrResList->List[0])	// Point to translated resource list
	{
		pPartialResourceList = &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc = pPartialResourceList->PartialDescriptors;
		count = pPartialResourceList->Count;		// number of partial resource descriptors 

		pCard->InterfaceType = pFullResourceDesc->InterfaceType;	// Bus type 
		pCard->BusNumber = pFullResourceDesc->BusNumber;			// Bus number 

		for(loop = 0; loop < count; loop++, pPartialResourceDesc++)
		{
			switch(pPartialResourceDesc->Type)
			{
			case CmResourceTypeMemory:		// Memory resource
				{
					if(pPartialResourceDesc->u.Memory.Length == 0x80)	// Must be config space 
					{
						pCard->PCIConfigRegisters = pPartialResourceDesc->u.Memory.Start;
						pCard->SpanOfPCIConfigRegisters = pPartialResourceDesc->u.Memory.Length;
					}
					else
					{
						pCard->PhysAddr = pPartialResourceDesc->u.Memory.Start;
						pCard->SpanOfController = pPartialResourceDesc->u.Memory.Length;
					}
					break;
				}

			case CmResourceTypePort:		// I/O resource
				break;

			case CmResourceTypeInterrupt:
				pCard->TrIrql = (KIRQL)pPartialResourceDesc->u.Interrupt.Level;
				pCard->TrVector = pPartialResourceDesc->u.Interrupt.Vector;
				pCard->ProcessorAffinity = pPartialResourceDesc->u.Interrupt.Affinity;
				pCard->PolledMode = 0;		// Switch off polled mode 
				break;

			default:
				break;
			}
		}

	} // Translated Descriptors 

	return(STATUS_SUCCESS);

} // End XXX_CardGetResources. 

/*****************************************************************************
******************************                  ******************************
******************************   XXX_CardInit   ******************************
******************************                  ******************************
******************************************************************************

prototype:		NTSTATUS XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard)

description:	Initialise non-hardware fields of the card extension to a known state

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardInit\n", PRODUCT_NAME));

	pCard->PolledMode = 1;					// Poll by default 
	pCard->InterruptMode = Latched;			// Default interrupt mode 
	pCard->InterruptShareable = FALSE;		// Default interrupt share mode 
	pCard->OurIsr = SerialISR;				// Interrupt Service Routine 
	pCard->OurIsrContext = pCard;			// ISR data context 

	// Initialise spinlock for the DPC... 
	KeInitializeSpinLock(&pCard->DpcLock);		// Initialise DPC lock for the card 
	pCard->DpcFlag = FALSE;						// Initialise DPC ownership for this card 

	return(status);

} // End XXX_CardInit.

/*****************************************************************************
*****************************                    *****************************
*****************************   XXX_CardDeInit   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard)

description:	De-Initialise any non-hardware allocations made during XXX_CardInit

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardDeInit\n",PRODUCT_NAME));

	return(status);

} // End XXX_CardDeInit.

/*****************************************************************************
******************************                  ******************************
******************************   CardFindType   ******************************
******************************                  ******************************
******************************************************************************

prototype:		BOOLEAN	CheckMemoryWindow(IN PCARD_DEVICE_EXTENSION pCard)

description:	Perform checking where possible on memory window.

parameters:		pCard points to a card device extension structure with following entries:
				BaseController points to valid virtual address for shared memory window

returns:		FALSE to recognise card at memory loaction
				TRUE SUCCESS
*/

BOOLEAN	CheckMemoryWindow(IN PCARD_DEVICE_EXTENSION pCard)
{
	_u32	offset;
	pu8		pAddr;
	_u8		*cp;
	BOOLEAN	CardPresent;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering CardFindType\n", PRODUCT_NAME));
	SpxDbgMsg(SPX_MISC_DBG,("%s: pCard->PhysAddr = 0x%08lX\n", PRODUCT_NAME, pCard->PhysAddr));
	SpxDbgMsg(SPX_MISC_DBG,("%s: pCard->BaseController = 0x%08lX\n", PRODUCT_NAME, pCard->BaseController));

	pAddr = pCard->BaseController;		// Point to base of memory window 

	switch(pCard->CardType)
	{
	case SiHost_1:	// ISA card phase 1
		{
            pAddr[0x8000] = 0;
            for(offset = 0; offset < 0x8000; offset++)
                pAddr[offset] = 0;

            for(offset = 0; offset < 0x8000; offset++) 
			{
                if(pAddr[offset] != 0) 
                    return FALSE;
            }

            for(offset = 0; offset < 0x8000; offset++) 
                pAddr[offset] = 0xff;

            for(offset = 0; offset < 0x8000; offset++) 
			{
                if(pAddr[offset] != 0xff) 
                    return FALSE;
            }

            return TRUE;

		}

	case SiHost_2:	// SI/XIO ISA card phase 2
		{
			// Examine memory window for SI2 ISA signature... 
			CardPresent = TRUE;		// Assume card is there 
			for(offset=SI2_ISA_ID_BASE; offset<SI2_ISA_ID_BASE+8; offset++)
			{
				if((pAddr[offset]&0x7) != ((_u8)(~offset)&0x7)) 
					CardPresent = FALSE;
			}

			if(CardPresent)
				return TRUE;	// Card is present

			break;
		}

	case SiPCI:		// SI/XIO PCI card
		{
			if(pCard->SpanOfController == SI2_PCI_WINDOW_LEN)	// Only card with this memory window size 
				return TRUE;

			break;
		}

	case Si3Isa:	// SX ISA card
	case Si3Pci:	// SX PCI card
		{
			// Examine memory window for SX VPD PROM contents... 
			CardPresent = TRUE;						// Assume card is present
			offset = SX_VPD_ROM|2*SX_VPD_IDENT;		// Offset of ID string 
			for(cp = SX_VPD_IDENT_STRING;*cp != '\0';++cp)
			{
				if(pAddr[offset] != *cp) 
					CardPresent = FALSE;	// Mismatch 

				offset += 2;
			}

			if(CardPresent)				// Found an SX card 
			{
				// Set SX Unique Id
				pCard->UniqueId = (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID1*2]<<24)
								+ (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID2*2]<<16)
								+ (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID3*2]<<8)
								+ (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID4*2]);

				if(pCard->CardType == Si3Isa)	// SX ISA card 
				{
					if((pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID1*2]&SX_UNIQUEID_MASK) == SX_ISA_UNIQUEID1)
						return TRUE;
				}

				if(pCard->CardType == Si3Pci)	// SX PCI card 
				{
					if((pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID1*2]&SX_UNIQUEID_MASK) == SX_PCI_UNIQUEID1)
						return TRUE;
				}
			}

			break;
		}

	case Si_2:		// MCA card
	case SiEisa:	// EISA card
	case SxPlusPci:	// SX+ PCI card
		return TRUE;
	}

	SpxDbgMsg(SPX_MISC_DBG,("%s: Card not at memory location or card type is not recognised.\n", PRODUCT_NAME));

	return FALSE;	// Check Failed

} // End CheckMemoryWindow.

/*****************************************************************************
*****************************                   ******************************
*****************************   XXX_CardStart   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard)

description:	Start card operations:
				map in memory
				initialise hardware
				initialise interrupts/polling
				start interrupts/polling

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard)
{

	NTSTATUS status = STATUS_SUCCESS;
	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	int SlxosStatus = SUCCESS;
	BOOLEAN bInterruptConnnected = FALSE;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardStart\n", PRODUCT_NAME));


// Map in the virtual memory address... 
	pCard->BaseController = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);

	if(!pCard->BaseController)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto Error;
	}


	if(pCard->CardType == Si3Pci)
	{
		if(!SPX_SUCCESS(status = PLX_9050_CNTRL_REG_FIX(pCard)))	// Apply PLX9050 fix 
			goto Error;
	}

	if(!CheckMemoryWindow(pCard))	// Check if card is present at memory location.
	{
		status = STATUS_UNSUCCESSFUL;
		goto Error;
	}

	if(pCard->CardType == SiPCI)				// SI/XIO PCI card? 
		pCard->PolledMode = 1;					// Yes, polled mode only

	pCard->Controller = pCard->BaseController;	// Default 

	if(pCard->CardType == SxPlusPci)	
		pCard->Controller = pCard->BaseController + pCard->SpanOfController/2 - SX_WINDOW_LEN;


	ResetBoardInt(pCard);				// Reset the board interrupt to prevent problems when sharing 

// Set up interrupt mode, if not possible, switch to polled... 

	if(!(pCard->PolledMode))				// Set up interrupt mode 
	{	
		// MCA and PCI card interrupts 	
		if((pCard->InterfaceType == MicroChannel) || (pCard->InterfaceType == PCIBus))		
		{
			pCard->InterruptMode = LevelSensitive;	// are level sensitive and 
			pCard->InterruptShareable = TRUE;		// can share interrupts 
		}

		// Try to connect to interrupt.
		if(SPX_SUCCESS(status = IoConnectInterrupt(	&pCard->Interrupt,			// Interrupt object
													pCard->OurIsr,				// Service routine  
													pCard->OurIsrContext,		// Service context 
													NULL,						// SpinLock (optional) 
													pCard->TrVector,			// Vector 
													pCard->TrIrql,				// IRQL 
													pCard->TrIrql,				// Synchronize IRQL
													pCard->InterruptMode,		// Mode (Latched/Level Sensitive) 
													pCard->InterruptShareable,	// Sharing mode 
													pCard->ProcessorAffinity,	// Processors to handle ints 
													FALSE)))					// Floating point save 	
		{						
			IoInitializeDpcRequest(pCard->DeviceObject, Slxos_IsrDpc);	// Initialise DPC
			bInterruptConnnected = TRUE;	// Set Interrupt Connected flag. 
		}
		else
		{	
			// Tell user the problem 
			sprintf(szErrorMsg, "Card at %08lX: Interrupt unavailable, Polling.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,		// Driver Object
							pCard->DeviceObject,		// Device Object (Optional)
							PhysicalZero,				// Physical Address 1
							PhysicalZero,				// Physical Address 2
							0,							// SequenceNumber
							0,							// Major Function Code
							0,							// RetryCount
							FILE_ID | __LINE__,			// UniqueErrorValue
							STATUS_SUCCESS,				// FinalStatus
							szErrorMsg);				// Error Message

			pCard->PolledMode = 1;			// No interrupt, poll instead 
		}
	}



	SlxosStatus = Slxos_ResetBoard(pCard);		// Reset the card and start download 
	
	if(SlxosStatus != SUCCESS)	
	{
		status = STATUS_UNSUCCESSFUL;		// Error 
		goto Error;
	}

// Set up polled mode operation and Start timer with a period of 10ms (100Hz)...

	if(pCard->PolledMode)	// Set up polled mode 
	{
		LARGE_INTEGER	PolledPeriod;

		KeInitializeTimer(&pCard->PolledModeTimer);
		KeInitializeDpc(&pCard->PolledModeDpc, Slxos_PolledDpc, pCard);
		PolledPeriod.QuadPart = -100000;		// 100,000*100nS = 10mS 
		KeSetTimer(&pCard->PolledModeTimer, PolledPeriod, &pCard->PolledModeDpc);
	}


	return status;




Error:

	if(bInterruptConnnected)
		IoDisconnectInterrupt(pCard->Interrupt);	// Disconnect Interrupt.

	if(pCard->BaseController)	// If mapped in.
		MmUnmapIoSpace(pCard->BaseController, pCard->SpanOfController);	// Unmap.

	switch(SlxosStatus)	
	{
	case MODULE_MIXTURE_ERROR:
		{
			sprintf(szErrorMsg, "Card at %08lX: Incompatible module mixture.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			return(status);
		}

	case NON_SX_HOST_CARD_ERROR:
		{
			sprintf(szErrorMsg, "Card at %08lX: SXDCs not supported by this card.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			return(status);
		}

	case DCODE_OR_NO_MODULES_ERROR:
		{
			sprintf(szErrorMsg, "Card at %08lX: No ports found.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			return(status);
		}

	default:
		break;
	}


	switch(status)
	{
	case STATUS_DEVICE_DOES_NOT_EXIST:
	case STATUS_UNSUCCESSFUL:
		{
			sprintf(szErrorMsg, "Card at %08lX: Unrecognised or malfunctioning.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	case STATUS_INSUFFICIENT_RESOURCES:
		{
			sprintf(szErrorMsg, "Card at %08lX: Insufficient resources.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	default:
		break;

	}

	return status;


} // End XXX_CardStart.

/*****************************************************************************
******************************                  ******************************
******************************   XXX_CardStop   ******************************
******************************                  ******************************
******************************************************************************

prototype:		NTSTATUS XXX_StopCardDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:	Stop card operations:
				stop interrupts/polling
				disconnect interrupts/polling
				stop hardware
				unmap memory
				free any hardware related allocations

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardStop\n", PRODUCT_NAME));

// Stop interrupts...
	if(!(pCard->PolledMode))
		IoDisconnectInterrupt(pCard->Interrupt);

// Stop polling... 
    if(pCard->PolledMode)
    {
		SpxDbgMsg(SERDIAG5,("%s: Extension is polled.  Cancelling.\n", PRODUCT_NAME));
		KeCancelTimer(&pCard->PolledModeTimer);
    }

// Unmap virtual memory address...
	if(pCard->BaseController)	// If mapped in - almost certainly.
		MmUnmapIoSpace(pCard->BaseController, pCard->SpanOfController);

	return(status);

} // End XXX_CardStop.

/*****************************************************************************
******************************                  ******************************
******************************   XXX_PortInit   ******************************
******************************                  ******************************
******************************************************************************

prototype:		NTSTATUS XXX_PortInit(PPORT_DEVICE_EXTENSION pPort)

description:	Initialise non-hardware fields of the port extension:
				identifier strings

parameters:		pPort points to the PORT_DEVICE_EXTENSION structure
				the following fields are initialised on entry:
					PortNumber	Card relative port number (0 based)
					pCard		Pointer to parent card extension

returns:		STATUS_SUCCESS
				The following PORT_DEVICE_EXTENSION fields must be set up:
					pPort->DeviceID
					pPort->HardwareIDs
					pPort->InstanceID
					pPort->DevDesc
*/

NTSTATUS XXX_PortInit(PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PSXCARD		pSxCard = (PSXCARD)pCard->Controller;
	NTSTATUS	status = STATUS_SUCCESS;
	PMOD		pMod;
	PCHAN		pChan;
	int			nModules = 0;
	int			nChannels = 0;
	_u8			loop;
	char		szTemp[30];			// Space to hold string 
	char		szCard[10];			// Space to hold card type string 
	char		szModule[20];		// Space to hold module type string 
	int			i = 0;				// String index 
	char		*ptr;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortInit\n",PRODUCT_NAME));

	if(pSxCard->cc_init_status == NO_ADAPTERS_FOUND)
	{
		SpxDbgMsg(SPX_MISC_DBG,("%s: No modules found on card.\n",PRODUCT_NAME));
		return(STATUS_NOT_FOUND);			// No modules/ports found on this card 
	}

// Scan through the module and channel structures until the specfied port is reached... 
	pMod = (PMOD)(pCard->Controller + sizeof(SXCARD));	// First module structure on card 

	while(nModules++ < SLXOS_MAX_MODULES)
	{
		pChan = (PCHAN)((pu8)pMod + sizeof(SXMODULE));	// First channel on module 

		for(loop = 0; loop < pMod->mc_type; loop++)
		{
			if(nChannels++ == (int)pPort->PortNumber)	// Match with port number?
			{
				pPort->pChannel = (PUCHAR)pChan;		// Yes, store channel pointer
				break;	// Stop scan 
			}

			pChan = (PCHAN)((pu8)pChan + sizeof(SXCHANNEL));
		}

		if(pPort->pChannel) 
			break;			// If channel found, stop scan 

		if(pMod->mc_next & 0x8000) 
			pMod = (PMOD)pChan;	// Next module structure 
		else	
			break;
	}

	if(!(pPort->pChannel)) 
		return(STATUS_NOT_FOUND);	// No port found 

// Initialise the card type string... 

	switch(pCard->CardType)
	{
	case SiHost_1:
	case SiHost_2:
	case Si_2:
	case SiEisa:
	case SiPCI:
		switch(pMod->mc_chip)				// SI/XIO card type depends on module type 
		{
		case TA4:
		case TA4_ASIC:
		case TA8:
		case TA8_ASIC:	
			sprintf(szCard,"SI"); 
			break;

		case MTA_CD1400:
		case SXDC:		
			sprintf(szCard,"XIO"); 
			break;

		default:		
			sprintf(szCard,"XIO"); 
			break;
		}
		break;

	case Si3Isa:
	case Si3Pci:
		pPort->DetectEmptyTxBuffer = TRUE;	
		sprintf(szCard,"SX");
		break;

	case SxPlusPci:
		pPort->DetectEmptyTxBuffer = TRUE;	
		sprintf(szCard,"SX");
		break;

	default:
		sprintf(szCard,"Unknown");
		break;
	}


	//if(pCard->PolledMode)
	//	pPort->DetectEmptyTxBuffer = TRUE;


// Initialise the module type string...

	switch(pMod->mc_chip)			// Set the module type
	{
	case TA4:
	case TA4_ASIC:				
		sprintf(szModule,"TA4"); 
		break;

	case TA8:
	case TA8_ASIC:				
		sprintf(szModule,"TA8"); 
		break;

	case MTA_CD1400:
	{
		_u8	ModType;

		i = sprintf(szModule,"MTA8");			// Generic name root

		pChan = (PCHAN)pPort->pChannel;
		if((pMod->mc_mods == MOD_RS232RJ45_OI)||(pMod->mc_mods == MOD_2_RS232RJ45S))
			ModType = pMod->mc_mods;		// Use full type field 
		else
		{
			if(pChan->chan_number <= 3)
				ModType = pMod->mc_mods & 0xF;		// First module type 
			else	
				ModType = pMod->mc_mods >> 4;		// Second module type 
		}

		switch(ModType)
		{
		case MOD_RS232DB25:
		case MOD_2_RS232DB25:		
			sprintf(szModule+i,"&DM"); 
			break;

		case MOD_RS232RJ45:
		case MOD_2_RS232RJ45:		
			sprintf(szModule+i,"&RJ"); 
			break;

		case MOD_2_RS232RJ45S:		
			sprintf(szModule+i,"&RJX"); 
			break;

		case MOD_RS232RJ45_OI:		
			sprintf(szModule+i,"&O"); 
			break;

		case MOD_PARALLEL:
		case MOD_2_PARALLEL:
			if(pChan->chan_number > 0)	
				sprintf(szModule+i,"&PR");
			else				
				sprintf(szModule+i,"&PP");
			break;

		case MOD_RS422DB25:
		case MOD_2_RS422DB25:		
			sprintf(szModule+i,"&422"); 
			break;

		default:
			break;
		}
		break;
	}
	case SXDC:
	{
		_u8	ModType;

		i = sprintf(szModule,"SXDC8");			// Generic name root

		pChan = (PCHAN)pPort->pChannel;
		ModType = pMod->mc_mods & 0xF;			// Only look at first module type for SXDC

		switch(ModType)
		{
		case MOD_2_RS232DB25:		
			sprintf(szModule+i,"&DX"); 
			break;

		case MOD_2_RS232RJ45:	
			sprintf(szModule+i,"&RJX"); 
			break;

		case MOD_2_RS232DB25_DTE:		
			sprintf(szModule+i,"&MX"); 
			break;

		case MOD_2_PARALLEL:
			if(pChan->chan_number > 3)	
				sprintf(szModule+i,"&DX");
			else 
			{
				if(pChan->chan_number > 0)	
					sprintf(szModule+i,"&PXR");
				else				
					sprintf(szModule+i,"&PXP");
			}
			break;

		case MOD_2_RS422DB25:
			sprintf(szModule+i,"&422DX"); 
			break;

		default:
			break;
		}
		break;
	}

	default:
		i += sprintf(szModule,"Unknown"); 
		break;
	}

// Initialise device identifiers... 
	sprintf(szTemp,"%s\\%s",szCard,szModule);	// Set the card name 
	Spx_InitMultiString(FALSE,&pPort->DeviceID,szTemp,NULL);
	Spx_InitMultiString(TRUE,&pPort->HardwareIDs,szTemp,NULL);

#ifndef BUILD_SPXMINIPORT
	// Form an InstanceID for the port.
	if(!SPX_SUCCESS(status = Spx_CreatePortInstanceID(pPort)))
		return status;
#endif

	sprintf(szTemp,"%s\\",szCard);
	Spx_InitMultiString(TRUE,&pPort->CompatibleIDs,szTemp,NULL);

	sprintf(szTemp,"Specialix %s Port %d",szModule,pPort->PortNumber+1);

	ptr = szTemp;
	while(*ptr)		
	{
		if(*ptr=='&')		// Replace all "&" with "/" in the device description.
			*ptr = '/';

		ptr++;
	}

	Spx_InitMultiString(FALSE,&pPort->DevDesc,szTemp,NULL);


/* Not required as we are using INF file 
	i = sprintf(szTemp, "Port %d on ", pPort->PortNumber + 1);

	switch(pCard->InterfaceType)
	{
	case Isa:
		sprintf(szTemp+i, "ISA Card 0x%08lX", pCard->PhysAddr);
		break;

	case PCIBus:
		sprintf(szTemp+i, "PCI Card 0x%08lX", pCard->PhysAddr);
		break;

	default:
		sprintf(szTemp+i, "Card 0x%08lX", pCard->PhysAddr);
		break;
	}


	Spx_InitMultiString(FALSE,&pPort->DevLocation,szTemp,NULL);
*/

	return(status);	// Done 

} // End XXX_PortInit.

/*****************************************************************************
*****************************                    *****************************
*****************************   XXX_PortDeInit   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS XXX_PortDeInit(PPORT_DEVICE_EXTENSION pPort)

description:	De-Initialise any port extension allocations made during XXX_PortInit

parameters:		pPort points to the PORT_DEVICE_EXTENSION structure
				the following fields are initialised on entry:
					PortNumber	Card relative port number (0 based)
					pCard		Pointer to parent card extension

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_PortDeInit(PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortDeInit\n",PRODUCT_NAME));

// Free identifier string allocations... 

	if(pPort->DeviceID.Buffer)		SpxFreeMem(pPort->DeviceID.Buffer);
	if(pPort->CompatibleIDs.Buffer)	SpxFreeMem(pPort->CompatibleIDs.Buffer);
	if(pPort->HardwareIDs.Buffer)	SpxFreeMem(pPort->HardwareIDs.Buffer);
	if(pPort->InstanceID.Buffer)	SpxFreeMem(pPort->InstanceID.Buffer);
	if(pPort->DevDesc.Buffer)		SpxFreeMem(pPort->DevDesc.Buffer);
	if(pPort->DevLocation.Buffer)	SpxFreeMem(pPort->DevLocation.Buffer);

	return(status);	// Done 

} // End XXX_PortDeInit 

/*****************************************************************************
*****************************                   ******************************
*****************************   XXX_PortStart   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort)

description:	Start port operations after port has been initialised

parameters:		pPort points to the PORT_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS		status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortStart\n",PRODUCT_NAME));

/* Initialize the list heads for the read, write, and mask queues... */

	InitializeListHead(&pPort->ReadQueue);
	InitializeListHead(&pPort->WriteQueue);
	InitializeListHead(&pPort->MaskQueue);
	InitializeListHead(&pPort->PurgeQueue);

/* Initialize the spinlock associated with fields read (& set) by IO Control functions... */

	KeInitializeSpinLock(&pPort->ControlLock);
	KeInitializeSpinLock(&pPort->BufferLock);

/* Initialize the timers used to timeout operations... */

	KeInitializeTimer(&pPort->ReadRequestTotalTimer);
	KeInitializeTimer(&pPort->ReadRequestIntervalTimer);
	KeInitializeTimer(&pPort->WriteRequestTotalTimer);
	KeInitializeTimer(&pPort->ImmediateTotalTimer);
	KeInitializeTimer(&pPort->XoffCountTimer);
	KeInitializeTimer(&pPort->LowerRTSTimer);

/* Initialise the dpcs that will be used to complete or timeout various IO operations... */

	KeInitializeDpc(&pPort->CompleteWriteDpc,SerialCompleteWrite,pPort);
	KeInitializeDpc(&pPort->CompleteReadDpc,SerialCompleteRead,pPort);
	KeInitializeDpc(&pPort->TotalReadTimeoutDpc,SerialReadTimeout,pPort);
	KeInitializeDpc(&pPort->IntervalReadTimeoutDpc,SerialIntervalReadTimeout,pPort);
	KeInitializeDpc(&pPort->TotalWriteTimeoutDpc,SerialWriteTimeout,pPort);
	KeInitializeDpc(&pPort->CommErrorDpc,SerialCommError,pPort);
	KeInitializeDpc(&pPort->CompleteImmediateDpc,SerialCompleteImmediate,pPort);
	KeInitializeDpc(&pPort->TotalImmediateTimeoutDpc,SerialTimeoutImmediate,pPort);
	KeInitializeDpc(&pPort->CommWaitDpc,SerialCompleteWait,pPort);
	KeInitializeDpc(&pPort->XoffCountTimeoutDpc,SerialTimeoutXoff,pPort);
	KeInitializeDpc(&pPort->XoffCountCompleteDpc,SerialCompleteXoff,pPort);
	KeInitializeDpc(&pPort->StartTimerLowerRTSDpc,SerialStartTimerLowerRTS,pPort);
	KeInitializeDpc(&pPort->PerhapsLowerRTSDpc,SerialInvokePerhapsLowerRTS,pPort);

/* Specify that this driver only supports buffered IO.  This basically means that the IO */
/* system copies the users data to and from system supplied buffers. */

	pPort->DeviceObject->Flags |= DO_BUFFERED_IO;
	pPort->OriginalController = pCard->PhysAddr;

/* Default device control fields... */

	pPort->SpecialChars.XonChar = SERIAL_DEF_XON;
	pPort->SpecialChars.XoffChar = SERIAL_DEF_XOFF;
	pPort->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
	pPort->HandFlow.FlowReplace = SERIAL_RTS_CONTROL;

/* Default line configuration: 1200,E,7,1 */

	pPort->CurrentBaud = 1200;
	pPort->LineControl = SERIAL_7_DATA | SERIAL_EVEN_PARITY | SERIAL_1_STOP;
	pPort->ValidDataMask = 0x7F;

/* Default xon/xoff limits... */

	pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
	pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;
	pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2))+(pPort->BufferSize>>4));

/* Define which baud rates can be supported... */

	pPort->SupportedBauds = SERIAL_BAUD_USER;
	pPort->SupportedBauds |= SERIAL_BAUD_075;
	pPort->SupportedBauds |= SERIAL_BAUD_110;
	pPort->SupportedBauds |= SERIAL_BAUD_150;
	pPort->SupportedBauds |= SERIAL_BAUD_300;
	pPort->SupportedBauds |= SERIAL_BAUD_600;
	pPort->SupportedBauds |= SERIAL_BAUD_1200;
	pPort->SupportedBauds |= SERIAL_BAUD_1800;
	pPort->SupportedBauds |= SERIAL_BAUD_2400;
	pPort->SupportedBauds |= SERIAL_BAUD_4800;
	pPort->SupportedBauds |= SERIAL_BAUD_9600;
	pPort->SupportedBauds |= SERIAL_BAUD_19200;
	pPort->SupportedBauds |= SERIAL_BAUD_38400;
	pPort->SupportedBauds |= SERIAL_BAUD_57600;
	pPort->SupportedBauds |= SERIAL_BAUD_115200;

/* Set up values for interval timing... */

	pPort->ShortIntervalAmount.LowPart = 1;
	pPort->ShortIntervalAmount.HighPart = 0;
	pPort->ShortIntervalAmount = RtlLargeIntegerNegate(pPort->ShortIntervalAmount);
	pPort->LongIntervalAmount.LowPart = 10000000;
	pPort->LongIntervalAmount.HighPart = 0;
	pPort->LongIntervalAmount = RtlLargeIntegerNegate(pPort->LongIntervalAmount);
	pPort->CutOverAmount.LowPart = 200000000;
	pPort->CutOverAmount.HighPart = 0;

#ifdef WMI_SUPPORT
	//
	// Fill in WMI hardware data
	//

	pPort->WmiHwData.IrqNumber			= pCard->TrIrql;
	pPort->WmiHwData.IrqVector			= pCard->TrVector;
	pPort->WmiHwData.IrqLevel			= pCard->TrIrql;
	pPort->WmiHwData.IrqAffinityMask	= pCard->ProcessorAffinity;
	
	if(pCard->InterruptMode == Latched)
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LATCHED;
	else
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LEVEL;

	pPort->WmiHwData.BaseIOAddress = (ULONG_PTR)pCard->Controller;


	//
	// Fill in WMI device state data (as defaults)
	//

	pPort->WmiCommData.BaudRate					= pPort->CurrentBaud;
	UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
	UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);

	pPort->WmiCommData.MaximumBaudRate			= 115200U;	// 115200k baud max
	pPort->WmiCommData.MaximumOutputBufferSize	= (UINT32)((ULONG)-1);
	pPort->WmiCommData.MaximumInputBufferSize	= (UINT32)((ULONG)-1);

	pPort->WmiCommData.Support16BitMode			= FALSE;
	pPort->WmiCommData.SupportDTRDSR			= TRUE;
	pPort->WmiCommData.SupportIntervalTimeouts	= TRUE;
	pPort->WmiCommData.SupportParityCheck		= TRUE;
	pPort->WmiCommData.SupportRTSCTS			= TRUE;
	pPort->WmiCommData.SupportXonXoff			= TRUE;
	pPort->WmiCommData.SettableBaudRate			= TRUE;
	pPort->WmiCommData.SettableDataBits			= TRUE;
	pPort->WmiCommData.SettableFlowControl		= TRUE;
	pPort->WmiCommData.SettableParity			= TRUE;
	pPort->WmiCommData.SettableParityCheck		= TRUE;
	pPort->WmiCommData.SettableStopBits			= TRUE;
	pPort->WmiCommData.IsBusy					= FALSE;


	// Fill in wmi perf data (all zero's)
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));


	//
    // Register for WMI
	//
	
	SpxPort_WmiInitializeWmilibContext(&pPort->WmiLibInfo);

	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_REGISTER);
#endif

/* Initialise the port hardware... */

	Slxos_SyncExec(pPort,Slxos_ResetChannel,pPort,0x02);	/* Apply initial port settings */
	Slxos_SyncExec(pPort,SerialClrRTS,pPort,0x03);		/* Clear RTS signal */
	Slxos_SyncExec(pPort,SerialClrDTR,pPort,0x04);		/* Cleat DTR signal */

	return(status);

} // End XXX_PortStart.

/*****************************************************************************
******************************                  ******************************
******************************   XXX_PortStop   ******************************
******************************                  ******************************
******************************************************************************

prototype:	NTSTATUS XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort)

description:	Stop port operations

parameters:	pPort points to the PORT_DEVICE_EXTENSION structure

returns:	STATUS_SUCCESS

*/


NTSTATUS XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortStop\n",PRODUCT_NAME));

#ifdef WMI_SUPPORT
	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_DEREGISTER);
#endif

/* Cancel timers... */
	
	KeCancelTimer(&pPort->ReadRequestTotalTimer);
	KeCancelTimer(&pPort->ReadRequestIntervalTimer);
	KeCancelTimer(&pPort->WriteRequestTotalTimer);
	KeCancelTimer(&pPort->ImmediateTotalTimer);
	KeCancelTimer(&pPort->XoffCountTimer);
	KeCancelTimer(&pPort->LowerRTSTimer);

/* Cancel pending DPCs... */

	KeRemoveQueueDpc(&pPort->CompleteWriteDpc);
	KeRemoveQueueDpc(&pPort->CompleteReadDpc);
	KeRemoveQueueDpc(&pPort->TotalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->IntervalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->TotalWriteTimeoutDpc);
	KeRemoveQueueDpc(&pPort->CommErrorDpc);
	KeRemoveQueueDpc(&pPort->CompleteImmediateDpc);
	KeRemoveQueueDpc(&pPort->TotalImmediateTimeoutDpc);
	KeRemoveQueueDpc(&pPort->CommWaitDpc);
	KeRemoveQueueDpc(&pPort->XoffCountTimeoutDpc);
	KeRemoveQueueDpc(&pPort->XoffCountCompleteDpc);
	KeRemoveQueueDpc(&pPort->StartTimerLowerRTSDpc);
	KeRemoveQueueDpc(&pPort->PerhapsLowerRTSDpc);

	return(status);

} // End XXX_PortStop.


/* End of SX_PNP.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\spx_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING pMofResourceName,
						OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchSystemControl)
#pragma alloc_text(PAGE, SpxPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpxPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpxPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataItem)
#endif




/********************************************************************************
********************								*****************************
********************	Spx_SystemControlDispatch	*****************************
********************								*****************************
********************************************************************************/
NTSTATUS
Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		pCommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION	IrpDisposition;
	PDEVICE_OBJECT			pLowerDevObj = pCommonData->LowerDeviceObject;
    NTSTATUS				status = pIrp->IoStatus.Status;

    PAGED_CODE();

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DispatchSystemControl.\n", PRODUCT_NAME));

    status = WmiSystemControl(&pCommonData->WmiLibInfo, pDevObject, pIrp, &IrpDisposition);
                                 
    switch(IrpDisposition)
    {
        case IrpProcessed:
        {
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            // This irp has not been completed, but has been fully processed, we will complete it now.
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            // This irp is either not a WMI irp or is a WMI irp targetted at a device lower in the stack.

			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }
                                    
        default:
        {
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
			
			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }        
    }
    
	return(status);
}







// End of prototypes.


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID StdSerialPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID StdSerialPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID StdSerialPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID StdSerialPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID StdSerialPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI

WMIGUIDREGINFO SpxPort_WmiGuidList[] =
{
    { &StdSerialPortNameGuid, 1, 0 },
    { &StdSerialPortCommGuid, 1, 0 },
    { &StdSerialPortHWGuid, 1, 0 },
    { &StdSerialPortPerfGuid, 1, 0 },
    { &StdSerialPortPropertiesGuid, 1, 0}
};


#define SpxPort_WmiGuidCount (sizeof(SpxPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpxPort_WmiGuidCount;
    WmilibContext->GuidList				= SpxPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpxPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpxPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpxPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpxPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	
    WmilibContext->WmiFunctionControl	= NULL;	

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.


	return(status);
}





NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\sx_w2k.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SX_W2K.C															*
*																						*
*	Creation:		14th April 1999														*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Functions specific to SX and Windows 2000							*
*																						*
****************************************************************************************/

// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SpxGetNtCardType)
#endif


#define FILE_ID		SX_W2K_C		// File ID for Event Logging see SX_DEFS.H for values.


/*****************************************************************************
****************************                      ****************************
****************************   SpxGetNtCardType   ****************************
****************************                      ****************************
******************************************************************************

prototype:		ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
	
description:	Return the NT defined card type for the specified card
				device object.

parameters:		pDevObject points to the NT device object for the card

returns:		NT defined card type,
				or -1 if not identified
*/

ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard	= pDevObject->DeviceExtension;
	ULONG					NtCardType = -1;
	PVOID					pPropertyBuffer = NULL;
	ULONG					ResultLength = 0; 
	NTSTATUS				status = STATUS_SUCCESS;
	ULONG					BufferLength = 1;	// Initial size.

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate the buffer

	if(pPropertyBuffer == NULL)									// SpxAllocateMem failed.
		return -1;

	// Try to get HardwareID
	status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
									pPropertyBuffer, &ResultLength);

	if(!SPX_SUCCESS(status))					// IoGetDeviceProperty failed.
	{
		if(status == STATUS_BUFFER_TOO_SMALL)	// Buffer was too small.
		{
			SpxFreeMem(pPropertyBuffer);			// Free old buffer that was not big enough.
			BufferLength = ResultLength + 1;		// Set BufferLength to size required.

			pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate a bigger buffer.

			if(pPropertyBuffer == NULL)			// SpxAllocateMem failed.
				return -1;

			// Try again.
			status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
											pPropertyBuffer, &ResultLength);

			if(!SPX_SUCCESS(status))			// IoGetDeviceProperty failed a second time.
			{
				SpxFreeMem(pPropertyBuffer);	// Free buffer.
				return -1;
			}
		}
		else
		{
			SpxFreeMem(pPropertyBuffer);			// Free buffer.
			return -1;
		}
	}



	// If we get to here then there is something in the PropertyBuffer.

	_wcsupr(pPropertyBuffer);		// Convert HardwareID to uppercase


	// SX
	if(wcsstr(pPropertyBuffer, SIXIO_ISA_HWID) != NULL)
		NtCardType = SiHost_2;

	if(wcsstr(pPropertyBuffer, SIXIO_PCI_HWID) != NULL)
		NtCardType = SiPCI;

	if(wcsstr(pPropertyBuffer, SX_ISA_HWID) != NULL)
		NtCardType = Si3Isa;

	if(wcsstr(pPropertyBuffer, SX_PCI_HWID) != NULL)
		NtCardType = Si3Pci;

	if(wcsstr(pPropertyBuffer, SXPLUS_PCI_HWID) != NULL)
		NtCardType = SxPlusPci;	


	SpxFreeMem(pPropertyBuffer);			// Free buffer.

	return(NtCardType);

} // SpxGetNtCardType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\write.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );



NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialWrite dispatch entry for: %x\n",Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
       
#ifdef	CHECK_COMPLETED
	SpxDbgMsg(SERDEBUG,("Start WRITE %lX\n",Irp));
#endif

    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;


    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) 
	{

        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //

        return SerialStartOrQueue(
                   pPort,
                   Irp,
                   &pPort->WriteQueue,
                   &pPort->CurrentWriteIrp,
                   SerialStartWrite
                   );

    } 
	else 
	{

        Irp->IoStatus.Status = STATUS_SUCCESS;
        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
            
           
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,17);
#endif
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,0);

        return STATUS_SUCCESS;
    }

}

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    pPort - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

--*/

{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    do 
	{
        //
        // If there is an xoff counter then complete it.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if(pPort->CurrentXoffIrp) 
		{
            InsertHeadList(&pPort->WriteQueue,&pPort->CurrentWriteIrp->Tail.Overlay.ListEntry);
			SpxIRPCounter(pPort, pPort->CurrentWriteIrp, IRP_QUEUED);

            if(!SetFirstStatus) 
			{
                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            if(SERIAL_REFERENCE_COUNT(pPort->CurrentXoffIrp)) 
			{
                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

                pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(
                    pPort,
                    SerialGrabXoffFromIsr,
                    OldIrql,
                    STATUS_SERIAL_MORE_WRITES,
                    &pPort->CurrentWriteIrp,
                    &pPort->WriteQueue,
                    NULL,
                    &pPort->XoffCountTimer,
                    SerialStartWrite,
                    SerialGetNextWrite
                    );

                return FirstStatus;

            } 
			else 
			{
                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

                return FirstStatus;

            }

        } 
		else 
		{
            IoReleaseCancelSpinLock(OldIrql);
        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            
        Timeouts = pPort->Timeouts;

        KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            

        if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier)
		{
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
                                           
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading
            // as a write.
            //

            TotalTime = RtlEnlargedUnsignedMultiply(
                            (IrpSp->MajorFunction == IRP_MJ_WRITE)?(IrpSp->Parameters.Write.Length):(1),
                            Timeouts.WriteTotalTimeoutMultiplier);    

            TotalTime = RtlLargeIntegerAdd(
							TotalTime,
							RtlConvertUlongToLargeInteger(Timeouts.WriteTotalTimeoutConstant));

            TotalTime = RtlExtendedIntegerMultiply(TotalTime,-10000);

        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //

        SERIAL_INIT_REFERENCE(pPort->CurrentWriteIrp);

        //
        // We need to see if this irp should be cancelled.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        if(pPort->CurrentWriteIrp->Cancel) 
		{
            IoReleaseCancelSpinLock(OldIrql);
            pPort->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if(!SetFirstStatus) 
			{
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }

        } 
		else 
		{
            if(!SetFirstStatus) 
			{

                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;

            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(pPort->CurrentWriteIrp,SerialCancelCurrentWrite);
                
                
                

            SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

            if(UseATimer) 
			{
                KeSetTimer(&pPort->WriteRequestTotalTimer,TotalTime,&pPort->TotalWriteTimeoutDpc);

                //
                // This timer now has a reference to the irp.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);
            }

			Slxos_SyncExec(pPort,SerialGiveWriteToIsr,pPort,0x1F);

            IoReleaseCancelSpinLock(OldIrql);
            break;
        }

        //
        // Well the write was cancelled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return FirstStatus;

}

VOID
SerialGetNextWrite(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessarily mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

--*/
{

	pPort = CONTAINING_RECORD(QueueToProcess, PORT_DEVICE_EXTENSION, WriteQueue);

    do 
	{
        //
        // We could be completing a flush.
        //

        if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_WRITE) 
		{

            KIRQL OldIrql;

            ASSERT(pPort->TotalCharsQueued >= (IoGetCurrentIrpStackLocation(*CurrentOpIrp)
					->Parameters.Write.Length));
			
            IoAcquireCancelSpinLock(&OldIrql);
            pPort->TotalCharsQueued -= IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length;
                
            IoReleaseCancelSpinLock(OldIrql);

        } 
		else if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
		{

            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);

            //
            // If CurrentXoffIrp is not equal to null, this
            // implies that this is the "second" time around
            // for this irp, which implies that we should really
            // be completing it this time.
            //

            if(pPort->CurrentXoffIrp) 
			{
                pPort->CurrentXoffIrp = NULL;
                IoReleaseCancelSpinLock(OldIrql);
            } 
			else 
			{
                PIRP Irp = *CurrentOpIrp;

                PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

                // We absolutely shouldn't have a cancel routine at this point.
                ASSERT(!Irp->CancelRoutine);

                // This could only be a xoff counter masquerading as a write irp.
                pPort->TotalCharsQueued--;

                //
                // Check to see of the xoff irp has been set with success.
                // This means that the write completed normally.  If that
                // is the case, and it hasn't been set to cancel in the
                // meanwhile, then go on and make it the CurrentXoffIrp.
                //

                if(Irp->IoStatus.Status != STATUS_SUCCESS) 
				{
                    NOTHING;	// Oh well, we can just finish it off.
                } 
				else if(Irp->Cancel) 
				{
                    Irp->IoStatus.Status = STATUS_CANCELLED;
                } 
				else 
				{

                    //
                    // Give it a new cancel routine, and increment the
                    // reference count because the cancel routine has
                    // a reference to it.
                    //

                    IoSetCancelRoutine(Irp, SerialCancelCurrentXoff);
                     

                    SERIAL_INC_REFERENCE(Irp);

                    //
                    // We don't want to complete the current irp now.  This
                    // will now get completed by the Xoff counter code.
                    //

                    CompleteCurrent = FALSE;

                    //
                    // Give the counter to the isr.
                    //

                    pPort->CurrentXoffIrp = Irp;
					Slxos_SyncExec(pPort, SerialGiveXoffToIsr, pPort,0x20);

                    //
                    // Start the timer for the counter and increment the reference
                    // count since the timer has a reference to the irp.
                    //

                    if(Xc->Timeout) 
					{
                        KeSetTimer(	&pPort->XoffCountTimer,
									RtlLargeIntegerNegate(RtlEnlargedUnsignedMultiply(10000,Xc->Timeout)),
									&pPort->XoffCountTimeoutDpc);

                        SERIAL_INC_REFERENCE(Irp);
                    }

                }

                IoReleaseCancelSpinLock(OldIrql);

            }

        }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(pPort, CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent);
            

        if(!*NewIrp) 
		{
            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
			Slxos_SyncExec(pPort, SerialProcessEmptyTransmit, pPort,0x21);
            IoReleaseCancelSpinLock(OldIrql);

            break;
        } 
		else if(IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction == IRP_MJ_FLUSH_BUFFERS) 
		{
            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //

            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
        } 
		else 
		{
            break;
        }

    } while (TRUE);

}

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    if (pPort->IsrWaitMask && (pPort->IsrWaitMask & SERIAL_EV_TXEMPTY) 
	&& pPort->EmptiedTransmit && (!pPort->TransmitImmediate) 
	&& (!pPort->CurrentWriteIrp) && IsListEmpty(&pPort->WriteQueue)) 
	{

#if USE_NEW_TX_BUFFER_EMPTY_DETECT
		// On cards that are polled or interrupt when the card's Tx Buffer empties we 
		// can detect the Tx Empty Event very accurately otherwise we have to just signal the 
		// event when all the Write IRPs have been completed.  In this case there could and will  
		// still be data left in the card's buffer and UART FIFO when we signal the event.
		if(pPort->DetectEmptyTxBuffer)
		{
			if(Slxos_GetCharsInTxBuffer(pPort) || ((PCHAN)pPort->pChannel)->tx_fifo_count)	// Only if there is no data in the Tx Buffer will we signal.  
				return FALSE;				
		}
#endif
		pPort->HistoryMask |= SERIAL_EV_TXEMPTY;
    
		if(pPort->IrpMaskLocation) 
		{
            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

			pPort->EmptiedTransmit = FALSE;

            KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
        }
    }

    return FALSE;

}

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by polling the interrupt routine.
    This will slip it in behind a transmit immediate char, or if
    that isn't available, the next write.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

    //
    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->WriteLength = IrpSp->Parameters.Write.Length;
        pPort->WriteCurrentChar = pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer;
    } 
	else 
	{
        pPort->WriteLength = 1;
        pPort->WriteCurrentChar = ((PUCHAR)pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer) 
			+ FIELD_OFFSET(SERIAL_XOFF_COUNTER, XoffChar);
    }

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

    //
    // Do a poll to start things going.
    //

    Slxos_PollForInterrupt(pPort->pParentCardExt,FALSE);

    return FALSE;

}

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or cancelling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp.  We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    //

    if (pPort->WriteLength) 
	{
        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if (IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->MajorFunction == IRP_MJ_WRITE) 
		{
            pPort->CurrentWriteIrp->IoStatus.Information 
				= IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length
				- pPort->WriteLength;
        } 
		else 
		{
            pPort->CurrentWriteIrp->IoStatus.Information = 0;
        }

        //
        // Since the isr no longer references this irp, we can
        // decrement its reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWriteIrp);

        pPort->WriteLength = 0;

    }

    return FALSE;

}

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->CountSinceXoff) 
	{
        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        pPort->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentXoffIrp);
    }

    return FALSE;

}

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

	SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        OldIrql,
        STATUS_SERIAL_COUNTER_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

	SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PSERIAL_XOFF_COUNTER Xc = pPort->CurrentXoffIrp->AssociatedIrp.SystemBuffer;
    pPort->CountSinceXoff = Xc->Counter;

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\utils.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains code that perform queueing and completion
    manipulation on requests.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer
    );


VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )

/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    DeviceObject - A pointer to the serial device object.

    QueueToClean - A pointer to the queue which we're going to clean out.

    CurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //

    while(!IsListEmpty(QueueToClean)) 
	{
        PIRP currentLastIrp = CONTAINING_RECORD(QueueToClean->Blink, IRP, Tail.Overlay.ListEntry);

        RemoveEntryList(QueueToClean->Blink);
		SpxIRPCounter(pPort, currentLastIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(DeviceObject,currentLastIrp);

        IoAcquireCancelSpinLock(&cancelIrql);
    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if(*CurrentOpIrp) 
	{
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancellable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancellable state then the following will kill it.
        //

        if(cancelRoutine) 
		{
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancellable state.  We simply
            // mark it as cancelled and call the cancel routine for
            // it.
            //

            cancelRoutine(DeviceObject, *CurrentOpIrp);
        } 
		else 
		{
            IoReleaseCancelSpinLock(cancelIrql);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(cancelIrql);
    }

}

VOID
SerialGetNextIrp(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes what was the old
    current irp if desired.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    PIRP oldIrp;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    oldIrp = *CurrentOpIrp;

    if(CompleteCurrent) 
	{
        ASSERT(!oldIrp->CancelRoutine);
    }

    //
    // Check to see if there is a new irp to start up.
    //

    if (!IsListEmpty(QueueToProcess)) 
	{
        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(headOfList,IRP,Tail.Overlay.ListEntry);
		SpxIRPCounter(pPort, *CurrentOpIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        IoSetCancelRoutine(*CurrentOpIrp,NULL);
    } 
	else 
	{
        *CurrentOpIrp = NULL;
    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(oldIrql);

    if(CompleteCurrent) 
	{
        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",oldIrp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(oldIrp,12);
#endif
		SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
		IoCompleteRequest(oldIrp,IO_SERIAL_INCREMENT);

    }

}

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    pPort - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //

    SERIAL_DEC_REFERENCE(*CurrentOpIrp);

    if(SynchRoutine) 
	{
		Slxos_SyncExec(pPort,SynchRoutine,pPort,0x1C);
    }

    //
    // Try to run down all other references to this irp.
    //

    SerialRundownIrpRefs(CurrentOpIrp,IntervalTimer,TotalTimer);
        
        

    //
    // See if the ref count is zero after trying to kill everybody else.
    //

    if(!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) 
	{
        PIRP newIrp;


        //
        // The ref count was zero so we should complete this
        // request.
        //
        // The following call will also cause the current irp to be
        // completed.
        //

        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if(StatusToUse == STATUS_CANCELLED) 
		{
            (*CurrentOpIrp)->IoStatus.Information = 0;
        }

        if(GetNextIrp) 
		{
            IoReleaseCancelSpinLock(IrqlForRelease);
            GetNextIrp(pPort, CurrentOpIrp, QueueToProcess, &newIrp, TRUE);
                

            if(newIrp) 
			{
                Starter(pPort);
            }

        } 
		else 
		{
            PIRP oldIrp = *CurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //

            *CurrentOpIrp = NULL;

            IoReleaseCancelSpinLock(IrqlForRelease);
            SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",oldIrp));
                
                
                
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(oldIrp,13);
#endif
			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);

        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(IrqlForRelease);
    }

}
 
VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    )

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It tries to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

Return Value:

    None.

--*/


{

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if((*CurrentOpIrp)->CancelRoutine) 
	{
        SERIAL_DEC_REFERENCE(*CurrentOpIrp);

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    }

    if(IntervalTimer) 
	{
        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've cancelled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement its reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(IntervalTimer)) 
		{
            SERIAL_DEC_REFERENCE(*CurrentOpIrp);
        }

    }

    if(TotalTimer) 
	{

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've cancelled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement its reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(TotalTimer)) 
		{

            SERIAL_DEC_REFERENCE(*CurrentOpIrp);

        }
    }

}

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )

/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    pPort - Points to the serial device extension.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{

    KIRQL oldIrql;
    PIO_STACK_LOCATION irpSp;

    IoAcquireCancelSpinLock(&oldIrql);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued += irpSp->Parameters.Write.Length;

    } 
	else 
		if((irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
			&& ((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR) 
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))) 
		{
	        pPort->TotalCharsQueued++;
	    }

    if((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp)) 
	{
        //
        // There were no current operation.  Mark this one as
        // current and start it up.
        //

        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(pPort);

    } 
	else 
	{
        //
        // We don't know how long the irp will be in the
        // queue.  So we need to handle cancel.
        //

        if(Irp->Cancel) 
		{
            IoReleaseCancelSpinLock(oldIrql);

            Irp->IoStatus.Status = STATUS_CANCELLED;

            SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
                
                
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,14);
#endif
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);

            return STATUS_CANCELLED;

        } 
		else 
		{
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(QueueToExamine, &Irp->Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp, SerialCancelQueued);

			SpxIRPCounter(pPort, Irp, IRP_QUEUED);	// Increment counter for performance stats.
            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;

        }

    }

}

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel Irps that currently reside on
    a queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be cancelled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
	SpxIRPCounter(pPort, Irp, IRP_DEQUEUED);	// Decrement counter for performance stats.

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued -= irpSp->Parameters.Write.Length;
    } 
	else 
		if(irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
		{

        //
        // If it's an immediate then we need to decrement the
        // count of chars queued.  If it's a resize then we
        // need to deallocate the pool that we're passing on
        // to the "resizing" routine.
        //

			if((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR) 
				 || (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))
			{
				pPort->TotalCharsQueued--;
			} 
			else 
				if(irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_QUEUE_SIZE)
				{

					//
					// We shoved the pointer to the memory into the
					// the type 3 buffer pointer which we KNOW we
					// never use.
					//

					ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					SpxFreeMem(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

				}

		}

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,15);
#endif
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_SERIAL_INCREMENT);

}


NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    if((pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pPort->ErrorWord)
	{

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //

        if((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) 
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_SERIAL_GET_COMMSTATUS)) 
		{

            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
                
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,16);
#endif
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);

        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\waitmask.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    waitmask.c

Abstract:

    This module contains the code that is very specific to get/set/wait
    on event mask operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    );


NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/

{

    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialStartMask\n")
        );

    ASSERT(pPort->CurrentMaskIrp);

    do {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: STARMASK - CurrentMaskIrp: %x\n",pPort->CurrentMaskIrp)
            );
        IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_WAIT_ON_MASK) ||
               (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_SET_WAIT_MASK));

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SERIAL_SET_WAIT_MASK) {

            SpxDbgMsg(
                SERDIAG4,
                ("SERIAL - %x is a SETMASK irp\n",pPort->CurrentMaskIrp)
                );

            //
            // Complete the old wait if there is one.
            //

	    Slxos_SyncExec(pPort,SerialFinishOldWait,pPort,0x1D);

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!pPort->IrpMaskLocation);

            pPort->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if (!SetFirstStatus) {

                SpxDbgMsg(
                    SERDIAG4,
                    ("SERIAL: %x was the first irp processed by this\n"
                     "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                    );
                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;

            }

            //
            // The following call will also cause the current
            // call to be completed.
            //

            SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
               
                
            SpxDbgMsg(
                SERDIAG4,
                ("SERIAL: Perhaps another mask irp was found in the queue\n"
                 "------- %x/%x <- values should be the same\n",
                 pPort->CurrentMaskIrp,NewIrp)
                );


        } else {

            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be satisfied so it makes no sense to start it.
            //

            if ((!pPort->IsrWaitMask) || (pPort->CurrentWaitIrp)) {

                SpxDbgMsg(
                    SERDIAG4,
                    ("SERIAL: WaitIrp is invalid\n"
                     "------- IsrWaitMask: %x\n"
                     "------- CurrentWaitIrp: %x\n",
                     pPort->IsrWaitMask,
                     pPort->CurrentWaitIrp)
                    );

                pPort->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                if (!SetFirstStatus) {

                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: %x was the first irp processed by this\n"
                         "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                        );
                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;

                }

                SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                    
                SpxDbgMsg(
                    SERDIAG4,
                    ("SERIAL: Perhaps another mask irp was found in the queue\n"
                     "------- %x/%x <- values should be the same\n",
                     pPort->CurrentMaskIrp,NewIrp)
                    );

            } else {

                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be cancelled.
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if (pPort->CurrentMaskIrp->Cancel) {

                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: %x irp was already marked as cancelled\n",
                         pPort->CurrentMaskIrp)
                        );
                    IoReleaseCancelSpinLock(OldIrql);
                    pPort->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if (!SetFirstStatus) {

                        SpxDbgMsg(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );
                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;

                    }

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                        
                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                } else {

                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: %x will become the current wait irp\n",
                         pPort->CurrentMaskIrp)
                        );
                    if (!SetFirstStatus) {

                        SpxDbgMsg(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );
                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(pPort->CurrentMaskIrp);

                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!pPort->IrpMaskLocation);
                    ASSERT(!pPort->CurrentWaitIrp);

                    pPort->CurrentWaitIrp = pPort->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(pPort->CurrentWaitIrp);
                    IoSetCancelRoutine(
                        pPort->CurrentWaitIrp,
                        SerialCancelWait
                        );

                    //
                    // Since the cancel routine has a reference to the
                    // irp we need to update the reference count.
                    //

                    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

		    Slxos_SyncExec(pPort,SerialGiveWaitToIsr,pPort,0x1E);

                    IoReleaseCancelSpinLock(OldIrql);

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, FALSE);
                        
                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the IrpMaskLocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    by the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialGrabWaitFromIsr\n")
        );

    if (pPort->IrpMaskLocation) {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWaitIrp);

    }

    return FALSE;
}

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialGiveWaitToIsr\n")
        );
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!pPort->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

    if (!pPort->HistoryMask) {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: No events occurred prior to the wait call\n")
            );

        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        pPort->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        pPort->IrpMaskLocation =
            pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: The isr owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

    } else {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: %x occurred prior to the wait - starting the\n"
             "------- completion code for %x\n",
             pPort->HistoryMask,pPort->CurrentWaitIrp)
            );

        *((ULONG *)pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer) =
            pPort->HistoryMask;

        pPort->HistoryMask = 0;
        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        pPort->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;


        KeInsertQueueDpc(
            &pPort->CommWaitDpc,
            NULL,
            NULL
            );

    }

    return FALSE;
}

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialFinishOldWait\n")
        );
    if (pPort->IrpMaskLocation) {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );
        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

        KeInsertQueueDpc(
            &pPort->CommWaitDpc,
            NULL,
            NULL
            );

    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    pPort->HistoryMask &= *((ULONG *)pPort->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);

    pPort->IsrWaitMask = *((ULONG *)pPort->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);
    SpxDbgMsg(
        SERDIAG4,
        ("SERIAL: Set mask location of %x, in irp %x, with system buffer of %x\n",
         pPort->IrpMaskLocation,
         pPort->CurrentMaskIrp,pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer)
        );
    return FALSE;
}

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialCancelWait\n")
        );

    SpxDbgMsg(
        SERDIAG4,
        ("SERIAL: Canceling wait for irp %x\n",pPort->CurrentWaitIrp)
        );
    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWaitFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialCompleteWait\n")
        );
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SpxDbgMsg(
        SERDIAG4,
        ("SERIAL: Completing wait for irp %x\n",pPort->CurrentWaitIrp)
        );
    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\serialp.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 Microsoft Corporation

Module Name :
	
    serialp.h

Abstract:

    Prototypes and macros that are used throughout the driver.

Author:

    Anthony V. Ercolano                 September 26, 1991

Revision History:
--*/

typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PPORT_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
	IN PPORT_DEVICE_EXTENSION,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

BOOLEAN SerialGetStats(IN PVOID Context);	// Get stats
BOOLEAN SerialClearStats(IN PVOID Context);	// Clear Stats called during open

NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialGetNextWrite(
    IN PPORT_DEVICE_EXTENSION,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    );

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialSetDTR(
    IN PVOID Context
    );

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    );

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    );

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    );

BOOLEAN
SerialSetChars(
    IN PVOID Context
    );

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    );

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    );

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    );

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
    IN PPORT_DEVICE_EXTENSION,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_START_ROUTINE Starter,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp
    );

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    );

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
slxos_dpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2 
    );

VOID
SerialCleanupDevice(
    IN PPORT_DEVICE_EXTENSION pPort
    );

UCHAR
SerialProcessLSR(
    IN PPORT_DEVICE_EXTENSION pPort,
    UCHAR LineStatus
    );

LARGE_INTEGER
SerialGetCharTime(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    );


VOID SerialGetProperties(
	IN PPORT_DEVICE_EXTENSION pPort, 
	IN PSERIAL_COMMPROP Properties
	);

UCHAR	SerialPutBlock(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pBlock,IN UCHAR BlockLen,BOOLEAN Filter);
USHORT	SerialTransferReadChar(IN PPORT_DEVICE_EXTENSION pExt,IN PUCHAR pFrom,IN PUCHAR pTo);

typedef struct _SERIAL_UPDATE_CHAR {
    PPORT_DEVICE_EXTENSION pPort;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC {
    PPORT_DEVICE_EXTENSION pPort;
    PVOID Data;
    } SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

//
// The following three macros are used to initialize, increment
// and decrement reference counts in IRPs that are used by
// this driver.  The reference count is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_INC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))++)

#define SERIAL_DEC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))--)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\slxos_nt.h ===
/*

    #########     ##              ##        ##      ########        #########
   ##########     ##              ##        ##     ##########      ##########
  ##              ##                ##    ##      ##        ##    ##
  ##              ##                ##    ##      ##        ##    ##
   #########      ##                  ####        ##        ##     #########
    #########     ##                  ####        ##        ##      #########
            ##    ##                  ####        ##        ##              ##
            ##    ##                  ####        ##        ##              ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
   ##########     ############    ##        ##     ##########      ##########
    ########      ############    ##        ##      ########        ########

	  SI Intelligent I/O Board driver
	  Copyright (c) Specialix International 1993
*/

#include	"sxwindow.h"				/* Shared Memory Window Definitions */
#include	"sxboards.h"				/* SX Board Hardware Definitions */

#define	ResetBoardInt(pCard)												\
	switch(pCard->CardType)													\
	{																		\
	case SiHost_1:															\
		pCard->Controller[0xa000] = 0;										\
		pCard->Controller[0xe000] = 0;										\
		break;																\
																			\
	case Si_2:																\
	{																		\
		UCHAR	c;															\
		WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));	\
		c = READ_PORT_UCHAR((PUCHAR)0x102);									\
		c &= ~0x08;															\
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);									\
		c |= 0x08;															\
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);									\
		WRITE_PORT_UCHAR((PUCHAR)0x96, 0);									\
		break;																\
	}																		\
																			\
	case SiHost_2:															\
		pCard->Controller[0x7FFD] = 0x00;									\
		pCard->Controller[0x7FFD] = 0x10;									\
		break;																\
																			\
	case SiEisa:															\
		READ_PORT_UCHAR((PUCHAR)((pCard->SlotNumber << 12) | 0xc03));		\
		break;																\
																			\
	case SiPCI:																\
		pCard->Controller[SI2_PCI_SET_IRQ] = 0;								\
		break;																\
																			\
	case Si3Isa:															\
	case Si3Eisa:															\
	case Si3Pci:															\
	case SxPlusPci:															\
		pCard->Controller[SX_RESET_IRQ]=0;									\
		break;																\
																			\
	default:																\
		break;																\
	}



/////////////////////////////////////////////////////////////////////////////
// Macro to sent configure port command to firmware
//
// If in IDLE_OPEN then we can configure it right now.
// If we are in a transient state that the firmware will return to IDLE_OPEN 
// soon we can do the config next.  So we set PendingOperation to HS_CONFIG.
//
#define SX_CONFIGURE_PORT(pPort, channelControl)			\
	switch (channelControl->hi_hstat)						\
	{														\
	case HS_IDLE_OPEN:										\
		channelControl->hi_hstat = HS_CONFIG;				\
		pPort->PendingOperation = HS_IDLE_OPEN;				\
		break;												\
															\
	case HS_LOPEN:											\
	case HS_MOPEN:											\
	case HS_IDLE_MPEND:										\
	case HS_CONFIG:											\
	case HS_STOP:											\
	case HS_RESUME:											\
	case HS_WFLUSH:											\
	case HS_RFLUSH:											\
	case HS_SUSPEND:										\
	case HS_CLOSE:											\
		pPort->PendingOperation = HS_CONFIG;				\
		break;												\
															\
	default:												\
		break;												\
	}		

/* End of SLXOS_NT.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\slxosexp.h ===
/***************************************************************************\
*                                                                           *
* SLXOSEXP.H                                                                *
*                                                                           *
* SI Intelligent I/O Board driver                                           *
*	Copyright (c) Specialix 1993                                        *
*                                                                           *
* Prototypes and macros that are used throughout the driver.                *
*                                                                           *
\***************************************************************************/

BOOLEAN Slxos_Present (IN PVOID Context);

int Slxos_ResetBoard (IN PVOID Context);
#define CARD_RESET_ERROR 		1
#define DCODE_OR_NO_MODULES_ERROR	2 	
#define MODULE_MIXTURE_ERROR		3
#define NON_SX_HOST_CARD_ERROR		4
#define SUCCESS 			0

BOOLEAN Slxos_ResetChannel (IN PVOID Context);
VOID    Slxos_EnableAllInterrupts (IN PVOID Context);

BOOLEAN Slxos_SetDTR (IN PVOID Context);
BOOLEAN Slxos_ClearDTR (IN PVOID Context);
BOOLEAN Slxos_SetRTS (IN PVOID Context);
BOOLEAN Slxos_ClearRTS (IN PVOID Context);
BOOLEAN	Slxos_FlushTxBuff(IN PVOID Context);

BOOLEAN Slxos_Interrupt (IN PVOID Context);
VOID	Slxos_IsrDpc				/* SLXOS_NT.C */
(
	IN PKDPC 		Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP 		Irp,
	IN PVOID 		Context
);
VOID	Slxos_PolledDpc(IN PKDPC Dpc,IN PVOID Context,IN PVOID SysArg1,IN PVOID SysArg2);
VOID	Slxos_SyncExec(PPORT_DEVICE_EXTENSION pPort,PKSYNCHRONIZE_ROUTINE SyncRoutine,PVOID SyncContext,int index);

BOOLEAN	Slxos_PollForInterrupt(IN PVOID Context,IN BOOLEAN Obsolete);
void	SpxCopyBytes(PUCHAR To,PUCHAR From,ULONG Count);

BOOLEAN	Slxos_CheckBaud(PPORT_DEVICE_EXTENSION pPort,ULONG BaudRate);
BOOLEAN Slxos_SetBaud (IN PVOID Context);
BOOLEAN Slxos_SetLineControl (IN PVOID Context);
BOOLEAN Slxos_SendXon (IN PVOID Context);
BOOLEAN Slxos_SetFlowControl (IN PVOID Context);
VOID    Slxos_SetChars (IN PVOID Context);

VOID    Slxos_DisableAllInterrupts (IN PVOID Context);

BOOLEAN Slxos_TurnOnBreak (IN PVOID Context);
BOOLEAN Slxos_TurnOffBreak (IN PVOID Context);

UCHAR   Slxos_GetModemStatus (IN PVOID Context);
ULONG   Slxos_GetModemControl (IN PVOID Context);

VOID    Slxos_Resume (IN PVOID Context);
ULONG   Slxos_GetCharsInTxBuffer(IN PVOID Context);

UCHAR	si2_z280_download[];
int	si2_z280_dsize;

UCHAR	si3_t225_download[];			/* SI3_T225.C */
int	si3_t225_dsize;				/* SI3_T225.C */
USHORT	si3_t225_downloadaddr;			/* SI3_T225.C */

UCHAR	si3_t225_bootstrap[];			/* SI3_T225.C */
int	si3_t225_bsize;				/* SI3_T225.C */
USHORT	si3_t225_bootloadaddr;			/* SI3_T225.C */

UCHAR	si4_cf_download[];				/* SX_CSX.C */
int	si4_cf_dsize;				/* SX_CSX.C */
USHORT	si4_cf_downloadaddr;			/* SX_CSX.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\sxboards.h ===
/************************************************************************/
/*									*/
/*	Title		:	SX/SI/XIO Board Hardware Definitions	*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	16th March 1998				*/
/*									*/
/*	Version		:	3.0.0					*/
/*									*/
/*	Copyright	:	(c) Specialix International Ltd. 1998	*/
/*									*/
/*	Description	:	Prototypes, structures and definitions	*/
/*				describing the SX/SI/XIO board hardware	*/
/*									*/
/************************************************************************/

/* History...

3.0.0	16/03/98 NPV	Creation.

*/

#ifndef	_sxboards_h				/* If SXBOARDS.H not already defined */
#define	_sxboards_h    1

/*****************************************************************************
*******************************                 ******************************
*******************************   Board Types   ******************************
*******************************                 ******************************
*****************************************************************************/

/* BUS types... */
#define		BUS_ISA		0
#define		BUS_MCA		1
#define		BUS_EISA	2
#define		BUS_PCI		3

/* Board phases... */
#define		SI1_Z280	1
#define		SI2_Z280	2
#define		SI3_T225	3
 /* @@@ Changes for CSX 22/1/99 */
#define    SI4_MCF5206E 4
/* end */

/* Board types... */
#define		CARD_TYPE(bus,phase)	(bus<<4|phase)
#define		CARD_BUS(type)		((type>>4)&0xF)
#define		CARD_PHASE(type)	(type&0xF)

#define		TYPE_SI2_ISA		CARD_TYPE(BUS_ISA,SI2_Z280)
#define		TYPE_SI2_EISA		CARD_TYPE(BUS_EISA,SI2_Z280)
#define		TYPE_SI2_PCI		CARD_TYPE(BUS_PCI,SI2_Z280)
 /* @@@ Changes for CSX 22/1/99 */
/* end */

#define		TYPE_SX_ISA		CARD_TYPE(BUS_ISA,SI3_T225)
#define		TYPE_SX_PCI		CARD_TYPE(BUS_PCI,SI3_T225)
 /* @@@ Changes for CSX 22/1/99 */
 #define  TYPE_CSX_PCI    CARD_TYPE(BUS_PCI,SI4_MCF5206E)
/* end */
/*****************************************************************************
******************************                  ******************************
******************************   Phase 2 Z280   ******************************
******************************                  ******************************
*****************************************************************************/

/* ISA board details... */
#define		SI2_ISA_WINDOW_LEN	0x8000		/* 32 Kbyte shared memory window */
#define 	SI2_ISA_MEMORY_LEN	0x7FF8		/* Usable memory */
#define		SI2_ISA_ADDR_LOW	0x0A0000	/* Lowest address = 640 Kbyte */
#define		SI2_ISA_ADDR_HIGH	0xFF8000	/* Highest address = 16Mbyte - 32Kbyte */
#define		SI2_ISA_ADDR_STEP	SI2_ISA_WINDOW_LEN/* ISA board address step */
#define		SI2_ISA_IRQ_MASK	0x9800		/* IRQs 15,12,11 */

/* ISA board, register definitions... */
#define		SI2_ISA_ID_BASE		0x7FF8			/* READ:  Board ID string */
#define		SI2_ISA_RESET		SI2_ISA_ID_BASE		/* WRITE: Host Reset */
#define		SI2_ISA_IRQ11		(SI2_ISA_ID_BASE+1)	/* WRITE: Set IRQ11 */
#define		SI2_ISA_IRQ12		(SI2_ISA_ID_BASE+2)	/* WRITE: Set IRQ12 */
#define		SI2_ISA_IRQ15		(SI2_ISA_ID_BASE+3)	/* WRITE: Set IRQ15 */
#define		SI2_ISA_IRQSET		(SI2_ISA_ID_BASE+4)	/* WRITE: Set Host Interrupt */
#define		SI2_ISA_INTCLEAR	(SI2_ISA_ID_BASE+5)	/* WRITE: Enable Host Interrupt */

#define		SI2_ISA_IRQ11_SET	0x10
#define		SI2_ISA_IRQ11_CLEAR	0x00
#define		SI2_ISA_IRQ12_SET	0x10
#define		SI2_ISA_IRQ12_CLEAR	0x00
#define		SI2_ISA_IRQ15_SET	0x10
#define		SI2_ISA_IRQ15_CLEAR	0x00
#define		SI2_ISA_INTCLEAR_SET	0x10
#define		SI2_ISA_INTCLEAR_CLEAR	0x00
#define		SI2_ISA_IRQSET_CLEAR	0x10
#define		SI2_ISA_IRQSET_SET	0x00
#define		SI2_ISA_RESET_SET	0x00
#define		SI2_ISA_RESET_CLEAR	0x10

/* PCI board details... */
#define		SI2_PCI_WINDOW_LEN	0x100000	/* 1 Mbyte memory window */

/* PCI board register definitions... */
#define		SI2_PCI_SET_IRQ		0x40001		/* Set Host Interrupt  */
#define		SI2_PCI_RESET		0xC0001		/* Host Reset */

/*****************************************************************************
******************************                  ******************************
******************************   Phase 3 T225   ******************************
******************************                  ******************************
*****************************************************************************/

/* General board details... */
#define		SX_WINDOW_LEN		32*1024		/* 32 Kbyte memory window */

/* ISA board details... */
#define		SX_ISA_ADDR_LOW		0x0A0000	/* Lowest address = 640 Kbyte */
#define		SX_ISA_ADDR_HIGH	0xFF8000	/* Highest address = 16Mbyte - 32Kbyte */
#define		SX_ISA_ADDR_STEP	SX_WINDOW_LEN	/* ISA board address step */
#define		SX_ISA_IRQ_MASK		0x9E00		/* IRQs 15,12,11,10,9 */

/* Hardware register definitions... */
#define		SX_EVENT_STATUS		0x7800		/* READ:  T225 Event Status */
#define		SX_EVENT_STROBE		0x7800		/* WRITE: T225 Event Strobe */
#define		SX_EVENT_ENABLE		0x7880		/* WRITE: T225 Event Enable */
#define		SX_VPD_ROM		0x7C00		/* READ:  Vital Product Data ROM */
#define		SX_CONFIG		0x7C00		/* WRITE: Host Configuration Register */
#define		SX_IRQ_STATUS		0x7C80		/* READ:  Host Interrupt Status */
#define		SX_SET_IRQ		0x7C80		/* WRITE: Set Host Interrupt */
#define		SX_RESET_STATUS		0x7D00		/* READ:  Host Reset Status */
#define		SX_RESET		0x7D00		/* WRITE: Host Reset */
#define		SX_RESET_IRQ		0x7D80		/* WRITE: Reset Host Interrupt */

/* SX_VPD_ROM definitions... */
#define		SX_VPD_SLX_ID1		0x00
#define		SX_VPD_SLX_ID2		0x01
#define		SX_VPD_HW_REV		0x02
#define		SX_VPD_HW_ASSEM		0x03
#define		SX_VPD_UNIQUEID4	0x04
#define		SX_VPD_UNIQUEID3	0x05
#define		SX_VPD_UNIQUEID2	0x06
#define		SX_VPD_UNIQUEID1	0x07
#define		SX_VPD_MANU_YEAR	0x08
#define		SX_VPD_MANU_WEEK	0x09
#define		SX_VPD_IDENT		0x10
#define		SX_VPD_IDENT_STRING	"JET HOST BY KEV#"

/* SX unique identifiers... */
#define		SX_UNIQUEID_MASK	0xF0
#define		SX_ISA_UNIQUEID1	0x20
#define		SX_PCI_UNIQUEID1	0x50

/* SX_CONFIG definitions... */
#define		SX_CONF_BUSEN		0x02		/* Enable T225 memory and I/O */
#define		SX_CONF_HOSTIRQ		0x04		/* Enable board to host interrupt */

/* SX bootstrap... */
#define		SX_BOOTSTRAP		"\x28\x20\x21\x02\x60\x0a"
#define		SX_BOOTSTRAP_SIZE	6
#define		SX_BOOTSTRAP_ADDR	(0x8000-SX_BOOTSTRAP_SIZE)

/* @@@ Changes for CSX 22/1/99 */
/*****************************************************************************
******************************                  ******************************
******************************   Phase 4 MCF5206e Coldfire   *****************
******************************                  ******************************
*****************************************************************************/

/* General board details... */
#define		CSX_WINDOW_LEN		128*1024		/* 128 Kbyte memory window ?shadow? */
#define    CSX_SM_OFFSET 0x18000   /* i.e 92k  which is the offset of the shared memory window within the 128k  card window */

/* Hardware register definitions... */
/* #define		SX_EVENT_STATUS		0x7800	*/	/* READ:  T225 Event Status */
/* #define		SX_EVENT_STROBE		0x7800	*/	/* WRITE: T225 Event Strobe */
/* #define		SX_EVENT_ENABLE		0x7880	*/	/* WRITE: T225 Event Enable */
/* #define		SX_VPD_ROM		      0x7C00	*/	/* READ:  Vital Product Data ROM */
/* #define		SX_CONFIG		      0x7C00	*/	/* WRITE: Host Configuration Register */
/* #define		SX_IRQ_STATUS		   0x7C80	*/	/* READ:  Host Interrupt Status */
/* #define		SX_SET_IRQ		      0x7C80	*/	/* WRITE: Set Host Interrupt */
/* #define		SX_RESET_STATUS		0x7D00	*/	/* READ:  Host Reset Status */
/* #define		SX_RESET		         0x7D00	*/	/* WRITE: Host Reset */
/* #define		SX_RESET_IRQ		   0x7D80	*/	/* WRITE: Reset Host Interrupt */

/* SX_VPD_ROM definitions... */
/*
 #define		SX_VPD_SLX_ID1		0x00
 #define		SX_VPD_SLX_ID2		0x01
 #define		SX_VPD_HW_REV		0x02
 #define		SX_VPD_HW_ASSEM		0x03
 #define		SX_VPD_UNIQUEID4	0x04
 #define		SX_VPD_UNIQUEID3	0x05
 #define		SX_VPD_UNIQUEID2	0x06
 #define		SX_VPD_UNIQUEID1	0x07
 #define		SX_VPD_MANU_YEAR	0x08
 #define		SX_VPD_MANU_WEEK	0x09
 #define		SX_VPD_IDENT		0x10
 #define		SX_VPD_IDENT_STRING	"JET HOST BY KEV#"
*/

/* SX unique identifiers... */
#define		CSX_UNIQUEID_MASK	0xF0
#define		CSX_PCI_UNIQUEID1	0x70

/* SX_CONFIG definitions... */
/* #define		SX_CONF_BUSEN		0x02	   */	 /* Enable T225 memory and I/O */
/* #define		SX_CONF_HOSTIRQ		0x04	*/ 	/* Enable board to host interrupt */


/* end changes */

/*****************************************************************************
**********************************          **********************************
**********************************   EISA   **********************************
**********************************          **********************************
*****************************************************************************/

/* EISA ID definitions... */
#define		SI2_EISA_ID_BASE	0xC80			/* EISA ID base address */
#define		SI2_EISA_ID_LO		SI2_EISA_ID_BASE	/* EISA ID Ports LOW */
#define		SI2_EISA_ID_MI		(SI2_EISA_ID_BASE+1)	/* EISA ID Ports MIDDLE */
#define		SI2_EISA_ID_HI		(SI2_EISA_ID_BASE+2)	/* EISA ID Ports HIGH */
#define		SI2_EISA_ID_REV		(SI2_EISA_ID_BASE+3)	/* EISA Revision number */
#define		SI2_EISA_ID		0x04984D		/* Actual ID string */

/* EISA download code "magic" value... */
#define		SI2_EISA_OFF		0x42			/* Magic offset to set for EISA */
#define		SI2_EISA_VAL		0x01

/* EISA Address and Interrupt definitions... */
#define		SI2_EISA_ADDR_LO	0xC00			/* Base address low */
#define		SI2_EISA_ADDR_HI	0xC01			/* Base address high */
#define		SI2_EISA_IVEC		0xC02			/* Interrupt vector */
#define		SI2_EISA_IRQ_CNTRL	0xC03			/* Interrupt control */

/* EISA_IVEC bits 7-4 = irq level */
#define		SI2_EISA_IVEC_MASK	0xF0			/* irq = (EISA_IVEC & EISA_IVEC_MASK) >> 4 */

/* EISA_IVEC bit 2 = Z280 control */
#define		SI2_EISA_REL_Z280	0x04
#define		SI2_EISA_RESET_Z280	0x00

/* EISA_IRQ_CNTRL, read to clear interrupt state */
#define		SI2_EISA_IRQ_SET	0x00

/*****************************************************************************
***********************************         **********************************
***********************************   PCI   **********************************
***********************************         **********************************
*****************************************************************************/

/* General definitions... */

#define		SPX_VENDOR_ID		0x11CB		/* Assigned by the PCI SIG */
#define		SPX_DEVICE_ID		0x4000		/* SI/XIO boards */
#define		SPX_PLXDEVICE_ID	0x2000		/* SX boards */

#define		SPX_SUB_VENDOR_ID	SPX_VENDOR_ID	/* Same as vendor id */
#define		SI2_SUB_SYS_ID		0x400		/* Phase 2 (Z280) board */
#define		SX_SUB_SYS_ID		0x200		/* Phase 3 (t225) board */

/* @@@ Changes for CSX 22/1/99 */
#define   CSX_SUB_SYS_ID     0x300  /* Phase 4 (MCF5206e) board */
/* end changes */

#endif						/*_sxboards_h */

/* End of SXBOARDS.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\incl\spx.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	File: SPX.H 
//
//	Contains:	Prototypes of functions to be supplied by a specific  
//				driver to integrate into NT generic PnP code.
//
//	Note:	All generic NT PnP code is prefixed by Spx_.
//			All funcions that are required to integrate into the generic 
//			code are prefixed by XXX_.
//
//
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_H
#define SPX_H	


// Purpose:		Interpret resources given to card by PnP Manager.
//
// Must:		Store resource details in card extension.
NTSTATUS
XXX_CardGetResources(	
	IN PDEVICE_OBJECT pDevObject, 
	IN PCM_RESOURCE_LIST PResList,
	IN PCM_RESOURCE_LIST PTrResList
	);

// Purpose:		Initialise card.
//				Find out how many ports are attached.
// 
// Must:		Fill in NumberOfPorts field in card extension.
NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Start up the card.
//
// Must:		Connect up any interrupts.
NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Stop the card.
//
// Must:		Stop Card from interrupting.
NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Deinitialise the card.
//
// Must:		Disconnect any interrupts.
NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Initialise the port extension.
//
// Must:		Store DeviceID, HardwareIDs, DevDesc into the port extension.
//					
NTSTATUS
XXX_PortInit(PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Start up the port.
//
// Must:		Get port ready to receive read and write commands.
NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort);


// Purpose:		Stop the port.
//
// Must:		Disconnect any resources and stop DPCs.
//				Do not delete the device object or symbolic link.
NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Deinitialise the port.
//
// Must:		Delete the device object & symbolic link.
NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Save the state of the card hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Restore the state of the card hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Save the state of the port hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Restore the state of the port hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Queries whether it is safe for the port to power down.
//
// Must:		Return STATUS_SUCCESS if OK to power down.			
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Set hand shaking and flow control on a port.
VOID 
XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS);

// Paging 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, XXX_CardGetResources)
#pragma alloc_text (PAGE, XXX_CardInit)
#pragma alloc_text (PAGE, XXX_CardDeInit)
#pragma alloc_text (PAGE, XXX_CardStart)
#pragma alloc_text (PAGE, XXX_CardStop)
#pragma alloc_text (PAGE, XXX_PortInit)
#pragma alloc_text (PAGE, XXX_PortDeInit)
#pragma alloc_text (PAGE, XXX_PortStart)
#pragma alloc_text (PAGE, XXX_PortStop)
#endif  


#endif	// End of SPX.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\incl\spx_defs.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_DEFS.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	Definitions for all the common PnP and power code.						*
*																						*
****************************************************************************************/

#if	!defined(SPX_DEFS_H)
#define SPX_DEFS_H	

static const PHYSICAL_ADDRESS PhysicalZero = {0};

#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128

#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY		L"DosDevices"

#define MAX_ERROR_LOG_INSERT	52


// File IDs for Event Logging (top 8 bits only).
#define SPX_INIT_C		((ULONG)0x01000000)
#define SPX_PNP_C		((ULONG)0x02000000)
#define SPX_POWR_C		((ULONG)0x03000000)
#define SPX_DISP_C		((ULONG)0x04000000)
#define SPX_UTILS_C		((ULONG)0x05000000)
#define SPX_IIOC_C		((ULONG)0x06000000)




// COMMON_OBJECT_DATA.PnpPowerFlags definitions... 
#define	PPF_STARTED			0x00000001		// Device has been started 
#define	PPF_STOP_PENDING	0x00000002		// Device stop is pending 
#define	PPF_REMOVE_PENDING	0x00000004		// Device remove is pending 
#define	PPF_REMOVED			0x00000008		// Device has been removed 
#define	PPF_POWERED			0x00000010		// Device has been powered up 
			
typedef enum _SPX_MEM_COMPARES 
{
	AddressesAreEqual,
	AddressesOverlap,
	AddressesAreDisjoint

}SPX_MEM_COMPARES, *PSPX_MEM_COMPARES;

// IRP Counters
#define IRP_SUBMITTED		0x00000001	
#define IRP_COMPLETED		0x00000002
#define IRP_QUEUED			0x00000003
#define IRP_DEQUEUED		0x00000004


extern UNICODE_STRING SavedRegistryPath;	// Driver Registry Path.


#endif	// End of SPX_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\sx_defs.h ===
/* SX Card and Port definitions... */

#define PRODUCT_MAX_PORTS		32

/* Port device object name... */
#define PORT_PDO_NAME_BASE		L"\\Device\\SXPort"

// File IDs for Event Logging (top 8 bits only).
#define SX_PNP_C		((ULONG)0x010000)
#define SX_W2K_C		((ULONG)0x020000)

// Tag used for memory allocations (must be 4 bytes in reverse).
#define MEMORY_TAG				'*XS*'


// SX HardwareIDs
#define SX_ISA_HWID		L"SPX_SX001"								// SX ISA (T225) card
#define SX_PCI_HWID		L"PCI\\VEN_11CB&DEV_2000&SUBSYS_020011CB"	// SX PCI (T225) card
#define SXPLUS_PCI_HWID	L"PCI\\VEN_11CB&DEV_2000&SUBSYS_030011CB"	// SX+ PCI (MCF5206e) card

#define SIXIO_ISA_HWID	L"SPX_SIXIO001"								// SIXIO ISA (Z280) card
#define SIXIO_PCI_HWID	L"PCI\\VEN_11CB&DEV_4000&SUBSYS_040011CB"	// SIXIO PCI (Z280) card


// SX CardTypes
#define	SiHost_1	0
#define	SiHost_2	1
#define	Si_2		2
#define	SiEisa		3
#define	SiPCI		4
#define	Si3Isa		5
#define	Si3Eisa		6
#define	Si3Pci		7
#define	SxPlusPci	8


/* End of SXDEFS.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\sx_card.h ===
/************************************************************************/
/*									*/
/*	Title		:	Card and Port Prototypes & Definitions	*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	18th September 1998			*/
/*									*/
/*	Version		:	1.1.0					*/
/*									*/
/*	Copyright	:	(c) Specialix International Ltd. 1998	*/
/*									*/
/*	Description	:	Prototypes, structures and definitions:	*/
/*					CARD_DEVICE_EXTENSION		*/
/*					PORT_DEVICE_EXTENSION		*/
/*									*/
/************************************************************************/

/* History...

1.0.0	18/09/98 NPV	Creation.

*/

#define		SLXOS_MAX_PORTS		(32)
#define		SLXOS_MAX_BOARDS	(4)
#define		SLXOS_MAX_MODULES	(4)
#define		SLXOS_REGISTER_SPAN	((ULONG)65536)

/*****************************************************************************
**************************                         ***************************
**************************   General Definitions   ***************************
**************************                         ***************************
*****************************************************************************/

#ifndef	_common_defs				/* If common definitions not already defined */
#define	_common_defs

#ifndef	_sx_defs				/* If SX definitions not already defined */
#define	_sx_defs
typedef	unsigned long	_u32;
typedef	unsigned short	_u16;
typedef	unsigned char	_u8;

#define	POINTER *
typedef _u32 POINTER pu32;
typedef _u16 POINTER pu16;
typedef _u8 POINTER pu8;
#endif

#define	DWORD	_u32
#define	ulong	_u32

#define	WORD	_u16
#define	ushort	_u16
#define	uint	_u16

#define	BYTE	_u8
#define	uchar	_u8

typedef char POINTER PSTR;
typedef	void POINTER PVOID;

#endif


#define		SERDIAG1	((ULONG)0x00000001)
#define		SERDIAG2	((ULONG)0x00000002)
#define		SERDIAG3	((ULONG)0x00000004)
#define		SERDIAG4	((ULONG)0x00000008)
#define		SERDIAG5	((ULONG)0x00000010)
#define		SERIRPPATH	((ULONG)0x00000020)
#define		SERINTERRUPT	((ULONG)0x04000000)
#define		SERPERFORM	((ULONG)0x08000000)
#define		SERDEBUG	((ULONG)0x10000000)
#define		SERFLOW		((ULONG)0x20000000)
#define		SERERRORS	((ULONG)0x40000000)
#define		SERBUGCHECK	((ULONG)0x80000000)

#ifndef	ESIL_XXX0				/* ESIL_XXX0 21/09/98 */
#if	DBG
extern ULONG SerialDebugLevel;
#define SpxDbgMsg(LEVEL,STRING)			\
	do					\
	{					\
		ULONG _level = (LEVEL);		\
		if(SerialDebugLevel & _level)	\
		{				\
			DbgPrint STRING;	\
		}				\
		if(_level == SERBUGCHECK)	\
		{				\
			ASSERT(FALSE);		\
		}				\
	} while (0)
#else
#define SpxDbgMsg(LEVEL,STRING) do {NOTHING;} while (0)
#endif
#endif						/* ESIL_XXX0 21/09/98 */


#ifndef	ESIL_XXX0				/* ESIL_XXX0 21/09/98 */
//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.

#define DEFAULT_DIRECTORY L"DosDevices"

typedef struct _CONFIG_DATA
{
	UNICODE_STRING	ObjectDirectory;
	UNICODE_STRING	NtNameForPort;
	UNICODE_STRING	SymbolicLinkName;
	UNICODE_STRING	ExternalNamePath;	/* Registry path for the external device name mapping */
	UCHAR		ChannelNumber;

} CONFIG_DATA,*PCONFIG_DATA;
#endif						/* ESIL_XXX0 21/09/98 */

/*****************************************************************************
**************************                           *************************
**************************   CARD_DEVICE_EXTENSION   *************************
**************************                           *************************
*****************************************************************************/

/* Card Device Extension Structure... */
   
typedef struct _CARD_DEVICE_EXTENSION
{
	COMMON_CARD_DEVICE_EXTENSION;			/* Common device extension structure */

#ifndef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	PDEVICE_OBJECT		DeviceObject;		/* Points to owning device object */
	UNICODE_STRING		DeviceName;		/* NT internal device name */
#endif							/* ESIL_XXX0 21/09/98 */

	PHYSICAL_ADDRESS	PCIConfigRegisters;
	ULONG				SpanOfPCIConfigRegisters;

/* Physical parameters... */

#ifdef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	PUCHAR			BaseController;		/* Pointer to base of card memory window */
#else							/* ESIL_XXX0 21/09/98 */
	PHYSICAL_ADDRESS	PhysAddr;		/* Physical address of card shared memory window */
	PUCHAR			Controller;		/* Pointer to base of card shared memory window */
	ULONG			SpanOfController;	/* Size of card shared memory window (in bytes) */
	ULONG			BusNumber;		/* Bus number */
	ULONG			SlotNumber;		/* Slot number in EISA/PCI system */
	ULONG			AddressSpace;		/* Type of address space (memory/IO) */
	KINTERRUPT_MODE		InterruptMode;		/* Interrupt mode (sharable/non-sharable) */
	INTERFACE_TYPE		InterfaceType;		/* Bus interface type */
	ULONG			OriginalVector;		/* Original (unmapped) interrupt vector */
	ULONG			OriginalIrql;		/* Original (unmapped) interrupt request level */
	ULONG			TrVector;		/* Interrupt vector */
	KIRQL			TrIrql;			/* Interrupt request level */
	KAFFINITY		ProcessorAffinity;	/* Interrupt processor affinity */
	PKINTERRUPT		Interrupt;		/* Points to interrupt object used by the card */
	BOOLEAN			InterruptShareable;	/* Indicates if card can share interrupts */
	PKSERVICE_ROUTINE	OurIsr;			/* Function pointer to Interrupt Service Routine */
	PVOID			OurIsrContext;		/* Context to be passed to "OurIsr" */
#endif							/* ESIL_XXX0 21/09/98 */
//	ULONG			CardType;		/* Defines the type of host card */
	BOOLEAN			UnMapRegisters;		/* Indicates if "controller" needs to be unmapped */
#ifdef	ESIL_XXX0					/* ESIL_XXX0 22/09/98 */
	_u32			UniqueId;		/* Unique hardware ID of card */
#endif							/* ESIL_XXX0 22/09/98 */

/* Functional parameters... */

	ULONG			PolledMode;		/* Indicates polled/interrupt mode */
	KTIMER			PolledModeTimer;	/* Used for polled mode processing */
	KDPC			PolledModeDpc;		/* Called to perform polled processing */
	ULONG			AutoIRQ;		/* Indicates auto IRQ selection */
	KSPIN_LOCK		DpcLock;		/* Lock for the DPC */
	BOOLEAN			DpcFlag;		/* Ownership flag for DPC */
	ULONG			MemoryHole;		/* If !0, don't report board memory usage */

/* Attached port details... */
	
	ULONG			ConfiguredNumberOfPorts;/* Number of ports expected on card */
	PPORT_DEV_EXT		PortExtTable[SLXOS_MAX_PORTS];
#ifndef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	ULONG			NumberOfPorts;		/* Number of ports on card */
	PCONFIG_DATA		Config[SLXOS_MAX_PORTS];
#endif							/* ESIL_XXX0 21/09/98 */

} CARD_DEVICE_EXTENSION, *PCARD_DEVICE_EXTENSION;


/*****************************************************************************
**************************                           *************************
**************************   PORT_DEVICE_EXTENSION   *************************
**************************                           *************************
*****************************************************************************/

/* Serial Port Device Extension Structure... */

typedef struct _PORT_DEVICE_EXTENSION
{
	COMMON_PORT_DEVICE_EXTENSION;			/* Common device extension structure */

#ifndef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	PDEVICE_OBJECT		DeviceObject;		/* Pointer to owning device object */
	UNICODE_STRING		DeviceName;		/* NT internal device name */
	UNICODE_STRING		SymbolicLinkName;	/* External device name */
	BOOLEAN			CreatedSymbolicLink;	/* Indicates if symbolic link was created */
	PCARD_DEV_EXT		pParentCardExt;		/* Pointer to owning card CARD_DEVICE_EXTENSION structure */
#endif							/* ESIL_XXX0 21/09/98 */
	_u32			SysPortNumber;		/* System port number */
	UNICODE_STRING		ObjectDirectory;	/* Pointer to object directory for symbolic name */
	UNICODE_STRING		NtNameForPort;		/* NT name for port without device prefix */
	UNICODE_STRING		ExternalNamePath;	/* Registry path for the external device name mapping */

/* Card related details... */

	PUCHAR			pChannel;		/* Pointer to CHANNEL structure in memory window */
	PKINTERRUPT		Interrupt;		/* Pointer to card interrupt object */
	PHYSICAL_ADDRESS	OriginalController;	/* Physical addresss of owning card */

/* Timing variables... */

	LARGE_INTEGER		IntervalTime;		/* Read interval time */
	LARGE_INTEGER		ShortIntervalAmount;	/* Short tread interval time */
	LARGE_INTEGER		LongIntervalAmount;	/* Long read interval time */
	LARGE_INTEGER		CutOverAmount;		/* Used to determine short/long interval time */
	LARGE_INTEGER		LastReadTime;		/* System time of last read */
	PLARGE_INTEGER		IntervalTimeToUse;	/* Interval timing delta time delay */

/* Queued IRP lists... */

	LIST_ENTRY		ReadQueue;		/* Head of read IRP list, protected by cancel spinlock */
	LIST_ENTRY		WriteQueue;		/* Head of write IRP list, protected by cancel spinlock */
	LIST_ENTRY		MaskQueue;		/* Head of set/wait mask IRP list, protected by cancel spinlock */
	LIST_ENTRY		PurgeQueue;		/* Head of purge IRP list, protected by cancel spinlock */

/* Current IRPs... */

	PIRP			CurrentReadIrp;		/* Pointer to current read IRP */
	PIRP			CurrentWriteIrp;	/* Pointer to current write IRP */
	PIRP			CurrentMaskIrp;		/* Pointer to current mask IRP */
	PIRP			CurrentPurgeIrp;	/* Pointer to current purge IRP */
	PIRP			CurrentWaitIrp;		/* Pointer to current wait IRP */
	PIRP			CurrentImmediateIrp;	/* Pointer to current send immediate IRP */
	PIRP			CurrentXoffIrp;		/* Pointer to current XOFF_COUNTER IRP */

/* Write IRP variables... */

	ULONG			WriteLength;		/* Write character count in current write IRP */
	PUCHAR			WriteCurrentChar;	/* Pointer to write character in current write IRP */

/* Read IRP variables... */

	PUCHAR			InterruptReadBuffer;	/* Read buffer current pointer in current read IRP */
	PUCHAR			ReadBufferBase;		/* Read buffer base pointer in current read IRP */
	ULONG			CharsInInterruptBuffer;	/* Characters read into read buffer */
	KSPIN_LOCK		BufferLock;		/* Spinlock protecting "CharsInInterruptBuffer" */
	PUCHAR			CurrentCharSlot;	/* Pointer at space to store new read data */
	PUCHAR			LastCharSlot;		/* Last valid position in read buffer */
	PUCHAR			FirstReadableChar;	/* First read character in read buffer */
	ULONG			BufferSize;		/* Read buffer size */
	ULONG			BufferSizePt8;		/* 80% read buffer size */
	ULONG			NumberNeededForRead;	/* Number of characters requested in current read IRP */

/* Mask IRP variables... */

	ULONG			IsrWaitMask;		/* Wait mask in current wait IRP */
	ULONG			HistoryMask;		/* History of masked events */
	ULONG			*IrpMaskLocation;	/* Pointer to mask location */

/* Serial port configuration... */

	ULONG			CurrentBaud;		/* Current baud rate */
	ULONG			SupportedBauds;		/* Bitmask defining supported baud rates */
	SERIAL_HANDFLOW		HandFlow;		/* Current handshaking and flow control settings */
	UCHAR			LineControl;		/* Current parity,databits,stopbits */
	SERIAL_CHARS		SpecialChars;		/* Current Special error/replacement characters */
	SERIAL_TIMEOUTS		Timeouts;		/* Read and write timeouts */
	UCHAR			ValidDataMask;		/* Read data mask */
	UCHAR			EscapeChar;		/* Escape character used with line/modem status strings */
	BOOLEAN			InsertEscChar;		/* Indicates of EscapeChar should be inserted */

/* Serial port status... */

	LONG			CountSinceXoff;		/* Nun chars read since XOFF counter started */
	ULONG			CountOfTryingToLowerRTS;/* Count of processes trying to lower RTS */
	BOOLEAN			TransmitImmediate;	/* Indicates of transmit immediate is pending */
	BOOLEAN			EmptiedTransmit;	/* Indicates transmit empty */
	BOOLEAN			DataInTxBuffer;		/* Indicates data has been placed in the card's Tx Buffer */
	BOOLEAN			DetectEmptyTxBuffer;/* Indicates we can detect when the card's Tx Buffer is empty */

	UCHAR			PendingOperation;	/* Pending CHANNEL hi_hstat operation */
	UCHAR			ImmediateChar;		/* Character to be transmitted immediately */
	UCHAR			LastStatus;		/* Last modem status (SX format) */
	UCHAR			LastModemStatus;	/* Last modem status (NT format) */
	ULONG			TXHolding;		/* Reasons for transmit blocked */
	ULONG			RXHolding;		/* Reasons for receive blocked */
	ULONG			ErrorWord;		/* Error conditions */
	ULONG			TotalCharsQueued;	/* Total number of queued characters in all write IRPs */
	LONG			CountOnLastRead;	/* Number of chars read last time interval timer DPC ran */
	ULONG			ReadByIsr;		/* Number of characters read during ISR */

	KSPIN_LOCK		ControlLock;		/* Used to protect certain fields */

#ifdef	ESIL_XXX0					/* ESIL_XXX0 15/10/98 */

/* Saved data during power down... */

	_u8		saved_hi_rxipos;		/* Saved Receive buffer input index */
	_u8		saved_hi_rxopos;		/* Saved Receive buffer output index */
	_u8		saved_hi_txopos;		/* Saved Transmit buffer output index */
	_u8		saved_hi_txipos;		/* Saved Transmit buffer input index */
	_u8		saved_hi_txbuf[256];		/* Saved Transmit buffer */
	_u8		saved_hi_rxbuf[256];		/* Saved Receive buffer */

#endif							/* ESIL_XXX0 15/10/98 */

/* Deferred procedure calls... */
	
	KDPC			CompleteWriteDpc;	/* DPC used to complete write IRPs */
	KDPC			CompleteReadDpc;	/* DPC used to complete read IRPs */
	KDPC			TotalReadTimeoutDpc;	/* DPC used to handle read total timeout */
	KDPC			IntervalReadTimeoutDpc;	/* DPC used to handle read interval timeout */
	KDPC			TotalWriteTimeoutDpc;	/* DPC used to handle write total timeout */
	KDPC			CommErrorDpc;		/* DPC used to handle cancel on error */
	KDPC			CommWaitDpc;		/* DPC used to handle waking IRPs waiting on an event */
	KDPC			CompleteImmediateDpc;	/* DPC used to handle transmitting an immediate character */
	KDPC			TotalImmediateTimeoutDpc;/* DPC used to handle immediate char timeout */
	KDPC			XoffCountTimeoutDpc;	/* DPC used to handle XOFF_COUNT timeout */
	KDPC			XoffCountCompleteDpc;	/* DPC used to complete XOFF_COUNT IRP */
	KDPC			StartTimerLowerRTSDpc;	/* DPC used to check for RTS lowering */
	KDPC			PerhapsLowerRTSDpc;	/* DPC used to check for RTS lowering */
	KDPC			SlxosDpc;		/* DPC used to handle interface with card */

/* Timers... */

	KTIMER			ReadRequestTotalTimer;	/* Timer used to handle total read request timeout */
	KTIMER			ReadRequestIntervalTimer;/* Timer used to handle interval read timeout */
	KTIMER			WriteRequestTotalTimer;	/* Timer used to handle total write request timeout */
	KTIMER			ImmediateTotalTimer;	/* Timer used to handle send immediate timeout */
	KTIMER			XoffCountTimer;		/* Timer used to handle XOFF_COUNT timeout */
	KTIMER			LowerRTSTimer;		/* Timer used to handle lower RTS timing */

	
	
} PORT_DEVICE_EXTENSION, *PPORT_DEVICE_EXTENSION;

/* PORT_DEVICE_EXTENSION.CountOnLastRead definitions... */
#define		SERIAL_COMPLETE_READ_CANCEL	((LONG)-1)
#define		SERIAL_COMPLETE_READ_TOTAL	((LONG)-2)
#define		SERIAL_COMPLETE_READ_COMPLETE	((LONG)-3)

/* PORT_DEVICE_EXTENSION.LineControl definitions... */
#define		SERIAL_5_DATA		((UCHAR)0x00)
#define		SERIAL_6_DATA		((UCHAR)0x01)
#define		SERIAL_7_DATA		((UCHAR)0x02)
#define		SERIAL_8_DATA		((UCHAR)0x03)
#define		SERIAL_DATA_MASK	((UCHAR)0x03)

#define		SERIAL_1_STOP		((UCHAR)0x00)
#define		SERIAL_1_5_STOP		((UCHAR)0x04) // Only valid for 5 data bits
#define		SERIAL_2_STOP		((UCHAR)0x04) // Not valid for 5 data bits
#define		SERIAL_STOP_MASK	((UCHAR)0x04)

#define		SERIAL_NONE_PARITY	((UCHAR)0x00)
#define		SERIAL_ODD_PARITY	((UCHAR)0x08)
#define		SERIAL_EVEN_PARITY	((UCHAR)0x18)
#define		SERIAL_MARK_PARITY	((UCHAR)0x28)
#define		SERIAL_SPACE_PARITY	((UCHAR)0x38)
#define		SERIAL_PARITY_MASK	((UCHAR)0x38)
#define		SERIAL_LCR_BREAK	0x40

/* PORT_DEVICE_EXTENSION.SpecialChars default xon/xoff characters... */
#define		SERIAL_DEF_XON		0x11
#define		SERIAL_DEF_XOFF		0x13

/* PORT_DEVICE_EXTENSION.TXHolding definitions... */
#define		SERIAL_TX_CTS		((ULONG)0x01)
#define		SERIAL_TX_DSR		((ULONG)0x02)
#define		SERIAL_TX_DCD		((ULONG)0x04)
#define		SERIAL_TX_XOFF		((ULONG)0x08)
#define		SERIAL_TX_BREAK		((ULONG)0x10)

/* PORT_DEVICE_EXTENSION.RXHolding definitions... */
#define		SERIAL_RX_DTR		((ULONG)0x01)
#define		SERIAL_RX_XOFF		((ULONG)0x02)
#define		SERIAL_RX_RTS		((ULONG)0x04)
#define		SERIAL_RX_DSR		((ULONG)0x08)

/* PORT_DEVICE_EXTENSION.LastStatus definitions... */
#define		SERIAL_LSR_OE		0x02
#define		SERIAL_LSR_PE		0x04
#define		SERIAL_LSR_FE		0x08
#define		SERIAL_LSR_BI		0x10

/* 16550 Modem Control Register definitions... */
#define		SERIAL_MCR_DTR		0x01
#define		SERIAL_MCR_RTS		0x02

/* 16550 Modem Status Register definitions... */
#define		SERIAL_MSR_DCTS		0x01
#define		SERIAL_MSR_DDSR		0x02
#define		SERIAL_MSR_TERI		0x04
#define		SERIAL_MSR_DDCD		0x08
#define		SERIAL_MSR_CTS		0x10
#define		SERIAL_MSR_DSR		0x20
#define		SERIAL_MSR_RI		0x40
#define		SERIAL_MSR_DCD		0x80

/* End of SX_CARD.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\sxwindow.h ===
/************************************************************************/
/*									*/
/*	Title		:	SX Shared Memory Window Structure	*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	16th March 1998				*/
/*									*/
/*	Version		:	3.0.8					*/
/*									*/
/*	Copyright	:	(c) Specialix International Ltd. 1998	*/
/*									*/
/*	Description	:	Prototypes, structures and definitions	*/
/*				describing the SX/SI/XIO cards shared	*/
/*				memory window structure:		*/
/*					SXCARD				*/
/*					SXMODULE			*/
/*					SXCHANNEL			*/
/*									*/
/************************************************************************/

/* History...

3.0.0	16/03/98 NPV	Creation. (based on STRUCT.H)
3.0.1	30/04/98 NPV	Add SP_DSR_TXFLOW to SXCHANNEL.hi_prtcl field
3.0.2	14/07/98 NPV	Add flow_state field to SXCHANNEL structure
3.0.3	17/07/98 NPV	Use new typedefs _u8, _u16 etc.
3.0.4	24/07/98 NPV	Add hi_err_replace to SXCHANNEL structure
3.0.5	05/10/98 NPV	Add new module type RS232 DTE.
3.0.6	10/08/99 NPV	Add io_state field to SXCHANNEL structure
3.0.7	28/07/00 NPV	Add tx_fifo_size, tx_fifo_level and tx_fifo_count to SXCHANNEL structure
3.0.8	18-Sep-00 NPV	Add hs_config_mask field to refine the operations during HS_CONFIG command

*/

#ifndef	_sxwindow_h				/* If SXWINDOW.H not already defined */
#define	_sxwindow_h    1

/*****************************************************************************
***************************                        ***************************
***************************   Common Definitions   ***************************
***************************                        ***************************
*****************************************************************************/

#ifndef	_sx_defs				/* If SX definitions not already defined */
#define	_sx_defs
typedef	unsigned long	_u32;
typedef	unsigned short	_u16;
typedef	unsigned char	_u8;

#define	POINTER *
typedef _u32 POINTER pu32;
typedef _u16 POINTER pu16;
typedef _u8 POINTER pu8;
#endif

typedef	struct	_SXCARD		*PSXCARD;	/* SXCARD structure pointer */
typedef	struct	_SXMODULE	*PMOD;		/* SXMODULE structure pointer */
typedef	struct	_SXCHANNEL	*PCHAN;		/* SXCHANNEL structure pointer */

/*****************************************************************************
*********************************            *********************************
*********************************   SXCARD   *********************************
*********************************            *********************************
*****************************************************************************/
 #ifdef COLDFIRE_SX
 typedef	__packed__(1,1,1) struct	_SXCARD 
/* typedef	struct	_SXCARD */
#else
typedef	struct	_SXCARD
#endif
{
	_u8	cc_init_status;			/* 0x00 Initialisation status */
	_u8	cc_mem_size;			/* 0x01 Size of memory on card */
	_u16	cc_int_count;			/* 0x02 Interrupt count */
	_u16	cc_revision;			/* 0x04 Download code revision */
	_u8	cc_isr_count;			/* 0x06 Count when ISR is run */
	_u8	cc_main_count;			/* 0x07 Count when main loop is run */
	_u16	cc_int_pending;			/* 0x08 Interrupt pending */
	_u16	cc_poll_count;			/* 0x0A Count when poll is run */
	_u8	cc_int_set_count;		/* 0x0C Count when host interrupt is set */
	_u8	cc_rfu[0x80 - 0x0D];		/* 0x0D Pad structure to 128 bytes (0x80) */

} SXCARD;

/* SXCARD.cc_init_status definitions... */
#define 	ADAPTERS_FOUND		(_u8)0x01
#define 	NO_ADAPTERS_FOUND	(_u8)0xFF

/* SXCARD.cc_mem_size definitions... */
#define 	SX_MEMORY_SIZE		(_u8)0x40
#define    SXC_MEMORY_SIZE   (_u8)0x80

/* SXCARD.cc_int_count definitions... */
#define 	INT_COUNT_DEFAULT	100	/* Hz */

/*****************************************************************************
********************************              ********************************
********************************   SXMODULE   ********************************
********************************              ********************************
*****************************************************************************/

#define	TOP_POINTER(a)		((a)|0x8000)	/* Sets top bit of word */
#define UNTOP_POINTER(a)	((a)&~0x8000)	/* Clears top bit of word */

#ifdef COLDFIRE_SX
typedef	__packed__(1,1,1) struct	_SXMODULE 
/* typedef	struct	_SXMODULE */
#else
typedef	struct	_SXMODULE
#endif
{
	_u16	mc_next;			/* 0x00 Next module "pointer" (ORed with 0x8000) */
	_u8	mc_type;			/* 0x02 Type of TA in terms of number of channels */
	_u8	mc_mod_no;			/* 0x03 Module number on SI bus cable (0 closest to card) */
	_u8	mc_dtr;				/* 0x04 Private DTR copy (TA only) */
	_u8	mc_rfu1;			/* 0x05 Reserved */
	_u16	mc_uart;			/* 0x06 UART base address for this module */
	_u8	mc_chip;			/* 0x08 Chip type / number of ports */
	_u8	mc_current_uart;		/* 0x09 Current uart selected for this module */
#ifdef	DOWNLOAD
	PCHAN	mc_chan_pointer[8];		/* 0x0A Pointer to each channel structure */
#else
	_u16	mc_chan_pointer[8];		/* 0x0A Define as WORD if not compiling into download */
#endif
	_u16	mc_rfu2;			/* 0x1A Reserved */
	_u8	mc_opens1;			/* 0x1C Number of open ports on first four ports on MTA/SXDC */
	_u8	mc_opens2;			/* 0x1D Number of open ports on second four ports on MTA/SXDC */
	_u8	mc_mods;			/* 0x1E Types of connector module attached to MTA/SXDC */
	_u8	mc_rev1;			/* 0x1F Revision of first CD1400 on MTA/SXDC */
	_u8	mc_rev2;			/* 0x20 Revision of second CD1400 on MTA/SXDC */
	_u8	mc_mtaasic_rev;			/* 0x21 Revision of MTA ASIC 1..4 -> A, B, C, D */
	_u8	mc_rfu3[0x100 - 0x22];		/* 0x22 Pad structure to 256 bytes (0x100) */

} SXMODULE;

/* SXMODULE.mc_type definitions... */
#define		FOUR_PORTS	(_u8)4
#define 	EIGHT_PORTS	(_u8)8

/* SXMODULE.mc_chip definitions... */
#define 	CHIP_MASK	0xF0
#define		TA		(_u8)0
#define 	TA4		(TA | FOUR_PORTS)
#define 	TA8		(TA | EIGHT_PORTS)
#define		TA4_ASIC	(_u8)0x0A
#define		TA8_ASIC	(_u8)0x0B
#define 	MTA_CD1400	(_u8)0x28
#define 	SXDC		(_u8)0x48

/* SXMODULE.mc_mods definitions... */
#define		MOD_RS232DB25		0x00	/* RS232 DB25 (socket/plug) */
#define		MOD_RS232RJ45		0x01	/* RS232 RJ45 (shielded/opto-isolated) */
#define		MOD_RESERVED_2		0x02	/* Reserved (RS485) */
#define		MOD_RS422DB25		0x03	/* RS422 DB25 Socket */
#define		MOD_RESERVED_4		0x04	/* Reserved */
#define		MOD_PARALLEL		0x05	/* Parallel */
#define		MOD_RESERVED_6		0x06	/* Reserved (RS423) */
#define		MOD_RESERVED_7		0x07	/* Reserved */
#define		MOD_2_RS232DB25		0x08	/* Rev 2.0 RS232 DB25 (socket/plug) */
#define		MOD_2_RS232RJ45		0x09	/* Rev 2.0 RS232 RJ45 */
#define		MOD_2_RS232DB25_DTE	0x0A	/* Rev 2.0 Reserved */
#define		MOD_2_RS422DB25		0x0B	/* Rev 2.0 RS422 DB25 */
#define		MOD_RESERVED_C		0x0C	/* Rev 2.0 Reserved */
#define		MOD_2_PARALLEL		0x0D	/* Rev 2.0 Parallel */
#define		MOD_RESERVED_E		0x0E	/* Rev 2.0 Reserved */
#define		MOD_BLANK		0x0F	/* Blank Panel */

/* Mapped module types...*/
#define		MOD_RS232RJ45_OI	0x10	/* RS232 RJ45 Opto-Isolated */
#define		MOD_2_RS232RJ45S	0x11	/* RS232 RJ45 Shielded Rev 2.0 */

/*****************************************************************************
********************************               *******************************
********************************   SXCHANNEL   *******************************
********************************               *******************************
*****************************************************************************/

#define		TX_BUFF_OFFSET		0x60	/* Transmit buffer offset in channel structure */
#define		BUFF_POINTER(a)		(((a)+TX_BUFF_OFFSET)|0x8000)
#define		UNBUFF_POINTER(a)	(jet_channel*)(((a)&~0x8000)-TX_BUFF_OFFSET) 
#define 	BUFFER_SIZE		256
#define 	HIGH_WATER		((BUFFER_SIZE / 4) * 3)
#define 	LOW_WATER		(BUFFER_SIZE / 4)

#ifdef COLDFIRE_SX
typedef	__packed__(1,1,1) struct	_SXCHANNEL 
/* typedef	struct	_SXCHANNEL */
#else
typedef	struct	_SXCHANNEL
#endif
{
	_u16	next_item;			/* 0x00 Offset from window base of next channels hi_txbuf (ORred with 0x8000) */
	_u16 	addr_uart;			/* 0x02 INTERNAL pointer to uart address. Includes FASTPATH bit */
	_u16	module;				/* 0x04 Offset from window base of parent SXMODULE structure */
	_u8 	type;				/* 0x06 Chip type / number of ports (copy of mc_chip) */
	_u8	chan_number;			/* 0x07 Channel number on the TA/MTA/SXDC */
	_u16	xc_status;			/* 0x08 Flow control and I/O status */
	_u8	hi_rxipos;			/* 0x0A Receive buffer input index */
	_u8	hi_rxopos;			/* 0x0B Receive buffer output index */
	_u8	hi_txopos;			/* 0x0C Transmit buffer output index */
	_u8	hi_txipos;			/* 0x0D Transmit buffer input index */
	_u8	hi_hstat;			/* 0x0E Command register */
	_u8	dtr_bit;			/* 0x0F INTERNAL DTR control byte (TA only) */
	_u8	txon;				/* 0x10 INTERNAL copy of hi_txon */
	_u8	txoff;				/* 0x11 INTERNAL copy of hi_txoff */
	_u8	rxon;				/* 0x12 INTERNAL copy of hi_rxon */
	_u8	rxoff;				/* 0x13 INTERNAL copy of hi_rxoff */
	_u8	hi_mr1;				/* 0x14 Mode Register 1 (databits,parity,RTS rx flow)*/
	_u8	hi_mr2;				/* 0x15 Mode Register 2 (stopbits,local,CTS tx flow)*/
	_u8	hi_csr;				/* 0x16 Clock Select Register (baud rate) */
	_u8	hi_op;				/* 0x17 Modem Output Signal */
	_u8	hi_ip;				/* 0x18 Modem Input Signal */
	_u8	hi_state;			/* 0x19 Channel status */
	_u8	hi_prtcl;			/* 0x1A Channel protocol (flow control) */
	_u8	hi_txon;			/* 0x1B Transmit XON character */
	_u8	hi_txoff;			/* 0x1C Transmit XOFF character */
	_u8	hi_rxon;			/* 0x1D Receive XON character */
	_u8	hi_rxoff;			/* 0x1E Receive XOFF character */
	_u8	close_prev;			/* 0x1F INTERNAL channel previously closed flag */
	_u8	hi_break;			/* 0x20 Break and error control */
	_u8	break_state;			/* 0x21 INTERNAL copy of hi_break */
	_u8	hi_mask;			/* 0x22 Mask for received data */
	_u8	mask;				/* 0x23 INTERNAL copy of hi_mask */
	_u8	mod_type;			/* 0x24 MTA/SXDC hardware module type */
	_u8	ccr_state;			/* 0x25 INTERNAL MTA/SXDC state of CCR register */
	_u8	ip_mask;			/* 0x26 Input handshake mask */
	_u8	hi_parallel;			/* 0x27 Parallel port flag */
	_u8	par_error;			/* 0x28 Error code for parallel loopback test */
	_u8	any_sent;			/* 0x29 INTERNAL data sent flag */
	_u8	asic_txfifo_size;		/* 0x2A INTERNAL SXDC transmit FIFO size */
	_u8	hi_err_replace;			/* 0x2B Error replacement character (enabled by BR_ERR_REPLACE) */
	_u8	rfu1[1];			/* 0x2C Reserved */
	_u8	csr;				/* 0x2D INTERNAL copy of hi_csr */
#ifdef	DOWNLOAD
	PCHAN	nextp;				/* 0x2E Offset from window base of next channel structure */
#else
	_u16	nextp;				/* 0x2E Define as WORD if not compiling into download */
#endif
	_u8	prtcl;				/* 0x30 INTERNAL copy of hi_prtcl */
	_u8	mr1;				/* 0x31 INTERNAL copy of hi_mr1 */
	_u8	mr2;				/* 0x32 INTERNAL copy of hi_mr2 */
	_u8	hi_txbaud;			/* 0x33 Extended transmit baud rate (SXDC only if((hi_csr&0x0F)==0x0F) */
	_u8	hi_rxbaud;			/* 0x34 Extended receive baud rate  (SXDC only if((hi_csr&0xF0)==0xF0) */
	_u8	txbreak_state;			/* 0x35 INTERNAL MTA/SXDC transmit break state */
	_u8	txbaud;				/* 0x36 INTERNAL copy of hi_txbaud */
	_u8	rxbaud;				/* 0x37 INTERNAL copy of hi_rxbaud */
	_u16	err_framing;			/* 0x38 Count of receive framing errors */
	_u16	err_parity;			/* 0x3A Count of receive parity errors */
	_u16	err_overrun;			/* 0x3C Count of receive overrun errors */
	_u16	err_overflow;			/* 0x3E Count of receive buffer overflow errors */
	_u8	flow_state;			/* 0x40 INTERNAL state of flow control */
	_u8	io_state;			/* 0x41 INTERNAL state of transmit/receive data */
	_u8	tx_fifo_size;			/* 0x42 Size of the channels transmit FIFO */
	_u8	tx_fifo_level;			/* 0x43 Level of transmit FIFO to use */
	_u8	tx_fifo_count;			/* 0x44 Count of characters currently in the transmit FIFO */
	_u8	hs_config_mask;			/* 0x45 Mask used to refine HS_CONFIG operation */
	_u8	rfu2[TX_BUFF_OFFSET - 0x46];	/* 0x46 Reserved until hi_txbuf */
	_u8	hi_txbuf[BUFFER_SIZE];		/* 0x060 Transmit buffer */
	_u8	hi_rxbuf[BUFFER_SIZE];		/* 0x160 Receive buffer */
	_u8	rfu3[0x300 - 0x260];		/* 0x260 Reserved until 768 bytes (0x300) */

} SXCHANNEL;

/* SXCHANNEL.addr_uart definitions... */
#define		FASTPATH	0x1000		/* Set to indicate fast rx/tx processing (TA only) */

/* SXCHANNEL.xc_status definitions... */
#define		X_TANY		0x0001		/* XON is any character (TA only) */
#define		X_TION		0x0001		/* Tx interrupts on (MTA only) */
#define		X_TXEN		0x0002		/* Tx XON/XOFF enabled (TA only) */
#define		X_RTSEN		0x0002		/* RTS FLOW enabled (MTA only) */
#define		X_TXRC		0x0004		/* XOFF received (TA only) */
#define		X_RTSLOW	0x0004		/* RTS dropped (MTA only) */
#define		X_RXEN		0x0008		/* Rx XON/XOFF enabled */
#define		X_ANYXO		0x0010		/* XOFF pending/sent or RTS dropped */
#define		X_RXSE		0x0020		/* Rx XOFF sent */
#define		X_NPEND		0x0040		/* Rx XON pending or XOFF pending */
#define		X_FPEND		0x0080		/* Rx XOFF pending */
#define		C_CRSE		0x0100		/* Carriage return sent (TA only) */
#define		C_TEMR		0x0100		/* Tx empty requested (MTA only) */
#define		C_TEMA		0x0200		/* Tx empty acked (MTA only) */
#define		C_ANYP		0x0200		/* Any protocol bar tx XON/XOFF (TA only) */
#define		C_EN		0x0400		/* Cooking enabled (on MTA means port is also || */
#define		C_HIGH		0x0800		/* Buffer previously hit high water */
#define		C_CTSEN		0x1000		/* CTS automatic flow-control enabled */
#define		C_DCDEN		0x2000		/* DCD/DTR checking enabled */
#define		C_BREAK		0x4000		/* Break detected */
#define		C_RTSEN		0x8000		/* RTS automatic flow control enabled (MTA only) */
#define		C_PARITY	0x8000		/* Parity checking enabled (TA only) */

/* SXCHANNEL.hi_hstat definitions... */
#define		HS_IDLE_OPEN	0x00		/* Channel open state */
#define		HS_LOPEN	0x02		/* Local open command (no modem monitoring) */
#define		HS_MOPEN	0x04		/* Modem open command (wait for DCD signal) */
#define		HS_IDLE_MPEND	0x06		/* Waiting for DCD signal state */
#define		HS_CONFIG	0x08		/* Configuration command */
#define		HS_CLOSE	0x0A		/* Close command */
#define		HS_START	0x0C		/* Start transmit break command */
#define		HS_STOP		0x0E		/* Stop transmit break command */
#define		HS_IDLE_CLOSED	0x10		/* Closed channel state */
#define		HS_IDLE_BREAK	0x12		/* Transmit break state */
#define		HS_FORCE_CLOSED	0x14		/* Force close command */
#define		HS_RESUME	0x16		/* Clear pending XOFF command */
#define		HS_WFLUSH	0x18		/* Flush transmit buffer command */
#define		HS_RFLUSH	0x1A		/* Flush receive buffer command */
#define		HS_SUSPEND	0x1C		/* Suspend output command (like XOFF received) */
#define		PARALLEL	0x1E		/* Parallel port loopback test command (Diagnostics Only) */
#define		ENABLE_RX_INTS	0x20		/* Enable receive interrupts command (Diagnostics Only) */
#define		ENABLE_TX_INTS	0x22		/* Enable transmit interrupts command (Diagnostics Only) */
#define		ENABLE_MDM_INTS	0x24		/* Enable modem interrupts command (Diagnostics Only) */
#define		DISABLE_INTS	0x26		/* Disable interrupts command (Diagnostics Only) */

/* SXCHANNEL.hi_mr1 definitions... */
#define		MR1_BITS	0x03		/* Data bits mask */
#define		MR1_5_BITS	0x00		/* 5 data bits */
#define		MR1_6_BITS	0x01		/* 6 data bits */
#define		MR1_7_BITS	0x02		/* 7 data bits */
#define		MR1_8_BITS	0x03		/* 8 data bits */
#define		MR1_PARITY	0x1C		/* Parity mask */
#define		MR1_ODD		0x04		/* Odd parity */
#define		MR1_EVEN	0x00		/* Even parity */
#define		MR1_WITH	0x00		/* Parity enabled */
#define		MR1_FORCE	0x08		/* Force parity */
#define		MR1_NONE	0x10		/* No parity */
#define		MR1_NOPARITY	MR1_NONE		/* No parity */
#define		MR1_ODDPARITY	(MR1_WITH|MR1_ODD)	/* Odd parity */
#define		MR1_EVENPARITY	(MR1_WITH|MR1_EVEN)	/* Even parity */
#define		MR1_MARKPARITY	(MR1_FORCE|MR1_ODD)	/* Mark parity */
#define		MR1_SPACEPARITY	(MR1_FORCE|MR1_EVEN)	/* Space parity */
#define		MR1_RTS_RXFLOW	0x80		/* RTS receive flow control */

/* SXCHANNEL.hi_mr2 definitions... */
#define		MR2_STOP	0x0F		/* Stop bits mask */
#define		MR2_1_STOP	0x07		/* 1 stop bit */
#define		MR2_2_STOP	0x0F		/* 2 stop bits */
#define		MR2_CTS_TXFLOW	0x10		/* CTS transmit flow control */
#define		MR2_RTS_TOGGLE	0x20		/* RTS toggle on transmit */
#define		MR2_NORMAL	0x00		/* Normal mode */
#define		MR2_AUTO	0x40		/* Auto-echo mode (TA only) */
#define		MR2_LOCAL	0x80		/* Local echo mode */
#define		MR2_REMOTE	0xC0		/* Remote echo mode (TA only) */

/* SXCHANNEL.hi_csr definitions... */
#define		CSR_75		0x0		/*    75 baud */
#define		CSR_110		0x1		/*   110 baud (TA), 115200 (MTA/SXDC) */
#define		CSR_38400	0x2		/* 38400 baud */
#define		CSR_150		0x3		/*   150 baud */
#define		CSR_300		0x4		/*   300 baud */
#define		CSR_600		0x5		/*   600 baud */
#define		CSR_1200	0x6		/*  1200 baud */
#define		CSR_2000	0x7		/*  2000 baud */
#define		CSR_2400	0x8		/*  2400 baud */
#define		CSR_4800	0x9		/*  4800 baud */
#define		CSR_1800	0xA		/*  1800 baud */
#define		CSR_9600	0xB		/*  9600 baud */
#define		CSR_19200	0xC		/* 19200 baud */
#define		CSR_57600	0xD		/* 57600 baud */
#define		CSR_EXTBAUD	0xF		/* Extended baud rate (hi_txbaud/hi_rxbaud) */

/* SXCHANNEL.hi_op definitions... */
#define		OP_RTS		0x01		/* RTS modem output signal */
#define		OP_DTR		0x02		/* DTR modem output signal */

/* SXCHANNEL.hi_ip definitions... */
#define		IP_CTS		0x02		/* CTS modem input signal */
#define		IP_DCD		0x04		/* DCD modem input signal */
#define		IP_DSR		0x20		/* DSR modem input signal */
#define		IP_RI		0x40		/* RI modem input signal */

/* SXCHANNEL.hi_state definitions... */
#define		ST_BREAK	0x01		/* Break received (clear with config) */
#define		ST_DCD		0x02		/* DCD signal changed state */

/* SXCHANNEL.hi_prtcl definitions... */
#define		SP_TANY		0x01		/* Transmit XON/XANY (if SP_TXEN enabled) */
#define		SP_TXEN		0x02		/* Transmit XON/XOFF flow control */
#define		SP_CEN		0x04		/* Cooking enabled */
#define		SP_RXEN		0x08		/* Rx XON/XOFF enabled */
#define		SP_DSR_TXFLOW	0x10		/* DSR transmit flow control */
#define		SP_DCEN		0x20		/* Enable modem signal reporting (DCD / DTR check) */
#define		SP_DTR_RXFLOW	0x40		/* DTR receive flow control */
#define		SP_PAEN		0x80		/* Parity checking enabled */

/* SXCHANNEL.hi_break definitions... */
#define		BR_IGN		0x01		/* Ignore any received breaks */
#define		BR_INT		0x02		/* Interrupt on received break */
#define		BR_PARMRK	0x04		/* Enable parmrk parity error processing */
#define		BR_PARIGN	0x08		/* Ignore chars with parity errors */
#define		BR_ERR_REPLACE	0x40		/* Replace errors with hi_err_replace character */
#define 	BR_ERRINT	0x80		/* Treat parity/framing/overrun errors as exceptions */

/* SXCHANNEL.par_error definitions.. */
#define		DIAG_IRQ_RX	0x01		/* Indicate serial receive interrupt (diags only) */
#define		DIAG_IRQ_TX	0x02		/* Indicate serial transmit interrupt (diags only) */
#define		DIAG_IRQ_MD	0x04		/* Indicate serial modem interrupt (diags only) */

/* SXCHANNEL.hi_txbaud/hi_rxbaud definitions... (SXDC only) */
#define		BAUD_75		0x00		/*     75 baud */
#define		BAUD_115200	0x01		/* 115200 baud */
#define		BAUD_38400	0x02		/*  38400 baud */
#define		BAUD_150	0x03		/*    150 baud */
#define		BAUD_300	0x04		/*    300 baud */
#define		BAUD_600	0x05		/*    600 baud */
#define		BAUD_1200	0x06		/*   1200 baud */
#define		BAUD_2000	0x07		/*   2000 baud */
#define		BAUD_2400	0x08		/*   2400 baud */
#define		BAUD_4800	0x09		/*   4800 baud */
#define		BAUD_1800	0x0A		/*   1800 baud */
#define		BAUD_9600	0x0B		/*   9600 baud */
#define		BAUD_19200	0x0C		/*  19200 baud */
#define		BAUD_57600	0x0D		/*  57600 baud */
#define		BAUD_230400	0x0E		/* 230400 baud */
#define		BAUD_460800	0x0F		/* 460800 baud */
#define		BAUD_921600	0x10		/* 921600 baud */
#define		BAUD_50		0x11    	/*     50 baud */
#define		BAUD_110	0x12		/*    110 baud */
#define		BAUD_134_5	0x13		/*  134.5 baud */
#define		BAUD_200	0x14		/*    200 baud */
#define		BAUD_7200	0x15		/*   7200 baud */
#define		BAUD_56000	0x16		/*  56000 baud */
#define		BAUD_64000	0x17		/*  64000 baud */
#define		BAUD_76800	0x18		/*  76800 baud */
#define		BAUD_128000	0x19		/* 128000 baud */
#define		BAUD_150000	0x1A		/* 150000 baud */
#define		BAUD_14400	0x1B		/*  14400 baud */
#define		BAUD_256000	0x1C		/* 256000 baud */
#define		BAUD_28800	0x1D		/*  28800 baud */

/* SXCHANNEL.txbreak_state definiions... */
#define		TXBREAK_OFF	0		/* Not sending break */
#define		TXBREAK_START	1		/* Begin sending break */
#define		TXBREAK_START1	2		/* Begin sending break, part 1 */
#define		TXBREAK_ON	3		/* Sending break */
#define		TXBREAK_STOP	4		/* Stop sending break */
#define		TXBREAK_STOP1	5		/* Stop sending break, part 1 */

/* SXCHANNEL.flow_state definitions... */
#define		FS_TXBLOCKEDDSR		0x01	/* Transmit blocked by DSR flow control */
#define		FS_PENDING		0x10	/* Flow state check pending */

/* SXCHANNEL.io_state definitions... */
#define		IO_TXNOTEMPTY		0x01	/* Data present in the transmit buffer */

/* SXCHANNEL.hs_config_mask definitions... */
#define		CFGMASK_ALL		0xFF	/* Configure all parameters (set initially and at end of HS_CONFIG) */
#define		CFGMASK_BAUD		0x01	/* Configure baud rate if set */
#define		CFGMASK_LINE		0x02	/* Configure parity/start/stop bits if set */
#define		CFGMASK_MODEM		0x10	/* Configure DTR/RTS modem signals if set */
#define		CFGMASK_FLOW		0x20	/* Configure flow control if set */

#endif						/* _sxwindow_h */

/* End of SXWINDOW.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\inc\sx_ver.h ===
/************************************************************************
*									
*	Title:		Version and ESIL Log File for SX NT Driver.	
*									
*	Author:		N.P.Vassallo					
*									
*	Creation:	21st September 1998				
*									
*	Description:	This file has three sections:			
*					Current version definition,		
*					Previous version changes,		
*					ESIL modification definitions		
*									
************************************************************************/

/*****************************************************************************
*****************************                     ****************************
*****************************   Current Version   ****************************
*****************************                     ****************************
*****************************************************************************/

/* The following definitions are used to define the driver "properties" */

#define	VER_MAJOR			01
#define	VER_MINOR			01
#define	VER_REVISION		02

#define VER_BUILD			0031
#define VER_BUILDSTR		"0031"

#define	VERSION_NUMBER		VER_MAJOR,VER_MINOR,VER_REVISION,VER_BUILD
#define VERSION_NUMBER_STR	"1.1.2." VER_BUILDSTR

#define COMPANY_NAME		"Perle Systems Ltd. " 
#define COPYRIGHT_YEARS		"2001 "
#define COPYRIGHT_SYMBOL	" "

#define PRODUCT_NAME		"SX"

#define SOFTWARE_NAME		" Serial Device Driver "
#define DRIVER_FILENAME 	"SX.SYS"


/* Latest changes...

Version		Date	 Author	Description
=======		====	 ======	===========

*/

/*****************************************************************************
****************************                       ***************************
****************************   Previous Versions   ***************************
****************************                       ***************************
******************************************************************************

Version		Date	 Author	Description
=======		====	 ======	===========

*/

/*****************************************************************************
****************************                      ****************************
****************************   ESIL Definitions   ****************************
****************************                      ****************************
*****************************************************************************/

//#define	CHECK_COMPLETED

#ifdef	CHECK_COMPLETED
void	DisplayCompletedIrp(struct _IRP *Irp,int index);
#endif

/* ESIL	Date	 Author		Description */
/* ====	====	 ======		=========== */

/* XXX0 21/09/98 NPV		Conditional compilation for NT5 driver. */
#define	ESIL_XXX0

/* End of VERSIONS.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\error.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the code that is very specific to error
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#endif


VOID
SerialCommError(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);

    SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\incl\spx_card.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//  Card and Port device extension structures.
// 
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_CARD_H
#define SPX_CARD_H	

typedef	struct _CARD_DEVICE_EXTENSION *PCARD_DEV_EXT;
typedef	struct _PORT_DEVICE_EXTENSION *PPORT_DEV_EXT;

//////////////////////////////////////////////////////////////////////////////////////////
// Common header for all the device extensions 
// Common to all the PDOs and FDOs (cards and ports).
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_OBJECT_DATA
{
    PDEVICE_OBJECT	DeviceObject;			// A backpointer to the device object that contains this device extension.
    PDRIVER_OBJECT	DriverObject;			// Pointer to Driver Object
    BOOLEAN         IsFDO;					// A boolean to distringuish between PDO and FDO.
	PDEVICE_OBJECT	LowerDeviceObject;		// This is a pointer to the next lower device in the IRP stack.

    ULONG           DebugLevel;

	ULONG			PnpPowerFlags;			// Plug & Play / Power flags
	KSPIN_LOCK		PnpPowerFlagsLock;		// Lock for protecting the flags
	BOOLEAN         PowerQueryLock;			// Are we currently in a query power state? 
    LIST_ENTRY		StalledIrpQueue;		// List of stalled IRPs
	KSPIN_LOCK		StalledIrpLock;			// Lock for protecting stalled IRPs
	BOOLEAN			UnstallingFlag;			// Flag set if we are unstalling IRPs currently queued.

#ifndef	BUILD_SPXMINIPORT
	SYSTEM_POWER_STATE  SystemState;		// Current System Power State
    DEVICE_POWER_STATE  DeviceState;		// Current Device Power State
#endif

#ifdef WMI_SUPPORT
    WMILIB_CONTEXT		WmiLibInfo;			// WMI Information
#endif

} COMMON_OBJECT_DATA, *PCOMMON_OBJECT_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Configuration Data.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CONFIG_DATA 
{
	PHYSICAL_ADDRESS	RawPhysAddr;		// Raw physical address of card 
    PHYSICAL_ADDRESS    PhysAddr;			// Translated Physical address of card.
	PUCHAR				Controller;			// Virtual mapped sddress of card.
    ULONG               SpanOfController;	// Size of memory used by Cord.
    INTERFACE_TYPE      InterfaceType;		// Type of card (Isa or Pci)
    ULONG               BusNumber;			// Bus number card is using.
	ULONG				SlotNumber;			// Slot number on bus.		
    ULONG               AddressSpace;		// Flag used by SX
    ULONG               OriginalVector;		// Original Vector (bus relative)
    ULONG               OriginalIrql;		// Original Irql (bus relative)
    ULONG               TrVector;			// Translated Vector (system relative).
    KIRQL               TrIrql;				// Translated Irql (system relative).
    KINTERRUPT_MODE     InterruptMode;		// Interrupt mode (LevelSensitive or Latched)
	BOOLEAN				InterruptShareable;	// Interrupt shareable flag.
    KAFFINITY           ProcessorAffinity;	// Processor affintity.
	PKSERVICE_ROUTINE	OurIsr;				// Points to interrupt service routine.
    PVOID				OurIsrContext;		// Points to card device extension.
    PKINTERRUPT			Interrupt;			// Points to the interrupt object used by the card.
    ULONG               ClockRate;			// ClockRate.
} CONFIG_DATA,*PCONFIG_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_CARD_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	CONFIG_DATA;									// Card Config Data
	PDEVICE_OBJECT PDO;								// Pointer to Physical Device Object 

	UNICODE_STRING	DeviceName;						// Device name.
	ULONG			CardNumber;
	ULONG			NumberOfPorts;					// Number of ports attached to card.
	ULONG			NumPDOs;						// The PDOs currently enumerated.
	ULONG			CardType;						// Defines the type of host card.

	PDEVICE_OBJECT  AttachedPDO[PRODUCT_MAX_PORTS];	// Array of pointers to PDOs for ports attached to card.

} COMMON_CARD_DEVICE_EXTENSION, *PCOMMON_CARD_DEVICE_EXTENSION;



typedef struct _PORT_PERFORMANCE_STATS
{
    SERIALPERF_STATS;

	// IRPs with a Major Function of IRP_MJ_WRITE
	ULONG WriteIrpsSubmitted;
	ULONG WriteIrpsCompleted;
	ULONG WriteIrpsCancelled;
	ULONG WriteIrpsTimedOut;
	ULONG WriteIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_READ
	ULONG ReadIrpsSubmitted;
	ULONG ReadIrpsCompleted;
	ULONG ReadIrpsCancelled;
	ULONG ReadIrpsTimedOut;
	ULONG ReadIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_FLUSH_BUFFERS
	ULONG FlushIrpsSubmitted;
	ULONG FlushIrpsCompleted;
	ULONG FlushIrpsCancelled;
	ULONG FlushIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_DEVICE_CONTROL
	ULONG IoctlIrpsSubmitted;
	ULONG IoctlIrpsCompleted;
	ULONG IoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_INTERNAL_DEVICE_CONTROL
	ULONG InternalIoctlIrpsSubmitted;
	ULONG InternalIoctlIrpsCompleted;
	ULONG InternalIoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CREATE
	ULONG CreateIrpsSubmitted;
	ULONG CreateIrpsCompleted;
	ULONG CreateIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLOSE
	ULONG CloseIrpsSubmitted;
	ULONG CloseIrpsCompleted;
	ULONG CloseIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLEANUP
	ULONG CleanUpIrpsSubmitted;
	ULONG CleanUpIrpsCompleted;
	ULONG CleanUpIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION 
	ULONG InfoIrpsSubmitted;
	ULONG InfoIrpsCompleted;
	ULONG InfoIrpsCancelled;

} PORT_PERFORMANCE_STATS, *PPORT_PERFORMANCE_STATS;

//////////////////////////////////////////////////////////////////////////////////////////
// Common Port Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_PORT_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	PDEVICE_OBJECT		ParentFDO;					// A back pointer to the bus FDO  (this will be the LowerDeviceObject) 
	PCARD_DEV_EXT		pParentCardExt;				// Pointer to parent card device structure
	UNICODE_STRING		DeviceName;					// Device name eg. "\Device\PortName#".
	UNICODE_STRING		DeviceClassSymbolicName;	// Device Interface Name
	UNICODE_STRING		SerialCommEntry;			// Device name in SERIALCOMM Reg key eg. "PortName#".
	ULONG				PortNumber;					// Port number.
	UNICODE_STRING		DeviceID;					// Format: bus\device (must be most specific HardwareID)
	UNICODE_STRING		InstanceID;					// Instance ID 
	BOOLEAN				UniqueInstanceID;			// TRUE if InstanceID is gloablly unique, FALSE otherwise.
    UNICODE_STRING		HardwareIDs;				// Format bus\device or *PNPXXXX - meaning root enumerated
    UNICODE_STRING		CompatibleIDs;				// Compatible IDs to the Hardware ID
    UNICODE_STRING		DevDesc;					// Text describing device
    UNICODE_STRING		DevLocation;				// Text describing device location
	UNICODE_STRING		DosName;					// Dos device name "COM#" 
	UNICODE_STRING		SymbolicLinkName;			// External Device Name eg."\DosDevices\COM#".
	BOOLEAN				CreatedSymbolicLink;		// Flag to indicate that a symbolic link has been created.
	BOOLEAN				CreatedSerialCommEntry;		// Flag to indicate that a reg entry has been created in "SERIALCOMM"
	BOOLEAN				DeviceIsOpen;				// Flag to indicate when the port is open	
	ULONG				SavedModemControl;			// DTR/RTS signal states saved during power down
    FAST_MUTEX			OpenMutex;					// Mutex on open status

	    
#ifdef WMI_SUPPORT
	SERIAL_WMI_COMM_DATA	WmiCommData;			// WMI Comm Data
    SERIAL_WMI_HW_DATA		WmiHwData;				// WMI HW Data
	SERIAL_WMI_PERF_DATA	WmiPerfData;			// WMI Performance Data
#endif

    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
	PORT_PERFORMANCE_STATS PerfStats;

} COMMON_PORT_DEVICE_EXTENSION, *PCOMMON_PORT_DEVICE_EXTENSION;


#endif	// End of SPX_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\mps\sx\incl\spx_misc.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_MISC.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	All Macros and function prototypes for the common PnP and power code.	*
*																						*
****************************************************************************************/

#if	!defined(SPX_MISC_H)
#define SPX_MISC_H	


// Prototypes for common PnP code.
NTSTATUS
Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPDO);

NTSTATUS
Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP	pIrp);

NTSTATUS 
Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp, IN PVOID Context);

NTSTATUS 
Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp);

NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...);

NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	);

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	);

VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp);

VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	);

ULONG	SpxGetNtCardType(PDEVICE_OBJECT pNtDevObj);
NTSTATUS Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort);

SPX_MEM_COMPARES Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB);

NTSTATUS PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard);

VOID SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set);
VOID SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set);

BOOLEAN 
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll);


PVOID SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);
PVOID SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);

#ifndef BUILD_SPXMINIPORT
void SpxFreeMem(PVOID pMem);
#endif
						   
VOID SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition);
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort);


// Filtered dispatch entry points... 
NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 
NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);	// SPX_DISP.C 
NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort);							// SPX_DISP.C 
VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj);							// SPX_DISP.C 


// End of prototypes for common PnP code.


#ifdef WMI_SUPPORT

NTSTATUS Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);

#define UPDATE_WMI_LINE_CONTROL(WmiCommData, LineControl)						\
do																				\
{																				\
																				\
	WmiCommData.BitsPerByte			= (LineControl & SERIAL_DATA_MASK) + 5;		\
	WmiCommData.ParityCheckEnable	= (LineControl & 0x08) ? TRUE : FALSE;		\
																				\
	switch(LineControl & SERIAL_PARITY_MASK)									\
	{																			\
	case SERIAL_ODD_PARITY:														\
		WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;								\
		break;																	\
																				\
	case SERIAL_EVEN_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;							\
		break;																	\
																				\
	case SERIAL_MARK_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;							\
		break;																	\
																				\
	case SERIAL_SPACE_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;							\
		break;																	\
																				\
	case SERIAL_NONE_PARITY:													\
	default:																	\
		WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;							\
		break;																	\
	}																			\
																				\
																				\
	if(LineControl & SERIAL_STOP_MASK)											\
	{																			\
		if((LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA)					\
			WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;							\
		else																	\
			WmiCommData.StopBits = SERIAL_WMI_STOP_2;							\
	}																			\
	else																		\
		WmiCommData.StopBits = SERIAL_WMI_STOP_1;								\
																				\
} while (0)


#define UPDATE_WMI_XON_XOFF_CHARS(WmiCommData, SpecialChars)					\
do																				\
{																				\
	WmiCommData.XoffCharacter	= SpecialChars.XoffChar;						\
	WmiCommData.XonCharacter	= SpecialChars.XonChar;							\
																				\
} while (0)


#define UPDATE_WMI_XMIT_THRESHOLDS(WmiCommData, HandFlow)						\
do																				\
{																				\
	WmiCommData.XoffXmitThreshold	= HandFlow.XoffLimit;						\
	WmiCommData.XonXmitThreshold	= HandFlow.XonLimit;						\
																				\
} while (0)

#endif



// Macros 

// Debug Messages
#if DBG
#define SPX_TRACE_CALLS			((ULONG)0x00000001)
#define SPX_TRACE_PNP_IRPS		((ULONG)0x00000002)
#define SPX_ERRORS				((ULONG)0x00000004)
#define SPX_MISC_DBG			((ULONG)0x00000008)
#define SPX_TRACE_POWER_IRPS	((ULONG)0x00000010)
#define	SPX_TRACE_IRP_PATH		((ULONG)0x00000020)
#define	SPX_TRACE_FILTER_IRPS	((ULONG)0x00000040)
//#define SERFLOW				((ULONG)0x00000080)
//#define SERERRORS				((ULONG)0x00000100)
//#define SERBUGCHECK			((ULONG)0x00000200)

extern ULONG SpxDebugLevel;		// Global Debug Level 

#define SpxDbgMsg(LEVEL, STRING)			\
        do{									\
            if(SpxDebugLevel & (LEVEL))		\
			{								\
                DbgPrint STRING;			\
            }								\
            if((LEVEL) == SERBUGCHECK)		\
			{								\
                ASSERT(FALSE);				\
            }								\
        }while (0)
#else
#define SpxDbgMsg(LEVEL, STRING) do {NOTHING;} while (0)
#endif




#define	SetPnpPowerFlags(pDevExt,Value)		\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), TRUE);		

#define	ClearPnpPowerFlags(pDevExt,Value)	\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), FALSE);	

#define SPX_SUCCESS(Status) ((NTSTATUS)(Status) == 0)

#define	SetUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), TRUE);		

#define	ClearUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), FALSE);	

// End of macros.

#endif	// End of SPX_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\isr.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    isr.c

Abstract:

    This module contains the interrupt service routine for the
    serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"




BOOLEAN
SerialISR(IN PKINTERRUPT InterruptObject, IN PVOID Context)
{
    // Holds the information specific to handling this device.
    PCARD_DEVICE_EXTENSION	pCard = Context;
    PPORT_DEVICE_EXTENSION	pPort; 
    BOOLEAN					ServicedAnInterrupt = FALSE;

	PUART_OBJECT pUart = pCard->pFirstUart;
	DWORD IntsPending = 0;
	
	UNREFERENCED_PARAMETER(InterruptObject);

#ifndef	BUILD_SPXMINIPORT
	// If the card is not powered, delay interrupt service until it is.
	if(!(pCard->PnpPowerFlags & PPF_POWERED) && (pCard->PnpPowerFlags & PPF_STARTED))
		return ServicedAnInterrupt;	// Most likely the interrupt is not ours anyway.
#endif


	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast4_Pci:
	case RAS4_Pci:
		{
			if((READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_0_TO_7_INTS_REG) & FAST_UARTS_0_TO_3_INT_PENDING) == 0)	
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

	case Fast8_Isa:
	case Fast8_Pci:
	case RAS8_Pci:
		{
			if(READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_0_TO_7_INTS_REG) == 0)	
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

	case Fast16_Isa:
	case Fast16_Pci:
	case Fast16FMC_Pci:
		{
			if((READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_0_TO_7_INTS_REG) == 0) 
			&& (READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_9_TO_16_INTS_REG) == 0))	
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

		break;

	case Speed2_Pci:
	case Speed2P_Pci:
	case Speed4_Pci:
	case Speed4P_Pci:
		{
			if((READ_REGISTER_ULONG( (PULONG)(pCard->LocalConfigRegisters + SPEED_GIS_REG)) & INTERNAL_UART_INT_PENDING) == 0)
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

	case Speed2and4_Pci_8BitBus:
	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		return ServicedAnInterrupt;	// No UARTs therefore NO interrupts that are ours - we hope.
		break;

	default:
		break;
	}




	if(pUart)
	{
		while((IntsPending = pCard->UartLib.UL_IntsPending_XXXX(&pUart)))
		{
			pPort = (PPORT_DEVICE_EXTENSION) pCard->UartLib.UL_GetAppBackPtr_XXXX(pUart);	// Get Port Extension for UART.

			SpxDbgMsg(ISRINFO, ("%s: Int on 0x%lX", PRODUCT_NAME, IntsPending));

			// Service receive status interrupts
			if(IntsPending & UL_IP_RX_STAT)
			{	
				BYTE LineStatus = 0;
				DWORD RxStatus;
				pPort->pUartLib->UL_GetStatus_XXXX(pUart, &RxStatus, UL_GS_OP_LINESTATUS);
				
				// If OVERRUN/PARITY/FRAMING/DATA/BREAK error
				if(RxStatus & (UL_US_OVERRUN_ERROR | UL_US_PARITY_ERROR | UL_US_FRAMING_ERROR | UL_US_DATA_ERROR | UL_US_BREAK_ERROR))
				{
					BYTE TmpByte;

					// If the application has requested it, abort all the reads and writes on an error.
					if(pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT)
						KeInsertQueueDpc(&pPort->CommErrorDpc, NULL, NULL);
/*
					if(pPort->EscapeChar) 
					{
						TmpByte = pPort->EscapeChar;
						pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);

						
						if(RxStatus & UL_US_DATA_ERROR)
						{
							TmpByte = SERIAL_LSRMST_LSR_DATA
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
						}
						else
						{
							TmpByte = SERIAL_LSRMST_LSR_NODATA
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
						}
					}

*/
					if(RxStatus & UL_US_OVERRUN_ERROR) 
					{
						pPort->ErrorWord |= SERIAL_ERROR_OVERRUN;
						LineStatus |= SERIAL_LSR_OE; 
						pPort->PerfStats.SerialOverrunErrorCount++;
#ifdef WMI_SUPPORT 
						pPort->WmiPerfData.SerialOverrunErrorCount++;
#endif
					}

					if(RxStatus & UL_US_PARITY_ERROR) 
					{
						pPort->ErrorWord |= SERIAL_ERROR_PARITY;
						LineStatus |= SERIAL_LSR_PE; 
						pPort->PerfStats.ParityErrorCount++;
#ifdef WMI_SUPPORT 
						pPort->WmiPerfData.ParityErrorCount++;
#endif
					}

					if(RxStatus & UL_US_FRAMING_ERROR) 
					{
						pPort->ErrorWord |= SERIAL_ERROR_FRAMING;
						LineStatus |= SERIAL_LSR_FE; 
						pPort->PerfStats.FrameErrorCount++;
#ifdef WMI_SUPPORT 
						pPort->WmiPerfData.FrameErrorCount++;
#endif
					}

					if(RxStatus & UL_US_DATA_ERROR) 
					{
						LineStatus |= SERIAL_LSR_DR; 
					}


					if(RxStatus & UL_US_BREAK_ERROR)
					{
						pPort->ErrorWord |= SERIAL_ERROR_BREAK;
						LineStatus |= SERIAL_LSR_BI;
					}

/*
					if(pPort->EscapeChar)
					{
							TmpByte = LineStatus;
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
					}

					if(RxStatus & (UL_US_OVERRUN_ERROR | UL_US_PARITY_ERROR | UL_US_FRAMING_ERROR | UL_US_DATA_ERROR))
					{
						if(pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
						{
							TmpByte = pPort->SpecialChars.ErrorChar;
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
						}
					}
*/
				}

		        if(pPort->IsrWaitMask) 
				{
					if((pPort->IsrWaitMask & SERIAL_EV_ERR) 
						&& (RxStatus & (UL_US_OVERRUN_ERROR | UL_US_PARITY_ERROR | UL_US_FRAMING_ERROR | UL_US_DATA_ERROR)))
					{
						// if we detected a overrun/parity/framing/data error
						pPort->HistoryMask |= SERIAL_EV_ERR;
					}

					// if we detected a break error
					if((pPort->IsrWaitMask & SERIAL_EV_BREAK) && (RxStatus & UL_US_BREAK_ERROR)) 
						pPort->HistoryMask |= SERIAL_EV_BREAK;
#ifdef USE_HW_TO_DETECT_CHAR
					// if we detected the special char
					if((pPort->IsrWaitMask & SERIAL_EV_RXFLAG) && (RxStatus & UL_RS_SPECIAL_CHAR_DETECTED)) 
						pPort->HistoryMask |= SERIAL_EV_RXFLAG;
#endif
					if(pPort->IrpMaskLocation && pPort->HistoryMask)
					{
						*pPort->IrpMaskLocation = pPort->HistoryMask;
                
						pPort->IrpMaskLocation = NULL;
						pPort->HistoryMask = 0;

						pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
						
						// Mark IRP as about to complete normally to prevent cancel & timer DPCs
						// from doing so before DPC is allowed to run.
						//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
							
						KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
					}
				}
			}


			// Service receive and receive timeout interrupts.
			if((IntsPending & UL_IP_RX) || (IntsPending & UL_IP_RXTO))
			{
				DWORD StatusFlags = 0;
				int BytesReceived = pPort->pUartLib->UL_InputData_XXXX(pUart, &StatusFlags);

			
				if(StatusFlags & UL_RS_BUFFER_OVERRUN)
				{
					// We have a new character but no room for it.
					pPort->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
					pPort->PerfStats.BufferOverrunErrorCount++;
#ifdef WMI_SUPPORT 
					pPort->WmiPerfData.BufferOverrunErrorCount++;
#endif
				}

				if(BytesReceived) 
				{
					ULONG AmountInBuffer = 0;
					GET_BUFFER_STATE BufferState;

					pPort->ReadByIsr += BytesReceived;
					pPort->PerfStats.ReceivedCount += BytesReceived;	// Increment Rx Counter
#ifdef WMI_SUPPORT 
					pPort->WmiPerfData.ReceivedCount += BytesReceived;
#endif

					pPort->pUartLib->UL_BufferControl_XXXX(pUart, &BufferState, UL_BC_OP_GET, UL_BC_BUFFER | UL_BC_IN);
					AmountInBuffer = BufferState.BytesInINBuffer; 


					if(pPort->IsrWaitMask) 
					{
						// Check to see if we should note the receive character
						if(pPort->IsrWaitMask & SERIAL_EV_RXCHAR)
							pPort->HistoryMask |= SERIAL_EV_RXCHAR;

						// If we've become 80% full on this character and this is an interesting event, note it.
						if((pPort->IsrWaitMask & SERIAL_EV_RX80FULL) && (AmountInBuffer >= pPort->BufferSizePt8)) 
							pPort->HistoryMask |= SERIAL_EV_RX80FULL;

#ifndef USE_HW_TO_DETECT_CHAR
						// if we detected the special char
						if((pPort->IsrWaitMask & SERIAL_EV_RXFLAG) && (StatusFlags & UL_RS_SPECIAL_CHAR_DETECTED)) 
							pPort->HistoryMask |= SERIAL_EV_RXFLAG;
#endif
						if(pPort->IrpMaskLocation && pPort->HistoryMask)
						{
							*pPort->IrpMaskLocation = pPort->HistoryMask;
            
							pPort->IrpMaskLocation = NULL;
							pPort->HistoryMask = 0;

							pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
               
							// Mark IRP as about to complete normally to prevent cancel & timer DPCs
							// from doing so before DPC is allowed to run.
							//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);

							KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
						}
					}


					// If we have a current Read IRP. 
					if(pPort->CurrentReadIrp && pPort->NumberNeededForRead)
					{
						// If our ISR currently owns the IRP the we are allowed to do something with it,
						// But we only need to do something if we need to make room in the buffer
						// or we have enough bytes in the buffer to complete the current read IRP.
						if((SERIAL_REFERENCE_COUNT(pPort->CurrentReadIrp) & SERIAL_REF_ISR) 
							&& ((AmountInBuffer >= pPort->BufferSizePt8) 
							|| (AmountInBuffer >= pPort->NumberNeededForRead)))
						{
							int NumberOfBytes = 0;

							NumberOfBytes = pPort->pUartLib->UL_ReadData_XXXX(pPort->pUart, 
									(PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer) 
									+ IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length 
									- pPort->NumberNeededForRead, 
									pPort->NumberNeededForRead);

							pPort->NumberNeededForRead -= NumberOfBytes;

							pPort->CurrentReadIrp->IoStatus.Information += NumberOfBytes;

							if(pPort->NumberNeededForRead == 0)
							{
								ASSERT(pPort->CurrentReadIrp->IoStatus.Information 
									== IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length);
							
								// Mark IRP as about to complete normally to prevent cancel & timer DPCs
								// from doing so before DPC is allowed to run.
								SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_COMPLETING);

								KeInsertQueueDpc(&pPort->CompleteReadDpc, NULL, NULL);
							}
						}
					}

				}

			}

			// Service transmitt and transmitt empty interrupts.
			if((IntsPending & UL_IP_TX) || (IntsPending & UL_IP_TX_EMPTY))
			{
				// No need to clear the INT it was already cleared by reading the IIR.
				DWORD BytesRemaining = pPort->pUartLib->UL_OutputData_XXXX(pUart);	// Output some bytes


				// If we have a current Write Immediate IRP. 
				if(pPort->CurrentImmediateIrp)
				{
					if(SERIAL_REFERENCE_COUNT(pPort->CurrentImmediateIrp) & SERIAL_REF_ISR)
					{
						if(pPort->TransmitImmediate == TRUE)
						{
							// Check if the byte has been sent.
							if(pPort->pUartLib->UL_ImmediateByte_XXXX(pUart, &pPort->ImmediateIndex, UL_IM_OP_STATUS) == UL_IM_NO_BYTE_TO_SEND)
							{
								pPort->TransmitImmediate = FALSE;
								pPort->EmptiedTransmit = TRUE;

								pPort->PerfStats.TransmittedCount++;	// Increment Tx Counter
#ifdef WMI_SUPPORT 
								pPort->WmiPerfData.TransmittedCount++;
#endif

								// Mark IRP as about to complete normally to prevent cancel & timer DPCs
								// from doing so before DPC is allowed to run.
								SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_COMPLETING);

								// Ask to complete the IRP.
								KeInsertQueueDpc(&pPort->CompleteImmediateDpc, NULL, NULL);
							}
						}
					}
				}



				// If we have a current Write IRP. 
				if(pPort->CurrentWriteIrp && pPort->WriteLength)
				{
					//
                    // Even though all of the characters being
                    // sent haven't all been sent, this variable
                    // will be checked when the transmit queue is
                    // empty.  If it is still true and there is a
                    // wait on the transmit queue being empty then
                    // we know we finished transmitting all characters
                    // following the initiation of the wait since
                    // the code that initiates the wait will set
                    // this variable to false.
                    //
                    // One reason it could be false is that
                    // the writes were cancelled before they
                    // actually started, or that the writes
                    // failed due to timeouts.  This variable
                    // basically says a character was written
                    // by the isr at some point following the
                    // initiation of the wait.
                    //

					if(SERIAL_REFERENCE_COUNT(pPort->CurrentWriteIrp) & SERIAL_REF_ISR)
					{
						if(pPort->WriteLength > BytesRemaining)
						{
							pPort->PerfStats.TransmittedCount += (pPort->WriteLength - BytesRemaining);	// Increment Tx Counter
#ifdef WMI_SUPPORT 
							pPort->WmiPerfData.TransmittedCount  += (pPort->WriteLength - BytesRemaining);
#endif	
						}
						else
						{
							pPort->PerfStats.TransmittedCount += pPort->WriteLength;	// Increment Tx Counter
#ifdef WMI_SUPPORT 
							pPort->WmiPerfData.TransmittedCount += pPort->WriteLength;
#endif	
						}

						pPort->WriteLength = BytesRemaining;
						pPort->EmptiedTransmit = TRUE;


						if(pPort->WriteLength == 0)		// If write is complete - lets complete the IRP
						{
							PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
					
							// No More characters left. This write is complete. Take care when 
							// updating the information field, we could have an xoff
							// counter masquerading as a write irp.
									
							pPort->CurrentWriteIrp->IoStatus.Information 
								= (IrpSp->MajorFunction == IRP_MJ_WRITE) 
								? (IrpSp->Parameters.Write.Length) : (1);

							// Mark IRP as about to complete normally to prevent cancel & timer DPCs
							// from doing so before DPC is allowed to run.
							SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_COMPLETING);

							KeInsertQueueDpc(&pPort->CompleteWriteDpc, NULL, NULL);
						}
					}
				}
			}


			// Service modem interrupts.
			if(IntsPending & UL_IP_MODEM)
			{
				SerialHandleModemUpdate(pPort, FALSE);
			}


			// Save a pointer to the UART serviced so it can be the first UART serviced 
			// in the list the next time the ISR is called.  
			//pCard->pFirstUart = pUart;

			ServicedAnInterrupt = TRUE;
		}
		
	}


	return ServicedAnInterrupt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\flush.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module contains the code that is very specific to flush
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
NTSTATUS SerialStartFlush(IN PPORT_DEVICE_EXTENSION pPort);
// End of prototypes    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
    Irp->IoStatus.Information = 0L;

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    return SerialStartOrQueue(pPort, Irp, &pPort->WriteQueue, &pPort->CurrentWriteIrp, SerialStartFlush);
}



NTSTATUS
SerialStartFlush(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This will always return STATUS_SUCCESS.

-----------------------------------------------------------------------------*/
{
    PIRP NewIrp;

    pPort->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    // The following call will actually complete the flush.
    SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);
        
    if(NewIrp) 
	{
        ASSERT(NewIrp == pPort->CurrentWriteIrp);
        SerialStartWrite(pPort);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\modmflow.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    modmflow.c

Abstract:

    This module contains *MOST* of the code used to manipulate
    the modem control and status registers.  The vast majority
    of the remainder of flow control is concentrated in the
    Interrupt service routine.  A very small amount resides
    in the read code that pull characters out of the interrupt
    buffer.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
BOOLEAN SerialDecrementRTSCounter(IN PVOID Context);
// End of prototypes.    
    

#ifdef ALLOC_PRAGMA
#endif


BOOLEAN
SerialSetDTR(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_DTR;

    SpxDbgMsg(SERFLOW, ("%s: Setting DTR for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_SET);
	pPort->DTR_Set = TRUE;

    return FALSE;
}



BOOLEAN
SerialClrDTR(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_DTR;

    SpxDbgMsg(SERFLOW, ("%s: Clearing DTR for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_CLEAR);
	pPort->DTR_Set = FALSE;

    return FALSE;
}



BOOLEAN
SerialSetRTS(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_RTS;

    SpxDbgMsg(SERFLOW, ("%s: Setting RTS for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_SET);
	pPort->RTS_Set = TRUE;

    return FALSE;
}



BOOLEAN
SerialClrRTS(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_RTS;

    SpxDbgMsg(SERFLOW, ("%s: Clearing RTS for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_CLEAR);
	pPort->RTS_Set = FALSE;

    return FALSE;
}



BOOLEAN
SerialSetupNewHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_HANDFLOW NewHandFlow)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine adjusts the flow control based on new control flow.

Arguments:

    Extension - A pointer to the serial device extension.

    NewHandFlow - A pointer to a serial handflow structure
                  that is to become the new setup for flow
                  control.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{

    SERIAL_HANDFLOW New = *NewHandFlow;

    // If the Extension->DeviceIsOpen is FALSE that means
    // we are entering this routine in response to an open request.
    // If that is so, then we always proceed with the work regardless
    // of whether things have changed.


	if((!pPort->DeviceIsOpen) 
		|| (pPort->HandFlow.ControlHandShake != New.ControlHandShake) 
		|| (pPort->HandFlow.FlowReplace != New.FlowReplace))
	{
		
		// First we take care of the DTR flow control.  We only do work if something has changed.
        SerialDump(SERFLOW, ("Processing DTR flow for %x\n", pPort->Controller));

		switch(New.ControlHandShake & SERIAL_DTR_MASK)
		{
		case SERIAL_DTR_HANDSHAKE:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DTR_FLOW_MASK) | UC_FLWC_DTR_HS;
			break;

		case SERIAL_DTR_CONTROL:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DTR_FLOW_MASK) | UC_FLWC_NO_DTR_FLOW;
			SerialSetDTR(pPort);
			break;

		default:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DTR_FLOW_MASK) | UC_FLWC_NO_DTR_FLOW;
			SerialClrDTR(pPort);
			break;
		}


		// Time to take care of the RTS Flow control.
        SerialDump(SERFLOW,("Processing RTS flow for %x\n", pPort->Controller));
	
		switch(New.FlowReplace & SERIAL_RTS_MASK)
		{
		case SERIAL_RTS_HANDSHAKE:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_RTS_HS;
			break;

		case SERIAL_RTS_CONTROL:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_NO_RTS_FLOW;
			SerialSetRTS(pPort);
			break;

		case SERIAL_TRANSMIT_TOGGLE:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_RTS_TOGGLE;
			break;

		default:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_NO_RTS_FLOW;
			SerialClrRTS(pPort);
			break;
		}



		if(New.ControlHandShake & SERIAL_CTS_HANDSHAKE) 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_CTS_FLOW_MASK) | UC_FLWC_CTS_HS;
		else
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_CTS_FLOW_MASK) | UC_FLWC_NO_CTS_FLOW;
		
		if(New.ControlHandShake & SERIAL_DSR_HANDSHAKE)
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DSR_FLOW_MASK) | UC_FLWC_DSR_HS;
		else
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DSR_FLOW_MASK) | UC_FLWC_NO_DSR_FLOW;

	    //if(New.ControlHandShake & SERIAL_DCD_HANDSHAKE)

		if(New.FlowReplace & SERIAL_NULL_STRIPPING)
			pPort->UartConfig.SpecialMode |= UC_SM_DO_NULL_STRIPPING;
		else
			pPort->UartConfig.SpecialMode &= ~UC_SM_DO_NULL_STRIPPING;


		//
		// We now take care of automatic receive flow control.
		//

        if(New.FlowReplace & SERIAL_AUTO_RECEIVE) 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RX_XON_XOFF_FLOW_MASK) | UC_FLWC_RX_XON_XOFF_FLOW;
		else 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RX_XON_XOFF_FLOW_MASK) | UC_FLWC_RX_NO_XON_XOFF_FLOW;

		//
		// We now take care of automatic transmit flow control.
		//

        if(New.FlowReplace & SERIAL_AUTO_TRANSMIT) 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_TX_XON_XOFF_FLOW_MASK) | UC_FLWC_TX_XON_XOFF_FLOW;
		else 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_TX_XON_XOFF_FLOW_MASK) | UC_FLWC_TX_NO_XON_XOFF_FLOW;


		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FLOW_CTRL_MASK | UC_SPECIAL_MODE_MASK);


	}



    //
    // At this point we can simply make sure that entire
    // handflow structure in the extension is updated.
    //

    pPort->HandFlow = New;

    return FALSE;

}

BOOLEAN
SerialSetHandFlow(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the handshake and control
    flow in the device extension.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a handflow
              structure..

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PSERIAL_IOCTL_SYNC S = Context;
    PPORT_DEVICE_EXTENSION pPort = S->pPort;
    PSERIAL_HANDFLOW HandFlow = S->Data;

    SerialSetupNewHandFlow(pPort, HandFlow);

    SerialHandleModemUpdate(pPort, FALSE);

    return FALSE;
}



BOOLEAN
SerialTurnOnBreak(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will turn on break in the hardware and
    record the fact the break is on, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE)
        SerialSetRTS(pPort);

	// Set break.
	pPort->UartConfig.SpecialMode |= UC_SM_TX_BREAK;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);

    return FALSE;
}



BOOLEAN
SerialTurnOffBreak(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will turn off break in the hardware and
    record the fact the break is off, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	// Clear break.
	pPort->UartConfig.SpecialMode &= ~UC_SM_TX_BREAK;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);

    return FALSE;
}



BOOLEAN
SerialPretendXoff(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xoff was received.  Even if the
    driver does not have automatic Xoff/Xon flowcontrol - This
    will still stop the transmission.  This is the OS/2 behavior
    and is not well specified for Windows.  Therefore we adopt
    the OS/2 behavior.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TXHolding |= SERIAL_TX_XOFF;

    if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE) 
	{
        KeInsertQueueDpc(&pPort->StartTimerLowerRTSDpc, NULL, NULL) ? pPort->CountOfTryingToLowerRTS++ : 0;
    }

    return FALSE;
}



BOOLEAN
SerialPretendXon(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xon was received.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->TXHolding) 
	{
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.

        pPort->TXHolding &= ~SERIAL_TX_XOFF;

    }

    return FALSE;
}



VOID
SerialHandleReducedIntBuffer(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is called to handle a reduction in the number
    of characters in the interrupt (typeahead) buffer.  It
    will check the current output flow control and re-enable transmission
    as needed.

    NOTE: This routine assumes that it is working at interrupt level.

Arguments:

    Extension - A pointer to the device extension.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{


    //
    // If we are doing receive side flow control and we are
    // currently "holding" then because we've emptied out
    // some characters from the interrupt buffer we need to
    // see if we can "re-enable" reception.
    //

    if(pPort->RXHolding) 
	{
        if(pPort->CharsInInterruptBuffer <= (ULONG)pPort->HandFlow.XonLimit)
		{
            if(pPort->RXHolding & SERIAL_RX_DTR) 
			{
                pPort->RXHolding &= ~SERIAL_RX_DTR;
                SerialSetDTR(pPort);
            }

            if(pPort->RXHolding & SERIAL_RX_RTS) 
			{
                pPort->RXHolding &= ~SERIAL_RX_RTS;
                SerialSetRTS(pPort);
            }

            if(pPort->RXHolding & SERIAL_RX_XOFF) 
			{
                // Prod the transmit code to send xon.
                SerialProdXonXoff(pPort, TRUE);
            }

        }

    }

}



VOID
SerialProdXonXoff(IN PPORT_DEVICE_EXTENSION pPort, IN BOOLEAN SendXon)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will set up the SendXxxxChar variables if
    necessary and determine if we are going to be interrupting
    because of current transmission state.  It will cause an
    interrupt to occur if neccessary, to send the xon/xoff char.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Extension - A pointer to the serial device extension.

    SendXon - If a character is to be send, this indicates whether
              it should be an Xon or an Xoff.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    //
    // We assume that if the prodding is called more than
    // once that the last prod has set things up appropriately.
    //
    // We could get called before the character is sent out
    // because the send of the character was blocked because
    // of hardware flow control (or break).
    //


    if(SendXon) 
	{
        pPort->SendXonChar = TRUE;
        pPort->SendXoffChar = FALSE;
    } 
	else 
	{
        pPort->SendXonChar = FALSE;
		pPort->SendXoffChar = TRUE;
    }

}



ULONG
SerialHandleModemUpdate(IN PPORT_DEVICE_EXTENSION pPort, IN BOOLEAN DoingTX)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will be to check on the modem status, and
    handle any appropriate event notification as well as
    any flow control appropriate to modem status lines.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Extension - A pointer to the serial device extension.

    DoingTX - This boolean is used to indicate that this call
              came from the transmit processing code.  If this
              is true then there is no need to cause a new interrupt
              since the code will be trying to send the next
              character as soon as this call finishes.

Return Value:

    This returns the old value of the modem status register
    (extended into a ULONG).

-----------------------------------------------------------------------------*/
{
    // We keep this local so that after we are done
    // examining the modem status and we've updated
    // the transmission holding value, we know whether
    // we've changed from needing to hold up transmission
    // to transmission being able to proceed.

    ULONG OldTXHolding = pPort->TXHolding;

    // Holds the value in the mode status register.
    UCHAR ModemStatus = 0;
	DWORD ModemSignals = 0;

	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_STATUS);


	// Put data in 16x5x format.
	if(ModemSignals & UL_MC_DELTA_CTS)
		ModemStatus |= SERIAL_MSR_DCTS;
	
	if(ModemSignals & UL_MC_DELTA_DSR)
		ModemStatus |= SERIAL_MSR_DDSR;
	
	if(ModemSignals & UL_MC_TRAILING_RI_EDGE)
		ModemStatus |= SERIAL_MSR_TERI;

	if(ModemSignals & UL_MC_DELTA_DCD)
		ModemStatus |= SERIAL_MSR_DDCD;

	if(ModemSignals & UL_MC_CTS)
		ModemStatus |= SERIAL_MSR_CTS;
	
	if(ModemSignals & UL_MC_DSR)
		ModemStatus |= SERIAL_MSR_DSR;
	
	if(ModemSignals & UL_MC_RI)
		ModemStatus |= SERIAL_MSR_RI;

	if(ModemSignals & UL_MC_DCD)
		ModemStatus |= SERIAL_MSR_DCD;


    // If we are placing the modem status into the data stream
    // on every change, we should do it now.
    if(pPort->EscapeChar) 
	{
		// If a signal changed...
		if(ModemStatus & (SERIAL_MSR_DCTS | SERIAL_MSR_DDSR | SERIAL_MSR_TERI | SERIAL_MSR_DDCD)) 
		{
			BYTE TmpByte;

			TmpByte = pPort->EscapeChar;
			pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);

			TmpByte = SERIAL_LSRMST_MST;
			pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);

			TmpByte = ModemStatus;
			pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
        }
    }


    // Check to see if we have a wait pending on the modem status events.  If we
    // do then we schedule a dpc to satisfy that wait.

    if(pPort->IsrWaitMask) 
	{
        if((pPort->IsrWaitMask & SERIAL_EV_CTS) && (ModemStatus & SERIAL_MSR_DCTS))
            pPort->HistoryMask |= SERIAL_EV_CTS;

        if((pPort->IsrWaitMask & SERIAL_EV_DSR) && (ModemStatus & SERIAL_MSR_DDSR))
            pPort->HistoryMask |= SERIAL_EV_DSR;

        if((pPort->IsrWaitMask & SERIAL_EV_RING) && (ModemStatus & SERIAL_MSR_TERI)) 
            pPort->HistoryMask |= SERIAL_EV_RING;

        if((pPort->IsrWaitMask & SERIAL_EV_RLSD) && (ModemStatus & SERIAL_MSR_DDCD))
            pPort->HistoryMask |= SERIAL_EV_RLSD;

        if(pPort->IrpMaskLocation && pPort->HistoryMask)
		{
            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

 			// Mark IRP as about to complete normally to prevent cancel & timer DPCs
			// from doing so before DPC is allowed to run.
			//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
           
			KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
        }
    }


    return ((ULONG)ModemStatus);
}



BOOLEAN
SerialPerhapsLowerRTS(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    return FALSE;
}



VOID
SerialStartTimerLowerRTS(IN PKDPC Dpc, 
						 IN PVOID DeferredContext, 
						 IN PVOID SystemContext1, 
						 IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine starts a timer that when it expires will start
    a dpc that will check if it can lower the rts line because
    there are no characters in the hardware.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    LARGE_INTEGER CharTime;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    // Take out the lock to prevent the line control
    // from changing out from under us while we calculate
    // a character time.

    KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

    CharTime = SerialGetCharTime(pPort);

    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

    CharTime.QuadPart = -CharTime.QuadPart;

    if(KeSetTimer(&pPort->LowerRTSTimer, CharTime, &pPort->PerhapsLowerRTSDpc))
	{
        // The timer was already in the timer queue.  This implies
        // that one path of execution that was trying to lower
        // the RTS has "died".  Synchronize with the ISR so that
        // we can lower the count.
        KeSynchronizeExecution(pPort->Interrupt, SerialDecrementRTSCounter, pPort);
    }
}



VOID
SerialInvokePerhapsLowerRTS(IN PKDPC Dpc,
							IN PVOID DeferredContext, 
							IN PVOID SystemContext1,
							IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This dpc routine exists solely to call the code that
    tests if the rts line should be lowered when TRANSMIT
    TOGGLE flow control is being used.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    KeSynchronizeExecution(pPort->Interrupt, SerialPerhapsLowerRTS, pPort);
}



BOOLEAN
SerialDecrementRTSCounter(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    
	pPort->CountOfTryingToLowerRTS--;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\makefile.inc ===
#
# generate auxilary files from the binary mof (bmf) file
#
# speedwmi.h has definitions for the guids, data structures and definitions
#                of the method ids.
#
# speedwmi.vbs is a ready to run vbscript applet that will query all classes
#            in the mof. Once you install your driver, run the script
#            at the command line by typing: filter.vbs.

$(O)\speedwmi.vbs $(O)\speedwmi.h $(O)\speedwmi.hex: speedwmi.bmf
    wmimofck -h$(O)\speedwmi.h -x$(O)\speedwmi.hex -t$(O)\speedwmi.vbs -w$(O)\speedwmi.htm speedwmi.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\immediat.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    immediat.c

Abstract:

    This module contains the code that is very specific to transmit
    immediate character operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
VOID SerialGetNextImmediate(IN PPORT_DEVICE_EXTENSION pPort,
							IN PIRP *CurrentOpIrp, 
							IN PLIST_ENTRY QueueToProcess, 
							IN PIRP *NewIrp, 
							IN BOOLEAN CompleteCurrent);

VOID SerialCancelImmediate(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
BOOLEAN SerialGiveImmediateToIsr(IN PVOID Context);
BOOLEAN SerialGrabImmediateFromIsr(IN PVOID Context);
BOOLEAN SerialGiveImmediateToIsr(IN PVOID Context);
BOOLEAN SerialGrabImmediateFromIsr(IN PVOID Context);
// End of prototypes

// Paging
#ifdef ALLOC_PRAGMA
#endif


VOID
SerialStartImmediate(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will calculate the timeouts needed for the
    write.  It will then hand the irp off to the isr.  It
    will need to be careful incase the irp has been canceled.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;


    UseATimer = FALSE;
    pPort->CurrentImmediateIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pPort->CurrentImmediateIrp);

    //
    // Calculate the timeout value needed for the
    // request.  Note that the values stored in the
    // timeout record are in milliseconds.  Note that
    // if the timeout values are zero then we won't start
    // the timer.
    //
    KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
        
    Timeouts = pPort->Timeouts;

    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
        

    if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier)
	{
        UseATimer = TRUE;

        // We have some timer values to calculate.
        TotalTime.QuadPart = (LONGLONG)((ULONG)Timeouts.WriteTotalTimeoutMultiplier);

        TotalTime.QuadPart += Timeouts.WriteTotalTimeoutConstant;

        TotalTime.QuadPart *= -10000;
    }

    //
    // As the irp might be going to the isr, this is a good time
    // to initialize the reference count.
    //

    SERIAL_INIT_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // We need to see if this irp should be canceled.
    //

    IoAcquireCancelSpinLock(&OldIrql);

    if(pPort->CurrentImmediateIrp->Cancel) 
	{
        PIRP OldIrp = pPort->CurrentImmediateIrp;

        pPort->CurrentImmediateIrp = NULL;
        IoReleaseCancelSpinLock(OldIrql);

        OldIrp->IoStatus.Status = STATUS_CANCELLED;
        OldIrp->IoStatus.Information = 0;

        SerialDump(SERIRPPATH,("Complete Irp: %x\n",OldIrp));
		SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(OldIrp, 0);

    } 
	else 
	{
        //
        // We give the irp to to the isr to write out.
        // We set a cancel routine that knows how to
        // grab the current write away from the isr.
        //
        IoSetCancelRoutine(pPort->CurrentImmediateIrp, SerialCancelImmediate);
            

        //
        // Since the cancel routine knows about the irp we increment the reference count.
        //
        SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_CANCEL);
            

        if(UseATimer) 
		{
            KeSetTimer(&pPort->ImmediateTotalTimer, TotalTime, &pPort->TotalImmediateTimeoutDpc);

            // Since the timer knows about the irp we increment the reference count.
            SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_TOTAL_TIMER);
        }

        KeSynchronizeExecution(pPort->Interrupt, SerialGiveImmediateToIsr, pPort);

        IoReleaseCancelSpinLock(OldIrql);
    }

}

VOID
SerialCompleteImmediate(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort, NULL, OldIrql, STATUS_SUCCESS, &pPort->CurrentImmediateIrp,
								NULL, NULL, &pPort->ImmediateTotalTimer, NULL, SerialGetNextImmediate, 
								SERIAL_REF_ISR);
}

VOID
SerialTimeoutImmediate(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(	pPort, SerialGrabImmediateFromIsr, OldIrql, STATUS_TIMEOUT, 
								&pPort->CurrentImmediateIrp, NULL, NULL, &pPort->ImmediateTotalTimer, 
								NULL, SerialGetNextImmediate, SERIAL_REF_TOTAL_TIMER);
}

VOID
SerialGetNextImmediate(IN PPORT_DEVICE_EXTENSION pPort,
					   IN PIRP *CurrentOpIrp, 
					   IN PLIST_ENTRY QueueToProcess, 
					   IN PIRP *NewIrp, 
					   IN BOOLEAN CompleteCurrent)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to complete the current immediate
    irp.  Even though the current immediate will always
    be completed and there is no queue associated with it,
    we use this routine so that we can try to satisfy
    a wait for transmit queue empty event.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.  This should point
                   to CurrentImmediateIrp.

    QueueToProcess - Always NULL.

    NewIrp - Always NULL on exit to this routine.

    CompleteCurrent - Should always be true for this routine.


Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    KIRQL OldIrql;
                                             
    PIRP OldIrp = *CurrentOpIrp;

    UNREFERENCED_PARAMETER(QueueToProcess);
    UNREFERENCED_PARAMETER(CompleteCurrent);
    pPort = CONTAINING_RECORD(CurrentOpIrp, PORT_DEVICE_EXTENSION, CurrentImmediateIrp);

    IoAcquireCancelSpinLock(&OldIrql);

    ASSERT(pPort->TotalCharsQueued >= 1);
    pPort->TotalCharsQueued--;

    *CurrentOpIrp = NULL;
    *NewIrp = NULL;

    KeSynchronizeExecution(pPort->Interrupt, SerialProcessEmptyTransmit, pPort);
        
    IoReleaseCancelSpinLock(OldIrql);

    SerialDump(SERIRPPATH,("SERIAL: Complete Irp: %x\n", OldIrp));
	SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(OldIrp, IO_SERIAL_INCREMENT);
}



VOID
SerialCancelImmediate(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(	pPort, SerialGrabImmediateFromIsr, Irp->CancelIrql, STATUS_CANCELLED,
								&pPort->CurrentImmediateIrp, NULL, NULL, &pPort->ImmediateTotalTimer, 
								NULL, SerialGetNextImmediate, SERIAL_REF_CANCEL);
}


BOOLEAN
SerialGiveImmediateToIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TransmitImmediate = TRUE;

	pPort->ImmediateIndex = *((UCHAR *)(pPort->CurrentImmediateIrp->AssociatedIrp.SystemBuffer));
	
    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_ISR);
        
	pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &pPort->ImmediateIndex, UL_IM_OP_WRITE);
    return FALSE;

}


BOOLEAN
SerialGrabImmediateFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->TransmitImmediate) 
	{
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        SERIAL_CLEAR_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_ISR);

        pPort->TransmitImmediate = FALSE;

		pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &pPort->ImmediateIndex, UL_IM_OP_CANCEL);

		pPort->ImmediateIndex = 0;

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\ioctl.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the ioctl dispatcher as well as a couple
    of routines that are generally just called in response to
    ioctl calls.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

BOOLEAN SerialGetModemUpdate(IN PVOID Context);
BOOLEAN SerialGetCommStatus(IN PVOID Context);
VOID SerialGetProperties(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_COMMPROP Properties);
BOOLEAN SerialSetEscapeChar(IN PVOID Context);

#ifdef ALLOC_PRAGMA
#endif



BOOLEAN
SerialGetStats(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    return the perf stats to the caller.

Arguments:

    Context - Pointer to a the irp.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PPORT_DEVICE_EXTENSION pPort = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

	*sp = *((PSERIALPERF_STATS) &pPort->PerfStats);

    return FALSE;
}



BOOLEAN
SerialClearStats(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    clear the perf stats.


Arguments:

    Context - Pointer to a the extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)Context;

    RtlZeroMemory(&pPort->PerfStats, sizeof(SERIALPERF_STATS));

#ifdef WMI_SUPPORT
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));	
#endif

    return FALSE;
}



BOOLEAN
SerialSetChars(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the special characters for the driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a special characters
              structure.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    
	pPort->SpecialChars = *((PSERIAL_CHARS)(((PSERIAL_IOCTL_SYNC)Context)->Data));

	pPort->UartConfig.XON = pPort->SpecialChars.XonChar;	
	pPort->UartConfig.XOFF = pPort->SpecialChars.XoffChar;
	pPort->UartConfig.SpecialCharDetect = pPort->SpecialChars.EventChar;

	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_CHARS_MASK);

    return FALSE;
}




BOOLEAN
SerialSetBaud(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the buad rate of the device.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and what should be the current
              baud rate.

Return Value:

    This routine returns TRUE if it succeeds otherwise FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	if(pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_TX_BAUD_RATE_MASK) == UL_STATUS_SUCCESS)
	{
		// If baud rate is 300 or less then reduce the Tx FIFO size. 
		if(pPort->UartConfig.TxBaud <= 75)
		{
			pPort->BufferSizes.TxFIFOSize = 16;
			pPort->BufferSizes.TxFIFOTrigLevel = 4;
		}
		else if(pPort->UartConfig.TxBaud <= 300)
		{
			pPort->BufferSizes.TxFIFOSize = 32;
			pPort->BufferSizes.TxFIFOTrigLevel = 8;
		}
		else
		{
			pPort->BufferSizes.TxFIFOSize = pPort->TxFIFOSize;
			pPort->BufferSizes.TxFIFOTrigLevel = (BYTE) pPort->TxFIFOTrigLevel;
		}

		// Set Tx FIFO size.
		pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_OUT);

		return TRUE;
	}

	// It failed so lets revert the config settings back to those currently set.
	pPort->pUartLib->UL_GetConfig_XXXX(pPort->pUart, &pPort->UartConfig);

    return FALSE;
}



BOOLEAN
SerialSetLineControl(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the buad rate of the device.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FRAME_CONFIG_MASK);
	
	return FALSE;
}



BOOLEAN
SerialGetModemUpdate(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is simply used to call the interrupt level routine
    that handles modem status update.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

    *Result = SerialHandleModemUpdate(pPort, FALSE);

    return FALSE;
}



BOOLEAN
SerialGetCommStatus(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is used to get the current state of the serial driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a serial status
              record.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    PSERIAL_STATUS Stat = ((PSERIAL_IOCTL_SYNC)Context)->Data;
	GET_BUFFER_STATE BufferState;
	DWORD HoldingReasons = 0;

    Stat->Errors = pPort->ErrorWord;
    pPort->ErrorWord = 0;


    // BUG BUG We need to do something about eof (binary mode).
	Stat->EofReceived = FALSE;

	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &BufferState, UL_BC_OP_GET, UL_BC_IN | UL_BC_BUFFER);
	Stat->AmountInInQueue = BufferState.BytesInINBuffer; 
    Stat->AmountInOutQueue = pPort->TotalCharsQueued;

    if(pPort->WriteLength) 
	{
        // By definition if we have a writelength, then we have a current write irp.
        ASSERT(pPort->CurrentWriteIrp);
        ASSERT(Stat->AmountInOutQueue >= pPort->WriteLength);
        ASSERT((IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length)
			>= pPort->WriteLength);

        Stat->AmountInOutQueue -= IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length 
			- (pPort->WriteLength);
    }

    Stat->WaitForImmediate = pPort->TransmitImmediate;



    Stat->HoldReasons = 0;
	pPort->pUartLib->UL_GetStatus_XXXX(pPort->pUart, &HoldingReasons, UL_GS_OP_HOLDING_REASONS);

	// Transmit holding reasons
    if(HoldingReasons & UL_TX_WAITING_FOR_CTS) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;

    if(HoldingReasons & UL_TX_WAITING_FOR_DSR) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;

    if(HoldingReasons & UL_TX_WAITING_FOR_DCD) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;

    if(HoldingReasons & UL_TX_WAITING_FOR_XON) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;

    if(HoldingReasons & UL_TX_WAITING_ON_BREAK)
        Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;


	// Receive holding reasons
    if(HoldingReasons & UL_RX_WAITING_FOR_DSR) 
        Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;

    if(HoldingReasons & UL_TX_WAITING_XOFF_SENT)
        Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;

    return FALSE;
}



BOOLEAN
SerialSetEscapeChar(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is used to set the character that will be used to escape
    line status and modem status information when the application
    has set up that line status and modem status should be passed
    back in the data stream.

Arguments:

    Context - Pointer to the irp that is specify the escape character.
              Implicitly - An escape character of 0 means no escaping
              will occur.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = IoGetCurrentIrpStackLocation((PIRP)Context)->DeviceObject->DeviceExtension;

    pPort->EscapeChar = *(PUCHAR)((PIRP)Context)->AssociatedIrp.SystemBuffer;

    return FALSE;
}




NTSTATUS
SerialIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine provides the initial processing for all of the
    Ioctrls for the serial device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/

{
    // The status that gets returned to the caller and
    // set in the Irp.
    NTSTATUS Status;

    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    PIO_STACK_LOCATION IrpSp;

    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    KIRQL OldIrql;

    SerialDump(SERIRPPATH, ("Serial I/O Ctrl Dispatch entry for Irp: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) 
	{

    case IOCTL_SERIAL_SET_BAUD_RATE: 
		{

			ULONG BaudRate;
			// Will hold the value of the appropriate divisor for
			// the requested baud rate.  If the baudrate is invalid
			// (because the device won't support that baud rate) then
			// this value is undefined.
			//
			// Note: in one sense the concept of a valid baud rate
			// is cloudy.  We could allow the user to request any
			// baud rate.  We could then calculate the divisor needed
			// for that baud rate.  As long as the divisor wasn't less
			// than one we would be "ok".  (The percentage difference
			// between the "true" divisor and the "rounded" value given
			// to the hardware might make it unusable, but... )  It would
			// really be up to the user to "Know" whether the baud rate
			// is suitable.  So much for theory, *We* only support a given
			// set of baud rates.
        
			SHORT AppropriateDivisor;

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BAUD_RATE))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			} 
			else 
			{
				BaudRate = ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;
			}

			// Get the baud rate from the irp.  We pass it
			// to a routine which will set the correct divisor.

			pPort->UartConfig.TxBaud = BaudRate;
			
			SpxDbgMsg(BAUDINFO,("%s: Requested Baud Rate: %d\n", PRODUCT_NAME, BaudRate)); 
		
			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			
			if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort))
			{
				Status = STATUS_SUCCESS;
#ifdef WMI_SUPPORT
				pPort->WmiCommData.BaudRate = BaudRate;
#endif
			}
			else
			{
				Status = STATUS_INVALID_PARAMETER;
			}

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_GET_BAUD_RATE: 
		{
			PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
			
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_BAUD_RATE)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			Br->BaudRate = pPort->UartConfig.TxBaud;
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);

			break;
		}

    case IOCTL_SERIAL_SET_LINE_CONTROL: 
		{
			// Points to the line control record in the Irp.
			PSERIAL_LINE_CONTROL Lc = ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

			ULONG FCData;
			ULONG FCStop;
			ULONG FCParity;
			UCHAR LData;
			UCHAR LStop;
			UCHAR LParity;
			UCHAR Mask = 0xff;

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_LINE_CONTROL)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			switch(Lc->WordLength) 
			{
				case 5:
					FCData = UC_FCFG_DATALEN_5;
					LData = SERIAL_5_DATA;
					Mask = 0x1f;
					break;

				case 6: 
					FCData = UC_FCFG_DATALEN_6;
					LData = SERIAL_6_DATA;
					Mask = 0x3f;
					break;

				case 7: 
					FCData = UC_FCFG_DATALEN_7;
					LData = SERIAL_7_DATA;
					Mask = 0x7f;
					break;

				case 8: 
					FCData = UC_FCFG_DATALEN_8;
					LData = SERIAL_8_DATA;
					break;

				default: 
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
			}

			switch(Lc->Parity) 
			{

				case NO_PARITY: 
					FCParity = UC_FCFG_NO_PARITY;
					LParity = SERIAL_NONE_PARITY;
					break;

				case EVEN_PARITY:
					FCParity = UC_FCFG_EVEN_PARITY;
					LParity = SERIAL_EVEN_PARITY;
					break;

				case ODD_PARITY: 
					FCParity = UC_FCFG_ODD_PARITY;
					LParity = SERIAL_ODD_PARITY;
					break;

				case SPACE_PARITY: 
					FCParity = UC_FCFG_SPACE_PARITY;
					LParity = SERIAL_SPACE_PARITY;
					break;

				case MARK_PARITY: 
					FCParity = UC_FCFG_MARK_PARITY;
					LParity = SERIAL_MARK_PARITY;
					break;

				default:
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
					break;
			}

			switch(Lc->StopBits) 
			{
				case STOP_BIT_1: 
					FCStop = UC_FCFG_STOPBITS_1;
					LStop = SERIAL_1_STOP;
					break;

				case STOP_BITS_1_5: 
					{
						if(LData != SERIAL_5_DATA) 
						{
							Status = STATUS_INVALID_PARAMETER;
							goto DoneWithIoctl;
						}

						FCStop = UC_FCFG_STOPBITS_1_5;
						LStop = SERIAL_1_5_STOP;
						break;
					}

				case STOP_BITS_2: 
					{
						if(LData == SERIAL_5_DATA) 
						{
							Status = STATUS_INVALID_PARAMETER;
							goto DoneWithIoctl;
						}

						FCStop = UC_FCFG_STOPBITS_2;
						LStop = SERIAL_2_STOP;
						break;
					}

				default:
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_DATALEN_MASK) | FCData;
			pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_PARITY_MASK) | FCParity;
			pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_STOPBITS_MASK) | FCStop;
			
			pPort->LineControl 	= (UCHAR)((pPort->LineControl & SERIAL_LCR_BREAK) | (LData | LParity | LStop));
			pPort->ValidDataMask = Mask;

			KeSynchronizeExecution(pPort->Interrupt, SerialSetLineControl, pPort);


#ifdef WMI_SUPPORT
			UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
#endif
				
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_GET_LINE_CONTROL: 
		{
			PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_LINE_CONTROL))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

		
			switch(pPort->UartConfig.FrameConfig & UC_FCFG_DATALEN_MASK)
			{
			case UC_FCFG_DATALEN_5:
				Lc->WordLength = 5;
				break;

			case UC_FCFG_DATALEN_6:
				Lc->WordLength = 6;
				break;

			case UC_FCFG_DATALEN_7:
				Lc->WordLength = 7;
				break;

			case UC_FCFG_DATALEN_8:
				Lc->WordLength = 8;
				break;

			default:
				break;
			}

			switch(pPort->UartConfig.FrameConfig & UC_FCFG_PARITY_MASK)
			{
			case UC_FCFG_NO_PARITY:
				Lc->Parity = NO_PARITY;
				break;

			case UC_FCFG_ODD_PARITY:
				Lc->Parity = ODD_PARITY;
				break;

			case UC_FCFG_EVEN_PARITY:
				Lc->Parity = EVEN_PARITY;
				break;

			case UC_FCFG_MARK_PARITY:
				Lc->Parity = MARK_PARITY;
				break;

			case UC_FCFG_SPACE_PARITY:
				Lc->Parity = SPACE_PARITY;
				break;

			default:
				break;
			}

			switch(pPort->UartConfig.FrameConfig & UC_FCFG_STOPBITS_MASK)
			{
			case UC_FCFG_STOPBITS_1:
				Lc->StopBits = STOP_BIT_1;
				break;

			case UC_FCFG_STOPBITS_1_5:
				Lc->StopBits = STOP_BITS_1_5;
				break;

			case UC_FCFG_STOPBITS_2:
				Lc->StopBits = STOP_BITS_2;
				break;

			default:
				break;
			}


			Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

    case IOCTL_SERIAL_SET_TIMEOUTS: 
		{
			PSERIAL_TIMEOUTS NewTimeouts = ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_TIMEOUTS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if((NewTimeouts->ReadIntervalTimeout == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG)) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			pPort->Timeouts.ReadIntervalTimeout			= NewTimeouts->ReadIntervalTimeout;
			pPort->Timeouts.ReadTotalTimeoutMultiplier	= NewTimeouts->ReadTotalTimeoutMultiplier;
			pPort->Timeouts.ReadTotalTimeoutConstant	= NewTimeouts->ReadTotalTimeoutConstant;
			pPort->Timeouts.WriteTotalTimeoutMultiplier = NewTimeouts->WriteTotalTimeoutMultiplier;
			pPort->Timeouts.WriteTotalTimeoutConstant	= NewTimeouts->WriteTotalTimeoutConstant;

			KeReleaseSpinLock(&pPort->ControlLock,OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_GET_TIMEOUTS: 
		{

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_TIMEOUTS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            
			*((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = pPort->Timeouts;
			Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            
			break;
		}

    case IOCTL_SERIAL_SET_CHARS: 
		{

			SERIAL_IOCTL_SYNC S;
			PSERIAL_CHARS NewChars = ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));
            
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_CHARS)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			//
			// The only thing that can be wrong with the chars
			// is that the xon and xoff characters are the
			// same.
			//
#if 0
			if(NewChars->XonChar == NewChars->XoffChar) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}
#endif

			//
			// We acquire the control lock so that only
			// one request can GET or SET the characters
			// at a time.  The sets could be synchronized
			// by the interrupt spinlock, but that wouldn't
			// prevent multiple gets at the same time.
			//

			S.pPort = pPort;
			S.Data = NewChars;

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            
			//
			// Under the protection of the lock, make sure that
			// the xon and xoff characters aren't the same as
			// the escape character.
			//

			if(pPort->EscapeChar) 
			{
				if((pPort->EscapeChar == NewChars->XonChar) || (pPort->EscapeChar == NewChars->XoffChar))
				{
					Status = STATUS_INVALID_PARAMETER;
					KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
					break;
				}
			}

			KeSynchronizeExecution(pPort->Interrupt, SerialSetChars, &S);
#ifdef WMI_SUPPORT
			UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
#endif

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

    case IOCTL_SERIAL_GET_CHARS: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_CHARS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			*((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) = pPort->SpecialChars;
			Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_SET_DTR:
    case IOCTL_SERIAL_CLR_DTR: 
		{
			//
			// We acquire the lock so that we can check whether
			// automatic dtr flow control is enabled.  If it is
			// then we return an error since the app is not allowed
			// to touch this if it is automatic.
			//

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
				
			if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
			{
				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
			} 
			else 
			{
				KeSynchronizeExecution(pPort->Interrupt,
					((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR)
					 ? (SerialSetDTR) : (SerialClrDTR)) , pPort);
			}

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_RESET_DEVICE: 
		{
			break;
		}

    case IOCTL_SERIAL_SET_RTS:
    case IOCTL_SERIAL_CLR_RTS: 
		{
			//
			// We acquire the lock so that we can check whether automatic rts flow control 
			// or transmit toggleing is enabled.  If it is then we return an error since
			// the app is not allowed to touch this if it is automatic or toggling.
			//

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
				
			if(((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE)
				|| ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE))
			{	
				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
			} 
			else 
			{
				KeSynchronizeExecution(pPort->Interrupt,
					((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_RTS)
					? (SerialSetRTS) : (SerialClrRTS)), pPort);		
			}

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

    case IOCTL_SERIAL_SET_XOFF: 
		{
			KeSynchronizeExecution(pPort->Interrupt, SerialPretendXoff, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_XON: 
		{
			KeSynchronizeExecution(pPort->Interrupt, SerialPretendXon, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_BREAK_ON: 
		{

			KeSynchronizeExecution(pPort->Interrupt, SerialTurnOnBreak, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_BREAK_OFF: 
		{

			KeSynchronizeExecution(pPort->Interrupt, SerialTurnOffBreak, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_QUEUE_SIZE: 
		{

			// Type ahead buffer is fixed, so we just validate
			// the the users request is not bigger that our
			// own internal buffer size.
        
			PSERIAL_QUEUE_SIZE Rs = ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));
				

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_QUEUE_SIZE)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// We have to allocate the memory for the new
			// buffer while we're still in the context of the
			// caller.  We don't even try to protect this
			// with a lock because the value could be stale
			// as soon as we release the lock - The only time
			// we will know for sure is when we actually try
			// to do the resize.
        
			if(Rs->InSize <= pPort->BufferSize) 
			{
				Status = STATUS_SUCCESS;
				break;
			}

			try 
			{
				IrpSp->Parameters.DeviceIoControl.Type3InputBuffer 
					= SpxAllocateMemWithQuota(NonPagedPool, Rs->InSize);
			} 
			except (EXCEPTION_EXECUTE_HANDLER) 
			{
				IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
				Status = GetExceptionCode();
			}

			
			if(!IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) 
			{
				break;
			}

			//
			// Well the data passed was big enough.  Do the request.
			//
			// There are two reason we place it in the read queue:
			//
			// 1) We want to serialize these resize requests so that
			//    they don't contend with each other.
			//
			// 2) We want to serialize these requests with reads since
			//    we don't want reads and resizes contending over the
			//    read buffer.
			//
			
			return SerialStartOrQueue(pPort, Irp, &pPort->ReadQueue, 
						&pPort->CurrentReadIrp, SerialStartRead);
					   
			break;

		}

    case IOCTL_SERIAL_GET_WAIT_MASK: 
		{

			if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Simple scalar read.  No reason to acquire a lock.
			Irp->IoStatus.Information = sizeof(ULONG);

			*((ULONG *)Irp->AssociatedIrp.SystemBuffer) = pPort->IsrWaitMask;

			break;
		}

    case IOCTL_SERIAL_SET_WAIT_MASK: 
		{
			ULONG NewMask;

			SerialDump(SERDIAG3 | SERIRPPATH,	("In Ioctl processing for set mask\n"));
				
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
			{
				SerialDump(SERDIAG3, ("Invalid size for the buffer %d\n", IrpSp->Parameters.DeviceIoControl.InputBufferLength));
					
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			} 
			else 
			{
				NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
			}

			// Make sure that the mask only contains valid
			// waitable events.

			if(NewMask & ~(	SERIAL_EV_RXCHAR   |
							SERIAL_EV_RXFLAG   |
							SERIAL_EV_TXEMPTY  |
							SERIAL_EV_CTS      |
							SERIAL_EV_DSR      |
							SERIAL_EV_RLSD     |
							SERIAL_EV_BREAK    |
							SERIAL_EV_ERR      |
							SERIAL_EV_RING     |
							SERIAL_EV_PERR     |
							SERIAL_EV_RX80FULL |
							SERIAL_EV_EVENT1   |
							SERIAL_EV_EVENT2)) 
			{

				SerialDump(SERDIAG3,("Unknown mask %x\n", NewMask));
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// Either start this irp or put it on the
			// queue.

			SerialDump(SERDIAG3 | SERIRPPATH, ("Starting or queuing set mask irp %x\n", Irp));
				
				
				
			return SerialStartOrQueue(pPort, Irp, &pPort->MaskQueue, 
						&pPort->CurrentMaskIrp, SerialStartMask);
					   
		}

    case IOCTL_SERIAL_WAIT_ON_MASK: 
		{
			SerialDump(SERDIAG3 | SERIRPPATH, ("In Ioctl processing for wait mask\n"));

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{

				SerialDump(SERDIAG3,("Invalid size fo the buffer %d\n", 
					IrpSp->Parameters.DeviceIoControl.InputBufferLength));

				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Either start this irp or put it on the queue.
			SerialDump(SERDIAG3 | SERIRPPATH,("Starting or queuing wait mask irp %x\n", Irp));
            
			return SerialStartOrQueue(pPort, Irp, &pPort->MaskQueue, 
						&pPort->CurrentMaskIrp, SerialStartMask);
                  
	    }

	case IOCTL_SERIAL_IMMEDIATE_CHAR: 
		{
			KIRQL OldIrql;

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			IoAcquireCancelSpinLock(&OldIrql);
			
			if(pPort->CurrentImmediateIrp) 
			{
				Status = STATUS_INVALID_PARAMETER;
				IoReleaseCancelSpinLock(OldIrql);
			} 
			else 
			{
				// We can queue the char.  We need to set
				// a cancel routine because flow control could
				// keep the char from transmitting.  Make sure
				// that the irp hasn't already been canceled.

				if(Irp->Cancel) 
				{
					IoReleaseCancelSpinLock(OldIrql);
					Status = STATUS_CANCELLED;
				} 
				else 
				{
					pPort->CurrentImmediateIrp = Irp;
					pPort->TotalCharsQueued++;
					IoReleaseCancelSpinLock(OldIrql);
					SerialStartImmediate(pPort);

					return STATUS_PENDING;
				}
			}

			break;
		}

    case IOCTL_SERIAL_PURGE: 
		{
	        ULONG Mask;

		    if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Check to make sure that the mask only has
			// 0 or the other appropriate values.

			Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

			if((!Mask) || (Mask & (~( SERIAL_PURGE_TXABORT |
									  SERIAL_PURGE_RXABORT |
									  SERIAL_PURGE_TXCLEAR |
									  SERIAL_PURGE_RXCLEAR ))))
			{

				Status = STATUS_INVALID_PARAMETER;
				break;

			}

			// Either start this irp or put it on the queue.
			return SerialStartOrQueue(pPort, Irp, &pPort->PurgeQueue, 
						&pPort->CurrentPurgeIrp, SerialStartPurge);

		}

    case IOCTL_SERIAL_GET_HANDFLOW: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_HANDFLOW))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			*((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) = pPort->HandFlow;
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_SET_HANDFLOW: 
		{
			SERIAL_IOCTL_SYNC S;
			PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

			// Make sure that the hand shake and control is the right size.
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_HANDFLOW))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Make sure that there are no invalid bits set in the control and handshake.
			if(HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if(HandFlow->FlowReplace & SERIAL_FLOW_INVALID) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// Make sure that the app hasn't set an invlid DTR mode.
			if((HandFlow->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK)
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// Make sure that haven't set totally invalid xon/xoff limits.
			if((HandFlow->XonLimit < 0) || ((ULONG)HandFlow->XonLimit > pPort->BufferSize)) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if((HandFlow->XoffLimit < 0) || ((ULONG)HandFlow->XoffLimit > pPort->BufferSize)) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			S.pPort = pPort;
			S.Data = HandFlow;

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			// Under the protection of the lock, make sure that we aren't turning on error 
			// replacement when we are doing line status/modem status insertion.

			if(pPort->EscapeChar) 
			{
				if(HandFlow->FlowReplace & SERIAL_ERROR_CHAR) 
				{
					Status = STATUS_INVALID_PARAMETER;
					KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
					break;
				}
			}

			KeSynchronizeExecution(pPort->Interrupt, SerialSetHandFlow, &S);
#ifdef WMI_SUPPORT
			UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_GET_MODEMSTATUS: 
		{
			SERIAL_IOCTL_SYNC S;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(ULONG);

			S.pPort = pPort;
			S.Data = Irp->AssociatedIrp.SystemBuffer;

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			KeSynchronizeExecution(pPort->Interrupt, SerialGetModemUpdate, &S);
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;

		}

    case IOCTL_SERIAL_GET_DTRRTS: 
		{
			ULONG ModemControl = 0;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(ULONG);
			Status = STATUS_SUCCESS;

			// Reading this hardware has no effect on the device.

			if(pPort->DTR_Set)
				ModemControl |= SERIAL_DTR_STATE;

			if(pPort->RTS_Set)
				ModemControl |= SERIAL_RTS_STATE;

			*(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;
			break;
		}

    case IOCTL_SERIAL_GET_COMMSTATUS: 
		{
			SERIAL_IOCTL_SYNC S;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength <sizeof(SERIAL_STATUS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

			S.pPort	= pPort;
			S.Data	= Irp->AssociatedIrp.SystemBuffer;

			//
			// Acquire the cancel spin lock so nothing much
			// changes while were getting the state.
			//

			IoAcquireCancelSpinLock(&OldIrql);

			KeSynchronizeExecution(pPort->Interrupt, SerialGetCommStatus, &S);
				
			IoReleaseCancelSpinLock(OldIrql);
			break;
		}

    case IOCTL_SERIAL_GET_PROPERTIES: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength <sizeof(SERIAL_COMMPROP))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// No synchronization is required since this information is "static".
			SerialGetProperties(pPort, Irp->AssociatedIrp.SystemBuffer);

			Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
			Status = STATUS_SUCCESS;

			break;
		}

    case IOCTL_SERIAL_XOFF_COUNTER: 
		{
			PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

            Status = STATUS_NOT_IMPLEMENTED;

			/*
			if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_XOFF_COUNTER))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(Xc->Counter <= 0) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// So far so good.  Put the irp onto the write queue.

			return SerialStartOrQueue(pPort, Irp, &pPort->WriteQueue, 
						&pPort->CurrentWriteIrp,SerialStartWrite);

			*/

			break;
		}

    case IOCTL_SERIAL_LSRMST_INSERT: 
		{

			PUCHAR escapeChar = Irp->AssociatedIrp.SystemBuffer;

			// Make sure we get a byte.

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
				
			if(*escapeChar) 
			{
				// We've got some escape work to do.  We will make sure that
				// the character is not the same as the Xon or Xoff character,
				// or that we are already doing error replacement.

				if((*escapeChar == pPort->SpecialChars.XoffChar) 
					|| (*escapeChar == pPort->SpecialChars.XonChar) 
					|| (pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)) 
				{
					Status = STATUS_INVALID_PARAMETER;

					KeReleaseSpinLock(&pPort->ControlLock,OldIrql);

					break;
				}
			}

			KeSynchronizeExecution(pPort->Interrupt, SerialSetEscapeChar, Irp);
				
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_CONFIG_SIZE:
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(ULONG);
			Status = STATUS_SUCCESS;

			*(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;
			break;
		}

    case IOCTL_SERIAL_GET_STATS: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
			Status = STATUS_SUCCESS;

			KeSynchronizeExecution(pPort->Interrupt, SerialGetStats, Irp);
			break;
		}

    case IOCTL_SERIAL_CLEAR_STATS: 
		{
			KeSynchronizeExecution(pPort->Interrupt, SerialClearStats, pPort);
			break;
		}

    default: 
		{

			Status = STATUS_INVALID_PARAMETER;
			break;
		}
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = Status;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}



VOID
SerialGetProperties(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_COMMPROP Properties)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This function returns the capabilities of this particular
    serial device.

Arguments:

    Extension - The serial device extension.

    Properties - The structure used to return the properties

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    RtlZeroMemory(Properties, sizeof(SERIAL_COMMPROP));

    Properties->PacketLength = sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion = 2;
    Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue = 0;
    Properties->MaxRxQueue = 0;

    Properties->MaxBaud = SERIAL_BAUD_USER;
    Properties->SettableBaud = pPort->SupportedBauds;

    Properties->ProvSubType = SERIAL_SP_RS232;

    Properties->ProvCapabilities = SERIAL_PCF_DTRDSR		|
                                   SERIAL_PCF_RTSCTS		|
                                   SERIAL_PCF_CD			|
                                   SERIAL_PCF_PARITY_CHECK	|
                                   SERIAL_PCF_XONXOFF		|
                                   SERIAL_PCF_SETXCHAR		|
                                   SERIAL_PCF_TOTALTIMEOUTS |
                                   SERIAL_PCF_INTTIMEOUTS	|
								   SERIAL_PCF_SPECIALCHARS;

    Properties->SettableParams = SERIAL_SP_PARITY		|
                                 SERIAL_SP_BAUD			|
                                 SERIAL_SP_DATABITS		|
                                 SERIAL_SP_STOPBITS		|
                                 SERIAL_SP_HANDSHAKING	|
                                 SERIAL_SP_PARITY_CHECK |
                                 SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData = SERIAL_DATABITS_5 |
                               SERIAL_DATABITS_6 |
                               SERIAL_DATABITS_7 |
                               SERIAL_DATABITS_8;

    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN |
                                     SERIAL_PARITY_MARK |
                                     SERIAL_PARITY_SPACE;
    Properties->CurrentTxQueue = 0;
    Properties->CurrentRxQueue = pPort->BufferSize;

}




// Set Fast 16 and Fast 16 FMC cards to delay UART interrupts by 1.1 ms
// to improve performance when more than 50% of the ports are in full use.
// This is the default option.
BOOLEAN SetCardToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard)
{
	if((pCard->CardType == Fast16_Pci) || pCard->CardType == Fast16FMC_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), 0x59);
		}
		else
		{
			// Read Register Value and set bit 2 to enable RTS on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) | 0x8;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}


	return FALSE;
}


// Set Fast 16 and Fast 16 FMC cards not to delay UART interrupts by 1.1 ms.
BOOLEAN SetCardNotToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard)
{
	if((pCard->CardType == Fast16_Pci) || pCard->CardType == Fast16FMC_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), 0x51);
		}
		else
		{
			// Read Register Value and set bit 2 to enable RTS on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) & ~0x8;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}

	return FALSE;
}




// Sets card not to use DTR instead of RTS on Fast 16 PCI cards only.
// This is the default option.
BOOLEAN SetCardNotToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard)
{
	if(pCard->CardType == Fast16_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), 0x56);
		}
		else
		{
			// Read Register Value and set bit 2 to enable RTS on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) | 0x4;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}


	return FALSE;
}


// Sets card to use DTR instead of RTS on Fast 16 PCI cards only.
BOOLEAN SetCardToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard)
{
	if(pCard->CardType == Fast16_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), 0x52);
		}
		else
		{
			// Read Register Value and clear bit 2 to enable DTR on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) & ~0x4;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\openclos.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module contains the code that is very specific to
    opening, closing, and cleaning up in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"


BOOLEAN SerialMarkOpen(IN PVOID Context);
BOOLEAN SerialNullSynch(IN PVOID Context);
BOOLEAN GetFifoStatus(IN PVOID Context);


#ifdef ALLOC_PRAGMA
#endif

typedef struct _SERIAL_CHECK_OPEN
{
    PPORT_DEVICE_EXTENSION pPort;
    NTSTATUS *StatusOfOpen;

} SERIAL_CHECK_OPEN,*PSERIAL_CHECK_OPEN;


typedef struct _FIFO_STATUS
{
    PPORT_DEVICE_EXTENSION pPort;
    ULONG	BytesInTxFIFO;
    ULONG	BytesInRxFIFO;

} FIFO_STATUS,*PFIFO_STATUS;



// Just a bogus little routine to make sure that we can synch with the ISR.
BOOLEAN
SerialNullSynch(IN PVOID Context)
{
    UNREFERENCED_PARAMETER(Context);
    return FALSE;
}



NTSTATUS
SerialCreateOpen(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    We connect up to the interrupt for the create/open and initialize
    the structures needed to maintain an open for a device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    SERIAL_CHECK_OPEN checkOpen;
    NTSTATUS status;

    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
    SerialDump(SERDIAG3, ("In SerialCreateOpen\n"));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    // Before we do anything, let's make sure they aren't trying
    // to create a directory.  This is a silly, but what's a driver to do!?

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE)
	{
        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;

        SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_NOT_A_DIRECTORY;
    }

	// Do not allow any software to open the card object.
	if(DeviceObject->DeviceType != FILE_DEVICE_SERIAL_PORT)
	{
	    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

		return(STATUS_NO_SUCH_DEVICE);
	}

    // Create a buffer for the RX data when no reads are outstanding.
    pPort->InterruptReadBuffer = NULL;
    pPort->BufferSize = 0;

    switch(MmQuerySystemSize())
	{
        case MmLargeSystem:
			pPort->BufferSize = 4096;
			break;

        case MmMediumSystem:
			pPort->BufferSize = 1024;
			break;

        case MmSmallSystem:
			pPort->BufferSize = 128;

		default:
			break;
    }


	if(pPort->BufferSize)
	{
		pPort->BufferSizes.pINBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
	 	pPort->BufferSizes.INBufferSize = pPort->BufferSize;
    }
	else
	{
        pPort->BufferSize = 0;
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // On a new open we "flush" the read queue by initializing the count of characters.

    pPort->CharsInInterruptBuffer = 0;

    pPort->ReadBufferBase		= pPort->InterruptReadBuffer;
    pPort->CurrentCharSlot		= pPort->InterruptReadBuffer;
    pPort->FirstReadableChar	= pPort->InterruptReadBuffer;

    pPort->TotalCharsQueued = 0;

    // We set up the default xon/xoff limits.
    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;
    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));

	SpxDbgMsg(SPX_MISC_DBG,	("%s: The default interrupt read buffer size is: %d\n"
								"------  The XoffLimit is                         : %d\n"
								"------  The XonLimit is                          : %d\n"
								"------  The pt 8 size is                         : %d\n",
								PRODUCT_NAME,
								pPort->BufferSize,
								pPort->HandFlow.XoffLimit,
								pPort->HandFlow.XonLimit,
								pPort->BufferSizePt8 ));


    pPort->IrpMaskLocation = NULL;
    pPort->HistoryMask = 0;
    pPort->IsrWaitMask = 0;

    pPort->SendXonChar = FALSE;
    pPort->SendXoffChar = FALSE;


    // Clear out the statistics.
    KeSynchronizeExecution(pPort->Interrupt, SerialClearStats, pPort);

    // The escape char replacement must be reset upon every open
	pPort->EscapeChar = 0;

	GetPortSettings(pPort->DeviceObject);	// Get Saved Port Settings if present.


    // Synchronize with the ISR and let it know that the device has been successfully opened.
    KeSynchronizeExecution(pPort->Interrupt, SerialMarkOpen, pPort);

	status = STATUS_SUCCESS;

	Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0L;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}



NTSTATUS
SerialClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    We simply disconnect the interrupt for now.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/
{

    // This "timer value" is used to wait 10 character times
    // after the hardware is empty before we actually "run down"
    // all of the flow control/break junk.
    LARGE_INTEGER tenCharDelay;

    LARGE_INTEGER charTime;   // Holds a character time.
	FIFO_STATUS FifoStatus;

    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
    SerialDump(SERDIAG3, ("In SerialClose\n"));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.


    charTime.QuadPart = -SerialGetCharTime(pPort).QuadPart;

    // Do this now so that if the isr gets called it won't do anything
    // to cause more chars to get sent.  We want to run down the hardware.
    pPort->DeviceIsOpen = FALSE;


    // Synchronize with the isr to turn off break if it is already on.
    KeSynchronizeExecution(pPort->Interrupt, SerialTurnOffBreak, pPort);


    // Wait until all characters have been emptied out of the hardware.

	FifoStatus.pPort = pPort;
	// Get the number of characters left to send in the Tx FIFO
	if(KeSynchronizeExecution(pPort->Interrupt, GetFifoStatus, &FifoStatus))
	{
		ULONG i = 0;

		// Wait the appropriate time
		for(i = 0; i<FifoStatus.BytesInTxFIFO; i++)
			KeDelayExecutionThread(KernelMode, FALSE, &charTime);
	}

    // Synchronize with the ISR to let it know that interrupts are no longer important.
    KeSynchronizeExecution(pPort->Interrupt, SerialMarkClose, pPort);


    // The hardware is empty.  Delay 10 character times before
    // shut down all the flow control.

    tenCharDelay.QuadPart = charTime.QuadPart * 10;

    KeDelayExecutionThread(KernelMode, TRUE, &tenCharDelay);

    SerialClrDTR(pPort);

    SerialClrRTS(pPort);

    // Clean out the holding reasons (since we are closed).
    pPort->RXHolding = 0;
    pPort->TXHolding = 0;

    // All is done.  The port has been disabled from interrupting
    // so there is no point in keeping the memory around.

    pPort->BufferSize = 0;

	SpxFreeMem(pPort->BufferSizes.pINBuffer);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}




BOOLEAN
SerialMarkOpen(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine merely sets a boolean to true to mark the fact that
    somebody opened the device and its worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	SerialReset(pPort);

	// Set Buffer sizes.
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_BUFFER | UL_BC_IN | UL_BC_OUT);

	// Apply settings.
	ApplyInitialPortSettings(pPort);

	// Enable interrupts.
	pPort->UartConfig.InterruptEnable = UC_IE_RX_INT | UC_IE_TX_INT | UC_IE_RX_STAT_INT | UC_IE_MODEM_STAT_INT;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_INT_ENABLE_MASK);


	SpxDbgMsg(SERINFO,("%s: PORT OPENED: (%.8X)\n", PRODUCT_NAME, pPort->Controller));

	pPort->DeviceIsOpen = TRUE;
    pPort->ErrorWord = 0;

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
	pPort->WmiCommData.IsBusy = TRUE;
#endif

    return FALSE;
}



BOOLEAN
SerialMarkClose(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine merely sets a boolean to false to mark the fact that
    somebody closed the device and it's no longer worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.
-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;


	// CONCERN!!
	// We used to disable interrupts here by writing OUT2 to zero, this bit has
	// no effect on the PCI device so what happens if we get an interrupt after
	// the port has been closed?

	// Just reset the device
	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Serial Mark Close\n", PRODUCT_NAME));
   	pPort->pUartLib->UL_ResetUart_XXXX(pPort->pUart);	// Reset UART and turn off interrupts.
	ApplyInitialPortSettings(pPort);

	pPort->DeviceIsOpen = FALSE;
#ifdef WMI_SUPPORT
	pPort->WmiCommData.IsBusy	= FALSE;
#endif

	pPort->BufferSizes.pINBuffer = NULL;	// We are now finished with the IN Buffer
 	pPort->BufferSizes.INBufferSize = 0;
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_BUFFER | UL_BC_IN);


    return FALSE;
}





NTSTATUS
SerialCleanup(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This function is used to kill all longstanding IO operations.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    KIRQL oldIrql;

    SerialDump(SERIRPPATH,("Dispatch entry for: %x\n", Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    // First kill all the reads and writes.
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);

    // Next get rid of purges.
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->PurgeQueue, &pPort->CurrentPurgeIrp);

    // Get rid of any mask operations.
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->MaskQueue, &pPort->CurrentMaskIrp);

    // Now get rid a pending wait mask irp.
    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CurrentWaitIrp)
	{
        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pPort->CurrentWaitIrp->CancelRoutine;
        pPort->CurrentWaitIrp->Cancel = TRUE;

        if(cancelRoutine)
		{
            pPort->CurrentWaitIrp->CancelIrql = oldIrql;
            pPort->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(DeviceObject, pPort->CurrentWaitIrp);
        }
    }
	else
	{
        IoReleaseCancelSpinLock(oldIrql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

    SerialDump(SERIRPPATH,("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}



LARGE_INTEGER
SerialGetCharTime(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.

Arguments:

    Extension - Just what it says.

Return Value:

    100 nanosecond intervals in a character time.

-----------------------------------------------------------------------------*/
{
    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;
    LARGE_INTEGER tmp;

	switch(pPort->UartConfig.FrameConfig & UC_FCFG_DATALEN_MASK)
	{
	case UC_FCFG_DATALEN_5:
		dataSize = 5;
		break;

	case UC_FCFG_DATALEN_6:
		dataSize = 6;
		break;

	case UC_FCFG_DATALEN_7:
		dataSize = 7;
		break;

	case UC_FCFG_DATALEN_8:
		dataSize = 8;
		break;

	default:
		break;
	}

	if((pPort->UartConfig.FrameConfig & UC_FCFG_PARITY_MASK) == UC_FCFG_NO_PARITY)
		paritySize = 0;
	else
		paritySize = 1;

	if((pPort->UartConfig.FrameConfig & UC_FCFG_STOPBITS_MASK) == UC_FCFG_STOPBITS_1)
		stopSize = 1;
	else
		stopSize = 2; // Even if it is 1.5, for sanities sake were going to say 2.


    // First we calculate the number of 100 nanosecond intervals
    // are in a single bit time (Approximately).
    bitTime = (10000000 + (pPort->UartConfig.TxBaud - 1)) / pPort->UartConfig.TxBaud;
    charTime = bitTime + ((dataSize + paritySize + stopSize) * bitTime);

    tmp.QuadPart = charTime;
    return tmp;
}



BOOLEAN
GetFifoStatus(IN PVOID Context)
{
	PFIFO_STATUS pFifoStatus = Context;
    PPORT_DEVICE_EXTENSION pPort = pFifoStatus->pPort;
	GET_BUFFER_STATE GetBufferState;

	// Get the FIFO status.
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &GetBufferState, UL_BC_OP_GET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT);

	pFifoStatus->BytesInTxFIFO = GetBufferState.BytesInTxFIFO;
	pFifoStatus->BytesInRxFIFO = GetBufferState.BytesInRxFIFO;

	if(pFifoStatus->BytesInTxFIFO || pFifoStatus->BytesInRxFIFO)
		return TRUE;

	return FALSE;
}


BOOLEAN
ApplyInitialPortSettings(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	UART_CONFIG UartConfig = {0};

	// Set FIFO Flow Control Levels
	pPort->UartConfig.LoFlowCtrlThreshold = pPort->LoFlowCtrlThreshold;
	pPort->UartConfig.HiFlowCtrlThreshold = pPort->HiFlowCtrlThreshold;

	// Apply Flow control thresholds.
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK);

	// Fill BufferSizes Struct and apply FIFO settings.
	pPort->BufferSizes.TxFIFOSize		= pPort->TxFIFOSize;
	pPort->BufferSizes.RxFIFOSize		= pPort->RxFIFOSize;
	pPort->BufferSizes.TxFIFOTrigLevel	= (BYTE)pPort->TxFIFOTrigLevel;
	pPort->BufferSizes.RxFIFOTrigLevel	= (BYTE)pPort->RxFIFOTrigLevel;

	// Set Buffer sizes and FIFO depths.
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT);

	// Just do a quick get config to see if flow threshold have 
	// changed as a result of changing the FIFO triggers.
	pPort->pUartLib->UL_GetConfig_XXXX(pPort->pUart, &UartConfig);

	// Update FIFO Flow Control Levels in port extension
	pPort->LoFlowCtrlThreshold = UartConfig.LoFlowCtrlThreshold;
	pPort->HiFlowCtrlThreshold = UartConfig.HiFlowCtrlThreshold;	

	// Set FIFO Flow Control Levels
	pPort->UartConfig.LoFlowCtrlThreshold = pPort->LoFlowCtrlThreshold;
	pPort->UartConfig.HiFlowCtrlThreshold = pPort->HiFlowCtrlThreshold;

	// Set UART up with special chars.
	pPort->UartConfig.XON = pPort->SpecialChars.XonChar;
	pPort->UartConfig.XOFF = pPort->SpecialChars.XoffChar;

	// Apply any special UART Settings and Flow control thresholds.
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK | UC_SPECIAL_CHARS_MASK | UC_FC_THRESHOLD_SETTING_MASK);


    SerialSetLineControl(pPort);
	SerialSetBaud(pPort);
    SerialSetupNewHandFlow(pPort, &pPort->HandFlow);

	//SerialHandleModemUpdate(pPort, FALSE);


	
	return FALSE;
}



BOOLEAN
SerialReset(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This places the hardware in a standard configuration.

    NOTE: This assumes that it is called at interrupt level.


Arguments:

    Context - The device extension for serial device
    being managed.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	SerialDump(SERDIAG3, ("Serial Reset\n"));

   	pPort->pUartLib->UL_ResetUart_XXXX(pPort->pUart);	// Reset UART


    // Now we know that nothing could be transmitting at this point
    // so we set the HoldingEmpty indicator.

    pPort->HoldingEmpty = TRUE;

    return FALSE;
}


BOOLEAN SerialResetAndVerifyUart(PDEVICE_OBJECT pDevObj)
{
	if(pDevObj->DeviceType == FILE_DEVICE_CONTROLLER)
	{
		PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION) pDevObj->DeviceExtension;
   		
		if(pCard->UartLib.UL_VerifyUart_XXXX(pCard->pFirstUart) == UL_STATUS_SUCCESS)	// Verify UART
			return TRUE;
		else	
			return FALSE;
	}
	else if(pDevObj->DeviceType == FILE_DEVICE_SERIAL_PORT)
	{
		PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION) pDevObj->DeviceExtension;

		if(pPort->pUartLib->UL_VerifyUart_XXXX(pPort->pUart) == UL_STATUS_SUCCESS)	// Verify UART
			return TRUE;
		else	
			return FALSE;
	}

	return FALSE;	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//	Precompiled Header
/////////////////////////////////////////////////////////////////////////////

//#include <osrddk.h>
#include <ntddk.h>
#include <ntddser.h>
#include <stddef.h>
#include <stdarg.h>
#include "stdio.h"
#include "string.h"

#define WMI_SUPPORT	// Include WMI Support code
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>


typedef unsigned char	BYTE;	// 8-bits 
typedef unsigned short	WORD;	// 16-bits 
typedef unsigned long	DWORD;	// 32-bits
typedef unsigned char	UCHAR; 	// 8-bits 
typedef unsigned short	USHORT;	// 16-bits 
typedef unsigned long	ULONG;	// 32-bits

typedef BYTE	*PBYTE;
typedef WORD	*PWORD;
typedef DWORD	*PDWORD;
typedef UCHAR	*PUCHAR; 
typedef USHORT	*PUSHORT;
typedef ULONG	*PULONG; 



// Definitions and Macros.
#include "esils.h"		// Esils
#include "spd_ver.h"	// Dirver Version Information
#include "spx_defs.h"	// SPX Generic Definitions
#include "spd_defs.h"	// SPEED Specific Definitions
#include "speedwmi.h"	// SPEED Specific WMI Definitions	

#include "uartlib.h"
#include "lib95x.h"

//Structures  
#include "spx_card.h"	// Common Card Info
#include "spd_card.h"	// SPEED card device structure
#include "spx_misc.h"	// Misc 
#include "serialp.h"	// Serial prototypes and macros

// Common PnP function prototypes.
#include "spx.h"		// Common PnP header


// SPEED specific function prototypes
#include "spd_proto.h"	// Exportable Function Prototypes
#include "spd_log.h"	// SPEED Specific Error Log Messages
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spd_powr.c ===
#include "precomp.h"

// Paging 
#pragma alloc_text (PAGE, XXX_CardPowerDown)
#pragma alloc_text (PAGE, XXX_CardPowerUp)
#pragma alloc_text (PAGE, XXX_PortQueryPowerDown)
#pragma alloc_text (PAGE, XXX_PortPowerDown)
#pragma alloc_text (PAGE, XXX_PortPowerUp)
// End paging


////////////////////////////////////////////////////////////////////////
// XXX_CardPowerDown - Restores the state of the hardware & starts card.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	// Stop Card from interrupting

	return status;
}


//////////////////////////////////////////////////////////////////////
// XXX_CardPowerUp - Saves the state of the hardware & stops card. 
//////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	// Reset card and allow it to interrupt again.

	return status;
}



////////////////////////////////////////////////////////////////////////
// XXX_PortPowerDown - Decides whether it is safe to power down a port.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;


	return status;
}


////////////////////////////////////////////////////////////////////////
// XXX_PortPowerDown - Restores the state of the hardware & starts port.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;
	DWORD ModemSignals = 0;
	PCARD_DEVICE_EXTENSION pCard	= pPort->pParentCardExt;


	if(pPort->DeviceIsOpen)			// Is the port open? 
	{
		// Stop port from interrupting 
		pPort->UartConfig.InterruptEnable = 0;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_INT_ENABLE_MASK);

		// Get the current modem signals... 
		pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_STATUS);

		// Save the current modem signals... 
		pPort->SavedModemControl = ModemSignals;
	}

#ifdef MANAGE_HARDWARE_POWER_STATES
	// Power down RS232 line drivers
	switch(pPort->PortNumber)
	{
	case 0:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0xFC;
		break;
	case 1:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0xF3;
		break;
	case 2:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0xCF;
		break;
	case 3:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0x3F;
		break;

	default:
		break;
	}

	// Power down UART.
	pPort->UartConfig.SpecialMode = pPort->UartConfig.SpecialMode |= UC_SM_LOW_POWER_MODE;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);
#endif

	return status;
}

//////////////////////////////////////////////////////////////////////
// XXX_PortPowerUp - Saves the state of the hardware & stops port. 
//////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;
	PCARD_DEVICE_EXTENSION pCard	= pPort->pParentCardExt;



#ifdef MANAGE_HARDWARE_POWER_STATES
	// Wake up the UART
	pPort->UartConfig.SpecialMode = pPort->UartConfig.SpecialMode &= ~UC_SM_LOW_POWER_MODE;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);

	// Wake up the RS232 line drivers.
	switch(pPort->PortNumber)
	{
	case 0:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0x3;
		break;
	case 1:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0xC;
		break;
	case 2:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0x30;
		break;
	case 3:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0xC0;
		break;

	default:
		break;
	}
#endif

	SerialReset(pPort);
	ApplyInitialPortSettings(pPort);


	if(pPort->DeviceIsOpen)			// Was port open before? 
	{
		if(pPort->SavedModemControl & UL_MC_DTR)	// DTR active? 
			SerialSetDTR(pPort);	// Yes 
		else
			SerialClrDTR(pPort);	// No 


		if(pPort->SavedModemControl & UL_MC_RTS)	// RTS active? 
			SerialSetRTS(pPort);	// Yes 
		else
			SerialClrRTS(pPort);	// No 

		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK);

		// Re-enable interrupts  
		pPort->UartConfig.InterruptEnable = UC_IE_RX_INT | UC_IE_TX_INT | UC_IE_RX_STAT_INT | UC_IE_MODEM_STAT_INT;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_INT_ENABLE_MASK);
	}
	else
	{
		SerialClrDTR(pPort);
		SerialClrRTS(pPort);	
	}


	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spd_iioc.c ===
/************************************************************************/
/*																		*/
/*	Title		:	SPEED support funcs for INTERNAL IOCTLs			*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Support functions to support the					*/
/*					INTERNAL IOCTLs for specific hardware:				*/
/*					XXX_SetHandFlow										*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#include "precomp.h"

/*****************************************************************************
*****************************                     ****************************
*****************************   XXX_SetHandFlow   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		void XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS)

description:	Call to set the handshaking and flow control

parameters:		pPort points to the port device extension structure
				pS points to a serial ioctl synchronization structure

returns:		STATUS_SUCCESS

*/

void XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort,IN PSERIAL_IOCTL_SYNC pS)
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	KeSynchronizeExecution(pCard->Interrupt, SerialSetHandFlow, pS);

}	/* XXX_SetHandFlow */
                                                        
/* End of IO8_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\purge.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    purge.c

Abstract:

    This module contains the code that is very specific to purge
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialStartPurge(IN PPORT_DEVICE_EXTENSION pPort)
/*++

Routine Description:

    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.

--*/
{

    PIRP NewIrp;

    do 
	{
        ULONG Mask;

        Mask = *((ULONG *)(pPort->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));
                 

        if(Mask & SERIAL_PURGE_TXABORT) 
		{
            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);

            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentXoffIrp);
        }


        if(Mask & SERIAL_PURGE_RXABORT) 
            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);


        if(Mask & SERIAL_PURGE_RXCLEAR) 
		{
            KIRQL OldIrql;

            // Clean out the interrupt buffer.
            //
            // Note that we do this under protection of the
            // the drivers control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            KeSynchronizeExecution(pPort->Interrupt, SerialPurgeInterruptBuff, pPort);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
        }

        pPort->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        pPort->CurrentPurgeIrp->IoStatus.Information = 0;

        SerialGetNextIrp(pPort, &pPort->CurrentPurgeIrp, &pPort->PurgeQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return STATUS_SUCCESS;
}


BOOLEAN
SerialPurgeInterruptBuff(IN PVOID Context)
/*++

Routine Description:

    This routine simply resets the interrupt (typeahead) buffer.

    NOTE: This routine is being called from KeSynchronizeExecution.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

	// Flush the IN buffer	
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, NULL, UL_BC_OP_FLUSH, UL_BC_BUFFER | UL_BC_IN);

    SerialHandleReducedIntBuffer(pPort);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\read.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to read
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
VOID SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOLEAN SerialGrabReadFromIsr(IN PVOID Context);
BOOLEAN SerialUpdateReadByIsr(IN PVOID Context);
BOOLEAN ReadDataFromIntBuffer(IN PVOID Context);
BOOLEAN UpdateAndWaitForMoreData(IN PVOID Context);
NTSTATUS SerialResizeBuffer(IN PPORT_DEVICE_EXTENSION pPort);
BOOLEAN SerialUpdateAndSwitchToNew(IN PVOID Context);
// End of Prototypes    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialRead(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Read Irp dispatch entry for Irp: %x\n", PRODUCT_NAME, Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length read.  If it is zero length then we are already done!
    //
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) 
	{
        //
        // Well it looks like we actually have to do some work.  
        // Put the read on the queue so that we can process it when our previous reads are done.
        //
        return SerialStartOrQueue(pPort, Irp, &pPort->ReadQueue, &pPort->CurrentReadIrp, SerialStartRead);
    } 
	else 
	{
        Irp->IoStatus.Status = STATUS_SUCCESS;
		SpxDbgMsg(SPX_TRACE_CALLS,("%s: Complete Read for Irp: %x\n", PRODUCT_NAME, Irp));
       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, 0);

        return STATUS_SUCCESS;
    }
}

NTSTATUS
SerialStartRead(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

Arguments:

    Extension - Simply a pointer to the serial device extension.

Return Value:

    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.

-----------------------------------------------------------------------------*/

{

    SERIAL_UPDATE_CHAR updateChar;

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;


    updateChar.pPort = pPort;

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialStartRead - Irp: %x\n", pPort->CurrentReadIrp));


    do 
	{

        //
        // Check to see if this is a resize request.  If it is then go to a routine that specializes in that.
        //
        if(IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->MajorFunction != IRP_MJ_READ)
		{
            NTSTATUS localStatus = SerialResizeBuffer(pPort);

            if(!setFirstStatus) 
			{
                firstStatus = localStatus;
                setFirstStatus = TRUE;
            }
        } 
		else 
		{
			//
			// The irp might go under control of the isr.  
			// It won't hurt to initialize the reference count right now.
			//
			SERIAL_INIT_REFERENCE(pPort->CurrentReadIrp);

            pPort->NumberNeededForRead = IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length;

            // Calculate the timeout value needed for the request.  
            // Note that the values stored in the timeout record are in milliseconds.
            useTotalTimer			= FALSE;
            returnWithWhatsPresent	= FALSE;
            os2ssreturn				= FALSE;
            crunchDownToOne			= FALSE;
            useIntervalTimer		= FALSE;


            // Always initialize the timer objects so that the completion code can tell when it 
            // attempts to cancel the timers whether the timers had ever been Set.
            KeInitializeTimer(&pPort->ReadRequestTotalTimer);
            KeInitializeTimer(&pPort->ReadRequestIntervalTimer);


            // We get the *current* timeout values to use for timing this read.
            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);
            timeoutsForIrp = pPort->Timeouts;
            KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                

            // Calculate the interval timeout for the read.
            if(timeoutsForIrp.ReadIntervalTimeout && (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) 
			{
                useIntervalTimer = TRUE;

                pPort->IntervalTime.QuadPart = UInt32x32To64(timeoutsForIrp.ReadIntervalTimeout, 10000);

                if(pPort->IntervalTime.QuadPart >= pPort->CutOverAmount.QuadPart)
                    pPort->IntervalTimeToUse = &pPort->LongIntervalAmount;
				else 
                    pPort->IntervalTimeToUse = &pPort->ShortIntervalAmount;
            }

            if(timeoutsForIrp.ReadIntervalTimeout == MAXULONG) 
			{

                //
                // We need to do special return quickly stuff here.
                //
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                //
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                //
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.
                //

                if(!timeoutsForIrp.ReadTotalTimeoutConstant && !timeoutsForIrp.ReadTotalTimeoutMultiplier) 
				{
                    returnWithWhatsPresent = TRUE;
                } 
				else if((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
					&& (timeoutsForIrp.ReadTotalTimeoutMultiplier != MAXULONG))
				{
                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                } 
				else if((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
					&& (timeoutsForIrp.ReadTotalTimeoutMultiplier == MAXULONG)) 
				{
                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            } 
			else 
			{
                //
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.
                //

                if(timeoutsForIrp.ReadTotalTimeoutMultiplier || timeoutsForIrp.ReadTotalTimeoutConstant)
				{
                    // We have some timer values to calculate.
                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            }

            if(useTotalTimer) 
			{
                totalTime.QuadPart = ((LONGLONG)(UInt32x32To64(pPort->NumberNeededForRead, multiplierVal) 
									+ constantVal)) * -10000;
            }


			//
            // If we are supposed to crunch the read down to one character, then update 
            // the number needed for read down to one.
            //

            if(crunchDownToOne) 
                pPort->NumberNeededForRead = 1;


            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //
            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

            KeSynchronizeExecution(pPort->Interrupt, ReadDataFromIntBuffer, pPort);

            //
            // See if we have any cause to return immediately.
            //

            if(returnWithWhatsPresent || (!pPort->NumberNeededForRead) 
				|| (os2ssreturn && pPort->CurrentReadIrp->IoStatus.Information))
			{
                // We got all we needed for this read.

                KeReleaseSpinLock(&pPort->ControlLock, controlIrql);

                pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                
				if(!setFirstStatus) 
				{
                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }
            } 
			else 
			{

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be canceled.
                //

                if(pPort->CurrentReadIrp->Cancel) 
				{
                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                        
                    pPort->CurrentReadIrp->IoStatus.Status = STATUS_CANCELLED;
                       
                    pPort->CurrentReadIrp->IoStatus.Information = 0;

                    if(!setFirstStatus) 
					{
                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;
                    }
                } 
				else 
				{


                    //
                    // We still need to get more characters for this read.
                    // synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the users buffer.
                    //

                    KeSynchronizeExecution(pPort->Interrupt, UpdateAndWaitForMoreData, pPort);
                        
                    //
                    // The irp still isn't complete.  The
                    // completion routines will end up reinvoking
                    // this routine.  So we simply leave.
                    //
                    // First thought we should start off the total
                    // timer for the read and increment the reference
                    // count that the total timer has on the current
                    // irp.  Note that this is safe, because even if
                    // the io has been satisfied by the isr it can't
                    // complete yet because we still own the cancel
                    // spinlock.
                    //

                    if(useTotalTimer) 
					{
                        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_TOTAL_TIMER);

                        KeSetTimer(&pPort->ReadRequestTotalTimer, totalTime, &pPort->TotalReadTimeoutDpc);
                    }

                    if(useIntervalTimer) 
					{
                        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_INT_TIMER);

                        KeQuerySystemTime(&pPort->LastReadTime);

                        KeSetTimer(&pPort->ReadRequestIntervalTimer,
							*pPort->IntervalTimeToUse,
							&pPort->IntervalReadTimeoutDpc);
                    }

                    IoMarkIrpPending(pPort->CurrentReadIrp);
                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                        
                    if(!setFirstStatus) 
                        firstStatus = STATUS_PENDING;

					if(firstStatus == STATUS_PENDING)
						SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead - STATUS_PENDING - Irp: %x\n", pPort->CurrentReadIrp));

					if(firstStatus == STATUS_SUCCESS)
						SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead - STATUS_SUCCESS - Irp: %x\n", pPort->CurrentReadIrp));
					
					if(firstStatus == STATUS_CANCELLED)
						SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead - STATUS_CANCELLED - Irp: %x\n", pPort->CurrentReadIrp));

                    return firstStatus;

                }

            }

        }

        //
        // Well the operation is complete.
        //

        SerialGetNextIrp(pPort, &pPort->CurrentReadIrp, &pPort->ReadQueue, &newIrp, TRUE);
            

    } while (newIrp);


	if(firstStatus == STATUS_PENDING)
		SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead 2 - STATUS_PENDING - Irp: %x\n", pPort->CurrentReadIrp));

	if(firstStatus == STATUS_SUCCESS)
		SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead 2 - STATUS_SUCCESS - Irp: %x\n", pPort->CurrentReadIrp));
	
	if(firstStatus == STATUS_CANCELLED)
		SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead 2 - STATUS_CANCELLED - Irp: %x\n", pPort->CurrentReadIrp));

    return firstStatus;

}

VOID
SerialCompleteRead(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialCompleteRead - Irp: %x\n", pPort->CurrentReadIrp));

    IoAcquireCancelSpinLock(&oldIrql);

    // We set this to indicate to the interval timer that the read has completed.
    // Recall that the interval timer dpc can be lurking in some DPC queue.
    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_COMPLETING);

	// Clear reference to ISR on completion
	SerialTryToCompleteCurrent(	pPort,
								NULL,
								oldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentReadIrp,
								&pPort->ReadQueue,
								&pPort->ReadRequestIntervalTimer,
								&pPort->ReadRequestTotalTimer,
								SerialStartRead,
								SerialGetNextIrp,
								SERIAL_REF_ISR);
        
}

VOID
SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialCancelCurrentRead - Irp: %x\n", pPort->CurrentReadIrp));

    // We set this to indicate to the interval timer that the read has encountered a cancel.
    // Recall that the interval timer dpc can be lurking in some DPC queue.
    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabReadFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentReadIrp,
								&pPort->ReadQueue,
								&pPort->ReadRequestIntervalTimer,
								&pPort->ReadRequestTotalTimer,
								SerialStartRead,
								SerialGetNextIrp,
								SERIAL_REF_CANCEL);
        
}

BOOLEAN
SerialGrabReadFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    isr.  If it finds that the isr still owns the irp it grabs
    the irp away (updating the number of characters copied into the
    users buffer).  If it grabs it away it also decrements the
    reference count on the irp since it no longer belongs to the
    isr (and the dpc that would complete it).

    NOTE: This routine assumes that if the current buffer that the
          ISR is copying characters into is the interrupt buffer then
          the dpc has already been queued.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	SpxDbgMsg(SPX_TRACE_CALLS,("SerialGrabReadFromIsr - Irp: %x\n", pPort->CurrentReadIrp));

	ReadDataFromIntBuffer(pPort);

	SERIAL_CLEAR_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_ISR);

    return FALSE;
}


VOID
SerialReadTimeout(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialReadTimeout - Irp: %x\n", pPort->CurrentReadIrp));

    IoAcquireCancelSpinLock(&oldIrql);

    // We set this to indicate to the interval timer that the read has completed due to total timeout.
    // Recall that the interval timer dpc can be lurking in some DPC queue.
    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabReadFromIsr,
								oldIrql,
								STATUS_TIMEOUT,
								&pPort->CurrentReadIrp,
								&pPort->ReadQueue,
								&pPort->ReadRequestIntervalTimer,
								&pPort->ReadRequestTotalTimer,
								SerialStartRead,
								SerialGetNextIrp,
								SERIAL_REF_TOTAL_TIMER);
        

}

BOOLEAN
SerialUpdateReadByIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to update the count of characters read
    by the isr since the last interval timer experation.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;
	SpxDbgMsg(SPX_TRACE_CALLS,("SerialUpdateReadByIsr - Irp: %x\n", pPort->CurrentReadIrp));

    pPort->CountOnLastRead = pPort->ReadByIsr;
    pPort->ReadByIsr = 0;

    return FALSE;

}

VOID
SerialIntervalReadTimeout(IN PKDPC Dpc, 
						  IN PVOID DeferredContext, 
						  IN PVOID SystemContext1, 
						  IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialIntervalReadTimeout - Irp: %x\n", pPort->CurrentReadIrp));

    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) 
	{
        // This value is only set by the total timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        SerialTryToCompleteCurrent(	pPort,
									SerialGrabReadFromIsr,
									oldIrql,
									STATUS_TIMEOUT,
									&pPort->CurrentReadIrp,
									&pPort->ReadQueue,
									&pPort->ReadRequestIntervalTimer,
									&pPort->ReadRequestTotalTimer,
									SerialStartRead,
									SerialGetNextIrp,
									SERIAL_REF_INT_TIMER);
    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) 
	{

        // This value is only set by the regular completion routine.
        // If so, then we should simply try to complete.
        SerialTryToCompleteCurrent(	pPort,
									SerialGrabReadFromIsr,
									oldIrql,
									STATUS_SUCCESS,
									&pPort->CurrentReadIrp,
									&pPort->ReadQueue,
									&pPort->ReadRequestIntervalTimer,
									&pPort->ReadRequestTotalTimer,
									SerialStartRead,
									SerialGetNextIrp,
									SERIAL_REF_INT_TIMER);
    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) 
	{

        // This value is only set by the cancel read routine.
        // If so, then we should simply try to complete.
        SerialTryToCompleteCurrent(	pPort,
									SerialGrabReadFromIsr,
									oldIrql,
									STATUS_CANCELLED,
									&pPort->CurrentReadIrp,
									&pPort->ReadQueue,
									&pPort->ReadRequestIntervalTimer,
									&pPort->ReadRequestTotalTimer,
									SerialStartRead,
									SerialGetNextIrp,
									SERIAL_REF_INT_TIMER);
    } 
	else if(pPort->CountOnLastRead || pPort->ReadByIsr) 
	{
        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if(pPort->ReadByIsr) 
		{

            KeSynchronizeExecution(pPort->Interrupt, SerialUpdateReadByIsr, pPort);
                
            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(&pPort->LastReadTime);

            KeSetTimer(	&pPort->ReadRequestIntervalTimer,
						*pPort->IntervalTimeToUse,
						&pPort->IntervalReadTimeoutDpc);

            IoReleaseCancelSpinLock(oldIrql);

        } 
		else 
		{
            //
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            // No characters read in the interval time.  Kill this read.

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(&currentTime);

            if((currentTime.QuadPart - pPort->LastReadTime.QuadPart) >= pPort->IntervalTime.QuadPart) 
			{
                SerialTryToCompleteCurrent(	pPort,
											SerialGrabReadFromIsr,
											oldIrql,
											STATUS_TIMEOUT,
											&pPort->CurrentReadIrp,
											&pPort->ReadQueue,
											&pPort->ReadRequestIntervalTimer,
											&pPort->ReadRequestTotalTimer,
											SerialStartRead,
											SerialGetNextIrp,
											SERIAL_REF_INT_TIMER);
            } 
			else 
			{
                KeSetTimer(	&pPort->ReadRequestIntervalTimer,
							*pPort->IntervalTimeToUse,
							&pPort->IntervalReadTimeoutDpc);
                
                IoReleaseCancelSpinLock(oldIrql);
            }


        }

    } 
	else 
	{

        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

        KeSetTimer(&pPort->ReadRequestIntervalTimer, *pPort->IntervalTimeToUse, &pPort->IntervalReadTimeoutDpc);

        IoReleaseCancelSpinLock(oldIrql);
    }

}

BOOLEAN
ReadDataFromIntBuffer(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    Extension - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

-----------------------------------------------------------------------------*/
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	ULONG NumberOfBytes = 0;

	SpxDbgMsg(SPX_TRACE_CALLS,("ReadDataFromIntBuffer - Irp: %x\n", pPort->CurrentReadIrp));
	NumberOfBytes = pPort->pUartLib->UL_ReadData_XXXX(pPort->pUart, 
							(PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer) 
							+ IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length 
							- pPort->NumberNeededForRead, 
							pPort->NumberNeededForRead);

	if(NumberOfBytes)
	{
		pPort->NumberNeededForRead -= NumberOfBytes;

		pPort->CurrentReadIrp->IoStatus.Information += NumberOfBytes;

		// Deal with flow control if necessary.
		SerialHandleReducedIntBuffer(pPort);

		return TRUE;
	}
	
    return FALSE;
}



BOOLEAN
UpdateAndWaitForMoreData(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the users buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the users buffer.

Return Value:


-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	SpxDbgMsg(SPX_TRACE_CALLS,("UpdateAndWaitForMoreData - Irp: %x\n", pPort->CurrentReadIrp));

    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got the last batch.
    ReadDataFromIntBuffer(pPort);

    //
    // No more new characters will be "received" until we exit this routine.  
    // We again check to make sure that we haven't satisfied this read,
    // and if we haven't, we wait for the ISR to get some more data.
    //

    if(pPort->NumberNeededForRead) 
	{
		pPort->CountOnLastRead = pPort->CurrentReadIrp->IoStatus.Information;
        pPort->ReadByIsr = 0;

        // Mark the irp as being in a cancelable state.
        IoSetCancelRoutine(pPort->CurrentReadIrp, SerialCancelCurrentRead);
            
        // Increment the reference count twice.
        // Once for the Isr owning the irp and once because the cancel routine has a reference to it.
        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_ISR);
        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_CANCEL);

        return FALSE;
    } 


    return TRUE;
}




//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS 
{
    PPORT_DEVICE_EXTENSION pPort;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;
    
} SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;


NTSTATUS
SerialResizeBuffer(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    Extension - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

-----------------------------------------------------------------------------*/
{

    PSERIAL_QUEUE_SIZE rs = pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;
                                                       
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp);
                                   
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    pPort->CurrentReadIrp->IoStatus.Information = 0L;
    pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if(rs->InSize <= pPort->BufferSize) 
	{

        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //
        ExFreePool(newBuffer);
    } 
	else 
	{
        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.pPort = pPort;
        rp.OldBuffer = NULL;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

        KeSynchronizeExecution(pPort->Interrupt, SerialUpdateAndSwitchToNew, &rp);

        KeReleaseSpinLock( &pPort->ControlLock, controlIrql);
           

        // Free up the memory that the old buffer consumed.
        ExFreePool(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}



BOOLEAN
SerialUpdateAndSwitchToNew(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PSERIAL_RESIZE_PARAMS params = Context;
    PPORT_DEVICE_EXTENSION pPort = params->pPort;

	pPort->BufferSizes.pINBuffer = params->NewBuffer; 
	pPort->BufferSizes.INBufferSize = params->NewBufferSize;

	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_BUFFER | UL_BC_IN);

	params->OldBuffer = pPort->BufferSizes.pINBuffer;
	
    pPort->BufferSize = params->NewBufferSize;

    // We set up the default xon/xoff limits.
    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif                                 

    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    SerialHandleReducedIntBuffer(pPort);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spd_log.h ===
/*++

Copyright (c) 1998  Specialix International Ltd.

Abstract:

    Constant definitions for the I/O error code log values.

--*/

#ifndef IO8_LOG_H
#define IO8_LOG_H

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SPX_SEVERITY_SUCCESS
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_SUCCESS             ((NTSTATUS)0x00060001L)

//
// MessageId: SPX_SEVERITY_INFORMATIONAL
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_INFORMATIONAL       ((NTSTATUS)0x40060002L)

//
// MessageId: SPX_SEVERITY_WARNING
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_WARNING             ((NTSTATUS)0x80060003L)

//
// MessageId: SPX_SEVERITY_ERROR
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_ERROR               ((NTSTATUS)0xC0060004L)


#endif // End of IO8_LOG.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\qsfile.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    qsfile.c

Abstract:

    This module contains the code that is very specific to query/set file
    operations in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialQueryInformationFile(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/

{
    NTSTATUS Status;	// The status that gets returned to the caller and set in the Irp.

    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    PIO_STACK_LOCATION IrpSp;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;


    SerialDump(SERIRPPATH,("Dispatch entry for: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
        
    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    if(IrpSp->Parameters.QueryFile.FileInformationClass == FileStandardInformation) 
	{
        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize.QuadPart = 0;
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } 
	else if (IrpSp->Parameters.QueryFile.FileInformationClass == FilePositionInformation)
	{
        ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset.QuadPart = 0;
           
        Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

    } 
	else 
	{
        Status = STATUS_INVALID_PARAMETER;
    }

	Irp->IoStatus.Status = Status;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}

NTSTATUS
SerialSetInformationFile(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

-----------------------------------------------------------------------------*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;


    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
       
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;
    
	if((IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation)
		|| (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileAllocationInformation))
	{
        Status = STATUS_SUCCESS;
    } 
	else 
	{
        Status = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = Status;

    SerialDump(SERIRPPATH,("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spd_cwmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes


// -- CARD WMI Routines -- 
NTSTATUS
SpeedCard_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						  OUT PUNICODE_STRING pInstanceName,
						  OUT PUNICODE_STRING *pRegistryPath,
						  OUT PUNICODE_STRING pMofResourceName,
						  OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpeedCard_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
							IN ULONG GuidIndex, IN ULONG InstanceIndex,
							IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
							IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpeedCard_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpeedCard_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						 IN ULONG GuidIndex, IN ULONG InstanceIndex,
						 IN ULONG DataItemId, IN ULONG BufferSize,
						 IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpeedCard_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpeedCard_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpeedCard_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpeedCard_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpeedCard_WmiSetDataItem)
#endif






#define WMI_FAST_CARD_PROP			0

GUID FastCardWmiPropGuid				= SPX_SPEED_WMI_FAST_CARD_PROP_GUID;	// Fast Card Properties 


WMIGUIDREGINFO SpeedCard_WmiGuidList[] =
{
    { &FastCardWmiPropGuid, 1, 0 },
};


#define SpeedCard_WmiGuidCount (sizeof(SpeedCard_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpeedCard_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpeedCard_WmiGuidCount;
    WmilibContext->GuidList				= SpeedCard_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpeedCard_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpeedCard_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpeedCard_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpeedCard_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	//SpeedCard_WmiExecuteMethod
    WmilibContext->WmiFunctionControl	= NULL;	//SpeedCard_WmiFunctionControl;

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpeedCard_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						  OUT PUNICODE_STRING pInstanceName,
						  OUT PUNICODE_STRING *pRegistryPath,
						  OUT PUNICODE_STRING MofResourceName,
						  OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pCard->PDO;  // Card device object's PDO.

    RtlInitUnicodeString(MofResourceName, L"MofResource");

	return(status);
}





NTSTATUS
SpeedCard_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
							IN ULONG GuidIndex, IN ULONG InstanceIndex,
							IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
							IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
	case WMI_FAST_CARD_PROP:
		{
			size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;

			// Update items that may have changed.

			if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->DelayCardIntrrupt = TRUE;
			else
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->DelayCardIntrrupt = FALSE;

			if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR = TRUE;
			else
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR = FALSE;

			status = STATUS_SUCCESS;
			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpeedCard_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
	PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_FAST_CARD_PROP:
		{
			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pCard, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}


			size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP);
			
			if(BufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Currently these options are only settable on PCI-Fast 16 and PCI-Fast 16 FMC
			if((pCard->CardType != Fast16_Pci) && (pCard->CardType != Fast16FMC_Pci))
			{
				status = STATUS_WMI_READ_ONLY;
				break;
			}

			
			if(((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR)
			{
				// This option is not settable on PCI-Fast 16 FMC
				if((pCard->CardType != Fast16_Pci))
				{
					status = STATUS_WMI_READ_ONLY;
					break;
				}
			}


			if(((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->DelayCardIntrrupt)
			{
				if(!(pCard->CardOptions & DELAY_INTERRUPT_OPTION))	// If not already set then set the option
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardToDelayInterrupt, pCard))
					{
						pCard->CardOptions |= DELAY_INTERRUPT_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
					
				status = STATUS_SUCCESS;
			}
			else
			{
				if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)	// If set then unset the option.
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToDelayInterrupt, pCard))
					{
						pCard->CardOptions &= ~DELAY_INTERRUPT_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
						
				status = STATUS_SUCCESS;
			}


			if(((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR)
			{
				if(!(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION))	// If not already set then set the option
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardToUseDTRInsteadOfRTS, pCard))
					{
						pCard->CardOptions |= SWAP_RTS_FOR_DTR_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
					
				status = STATUS_SUCCESS;
			}
			else
			{
				if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)	// If set then unset the option.
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToUseDTRInsteadOfRTS, pCard))
					{
						pCard->CardOptions &= ~SWAP_RTS_FOR_DTR_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
					
				status = STATUS_SUCCESS;
			}
			
			

			if(SPX_SUCCESS(status))	// If set was successful then save setting to registry.
			{
				HANDLE PnPKeyHandle;

				// Open PnP Reg Key and save new setting to registry.
				if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
				{					
					ULONG TmpReg = 0;

					if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)
						TmpReg = 0x1;
					else
						TmpReg = 0x0;

					Spx_PutRegistryKeyValue(	PnPKeyHandle, DELAY_INTERRUPT, sizeof(DELAY_INTERRUPT), REG_DWORD, 
												&TmpReg, sizeof(ULONG));


					if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)
						TmpReg = 0x1;
					else
						TmpReg = 0x0;

					
					Spx_PutRegistryKeyValue(	PnPKeyHandle, SWAP_RTS_FOR_DTR, sizeof(SWAP_RTS_FOR_DTR), REG_DWORD, 
												&TmpReg, sizeof(ULONG));

					ZwClose(PnPKeyHandle);
				}

			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpeedCard_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_FAST_CARD_PROP:
		{
			HANDLE	PnPKeyHandle;

			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pCard, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}


			switch(DataItemId)
			{
			case SPX_SPEED_WMI_FAST_CARD_PROP_DelayCardIntrrupt_ID:
				{
					size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP_DelayCardIntrrupt_SIZE);
					
					if(BufferSize < size) 
					{
						status = STATUS_BUFFER_TOO_SMALL;
						break;
					}

					if((pCard->CardType != Fast16_Pci) && (pCard->CardType != Fast16FMC_Pci))
					{
						status = STATUS_WMI_READ_ONLY;
						break;
					}


					if(*pBuffer)
					{
						if(!(pCard->CardOptions & DELAY_INTERRUPT_OPTION))	// If not already set then set the option
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardToDelayInterrupt, pCard))
							{
								pCard->CardOptions |= DELAY_INTERRUPT_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
							
						status = STATUS_SUCCESS;
					}
					else
					{
						if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)	// If set then unset the option.
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToDelayInterrupt, pCard))
							{
								pCard->CardOptions &= ~DELAY_INTERRUPT_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
								
						status = STATUS_SUCCESS;
					}

					if(SPX_SUCCESS(status))	// If we set the option successfully then save the setting to the registry.
					{
						// Open PnP Reg Key and save new setting to registry.
						if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
						{
							ULONG TmpReg = 0;

							if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)
								TmpReg = 0x1;
							else
								TmpReg = 0x0;

							Spx_PutRegistryKeyValue(	PnPKeyHandle, DELAY_INTERRUPT, sizeof(DELAY_INTERRUPT), REG_DWORD, 
														&TmpReg, sizeof(ULONG));

							ZwClose(PnPKeyHandle);
						}
					}


					break;
				}

			case SPX_SPEED_WMI_FAST_CARD_PROP_SwapRTSForDTR_ID:
				{
					size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP_SwapRTSForDTR_SIZE);
					
					if(BufferSize < size) 
					{
						status = STATUS_BUFFER_TOO_SMALL;
						break;
					}

					if(pCard->CardType != Fast16_Pci)
					{
						status = STATUS_WMI_READ_ONLY;
						break;
					}

					if(*pBuffer)
					{
						if(!(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION))	// If not already set then set the option
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardToUseDTRInsteadOfRTS, pCard))
							{
								pCard->CardOptions |= SWAP_RTS_FOR_DTR_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
							
						status = STATUS_SUCCESS;
					}
					else
					{
						if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)	// If set then unset the option.
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToUseDTRInsteadOfRTS, pCard))
							{
								pCard->CardOptions &= ~SWAP_RTS_FOR_DTR_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
							
						status = STATUS_SUCCESS;
					}


					if(SPX_SUCCESS(status))	// If we set the option successfully then save the setting to the registry.
					{
						// Open PnP Reg Key and save new setting to registry.
						if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
						{
							ULONG TmpReg = 0;

							if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)
								TmpReg = 0x1;
							else
								TmpReg = 0x0;

							Spx_PutRegistryKeyValue(	PnPKeyHandle, SWAP_RTS_FOR_DTR, sizeof(SWAP_RTS_FOR_DTR), REG_DWORD, 
														&TmpReg, sizeof(ULONG));

							ZwClose(PnPKeyHandle);
						}

					}

					break;
				}
			

			default:
				{
					status = STATUS_WMI_ITEMID_NOT_FOUND;
					break;
				}
			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spx_iioc.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Dispatch Entry for INTERNAL IOCTLs					*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Internal IOCTLs support the SERENUM					*/
/*					attached serial device enumerator:					*/
/*					IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS				*/
/*					IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS				*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#define FILE_ID	SPX_IIOC_C		// File ID for Event Logging see SPX_DEFS.H for values.



/*****************************************************************************
**********************                                 ***********************
**********************   Spx_SerialInternalIoControl   ***********************
**********************                                 ***********************
******************************************************************************
	
prototype:		NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)

description:	Internal IOCTL dipatch routine.
				These IOCTLs are only issued from know trusted system components such as
				the SERENUM.SYS attached serial device enumerator and the mouse driver:

parameters:		pDevObj points to the device object structure
				pIrp points to the IOCTL Irp packet

returns:		STATUS_SUCCESS

*/

NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
	NTSTATUS				status;
	PIO_STACK_LOCATION		pIrpStack;
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	KIRQL					OldIrql;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Entry\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	if(SerialCompleteIfError(pDevObj, pIrp) != STATUS_SUCCESS)
		return(STATUS_CANCELLED);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0L;
	status = STATUS_SUCCESS;

	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
	case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
		{
			SERIAL_BASIC_SETTINGS	Basic;
			PSERIAL_BASIC_SETTINGS	pBasic;
			SERIAL_IOCTL_SYNC	S;

			if (pIrpStack->Parameters.DeviceIoControl.IoControlCode 
				== IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
			{
          
/* Check the buffer size... */

				if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength 
					< sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

/* Everything is 0 -- timeouts and flow control. */
/* If we add additional features, this zero memory method may not work. */

				RtlZeroMemory(&Basic,sizeof(SERIAL_BASIC_SETTINGS));
				pIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;

/* Save off the old settings... */

				RtlCopyMemory(&pBasic->Timeouts, &pPort->Timeouts, sizeof(SERIAL_TIMEOUTS));
				RtlCopyMemory(&pBasic->HandFlow, &pPort->HandFlow, sizeof(SERIAL_HANDFLOW));

/* Point to our new settings... */

				pBasic = &Basic;
			}
			else
			{
				if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;
			}

			KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

/* Set the timeouts...	*/

			RtlCopyMemory(&pPort->Timeouts, &pBasic->Timeouts, sizeof(SERIAL_TIMEOUTS));

/* Set flowcontrol... */

			S.pPort = pPort;
			S.Data = &pBasic->HandFlow;
			XXX_SetHandFlow(pPort, &S);		/* Set the handflow for specific hardware */

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

	default:
		status = STATUS_INVALID_PARAMETER;
		break;
	}

	pIrp->IoStatus.Status = status;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Complete\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	IoCompleteRequest(pIrp,0);

	return(status);

} /* Spx_SerialInternalIoControl */
                                                        
/* End of SPX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spd_pnp.c ===
#include "precomp.h"

/////////////////////////////////////////////////////////////////////////////////////
//  This file contains all functions that are needed to integrate between the 
//  generic PnP code and the product specific code.
/////////////////////////////////////////////////////////////////////////////////////

#define FILE_ID		SPD_PNP_C		// File ID for Event Logging see SPD_DEFS.H for values.


// Prototypes
// End of Prototypes

NTSTATUS
XXX_CardGetResources(IN PDEVICE_OBJECT pDevObject,
					 IN PCM_RESOURCE_LIST PResList,
					 IN PCM_RESOURCE_LIST PTrResList) 	
/* ++
Routine Description:

	Stores resources given to us by the PnP manager 
	in the card's device extension.

Arguments:

    pDevObject - Pointer to the device object.
    
    PResList - Pointer to the untranslated resources requested.
    
    PTrResList - Pointer to the translated resources requested.

Return Value:

    STATUS_SUCCESS.

--*/
{

	PCARD_DEVICE_EXTENSION pCard		= pDevObject->DeviceExtension;
	NTSTATUS status						= STATUS_NOT_IMPLEMENTED;

	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	ULONG count				= 0;
	ULONG i					= 0;
	USHORT MemoryResource	= 0;
	USHORT IOResource		= 0;

	PCM_FULL_RESOURCE_DESCRIPTOR	pFullResourceDesc		= NULL;
	PCM_PARTIAL_RESOURCE_LIST		pPartialResourceList	= NULL;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR	pPartialResourceDesc	= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardGetResources for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	SpxDbgMsg(SPX_MISC_DBG, ("%s: Resource pointer is 0x%X\n", PRODUCT_NAME, PResList));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: Translated resource pointer is 0x%X\n", PRODUCT_NAME, PTrResList));

	if((PResList == NULL) || (PTrResList == NULL)) 
	{
		// This shouldn't happen in theory
		ASSERT(PResList != NULL);
		ASSERT(PTrResList != NULL);

		sprintf(szErrorMsg, "Card %d has been given no resources.", pCard->CardNumber);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,		// Driver Object
						pCard->DeviceObject,		// Device Object (Optional)
						PhysicalZero,				// Physical Address 1
						PhysicalZero,				// Physical Address 2
						0,							// SequenceNumber
						0,							// Major Function Code
						0,							// RetryCount
						FILE_ID | __LINE__,			// UniqueErrorValue
						STATUS_SUCCESS,				// FinalStatus
						szErrorMsg);				// Error Message

		// This status is as appropriate as I can think of
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Each resource list should have only one set of resources
	ASSERT(PResList->Count == 1);
	ASSERT(PTrResList->Count == 1);

	// Find out the card type... 
	if((pCard->CardType = SpxGetNtCardType(pCard->DeviceObject)) == -1)
	{
		sprintf(szErrorMsg, "Card %d is unrecognised.", pCard->CardNumber);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message


		return(STATUS_DEVICE_DOES_NOT_EXIST);
	}


	// Find out which raw resources have been given to us.
	pFullResourceDesc = &PResList->List[0];

	if(pFullResourceDesc)
	{
		pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
		count                   = pPartialResourceList->Count;	// Number of Partial Resource Descriptors

		// Pull out the stuff that is in the full descriptor.
		pCard->InterfaceType	= pFullResourceDesc->InterfaceType;
		pCard->BusNumber		= pFullResourceDesc->BusNumber;

		// Now run through the partial resource descriptors looking for the port and interrupt.
		for(i = 0; i < count; i++, pPartialResourceDesc++) 
		{
			switch(pPartialResourceDesc->Type) 
			{

			case CmResourceTypeMemory:
				break;

			case CmResourceTypePort: 
				{
					switch(pCard->CardType)
					{
					case Fast4_Isa:
					case Fast8_Isa:
					case Fast16_Isa:
					case Fast4_Pci:
					case Fast8_Pci:
					case Fast16_Pci:
					case Fast16FMC_Pci:
					case RAS4_Pci:
					case RAS8_Pci:
						pCard->PhysAddr			= pPartialResourceDesc->u.Memory.Start;
						pCard->SpanOfController	= pPartialResourceDesc->u.Memory.Length;
						break;

					default:	// Speed cards
						break;
					}

					IOResource++;
					break;
				}

			case CmResourceTypeInterrupt: 
				{
					pCard->OriginalIrql		= pPartialResourceDesc->u.Interrupt.Level;
					pCard->OriginalVector	= pPartialResourceDesc->u.Interrupt.Vector;
					pCard->ProcessorAffinity= pPartialResourceDesc->u.Interrupt.Affinity;

					if(pPartialResourceDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED)
						pCard->InterruptMode	= Latched;
					else
						pCard->InterruptMode	= LevelSensitive; 

					switch(pPartialResourceDesc->ShareDisposition)
					{
					case CmResourceShareDeviceExclusive:
						pCard->InterruptShareable	= FALSE;
						break;

					case CmResourceShareDriverExclusive:
						pCard->InterruptShareable	= FALSE;
						break;

					case CmResourceShareShared:
					default:
						pCard->InterruptShareable	= TRUE;
						break;
					}

					break;
				}

			default:
				break;

			}

		}
	}

	// Do the same for the translated resources.
	pFullResourceDesc = &PTrResList->List[0];

	if(pFullResourceDesc)
	{
		pPartialResourceList	= &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc	= pPartialResourceList->PartialDescriptors;
		count					= pPartialResourceList->Count;	// Number of Partial Resource Descriptors

		// Pull out the stuff that is in the full descriptor.
		pCard->InterfaceType		= pFullResourceDesc->InterfaceType;
		pCard->BusNumber			= pFullResourceDesc->BusNumber;

		// Now run through the partial resource descriptors looking for the interrupt,
		for(i = 0; i < count; i++, pPartialResourceDesc++) 
		{
			switch(pPartialResourceDesc->Type) 
			{

			case CmResourceTypeMemory: 
				{
					switch(pCard->CardType)
					{
					case Fast4_Isa:
					case Fast8_Isa:
					case Fast16_Isa:
						break;		// No Memory resource for these

					case Fast4_Pci:
					case Fast8_Pci:
					case Fast16_Pci:
					case Fast16FMC_Pci:
					case RAS4_Pci:
					case RAS8_Pci:
						{	// Must be config space 
							pCard->PCIConfigRegisters		= pPartialResourceDesc->u.Memory.Start;
							pCard->SpanOfPCIConfigRegisters	= pPartialResourceDesc->u.Memory.Length;
							break;
						}

					default:	// Speed cards
						{
							if(MemoryResource == 0)	
							{
								pCard->PhysAddr			= pPartialResourceDesc->u.Memory.Start;
								pCard->SpanOfController	= pPartialResourceDesc->u.Memory.Length;
							}
							else
							{	// Must be config space 
								pCard->PCIConfigRegisters		= pPartialResourceDesc->u.Memory.Start;
								pCard->SpanOfPCIConfigRegisters	= pPartialResourceDesc->u.Memory.Length;
							}

							break;
						}

					}
		
					MemoryResource++;
					break;
				}
			
			case CmResourceTypePort: 
				break;

			case CmResourceTypeInterrupt: 
				{
					pCard->TrIrql				= (KIRQL) pPartialResourceDesc->u.Interrupt.Level;
					pCard->TrVector				= pPartialResourceDesc->u.Interrupt.Vector;
					pCard->ProcessorAffinity	= pPartialResourceDesc->u.Interrupt.Affinity;
					break;
				}

			default:
				break;
			}
		}
	}

	// If we have 1 Mem or 1 I/O Resources and an interrupt the resource allocation most probably succeeded.
	if(((MemoryResource >= 1) || (IOResource >= 1)) && (pCard->TrVector))
		status = STATUS_SUCCESS;

	return status;
}




NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardInit for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));



    pCard->OurIsr			= SerialISR;
    pCard->OurIsrContext	= pCard;


	return status;
}

NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;
	UCHAR CardID	= 0;
	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	BOOLEAN bInterruptConnnected = FALSE;
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardStart for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast4_Pci:
	case RAS4_Pci:
		pCard->UARTOffset = 8;			// I/O address offset between UARTs
		pCard->UARTRegStride = 1;
		pCard->NumberOfPorts = 4;
		pCard->ClockRate = CLOCK_FREQ_7M3728Hz;		// 7.3728 MHz
		pCard->Controller = (PUCHAR) pCard->PhysAddr.LowPart;

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C65X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Fast8_Isa:
	case Fast8_Pci:
	case RAS8_Pci:
		pCard->UARTOffset = 8;			// I/O address offset between UARTs
		pCard->UARTRegStride = 1;
		pCard->NumberOfPorts = 8;
		pCard->ClockRate = CLOCK_FREQ_7M3728Hz;		// 7.3728 MHz
		pCard->Controller = (PUCHAR) pCard->PhysAddr.LowPart;

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C65X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Fast16_Isa:
	case Fast16_Pci:
	case Fast16FMC_Pci:
		pCard->UARTOffset = 8;			// I/O address offset between UARTs
		pCard->UARTRegStride = 1;
		pCard->NumberOfPorts = 16;
		pCard->ClockRate = CLOCK_FREQ_7M3728Hz;		// 7.3728 MHz
		pCard->Controller = (PUCHAR) pCard->PhysAddr.LowPart;

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C65X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed2_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 2;
		pCard->ClockRate = CLOCK_FREQ_1M8432Hz;		// 1.8432 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed2P_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 2;
		pCard->ClockRate = CLOCK_FREQ_14M7456Hz;	// 14.7456 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed4_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 4;
		pCard->ClockRate = CLOCK_FREQ_1M8432Hz;		// 1.8432 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed4P_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 4;
		pCard->ClockRate = CLOCK_FREQ_14M7456Hz;	// 14.7456 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed2and4_Pci_8BitBus:
		pCard->UARTOffset = OXPCI_LOCAL_MEM_OFFSET;			// Memory address offset between local bus UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 0;	// No ports.
		pCard->ClockRate = CLOCK_FREQ_1M8432Hz;
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address
		break;

	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		pCard->UARTOffset = OXPCI_LOCAL_MEM_OFFSET;			// Memory address offset between local bus UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 0;	// No ports on a Speed2/4+ card.
		pCard->ClockRate = CLOCK_FREQ_14M7456Hz;
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address
		break;

	default:
		pCard->NumberOfPorts = 0;	// Default = No ports.
		break;
	}



// Map in the card's memory base address

	if(!pCard->Controller)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto Error;
	}

// Map in the card's Local Configuration Registers... 
	if(pCard->InterfaceType == PCIBus)	// If we have some PCI config registers
	{
		pCard->LocalConfigRegisters = MmMapIoSpace(pCard->PCIConfigRegisters, pCard->SpanOfPCIConfigRegisters, FALSE);

		if(!pCard->LocalConfigRegisters)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			goto Error;
		}
	}


	// Try to connect to interrupt.
	if(SPX_SUCCESS(status = IoConnectInterrupt(&pCard->Interrupt,			// Interrupt object
												pCard->OurIsr,				// Service routine  
												pCard->OurIsrContext,		// Service context 
												NULL,						// SpinLock (optional) 
												pCard->TrVector,			// Vector 
												pCard->TrIrql,				// IRQL 
												pCard->TrIrql,				// Synchronize IRQL
												pCard->InterruptMode,		// Mode (Latched/Level Sensitive) 
												pCard->InterruptShareable,	// Sharing mode 
												pCard->ProcessorAffinity,	// Processors to handle ints 
												FALSE)))					// Floating point save 	
	{
		bInterruptConnnected = TRUE;	// Set Interrupt Connected flag. 
	}
	else
	{	
		// Tell user the problem 
		sprintf(szErrorMsg, "Card at %08lX: Interrupt unavailable.", pCard->PhysAddr);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,		// Driver Object
						pCard->DeviceObject,		// Device Object (Optional)
						PhysicalZero,				// Physical Address 1
						PhysicalZero,				// Physical Address 2
						0,							// SequenceNumber
						0,							// Major Function Code
						0,							// RetryCount
						FILE_ID | __LINE__,			// UniqueErrorValue
						STATUS_SUCCESS,				// FinalStatus
						szErrorMsg);				// Error Message
		
		goto Error;
	}


	switch(pCard->CardType)
	{	
	case Fast4_Isa:		// If ISA card try to verify the card is present at selected address
	case Fast8_Isa:		// by trying to verify first UART on the Card.
	case Fast16_Isa:
		{
			INIT_UART InitUart = {0};

			// Set base address of 1st UART
			InitUart.UartNumber		= 0;
			InitUart.BaseAddress	= pCard->Controller;
			InitUart.RegisterStride = pCard->UARTRegStride;
			InitUart.ClockFreq		= pCard->ClockRate; 
			
			pCard->pFirstUart = NULL;

			// Init a UART structure.
			if(pCard->UartLib.UL_InitUart_XXXX(&InitUart, pCard->pFirstUart, &(pCard->pFirstUart)) != UL_STATUS_SUCCESS)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto Error;
			}

			// Reset and try to verify the UART.
			if(!KeSynchronizeExecution(pCard->Interrupt, SerialResetAndVerifyUart, pCard->DeviceObject))	// Verify UART exists.
			{
				SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Failed to find 1st UART on Card %d.\n", PRODUCT_NAME, pCard->CardNumber));
				pCard->UartLib.UL_DeInitUart_XXXX(pCard->pFirstUart);	// DeInit UART
				status = STATUS_DEVICE_DOES_NOT_EXIST;
				goto Error;
			}

			// DeInit the UART structure.
			pCard->UartLib.UL_DeInitUart_XXXX(pCard->pFirstUart);	// DeInit UART
			
			pCard->pFirstUart = NULL;
		}
	
	default:
		break;
	}



	switch(pCard->CardType)
	{	
	case Speed2and4_Pci_8BitBus:
	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		break;

	default:
		GetCardSettings(pCard->DeviceObject);	// Get Card settings if present.

#ifdef WMI_SUPPORT
		// Register for WMI
		SpeedCard_WmiInitializeWmilibContext(&pCard->WmiLibInfo);
		IoWMIRegistrationControl(pCard->DeviceObject, WMIREG_ACTION_REGISTER);
#endif
		break;
	}


	return status;


Error:

	if(bInterruptConnnected)
		IoDisconnectInterrupt(pCard->Interrupt);	// Disconnect Interrupt.

	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast8_Isa:
	case Fast16_Isa:	
	case Fast4_Pci:
	case Fast8_Pci:
	case Fast16_Pci:
	case Fast16FMC_Pci:
	case RAS4_Pci:
	case RAS8_Pci:
		pCard->Controller = NULL;
		break;

	default:	// Speed cards
		if(pCard->Controller)	// If mapped in.
		{
			MmUnmapIoSpace(pCard->Controller, pCard->SpanOfController);	// Unmap.
			pCard->Controller = NULL;
		}

		break;
	}


	if(pCard->LocalConfigRegisters)	// If PCI Config registers are mapped in.
	{
		MmUnmapIoSpace(pCard->LocalConfigRegisters, pCard->SpanOfPCIConfigRegisters);	// Unmap.
		pCard->LocalConfigRegisters = NULL;
	}


	UL_DeInitUartLibrary(&pCard->UartLib);	// DeInit table of UART library functions pointers.

	switch(status)
	{
	case STATUS_DEVICE_DOES_NOT_EXIST:
	case STATUS_UNSUCCESSFUL:
		{
			sprintf(szErrorMsg, "Card at %08lX: Unrecognised or malfunctioning.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	case STATUS_INSUFFICIENT_RESOURCES:
		{
			sprintf(szErrorMsg, "Card at %08lX: Insufficient resources.", pCard->PhysAddr);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	default:
		break;

	}



	return status;
}

NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardStop for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));
	
	// Stop Card from interrupting

	IoDisconnectInterrupt(pCard->Interrupt);		// Disconnect from Interrupt.
	
	
#ifdef WMI_SUPPORT
	switch(pCard->CardType)
	{	
	case Speed2and4_Pci_8BitBus:
	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		break;

	default:
		// Deregister for WMI
		IoWMIRegistrationControl(pCard->DeviceObject, WMIREG_ACTION_DEREGISTER);
		break;
	}
#endif


	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast8_Isa:
	case Fast16_Isa:	
	case Fast4_Pci:
	case Fast8_Pci:
	case Fast16_Pci:
	case Fast16FMC_Pci:
	case RAS4_Pci:
	case RAS8_Pci:
		pCard->Controller = NULL;
		break;

	default:	// Speed cards
		if(pCard->Controller)	// If mapped in.
		{
			MmUnmapIoSpace(pCard->Controller, pCard->SpanOfController);	// Unmap.
			pCard->Controller = NULL;
		}

		break;
	}

	// Unmap PCI card's Local Configuration Registers...
	if(pCard->LocalConfigRegisters)	// If mapped in.
	{
		MmUnmapIoSpace(pCard->LocalConfigRegisters, pCard->SpanOfPCIConfigRegisters);
		pCard->LocalConfigRegisters = NULL;
	}

	UL_DeInitUartLibrary(&pCard->UartLib);	// DeInit table of UART library functions pointers.


	pCard->InterfaceType			= InterfaceTypeUndefined;
	pCard->PhysAddr					= PhysicalZero;
	pCard->SpanOfController			= 0;
	pCard->OriginalIrql				= 0;
	pCard->OriginalVector			= 0;
	pCard->ProcessorAffinity		= 0;
	pCard->TrIrql					= 0;
	pCard->TrVector					= 0;
	pCard->Controller				= NULL;
	pCard->LocalConfigRegisters		= NULL;
	pCard->SpanOfPCIConfigRegisters = 0;

	return status;
}


NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardDeInit for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

    pCard->OurIsr				= NULL;
    pCard->OurIsrContext		= NULL;

	pCard->pFirstUart = NULL;

	return status;
}


NTSTATUS
XXX_PortInit(IN	PPORT_DEVICE_EXTENSION pPort)
{
	// Initialise port device extension.	

	PCARD_DEVICE_EXTENSION pCard	= pPort->pParentCardExt;
	NTSTATUS status					= STATUS_SUCCESS;
	SHORT PortType = 0;
	CHAR szTemp[50];		// Space to hold string 
	CHAR szCard[10];		// Space to hold card type string 
	SHORT i = 0;
	int Result = 0;
	INIT_UART InitUart;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortInit for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));
	
#ifndef BUILD_SPXMINIPORT
	// Form an InstanceID for the port.
	if(!SPX_SUCCESS(status = Spx_CreatePortInstanceID(pPort)))
		return status;
#endif

	switch(pCard->CardType)
	{
	case Fast4_Isa:
	case Fast4_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_8PIN_RJ45;	// 8 pin RJ45 ports	with Chase pinouts
		break;

	case Fast8_Isa:
	case Fast8_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_8PIN_XXXX;	// 8 pin ports 
		break;

	case Fast16_Isa:
	case Fast16_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_6PIN_XXXX;	// 6 pin ports 
		break;

	case Fast16FMC_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_8PIN_XXXX;	// 8 pin Full Modem Control (FMC) ports 
		break;

 	case RAS4_Pci:
	case RAS8_Pci:
		sprintf(szCard, "SPDRAS");	// RAS card
		PortType = MODEM_PORT;		// Modem Ports
		break;

	case Speed2_Pci:
		sprintf(szCard, "SPD2");	// Speed 2 card
		PortType = SPD_8PIN_RJ45;	// 8 pin RJ45 ports
		break;

	case Speed2P_Pci:
		sprintf(szCard, "SPD2P");	// Speed 2+ card
		PortType = SPD_10PIN_RJ45;	// 10 pin RJ45 ports
		break;

	case Speed4_Pci:
		sprintf(szCard, "SPD4");	// Speed 4 card
		PortType = SPD_8PIN_RJ45;	// 8 pin RJ45 ports
		break;

	case Speed4P_Pci:
		sprintf(szCard, "SPD4P");	// Speed 4+ card
		PortType = SPD_10PIN_RJ45;	// 10 pin RJ45 ports
		break;

	default:
		sprintf(szCard, "XXX");		// Unknown card type
		break;
	}



	// Initialise device identifiers... 
	switch(PortType)
	{	
	case FAST_8PIN_RJ45:
		sprintf(szTemp,"FAST\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"FAST\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Chase FAST Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case FAST_8PIN_XXXX:
		sprintf(szTemp,"FAST\\%s&8PINXXXX", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"FAST\\%s&8PINXXXX", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Chase FAST Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case FAST_6PIN_XXXX:
		sprintf(szTemp,"FAST\\%s&6PINXXXX", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"FAST\\%s&6PINXXXX", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Chase FAST Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case MODEM_PORT:
		sprintf(szTemp,"SPDRAS\\RASPort");
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPDRAS\\RASPort");
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Chase RAS Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case SPD_8PIN_RJ45:
		sprintf(szTemp,"SPEED\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPEED\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Specialix SPEED Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case SPD_10PIN_RJ45:
		sprintf(szTemp,"SPEED\\%s&10PINRJ45", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPEED\\%s&10PINRJ45", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Specialix SPEED Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	default:
		sprintf(szTemp,"SPEED\\%s&XXXXXXXX", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPEED\\%s&XXXXXXXX", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);

		sprintf(szTemp,"Specialix Serial Port %d of Unknown Type.", pPort->PortNumber + 1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);

		status = STATUS_UNSUCCESSFUL;
		break;
	}


/* Not required as we are using INF file 
	i = sprintf(szTemp, "Port %d on ", pPort->PortNumber + 1);

	sprintf(szTemp+i, "PCI Card 0x%08lX", pCard->PhysAddr);

	Spx_InitMultiString(FALSE, &pPort->DevLocation, szTemp, NULL);
*/



	pPort->pUartLib = &pCard->UartLib;	// Store pointer to UART library functions in port.

	// Set base address of port
	InitUart.UartNumber		= pPort->PortNumber;
	InitUart.BaseAddress	= pCard->Controller + (pPort->PortNumber * pCard->UARTOffset);
	InitUart.RegisterStride = pCard->UARTRegStride;
	InitUart.ClockFreq		= pCard->ClockRate; 
	
	if(pPort->pUartLib->UL_InitUart_XXXX(&InitUart, pCard->pFirstUart, &(pPort->pUart)) != UL_STATUS_SUCCESS)
	{
		pPort->pUartLib = NULL;	// NULL pointer to UART library functions.
		return STATUS_UNSUCCESSFUL;
	}

	pPort->pUartLib->UL_SetAppBackPtr_XXXX(pPort->pUart, pPort);	// Set back ptr.

	if(pCard->pFirstUart == NULL)
		pCard->pFirstUart = pPort->pUart;

	pPort->Interrupt = pCard->Interrupt;



/*	pPort->RFLAddress = pCard->LocalConfigRegisters + URL + pPort->PortNumber;
	pPort->TFLAddress = pCard->LocalConfigRegisters + UTL + pPort->PortNumber;
//	pPort->InterruptStatus = pCard->LocalConfigRegisters
*/
	return status;
}




NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	SET_BUFFER_SIZES BufferSizes;
	UART_INFO	UartInfo;
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortStart for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	if(!KeSynchronizeExecution(pPort->Interrupt, SerialResetAndVerifyUart, pPort->DeviceObject))	// Verify UART exists.
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Failed to find 16Cx5x Port %d.\n", PRODUCT_NAME, pPort->PortNumber));
		return STATUS_UNSUCCESSFUL;
	}

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Found 16Cx5x Port %d.\n", PRODUCT_NAME, pPort->PortNumber));
	
	KeSynchronizeExecution(pPort->Interrupt, SerialReset, pPort);		// Resets the port

	pPort->pUartLib->UL_GetUartInfo_XXXX(pPort->pUart, &UartInfo);	// Get UART Capabilities


	switch(pCard->CardType)
	{
	case Fast4_Isa:
	case Fast4_Pci:
	case Fast8_Isa:
	case Fast8_Pci:
	case Fast16_Isa:
	case Fast16_Pci:
	case Fast16FMC_Pci:
	case RAS4_Pci:
	case RAS8_Pci:
		{
			pPort->MaxTxFIFOSize		= UartInfo.MaxTxFIFOSize;	// Max Tx FIFO Size.
			pPort->MaxRxFIFOSize		= UartInfo.MaxRxFIFOSize;	// Max Rx FIFO Size.
			pPort->TxFIFOSize			= pPort->MaxTxFIFOSize;		// Default Tx FIFO Size.
			pPort->RxFIFOSize			= pPort->MaxRxFIFOSize;		// Default Rx FIFO Size.
			pPort->TxFIFOTrigLevel		= 8;						// Default Tx FIFO Trigger Level. 
			pPort->RxFIFOTrigLevel		= 56;						// Default Rx FIFO Trigger Level.
			pPort->LoFlowCtrlThreshold	= 16;						// Default Low Flow Control Threshold.
			pPort->HiFlowCtrlThreshold	= 60;						// Default High Flow Control Threshold.
			break;
		}

	case Speed2_Pci:
	case Speed2P_Pci:
	case Speed4_Pci:
	case Speed4P_Pci:
		{
			pPort->MaxTxFIFOSize		= UartInfo.MaxTxFIFOSize;	// Max Tx FIFO Size.
			pPort->MaxRxFIFOSize		= UartInfo.MaxRxFIFOSize;	// Max Rx FIFO Size.
			pPort->TxFIFOSize			= pPort->MaxTxFIFOSize;		// Default Tx FIFO Size.
			pPort->RxFIFOSize			= pPort->MaxRxFIFOSize;		// Default Rx FIFO Size.
			pPort->TxFIFOTrigLevel		= 16;						// Default Tx FIFO Trigger Level. 
			pPort->RxFIFOTrigLevel		= 100;						// Default Rx FIFO Trigger Level.
			pPort->LoFlowCtrlThreshold	= 16;						// Default Low Flow Control Threshold.
			pPort->HiFlowCtrlThreshold	= 112;						// Default High Flow Control Threshold.
			break;
		}

	default:
		break;
	}


#ifdef WMI_SUPPORT
	// Store Default FIFO settings for WMI
	pPort->SpeedWmiFifoProp.MaxTxFiFoSize				= pPort->MaxTxFIFOSize;
	pPort->SpeedWmiFifoProp.MaxRxFiFoSize				= pPort->MaxRxFIFOSize;
	pPort->SpeedWmiFifoProp.DefaultTxFiFoLimit			= pPort->TxFIFOSize;
	pPort->SpeedWmiFifoProp.DefaultTxFiFoTrigger		= pPort->TxFIFOTrigLevel;
	pPort->SpeedWmiFifoProp.DefaultRxFiFoTrigger		= pPort->RxFIFOTrigLevel;
	pPort->SpeedWmiFifoProp.DefaultLoFlowCtrlThreshold	= pPort->LoFlowCtrlThreshold;
	pPort->SpeedWmiFifoProp.DefaultHiFlowCtrlThreshold	= pPort->HiFlowCtrlThreshold;
#endif

	GetPortSettings(pPort->DeviceObject);	// Get Saved Port Settings if present.

	// Initialize the list heads for the read, write, and mask queues... 
	InitializeListHead(&pPort->ReadQueue);
	InitializeListHead(&pPort->WriteQueue);
	InitializeListHead(&pPort->MaskQueue);
	InitializeListHead(&pPort->PurgeQueue);

	// Initialize the spinlock associated with fields read (& set) by IO Control functions... 
	KeInitializeSpinLock(&pPort->ControlLock);

	// Initialize the timers used to timeout operations... 
	KeInitializeTimer(&pPort->ReadRequestTotalTimer);
	KeInitializeTimer(&pPort->ReadRequestIntervalTimer);
	KeInitializeTimer(&pPort->WriteRequestTotalTimer);
	KeInitializeTimer(&pPort->ImmediateTotalTimer);
	KeInitializeTimer(&pPort->XoffCountTimer);
	KeInitializeTimer(&pPort->LowerRTSTimer);

	// Initialise the dpcs that will be used to complete or timeout various IO operations... 
	KeInitializeDpc(&pPort->CommWaitDpc, SerialCompleteWait, pPort);
	KeInitializeDpc(&pPort->CompleteReadDpc, SerialCompleteRead, pPort);
	KeInitializeDpc(&pPort->CompleteWriteDpc, SerialCompleteWrite, pPort);
	KeInitializeDpc(&pPort->TotalImmediateTimeoutDpc, SerialTimeoutImmediate, pPort);
	KeInitializeDpc(&pPort->TotalReadTimeoutDpc, SerialReadTimeout, pPort);
	KeInitializeDpc(&pPort->IntervalReadTimeoutDpc, SerialIntervalReadTimeout, pPort);
	KeInitializeDpc(&pPort->TotalWriteTimeoutDpc, SerialWriteTimeout, pPort);
	KeInitializeDpc(&pPort->CommErrorDpc, SerialCommError, pPort);
	KeInitializeDpc(&pPort->CompleteImmediateDpc, SerialCompleteImmediate, pPort);
	KeInitializeDpc(&pPort->XoffCountTimeoutDpc, SerialTimeoutXoff, pPort);
	KeInitializeDpc(&pPort->XoffCountCompleteDpc, SerialCompleteXoff, pPort);
	KeInitializeDpc(&pPort->StartTimerLowerRTSDpc, SerialStartTimerLowerRTS, pPort);
	KeInitializeDpc(&pPort->PerhapsLowerRTSDpc, SerialInvokePerhapsLowerRTS, pPort);


	// Default device control fields... 
	pPort->SpecialChars.XonChar			= SERIAL_DEF_XON;
	pPort->SpecialChars.XoffChar		= SERIAL_DEF_XOFF;
	pPort->HandFlow.ControlHandShake	= SERIAL_DTR_CONTROL;
	pPort->HandFlow.FlowReplace			= SERIAL_RTS_CONTROL;


	// Define which baud rates can be supported... 
	pPort->SupportedBauds = SERIAL_BAUD_USER;

	pPort->UartConfig.TxBaud = 75;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_075;

	pPort->UartConfig.TxBaud = 110;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_110;

	pPort->UartConfig.TxBaud = 134;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_134_5;

	pPort->UartConfig.TxBaud = 150;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_150;

	pPort->UartConfig.TxBaud = 300;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_300;

	pPort->UartConfig.TxBaud = 600;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_600;

	pPort->UartConfig.TxBaud = 1200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_1200;

	pPort->UartConfig.TxBaud = 1800;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_1800;

	pPort->UartConfig.TxBaud = 2400;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_2400;

	pPort->UartConfig.TxBaud = 4800;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_4800;

	pPort->UartConfig.TxBaud = 7200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_7200;

	pPort->UartConfig.TxBaud = 9600;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_9600;

	pPort->UartConfig.TxBaud = 14400;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_14400;

	pPort->UartConfig.TxBaud = 19200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_19200;

	pPort->UartConfig.TxBaud = 38400;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_38400;

	pPort->UartConfig.TxBaud = 56000;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_56K;

	pPort->UartConfig.TxBaud = 57600;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_57600;

	pPort->UartConfig.TxBaud = 115200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_115200;

	pPort->UartConfig.TxBaud = 128000;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_128K;


	// Default line configuration: 1200,E,7,1 
	pPort->UartConfig.TxBaud	= 1200;
	pPort->LineControl			= SERIAL_EVEN_PARITY | SERIAL_7_DATA | SERIAL_1_STOP;
	pPort->ValidDataMask		= 0x7F;

	// Set Frame Config 
	pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_DATALEN_MASK) | UC_FCFG_DATALEN_7;
	pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_PARITY_MASK) | UC_FCFG_EVEN_PARITY;
	pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_STOPBITS_MASK) | UC_FCFG_STOPBITS_1;




    // Mark this device as not being opened by anyone.  We keep a variable
	// around so that spurious interrupts are easily dismissed by the ISR.
    pPort->DeviceIsOpen		= FALSE;


//	pPort->UartConfig.SpecialMode |= UC_SM_LOOPBACK_MODE;   // Internal Loopback mode

	// Set up values for interval timing... 
	
	// Store values into the extension for interval timing. If the interval
	// timer is less than a second then come in with a short "polling" loop.
    // For large (> then 2 seconds) use a 1 second poller.
    pPort->ShortIntervalAmount.QuadPart = -1;
    pPort->LongIntervalAmount.QuadPart	= -10000000;
    pPort->CutOverAmount.QuadPart		= 200000000;


#ifdef WMI_SUPPORT
	//
	// Fill in WMI hardware data
	//

	pPort->WmiHwData.IrqNumber			= pCard->TrIrql;
	pPort->WmiHwData.IrqVector			= pCard->TrVector;
	pPort->WmiHwData.IrqLevel			= pCard->TrIrql;
	pPort->WmiHwData.IrqAffinityMask	= pCard->ProcessorAffinity;
	
	if(pCard->InterruptMode == Latched)
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LATCHED;
	else
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LEVEL;

	pPort->WmiHwData.BaseIOAddress = (ULONG_PTR)pCard->Controller;


	//
	// Fill in WMI device state data (as defaults)
	//

	pPort->WmiCommData.BaudRate					= pPort->UartConfig.TxBaud;
	UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
	UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);

	pPort->WmiCommData.MaximumBaudRate			= 115200U;	// 115200k baud max
	pPort->WmiCommData.MaximumOutputBufferSize	= (UINT32)((ULONG)-1);
	pPort->WmiCommData.MaximumInputBufferSize	= (UINT32)((ULONG)-1);

	pPort->WmiCommData.Support16BitMode			= FALSE;
	pPort->WmiCommData.SupportDTRDSR			= TRUE;
	pPort->WmiCommData.SupportIntervalTimeouts	= TRUE;
	pPort->WmiCommData.SupportParityCheck		= TRUE;
	pPort->WmiCommData.SupportRTSCTS			= TRUE;
	pPort->WmiCommData.SupportXonXoff			= TRUE;
	pPort->WmiCommData.SettableBaudRate			= TRUE;
	pPort->WmiCommData.SettableDataBits			= TRUE;
	pPort->WmiCommData.SettableFlowControl		= TRUE;
	pPort->WmiCommData.SettableParity			= TRUE;
	pPort->WmiCommData.SettableParityCheck		= TRUE;
	pPort->WmiCommData.SettableStopBits			= TRUE;
	pPort->WmiCommData.IsBusy					= FALSE;


	// Fill in wmi perf data (all zero's)
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));



	//
    // Register for WMI
	//
	
	SpeedPort_WmiInitializeWmilibContext(&pPort->WmiLibInfo);

	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_REGISTER);
#endif


	// Initialise the port hardware... 
	KeSynchronizeExecution(pPort->Interrupt, SerialReset, pPort);					// Resets the port
	KeSynchronizeExecution(pPort->Interrupt, ApplyInitialPortSettings, pPort);		// Apply settings
	KeSynchronizeExecution(pPort->Interrupt, SerialMarkClose, pPort);				// Disables the FIFO 
	KeSynchronizeExecution(pPort->Interrupt, SerialClrRTS, pPort);					// Clear RTS signal
	KeSynchronizeExecution(pPort->Interrupt, SerialClrDTR, pPort);					// Clear DTR signal 
	
	return status;
}


NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortStop for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

#ifdef WMI_SUPPORT
	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_DEREGISTER);

	RtlZeroMemory(&pPort->WmiLibInfo, sizeof(WMILIB_CONTEXT));
#endif

	// Cancel timers...
    KeCancelTimer(&pPort->ReadRequestTotalTimer);
    KeCancelTimer(&pPort->ReadRequestIntervalTimer);
    KeCancelTimer(&pPort->WriteRequestTotalTimer);
    KeCancelTimer(&pPort->ImmediateTotalTimer);
    KeCancelTimer(&pPort->XoffCountTimer);
	KeCancelTimer(&pPort->LowerRTSTimer);

	// Cancel pending DPCs...
	KeRemoveQueueDpc(&pPort->CommWaitDpc);
	KeRemoveQueueDpc(&pPort->CompleteReadDpc);
	KeRemoveQueueDpc(&pPort->CompleteWriteDpc);
	KeRemoveQueueDpc(&pPort->TotalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->IntervalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->TotalWriteTimeoutDpc);
	KeRemoveQueueDpc(&pPort->CommErrorDpc);
	KeRemoveQueueDpc(&pPort->CompleteImmediateDpc);
	KeRemoveQueueDpc(&pPort->TotalImmediateTimeoutDpc);
	KeRemoveQueueDpc(&pPort->XoffCountTimeoutDpc);
	KeRemoveQueueDpc(&pPort->XoffCountCompleteDpc);
	KeRemoveQueueDpc(&pPort->StartTimerLowerRTSDpc);
	KeRemoveQueueDpc(&pPort->PerhapsLowerRTSDpc);

	KeSynchronizeExecution(pPort->Interrupt, SerialReset, pPort);		// Resets the port

	return status;
}

NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortDeInit for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	// If we are about to DeInit the first UART object to be serviced next
	// Make the pFirstUart point to the next UART in the list.
	if(pPort->pUart == pCard->pFirstUart)
		pCard->pFirstUart = pCard->UartLib.UL_GetUartObject_XXXX(pPort->pUart, UL_OP_GET_NEXT_UART);

	pCard->UartLib.UL_DeInitUart_XXXX(pPort->pUart);	// DeInit UART
	pPort->pUart = NULL;

	pPort->pUartLib = NULL;	// NULL pointer to UART library functions.


	// Free identifier string allocations... 
	if(pPort->DeviceID.Buffer != NULL)
		ExFreePool(pPort->DeviceID.Buffer);

	if(pPort->InstanceID.Buffer != NULL)
		ExFreePool(pPort->InstanceID.Buffer);
	
	if(pPort->HardwareIDs.Buffer != NULL)	
		ExFreePool(pPort->HardwareIDs.Buffer);

	if(pPort->DevDesc.Buffer != NULL)
		ExFreePool(pPort->DevDesc.Buffer);

	if(pPort->DevLocation.Buffer != NULL)
		ExFreePool(pPort->DevLocation.Buffer);


	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spx_disp.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Specialix Generic Dispatch Functions.				*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	29th September 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Dispatch entry points are routed here				*/
/*					for PnP/Power filtering before being				*/
/*					passed to the main functions:						*/
/*						Spx_Flush										*/
/*						Spx_Write										*/
/*						Spx_Read										*/
/*						Spx_IoControl									*/
/*						Spx_InternalIoControl							*/
/*						Spx_CreateOpen									*/
/*						Spx_Close										*/
/*						Spx_Cleanup										*/
/*						Spx_QueryInformationFile						*/
/*						Spx_SetInformationFile							*/
/*																		*/
/*						Spx_UnstallIRPs									*/
/*						Spx_KillStalledIRPs								*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	29/09/98 NPV	Creation.

*/

#define FILE_ID	SPX_DISP_C		// File ID for Event Logging see SPX_DEFS.H for values.

/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp);



/*****************************************************************************
********************************   Spx_Flush   *******************************
*****************************************************************************/

NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialFlush(pDevObject,pIrp);

	return(status);

} // End Spx_Flush 

/*****************************************************************************
********************************   Spx_Write   *******************************
*****************************************************************************/

NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialWrite(pDevObject,pIrp);

	return(status);

} // End Spx_Write 

/*****************************************************************************
********************************   Spx_Read   ********************************
*****************************************************************************/

NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialRead(pDevObject,pIrp);

	return(status);

} // End Spx_Read 

/*****************************************************************************
******************************   Spx_IoControl   *****************************
*****************************************************************************/

NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialIoControl(pDevObject,pIrp);

	return(status);

} // End Spx_IoControl 

/*****************************************************************************
**************************   Spx_InternalIoControl   *************************
*****************************************************************************/

NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = Spx_SerialInternalIoControl(pDevObject,pIrp);

	return(status);

} // Spx_InternalIoControl 

/*****************************************************************************
*****************************   Spx_CreateOpen   *****************************
*****************************************************************************/

NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;

	// Lock out state Query stop and Query remove IRPs from changing the state 
	// of the port part way through openening the port.
	ExAcquireFastMutex(&pPort->OpenMutex);
	
	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		if(pPort->DeviceIsOpen)					// Is port already open? 
		{
			status = STATUS_ACCESS_DENIED;		// Yes, deny access 
			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
		}
		else
			status = SerialCreateOpen(pDevObject,pIrp);

	}

	ExReleaseFastMutex(&pPort->OpenMutex);

	return(status);

} // End Spx_CreateOpen 

/*****************************************************************************
********************************   Spx_Close   *******************************
*****************************************************************************/

NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)		// Successful close if device is removed 
		{
			pPort->BufferSize = 0;
			SpxFreeMem(pPort->InterruptReadBuffer);
			pPort->InterruptReadBuffer = NULL;
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialClose(pDevObject,pIrp);

	return(status);

} // End Spx_Close 

/*****************************************************************************
*******************************   Spx_Cleanup   ******************************
*****************************************************************************/

NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)
		{
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		Spx_KillStalledIRPs(pDevObject);
		status = SerialCleanup(pDevObject,pIrp);
	}

	return(status);

} // End Spx_Cleanup 

/*****************************************************************************
************************   Spx_QueryInformationFile   ************************
*****************************************************************************/

NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	status = SerialQueryInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_QueryInformationFile 

/*****************************************************************************
*************************   Spx_SetInformationFile   *************************
*****************************************************************************/

NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialSetInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_SetInformationFile 

/*****************************************************************************
*****************************                    *****************************
*****************************   Spx_FilterIRPs   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Filter incoming SERIAL IRPs (except PNP and POWER) to check
				the current PNP/POWER states and return an NT status code to
				just complete the IRP if device is blocked for the following reasons:

parameters:		pDevObject points to the device object for this IRP
				pIrp points to the IRP to filter

returns:		NT Status Code

*/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	KIRQL					oldIrqlFlags;
	KIRQL					StalledOldIrql;
	LARGE_INTEGER delay;

	if(pIrpStack->MajorFunction == IRP_MJ_PNP)			// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_POWER)		// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_SYSTEM_CONTROL)	// Don't filter WMI IRPs 
		return(STATUS_SUCCESS);


	if(pPort->IsFDO)									// Don't filter card IRPs	
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction != IRP_MJ_PNP)
	{
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
	}


	KeAcquireSpinLock(&pPort->PnpPowerFlagsLock, &oldIrqlFlags);

	if(pPort->PnpPowerFlags & PPF_REMOVED)				// Has this object been "removed"? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		return(STATUS_NO_SUCH_DEVICE);
	}

	if(pPort->PnpPowerFlags & PPF_REMOVE_PENDING)		// Removing the device? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_DELETE_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_DELETE_PENDING);
	}


	if((pPort->PnpPowerFlags & PPF_STOP_PENDING)		// Device stopping?
	||(!(pPort->PnpPowerFlags & PPF_POWERED))			// Device not powered?
	||(!(pPort->PnpPowerFlags & PPF_STARTED)))			// Device not started?
	{
		KIRQL	oldIrql;

		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);


		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		
		while(pPort->UnstallingFlag) // We do not wish to add any more IRPs to the queue if have started unstalling those currently queued.
		{
			KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
			
			KeDelayExecutionThread(KernelMode, FALSE, &delay);

			KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		}

		pPort->UnstallingFlag = TRUE;

		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	


		IoAcquireCancelSpinLock(&oldIrql);

		if(pIrp->Cancel)				// Has IRP been cancelled? 
		{								// Yes 
			IoReleaseCancelSpinLock(oldIrql);
			SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_CANCELLED\n",
				PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
				
			return(STATUS_CANCELLED);
		}

// Mark the IRP as pending and queue on the stalled list... 
		pIrp->IoStatus.Status = STATUS_PENDING;		// Mark IRP as pending 
		IoMarkIrpPending(pIrp);
		InsertTailList(&pPort->StalledIrpQueue,&pIrp->Tail.Overlay.ListEntry);
		IoSetCancelRoutine(pIrp,Spx_FilterCancelQueued);
		IoReleaseCancelSpinLock(oldIrql);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_PENDING);
	}

	KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

	return(STATUS_SUCCESS);

} // End Spx_FilterIRPs 

/*****************************************************************************
*****************************                     ****************************
*****************************   Spx_UnstallIRPs   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)

description:	Restart all IRPs stored on the temporary stalled list.

parameters:		pPort points to the device extension to unstall

returns:		None

*/

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)
{
	PLIST_ENTRY			pIrpLink;
	PIRP				pIrp;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		pDevObj;
	PDRIVER_OBJECT		pDrvObj;
	KIRQL				oldIrql;
	KIRQL				StalledOldIrql;
	LARGE_INTEGER		delay;

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Entry\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));


	KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	
	while(pPort->UnstallingFlag)	// We do not unstall any queued IRPs if some one is just about to be added to the queue.
	{
		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

		delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
		
		KeDelayExecutionThread(KernelMode, FALSE, &delay);

		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	}

	pPort->UnstallingFlag = TRUE;

	KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	





	IoAcquireCancelSpinLock(&oldIrql);
	pIrpLink = pPort->StalledIrpQueue.Flink;

// Restart each waiting IRP on the stalled list... 

	while(pIrpLink != &pPort->StalledIrpQueue)
	{
		pIrp = CONTAINING_RECORD(pIrpLink,IRP,Tail.Overlay.ListEntry);
		pIrpLink = pIrp->Tail.Overlay.ListEntry.Flink;
		RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
		pDevObj = pIrpStack->DeviceObject;
		pDrvObj = pDevObj->DriverObject;
		IoSetCancelRoutine(pIrp,NULL);
		IoReleaseCancelSpinLock(oldIrql);

		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Unstalling IRP 0x%X, Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,
			pIrp,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj,pIrp);
		IoAcquireCancelSpinLock(&oldIrql);
	}

	IoReleaseCancelSpinLock(oldIrql);

	ClearUnstallingFlag(pPort);

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Exit\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

} // End Spx_UnstallIRPs 

/*****************************************************************************
*************************                            *************************
*************************   Spx_FilterCancelQueued   *************************
*************************                            *************************
******************************************************************************

prototype:		VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)

description:	Routine to cancel IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue
				pIrp points to the IRP to cancel

returns:		None

*/

VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PIO_STACK_LOCATION		pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pIrp->IoStatus.Status = STATUS_CANCELLED;
	pIrp->IoStatus.Information = 0;

	RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
	IoReleaseCancelSpinLock(pIrp->CancelIrql);

} // End Spx_FilterCancelQueued 


/*****************************************************************************
***************************                         **************************
***************************   Spx_KillStalledIRPs   **************************
***************************                         **************************
******************************************************************************

prototype:		VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)

description:	Kill all IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue

returns:		None

*/

VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PDRIVER_CANCEL			cancelRoutine;
	KIRQL					cancelIrql;

	IoAcquireCancelSpinLock(&cancelIrql);

// Call the cancel routine of all IRPs queued on the stalled list... 

	while(!IsListEmpty(&pPort->StalledIrpQueue))
	{
		PIRP	pIrp = CONTAINING_RECORD(pPort->StalledIrpQueue.Blink, IRP, Tail.Overlay.ListEntry);

		RemoveEntryList(pPort->StalledIrpQueue.Blink);
		cancelRoutine = pIrp->CancelRoutine;		// Get the cancel routine for this IRP 
		pIrp->CancelIrql = cancelIrql;
		pIrp->CancelRoutine = NULL;
		pIrp->Cancel = TRUE;

		cancelRoutine(pDevObj,pIrp);				// Call the cancel routine 

		IoAcquireCancelSpinLock(&cancelIrql);
	}

	IoReleaseCancelSpinLock(cancelIrql);

} // End Spx_KillStalledIRPs 

// End of SPX_DISP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spxutils.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_UTILS.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Utility functions.													*
*																						*
****************************************************************************************/

#define FILE_ID	SPX_UTILS_C		// File ID for Event Logging see SPX_DEFS.H for values.

// Paging...  
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_InitMultiString)
#pragma alloc_text (PAGE, Spx_GetRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_PutRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_LogMessage)
#pragma alloc_text (PAGE, Spx_LogError)
#pragma alloc_text (PAGE, Spx_MemCompare)
#endif


/////////////////////////////////////////////////////////////////////////////////////////
//	
//	Description:
//
//		This routine will take a null terminated list of ascii strings and combine
//		them together to generate a unicode multi-string block
//
//	Arguments:
//
//		Multi		- TRUE if a MULTI_SZ list is required, FALSE for a simple UNICODE
//
//		MultiString - a unicode structure in which a multi-string will be built
//		...         - a null terminated list of narrow strings which will be
//			       combined together. This list must contain at least a trailing NULL
//
//	Return Value:
//
//		NTSTATUS
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...)
{

	ANSI_STRING ansiString;
	NTSTATUS status;
	PCSTR rawString;
	PWSTR unicodeLocation;
	ULONG multiLength = 0;
	UNICODE_STRING unicodeString;
	va_list ap;
	ULONG i;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	va_start(ap,MultiString);
  
	// Make sure that we won't leak memory
	ASSERT(MultiString->Buffer == NULL);

	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{
		RtlInitAnsiString(&ansiString, rawString);
		multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
		rawString = va_arg(ap, PCSTR);
	}

	va_end( ap );

	if (multiLength == 0) 
	{
		// Done
		RtlInitUnicodeString(MultiString, NULL);
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (1)\n", PRODUCT_NAME));

		return STATUS_SUCCESS;
	}

	

	if(multi)
		multiLength += sizeof(WCHAR);	// We need an extra null if we want a MULTI_SZ list


	MultiString->MaximumLength = (USHORT)multiLength;
	MultiString->Buffer = SpxAllocateMem(PagedPool, multiLength);
	MultiString->Length = 0;

	if (MultiString->Buffer == NULL) 
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (2) - FAILURE\n", PRODUCT_NAME));

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	SpxDbgMsg(SPX_MISC_DBG, ("%s: Allocated %lu bytes for buffer\n", PRODUCT_NAME, multiLength));

#if DBG
	RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

	unicodeString.Buffer = MultiString->Buffer;
	unicodeString.MaximumLength = (USHORT) multiLength;

	va_start(ap, MultiString);
	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{

		RtlInitAnsiString(&ansiString,rawString);
		status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

		// We don't allocate memory, so if something goes wrong here,
		// its the function that's at fault
		ASSERT(SPX_SUCCESS(status));

		// Check for any commas and replace them with NULLs
		ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

		for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) 
		{
			if (unicodeString.Buffer[i] == L'\x2C' || unicodeString.Buffer[i] == L'\x0C' ) 
			{
				unicodeString.Buffer[i] = L'\0'; 
			}
		}


		SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer: %ws\n", PRODUCT_NAME, unicodeString.Buffer));

		// Move the buffers along
		unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
		unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
		unicodeString.Length = 0;

		// Next
		rawString = va_arg(ap, PCSTR);

	} // while

	va_end(ap);

	if(multi)
	{
		ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));
	}
	else
	{
		ASSERT(unicodeString.MaximumLength == 0);
	}


	// Stick the final null there
 	SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer last addr: 0x%X\n", PRODUCT_NAME, unicodeString.Buffer));

	if(multi)
		unicodeString.Buffer[0] = L'\0'; 		// We need an extra null if we want a MULTI_SZ list


	MultiString->Length = (USHORT)multiLength - sizeof(WCHAR);
	MultiString->MaximumLength = (USHORT)multiLength;

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (3) - SUCCESS\n", PRODUCT_NAME));

	return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:	
//		Reads a registry key value from an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		KeyNameString       ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//
//		Data                Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	)

{

	UNICODE_STRING              keyName;
	ULONG                       length;
	PKEY_VALUE_FULL_INFORMATION fullInfo;

	NTSTATUS                    status = STATUS_INSUFFICIENT_RESOURCES;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Enter Spx_GetRegistryKeyValue\n", PRODUCT_NAME));


	RtlInitUnicodeString (&keyName, KeyNameString);

	length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength + DataLength;
	fullInfo = SpxAllocateMem(PagedPool, length); 

	if(fullInfo) 
	{
		status = ZwQueryValueKey(	Handle,
									&keyName,
									KeyValueFullInformation,
									fullInfo,
									length,
									&length);

		if(SPX_SUCCESS(status)) 
		{
			// If there is enough room in the data buffer, copy the output
			if(DataLength >= fullInfo->DataLength) 
				RtlCopyMemory (Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, fullInfo->DataLength);
		}

		SpxFreeMem(fullInfo);
	}

	return status;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//
//		Writes a registry key value to an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		PKeyNameString      ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//    
//		Dtype				REG_XYZ value type
//
//		PData               Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	)
{

	NTSTATUS status;
	UNICODE_STRING keyname;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Enter Spx_PutRegistryKeyValue\n", PRODUCT_NAME));

	RtlInitUnicodeString(&keyname, NULL);
	keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
	keyname.Buffer = SpxAllocateMem(PagedPool, keyname.MaximumLength);

	if(keyname.Buffer == NULL) 
		  return STATUS_INSUFFICIENT_RESOURCES;

	RtlAppendUnicodeToString(&keyname, PKeyNameString);

	status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

	SpxFreeMem(keyname.Buffer);

	return status;
}




VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp)	// Limited to 51 characters + 1 null
{
	
	UNICODE_STRING ErrorMsg;

	ErrorMsg.Length = 0;
	ErrorMsg.Buffer = 0;
	Spx_InitMultiString(FALSE, &ErrorMsg, szTemp, NULL);


	switch(MessageSeverity)
	{
	case STATUS_SEVERITY_SUCCESS:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_SUCCESS,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;
	
	case STATUS_SEVERITY_INFORMATIONAL:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_INFORMATIONAL,			// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_WARNING:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_WARNING,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_ERROR:
	default:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_ERROR,					// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	}

	if(ErrorMsg.Buffer != NULL)
		SpxFreeMem(ErrorMsg.Buffer);

}

/////////////////////////////////////////////////////////////////////////////////////////
//																
//	Spx_LogError														
//															
/////////////////////////////////////////////////////////////////////////////////////////
/*
	Routine Description:

		This routine allocates an error log entry, copies the supplied data
		to it, and requests that it be written to the error log file.

	Arguments:

		DriverObject - A pointer to the driver object for the device.

		DeviceObject - A pointer to the device object associated with the
		device that had the error, early in initialization, one may not
		yet exist.

		P1,P2 - If phyical addresses for the controller ports involved
		with the error are available, put them through as dump data.

		SequenceNumber - A ulong value that is unique to an IRP over the
		life of the irp in this driver - 0 generally means an error not
		associated with an irp.

		MajorFunctionCode - If there is an error associated with the irp,
		this is the major function code of that irp.

		RetryCount - The number of times a particular operation has been retried.

		UniqueErrorValue - A unique long word that identifies the particular
		call to this function.

		FinalStatus - The final status given to the irp that was associated
		with this error.  If this log entry is being made during one of
		the retries this value will be STATUS_SUCCESS.

		SpecificIOStatus - The IO status for a particular error.

		LengthOfInsert1 - The length in bytes (including the terminating NULL)
						  of the first insertion string.

		Insert1 - The first insertion string.

		LengthOfInsert2 - The length in bytes (including the terminating NULL)
						  of the second insertion string.  NOTE, there must
						  be a first insertion string for their to be
						  a second insertion string.

		Insert2 - The second insertion string.

	Return Value:	None.
*/


VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	)
{

	PIO_ERROR_LOG_PACKET ErrorLogEntry;

	PVOID objectToUse;
	SHORT dumpToAllocate = 0;
	PUCHAR ptrToFirstInsert;
	PUCHAR ptrToSecondInsert;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(Insert1 == NULL) 
		LengthOfInsert1 = 0;

	if(Insert2 == NULL) 
		LengthOfInsert2 = 0;


	if(ARGUMENT_PRESENT(DeviceObject)) 
		objectToUse = DeviceObject;
	else 
		objectToUse = DriverObject;


	if(Spx_MemCompare(P1, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	if(Spx_MemCompare(P2, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	ErrorLogEntry = IoAllocateErrorLogEntry(objectToUse,
											(UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + dumpToAllocate 
											+ LengthOfInsert1 + LengthOfInsert2)	
											);

	if(ErrorLogEntry != NULL) 
	{
		ErrorLogEntry->ErrorCode			= SpecificIOStatus;
		ErrorLogEntry->SequenceNumber		= SequenceNumber;
		ErrorLogEntry->MajorFunctionCode	= MajorFunctionCode;
		ErrorLogEntry->RetryCount			= RetryCount;
		ErrorLogEntry->UniqueErrorValue		= UniqueErrorValue;
		ErrorLogEntry->FinalStatus			= FinalStatus;
		ErrorLogEntry->DumpDataSize			= dumpToAllocate;

		
		if(dumpToAllocate) 
		{
			RtlCopyMemory(&ErrorLogEntry->DumpData[0], &P1,	sizeof(PHYSICAL_ADDRESS));

			if(dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) 
			{
				RtlCopyMemory(	((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS),
								&P2,
								sizeof(PHYSICAL_ADDRESS)
								);

				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + (2*sizeof(PHYSICAL_ADDRESS));

			} 
			else 
			{
				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS);
			}

		} 
		else 
		{
			ptrToFirstInsert = (PUCHAR)&ErrorLogEntry->DumpData[0];
		}

		ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

		if(LengthOfInsert1) 
		{
			ErrorLogEntry->NumberOfStrings	= 1;
			ErrorLogEntry->StringOffset		= (USHORT)(ptrToFirstInsert - (PUCHAR)ErrorLogEntry);

			RtlCopyMemory(ptrToFirstInsert, Insert1, LengthOfInsert1);

			if(LengthOfInsert2) 
			{
				ErrorLogEntry->NumberOfStrings = 2;
				RtlCopyMemory(ptrToSecondInsert, Insert2, LengthOfInsert2);
			}
		}


		IoWriteErrorLogEntry(ErrorLogEntry);

	}

}



SPX_MEM_COMPARES
Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB)
/*++
Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.
--*/
{
	LARGE_INTEGER a;
	LARGE_INTEGER b;

	LARGE_INTEGER lower;
	ULONG lowerSpan;
	LARGE_INTEGER higher;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	a = A;
	b = B;

	if(a.QuadPart == b.QuadPart) 
	  return AddressesAreEqual;


	if(a.QuadPart > b.QuadPart) 
	{
		higher = a;
		lower = b;
		lowerSpan = SpanOfB;
	} 
	else 
	{
		higher = b;
		lower = a;
		lowerSpan = SpanOfA;
	}

	if((higher.QuadPart - lower.QuadPart) >= lowerSpan)
      return AddressesAreDisjoint;


	return AddressesOverlap;
}


NTSTATUS
PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard)
{
	/******************************************************** 
	* Setting bit 17 in the CNTRL register of the PLX 9050	* 
	* chip forces a retry on writes while a read is pending.*
	* This is to prevent the card locking up on Intel Xeon  *
	* multiprocessor systems with the NX chipset.			*
	********************************************************/

	#define CNTRL_REG_OFFSET	0x14	// DWORD Offset (BYTE Offset 0x50) 
	
	NTSTATUS	status = STATUS_SUCCESS;
	PULONG		pPCIConfigRegisters = NULL;			// Pointer to PCI Config Registers.
	CHAR		szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering PLX_9050_CNTRL_REG_FIX for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	pPCIConfigRegisters = MmMapIoSpace(pCard->PCIConfigRegisters, pCard->SpanOfPCIConfigRegisters, FALSE);

	if(pPCIConfigRegisters != NULL)
	{
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */

		if(pPCIConfigRegisters[CNTRL_REG_OFFSET] == 0)	// If bit 7 is set Config Registers are zero (unreadable) 
		{
			// We have to blindly write the value to the register.
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;	// Set bits 17 & 21 of PLX CNTRL register 
		}
		else
		{	
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 1] &= ~0x40;		// Clear bit 14 of PLX CNTRL register
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;		// Set bits 17 & 21 of PLX CNTRL register
		}

		MmUnmapIoSpace(pPCIConfigRegisters, pCard->SpanOfPCIConfigRegisters);
	}
	else
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Insufficient resources available for Card %d.\n", 
			PRODUCT_NAME, pCard->CardNumber));
	
		sprintf(szErrorMsg, "Card at %08lX: Insufficient resources.", pCard->PhysAddr);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	return status;
}


//
// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	

	if(Set) 
		pDevExt->PnpPowerFlags |= Value;			
	else 
		pDevExt->PnpPowerFlags &= ~Value;	

	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->StalledIrpLock, &oldIrql);	

	pDevExt->UnstallingFlag = Set;			

	KeReleaseSpinLock(&pDevExt->StalledIrpLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
BOOLEAN
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll)
{
	KIRQL oldIrql;
	BOOLEAN bRet = FALSE; 

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	
	
	if(bAll)
	{
		// If all the requested SetFlags are set
		// and if all of the requested ClearedFlags are cleared then return true.
		if(((ulSetFlags & pDevExt->PnpPowerFlags) == ulSetFlags) && !(ulClearedFlags & pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}
	else
	{
		// If any of the requested SetFlags are set 
		// or if any of the requested ClearedFlags are cleared then return true.
		if((ulSetFlags & pDevExt->PnpPowerFlags) || (ulClearedFlags & ~pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}


	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);
	
	return bRet;
}




PVOID 
SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 

	pRet = ExAllocatePoolWithTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


PVOID 
SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 
	
	pRet = ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


#ifndef BUILD_SPXMINIPORT
void
SpxFreeMem(PVOID pMem)
{
	ASSERT(pMem != NULL);	// Assert if the pointer is NULL.

	ExFreePool(pMem);
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////
// Must be called just before an IoCompleteRequest if IrpCondition == IRP_SUBMITTED
//
///////////////////////////////////////////////////////////////////////////////////////////
VOID
SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition)
{
	PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	switch(pIrpStack->MajorFunction)		// Don't filter Plug and Play IRPs 
	{

	case IRP_MJ_FLUSH_BUFFERS:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.FlushIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.FlushIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.FlushIrpsQueued);
				pPort->PerfStats.FlushIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.FlushIrpsQueued);
				if(pPort->PerfStats.FlushIrpsQueued) 
					pPort->PerfStats.FlushIrpsQueued--;		// Decrement counter for performance stats.

				break;


			default:
				break;
			}

			break;
		}


	case IRP_MJ_WRITE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.WriteIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.WriteIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.WriteIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.WriteIrpsQueued);
				pPort->PerfStats.WriteIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.WriteIrpsQueued);
				if(pPort->PerfStats.WriteIrpsQueued) 
					pPort->PerfStats.WriteIrpsQueued--;		// Decrement counter for performance stats.

				break;

			default:
				break;
			}

			break;
		}

	case IRP_MJ_READ:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.ReadIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.ReadIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.ReadIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.ReadIrpsQueued);
				pPort->PerfStats.ReadIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.ReadIrpsQueued);
				if(pPort->PerfStats.ReadIrpsQueued) 
					pPort->PerfStats.ReadIrpsQueued--;		// Decrement counter for performance stats.
				
				break;


			default:
				break;
			}

			break;
		}

	case IRP_MJ_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.IoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.IoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InternalIoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InternalIoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}


	case IRP_MJ_CREATE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CreateIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CreateIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLOSE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CloseIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CloseIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLEANUP:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CleanUpIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CleanUpIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_QUERY_INFORMATION:
	case IRP_MJ_SET_INFORMATION:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InfoIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InfoIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}
	
	default:
		break;

	}
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    pPort - Pointer to a the Port Device Extension.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
{
    RtlZeroMemory(&pPort->PerfStats, sizeof(PORT_PERFORMANCE_STATS));

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spd_w2k.c ===
#include "precomp.h"    // Precompiled header

/****************************************************************************************
*                                                                                       *
*   Module:         SPD_W2K.C                                                           *
*                                                                                       *
*   Creation:       14th April 1999                                                     *
*                                                                                       *
*   Author:         Paul Smith                                                          *
*                                                                                       *
*   Version:        1.0.0                                                               *
*                                                                                       *
*   Description:    Functions specific to SPEED and Windows 2000                        *
*                                                                                       *
****************************************************************************************/

// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SpxGetNtCardType)
#endif


#define FILE_ID     SPD_W2K_C       // File ID for Event Logging see SPD_DEFS.H for values.


/*****************************************************************************
****************************                      ****************************
****************************   SpxGetNtCardType   ****************************
****************************                      ****************************
******************************************************************************

prototype:      ULONG   SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
    
description:    Return the NT defined card type for the specified card
                device object.

parameters:     pDevObject points to the NT device object for the card

returns:        NT defined card type,
                or -1 if not identified
*/

ULONG   SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
{
    PCARD_DEVICE_EXTENSION  pCard   = pDevObject->DeviceExtension;
    ULONG                   NtCardType = -1;
    PVOID                   pPropertyBuffer = NULL;
    ULONG                   ResultLength = 0; 
    NTSTATUS                status = STATUS_SUCCESS;
    ULONG                   BufferLength = 1;   // Initial size.

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);  // Allocate the buffer

    if(pPropertyBuffer == NULL)                                 // SpxAllocateMem failed.
        return -1;

    // Try to get HardwareID
    status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
                                    pPropertyBuffer, &ResultLength);

    if(!SPX_SUCCESS(status))                    // IoGetDeviceProperty failed.
    {
        if(status == STATUS_BUFFER_TOO_SMALL)   // Buffer was too small.
        {
            ExFreePool(pPropertyBuffer);            // Free old buffer that was not big enough.
            BufferLength = ResultLength + 1;        // Set BufferLength to size required.

            pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);  // Allocate a bigger buffer.

            if(pPropertyBuffer == NULL)         // SpxAllocateMem failed.
                return -1;

            // Try again.
            status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
                                            pPropertyBuffer, &ResultLength);

            if(!SPX_SUCCESS(status))            // IoGetDeviceProperty failed a second time.
            {
                ExFreePool(pPropertyBuffer);    // Free buffer.
                return -1;
            }
        }
        else
        {
            ExFreePool(pPropertyBuffer);            // Free buffer.
            return -1;
        }
    }



    // If we get to here then there is something in the PropertyBuffer.

    _wcsupr(pPropertyBuffer);       // Convert HardwareID to uppercase


    // Speed 2 adapters 
    if(wcsstr(pPropertyBuffer, SPD2_PCI_PCI954_HWID) != NULL)   // SPEED 2 Port Adapter
        NtCardType = Speed2_Pci;

    if(wcsstr(pPropertyBuffer, SPD2AND4_PCI_NO_F1_HWID) != NULL) // SPEED 2/4 Port Adapter Local Bus (unused)
        NtCardType = Speed2and4_Pci_8BitBus;
    

    if(wcsstr(pPropertyBuffer, SPD2P_PCI_PCI954_HWID) != NULL)  // SPEED+ 2 Port Adapter
        NtCardType = Speed2P_Pci;

    if(wcsstr(pPropertyBuffer, SPD2P_PCI_8BIT_LOCALBUS_HWID) != NULL)   // SPEED+ 2 Port Adapter Local bus (not used)
        NtCardType = Speed2P_Pci_8BitBus;


    // SPEED 4 adapters
    if(wcsstr(pPropertyBuffer, SPD4_PCI_PCI954_HWID) != NULL)   // SPEED 4 Port Adapter
        NtCardType = Speed4_Pci;


    if(wcsstr(pPropertyBuffer, SPD4P_PCI_PCI954_HWID) != NULL)  // SPEED+ 4 Port Adapter
        NtCardType = Speed4P_Pci;

    if(wcsstr(pPropertyBuffer, SPD4P_PCI_8BIT_LOCALBUS_HWID) != NULL)   // SPEED+ 4 Port Adapter Local bus (not used)
        NtCardType = Speed4P_Pci_8BitBus;



    // Chase Fast Cards
    if(wcsstr(pPropertyBuffer, FAST4_PCI_HWID) != NULL)     // PCI-Fast 4 Port Adapter
        NtCardType = Fast4_Pci;

    if(wcsstr(pPropertyBuffer, FAST8_PCI_HWID) != NULL)     // PCI-Fast 8 Port Adapter
        NtCardType = Fast8_Pci;

    if(wcsstr(pPropertyBuffer, FAST16_PCI_HWID) != NULL)    // PCI-Fast 16 Port Adapter
        NtCardType = Fast16_Pci;

    if(wcsstr(pPropertyBuffer, FAST16FMC_PCI_HWID) != NULL) // PCI-Fast 16 FMC Port Adapter
        NtCardType = Fast16FMC_Pci;

    if(wcsstr(pPropertyBuffer, AT_FAST4_HWID) != NULL)      // AT-Fast 4 Port Adapter
        NtCardType = Fast4_Isa;

    if(wcsstr(pPropertyBuffer, AT_FAST8_HWID) != NULL)      // AT-Fast 8 Port Adapter
        NtCardType = Fast8_Isa;

    if(wcsstr(pPropertyBuffer, AT_FAST16_HWID) != NULL)     // AT-Fast 16 Port Adapter
        NtCardType = Fast16_Isa;

    if(wcsstr(pPropertyBuffer, RAS4_PCI_HWID) != NULL)      // PCI-RAS 4 Multi-modem Adapter
        NtCardType = RAS4_Pci;

    if(wcsstr(pPropertyBuffer, RAS8_PCI_HWID) != NULL)      // PCI-RAS 8 Multi-modem Adapter
        NtCardType = RAS8_Pci;

    ExFreePool(pPropertyBuffer);            // Free buffer.

    return(NtCardType);

} // SpxGetNtCardType 



//////////////////////////////////////////////////////////////////////////////
// SetPortFiFoSettings
//
BOOLEAN SetPortFiFoSettings(PPORT_DEVICE_EXTENSION pPort)
{
    // Store current settings.
    ULONG TxFIFOSize                = pPort->BufferSizes.TxFIFOSize; 
    ULONG TxFIFOTrigLevel           = pPort->BufferSizes.TxFIFOTrigLevel; 
    ULONG RxFIFOTrigLevel           = pPort->BufferSizes.RxFIFOTrigLevel; 
    ULONG LoFlowCtrlThreshold       = pPort->UartConfig.LoFlowCtrlThreshold; 
    ULONG HiFlowCtrlThreshold       = pPort->UartConfig.HiFlowCtrlThreshold; 
    

    // Get Tx FIFO Limit.
    if((pPort->TxFIFOSize > 0) && (pPort->TxFIFOSize <= pPort->MaxTxFIFOSize))  // Check for good value.
    {   
        pPort->BufferSizes.TxFIFOSize = pPort->TxFIFOSize;
    }
    else
        goto SetFailure;


    // Get Tx FIFO Trigger Level.
    if(pPort->TxFIFOSize <= pPort->MaxTxFIFOSize)   // Check for good value.
    {
        pPort->BufferSizes.TxFIFOTrigLevel = (BYTE) pPort->TxFIFOTrigLevel;
    }
    else
        goto SetFailure;

    // Get Rx FIFO Trigger Level.
    if(pPort->RxFIFOTrigLevel <= pPort->MaxRxFIFOSize)  // Check for good value.
    {
        pPort->BufferSizes.RxFIFOTrigLevel = (BYTE) pPort->RxFIFOTrigLevel;
    }
    else
        goto SetFailure;

    // Attempt to change FIFO settings.
    if(pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT) != UL_STATUS_SUCCESS)
    {
        goto SetFailure;
    }





    // Get Low Flow Control Threshold Level.
    if(pPort->LoFlowCtrlThreshold <= pPort->MaxRxFIFOSize)  // Check for good value.
    {
        pPort->UartConfig.LoFlowCtrlThreshold = (BYTE) pPort->LoFlowCtrlThreshold;
    }
    else
        goto SetFailure;

    // Get High Flow Control Threshold Level.
    if(pPort->HiFlowCtrlThreshold <= pPort->MaxRxFIFOSize)  // Check for good value.
    {
        pPort->UartConfig.HiFlowCtrlThreshold = (BYTE) pPort->HiFlowCtrlThreshold;
    }
    else
        goto SetFailure;

    // Attempt to set the configuration.
    if(pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK) != UL_STATUS_SUCCESS)
    {
        goto SetFailure;
    }

    // Just do a quick get config to see if flow threshold have 
    // changed as a result of changing the FIFO triggers.
    pPort->pUartLib->UL_GetConfig_XXXX(pPort->pUart, &pPort->UartConfig);

    // Update FIFO Flow Control Levels
    pPort->LoFlowCtrlThreshold = pPort->UartConfig.LoFlowCtrlThreshold;
    pPort->HiFlowCtrlThreshold = pPort->UartConfig.HiFlowCtrlThreshold; 

    return TRUE;




// Restore all settings to the way they were.
SetFailure:

    // Restore settings.
    pPort->TxFIFOSize           = TxFIFOSize; 
    pPort->TxFIFOTrigLevel      = TxFIFOTrigLevel; 
    pPort->RxFIFOTrigLevel      = RxFIFOTrigLevel; 

    pPort->BufferSizes.TxFIFOSize       = TxFIFOSize;
    pPort->BufferSizes.TxFIFOTrigLevel  = (BYTE) TxFIFOTrigLevel;
    pPort->BufferSizes.RxFIFOTrigLevel  = (BYTE) RxFIFOTrigLevel;

    pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT);


    // Restore settings.
    pPort->LoFlowCtrlThreshold = LoFlowCtrlThreshold; 
    pPort->HiFlowCtrlThreshold = HiFlowCtrlThreshold; 

    pPort->UartConfig.LoFlowCtrlThreshold = LoFlowCtrlThreshold; 
    pPort->UartConfig.HiFlowCtrlThreshold = HiFlowCtrlThreshold; 

    pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK);


    return FALSE;

}



NTSTATUS GetPortSettings(PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
    HANDLE  PnPKeyHandle;
    ULONG   Data = 0;


    // Open PnP Reg Key
    if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle)))
    {
        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, TX_FIFO_LIMIT, sizeof(TX_FIFO_LIMIT), &Data, sizeof(ULONG))))
        {
            if((Data > 0) && (Data <= pPort->MaxTxFIFOSize))    // Check for good value.
                pPort->TxFIFOSize = Data;
        }
                                            
        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, TX_FIFO_TRIG_LEVEL, sizeof(TX_FIFO_TRIG_LEVEL), &Data, sizeof(ULONG))))
        {
            if(Data <= pPort->MaxTxFIFOSize)    // Check for good value.
                pPort->TxFIFOTrigLevel = Data;
        }

        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, RX_FIFO_TRIG_LEVEL, sizeof(RX_FIFO_TRIG_LEVEL), &Data, sizeof(ULONG))))
        {
            if(Data <= pPort->MaxRxFIFOSize)    // Check for good value.
                pPort->RxFIFOTrigLevel = Data;
        }

        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, LO_FLOW_CTRL_LEVEL, sizeof(LO_FLOW_CTRL_LEVEL), &Data, sizeof(ULONG))))
        {
            if(Data <= pPort->MaxRxFIFOSize)    // Check for good value.
                pPort->LoFlowCtrlThreshold = Data;
        }

        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, HI_FLOW_CTRL_LEVEL, sizeof(HI_FLOW_CTRL_LEVEL), &Data, sizeof(ULONG))))
        {
            if(Data <= pPort->MaxRxFIFOSize)    // Check for good value.
                pPort->HiFlowCtrlThreshold = Data;
        }

        ZwClose(PnPKeyHandle);
    }



    return STATUS_SUCCESS;
}



NTSTATUS GetCardSettings(PDEVICE_OBJECT pDevObject)
{
    PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
    HANDLE  PnPKeyHandle;
    ULONG   Data = 0;

    // Open PnP Reg Key
    if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle)))
    {

        if((pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
        {
            if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, DELAY_INTERRUPT, sizeof(DELAY_INTERRUPT), &Data, sizeof(ULONG))))
            {
                if(Data)
                {
                    if(!(pCard->CardOptions & DELAY_INTERRUPT_OPTION))  // If not already set then set the option
                    {
                        if(KeSynchronizeExecution(pCard->Interrupt, SetCardToDelayInterrupt, pCard))
                        {
                            pCard->CardOptions |= DELAY_INTERRUPT_OPTION;
                        }
                    }
                }
                else
                {
                    if(pCard->CardOptions & DELAY_INTERRUPT_OPTION) // If set then unset the option.
                    {
                        if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToDelayInterrupt, pCard))
                        {
                            pCard->CardOptions &= ~DELAY_INTERRUPT_OPTION;
                        }
                    }
                            
                }
            }
        }



        if(pCard->CardType == Fast16_Pci)   
        {
            if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, SWAP_RTS_FOR_DTR, sizeof(SWAP_RTS_FOR_DTR), &Data, sizeof(ULONG))))
            {
                if(Data)
                {
                    if(!(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)) // If not already set then set the option
                    {
                        if(KeSynchronizeExecution(pCard->Interrupt, SetCardToUseDTRInsteadOfRTS, pCard))
                        {
                            pCard->CardOptions |= SWAP_RTS_FOR_DTR_OPTION;
                        }
                    }
                }
                else
                {
                    if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)    // If set then unset the option.
                    {
                        if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToUseDTRInsteadOfRTS, pCard))
                        {
                            pCard->CardOptions &= ~SWAP_RTS_FOR_DTR_OPTION;
                        }
                    }
                        
                }
            }
        }




        if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, CLOCK_FREQ_OVERRIDE, sizeof(CLOCK_FREQ_OVERRIDE), &Data, sizeof(ULONG))))
        {
            if(Data > 0)
                pCard->ClockRate = Data;    // Store new clock rate to use.
        }


        ZwClose(PnPKeyHandle);
    }



    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spx_pnp.c ===
#include "precomp.h"    // Precompiled header

/****************************************************************************************
*                                                                                                                                                                               *
*       Module:                 SPX_PNP.C                                                                                                                       *
*                                                                                                                                                                               *
*       Creation:               27th September 1998                                                                                                     *
*                                                                                                                                                                               *
*       Author:                 Paul Smith                                                                                                                      *
*                                                                                                                                                                               *
*       Version:                1.0.0                                                                                                                           *
*                                                                                                                                                                               *
*       Description:    Generic Plug and Play Functions to handle PnP IRPS.                                     *
*                                                                                                                                                                               *
****************************************************************************************/
/* History...

1.0.0   27/09/98 PBS    Creation.

*/

#define FILE_ID         SPX_PNP_C               // File ID for Event Logging see SPX_DEFS.H for values.

 
/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp);
NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard);
NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp);
NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort);
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject);


// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_AddDevice)
#pragma alloc_text (PAGE, Spx_DispatchPnp)

#pragma alloc_text (PAGE, Spx_Card_FDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Card_StartDevice)
#pragma alloc_text (PAGE, Spx_Card_StopDevice)
#pragma alloc_text (PAGE, Spx_Card_RemoveDevice)

#pragma alloc_text (PAGE, Spx_CallDriverBelow)

#pragma alloc_text (PAGE, Spx_Port_PDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Port_StartDevice)
#pragma alloc_text (PAGE, Spx_Port_StopDevice)
#pragma alloc_text (PAGE, Spx_Port_RemoveDevice)

#pragma alloc_text (PAGE, Spx_EnumPorts)
#pragma alloc_text (PAGE, Spx_DoExternalNaming)
#pragma alloc_text (PAGE, Spx_GetExternalName)
#pragma alloc_text (PAGE, Spx_RemoveExternalNaming)
#pragma alloc_text (PAGE, Spx_CreatePortInstanceID)
#endif


#include <initguid.h>
#include <ntddser.h>


/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_AddDevice   ******************************
*****************************                   ******************************
******************************************************************************

prototype:              NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)

description:    Create a functional device object (FDO) for the specified card physical device object.

parameters:             pDriver point to the driver object
                                pPDO points to a card physical device object (PDO)

returns:                STATUS_SUCCESS
                                STATUS_NO_MORE_ENTRIES
*/

NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)
{
        NTSTATUS                                status = STATUS_SUCCESS;
        PDEVICE_OBJECT                  pDevObject = NULL;
        PCARD_DEVICE_EXTENSION  pCard = NULL;
        PDEVICE_OBJECT                  pLowerDevObject = NULL;
        static ULONG                    CardNumber = 0;
        ULONG                                   i = 0;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_AddDevice.\n", PRODUCT_NAME));

        if(pPDO == NULL)
        {
                SpxDbgMsg(SPX_MISC_DBG, ("%s: In Spx_AddDevice - No more entries.\n", PRODUCT_NAME));
                return(STATUS_NO_MORE_ENTRIES);
        }

/* Create the device object... */

        status = IoCreateDevice(pDriverObject,
                                                        sizeof(CARD_DEVICE_EXTENSION),
                                                        NULL,                                                   // Doesn't need a name.
                                                        FILE_DEVICE_CONTROLLER, 
                                                        FILE_DEVICE_SECURE_OPEN, 
                                                        TRUE, 
                                                        &pDevObject);

        if(!SPX_SUCCESS(status))
        {
                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed for card %d. CardExt at 0x%X.\n",
                        PRODUCT_NAME,CardNumber++,&pDevObject));

                sprintf(szErrorMsg, "Card %d: Failed IoCreateDevice.", CardNumber++);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pDriverObject,                                  // Driver Object
                                                NULL,                                                   // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                if(pDevObject)                                  // Clean up Device Object
                        IoDeleteDevice(pDevObject);

                SpxDbgMsg(SPX_ERRORS, ("%s: Leaving Spx_AddDevice - FAILURE.\n", PRODUCT_NAME));
                return(status);
        }


        ASSERT(pDevObject != NULL);

/* Initialise the device extension... */

        pCard = pDevObject->DeviceExtension;                                                    /* Point to card extension */
        RtlZeroMemory(pCard,sizeof(CARD_DEVICE_EXTENSION));                             /* Zero extension structure */

        pDevObject->Flags |= DO_POWER_PAGABLE;                          // Get power IRPs at IRQL PASSIVE_LEVEL 
        pDevObject->Flags &= ~DO_DEVICE_INITIALIZING;
        pLowerDevObject = IoAttachDeviceToDeviceStack(pDevObject,pPDO); /* Attach to device stack */
        ASSERT(pLowerDevObject != NULL);

        KeInitializeSpinLock(&pCard->PnpPowerFlagsLock);        /* Initialise the PNP flags lock */
        ClearPnpPowerFlags(pCard,PPF_STARTED);                          /* Not started yet */
        ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);                     /* Not pending a stop */
        ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);           /* Not pending a remove */

        pCard->IsFDO = TRUE;                                                            /* Card Object is a Functional Device Object (FDO) */
        pCard->CardNumber = CardNumber++;                                       /* Enumerate card devices */
        pCard->DeviceObject = pDevObject;                                       /* Back pointer to device object */
        pCard->LowerDeviceObject= pLowerDevObject;                      /* Pointer to device below in device stack */
        pCard->DriverObject = pDriverObject;                            /* Pointer to driver object */
        pCard->PDO = pPDO;                                                                      /* Pointer to card physical device object (PDO) */
    pCard->DeviceState = PowerDeviceD0;                                 /* Initial power state */
        pCard->SystemState = PowerSystemWorking;                        /* System in full power State */
        pCard->NumPDOs = 0;                                                                     /* Initialise attached port PDO pointers */

        for(i=0; i<PRODUCT_MAX_PORTS; i++)
                pCard->AttachedPDO[i] = NULL;

        SetPnpPowerFlags(pCard,PPF_POWERED);                            /* Initially assumed we are powered */

        XXX_CardInit(pCard);                                                            /* Initialise non-hardware extension fields */

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Leaving Spx_AddDevice - SUCCESS.\n",PRODUCT_NAME));

        return(status);

} /* Spx_AddDevice */

/*****************************************************************************
****************************                     *****************************
****************************   Spx_DispatchPnp   *****************************
****************************                     *****************************
******************************************************************************

prototype:              NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:    The plug and play dispatch routine.
                                Determines whether IRP is for a card or a port and calls other functions to handle it. 

parameters:             pDevObject points to a device object for this driver
                                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:                NT Status Code

*/

NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
        PCOMMON_OBJECT_DATA             CommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
        NTSTATUS                                status = STATUS_SUCCESS;
        
        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        if(CommonData->IsFDO)                                                                   /* Functional Device Object ? */
                status = Spx_Card_FDO_DispatchPnp(pDevObject,pIrp);     /* Yes, must be card device */
        else    
                status = Spx_Port_PDO_DispatchPnp(pDevObject,pIrp);     /* No, must be port device */

        return(status);

} /* Spx_DispatchPnp */

/*****************************************************************************
************************                              ************************
************************   Spx_Card_FDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:              NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)

description:    The plug and play dispatch routine to handle IRPs for card devices.

parameters:             pDevObject points to a card device object for this driver
                                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:                NT Status Code

*/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)
{
        PCARD_DEVICE_EXTENSION          pCard = pFDO->DeviceExtension;
        PDEVICE_OBJECT                          pLowerDevObj = pCard->LowerDeviceObject;
        NTSTATUS                                        status;
        PDEVICE_CAPABILITIES            pDevCaps = NULL;
        PIO_STACK_LOCATION                      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
        PDEVICE_RELATIONS                       pRelations = NULL;
        ULONG                                           length = 0;
        ULONG                                           i = 0;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 


        switch(pIrpStack->MinorFunction)
        {       

/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
        
        case    IRP_MN_START_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Card %d.\n",
                                PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

                        status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

/* If successful, then start the card... */

                        if(NT_SUCCESS(status))
                                status = Spx_Card_StartDevice(pFDO,pIrp);       /* Start the card */

                        pIrp->IoStatus.Status = status;
                        pIrp->IoStatus.Information = 0;
                        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
                        break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

        case    IRP_MN_QUERY_DEVICE_RELATIONS:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Card %d.\n",
                                PRODUCT_NAME,pCard->CardNumber));
                        
                        if(pIrpStack->Parameters.QueryDeviceRelations.Type != BusRelations)     /* Only handle BusRelations */
                        {
                                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: IRP_MN_QUERY_DEVICE_RELATIONS for Card - Non bus.\n",PRODUCT_NAME));
                                IoSkipCurrentIrpStackLocation(pIrp);
                                status = IoCallDriver(pLowerDevObj,pIrp);
                                break;
                        }

/* Enumerate devices on the card... */

                        Spx_EnumPorts(pFDO);                                                            /* Enumerate and create port device objects */

/* Tell the Plug and Play Manager any found ports... */

                        i = 0;
                        if(pIrp->IoStatus.Information)                                          /* Get current device object count */
                                i = ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Count;

                        length = sizeof(DEVICE_RELATIONS)+((pCard->NumPDOs+i)*sizeof(PDEVICE_OBJECT));
                        if(pRelations = SpxAllocateMem(NonPagedPool, length))/* Allocate new structure */
                        {

/* Copy in the device objects so far... */

                                if(i)
                                        RtlCopyMemory
                                        (
                                                pRelations->Objects,
                                                ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Objects,
                                                i * sizeof (PDEVICE_OBJECT)
                                        );

                                pRelations->Count = i;                                                          /* Update device count */

/* Add specialix ports to the device relations... */

                                if(pCard->NumPDOs)
                                {
                                        for(i=0; i<PRODUCT_MAX_PORTS; i++)
                                        {
                                                if(pCard->AttachedPDO[i])                                       /* If object exists */
                                                {                                                                                       /* add to table */
                                                        pRelations->Objects[pRelations->Count++] = pCard->AttachedPDO[i];
                                                        ObReferenceObject(pCard->AttachedPDO[i]);
                                                }
                                        }
                                }

                                if(pIrp->IoStatus.Information != 0)                                     /* If previous structure */
                                        SpxFreeMem((PVOID)pIrp->IoStatus.Information);  /* then free */

                                pIrp->IoStatus.Information = (ULONG_PTR)pRelations;     /* Set new structure */

                        }
                        else
                        {
                                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                                sprintf(szErrorMsg, "Card at %08lX: Insufficient resources.", pCard->PhysAddr);
                                
                                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                                pCard->DriverObject,                    // Driver Object
                                                                pCard->DeviceObject,                    // Device Object (Optional)
                                                                PhysicalZero,                                   // Physical Address 1
                                                                PhysicalZero,                                   // Physical Address 2
                                                                0,                                                              // SequenceNumber
                                                                pIrpStack->MajorFunction,               // Major Function Code
                                                                0,                                                              // RetryCount
                                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                                STATUS_SUCCESS,                                 // FinalStatus
                                                                szErrorMsg);                                    // Error Message
                        }

                        pIrp->IoStatus.Status = STATUS_SUCCESS;
                        IoSkipCurrentIrpStackLocation(pIrp);                            /* Copy parameters to next stack */
                        status = IoCallDriver(pLowerDevObj,pIrp);                       /* Call driver below */
                        break;

/*****************************************************************************
**********************   IRP_MN_QUERY_PNP_DEVICE_STATE   *********************
*****************************************************************************/

        case    IRP_MN_QUERY_PNP_DEVICE_STATE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_PNP_DEVICE_STATE Irp for Card %d.\n",
                                PRODUCT_NAME,pCard->CardNumber));
                        IoSkipCurrentIrpStackLocation(pIrp);
                        status = IoCallDriver(pLowerDevObj,pIrp);
                        break;

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

        case    IRP_MN_QUERY_CAPABILITIES:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Card %d.\n",
                                PRODUCT_NAME,pCard->CardNumber));
                        IoSkipCurrentIrpStackLocation(pIrp);
                        status = IoCallDriver(pLowerDevObj,pIrp);
                        break;

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

        case    IRP_MN_QUERY_STOP_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Card %d.\n",
                                PRODUCT_NAME,pCard->CardNumber));

                        status = STATUS_SUCCESS;
                        SetPnpPowerFlags(pCard,PPF_STOP_PENDING);       // We must now expect a STOP IRP

                        if(SPX_SUCCESS(status))                                         // If we can stop, pass IRP on down
                        {
                                pIrp->IoStatus.Status = status;
                                IoSkipCurrentIrpStackLocation(pIrp);
                                status = IoCallDriver(pLowerDevObj,pIrp);
                        }
                        else                                                                            // If we can't then complete
                        {
                                pIrp->IoStatus.Status = status;
                                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                        }
                        break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

        case    IRP_MN_CANCEL_STOP_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Card %d.\n",
                                PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

                        status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

                        if(SPX_SUCCESS(status))
                        {
                                // we return the device to its working state here.
                                ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);     // We are no longer expecting a STOP IRP.
                                status = STATUS_SUCCESS;
                        }

                        pIrp->IoStatus.Status = status;
                        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                        break;

/*****************************************************************************
****************************   IRP_MN_STOP_DEVICE   **************************
*****************************************************************************/

        case    IRP_MN_STOP_DEVICE: 
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_STOP_DEVICE Irp for Card %d.\n", 
                                PRODUCT_NAME, pCard->CardNumber));

                        Spx_Card_StopDevice(pCard);                             /* Stop the card hardware */

                        pIrp->IoStatus.Status = STATUS_SUCCESS; /* Cannot fail this request */
                        IoSkipCurrentIrpStackLocation(pIrp);            
                        status = IoCallDriver(pLowerDevObj,pIrp);
                        break;

/*****************************************************************************
************************   IRP_MN_QUERY_REMOVE_DEVICE   **********************
*****************************************************************************/
                                
        case    IRP_MN_QUERY_REMOVE_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Card %d.\n", 
                                PRODUCT_NAME, pCard->CardNumber));

                        status = STATUS_SUCCESS;

                        if(SPX_SUCCESS(status))                                 // If we can stop, pass IRP on down
                        {
                                SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);     // We are now ready to remove the card
                                pIrp->IoStatus.Status   = status;
                                IoSkipCurrentIrpStackLocation(pIrp);
                                status = IoCallDriver(pLowerDevObj,pIrp);
                        }
                        else                                                                    // If we can't then complete
                        {
                                pIrp->IoStatus.Status = status;
                                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                        }

                        break;

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

        case    IRP_MN_CANCEL_REMOVE_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Card %d.\n", 
                                PRODUCT_NAME, pCard->CardNumber));

/* Call driver below first... */

                        status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

                        if(SPX_SUCCESS(status))
                        {
                                ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);   // We are no longer expecting to remove the device.
                        }

                        pIrp->IoStatus.Status = status;
                        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
                        break;

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

        case    IRP_MN_SURPRISE_REMOVAL:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Card %d.\n", 
                                PRODUCT_NAME, pCard->CardNumber));

                        status = Spx_Card_StopDevice(pCard);    // Lets stop the port ready for the REMOVE IRP if we are not already.

                        SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);     // We are now ready to remove the card
                        pIrp->IoStatus.Status = status;
                        IoSkipCurrentIrpStackLocation(pIrp);
                        status = IoCallDriver(pLowerDevObj,pIrp);
                        break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

        case IRP_MN_REMOVE_DEVICE: 
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_REMOVE_DEVICE Irp for Card %d.\n", 
                                PRODUCT_NAME, pCard->CardNumber));

                        status = Spx_Card_RemoveDevice(pFDO);

                        pIrp->IoStatus.Status = status;
                        IoSkipCurrentIrpStackLocation(pIrp);
                        status = IoCallDriver(pLowerDevObj,pIrp);
                        break;

        default:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Card %d.\n",
                                PRODUCT_NAME,pIrpStack->MinorFunction,pCard->CardNumber));
                        
                        IoSkipCurrentIrpStackLocation(pIrp);
                        status = IoCallDriver(pLowerDevObj,pIrp);
                        break;

        }

        return(status);

} /* Spx_Card_FDO_DispatchPnp */

/*****************************************************************************
**************************                         ***************************
**************************   Spx_CallDriverBelow   ***************************
**************************                         ***************************
******************************************************************************

prototype:              NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)

description:    Pass the IRP to the driver below this first and wait for it to complete.

parameters:             pLowerDevObj points to a device object for the device below
                                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:                NT Status Code

*/

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)
{
        KEVENT          eventWaitLowerDrivers;
        NTSTATUS        status;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        IoCopyCurrentIrpStackLocationToNext(pIrp);                                                              /* Copy parameters to the stack below */
        KeInitializeEvent(&eventWaitLowerDrivers,SynchronizationEvent,FALSE);   /* Initialise event if need to wait */
        IoSetCompletionRoutine(pIrp,Spx_DispatchPnpPowerComplete,&eventWaitLowerDrivers,TRUE,TRUE,TRUE);

        if((status = IoCallDriver(pLowerDevObj,pIrp)) == STATUS_PENDING)
        {
                KeWaitForSingleObject(&eventWaitLowerDrivers,Executive,KernelMode,FALSE,NULL);
                status = pIrp->IoStatus.Status;
        }

        return(status);

} /* Spx_CallDriverBelow */

/************************************************************************************
************************                                                                        *************************
************************   Spx_DispatchPnpPowerComplete         *************************
************************                                                                        *************************
*************************************************************************************

prototype:              NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)

description:    The PnP IRP was completed by the lower-level drivers.
                                Signal this to whoever registered us.

parameters:             pDevObject point to the device completing the IRP
                                pIrp points to the Plug and Play I/O Request (IRP) to be completed
                                Context was set when the lower driver was called (actually event)

returns:                NT Status Code

*/

NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)
{

        PIO_STACK_LOCATION      stack = NULL;
        PKEVENT                         event = (PKEVENT) Context;
        NTSTATUS                        status;

        
        UNREFERENCED_PARAMETER(pDevObject);

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering DispatchPnpComplete.\n",PRODUCT_NAME));

        status = STATUS_SUCCESS;
        stack = IoGetCurrentIrpStackLocation(pIrp);

    switch(stack->MajorFunction) 
        {
                case IRP_MJ_PNP:

                        switch(stack->MinorFunction) 
                        {
                                case IRP_MN_START_DEVICE:               // Codes which need processing after lower drivers 
                                case IRP_MN_QUERY_CAPABILITIES:
                                case IRP_MN_CANCEL_STOP_DEVICE:
                                case IRP_MN_CANCEL_REMOVE_DEVICE:
                                        KeSetEvent(event,0,FALSE);              // Wake up waiting process //
                                        return(STATUS_MORE_PROCESSING_REQUIRED);

                                default:
                                        break;
                        }
                        break;

                case IRP_MJ_POWER:
                                KeSetEvent(event, 0, FALSE);            // Wake up waiting process 
                                return(STATUS_MORE_PROCESSING_REQUIRED);

                default:
                        break;

        }

    return(status);

} /* Spx_DispatchPnpPowerComplete */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Card_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:              NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:    Start the card device:
                                        Process resources (interrupt, I/O, memory)
                                        Initialise and start the hardware

parameters:             pDevObject point to the card device to start
                                pIrp points to the start I/O Request (IRP)

returns:                NT Status Code

*/

NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
        PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
        PIO_STACK_LOCATION              pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

        NTSTATUS status = STATUS_SUCCESS;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StartDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

/* Translate the card resources... */

        status = XXX_CardGetResources(  pDevObject,
                                                                        pIrpStack->Parameters.StartDevice.AllocatedResources,
                                                                        pIrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
        
        if(!SPX_SUCCESS(status))
                return(status);


/* Start the hardware... */

        if(!SPX_SUCCESS(status = XXX_CardStart(pCard)))
                return(status);

        SetPnpPowerFlags(pCard,PPF_STARTED);    /* Card has been started */

        return(status);

} /* Spx_Card_StartDevice */

/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_EnumPorts   ******************************
*****************************                   ******************************
******************************************************************************

prototype:              NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)

description:    Enumerate port devices found on the card device:

parameters:             pDevObject point to the card device to enumerate

returns:                NT Status Code

*/

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)
{
        PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
        PPORT_DEVICE_EXTENSION  pPort = NULL;

        NTSTATUS                                status = STATUS_SUCCESS;
        PDEVICE_OBJECT                  PortPDO = NULL;

        UNICODE_STRING                  PortPDOName;
        static ULONG                    CurrentInstance = 0;

        UNICODE_STRING                  InstanceStr;
        WCHAR                                   InstanceNumberBuffer[10];
        POWER_STATE                             PowerState;
        USHORT                                  PortNumber      = 0;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_EnumPorts for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

// Name and create device objects for each port on the card... 
        
        for(PortNumber=0;PortNumber<pCard->NumberOfPorts;PortNumber++)
        {

                if(pCard->AttachedPDO[PortNumber] == NULL)                      // Only create if not already present 
                {

// Create the base port name ("XxPort")... 
                
                        RtlZeroMemory(&PortPDOName, sizeof(UNICODE_STRING));
                        PortPDOName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
                        PortPDOName.Buffer = SpxAllocateMem(PagedPool, PortPDOName.MaximumLength+sizeof(WCHAR));
                        if(PortPDOName.Buffer == NULL) continue;
                        RtlZeroMemory(PortPDOName.Buffer, PortPDOName.MaximumLength+sizeof(WCHAR));
                        RtlAppendUnicodeToString(&PortPDOName, PORT_PDO_NAME_BASE);

// Create the instance ("0")... 

                        RtlInitUnicodeString(&InstanceStr,NULL);
                        InstanceStr.MaximumLength = sizeof(InstanceNumberBuffer);
                        InstanceStr.Buffer = InstanceNumberBuffer;
                        RtlIntegerToUnicodeString(CurrentInstance++, 10, &InstanceStr);

// Append instance to the device name ("XxPort0")... 

                        RtlAppendUnicodeStringToString(&PortPDOName, &InstanceStr);

// Create the port device object with this name... 

                        status = IoCreateDevice(pDevObject->DriverObject, 
                                                                        sizeof(PORT_DEVICE_EXTENSION),
                                                                        &PortPDOName,                           // Object Name 
                                                                        FILE_DEVICE_SERIAL_PORT, 
                                                                        FILE_DEVICE_SECURE_OPEN, 
                                                                        TRUE, 
                                                                        &PortPDO);

                        if(!SPX_SUCCESS(status))
                        {
                                SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed = %wZ\n",PRODUCT_NAME,&PortPDOName));
                                SpxFreeMem(PortPDOName.Buffer);
                                continue;
                        }

                        ASSERT(PortPDO != NULL);

// Increment the pdo's stacksize so that it can pass irps through... 

                        PortPDO->StackSize += pDevObject->StackSize;

// Keep a pointer to the device in the card structure... 

                        pCard->NumPDOs++;
                        pCard->AttachedPDO[PortNumber] = PortPDO;
                        ObReferenceObject(PortPDO);

// Initialise port device object and extension... 

                        pPort = PortPDO->DeviceExtension;
                        RtlZeroMemory(pPort,sizeof(PORT_DEVICE_EXTENSION));             // Clear the device extension 

                        pPort->DeviceName = PortPDOName;

                        KeInitializeSpinLock(&pPort->PnpPowerFlagsLock);                // Initialise the PNP flags lock 
                        ClearPnpPowerFlags(pPort,PPF_STARTED);                                  // Not started yet 
                        ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);                             // Not pending a stop 
                        ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);                   // Not pending a remove 
                        ClearPnpPowerFlags(pPort,PPF_REMOVED);                                  // Not removed 
                        SetPnpPowerFlags(pPort,PPF_POWERED);                                    // Initially powered up 

                        InitializeListHead(&pPort->StalledIrpQueue);                    // Initialise the stalled IRP list 
                        KeInitializeSpinLock(&pPort->StalledIrpLock);                   // Initialise the StalledIrpLock flags lock 
                        pPort->UnstallingFlag = FALSE;                                                  // Initialise UnstallingIrps Flag.

                        pPort->IsFDO = FALSE;
                        pPort->PortNumber = PortNumber;                                                 // system port number 
                        pPort->UniqueInstanceID = FALSE;                                                // Instance ID not unique by default.
                        pPort->DeviceIsOpen = FALSE;                                                    // Port is closed to start with 
                        pPort->DeviceObject = PortPDO;                                                  // Backpointer to device object 
                        pPort->DeviceState = PowerDeviceD0;                                             // Port device in full power state 
                        pPort->SystemState = PowerSystemWorking;                                // System in full power State 
                        pPort->pParentCardExt = pCard;                                                  // Point to the parent card extension 
                        ExInitializeFastMutex(&pPort->OpenMutex);

                        if(!SPX_SUCCESS(status = XXX_PortInit(pPort)))                  // Initialise hardware 
                                continue;

                        // Inform Power Manager the of the new power state.
                        PowerState.DeviceState = pPort->DeviceState;
                        PoSetPowerState(pPort->DeviceObject, DevicePowerState, PowerState);

                        PortPDO->Flags &= ~DO_DEVICE_INITIALIZING;                              // Finished Initialising 
                        PortPDO->Flags |= DO_BUFFERED_IO;                                               // Do Buffered IO 
                        PortPDO->Flags |= DO_BUS_ENUMERATED_DEVICE;                             // Bus enumerated 
                        PortPDO->Flags |= DO_POWER_PAGABLE;                                             // Get power IRPs at IRQL PASSIVE_LEVEL 

                }
                else
                {
                        PortPDO = pCard->AttachedPDO[PortNumber];
                        pPort = PortPDO->DeviceExtension;

                        if(pPort->PnpPowerFlags & PPF_REMOVED)
                                ClearPnpPowerFlags(pPort,PPF_REMOVED);
                }
        }

        return(status);

} // End Spx_EnumPorts 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Card_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:              NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:    Stop the card device:
                                        Stop the hardware
                                        Deinitialise card resources (interrupt, I/O, memory)

parameters:             pCard points to the card device to stop

returns:                NT Status Code

*/

NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)
{
        NTSTATUS        status = STATUS_SUCCESS;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StopDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

        if(pCard->PnpPowerFlags & PPF_STARTED)          /* If card is running */
        {
                XXX_CardStop(pCard);                                    /* Stop the card */
        }

        ClearPnpPowerFlags(pCard,PPF_STARTED);          /* Indicate card is stopped */
        ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);     /* Clear stop pending flag */

        return(status);

} /* Spx_Card_StopDevice */

/*****************************************************************************
*************************                           **************************
*************************   Spx_Card_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:              NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:    Remove the card device:
                                        Deallocate any resources
                                        Delete device object

parameters:             pDevObject points to the card device object to remove

returns:                NT Status Code

*/


NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
        PCARD_DEVICE_EXTENSION  pCard = pDevObject->DeviceExtension;
        PDEVICE_OBJECT                  pPortPdo;
        PPORT_DEVICE_EXTENSION  pPort;
        NTSTATUS                                status = STATUS_SUCCESS;
        int                                             loop;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_Card_RemoveDevice for Card %d.\n", 
                PRODUCT_NAME, pCard->CardNumber));

/* First remove all "removed" port device objects... */

        for(loop=0; loop<PRODUCT_MAX_PORTS; loop++)
        {
                if(pPortPdo = pCard->AttachedPDO[loop])                 /* Enumerated port PDO ? */
                {
                        pPort = pPortPdo->DeviceExtension;                      /* Get the device extension */
                        XXX_PortDeInit(pPort);                                          /* Deinitialise port structure */
                        if(pPort->DeviceName.Buffer)
                        {
                                SpxFreeMem(pPort->DeviceName.Buffer);   /* Free device name buffer */
                                pPort->DeviceName.Buffer = NULL;
                        }
                        pCard->AttachedPDO[loop] = NULL;                        /* Remove the port PDO pointer */
                        pCard->NumPDOs--;                                                       /* One less port attached */
                        IoDeleteDevice(pPortPdo);                                       /* Delete the port device object */
                        ObDereferenceObject(pPortPdo);                          /* Dereference the object */
                }
        }

/* Now, remove the card device object... */

        Spx_Card_StopDevice(pCard);                                                     /* Stop the card and release resources */
        XXX_CardDeInit(pCard);                                                          /* Deinitialise non-hardware fields */
        IoDetachDevice(pCard->LowerDeviceObject);                       /* Detach card device from the device stack. */
        IoDeleteDevice(pDevObject);                                                     /* Delete Card FDO from system. */

        return(status);

} /* Spx_Card_RemoveDevice */



/*****************************************************************************
************************                              ************************
************************   Spx_Port_PDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:              NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)

description:    The plug and play dispatch routine to handle IRPs for port devices.

parameters:             pDevObject points to a port device object for this driver
                                pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:                NT Status Code

*/

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)
{
        PPORT_DEVICE_EXTENSION  pPort = pPDO->DeviceExtension;
        PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
        PIO_STACK_LOCATION              pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
        NTSTATUS                                status;
        PWCHAR                                  ReturnBuffer = NULL;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        status = pIrp->IoStatus.Status;

        switch (pIrpStack->MinorFunction) 
        {
   
/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
        
        case    IRP_MN_START_DEVICE: 
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Port %d.\n",
                                PRODUCT_NAME,pPort->PortNumber));

                        status = STATUS_UNSUCCESSFUL;

                        if(SPX_SUCCESS(status = Spx_Port_StartDevice(pPDO)))
                                Spx_UnstallIrps(pPort);                                 // Restart any queued IRPs (from a previous start) 

                        break;

/*****************************************************************************
*****************************   IRP_MN_QUERY_ID   ****************************
*****************************************************************************/
        
        case    IRP_MN_QUERY_ID:
        {
                PUNICODE_STRING pId     = NULL;
                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                switch(pIrpStack->Parameters.QueryId.IdType)
                {
                case    BusQueryCompatibleIDs:
                case    BusQueryDeviceID:
                case    BusQueryInstanceID:
                case    BusQueryHardwareIDs:
                        {
                                status = STATUS_SUCCESS;

                                switch(pIrpStack->Parameters.QueryId.IdType)
                                {
                                case    BusQueryDeviceID:
                                                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryDeviceID Irp for Port %d.\n",
                                                        PRODUCT_NAME,pPort->PortNumber));
                                                SpxDbgMsg(SPX_MISC_DBG,("%s: Device ID %wZ.\n", PRODUCT_NAME,&pPort->DeviceID));
                                                pId = &pPort->DeviceID;
                                                break;

                                case    BusQueryInstanceID:
                                                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryInstanceID Irp for Port %d.\n",
                                                        PRODUCT_NAME, pPort->PortNumber));
                                                SpxDbgMsg(SPX_MISC_DBG,("%s: Instance ID %wZ.\n",PRODUCT_NAME,&pPort->InstanceID));
                                                pId = &pPort->InstanceID;
                                                break;

                                case    BusQueryCompatibleIDs:
                                                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryCompatibleIDs Irp for Port %d.\n",
                                                        PRODUCT_NAME, pPort->PortNumber));
                                                pId = &pPort->CompatibleIDs;
                                                break;

                                case    BusQueryHardwareIDs:
                                                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryHardwareIDs Irp for Port %d.\n",
                                                        PRODUCT_NAME, pPort->PortNumber));
                                                pId = &pPort->HardwareIDs;
                                                break;
                                
                                default:
                                        break;
                                }

                                if(pId)
                                {
                                        if(pId->Buffer)
                                        {
                                                if(ReturnBuffer = SpxAllocateMem(PagedPool, pId->Length + sizeof(WCHAR)))
                                                                RtlCopyMemory(ReturnBuffer, pId->Buffer, pId->Length + sizeof(WCHAR));
                                                else    
                                                {
                                                        sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                                                        pPort->PortNumber+1, pCard->PhysAddr);

                                                        Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                                                        pPort->DriverObject,                    // Driver Object
                                                                                        pPort->DeviceObject,                    // Device Object (Optional)
                                                                                        PhysicalZero,                                   // Physical Address 1
                                                                                        PhysicalZero,                                   // Physical Address 2
                                                                                        0,                                                              // SequenceNumber
                                                                                        pIrpStack->MajorFunction,               // Major Function Code
                                                                                        0,                                                              // RetryCount
                                                                                        FILE_ID | __LINE__,                             // UniqueErrorValue
                                                                                        STATUS_SUCCESS,                                 // FinalStatus
                                                                                        szErrorMsg);                                    // Error Message

                                                        status = STATUS_INSUFFICIENT_RESOURCES;
                                                }
                                        }

                                        pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
                                }
                                break;
                        }
                
                default:
                        break;
                }
                break;

        }

/*****************************************************************************
*************************   IRP_MN_QUERY_DEVICE_TEXT   ***********************
*****************************************************************************/

        case    IRP_MN_QUERY_DEVICE_TEXT:
        {
                PUNICODE_STRING pText = NULL;
                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_TEXT Irp for Port %d.\n",
                                PRODUCT_NAME,pPort->PortNumber));

                        if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription)
                                pText = &pPort->DevDesc;

                        if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation)
                                pText = &pPort->DevLocation;

                        if((pText == NULL)||(pText->Buffer == NULL))
                                break;

                        if(!(ReturnBuffer = SpxAllocateMem(PagedPool, pText->Length + sizeof(WCHAR))))
                        {
                                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                                pPort->PortNumber+1, pCard->PhysAddr);

                                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                                pPort->DriverObject,                    // Driver Object
                                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                                PhysicalZero,                                   // Physical Address 1
                                                                PhysicalZero,                                   // Physical Address 2
                                                                0,                                                              // SequenceNumber
                                                                pIrpStack->MajorFunction,               // Major Function Code
                                                                0,                                                              // RetryCount
                                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                                STATUS_SUCCESS,                                 // FinalStatus
                                                                szErrorMsg);                                    // Error Message

                                status = STATUS_INSUFFICIENT_RESOURCES;
                                break;
                        }

                        status = STATUS_SUCCESS;
                        RtlCopyMemory(ReturnBuffer, pText->Buffer, pText->Length + sizeof(WCHAR));
                        pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
                        break;
        }

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

        case    IRP_MN_QUERY_CAPABILITIES:
        {
                        PDEVICE_CAPABILITIES    pDevCaps = NULL;

                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Port %d.\n", 
                                PRODUCT_NAME,pPort->PortNumber));
                        
                        // Get the packet
                        pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

                        // Set the capabilities.
                        pDevCaps->Version = 1;
                        pDevCaps->Size = sizeof(DEVICE_CAPABILITIES);

                        // We cannot wake the system.
                        pDevCaps->SystemWake = PowerSystemUnspecified;
                        pDevCaps->DeviceWake = PowerSystemUnspecified;

                        // Set device state mapping...

                        pDevCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
                        pDevCaps->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
                        pDevCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
                        pDevCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
                        pDevCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
                        pDevCaps->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

                        // We have no latencies.
                        pDevCaps->D1Latency = 0;
                        pDevCaps->D2Latency = 0;
                        pDevCaps->D3Latency = 0;

                        // No locking or ejection.
                        pDevCaps->LockSupported = FALSE;
                        pDevCaps->EjectSupported = FALSE;

                        // Removable
                        pDevCaps->Removable = FALSE;

                        // Not a Docking device.
                        pDevCaps->DockDevice = FALSE;

                        // System wide unique ID.
                        pDevCaps->UniqueID = pPort->UniqueInstanceID;

                        //UINumber
                        pDevCaps->UINumber = pPort->PortNumber+1;

                        // Raw capable
                        pDevCaps->RawDeviceOK = TRUE;

                        // Silent Install
                        pDevCaps->SilentInstall = FALSE;

                        // Surprise Removal
                        pDevCaps->SurpriseRemovalOK = FALSE;

                        status = STATUS_SUCCESS;
                        break;
        }

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

        case    IRP_MN_QUERY_STOP_DEVICE: 
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Port %d.\n", 
                                PRODUCT_NAME,pPort->PortNumber));

                        status = STATUS_UNSUCCESSFUL;

                        if(pPort->PnpPowerFlags & PPF_STARTED)
                        {
                                ExAcquireFastMutex(&pPort->OpenMutex);

                                if(pPort->DeviceIsOpen) 
                                {
                                        ExReleaseFastMutex(&pPort->OpenMutex);
                                        status = STATUS_DEVICE_BUSY;

                                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
                                                PRODUCT_NAME, pPort->PortNumber));
                                }
                                else
                                {
                                        SetPnpPowerFlags(pPort,PPF_STOP_PENDING);
                                        status = STATUS_SUCCESS;
                                        ExReleaseFastMutex(&pPort->OpenMutex);
                                }
                        }
                        break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

        case    IRP_MN_CANCEL_STOP_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Port %d.\n", 
                                PRODUCT_NAME,pPort->PortNumber));

                        status = STATUS_SUCCESS;
                        ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);     // Clear the stop pending flag 
                        Spx_UnstallIrps(pPort);                                         // Restart any queued IRPs 
                        break;

/*****************************************************************************
***************************   IRP_MN_STOP_DEVICE   ***************************
*****************************************************************************/

        case    IRP_MN_STOP_DEVICE: 
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_STOP_DEVICE Irp for Port %d\n",
                                PRODUCT_NAME,pPort->PortNumber));

                        status = STATUS_SUCCESS;                // we must never fail this IRP (if we do we will probably unload).
                        status = Spx_Port_StopDevice(pPort);
                        ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);     // Clear the stop pending flag 
                        break;

/*****************************************************************************
***********************   IRP_MN_QUERY_REMOVE_DEVICE   ***********************
*****************************************************************************/

        case    IRP_MN_QUERY_REMOVE_DEVICE: 
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Port %d.\n", 
                                PRODUCT_NAME,pPort->PortNumber));

                        ExAcquireFastMutex(&pPort->OpenMutex);

                        if(pPort->DeviceIsOpen) 
                        {
                                ExReleaseFastMutex(&pPort->OpenMutex);
                                status = STATUS_DEVICE_BUSY;

                                SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
                                        PRODUCT_NAME, pPort->PortNumber));
                        }
                        else
                        {
                                SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);     // We are now ready to remove the port
                                status = STATUS_SUCCESS;
                                ExReleaseFastMutex(&pPort->OpenMutex);
                        }

                        break; 

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

        case    IRP_MN_CANCEL_REMOVE_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Port %d.\n", 
                                PRODUCT_NAME, pPort->PortNumber));
                        
                        status = STATUS_SUCCESS;
                        ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);   // We are no longer expecting to remove the device.
                        break; 

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

        case    IRP_MN_SURPRISE_REMOVAL:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Port %d\n",
                                PRODUCT_NAME,pPort->PortNumber));

                        status = STATUS_SUCCESS;                // we must never fail this IRP (if we do we will probably unload).
                        status = Spx_Port_StopDevice(pPort);
                        SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);     // We are now ready to remove the port
                        break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

        case    IRP_MN_REMOVE_DEVICE:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_REMOVE_DEVICE Irp for Port %d\n",
                                PRODUCT_NAME,pPort->PortNumber));

                        status = STATUS_SUCCESS;                // we must never fail this IRP (if we do we will probably unload).
                        Spx_KillStalledIRPs(pPDO);              // Kill off any waiting IRPS on the stalled list 
                        status = Spx_Port_RemoveDevice(pPDO);
                        ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);   // Clear the pending flag 
                        break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

        case    IRP_MN_QUERY_DEVICE_RELATIONS:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Port %d.\n", 
                                PRODUCT_NAME, pPort->PortNumber));

                        switch(pIrpStack->Parameters.QueryDeviceRelations.Type)
                        {
                        case TargetDeviceRelation:
                                {
                                        PDEVICE_RELATIONS pDevRel = NULL;

                                        if(pIrp->IoStatus.Information != 0)
                                                break;

                                        if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
                                        {
                                                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                                                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                                                pPort->PortNumber+1, pCard->PhysAddr);

                                                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                                                pPort->DriverObject,                    // Driver Object
                                                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                                                PhysicalZero,                                   // Physical Address 1
                                                                                PhysicalZero,                                   // Physical Address 2
                                                                                0,                                                              // SequenceNumber
                                                                                pIrpStack->MajorFunction,               // Major Function Code
                                                                                0,                                                              // RetryCount
                                                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                                                STATUS_SUCCESS,                                 // FinalStatus
                                                                                szErrorMsg);                                    // Error Message

                                                status = STATUS_INSUFFICIENT_RESOURCES;
                                                break;
                                        }

                                        pDevRel->Count = 1;
                                        pDevRel->Objects[0] = pPDO;
                                        ObReferenceObject(pPDO);

                                        status = STATUS_SUCCESS;
                                        pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
                                        break;
                                }

                        case BusRelations:
                                {
                                        PDEVICE_RELATIONS pDevRel = NULL;

                                        if(pIrp->IoStatus.Information != 0)
                                                break;

                                        if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
                                        {
                                                CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];  // Limited to 51 characters + 1 null 

                                                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                                                pPort->PortNumber+1, pCard->PhysAddr);
                                                
                                                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                                                pPort->DriverObject,                    // Driver Object
                                                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                                                PhysicalZero,                                   // Physical Address 1
                                                                                PhysicalZero,                                   // Physical Address 2
                                                                                0,                                                              // SequenceNumber
                                                                                pIrpStack->MajorFunction,               // Major Function Code
                                                                                0,                                                              // RetryCount
                                                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                                                STATUS_SUCCESS,                                 // FinalStatus
                                                                                szErrorMsg);                                    // Error Message

                                                status = STATUS_INSUFFICIENT_RESOURCES;
                                                break;
                                        }

                                        pDevRel->Count = 0;
                                        status = STATUS_SUCCESS;
                                        pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
                                        break;

                                }

                        default:
                                break;
                        }
                        break;


        default:
                        SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Port %d.\n", 
                                PRODUCT_NAME,pIrpStack->MinorFunction, pPort->PortNumber));
                        break;
        }

        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        return(status);

} /* Spx_Port_PDO_DispatchPnp */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Port_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:              NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)

description:    Start the port device:
                                        Setup external naming
                                        Initialise and start the hardware

parameters:             pDevObject point to the card device to start
                                pIrp points to the start I/O Request (IRP)

returns:                NT Status Code

*/

NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)
{

        PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;    
        NTSTATUS                                status = STATUS_SUCCESS;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StartDevice for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

        if(!pPort->CreatedSymbolicLink)
        {
                if(!SPX_SUCCESS(status = Spx_DoExternalNaming(pDevObject)))             // Set up external name for device 
                        return(status);
        }

        if(!SPX_SUCCESS(status = XXX_PortStart(pPort)))                         // Start hardware. 
        {
                Spx_RemoveExternalNaming(pDevObject);                                   // Remove external naming.
                return(status);
        }

        SetPnpPowerFlags(pPort,PPF_STARTED);                                            // Port has been started.
        ClearPnpPowerFlags(pPort,PPF_REMOVED);                                          // Port is not removed...yet. 
        ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);                                     // Not pending a stop. 
        ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);                           // Not pending a remove. 

        return(status);

} // Spx_Port_StartDevice 


/*****************************************************************************
**************************                          **************************
**************************   Spx_GetExternalName   **************************
**************************                          **************************
******************************************************************************

prototype:              NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)

description:    Setup external naming for a port:
                                        get Dos Name for port 
                                        form symbolic link name

parameters:             pDevObject points to the device object for the port to be named

returns:                NT Status Code

*/
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)
{
        PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
        PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
        NTSTATUS                                status = STATUS_SUCCESS;
        HANDLE                                  PnPKeyHandle;
        UNICODE_STRING                  TmpLinkName;
        WCHAR                                   *pRegName = NULL;
        ULONG                                   BuffLen = 0;
        CHAR                                    szErrorMsg[MAX_ERROR_LOG_INSERT];       // Limited to 51 characters + 1 null 
                
        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_GetExternalName for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

        status = IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle);

        if(!SPX_SUCCESS(status))
                return(status);

// Get the device name allocated by the PNP manager from the registry... 
        if(pRegName = SpxAllocateMem(PagedPool,SYMBOLIC_NAME_LENGTH * sizeof(WCHAR) + sizeof(WCHAR)))
        {
                status = Spx_GetRegistryKeyValue(       PnPKeyHandle,
                                                                                        L"PortName",
                                                                                        sizeof(L"PortName"),
                                                                                        pRegName,
                                                                                        SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
        }
        else
        {
                status = STATUS_INSUFFICIENT_RESOURCES;
        }

        ZwClose(PnPKeyHandle);

        if(!SPX_SUCCESS(status))
        {
                if(pRegName != NULL) 
                        SpxFreeMem(pRegName);

                return(STATUS_SUCCESS);                 // Port has not been given a name yet but we must not fail.
        }

        RtlZeroMemory(&TmpLinkName, sizeof(UNICODE_STRING));

        if(!SPX_SUCCESS(status))
                goto NamingError;
        
        TmpLinkName.MaximumLength       = SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
        TmpLinkName.Buffer                      = SpxAllocateMem(PagedPool, TmpLinkName.MaximumLength + sizeof(WCHAR));
        
        if(!TmpLinkName.Buffer)
        {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);

                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pPort->DriverObject,                    // Driver Object
                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto NamingError;
        }

        RtlZeroMemory(TmpLinkName.Buffer, TmpLinkName.MaximumLength + sizeof(WCHAR));

        // Create the "\\DosDevices\\<SymbolicName>" string.
        RtlAppendUnicodeToString(&TmpLinkName, L"\\");
        RtlAppendUnicodeToString(&TmpLinkName, DEFAULT_DIRECTORY);
        RtlAppendUnicodeToString(&TmpLinkName, L"\\");
        RtlAppendUnicodeToString(&TmpLinkName, pRegName);

        pPort->SymbolicLinkName.Length                  = 0;
        pPort->SymbolicLinkName.MaximumLength   = TmpLinkName.Length + sizeof(WCHAR);
        pPort->SymbolicLinkName.Buffer                  = SpxAllocateMem(PagedPool, pPort->SymbolicLinkName.MaximumLength);
        
        if(!pPort->SymbolicLinkName.Buffer)
        {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);

                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pPort->DriverObject,                    // Driver Object
                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto NamingError;
        }

        RtlZeroMemory(pPort->SymbolicLinkName.Buffer, pPort->SymbolicLinkName.MaximumLength);
        RtlAppendUnicodeStringToString(&pPort->SymbolicLinkName, &TmpLinkName);


        pPort->DosName.Buffer = SpxAllocateMem(PagedPool, 64 + sizeof(WCHAR));

        if(!pPort->DosName.Buffer)
        {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pPort->DriverObject,                    // Driver Object
                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto NamingError;
        }

        pPort->DosName.MaximumLength = 64 + sizeof(WCHAR);

        pPort->DosName.Length = 0;
        RtlZeroMemory(pPort->DosName.Buffer, pPort->DosName.MaximumLength);
        RtlAppendUnicodeToString(&pPort->DosName, pRegName);
        RtlZeroMemory(((PUCHAR) (&pPort->DosName.Buffer[0])) + pPort->DosName.Length, sizeof(WCHAR));

        SpxDbgMsg(SPX_MISC_DBG, ("%s: DeviceName is %wZ\n", PRODUCT_NAME, &pPort->DeviceName));
        SpxDbgMsg(SPX_MISC_DBG, ("%s: DosName is %wZ\n", PRODUCT_NAME, &pPort->DosName));
        SpxDbgMsg(SPX_MISC_DBG, ("%s: SymbolicName is %wZ\n", PRODUCT_NAME, &pPort->SymbolicLinkName));

        if(pRegName != NULL)
                SpxFreeMem(pRegName);   // Free pRegName

        if(TmpLinkName.Buffer != NULL)
                SpxFreeMem(TmpLinkName.Buffer); // Free TmpLinkName

        return(status);


NamingError:;

        if(TmpLinkName.Buffer != NULL)
                SpxFreeMem(TmpLinkName.Buffer);

        if(pRegName != NULL)
                SpxFreeMem(pRegName);

        return(status);
}

/*****************************************************************************
**************************                          **************************
**************************   Spx_DoExternalNaming   **************************
**************************                          **************************
******************************************************************************

prototype:              NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:    Setup external naming for a port:
                                        create symbolic link
                                        add to registry
                                        register and enable interface

parameters:             pDevObject points to the device object for the port to be named

returns:                NT Status Code

*/
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
        PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
        PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
        NTSTATUS                                status = STATUS_SUCCESS;
        CHAR                                    szErrorMsg[MAX_ERROR_LOG_INSERT];       // Limited to 51 characters + 1 null 
                
        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DoExternalNaming for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

// Get external name...
        if( !SPX_SUCCESS(status = Spx_GetExternalName(pDevObject)) || (pPort->DosName.Buffer == NULL))
                return(status);


        status = IoCreateSymbolicLink(&pPort->SymbolicLinkName, &pPort->DeviceName);  // Create the symbolic link... 

        if(!SPX_SUCCESS(status))
        {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Insufficient resources", 
                                pPort->PortNumber+1, pCard->PhysAddr);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pPort->DriverObject,                    // Driver Object
                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                goto ExternalNamingError;
        }

// Add mapping to "SERIALCOMM" section of registry... 
        pPort->CreatedSymbolicLink = TRUE;
        
        status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP,
                                                                        L"SERIALCOMM",
                                                                        pPort->DeviceName.Buffer,
                                                                        REG_SZ,
                                                                        pPort->DosName.Buffer,
                                                                        pPort->DosName.Length + sizeof(WCHAR));

        if(!SPX_SUCCESS(status))
        {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Registry error.", 
                                pPort->PortNumber+1, pCard->PhysAddr);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pPort->DriverObject,                    // Driver Object
                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                goto ExternalNamingError;
        }

        status = IoRegisterDeviceInterface(     pDevObject, (LPGUID)&GUID_CLASS_COMPORT,
                                                                                NULL, &pPort->DeviceClassSymbolicName);

        if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
        {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Interface error.", 
                                pPort->PortNumber+1, pCard->PhysAddr);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pPort->DriverObject,                    // Driver Object
                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                pPort->DeviceClassSymbolicName.Buffer = NULL;
                
                goto ExternalNamingError;
        }

        // Enable the device interface.
        status = IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, TRUE);

        if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
        {
                sprintf(szErrorMsg, "Port %d on card at %08lX: Interface error.", 
                                pPort->PortNumber+1, pCard->PhysAddr);
                
                Spx_LogMessage( STATUS_SEVERITY_ERROR,
                                                pPort->DriverObject,                    // Driver Object
                                                pPort->DeviceObject,                    // Device Object (Optional)
                                                PhysicalZero,                                   // Physical Address 1
                                                PhysicalZero,                                   // Physical Address 2
                                                0,                                                              // SequenceNumber
                                                0,                                                              // Major Function Code
                                                0,                                                              // RetryCount
                                                FILE_ID | __LINE__,                             // UniqueErrorValue
                                                STATUS_SUCCESS,                                 // FinalStatus
                                                szErrorMsg);                                    // Error Message

                
                goto ExternalNamingError;
        }



        pPort->CreatedSerialCommEntry = TRUE;                           // Set flag.

        return(status);


ExternalNamingError:;

        if(!SPX_SUCCESS(status))
                Spx_RemoveExternalNaming(pDevObject);                   // Remove and tidy up any allocations 


        return(status);

} // End Spx_DoExternalNaming 

/*****************************************************************************
************************                              ************************
************************   Spx_RemoveExternalNaming   ************************
************************                              ************************
******************************************************************************

prototype:              NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:    Remove external naming:
                                        remove symbolic link
                                        remove from registry
                                        stop interface

parameters:             pDevObject points to the device object for the port to be named.

returns:                NT Status Code

*/
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
        PPORT_DEVICE_EXTENSION  pPort = pDevObject->DeviceExtension;
        PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
        NTSTATUS status = STATUS_UNSUCCESSFUL;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        if(pPort->CreatedSymbolicLink)
        {
                if(pPort->DosName.Buffer)
                {
                        SpxFreeMem(pPort->DosName.Buffer);                                              // Free DOS name buffer. 
                        pPort->DosName.Buffer = NULL;
                }

                if(pPort->SymbolicLinkName.Buffer)
                {
                        SpxFreeMem(pPort->SymbolicLinkName.Buffer);                             // Free symbolic link name buffer. 
                        pPort->SymbolicLinkName.Buffer = NULL;
                }

                Spx_GetExternalName(pDevObject);        // Get external name..

                if(pPort->SymbolicLinkName.Buffer)
                        status = IoDeleteSymbolicLink(&pPort->SymbolicLinkName);        // Delete Symbolic Link. 

                if(pPort->DeviceClassSymbolicName.Buffer)       // Device Interface name
                        IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, FALSE);      // Disable Device Interface.


                pPort->CreatedSymbolicLink = FALSE;                                                                                             // Reset created flag. 
        }

        if(pPort->DosName.Buffer)
        {
                SpxFreeMem(pPort->DosName.Buffer);                                      // Free DOS name buffer. 
                pPort->DosName.Buffer = NULL;
        }

        if(pPort->SymbolicLinkName.Buffer)
        {
                SpxFreeMem(pPort->SymbolicLinkName.Buffer);                     // Free symbolic link name buffer. 
                pPort->SymbolicLinkName.Buffer = NULL;
        }

        if(pPort->CreatedSerialCommEntry && pPort->DeviceName.Buffer)
        {
                RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP,         // Delete SERIALCOMM registry entry. 
                                                                SERIAL_DEVICE_MAP,
                                                                pPort->DeviceName.Buffer);

                pPort->CreatedSerialCommEntry = FALSE;                          // Reset created flag.
        }

        if(pPort->DeviceClassSymbolicName.Buffer)       // Device Interface name
        {                       
                SpxFreeMem(pPort->DeviceClassSymbolicName.Buffer);                                      // Free Device Interface Name.
                pPort->DeviceClassSymbolicName.Buffer = NULL;
        }

        return(STATUS_SUCCESS);

} // End Spx_RemoveExternalNaming 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Port_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:              NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)

description:    Stop the port device:
                                        Stop the hardware
                                        Remove external naming

parameters:             pPort points to the port device extension to be stopped

returns:                NT Status Code

*/

NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)
{
        NTSTATUS        status  = STATUS_SUCCESS;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StopDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

        if(pPort->PnpPowerFlags & PPF_STARTED)
                XXX_PortStop(pPort);                                                                    // Stop the port hardware. 

        ClearPnpPowerFlags(pPort,PPF_STARTED);                                          // Indicate card is stopped. 
        ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);                                     // Clear stop pending flag.

        return(status);

} // End Spx_Port_StopDevice

/*****************************************************************************
*************************                           **************************
*************************   Spx_Port_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:              NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:    Remove the port device object:
                                        Remove PDO pointer from card structure
                                        Deinitialise port hardware
                                        Delete the device object

parameters:             pDevObject points to the port device object to be stopped

returns:                NT Status Code

*/
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
        PPORT_DEVICE_EXTENSION  pPort   = pDevObject->DeviceExtension;
        PCARD_DEVICE_EXTENSION  pCard   = pPort->pParentCardExt;
        NTSTATUS                                status  = STATUS_SUCCESS;

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_RemoveDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

        if(pPort->PnpPowerFlags & PPF_REMOVED)                                  // Has device been removed already?
                return(STATUS_SUCCESS);

        Spx_Port_StopDevice(pPort);                                                             // Stop the hardware.
        ClearPnpPowerFlags(pPort,PPF_STARTED);                                  // Mark the PDO as stopped.

        Spx_RemoveExternalNaming(pDevObject);                                   // Remove external naming. 


// Mark the port device as "removed", but don't delete the PDO until the card device is removed...
        SetPnpPowerFlags(pPort,PPF_REMOVED);                                    // Mark the PDO as "removed".

        return(status);

} // End Spx_Port_RemoveDevice 




/////////////////////////////////////////////////////////////////////////////////////////////
// Create an Instance ID for the port and try to make it globally unique if possible.
//
NTSTATUS
Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort)
{
        PCARD_DEVICE_EXTENSION  pCard = pPort->pParentCardExt;
        NTSTATUS                                status = STATUS_SUCCESS;
        CHAR                                    szTemp[100];            // Space to hold string 
        int                                             szTempPos = 0;
        HANDLE                                  PnPKeyHandle;
        BOOLEAN                                 UseBusWideInstanceID = FALSE;  // Try to create system wide unique instance IDs

        PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

        SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_CreatePortInstanceID for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

        status = IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_READ, &PnPKeyHandle);

        if(SPX_SUCCESS(status))
        {
                ULONG Data = 0;

                if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, L"UseBusWideInstanceID", 
                                                        sizeof(L"UseBusWideInstanceID"), &Data, sizeof(ULONG))))
                {
                        if(Data > 0)
                                UseBusWideInstanceID = TRUE;  // Installer has told us to use a bus wide instance ID 
                                                                                          // because child devices already exist with that type of ID.
                }
                

                ZwClose(PnPKeyHandle);
        }

        if(UseBusWideInstanceID)
        {
                pPort->UniqueInstanceID = FALSE;        // ID created is not unique system wide.
                status = STATUS_SUCCESS;
        }
        else
        {
                switch(pCard->InterfaceType)
                {
                case Isa:
                        // Start Instance ID with ISA address
                        szTempPos += sprintf(szTemp,"ISA&%08X%08X&", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
                        pPort->UniqueInstanceID = TRUE; // ID created is unique system wide.
                        status = STATUS_SUCCESS;
                        break;

                case PCIBus:
                        {
                                ULONG PCI_BusNumber = 0;
                                ULONG PCI_DeviceFunction = 0;
                                ULONG ResultLength;

                                // Try to get DevicePropertyBusNumber
                                if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyBusNumber, 
                                                                                        sizeof(PCI_BusNumber), &PCI_BusNumber, &ResultLength)))
                                        break;


                                // Start Instance ID with PCI bus number
                                szTempPos += sprintf(szTemp,"PCI&%04X&", PCI_BusNumber);

                                // Try to get DevicePropertyAddress
                                if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyAddress, 
                                                                                        sizeof(PCI_DeviceFunction),     &PCI_DeviceFunction, &ResultLength)))
                                        break;
                                

                                // Add on PCI Device and Function IDs
                                szTempPos += sprintf(szTemp + szTempPos,"%08X&", PCI_DeviceFunction);
                                pPort->UniqueInstanceID = TRUE; // ID created is unique system wide.

                                status = STATUS_SUCCESS;
                                break;
                        }
                
                default:
                        pPort->UniqueInstanceID = FALSE;        // ID created is not unique system wide.
                        status = STATUS_SUCCESS;
                        break;

                }

        }

        // Finish off the InstanceID with the port number on the card.
        sprintf(szTemp + szTempPos,"%04X", pPort->PortNumber);

        status = Spx_InitMultiString(FALSE, &pPort->InstanceID, szTemp, NULL);


        return status;
}



// End of SPX_PNP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spx_init.c ===
#include "precomp.h"    // Precompiled header

/****************************************************************************************
*                                                                                       *
*   Module:         SPX_INIT.C                                                          *
*                                                                                       *
*   Creation:       27th September 1998                                                 *
*                                                                                       *
*   Author:         Paul Smith                                                          *
*                                                                                       *
*   Version:        1.0.0                                                               *
*                                                                                       *
*   Description:    This module contains the code that load the driver.                 *
*                                                                                       *
****************************************************************************************/


#define FILE_ID SPX_INIT_C      // File ID for Event Logging see SPX_DEFS.H for values.


// Function Prototypes 
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
// End function prototypes.

// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#endif

// Gloabal Driver Data
UNICODE_STRING  SavedRegistryPath;

#if DBG
ULONG SpxDebugLevel = 0;        // Debug level for checked build
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//  DriverEntry - Load first and initialises entry points.                              //
//////////////////////////////////////////////////////////////////////////////////////////
/*
Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    RegistryPath - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS 
*/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    // Holds status information return by various OS and driver initialization routines.
    NTSTATUS status;

    // We use this to query into the registry as to whether we should break at driver entry.
    RTL_QUERY_REGISTRY_TABLE paramTable[3];
    ULONG zero          = 0;
    ULONG debugLevel    = 0;
    ULONG shouldBreak   = 0;        
    PWCHAR path         = NULL;

    PAGED_CODE();   // Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    #if DBG
        DbgPrint( "%s: In DriverEntry\n", PRODUCT_NAME);
    #endif


    // Store Registry Path
    SavedRegistryPath.MaximumLength = RegistryPath->MaximumLength;
    SavedRegistryPath.Length        = RegistryPath->Length;
    SavedRegistryPath.Buffer        = SpxAllocateMem(PagedPool, SavedRegistryPath.MaximumLength);

    if(SavedRegistryPath.Buffer)
    {
        RtlMoveMemory(SavedRegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
    
        RtlZeroMemory(&paramTable[0], sizeof(paramTable));
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"BreakOnEntry";
        paramTable[0].EntryContext = &shouldBreak;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"DebugLevel";
        paramTable[1].EntryContext = &debugLevel;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if(!SPX_SUCCESS(status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                                        RegistryPath->Buffer, &paramTable[0], 
                                                        NULL, NULL)))
        {
            shouldBreak = 0;
            debugLevel  = 0;
        }

    }
    else
        status = STATUS_INSUFFICIENT_RESOURCES;


    #if DBG
        SpxDebugLevel = debugLevel; 
    //  SpxDebugLevel = (ULONG)-1;          // Prints all debug messages

    //  shouldBreak = 1;    // HARD CODED BREAKPOINT WITH CHECKED BUILD !!!
    #endif


    if(shouldBreak)
    {
        DbgBreakPoint();    // Break Debugger.
    }


    if(SPX_SUCCESS(status))
    {
        // Initialize the Driver Object with driver's entry points
        DriverObject->DriverUnload                                  = DriverUnload;
        DriverObject->DriverExtension->AddDevice                    = Spx_AddDevice;
        DriverObject->MajorFunction[IRP_MJ_PNP]                     = Spx_DispatchPnp;
        DriverObject->MajorFunction[IRP_MJ_POWER]                   = Spx_DispatchPower;
        DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]           = Spx_Flush;
        DriverObject->MajorFunction[IRP_MJ_WRITE]                   = Spx_Write;
        DriverObject->MajorFunction[IRP_MJ_READ]                    = Spx_Read;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = Spx_IoControl;
        DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = Spx_InternalIoControl;
        DriverObject->MajorFunction[IRP_MJ_CREATE]                  = Spx_CreateOpen;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = Spx_Close;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = Spx_Cleanup;
        DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]       = Spx_QueryInformationFile;
        DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]         = Spx_SetInformationFile;
#ifdef WMI_SUPPORT
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = Spx_DispatchSystemControl;
#endif
        
    }
    else
    {
        // Free
        if(SavedRegistryPath.Buffer)
        {
            SpxFreeMem(SavedRegistryPath.Buffer);
            SavedRegistryPath.Buffer = NULL;
        }
    }


    return(status);

}   // DriverEntry 




//////////////////////////////////////////////////////////////////////////////////////////
//  DriverUnload - Called as driver unloads.                                            
//////////////////////////////////////////////////////////////////////////////////////////
VOID 
DriverUnload(IN PDRIVER_OBJECT pDriverObject)
/*++

Routine Description:

    This routine cleans up all of the resources allocated in DriverEntry.

Arguments:

    pDriverObject - Pointer to the driver object controling all of the
                    devices.

Return Value:

    None.

--*/
{
    PAGED_CODE();
    
    SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering DriverUnload\n", PRODUCT_NAME));

    // All Device Objects must have been deleted by now.
    ASSERT (pDriverObject->DeviceObject == NULL);

    // Free
    if(SavedRegistryPath.Buffer)
    {
        SpxFreeMem(SavedRegistryPath.Buffer);
        SavedRegistryPath.Buffer = NULL;
    }


    return;
}


// End of SPX_INIT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spd_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

// -- PORT WMI Routines -- 
NTSTATUS
SpeedPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						  OUT PUNICODE_STRING pInstanceName,
						  OUT PUNICODE_STRING *pRegistryPath,
						  OUT PUNICODE_STRING pMofResourceName,
						  OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpeedPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
							IN ULONG GuidIndex, IN ULONG InstanceIndex,
							IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
							IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpeedPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpeedPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						 IN ULONG GuidIndex, IN ULONG InstanceIndex,
						 IN ULONG DataItemId, IN ULONG BufferSize,
						 IN PUCHAR pBuffer);



// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpeedPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpeedPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpeedPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpeedPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpeedPort_WmiSetDataItem)
#endif





#define WMI_SERIAL_PORT_NAME_INFORMATION	0
#define WMI_SERIAL_PORT_COMM_INFORMATION	1
#define WMI_SERIAL_PORT_HW_INFORMATION		2
#define WMI_SERIAL_PORT_PERF_INFORMATION	3
#define WMI_SERIAL_PORT_PROPERTIES			4
#define WMI_SPEED_PORT_FIFO_PROP			5

GUID SpeedPortStdSerialWmiPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI
GUID SpeedPortWmiFifoPropGuid						= SPX_SPEED_WMI_FIFO_PROP_GUID;			// Speed WMI


WMIGUIDREGINFO SpeedPort_WmiGuidList[] =
{
    { &SpeedPortStdSerialWmiPortNameGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortCommGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortHWGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortPerfGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortPropertiesGuid, 1, 0},
    { &SpeedPortWmiFifoPropGuid, 1, 0 },
};


#define SpeedPort_WmiGuidCount (sizeof(SpeedPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpeedPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpeedPort_WmiGuidCount;
    WmilibContext->GuidList				= SpeedPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpeedPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpeedPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpeedPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpeedPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	//SpeedPort_WmiExecuteMethod
    WmilibContext->WmiFunctionControl	= NULL;	//SpeedPort_WmiFunctionControl;

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpeedPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.

    RtlInitUnicodeString(MofResourceName, L"MofResource");

	return(status);
}





NTSTATUS
SpeedPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}

	case WMI_SPEED_PORT_FIFO_PROP:
		{
			size = sizeof(SPX_SPEED_WMI_FIFO_PROP);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;

			// Update items that may have changed.
			pPort->SpeedWmiFifoProp.TxFiFoLimit			= pPort->TxFIFOSize;
			pPort->SpeedWmiFifoProp.TxFiFoTrigger		= pPort->TxFIFOTrigLevel;
			pPort->SpeedWmiFifoProp.RxFiFoTrigger		= pPort->RxFIFOTrigLevel;
			pPort->SpeedWmiFifoProp.LoFlowCtrlThreshold	= pPort->LoFlowCtrlThreshold;
			pPort->SpeedWmiFifoProp.HiFlowCtrlThreshold	= pPort->HiFlowCtrlThreshold;

			*(PSPX_SPEED_WMI_FIFO_PROP)pBuffer = pPort->SpeedWmiFifoProp;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpeedPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										

	case WMI_SPEED_PORT_FIFO_PROP:
		{
			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pPort, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}

			if(BufferSize < sizeof(SPX_SPEED_WMI_FIFO_PROP)) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// These Items are read only - If we have been asked to change them fail request.
			if((pPort->SpeedWmiFifoProp.MaxTxFiFoSize				!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->MaxTxFiFoSize)
			|| (pPort->SpeedWmiFifoProp.MaxRxFiFoSize				!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->MaxRxFiFoSize)
			|| (pPort->SpeedWmiFifoProp.DefaultTxFiFoLimit			!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultTxFiFoLimit)
			|| (pPort->SpeedWmiFifoProp.DefaultTxFiFoTrigger		!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultTxFiFoTrigger)
			|| (pPort->SpeedWmiFifoProp.DefaultRxFiFoTrigger		!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultRxFiFoTrigger)
			|| (pPort->SpeedWmiFifoProp.DefaultLoFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultLoFlowCtrlThreshold)
			|| (pPort->SpeedWmiFifoProp.DefaultHiFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultHiFlowCtrlThreshold))
			{
				status = STATUS_WMI_READ_ONLY;
				break;
			}

			if((pCard->CardType == Fast4_Isa)  || (pCard->CardType == Fast4_Pci)  || (pCard->CardType == RAS4_Pci) 
			|| (pCard->CardType == Fast8_Isa)  || (pCard->CardType == Fast8_Pci)  || (pCard->CardType == RAS8_Pci)  
			|| (pCard->CardType == Fast16_Isa) || (pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
			{
				if((pPort->LoFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->LoFlowCtrlThreshold)
				|| (pPort->HiFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->HiFlowCtrlThreshold))
				{
					status = STATUS_WMI_READ_ONLY;	// Flow ctrl threshold cannot be modified on Fast cards.
					break;
				}
			}


			pPort->TxFIFOSize				= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->TxFiFoLimit;
			pPort->TxFIFOTrigLevel			= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->TxFiFoTrigger;
			pPort->RxFIFOTrigLevel			= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->RxFiFoTrigger;
			pPort->LoFlowCtrlThreshold		= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->LoFlowCtrlThreshold;
			pPort->HiFlowCtrlThreshold		= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->HiFlowCtrlThreshold;
			
			// Make settings
			if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
			{
				HANDLE					PnPKeyHandle;

				// Open PnP Reg Key and save new setting to registry.
				if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
				{
					Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_LIMIT, sizeof(TX_FIFO_LIMIT), REG_DWORD, 
												&pPort->TxFIFOSize, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_TRIG_LEVEL, sizeof(TX_FIFO_TRIG_LEVEL), REG_DWORD, 
												&pPort->TxFIFOTrigLevel, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, RX_FIFO_TRIG_LEVEL, sizeof(RX_FIFO_TRIG_LEVEL), REG_DWORD, 
												&pPort->RxFIFOTrigLevel, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, LO_FLOW_CTRL_LEVEL, sizeof(LO_FLOW_CTRL_LEVEL), REG_DWORD, 
												&pPort->LoFlowCtrlThreshold, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, HI_FLOW_CTRL_LEVEL, sizeof(HI_FLOW_CTRL_LEVEL), REG_DWORD, 
												&pPort->HiFlowCtrlThreshold, sizeof(ULONG));

					ZwClose(PnPKeyHandle);
				}

				status = STATUS_SUCCESS;
			}
			else
			{
				status = STATUS_WMI_SET_FAILURE;
			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}


    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpeedPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										

	case WMI_SPEED_PORT_FIFO_PROP:
		{
			HANDLE	PnPKeyHandle;

			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pPort, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}

			switch(DataItemId)
			{
			case SPX_SPEED_WMI_FIFO_PROP_MaxTxFiFoSize_ID:
			case SPX_SPEED_WMI_FIFO_PROP_MaxRxFiFoSize_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoLimit_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoTrigger_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultRxFiFoTrigger_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultLoFlowCtrlThreshold_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultHiFlowCtrlThreshold_ID:
				status = STATUS_WMI_READ_ONLY;
				break;

			case SPX_SPEED_WMI_FIFO_PROP_TxFiFoLimit_ID:
				pPort->TxFIFOSize = *pBuffer;

				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_LIMIT, sizeof(TX_FIFO_LIMIT), REG_DWORD, 
													&pPort->TxFIFOSize, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;

			case SPX_SPEED_WMI_FIFO_PROP_TxFiFoTrigger_ID:
				pPort->TxFIFOTrigLevel = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_TRIG_LEVEL, sizeof(TX_FIFO_TRIG_LEVEL), REG_DWORD, 
													&pPort->TxFIFOTrigLevel, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;

			case SPX_SPEED_WMI_FIFO_PROP_RxFiFoTrigger_ID:
				pPort->RxFIFOTrigLevel = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, RX_FIFO_TRIG_LEVEL, sizeof(RX_FIFO_TRIG_LEVEL), REG_DWORD, 
													&pPort->RxFIFOTrigLevel, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;
			
			case SPX_SPEED_WMI_FIFO_PROP_LoFlowCtrlThreshold_ID:

				if((pCard->CardType == Fast4_Isa)  || (pCard->CardType == Fast4_Pci)  || (pCard->CardType == RAS4_Pci)  
				|| (pCard->CardType == Fast8_Isa)  || (pCard->CardType == Fast8_Pci)  || (pCard->CardType == RAS8_Pci)  
				|| (pCard->CardType == Fast16_Isa) || (pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
				{
					if(pPort->SpeedWmiFifoProp.LoFlowCtrlThreshold != *pBuffer)
					{
						status = STATUS_WMI_READ_ONLY;	// Flow ctrl threshold cannot be modified on Fast cards.
						break;
					}
				}

				pPort->LoFlowCtrlThreshold = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, LO_FLOW_CTRL_LEVEL, sizeof(LO_FLOW_CTRL_LEVEL), REG_DWORD, 
													&pPort->LoFlowCtrlThreshold, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;
			
			case SPX_SPEED_WMI_FIFO_PROP_HiFlowCtrlThreshold_ID:

				if((pCard->CardType == Fast4_Isa)  || (pCard->CardType == Fast4_Pci)  || (pCard->CardType == RAS4_Pci)  
				|| (pCard->CardType == Fast8_Isa)  || (pCard->CardType == Fast8_Pci)  || (pCard->CardType == RAS8_Pci)  
				|| (pCard->CardType == Fast16_Isa) || (pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
				{
					if(pPort->SpeedWmiFifoProp.HiFlowCtrlThreshold != *pBuffer)
					{
						status = STATUS_WMI_READ_ONLY;	// Flow ctrl threshold cannot be modified on Fast cards.
						break;
					}
				}

				pPort->HiFlowCtrlThreshold = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, HI_FLOW_CTRL_LEVEL, sizeof(HI_FLOW_CTRL_LEVEL), REG_DWORD, 
													&pPort->HiFlowCtrlThreshold, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;

			default:
				status = STATUS_WMI_ITEMID_NOT_FOUND;
				break;
			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}


    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spx_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING pMofResourceName,
						OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchSystemControl)
#pragma alloc_text(PAGE, SpxPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpxPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpxPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataItem)
#endif




/********************************************************************************
********************								*****************************
********************	Spx_SystemControlDispatch	*****************************
********************								*****************************
********************************************************************************/
NTSTATUS
Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		pCommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION	IrpDisposition;
	PDEVICE_OBJECT			pLowerDevObj = pCommonData->LowerDeviceObject;
    NTSTATUS				status = pIrp->IoStatus.Status;

    PAGED_CODE();

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DispatchSystemControl.\n", PRODUCT_NAME));

    status = WmiSystemControl(&pCommonData->WmiLibInfo, pDevObject, pIrp, &IrpDisposition);
                                 
    switch(IrpDisposition)
    {
        case IrpProcessed:
        {
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            // This irp has not been completed, but has been fully processed, we will complete it now.
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            // This irp is either not a WMI irp or is a WMI irp targetted at a device lower in the stack.

			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }
                                    
        default:
        {
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
			
			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }        
    }
    
	return(status);
}







// End of prototypes.


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID StdSerialPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID StdSerialPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID StdSerialPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID StdSerialPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID StdSerialPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI

WMIGUIDREGINFO SpxPort_WmiGuidList[] =
{
    { &StdSerialPortNameGuid, 1, 0 },
    { &StdSerialPortCommGuid, 1, 0 },
    { &StdSerialPortHWGuid, 1, 0 },
    { &StdSerialPortPerfGuid, 1, 0 },
    { &StdSerialPortPropertiesGuid, 1, 0}
};


#define SpxPort_WmiGuidCount (sizeof(SpxPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpxPort_WmiGuidCount;
    WmilibContext->GuidList				= SpxPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpxPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpxPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpxPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpxPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	
    WmilibContext->WmiFunctionControl	= NULL;	

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.


	return(status);
}





NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\spx_powr.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_POWER.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Handle all Power IRPS.												*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/
#define FILE_ID	SPX_POWR_C		// File ID for Event Logging see SPX_DEFS.H for values.

BOOLEAN	BREAK_ON_POWER_UP = FALSE;

// Prototypes
NTSTATUS Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp);
NTSTATUS Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp);
NTSTATUS Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp);
// End of prototypes


// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchPower)

#pragma alloc_text(PAGE, Spx_Card_FDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_CardSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_CardSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD3)

#pragma alloc_text(PAGE, Spx_Port_PDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_PortQuerySystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD3)

#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	Routine Description:
//		The power dispatch routine determine if the IRP is for a card or a port and 
//		then call the correct dispatch routine.
//
//	Arguments:
//		pDevObject	- pointer to a device object.
//		pIrp		- pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		CommonData	= (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO) 
        status = Spx_Card_FDO_DispatchPower(pDevObject, pIrp);
	else 
        status = Spx_Port_PDO_DispatchPower(pDevObject, pIrp);

    return status;
}	// Spx_DispatchPower


	
//////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//		The power dispatch routine to handle power IRPs for card devices.
//
//	Arguments:
//		pFDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pFDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:	// Driver MUST never fail this IRP.
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetSystemPowerState(pFDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetDevicePowerState(pFDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break; 
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
			
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			status = STATUS_NOT_SUPPORTED;
			break;

	}

	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_Card_FDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetSystemPowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetSystemPowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetSystemPowerState


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetDevicePowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetDevicePowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D0.\n", 
			PRODUCT_NAME, pCard->CardNumber));
		
		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D0.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D1.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D2.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D3.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D3.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}


	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetDevicePowerState




//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD0 -  Sets power state D0 for Card - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD0 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	status = Spx_PowerWaitForDriverBelow(pCard->LowerDeviceObject, pIrp);

	
#if DBG
	if(BREAK_ON_POWER_UP)
	{
		BREAK_ON_POWER_UP = FALSE;
	    KdPrint(("%s: Breaking debugger whilst powering up Card %d to debug after a hibernate\n", PRODUCT_NAME, pCard->CardNumber)); 
		DbgBreakPoint();
	}
#endif

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_CardPowerUp(pCard)))		// RESTORE HARDWARE STATE HERE & START CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD0;	// Store new power state.
		SetPnpPowerFlags(pCard, PPF_POWERED); 
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_SetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD3 -  Sets power state D3 for Card - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD3 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	ClearPnpPowerFlags(pCard, PPF_POWERED);		

	if(SPX_SUCCESS(pIrp->IoStatus.Status	= XXX_CardPowerDown(pCard))) // SAVE HARDWARE STATE HERE & STOP CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);						// Ready for next power IRP.
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);	// Pass IRP on down.

	return status;
}	// Spx_SetPowerStateD3







	
//////////////////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//	The power dispatch routine to handle power IRPs for port devices.
//
//	Arguments:
//		pPDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pPDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetSystemPowerState(pPDO, pIrp);
				
			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetDevicePowerState(pPDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
				
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortQuerySystemPowerState(pPDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));

				switch(pIrpStack->Parameters.Power.State.DeviceState)
				{
				case PowerDeviceD0:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to power state D0.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = STATUS_SUCCESS;
					break;

				case PowerDeviceD1:
				case PowerDeviceD2:
				case PowerDeviceD3:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to low power state D1, D2 or D3.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = XXX_PortQueryPowerDown(pPort);
					break;

				default:
					status = STATUS_SUCCESS;
					break;
					
				}

				break;
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));
				break;
			}

			pIrp->IoStatus.Status = status;
			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_SUPPORTED;
			break;
	}

	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_Port_PDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortSetSystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetSystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetSystemPowerState

//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortQuerySystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortQuerySystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortQuerySystemPowerState



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetDevicePowerState 
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetDevicePowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D0.\n", 
			PRODUCT_NAME, pPort->PortNumber));
		
		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D0.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D1.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D2.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D3.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D3.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetDevicePowerState 


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD0 -  Sets power state D0 for Port - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD0 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerUp(pPort)))		// RESTORE HARDWARE STATE HERE & START PORT
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pPort->DeviceState = PowerDeviceD0;	// Store new power state.
		SetPnpPowerFlags(pPort, PPF_POWERED); 
		Spx_UnstallIrps(pPort);				// Restart any queued IRPs (from a previous start)  
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD3 -  Sets power state D3 for Port - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD3 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	ClearPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerDown(pPort)))	// SAVE HARDWARE STATE HERE & STOP PORT
	{   
		// Inform Power Manager the of the new power state. 
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);
		pPort->DeviceState  = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD3



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PowerWaitForDriverBelow -  Waits for lower driver.
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp)
{
	KEVENT		EventWaitLowerDrivers;
	NTSTATUS	status;

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCopyCurrentIrpStackLocationToNext(pIrp);								// Copy parameters to the stack below 
	KeInitializeEvent(&EventWaitLowerDrivers, SynchronizationEvent, FALSE);	// Initialise event if need to wait 
	IoSetCompletionRoutine(pIrp, Spx_DispatchPnpPowerComplete, &EventWaitLowerDrivers, TRUE, TRUE, TRUE);

	if((status = PoCallDriver(pLowerDevObj, pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&EventWaitLowerDrivers, Executive, KernelMode, FALSE, NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} // Spx_PowerWaitForDriverBelow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\inc\esils.h ===
/************************************************************************/
/*																		*/
/*	Title:		Engineering Services Incident Log (ESIL)				*/
/*																		*/
/*	Author:		P.B Smith												*/
/*																		*/
/*	Version:	1.0.0 (SPEED NT Driver Version)							*/
/*																		*/
/*	Creation:	12th April 1999											*/
/*																		*/
/*	Description:	Contains descriptions and definitions of all		*/
/*					ESIL reports and modifications applied to the		*/
/*					SPEED NT Driver.									*/
/*																		*/
/************************************************************************/
#ifndef ESILS_H
#define ESILS_H

/* ESIL Log...
	
	ESIL		Date	 Author		Description
	====		====	 ======		=========== */




#endif	// End of ESILS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\write.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

//Prototypes
BOOLEAN SerialGiveWriteToIsr(IN PVOID Context);
VOID SerialCancelCurrentWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOLEAN SerialGrabWriteFromIsr(IN PVOID Context);
BOOLEAN SerialGrabXoffFromIsr(IN PVOID Context);
VOID SerialCancelCurrentXoff(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOLEAN SerialGiveXoffToIsr(IN PVOID Context);
//End of prototypes.    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERIRPPATH, ("Write Irp dispatch entry for: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) 
	{
        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //

        return SerialStartOrQueue(	pPort,
									Irp,
									&pPort->WriteQueue,
									&pPort->CurrentWriteIrp,
									SerialStartWrite);
    } 
	else 
	{
        Irp->IoStatus.Status = STATUS_SUCCESS;
        SerialDump(SERIRPPATH,("Complete Write Irp: %x\n",Irp));
       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,0);

        return STATUS_SUCCESS;
    }

}

NTSTATUS
SerialStartWrite(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

-----------------------------------------------------------------------------*/
{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    do 
	{
        // If there is an xoff counter then complete it.
        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if(pPort->CurrentXoffIrp) 
		{
            if(SERIAL_REFERENCE_COUNT(pPort->CurrentXoffIrp)) 
			{
                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //
                SERIAL_SET_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_XOFF_REF);

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(	pPort,
											SerialGrabXoffFromIsr,
											OldIrql,
											STATUS_SERIAL_MORE_WRITES,
											&pPort->CurrentXoffIrp,
											NULL,
											NULL,
											&pPort->XoffCountTimer,
											NULL,
											NULL,
											SERIAL_REF_XOFF_REF);
            } 
			else 
			{

                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

            }

        } 
		else 
		{
            IoReleaseCancelSpinLock(OldIrql);
        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
        Timeouts = pPort->Timeouts;
        KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            

        if(Timeouts.WriteTotalTimeoutConstant ||  Timeouts.WriteTotalTimeoutMultiplier)
		{
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
                                           
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading
            // as a write.
            //

            TotalTime.QuadPart = ((LONGLONG)((UInt32x32To64((IrpSp->MajorFunction == IRP_MJ_WRITE) 
								? (IrpSp->Parameters.Write.Length) : (1), 
								Timeouts.WriteTotalTimeoutMultiplier) + Timeouts.WriteTotalTimeoutConstant))) 
								* -10000;

        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //
        SERIAL_INIT_REFERENCE(pPort->CurrentWriteIrp);

        //
        // We need to see if this irp should be canceled.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        if(pPort->CurrentWriteIrp->Cancel) 
		{
            IoReleaseCancelSpinLock(OldIrql);
            pPort->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if(!SetFirstStatus) 
			{
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }
        }
		else 
		{
            if(!SetFirstStatus) 
			{
                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(pPort->CurrentWriteIrp, SerialCancelCurrentWrite);

            SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_CANCEL);

            if(UseATimer) 
			{
                KeSetTimer(&pPort->WriteRequestTotalTimer, TotalTime, &pPort->TotalWriteTimeoutDpc);
                    
                // This timer now has a reference to the irp.
                SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_TOTAL_TIMER);
            }

            KeSynchronizeExecution(pPort->Interrupt, SerialGiveWriteToIsr, pPort);
                
            IoReleaseCancelSpinLock(OldIrql);
            break;
        }

        //
        // Well the write was canceled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return FirstStatus;

}

VOID
SerialGetNextWrite(IN PPORT_DEVICE_EXTENSION pPort,
				   IN PIRP *CurrentOpIrp,
				   IN PLIST_ENTRY QueueToProcess,
				   IN PIRP *NewIrp,
				   IN BOOLEAN CompleteCurrent)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
	PCARD_DEVICE_EXTENSION pCard = NULL;
    pPort = CONTAINING_RECORD(QueueToProcess, PORT_DEVICE_EXTENSION, WriteQueue);
	pCard = pPort->pParentCardExt;

    do 
	{
        // We could be completing a flush.
        if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_WRITE)
		{
            KIRQL OldIrql;

            ASSERT(pPort->TotalCharsQueued 
				>= (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length));
                  
                    

            IoAcquireCancelSpinLock(&OldIrql);

            pPort->TotalCharsQueued -= IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length;
                
            IoReleaseCancelSpinLock(OldIrql);

        } 
		else if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL)
		{

            KIRQL OldIrql;
            PIRP Irp;
            PSERIAL_XOFF_COUNTER Xc;

            IoAcquireCancelSpinLock(&OldIrql);

            Irp = *CurrentOpIrp;
            Xc = Irp->AssociatedIrp.SystemBuffer;

            // We should never have a xoff counter when we get to this point.
            ASSERT(!pPort->CurrentXoffIrp);

            // We absolutely shouldn't have a cancel routine at this point.
            ASSERT(!Irp->CancelRoutine);

            // This could only be a xoff counter masquerading as a write irp.
            pPort->TotalCharsQueued--;

            //
            // Check to see of the xoff irp has been set with success.
            // This means that the write completed normally.  If that
            // is the case, and it hasn't been set to cancel in the
            // meanwhile, then go on and make it the CurrentXoffIrp.
            //

            if(Irp->IoStatus.Status != STATUS_SUCCESS) 
			{
                NOTHING; // Oh well, we can just finish it off.
            } 
			else if(Irp->Cancel) 
			{
                Irp->IoStatus.Status = STATUS_CANCELLED;
            } 
			else 
			{
                // Give it a new cancel routine, and increment the
                // reference count because the cancel routine has
                // a reference to it.
                IoSetCancelRoutine(Irp, SerialCancelCurrentXoff);
                SERIAL_SET_REFERENCE(Irp, SERIAL_REF_CANCEL);
                    

                // We don't want to complete the current irp now.  This
                // will now get completed by the Xoff counter code.
                CompleteCurrent = FALSE;


                // Give the counter to the isr.
                pPort->CurrentXoffIrp = Irp;
                KeSynchronizeExecution(pPort->Interrupt, SerialGiveXoffToIsr, pPort);
                    

                //
                // Start the timer for the counter and increment
                // the reference count since the timer has a
                // reference to the irp.
                //

                if(Xc->Timeout) 
				{
                    LARGE_INTEGER delta;

                    delta.QuadPart = -((LONGLONG)UInt32x32To64(1000, Xc->Timeout));

                    KeSetTimer(&pPort->XoffCountTimer, delta, &pPort->XoffCountTimeoutDpc);

                    SERIAL_SET_REFERENCE(Irp, SERIAL_REF_TOTAL_TIMER);
                }

            }

            IoReleaseCancelSpinLock(OldIrql);

        }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(pPort, CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent);

        if(!*NewIrp) 
		{
            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            KeSynchronizeExecution(pPort->Interrupt, SerialProcessEmptyTransmit, pPort);
            IoReleaseCancelSpinLock(OldIrql);

            break;

        } 
		else if(IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction == IRP_MJ_FLUSH_BUFFERS)
		{

            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //
            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
        } 
		else 
		{
            break;
        }

    } while (TRUE);

}

VOID
SerialCompleteWrite(IN PKDPC Dpc,
					IN PVOID DeferredContext,
					IN PVOID SystemContext1,
					IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.
-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort,
								NULL,
								OldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentWriteIrp,
								&pPort->WriteQueue,
								NULL,
								&pPort->WriteRequestTotalTimer,
								SerialStartWrite,
								SerialGetNextWrite,
								SERIAL_REF_ISR);
}

BOOLEAN
SerialProcessEmptyTransmit(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->IsrWaitMask && (pPort->IsrWaitMask & SERIAL_EV_TXEMPTY) 
		&& pPort->EmptiedTransmit && (!pPort->TransmitImmediate) 
		&& (!pPort->CurrentWriteIrp) && IsListEmpty(&pPort->WriteQueue)) 
	{
        pPort->HistoryMask |= SERIAL_EV_TXEMPTY;
        
		if(pPort->IrpMaskLocation) 
		{

            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

			// Mark IRP as about to complete normally to prevent cancel & timer DPCs
			// from doing so before DPC is allowed to run.
			//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
           
			KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
        }

        pPort->CountOfTryingToLowerRTS++;
        SerialPerhapsLowerRTS(pPort);
    }

    return FALSE;

}



BOOLEAN
SerialGiveWriteToIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Try to start off the write by slipping it in behind a transmit immediate
	char, or if that isn't available and the transmit holding register is empty,
	"tickle" the UART into interrupting with a transmit buffer empty.

    NOTE: This routine is called by KeSynchronizeExecution.
    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    // The current stack location.  This contains all of the
    // information we need to process this particular request.

    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    if(IrpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->WriteLength = IrpSp->Parameters.Write.Length;
        pPort->WriteCurrentChar = pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer;
    } 
	else 
	{
        pPort->WriteLength = 1;
        pPort->WriteCurrentChar = ((PUCHAR)pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer) 
								+ FIELD_OFFSET(SERIAL_XOFF_COUNTER, XoffChar);
    }

    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_ISR);

	pPort->pUartLib->UL_WriteData_XXXX(pPort->pUart, pPort->WriteCurrentChar, pPort->WriteLength);

    // The rts line may already be up from previous writes,
    // however, it won't take much additional time to turn
    // on the RTS line if we are doing transmit toggling.
    if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE) 
        SerialSetRTS(pPort);


    return FALSE;

}



VOID
SerialCancelCurrentWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabWriteFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentWriteIrp,
								&pPort->WriteQueue,
								NULL,
								&pPort->WriteRequestTotalTimer,
								SerialStartWrite,
								SerialGetNextWrite,
								SERIAL_REF_CANCEL);
        
}

VOID
SerialWriteTimeout(IN PKDPC Dpc,
				   IN PVOID DeferredContext,
				   IN PVOID SystemContext1,
				   IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabWriteFromIsr,
								OldIrql,
								STATUS_TIMEOUT,
								&pPort->CurrentWriteIrp,
								&pPort->WriteQueue,
								NULL,
								&pPort->WriteRequestTotalTimer,
								SerialStartWrite,
								SerialGetNextWrite,
								SERIAL_REF_TOTAL_TIMER);
}

BOOLEAN
SerialGrabWriteFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.

    if(pPort->WriteLength) 
	{
        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if(IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->MajorFunction == IRP_MJ_WRITE)
		{

            pPort->CurrentWriteIrp->IoStatus.Information 
				= IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length 
				- pPort->WriteLength;
        } 
		else 
		{
            pPort->CurrentWriteIrp->IoStatus.Information = 0;
        }

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_CLEAR_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_ISR);

		// Flush the output buffer.
		pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, NULL, UL_BC_OP_FLUSH, UL_BC_BUFFER | UL_BC_OUT);

        pPort->WriteLength = 0;

    }

    return FALSE;
}

BOOLEAN
SerialGrabXoffFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->CountSinceXoff) 
	{
        // This is only non-zero when there actually is a Xoff ioctl counting down.
        pPort->CountSinceXoff = 0;

        // We decrement the count since the isr no longer owns the irp.
        SERIAL_CLEAR_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_ISR);
    }

    return FALSE;
}


VOID
SerialCompleteXoff(IN PKDPC Dpc,
				   IN PVOID DeferredContext,
				   IN PVOID SystemContext1,
				   IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort,
								NULL,
								OldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentXoffIrp,
								NULL,
								NULL,
								&pPort->XoffCountTimer,
								NULL,
								NULL,
								SERIAL_REF_ISR);
}

VOID
SerialTimeoutXoff(IN PKDPC Dpc,
				  IN PVOID DeferredContext,
				  IN PVOID SystemContext1,
				  IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabXoffFromIsr,
								OldIrql,
								STATUS_SERIAL_COUNTER_TIMEOUT,
								&pPort->CurrentXoffIrp,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL,
								SERIAL_REF_TOTAL_TIMER);
}

VOID
SerialCancelCurrentXoff(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabXoffFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentXoffIrp,
								NULL,
								NULL,
								&pPort->XoffCountTimer,
								NULL,
								NULL,
								SERIAL_REF_CANCEL);
}

BOOLEAN
SerialGiveXoffToIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    PSERIAL_XOFF_COUNTER Xc = pPort->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    ASSERT(pPort->CurrentXoffIrp);
    pPort->CountSinceXoff = Xc->Counter;

    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_ISR);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\utils.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains code that perform queueing and completion
    manipulation on requests.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

VOID SerialRundownIrpRefs(IN PIRP *CurrentOpIrp, IN PKTIMER IntervalTimer, IN PKTIMER TotalTimer);
    

#ifdef ALLOC_PRAGMA
#endif


VOID
SerialKillAllReadsOrWrites(IN PDEVICE_OBJECT DeviceObject, 
						   IN PLIST_ENTRY QueueToClean, 
						   IN PIRP *CurrentOpIrp)
/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    DeviceObject - A pointer to the serial device object.

    QueueToClean - A pointer to the queue which we're going to clean out.

    CurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(QueueToClean)) 
	{
        PIRP currentLastIrp = CONTAINING_RECORD(QueueToClean->Blink, IRP, Tail.Overlay.ListEntry);

		SpxIRPCounter(pPort, currentLastIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.
        RemoveEntryList(QueueToClean->Blink);

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(DeviceObject, currentLastIrp);
            
        IoAcquireCancelSpinLock(&cancelIrql);
    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if(*CurrentOpIrp) 
	{
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //

        if(cancelRoutine) 
		{
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for it.
            //
            cancelRoutine(DeviceObject, *CurrentOpIrp);
        } 
		else 
		{
            IoReleaseCancelSpinLock(cancelIrql);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(cancelIrql);
    }

}


VOID
SerialGetNextIrp(IN PPORT_DEVICE_EXTENSION pPort,
				 IN PIRP *CurrentOpIrp,
				 IN PLIST_ENTRY QueueToProcess,
				 OUT PIRP *NextIrp,
				 IN BOOLEAN CompleteCurrent)
/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    KIRQL oldIrql;
    PIRP oldIrp;


    IoAcquireCancelSpinLock(&oldIrql);

    oldIrp = *CurrentOpIrp;

    if(oldIrp) 
	{
        if(CompleteCurrent) 
            ASSERT(!oldIrp->CancelRoutine);
    }

    //
    // Check to see if there is a new irp to start up.
    //

    if(!IsListEmpty(QueueToProcess)) 
	{
        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(headOfList, IRP, Tail.Overlay.ListEntry);
		SpxIRPCounter(pPort, *CurrentOpIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    } 
	else 
	{
        *CurrentOpIrp = NULL;
    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(oldIrql);

    if(CompleteCurrent) 
	{
        if(oldIrp) 
		{
            SerialDump(SERIRPPATH, ("Complete Irp: %x\n", oldIrp));
			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
        }
    }

}


VOID
SerialTryToCompleteCurrent(IN PPORT_DEVICE_EXTENSION pPort,
						   IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
						   IN KIRQL IrqlForRelease,
						   IN NTSTATUS StatusToUse,
						   IN PIRP *CurrentOpIrp,
						   IN PLIST_ENTRY QueueToProcess OPTIONAL,
						   IN PKTIMER IntervalTimer OPTIONAL,
						   IN PKTIMER TotalTimer OPTIONAL,
						   IN PSERIAL_START_ROUTINE Starter OPTIONAL,
						   IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
						   IN LONG RefType)

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Extension - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //

	// If RefType was not the ISR reference 
	if(RefType != SERIAL_REF_ISR)
	{
		SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, RefType);		// Clear the reference
	}
	else 
	{
		if(SERIAL_REFERENCE_COUNT(*CurrentOpIrp) & RefType)	// If reference is for ISR and is still set. 
			SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, RefType);		// Clear it.
	}

        
    if(SynchRoutine)
        KeSynchronizeExecution(pPort->Interrupt, SynchRoutine, pPort);


    //
    // Try to run down all other references to this irp.
    //

    SerialRundownIrpRefs(CurrentOpIrp, IntervalTimer, TotalTimer);
        

    //
    // See if the ref count is zero after trying to kill everybody else.
    //
    if(!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) 
	{
        PIRP newIrp;

        //
        // The ref count was zero so we should complete this request.
        // The following call will also cause the current irp to be completed.
        //
        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if(StatusToUse == STATUS_CANCELLED) 
            (*CurrentOpIrp)->IoStatus.Information = 0;


        if(GetNextIrp) 
		{
            IoReleaseCancelSpinLock(IrqlForRelease);
            
			GetNextIrp(pPort, CurrentOpIrp, QueueToProcess, &newIrp, TRUE);
            
			if(newIrp) 
                Starter(pPort);
        } 
		else 
		{

            PIRP oldIrp = *CurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //

            *CurrentOpIrp = NULL;

            IoReleaseCancelSpinLock(IrqlForRelease);
            SerialDump(SERIRPPATH, ("Complete Irp: %x\n", oldIrp));
			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(IrqlForRelease);
    }

}


VOID
SerialRundownIrpRefs(IN PIRP *CurrentOpIrp,
					 IN PKTIMER IntervalTimer OPTIONAL,
					 IN PKTIMER TotalTimer OPTIONAL)
/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

Return Value:

    None.

--*/
{

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if((*CurrentOpIrp)->CancelRoutine) 
	{
        SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_CANCEL);

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    }

    if(IntervalTimer) 
	{
        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(IntervalTimer)) 
		{
            SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_INT_TIMER);
        }

    }

    if(TotalTimer) 
	{
        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(TotalTimer)) 
		{
            SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_TOTAL_TIMER);
        }

    }

}


NTSTATUS
SerialStartOrQueue(IN PPORT_DEVICE_EXTENSION pPort,
				   IN PIRP Irp,
				   IN PLIST_ENTRY QueueToExamine,
				   IN PIRP *CurrentOpIrp,
				   IN PSERIAL_START_ROUTINE Starter)
/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    Extension - Points to the serial device extension.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{

    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if(IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_WRITE)
	{
        pPort->TotalCharsQueued += IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length;

    } else if((IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_DEVICE_CONTROL)
                && ((IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR) 
                ||(IoGetCurrentIrpStackLocation(Irp) ->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))) 
	{
        pPort->TotalCharsQueued++;
    }

    if((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp))
	{
        //
        // There were no current operation.  Mark this one as
        // current and start it up.
        //

        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(pPort);
    } 
	else 
	{
        //
        // We don't know how long the irp will be in the
        // queue.  So we need to handle cancel.
        //

        if(Irp->Cancel) 
		{
            IoReleaseCancelSpinLock(oldIrql);

            Irp->IoStatus.Status = STATUS_CANCELLED;

            SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);
            
			return STATUS_CANCELLED;

        } 
		else 
		{
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(QueueToExamine, &Irp->Tail.Overlay.ListEntry);

            IoSetCancelRoutine(Irp, SerialCancelQueued);
			
			SpxIRPCounter(pPort, Irp, IRP_QUEUED);	// Increment counter for performance stats.

            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;
        }

    }

}


VOID
SerialCancelQueued(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*++

Routine Description:

    This routine is used to cancel Irps that currently reside on
    a queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
	SpxIRPCounter(pPort, Irp, IRP_DEQUEUED);	// Decrement counter for performance stats.

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued -= irpSp->Parameters.Write.Length;
    } 
	else if(irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
	{
        //
        // If it's an immediate then we need to decrement the
        // count of chars queued.  If it's a resize then we
        // need to deallocate the pool that we're passing on
        // to the "resizing" routine.
        //
        if((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))
		{
            pPort->TotalCharsQueued--;
        } 
		else if(irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_QUEUE_SIZE) 
		{
            //
            // We shoved the pointer to the memory into the
            // the type 3 buffer pointer which we KNOW we
            // never use.
            //

            ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

            ExFreePool(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

            irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        }

    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_SERIAL_INCREMENT);
}



NTSTATUS
SerialCompleteIfError(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    if((pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pPort->ErrorWord)
	{
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //

        if((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) 
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_SERIAL_GET_COMMSTATUS))
		{
            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);
        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\inc\spd_card.h ===
#if !defined(SPD_CARD_H)
#define SPD_CARD_H	




#if DBG
#define SERDIAG1              ((ULONG)0x00000001)
#define SERDIAG2              ((ULONG)0x00000002)
#define SERDIAG3              ((ULONG)0x00000004)
#define SERDIAG4              ((ULONG)0x00000008)
#define SERDIAG5              ((ULONG)0x00000010)
#define SERIRPPATH            ((ULONG)0x00000020)
#define SERWARNING            ((ULONG)0x00000100)
#define SERINFO               ((ULONG)0x00000200)

#define SERFLOW               ((ULONG)0x00000400)
#define SERERRORS             ((ULONG)0x00000800)
#define SERBUGCHECK           ((ULONG)0x00001000)

// -- OXSER Diag 3 --
// Additional debug levels
#define PCIINFO               ((ULONG)0x00002000)
#define XTLINFO               ((ULONG)0x00004000)
#define ISRINFO				  ((ULONG)0x00008000)
#define TXINFO				  ((ULONG)0x00010000)
#define RXINFO				  ((ULONG)0x00020000)
#define LSINFO				  ((ULONG)0x00040000)
#define MSINFO				  ((ULONG)0x00080000)
#define KICKINFO			  ((ULONG)0x00100000)
#define FIFOINFO			  ((ULONG)0x00200000)
#define CLOSE_STATS			  ((ULONG)0x00400000)
#define BAUDINFO			  ((ULONG)0x00800000)	

extern ULONG SpxDebugLevel;

#define SerialDump(LEVEL,STRING)											\
    do {																	\
        ULONG _level = (LEVEL);												\
		if (SpxDebugLevel & _level) {										\
            DbgPrint STRING;												\
        }																	\
        if (_level == SERBUGCHECK) {										\
            ASSERT(FALSE);													\
        }																	\
    } while (0)
#else
#define SerialDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif





// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
#define DEFAULT_SERIAL_NAME L"COM"


// This define gives the default NT name for
// for serial ports detected by the firmware.
// This name will be appended to Device prefix
// with a number following it.  The number is
// incremented each time encounter a serial
// port detected by the firmware.  Note that
// on a system with multiple busses, this means
// that the first port on a bus is not necessarily
// \Device\Serial0.
//
#define DEFAULT_NT_SUFFIX L"Serial"



// Default xon/xoff characters.
#define SERIAL_DEF_XON		0x11
#define SERIAL_DEF_XOFF		0x13

// Reasons that recption may be held up.
#define SERIAL_RX_DTR       ((ULONG)0x01)
#define SERIAL_RX_XOFF      ((ULONG)0x02)
#define SERIAL_RX_RTS       ((ULONG)0x04)
#define SERIAL_RX_DSR       ((ULONG)0x08)

// Reasons that transmission may be held up.
#define SERIAL_TX_CTS       ((ULONG)0x01)
#define SERIAL_TX_DSR       ((ULONG)0x02)
#define SERIAL_TX_DCD       ((ULONG)0x04)
#define SERIAL_TX_XOFF      ((ULONG)0x08)
#define SERIAL_TX_BREAK     ((ULONG)0x10)


//////////////////////////////////////////////////////////////////////////////////////////
// SPEED Port Device Extenstion.
// Information specific to SPEED Ports.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _PORT_DEVICE_EXTENSION 
{

	COMMON_PORT_DEVICE_EXTENSION;		// Common Card Device Extension 

	ULONG			SysPortNumber;		// System port number 

	// Timing variables... 
    LARGE_INTEGER		IntervalTime;			// Read interval time 
	LARGE_INTEGER		ShortIntervalAmount;	// Short tread interval time 
	LARGE_INTEGER		LongIntervalAmount;		// Long read interval time 
	LARGE_INTEGER		CutOverAmount;			// Used to determine short/long interval time 
	LARGE_INTEGER		LastReadTime;			// System time of last read 
	PLARGE_INTEGER		IntervalTimeToUse;		// Interval timing delta time delay 
	
	// Queued IRP lists... 
	LIST_ENTRY		ReadQueue;		// Head of read IRP list, protected by cancel spinlock 
	LIST_ENTRY		WriteQueue;		// Head of write IRP list, protected by cancel spinlock 
	LIST_ENTRY		MaskQueue;		// Head of set/wait mask IRP list, protected by cancel spinlock 
	LIST_ENTRY		PurgeQueue;		// Head of purge IRP list, protected by cancel spinlock 

	// Current IRPs... 
	PIRP			CurrentReadIrp;			// Pointer to current read IRP 
	PIRP			CurrentWriteIrp;		// Pointer to current write IRP 
	PIRP			CurrentMaskIrp;			// Pointer to current mask IRP 
	PIRP			CurrentPurgeIrp;		// Pointer to current purge IRP 
	PIRP			CurrentWaitIrp;			// Pointer to current wait IRP 
	PIRP			CurrentImmediateIrp;	// Pointer to current send immediate IRP 
	PIRP			CurrentXoffIrp;			// Pointer to current XOFF_COUNTER IRP 

	// Write IRP variables... 
	ULONG			WriteLength;			// Write character count in current write IRP 
	PUCHAR			WriteCurrentChar;		// Pointer to write character in current write IRP 

	// Read IRP variables... 
	PUCHAR			InterruptReadBuffer;	// Read buffer current pointer in current read IRP 
	PUCHAR			ReadBufferBase;			// Read buffer base pointer in current read IRP 
	ULONG			CharsInInterruptBuffer;	// Characters read into read buffer 
//	KSPIN_LOCK		BufferLock;				// Spinlock protecting "CharsInInterruptBuffer" 
	PUCHAR			CurrentCharSlot;		// Pointer at space to store new read data 
	PUCHAR			LastCharSlot;			// Last valid position in read buffer 
	PUCHAR			FirstReadableChar;		// First read character in read buffer 
	ULONG			BufferSize;				// Read buffer size 
	ULONG			BufferSizePt8;			// 80% read buffer size 
	ULONG			NumberNeededForRead;	// Number of characters requested in current read IRP 

	// Mask IRP variables... 
	ULONG			IsrWaitMask;			// Wait mask in current wait IRP 
	ULONG			HistoryMask;			// History of masked events 
	ULONG			*IrpMaskLocation;		// Pointer to mask location 

	// Serial port configuration...
//	ULONG				CurrentBaud;		// Current baud rate 
	ULONG				SupportedBauds;		// Bitmask defining supported baud rates 
	SERIAL_HANDFLOW		HandFlow;			// Current handshaking and flow control settings 
	UCHAR				LineControl;		// Current parity,databits,stopbits 
	SERIAL_CHARS		SpecialChars;		// Current Special error/replacement characters 
	SERIAL_TIMEOUTS		Timeouts;			// Read and write timeouts 
	UCHAR				ValidDataMask;		// Read data mask 
	UCHAR				EscapeChar;			// Escape character used with line/modem status strings 
//	BOOLEAN				InsertEscChar;		// Indicates of EscapeChar should be inserted 

	// Serial port status... 
	LONG			CountSinceXoff;			// Nun chars read since XOFF counter started 
	ULONG			CountOfTryingToLowerRTS;// Count of processes trying to lower RTS 
	BOOLEAN			TransmitImmediate;		// Indicates of transmit immediate is pending 
	BOOLEAN			EmptiedTransmit;		// Indicates transmit empty 
	UCHAR			ImmediateChar;			// Character to be transmitted immediately 
	ULONG			TXHolding;				// Reasons for transmit blocked 
	ULONG			RXHolding;				// Reasons for receive blocked 
	ULONG			ErrorWord;				// Error conditions 
	ULONG			TotalCharsQueued;		// Total number of queued characters in all write IRPs 
	LONG			CountOnLastRead;		// Number of chars read last time interval timer DPC ran 
	ULONG			ReadByIsr;				// Number of characters read during ISR 

	KSPIN_LOCK		ControlLock;			// Used to protect certain fields 

	// Deferred procedure calls... 
	KDPC		CompleteWriteDpc;			// DPC used to complete write IRPs 
	KDPC		CompleteReadDpc;			// DPC used to complete read IRPs 
	KDPC		TotalReadTimeoutDpc;		// DPC used to handle read total timeout 
	KDPC		IntervalReadTimeoutDpc;		// DPC used to handle read interval timeout 
	KDPC		TotalWriteTimeoutDpc;		// DPC used to handle write total timeout 
	KDPC		CommErrorDpc;				// DPC used to handle cancel on error 
	KDPC		CommWaitDpc;				// DPC used to handle waking IRPs waiting on an event 
	KDPC		CompleteImmediateDpc;		// DPC used to handle transmitting an immediate character 
	KDPC		TotalImmediateTimeoutDpc;	// DPC used to handle immediate char timeout 
	KDPC		XoffCountTimeoutDpc;		// DPC used to handle XOFF_COUNT timeout 
	KDPC		XoffCountCompleteDpc;		// DPC used to complete XOFF_COUNT IRP 
	KDPC		StartTimerLowerRTSDpc;		// DPC used to check for RTS lowering 
	KDPC		PerhapsLowerRTSDpc;			// DPC used to check for RTS lowering 

	// Timers... 
	KTIMER		ReadRequestTotalTimer;		// Timer used to handle total read request timeout 
	KTIMER		ReadRequestIntervalTimer;	// Timer used to handle interval read timeout 
	KTIMER		WriteRequestTotalTimer;		// Timer used to handle total write request timeout 
	KTIMER		ImmediateTotalTimer;		// Timer used to handle send immediate timeout 
	KTIMER		XoffCountTimer;				// Timer used to handle XOFF_COUNT timeout 
	KTIMER		LowerRTSTimer;				// Timer used to handle lower RTS timing 



	PUART_LIB		pUartLib;	// Uart library finctions.
	PUART_OBJECT	pUart;
	UART_CONFIG		UartConfig;
	BOOLEAN			DTR_Set;
	BOOLEAN			RTS_Set;
	SET_BUFFER_SIZES BufferSizes;

	DWORD			MaxTxFIFOSize;		// Max Tx FIFO Size.
	DWORD			MaxRxFIFOSize;		// Max Rx FIFO Size.

	DWORD			TxFIFOSize;			// Tx FIFO Size.
	DWORD			RxFIFOSize;			// Rx FIFO Size.
	DWORD			TxFIFOTrigLevel;	// Tx FIFO Trigger Level.
	DWORD			RxFIFOTrigLevel;	// Rx FIFO Trigger Level.
	DWORD			HiFlowCtrlThreshold;	// High Flow Control Threshold.
	DWORD			LoFlowCtrlThreshold;	// Low Flow Control Threshold.

	#ifdef WMI_SUPPORT
	SPX_SPEED_WMI_FIFO_PROP		SpeedWmiFifoProp;
	#endif

	BYTE			ImmediateIndex;

    // This holds the isr that should be called from our own
    // dispatching isr for "cards" that are trying to share the
    // same interrupt.

    PKSERVICE_ROUTINE TopLevelOurIsr;

    // This holds the context that should be used when we
    // call the above service routine.
    
	PVOID TopLevelOurIsrContext;

    // This links together all of the different "cards" that are
    // trying to share the same interrupt of a non-mca machine.
    
    LIST_ENTRY TopLevelSharers;

    // This circular doubly linked list links together all
    // devices that are using the same interrupt object.
    // NOTE: This does not mean that they are using the
    // same interrupt "dispatching" routine.
    
    LIST_ENTRY CommonInterruptObject;

    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    
	PHYSICAL_ADDRESS OriginalController;

    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    
    PHYSICAL_ADDRESS OriginalInterruptStatus;




    // This points to the object directory that we will place
    // a symbolic link to our device name.
    
    UNICODE_STRING ObjectDirectory;
    
    // This points to the device name for this device
    // sans device prefix.
    
    UNICODE_STRING NtNameForPort;

    // After initialization of the driver is complete, this
    // will either be NULL or point to the routine that the
    // kernel will call when an interrupt occurs.
    
    // If the pointer is null then this is part of a list
    // of ports that are sharing an interrupt and this isn't
    // the first port that we configured for this interrupt.
    
    // If the pointer is non-null then this routine has some
    // kind of structure that will "eventually" get us into
    // the real serial isr with a pointer to this device extension.
    
    // NOTE: On an MCA bus (except for multiport cards) this
    // is always a pointer to the "real" serial isr.
    
	PKSERVICE_ROUTINE OurIsr;

    // This will generally point right to this device extension.
    //
    // However, when the port that this device extension is
    // "managing" was the first port initialized on a chain
    // of ports that were trying to share an interrupt, this
    // will point to a structure that will enable dispatching
    // to any port on the chain of sharers of this interrupt.
    
    PVOID OurIsrContext;

    // The base address for the set of device registers
    // of the serial port.
    
    PUCHAR Controller;

    // The base address for interrupt status register.
    // This is only defined in the root extension.
    
    PUCHAR InterruptStatus;

    // Points to the interrupt object for used by this device.
    
    PKINTERRUPT Interrupt;




    // Pointer to the lock variable returned for this extension when
    // locking down the driver
    
    PVOID LockPtr;


	// This value holds the span (in units of bytes) of the register
    // set controlling this port.  This is constant over the life
    // of the port.

    ULONG SpanOfController;

    // This value holds the span (in units of bytes) of the interrupt
    // status register associated with this port.  This is constant
    // over the life of the port.

    ULONG SpanOfInterruptStatus;

    // Hold the clock rate input to the serial part.

    ULONG ClockRate;

    // The number of characters to push out if a fifo is present.

    ULONG TxFifoAmount;

    // Set to indicate that it is ok to share interrupts within the device.

    ULONG PermitShare;





    // Set at intialization to indicate that on the current
    // architecture we need to unmap the base register address
    // when we unload the driver.

    BOOLEAN UnMapRegisters;

	// Set at intialization to indicate that on the current
    // architecture we need to unmap the interrupt status address
    // when we unload the driver.

    BOOLEAN UnMapStatus;

    // This is only accessed at interrupt level.  It keeps track
    // of whether the holding register is empty.

    BOOLEAN HoldingEmpty;



    // This simply indicates that the port associated with this
    // extension is part of a multiport card.

    BOOLEAN PortOnAMultiportCard;

    // We keep the following values around so that we can connect
    // to the interrupt and report resources after the configuration
    // record is gone.

    ULONG Vector;
    KIRQL Irql;
    ULONG OriginalVector;
    ULONG OriginalIrql;
    KINTERRUPT_MODE InterruptMode;
    KAFFINITY ProcessorAffinity;
    ULONG AddressSpace;
    ULONG BusNumber;
    INTERFACE_TYPE InterfaceType;



    // These two booleans are used to indicate to the isr transmit
    // code that it should send the xon or xoff character.  They are
    // only accessed at open and at interrupt level.

    BOOLEAN SendXonChar;
    BOOLEAN SendXoffChar;

    // This boolean will be true if a 16550 is present *and* enabled.

    BOOLEAN FifoPresent;

  	//	-- OXSER Mod 12 --
	// The Jensen does not interest us and all references to it have been
	// removed

	// This denotes that this particular port is an on the motherboard
    // port for the Jensen hardware.  On these ports the OUT2 bit
    // which is used to enable/disable interrupts is always hight.
    // BOOLEAN Jensen;
	
    // This is the water mark that the rxfifo should be
    // set to when the fifo is turned on.  This is not the actual
    // value, but the encoded value that goes into the register.

    UCHAR RxFifoTrigger;

    // Says whether this device can share interrupts with devices
    // other than serial devices.

    BOOLEAN InterruptShareable;


} PORT_DEVICE_EXTENSION, *PPORT_DEVICE_EXTENSION;











// PORT_DEVICE_EXTENSION.CountOnLastRead definitions... 
#define		SERIAL_COMPLETE_READ_CANCEL		((LONG)-1)
#define		SERIAL_COMPLETE_READ_TOTAL		((LONG)-2)
#define		SERIAL_COMPLETE_READ_COMPLETE	((LONG)-3)


// PORT_DEVICE_EXTENSION.LineControl definitions... 
#define		SERIAL_5_DATA		((UCHAR)0x00)
#define		SERIAL_6_DATA		((UCHAR)0x01)
#define		SERIAL_7_DATA		((UCHAR)0x02)
#define		SERIAL_8_DATA		((UCHAR)0x03)
#define		SERIAL_DATA_MASK	((UCHAR)0x03)

#define		SERIAL_1_STOP		((UCHAR)0x00)
#define		SERIAL_1_5_STOP		((UCHAR)0x04) // Only valid for 5 data bits
#define		SERIAL_2_STOP		((UCHAR)0x04) // Not valid for 5 data bits
#define		SERIAL_STOP_MASK	((UCHAR)0x04)

#define		SERIAL_NONE_PARITY	((UCHAR)0x00)
#define		SERIAL_ODD_PARITY	((UCHAR)0x08)
#define		SERIAL_EVEN_PARITY	((UCHAR)0x18)
#define		SERIAL_MARK_PARITY	((UCHAR)0x28)
#define		SERIAL_SPACE_PARITY	((UCHAR)0x38)
#define		SERIAL_PARITY_MASK	((UCHAR)0x38)
#define		SERIAL_LCR_BREAK	0x40


// PORT_DEVICE_EXTENSION.SpecialChars default xon/xoff characters... 
#define		SERIAL_DEF_XON		0x11
#define		SERIAL_DEF_XOFF		0x13

// PORT_DEVICE_EXTENSION.TXHolding definitions... 
#define		SERIAL_TX_CTS		((ULONG)0x01)
#define		SERIAL_TX_DSR		((ULONG)0x02)
#define		SERIAL_TX_DCD		((ULONG)0x04)
#define		SERIAL_TX_XOFF		((ULONG)0x08)
#define		SERIAL_TX_BREAK		((ULONG)0x10)

// PORT_DEVICE_EXTENSION.RXHolding definitions...
#define		SERIAL_RX_DTR		((ULONG)0x01)
#define		SERIAL_RX_XOFF		((ULONG)0x02)
#define		SERIAL_RX_RTS		((ULONG)0x04)
#define		SERIAL_RX_DSR		((ULONG)0x08)	
#define		SERIAL_RX_FULL      ((ULONG)0x10)   // VIV: If Io8 Rx queue is full.

// PORT_DEVICE_EXTENSION.LastStatus definitions... 
#define		SERIAL_LSR_DR       0x01
#define		SERIAL_LSR_OE		0x02
#define		SERIAL_LSR_PE		0x04
#define		SERIAL_LSR_FE		0x08
#define		SERIAL_LSR_BI		0x10

// 16550 Modem Control Register definitions... 
#define		SERIAL_MCR_DTR		0x01
#define		SERIAL_MCR_RTS		0x02

// 16550 Modem Status Register definitions... 
#define		SERIAL_MSR_DCTS		0x01
#define		SERIAL_MSR_DDSR		0x02
#define		SERIAL_MSR_TERI		0x04
#define		SERIAL_MSR_DDCD		0x08
#define		SERIAL_MSR_CTS		0x10
#define		SERIAL_MSR_DSR		0x20
#define		SERIAL_MSR_RI		0x40
#define		SERIAL_MSR_DCD		0x80



// These masks define the interrupts that can be enabled or disabled.
//
// This interrupt is used to notify that there is new incomming
// data available.  The SERIAL_RDA interrupt is enabled by this bit.
#define SERIAL_IER_RDA   0x01


// This interrupt is used to notify that there is space available
// in the transmitter for another character.  The SERIAL_THR
// interrupt is enabled by this bit.
#define SERIAL_IER_THR   0x02

// This interrupt is used to notify that some sort of error occured
// with the incomming data.  The SERIAL_RLS interrupt is enabled by
// this bit.
#define SERIAL_IER_RLS   0x04

// This interrupt is used to notify that some sort of change has
// taken place in the modem control line.  The SERIAL_MS interrupt is
// enabled by this bit.
#define SERIAL_IER_MS    0x08


// These masks define the values of the interrupt identification
// register.  The low bit must be clear in the interrupt identification
// register for any of these interrupts to be valid.  The interrupts
// are defined in priority order, with the highest value being most
// important.  See above for a description of what each interrupt
// implies.
#define SERIAL_IIR_RLS      0x06
#define SERIAL_IIR_RDA      0x04
#define SERIAL_IIR_CTI      0x0c
#define SERIAL_IIR_THR      0x02
#define SERIAL_IIR_MS       0x00


// This bit mask get the value of the high two bits of the
// interrupt id register.  If this is a 16550 class chip
// these bits will be a one if the fifo's are enbled, otherwise
// they will always be zero.
#define SERIAL_IIR_FIFOS_ENABLED 0xc0

// If the low bit is logic one in the interrupt identification register
// this implies that *NO* interrupts are pending on the device.
#define SERIAL_IIR_NO_INTERRUPT_PENDING 0x01




// These masks define access to the fifo control register.

// Enabling this bit in the fifo control register will turn
// on the fifos.  If the fifos are enabled then the high two
// bits of the interrupt id register will be set to one.  Note
// that this only occurs on a 16550 class chip.  If the high
// two bits in the interrupt id register are not one then
// we know we have a lower model chip.
#define SERIAL_FCR_ENABLE     ((UCHAR)0x01)
#define SERIAL_FCR_RCVR_RESET ((UCHAR)0x02)
#define SERIAL_FCR_TXMT_RESET ((UCHAR)0x04)


// This set of values define the high water marks (when the
// interrupts trip) for the receive fifo.
#define SERIAL_1_BYTE_HIGH_WATER   ((UCHAR)0x00)
#define SERIAL_4_BYTE_HIGH_WATER   ((UCHAR)0x40)
#define SERIAL_8_BYTE_HIGH_WATER   ((UCHAR)0x80)
#define SERIAL_14_BYTE_HIGH_WATER  ((UCHAR)0xc0)



// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
#define SERIAL_LCR_DLAB     0x80


// This bit is used for general purpose output.
#define SERIAL_MCR_OUT1     0x04

// This bit is used for general purpose output.
#define SERIAL_MCR_OUT2     0x08

// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
#define SERIAL_MCR_LOOP     0x10


// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
#define SERIAL_LSR_THRE     0x20


// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
#define SERIAL_LSR_TEMT     0x40


// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
#define SERIAL_LSR_FIFOERR  0x80


//
// This should be more than enough space to hold then
// numeric suffix of the device name.
//
#define DEVICE_NAME_DELTA 20


//
// Up to 16 Ports Per card.  However for sixteen
// port cards the interrupt status register must be
// the indexing kind rather then the bitmask kind.
//
#define SERIAL_MAX_PORTS_INDEXED      (16)
#define SERIAL_MAX_PORTS_NONINDEXED   (8)




















//////////////////////////////////////////////////////////////////////////////////////////
// SPEED Card Device Extenstion.
// Information specific to SPEED cards.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CARD_DEVICE_EXTENSION 
{

	COMMON_CARD_DEVICE_EXTENSION;	// Common Card Device Extension 
	
	ULONG CrystalFrequency;			// Frequency of onboard crystal

	PHYSICAL_ADDRESS	PCIConfigRegisters;
	ULONG				SpanOfPCIConfigRegisters;
	PUCHAR				LocalConfigRegisters;


	PUCHAR InterruptStatus;
    PPORT_DEVICE_EXTENSION Extensions[SERIAL_MAX_PORTS_INDEXED];
    ULONG MaskInverted;
    UCHAR UsablePortMask;
	ULONG UARTOffset;
	ULONG UARTRegStride;
 
	// First UART in the list to be serviced next by the ISR.
	PUART_OBJECT	pFirstUart;

	UART_LIB		UartLib;	// Uart library finctions.

	ULONG CardOptions;
	

} CARD_DEVICE_EXTENSION, *PCARD_DEVICE_EXTENSION;


#endif // End of SPD_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\waitmask.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    waitmask.c

Abstract:

    This module contains the code that is very specific to get/set/wait
    on event mask operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

// Prototypes
BOOLEAN SerialGrabWaitFromIsr(IN PVOID Context);
BOOLEAN SerialGiveWaitToIsr(IN PVOID Context);
BOOLEAN SerialFinishOldWait(IN PVOID Context);
// End of prototypes    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialStartMask(IN PPORT_DEVICE_EXTENSION pPort)
/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/
{

    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SerialDump(SERDIAG3,("In SerialStartMask\n"));

    ASSERT(pPort->CurrentMaskIrp);

    do 
	{
        SerialDump(SERDIAG4,("STARTMASK - CurrentMaskIrp: %x\n", pPort->CurrentMaskIrp));

        IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK) 
			|| (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK));
                

        if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK)
		{

            SerialDump(SERDIAG4, ("SERIAL - %x is a SETMASK irp\n", pPort->CurrentMaskIrp));
                
            // Complete the old wait if there is one.
            KeSynchronizeExecution(pPort->Interrupt, SerialFinishOldWait, pPort);
                

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!pPort->IrpMaskLocation);

            pPort->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if(!SetFirstStatus) 
			{
                SerialDump(SERDIAG4,("%x was the first irp processed by this\n"
									   "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                    
                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;
            }

            // The following call will also cause the current call to be completed.
            SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                
                
            SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                "------- %x/%x <- values should be the same\n", pPort->CurrentMaskIrp, NewIrp));

        } 
		else 
		{
            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be statisfied so it makes no sense to start it.
            //

            if((!pPort->IsrWaitMask) || (pPort->CurrentWaitIrp)) 
			{

                SerialDump(SERDIAG4,("WaitIrp is invalid\n"
                    "------- IsrWaitMask: %x\n"
                    "------- CurrentWaitIrp: %x\n",
                     pPort->IsrWaitMask,
                     pPort->CurrentWaitIrp));
                     

                pPort->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                if(!SetFirstStatus) 
				{
                    SerialDump(SERDIAG4,("%x was the first irp processed by this\n"
                         "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                        
                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;
                }

                SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                    
                    
                    
                SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                    "------- %x/%x <- values should be the same\n",
                    pPort->CurrentMaskIrp,NewIrp));

            } 
			else 
			{
                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be canceled
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if(pPort->CurrentMaskIrp->Cancel) 
				{
                    SerialDump(SERDIAG4, ("%x irp was already marked as cancelled\n", pPort->CurrentMaskIrp));
                         
                    IoReleaseCancelSpinLock(OldIrql);
                    pPort->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if(!SetFirstStatus) 
					{
                        SerialDump(SERDIAG4, ("%x was the first irp processed by this\n"
                             "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                            
                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;
                    }

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                        
                    SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                        "------- %x/%x <- values should be the same\n", pPort->CurrentMaskIrp, NewIrp));
                } 
				else 
				{

                    SerialDump(SERDIAG4, ("%x will become the current wait irp\n", pPort->CurrentMaskIrp));
                        
                    if(!SetFirstStatus) 
					{

                        SerialDump(SERDIAG4,("%x was the first irp processed by this\n"
                            "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                            
                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(pPort->CurrentMaskIrp);
                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!pPort->IrpMaskLocation);
                    ASSERT(!pPort->CurrentWaitIrp);

                    pPort->CurrentWaitIrp = pPort->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(pPort->CurrentWaitIrp);
                    IoSetCancelRoutine(pPort->CurrentWaitIrp, SerialCancelWait);
                        
                    //
                    // Since the cancel routine has a reference to#
                    // the irp we need to update the reference
                    // count.
                    //

                    SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_CANCEL);

                    KeSynchronizeExecution(pPort->Interrupt, SerialGiveWaitToIsr, pPort);
                        

                    //
                    // Since it isn't really the mask irp anymore,
                    // null out that pointer.
                    //

                    pPort->CurrentMaskIrp = NULL;

                    IoReleaseCancelSpinLock(OldIrql);

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, FALSE);
                       
                    SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                        "------- %x/%x <- values should be the same\n", pPort->CurrentMaskIrp, NewIrp));
                       
                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}


BOOLEAN
SerialGrabWaitFromIsr(IN PVOID Context)
/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3,("In SerialGrabWaitFromIsr\n"));
        
        
        

    if(pPort->IrpMaskLocation) 
	{
        SerialDump(SERDIAG4,("The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp, pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer));
            

        // The isr still "owns" the irp.

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_CLEAR_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_ISR);
            
    }

    return FALSE;
}


BOOLEAN
SerialGiveWaitToIsr(IN PVOID Context)
/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3,("In SerialGiveWaitToIsr\n"));
        
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!pPort->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_ISR);
        
        
       

    if(!pPort->HistoryMask) 
	{
        SerialDump(SERDIAG4, ("No events occured prior to the wait call\n"));
            
        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        pPort->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        pPort->IrpMaskLocation = pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
        

        SerialDump(SERDIAG4,("The isr owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp, pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer));
    } 
	else 
	{

        SerialDump(SERDIAG4, ("%x occurred prior to the wait - starting the\n"
             "------- completion code for %x\n",
             pPort->HistoryMask, pPort->CurrentWaitIrp));
            
        *((ULONG *)pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer) = pPort->HistoryMask;
           
        pPort->HistoryMask = 0;
        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        pPort->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

 		// Mark IRP as about to complete normally to prevent cancel & timer DPCs
		// from doing so before DPC is allowed to run.
		//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
       
		KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
            
    }

    return FALSE;
}


BOOLEAN
SerialFinishOldWait(IN PVOID Context)
/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3,("In SerialFinishOldWait\n"));
        
        
       
    if(pPort->IrpMaskLocation) 
	{

        SerialDump(SERDIAG4, ("The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp, pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer));
   
		//
        // The isr still "owns" the irp.
        //
        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

		// Mark IRP as about to complete normally to prevent cancel & timer DPCs
		// from doing so before DPC is allowed to run.
		//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);

        KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
            
    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    pPort->HistoryMask &= *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);
                                            
    pPort->IsrWaitMask = *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);

	// Setup UART for special character detection
	if(pPort->IsrWaitMask & SERIAL_EV_RXFLAG)
	{
		pPort->UartConfig.SpecialMode |= UC_SM_DETECT_SPECIAL_CHAR;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);
	}
	else
	{
		pPort->UartConfig.SpecialMode &= ~UC_SM_DETECT_SPECIAL_CHAR;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);
	}

    SerialDump(SERDIAG4, ("Set mask location of %x, in irp %x, with system buffer of %x\n",
         pPort->IrpMaskLocation,
         pPort->CurrentMaskIrp, pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer));
        
        
    return FALSE;
}


VOID
SerialCancelWait(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERDIAG3, ("In SerialCancelWait\n"));
        
    SerialDump(SERDIAG4, ("Canceling wait for irp %x\n", pPort->CurrentWaitIrp));
        
    SerialTryToCompleteCurrent(	pPort,
								SerialGrabWaitFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentWaitIrp,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL,
								SERIAL_REF_CANCEL);
        

}


VOID
SerialCompleteWait(IN PKDPC Dpc,
				   IN PVOID DeferredContext,
				   IN PVOID SystemContext1,
				   IN PVOID SystemContext2)
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    SerialDump(SERDIAG3, ("In SerialCompleteWait\n"));
       
        
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialDump(SERDIAG4, ("Completing wait for irp %x\n", pPort->CurrentWaitIrp));
   
	// Clear the normal complete reference.
	//SERIAL_CLEAR_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort,
								NULL,
								OldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentWaitIrp,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL,
								SERIAL_REF_ISR);
								

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\inc\spd_proto.h ===
//////////////////////////////////////////////////////////////////
// Prototypes and macros that are used throughout the driver. 
//////////////////////////////////////////////////////////////////
#if !defined(SPD_PROTO_H)
#define SPD_PROTO_H


VOID DriverUnload(IN PDRIVER_OBJECT pDriverObject);
NTSTATUS GetPortSettings(PDEVICE_OBJECT pDevObject);
BOOLEAN SetPortFiFoSettings(PPORT_DEVICE_EXTENSION pPort);
NTSTATUS GetCardSettings(PDEVICE_OBJECT pDevObject);


#ifdef WMI_SUPPORT
NTSTATUS SpeedCard_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);
NTSTATUS SpeedPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);
#endif

BOOLEAN SerialResetAndVerifyUart(PDEVICE_OBJECT pDevObj);
BOOLEAN SetCardToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard);
BOOLEAN SetCardNotToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard);
BOOLEAN SetCardNotToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard);
BOOLEAN SetCardToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard);

#endif	// End of SPD_PROTO.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\inc\spd_defs.h ===
#if !defined(SPD_DEFS_H)
#define SPD_DEFS_H


// File IDs for Event Logging (top 8 bits only).
#define SPD_PNP_C		((ULONG)0x010000)
#define SPD_W2K_C		((ULONG)0x020000)

#define PRODUCT_MAX_PORTS		20

// Port Types.
#define SPD_8PIN_RJ45			1	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR 
#define SPD_10PIN_RJ45			2	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR, RI
#define FAST_8PIN_RJ45			3	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR 
#define FAST_8PIN_XXXX			4	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR 
#define FAST_6PIN_XXXX			5	// FG, SG, TXD, RXD, RTS, CTS
#define MODEM_PORT				6	// Modem Port

// Port device object name.
#define PORT_PDO_NAME_BASE		L"\\Device\\SPEEDPort"

// Tag used for memory allocations (must be 4 bytes in reverse).
#define MEMORY_TAG				'DEPS'


#define OXPCI_IO_OFFSET			    0x0008 // I/O address offset between UARTs
#define OXPCI_INTERNAL_MEM_OFFSET	0x0020 // Memory address offset between internal UARTs
#define OXPCI_LOCAL_MEM_OFFSET		0x0400 // Memory address offset between local bus UARTs

#define SPEED_GIS_REG				0x1C	// Gloabl Interrupt Status Reg (GIS)
#define INTERNAL_UART_INT_PENDING	(ULONG)0x0000000F	// Interanl UART 0, 1, 2 or 3 has an Interrupt Pending
#define UART0_INT_PENDING			(ULONG)0x00000001	// Interanl UART 0 Interrupt Pending
#define UART1_INT_PENDING			(ULONG)0x00000002	// Interanl UART 1 Interrupt Pending
#define UART2_INT_PENDING			(ULONG)0x00000004	// Interanl UART 2 Interrupt Pending
#define UART3_INT_PENDING			(ULONG)0x00000008	// Interanl UART 3 Interrupt Pending

#define FAST_UARTS_0_TO_7_INTS_REG		0x07	// Fast UARTs 0 to 7 Interrupt Status Reg 

#define FAST_UARTS_0_TO_3_INT_PENDING	0x0F	// Fast UART 0, 1, 2 or 3 has an Interrupt Pending
#define FAST_UART0_INT_PENDING			0x01	// Fast UART 0 Interrupt Pending
#define FAST_UART1_INT_PENDING			0x02	// Fast UART 1 Interrupt Pending
#define FAST_UART2_INT_PENDING			0x04	// Fast UART 2 Interrupt Pending
#define FAST_UART3_INT_PENDING			0x08	// Fast UART 3 Interrupt Pending
#define FAST_UART4_INT_PENDING			0x10	// Fast UART 4 Interrupt Pending
#define FAST_UART5_INT_PENDING			0x20	// Fast UART 5 Interrupt Pending
#define FAST_UART6_INT_PENDING			0x40	// Fast UART 6 Interrupt Pending
#define FAST_UART7_INT_PENDING			0x80	// Fast UART 7 Interrupt Pending


#define FAST_UARTS_9_TO_16_INTS_REG		0x0F	// Fast UARTs 8 to 15 Interrupt Status Reg 
#define FAST_UART8_INT_PENDING			0x01	// Fast UART 8 Interrupt Pending
#define FAST_UART9_INT_PENDING			0x02	// Fast UART 9 Interrupt Pending
#define FAST_UART10_INT_PENDING			0x04	// Fast UART 10 Interrupt Pending
#define FAST_UART11_INT_PENDING			0x08	// Fast UART 11 Interrupt Pending
#define FAST_UART12_INT_PENDING			0x10	// Fast UART 12 Interrupt Pending
#define FAST_UART13_INT_PENDING			0x20	// Fast UART 13 Interrupt Pending
#define FAST_UART14_INT_PENDING			0x40	// Fast UART 14 Interrupt Pending
#define FAST_UART15_INT_PENDING			0x80	// Fast UART 15 Interrupt Pending


#define PLX9050_INT_CNTRL_REG_OFFSET	0x4C	// PLX 9050 Interrupt Control Reg Offset in PCI Config Regs.
#define PLX9050_CNTRL_REG_OFFSET		0x50	// PLX 9050 Control Reg Offset in PCI Config Regs.



// Clock frequencies
#define CLOCK_FREQ_1M8432Hz			1843200
#define CLOCK_FREQ_7M3728Hz			7372800
#define CLOCK_FREQ_14M7456Hz		14745600



// SPEED HardwareIDs
// -------------------

// Speed 2 and 4 local bus device (UNUSED)
#define SPD2AND4_PCI_NO_F1_HWID			L"PCI\\VEN_1415&DEV_9510&SUBSYS_000011CB"	// (F1: Unusable).

// SPEED4 Standard Performance PCI Card.
#define SPD4_PCI_PCI954_HWID			L"PCI\\VEN_1415&DEV_9501&SUBSYS_A00411CB"	// (F0: Quad 950 UART).

// SPEED4+ High Performance PCI Card.
#define SPD4P_PCI_PCI954_HWID			L"PCI\\VEN_11CB&DEV_9501&SUBSYS_A00411CB"	// (F0: Quad 950 UART).
#define SPD4P_PCI_8BIT_LOCALBUS_HWID	L"PCI\\VEN_11CB&DEV_9511&SUBSYS_A00011CB"	// (F1: 8 bit local bus).

// SPEED2 Standard Performance PCI Card.
#define SPD2_PCI_PCI954_HWID			L"PCI\\VEN_1415&DEV_9501&SUBSYS_A00211CB"	// (F0: 2 950 UARTs).

// SPEED2+ High Performance PCI Card.
#define SPD2P_PCI_PCI954_HWID			L"PCI\\VEN_11CB&DEV_9501&SUBSYS_A00211CB"	// (F0: 2 950 UARTs).
#define SPD2P_PCI_8BIT_LOCALBUS_HWID	L"PCI\\VEN_11CB&DEV_9511&SUBSYS_A00111CB"	// (F1: 8 bit local bus).


// Chase cards
#define FAST4_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_003112E0"	// PCI-Fast 4 Port Adapter
#define FAST8_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_002112E0"	// PCI-Fast 8 Port Adapter
#define FAST16_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_001112E0"	// PCI-Fast 16 Port Adapter
#define FAST16FMC_PCI_HWID				L"PCI\\VEN_10B5&DEV_9050&SUBSYS_004112E0"	// PCI-Fast 16 FMC Adapter
#define AT_FAST4_HWID					L"AT_FAST4"									// AT-Fast	4 Port Adapter
#define AT_FAST8_HWID					L"AT_FAST8"									// AT-Fast	8 Port Adapter
#define AT_FAST16_HWID					L"AT_FAST16"								// AT-Fast	16 Port Adapter

#define RAS4_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_F001124D"	// PCI-RAS 4 Multi-modem Adapter
#define RAS8_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_F010124D"	// PCI-RAS 8 Multi-modem Adapter


// SPEED CardTypes
#define Speed4_Pci				1		// Speed 4 adapter
#define Speed2and4_Pci_8BitBus	2		// Speed 2 and 4 unused local bus.
#define Speed4P_Pci				3		// Speed 4+ adapter
#define Speed4P_Pci_8BitBus		4		// Speed 4+ adapter local bus

// Chase Cards
#define Fast4_Pci				5
#define Fast8_Pci				6
#define Fast16_Pci				7
#define Fast16FMC_Pci			8
#define Fast4_Isa				9
#define Fast8_Isa				10
#define Fast16_Isa				11
#define RAS4_Pci				12
#define RAS8_Pci				13

#define Speed2_Pci				14		// Speed 2 adapter
#define Speed2P_Pci				15		// Speed 2+ adapter
#define Speed2P_Pci_8BitBus		16		// Speed 2+ adapter local bus


/*****************************************************************************
*********************************** NT 4.0 PCI IDs ***************************
*****************************************************************************/
// General definitions... 

#define	OX_SEMI_VENDOR_ID		0x1415				// Oxford's VendorID  Assigned by the PCI SIG 
#define	SPX_VENDOR_ID			0x11CB				// Specialix's VendorID Assigned by the PCI SIG 

#define	OX_SEMI_SUB_VENDOR_ID	OX_SEMI_VENDOR_ID	// Same as Oxford's VendorID 
#define	SPX_SUB_VENDOR_ID		SPX_VENDOR_ID		// Same as Specialix's VendorID 

// SPEED4 Low Performance Card.
// ---------------------------------------------------
// PCI Function 0 - (Quad 16C950 UARTs).
// --------------
// VendorID				= OX_SEMI_VENDOR_ID
// DeviceID				= OX_SEMI_PCI954_DEVICE_ID
// SubSystem DeviceID	= SPD4_PCI954_SUB_SYS_ID
// SubSystem VendorID	= SPX_SUB_VENDOR_ID
//
// PCI Function 1 - (Unusable).
// --------------
// VendorID				= OX_SEMI_VENDOR_ID
// DeviceID				= OX_SEMI_NO_F1_DEVICE_ID
// SubSystem DeviceID	= Unknown ??? could be 0x0000 which is bad for MS HCTs
// SubSystem VendorID	= OX_SEMI_SUB_VENDOR_ID
//
#define OX_SEMI_PCI954_DEVICE_ID			0x9501		// OX SEMI PCI954 Bridge and integrated Quad UARTs 
#define	SPD4_PCI954_SUB_SYS_ID				0xA004		// SPX SubSystem DeviceID

#define	SPD2_PCI954_SUB_SYS_ID				0xA002		// SPX SubSystem DeviceID


// SPEED4+ High Performance Card.
// ---------------------------------------------------
// PCI Function 0 - (Quad 16C950 UARTs).
// --------------
// VendorID				= SPX_VENDOR_ID
// DeviceID				= SPD4P_PCI954_DEVICE_ID
// SubSystem DeviceID	= SPD4P_PCI954_SUB_SYS_ID
// SubSystem VendorID	= SPX_SUB_VENDOR_ID
//
// PCI Function 1 - (8 Bit Local Bus with possibly more UARTs).
// -------------- 
// VendorID				= SPX_VENDOR_ID
// DeviceID				= SPD4P_PCI954_8BIT_BUS_DEVICE_ID
// SubSystem DeviceID	= SPD4P_PCI954_8BIT_BUS_SUB_SYS_ID
// SubSystem VendorID	= SPX_SUB_VENDOR_ID
//
#define	SPD4P_PCI954_DEVICE_ID				0x9501		// SPX PCI954 Bridge and integrated Quad UARTs
#define	SPD4P_PCI954_SUB_SYS_ID				0xA004		// SPX PCI954 Bridge and integrated Quad UARTs

#define	SPD4P_8BIT_BUS_DEVICE_ID			0x9511		// 8 Bit Local Bus 
#define	SPD4P_8BIT_BUS_SUB_SYS_ID			0xA000		// 8 Bit Local Bus 


#define	SPD2P_PCI954_DEVICE_ID				0x9501		// SPX PCI954 Bridge and integrated Quad UARTs
#define	SPD2P_PCI954_SUB_SYS_ID				0xA002		// SPX PCI954 Bridge and integrated Quad UARTs

#define	SPD2P_8BIT_BUS_DEVICE_ID			0x9511		// 8 Bit Local Bus 
#define	SPD2P_8BIT_BUS_SUB_SYS_ID			0xA001		// 8 Bit Local Bus 





#define	PLX_VENDOR_ID					0x10B5			// PLX board vendor ID
#define	PLX_DEVICE_ID					0x9050			// PLX board device ID 
	
#define CHASE_SUB_VENDOR_ID				0x12E0			// Chase Research SubVendorID
#define	FAST4_SUB_SYS_ID				0x0031			// PCI-Fast 4 SubSystem DeviceID
#define	FAST8_SUB_SYS_ID				0x0021			// PCI-Fast 8 SubSystem DeviceID
#define	FAST16_SUB_SYS_ID				0x0011			// PCI-Fast 16 SubSystem DeviceID
#define	FAST16FMC_SUB_SYS_ID			0x0041			// PCI-Fast 16 FMC SubSystem DeviceID


#define MORETONBAY_SUB_VENDOR_ID		0x124D			// Moreton Bay SubVendorID
#define	RAS4_SUB_SYS_ID					0xF001			// PCI-Fast 4 SubSystem DeviceID
#define	RAS8_SUB_SYS_ID					0xF010			// PCI-Fast 4 SubSystem DeviceID



// Port Property reg keys.
#define TX_FIFO_LIMIT		L"TxFiFoLimit"
#define TX_FIFO_TRIG_LEVEL	L"TxFiFoTrigger"
#define RX_FIFO_TRIG_LEVEL	L"RxFiFoTrigger"
#define LO_FLOW_CTRL_LEVEL	L"LoFlowCtrlThreshold" 
#define HI_FLOW_CTRL_LEVEL	L"HiFlowCtrlThreshold"





// Card Properties
#define DELAY_INTERRUPT			L"DelayInterrupt"	// Can be used to delay the interrupt by 1.1ms on PCI-Fast16 and PCI-Fast16 FMC cards.
#define SWAP_RTS_FOR_DTR		L"SwapRTSForDTR"	// Can be used to Swap RTS for DTR on the PCI-Fast16 cards.
#define CLOCK_FREQ_OVERRIDE		L"ClockFreqOverride"	// Can be used to set override the card's default clock frequency. 

// Card Options
#define DELAY_INTERRUPT_OPTION		0x00000001		// Settable on PCI-Fast 16 & PCI-Fast 16 FMC (Interrupt delayed 1.1 ms)
#define SWAP_RTS_FOR_DTR_OPTION		0x00000002		// Settable on PCI-Fast 16




#endif	// End of SPD_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\spx\speed\driver\inc\serialp.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 Microsoft Corporation

Module Name :
	
    serialp.h

Abstract:

    Prototypes and macros that are used throughout the driver.

Author:

    Anthony V. Ercolano                 September 26, 1991

Revision History:
--*/
#if !defined(SERIALP_H)
#define SERIALP_H	

typedef NTSTATUS(*PSERIAL_START_ROUTINE) (IN PPORT_DEVICE_EXTENSION);

typedef VOID(*PSERIAL_GET_NEXT_ROUTINE)(IN PPORT_DEVICE_EXTENSION pPort,
										IN PIRP *CurrentOpIrp,
										IN PLIST_ENTRY QueueToProcess,
										OUT PIRP *NewIrp,
										IN BOOLEAN CompleteCurrent);

NTSTATUS SerialRead(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialStartRead(IN PPORT_DEVICE_EXTENSION pPort);

VOID SerialCompleteRead(IN PKDPC Dpc, 
						IN PVOID DeferredContext, 
						IN PVOID SystemContext1, 
						IN PVOID SystemContext2);

VOID SerialReadTimeout(IN PKDPC Dpc,
					   IN PVOID DeferredContext,
					   IN PVOID SystemContext1,
					   IN PVOID SystemContext2);

VOID SerialIntervalReadTimeout(IN PKDPC Dpc,
							   IN PVOID DeferredContext,
							   IN PVOID SystemContext1,
							   IN PVOID SystemContext2);

NTSTATUS SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialStartWrite(IN PPORT_DEVICE_EXTENSION pPort);

VOID SerialGetNextWrite(IN PPORT_DEVICE_EXTENSION pPort,
						IN PIRP *CurrentOpIrp,
						IN PLIST_ENTRY QueueToProcess,
						IN PIRP *NewIrp,
						IN BOOLEAN CompleteCurrent);

VOID SerialCompleteWrite(IN PKDPC Dpc,
						 IN PVOID DeferredContext,
						 IN PVOID SystemContext1,
						 IN PVOID SystemContext2);

BOOLEAN SerialProcessEmptyTransmit(IN PVOID Context);

VOID SerialWriteTimeout(IN PKDPC Dpc, 
						IN PVOID DeferredContext,
						IN PVOID SystemContext1,
						IN PVOID SystemContext2);

VOID SerialCommError(IN PKDPC Dpc,
					 IN PVOID DeferredContext,
					 IN PVOID SystemContext1,
					 IN PVOID SystemContext2);

NTSTATUS SerialCleanup(IN PDEVICE_OBJEC