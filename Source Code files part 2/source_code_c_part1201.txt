        return FALSE;
        }
    }

    return TRUE;
}


void ScanRegistry(IN PCARD_EXTENSION pCard, PUCHAR param)
{
    gRegisterForShutdown =      GetDriverParameter(  "RegisterForShutdown", gRegisterForShutdown, 0, 2, param) ;
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: RegisterForShutdown=%x\n",gRegisterForShutdown));

    gRegSetting.PaPathIdWidth = GetDriverParameter(  "PaPathIdWidth", DEFAULT_PaPathIdWidth,0,8,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.PaPathIdWidth=%x\n",gRegSetting.PaPathIdWidth));

    gRegSetting.VoPathIdWidth = GetDriverParameter(  "VoPathIdWidth",DEFAULT_VoPathIdWidth,0,8,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.VoPathIdWidth=%x\n",gRegSetting.VoPathIdWidth));
    
    gRegSetting.LuPathIdWidth = GetDriverParameter(  "LuPathIdWidth",DEFAULT_LuPathIdWidth,0,8,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.LuPathIdWidth=%x\n",gRegSetting.LuPathIdWidth));
    
    gRegSetting.MaximumTids =   GetDriverParameter(  "MaximumTids",gRegSetting.MaximumTids,8,gMaximumTargetIDs,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.MaximumTids=%x\n",gRegSetting.MaximumTids));
    
    gRegSetting.LuTargetWidth = GetDriverParameter(  "LuTargetWidth",DEFAULT_LuTargetWidth,8,32,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.LuTargetWidth=%x\n",gRegSetting.LuTargetWidth));
    
    gGlobalIOTimeout =          GetDriverParameter(  "GlobalIOTimeout",gGlobalIOTimeout,0,20, param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gGlobalIOTimeout=%x\n",gGlobalIOTimeout));
    
    gEnablePseudoDevice =       GetDriverParameter(  "EnablePseudoDevice",gEnablePseudoDevice,0,1,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gEnablePseudoDevice=%x\n",gEnablePseudoDevice));
    
    gMaximumTransferLength =    GetDriverParameter(  "MaximumTransferLength",gMaximumTransferLength,0,-1,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gMaximumTransferLength=%x\n",gMaximumTransferLength));
    
    gCrashDumping = ( GetDriverParameter("dump", 0, 0, 1, param) || 
                        GetDriverParameter("ntldr", 0, 0, 1, param) );  
    
    pCard->ForceTag = GetDriverParameter("ForceTag",pCard->ForceTag,0,1, param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: pCard->ForceTag=%x\n",pCard->ForceTag));

    #ifdef DBGPRINT_IO
    gDbgPrintIo =    GetDriverParameter(  "DbgPrintIo",gDbgPrintIo,0,-1,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gDbgPrintIo=%x\n",gDbgPrintIo));
    #endif

	gMultiMode = GetDriverParameter("MultiMode", gMultiMode, 0,1, param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gMultiMode=%x\n",gMultiMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\flashsvc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FlashSvc.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/24/00 6:54p  $ (Last Modified)

Purpose:

  This file implements Flash Services for the FC Layer.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/flashsvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "flashsvc.h"
#endif  /* _New_Header_file_Layout_ */

os_bit32 fiFlashSvcASSERTs(
                         void
                       )
{
    os_bit32 to_return = 0;

    if ( sizeof(fiFlashBit16ToBit8s_t)          !=                       sizeof(os_bit16) ) to_return++;
    if ( sizeof(fiFlashBit32ToBit8s_t)          !=                       sizeof(os_bit32) ) to_return++;

    if ( sizeof(fiFlashSector_Bit8_Form_t)      !=                Am29F010_Sector_SIZE ) to_return++;
    if ( sizeof(fiFlashSector_Bit16_Form_t)     !=                Am29F010_Sector_SIZE ) to_return++;
    if ( sizeof(fiFlashSector_Bit32_Form_t)     !=                Am29F010_Sector_SIZE ) to_return++;
    if ( sizeof(fiFlashSector_Last_Form_t)      !=                Am29F010_Sector_SIZE ) to_return++;

#ifndef __FlashSvc_H__64KB_Struct_Size_Limited__
    if ( sizeof(fiFlashStructure_t)             !=                       Am29F010_SIZE ) to_return++;
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    return to_return;
}

agBOOLEAN fiFlashSvcInitialize(
                           agRoot_t  *hpRoot
                         )
{
    CThread_t          *CThread  = CThread_ptr(hpRoot);
    os_bit8             Sentinel;
    fiFlash_Card_WWN_t  WWN;

    /* Dump fiFlashStructure.Sector[fiFlashSector_Last] whether Present or Absent */

    if(    CThread->Calculation.Input.cardRomUpper32  == 0 &&
         ( CThread->Calculation.Input.cardRomLower32  == 0     ||
           CThread->Calculation.Input.cardRomLen      == 0        ))
    {
        CThread->flashPresent = agFALSE;
        fiFlashGet_Card_WWN( hpRoot, &WWN );

    }
    else
    {
        fiFlashDumpLastSector(
                               hpRoot
                             );

        /* Establish whether Flash is Present or Absent */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
        Sentinel = fiFlashReadBit8(
                                    hpRoot,
                                    hpFieldOffset(
                                                   fiFlashSector_Last_Form_t,
                                                   Sentinel
                                                 ) + (fiFlashSector_Last * sizeof(fiFlashSector_t))
                                  );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
        Sentinel = fiFlashReadBit8(
                                    hpRoot,
                                    hpFieldOffset(
                                                   fiFlashStructure_t,
                                                   Sector[fiFlashSector_Last].Last_Form.Sentinel
                                                 )
                                  );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

        if (Sentinel == fiFlash_Sector_Sentinel_Byte)
        {
            /* Read Card's WWN from Flash */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
            fiFlashReadBlock(
                              hpRoot,
                              hpFieldOffset(
                                             fiFlashSector_Last_Form_t,
                                             Card_WWN
                                           ) + (fiFlashSector_Last * sizeof(fiFlashSector_t)),
                              WWN,
                              sizeof(fiFlash_Card_WWN_t)
                            );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
            fiFlashReadBlock(
                              hpRoot,
                              hpFieldOffset(
                                             fiFlashStructure_t,
                                             Sector[fiFlashSector_Last].Last_Form.Card_WWN
                                           ),
                              WWN,
                              sizeof(fiFlash_Card_WWN_t)
                            );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

            /* Validate acceptable WWN found in Flash */

            if (   (WWN[0] != fiFlash_Card_WWN_0)
                || (WWN[1] != fiFlash_Card_WWN_1)
                || (WWN[2] != fiFlash_Card_WWN_2))
                {
                    fiLogDebugString(
                                      hpRoot,
                                      FlashSvcLogConsoleLevel,
                                      "fiFlashSvcInitialize(): Found invalid WWN in Flash!",
                                     (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                      0,0,0,0,0,0,0,0);

                    fiLogDebugString(
                                      hpRoot,
                                      FlashSvcLogConsoleLevel,
                                      "    WWN expected = %02X%02X%02X%s %s",
                                      "VV",
                                      "WWXXYYZZ",
                                      (void *)agNULL,(void *)agNULL,
                                      fiFlash_Card_WWN_0,
                                      fiFlash_Card_WWN_1,
                                      fiFlash_Card_WWN_2,
                                      0,0,0,0,0);

                    fiLogDebugString(
                                      hpRoot,
                                      FlashSvcLogConsoleLevel,
                                      "    WWN in Flash = %02X%02X%02X%02X %02X%02X%02X%02X",
                                     (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                      WWN[0],
                                      WWN[1],
                                      WWN[2],
                                      WWN[3],
                                      WWN[4],
                                      WWN[5],
                                      WWN[6],
                                      WWN[7]
                                    );
                }

            /* Indicate Flash is Present */

            CThread->flashPresent = agTRUE;
        }
        else /* Sentinel != fiFlash_Sector_Sentinel_Byte  (1st test) */
        {
            /* Return true to fail this card following code will write flash rom ! */
            return(agTRUE);

            fiFlashInitializeChip(
                                   hpRoot
                                 );

            /* Check to make sure initialization succeeded */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
            Sentinel = fiFlashReadBit8(
                                        hpRoot,
                                        hpFieldOffset(
                                                       fiFlashSector_Last_Form_t,
                                                       Sentinel
                                                     ) + (fiFlashSector_Last * sizeof(fiFlashSector_t))
                                      );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
            Sentinel = fiFlashReadBit8(
                                        hpRoot,
                                        hpFieldOffset(
                                                       fiFlashStructure_t,
                                                       Sector[fiFlashSector_Last].Last_Form.Sentinel
                                                     )
                                      );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

            if (Sentinel == fiFlash_Sector_Sentinel_Byte)
            {
                /* Indicate Flash is Present */

                CThread->flashPresent = agTRUE;
            }
            else /* Sentinel != fiFlash_Sector_Sentinel_Byte (2nd test) */
            {
                /* Indicate Flash is Absent */

                CThread->flashPresent = agFALSE;
            }
        }

    }
    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashSvcInitialize(): CThread->flashPresent set to %1x",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      (os_bit32)CThread->flashPresent,
                     0,0,0,0,0,0,0);

    /* Fill in NodeWWN and PortWWN in ChanInfo */

    CThread->ChanInfo.NodeWWN[0]= WWN[0];
    CThread->ChanInfo.NodeWWN[1]= WWN[1];
    CThread->ChanInfo.NodeWWN[2]= WWN[2];
    CThread->ChanInfo.NodeWWN[3]= WWN[3];
    CThread->ChanInfo.NodeWWN[4]= WWN[4];
    CThread->ChanInfo.NodeWWN[5]= WWN[5];
    CThread->ChanInfo.NodeWWN[6]= WWN[6];
    CThread->ChanInfo.NodeWWN[7]= (os_bit8)(WWN[7] ^ 0x01); /* Flip low bit to construct NodeWWN from PortWWN */

    CThread->ChanInfo.PortWWN[0]= WWN[0];
    CThread->ChanInfo.PortWWN[1]= WWN[1];
    CThread->ChanInfo.PortWWN[2]= WWN[2];
    CThread->ChanInfo.PortWWN[3]= WWN[3];
    CThread->ChanInfo.PortWWN[4]= WWN[4];
    CThread->ChanInfo.PortWWN[5]= WWN[5];
    CThread->ChanInfo.PortWWN[6]= WWN[6];
    CThread->ChanInfo.PortWWN[7]= WWN[7];
    return(agFALSE);

}

void fiFlashDumpLastSector(
                            agRoot_t *hpRoot
                          )
{
    CThread_t                 *CThread               = CThread_ptr(hpRoot);
    agBOOLEAN                    flashPresent_at_entry = CThread->flashPresent;
    fiFlashSector_Last_Form_t *Last_Sector           = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    /* Make sure FLASH appears to be present upon entry */

    CThread->flashPresent = agTRUE;

    /* Fetch Last_Sector from FLASH */

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    /* Now return entry value of CThread->flashPresent */

    CThread->flashPresent = flashPresent_at_entry;

    /* Finally, dump "interesting" contents of Last_Sector */

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Assembly_Info = %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[ 0],
                      Last_Sector->Assembly_Info[ 1],
                      Last_Sector->Assembly_Info[ 2],
                      Last_Sector->Assembly_Info[ 3],
                      Last_Sector->Assembly_Info[ 4],
                      Last_Sector->Assembly_Info[ 5],
                      Last_Sector->Assembly_Info[ 6],
                      Last_Sector->Assembly_Info[ 7]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector():                 %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[ 8],
                      Last_Sector->Assembly_Info[ 9],
                      Last_Sector->Assembly_Info[10],
                      Last_Sector->Assembly_Info[11],
                      Last_Sector->Assembly_Info[12],
                      Last_Sector->Assembly_Info[13],
                      Last_Sector->Assembly_Info[14],
                      Last_Sector->Assembly_Info[15]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector():                 %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[16],
                      Last_Sector->Assembly_Info[17],
                      Last_Sector->Assembly_Info[18],
                      Last_Sector->Assembly_Info[19],
                      Last_Sector->Assembly_Info[20],
                      Last_Sector->Assembly_Info[21],
                      Last_Sector->Assembly_Info[22],
                      Last_Sector->Assembly_Info[23]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector():                 %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[24],
                      Last_Sector->Assembly_Info[25],
                      Last_Sector->Assembly_Info[26],
                      Last_Sector->Assembly_Info[27],
                      Last_Sector->Assembly_Info[28],
                      Last_Sector->Assembly_Info[29],
                      Last_Sector->Assembly_Info[30],
                      Last_Sector->Assembly_Info[31]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Hard_Address  = %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Hard_Domain_Address,
                      Last_Sector->Hard_Area_Address,
                      Last_Sector->Hard_Loop_Address,
                      0,0,0,0,0
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Sentinel      = %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Sentinel,
                      0,0,0,0,0,0,0
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Card_WWN      = %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Card_WWN[0],
                      Last_Sector->Card_WWN[1],
                      Last_Sector->Card_WWN[2],
                      Last_Sector->Card_WWN[3],
                      Last_Sector->Card_WWN[4],
                      Last_Sector->Card_WWN[5],
                      Last_Sector->Card_WWN[6],
                      Last_Sector->Card_WWN[7]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Card_SVID     = %08X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Card_SVID,
                      0,0,0,0,0,0,0
                    );
}

void fiFlashInitializeChip(
                            agRoot_t *hpRoot
                          )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    /* Make sure FLASH appears to NOT be present upon entry */

    CThread->flashPresent = agFALSE;

    /* Fetch Last_Sector Template w/ Defaults filled in */

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    /* Now indicate that FLASH is present so that fiFlashUpdate_Last_Sector() will function */

    CThread->flashPresent = agTRUE;

    /* Update Last_Sector (w/out setting Sentinel byte) */

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );

    /* Finally, now that Last_Sector is successfully written, set the Sentinel byte */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    fiFlashWriteBit8(
                      hpRoot,
                      hpFieldOffset(
                                     fiFlashSector_Last_Form_t,
                                     Sentinel
                                   ) + (fiFlashSector_Last * sizeof(fiFlashSector_t)),
                      fiFlash_Sector_Sentinel_Byte
                    );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    fiFlashWriteBit8(
                      hpRoot,
                      hpFieldOffset(
                                     fiFlashStructure_t,
                                     Sector[fiFlashSector_Last].Last_Form.Sentinel
                                   ),
                      fiFlash_Sector_Sentinel_Byte
                    );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
}

void fiFlashFill_Assembly_Info( fiFlashSector_Last_Form_t    *Last_Sector,
                                fiFlash_Card_Assembly_Info_t *Assembly_Info
                              )
{
    os_bit32 i;

    for (i = 0;
         i < sizeof(fiFlash_Card_Assembly_Info_t);
         i++)
    {
        Last_Sector->Assembly_Info[i] = (*Assembly_Info)[i];
    }
}

void fiFlashFill_Hard_Address( fiFlashSector_Last_Form_t *Last_Sector,
                               os_bit8                       Hard_Domain_Address,
                               os_bit8                       Hard_Area_Address,
                               os_bit8                       Hard_Loop_Address
                             )
{
    Last_Sector->Hard_Domain_Address = Hard_Domain_Address;
    Last_Sector->Hard_Area_Address   = Hard_Area_Address;
    Last_Sector->Hard_Loop_Address   = Hard_Loop_Address;
}

void fiFlashFill_Card_WWN( fiFlashSector_Last_Form_t *Last_Sector,
                           fiFlash_Card_WWN_t        *Card_WWN
                         )
{
    os_bit32 i;

    for (i = 0;
         i < sizeof(fiFlash_Card_WWN_t);
         i++)
    {
        Last_Sector->Card_WWN[i] = (*Card_WWN)[i];
    }
}

void fiFlashFill_Card_SVID( fiFlashSector_Last_Form_t *Last_Sector,
                            fiFlash_Card_SVID_t        Card_SVID
                          )
{
    Last_Sector->Card_SVID = Card_SVID;
}

void fiFlashGet_Last_Sector(
                             agRoot_t                  *hpRoot,
                             fiFlashSector_Last_Form_t *Last_Sector
                           )
{
    CThread_t                 *CThread               = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32                      Last_Sector_Offset    = fiFlashSector_Last * sizeof(fiFlashSector_t);
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32                      Last_Sector_Offset    = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last]);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    fiFlashSector_Bit8_Form_t *Last_Sector_Bit8_Form;
    os_bit32      i;

    if (CThread->flashPresent == agTRUE)
    {
        fiFlashReadBlock(
                          hpRoot,
                          Last_Sector_Offset,
                          (void *)Last_Sector,
                          sizeof(fiFlashSector_Last_Form_t)
                        );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Initialize Last_Sector Template */

        Last_Sector_Bit8_Form = (fiFlashSector_Bit8_Form_t *)Last_Sector;

        for (i = 0;
             i < sizeof(fiFlashSector_Bit8_Form_t);
             i++)
        {
            Last_Sector_Bit8_Form->Bit8[i] = Am29F010_Erased_Bit8;
        }

        /* Fill in Last_Sector default/initial values (that can be computed) */

        fiFlashGet_Assembly_Info(
                                  hpRoot,
                                  &(Last_Sector->Assembly_Info)
                                );

        fiFlashGet_Hard_Address(
                                 hpRoot,
                                 &(Last_Sector->Hard_Domain_Address),
                                 &(Last_Sector->Hard_Area_Address),
                                 &(Last_Sector->Hard_Loop_Address)
                               );

        fiFlashGet_Card_WWN(
                             hpRoot,
                             &(Last_Sector->Card_WWN)
                           );

        fiFlashGet_Card_SVID(
                              hpRoot,
                              &(Last_Sector->Card_SVID)
                            );
    }
}

void fiFlashGet_Assembly_Info(
                               agRoot_t                     *hpRoot,
                               fiFlash_Card_Assembly_Info_t *Assembly_Info
                             )
{
    CThread_t *CThread              = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Assembly_Info_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Assembly_Info) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Assembly_Info_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Assembly_Info);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      i;

    if (CThread->flashPresent == agTRUE)
    {
        fiFlashReadBlock(
                          hpRoot,
                          Assembly_Info_Offset,
                          (void *)Assembly_Info,
                          sizeof(fiFlash_Card_Assembly_Info_t)
                        );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Initialize Last_Sector Template */

        for (i = 0;
             i < sizeof(fiFlash_Card_Assembly_Info_t);
             i++)
        {
            (*Assembly_Info)[i] = Am29F010_Erased_Bit8;
        }
    }
}

void fiFlashGet_Hard_Address(
                              agRoot_t *hpRoot,
                              os_bit8     *Hard_Domain_Address,
                              os_bit8     *Hard_Area_Address,
                              os_bit8     *Hard_Loop_Address
                            )
{
    CThread_t *CThread                    = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Hard_Domain_Address_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Hard_Domain_Address) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
    os_bit32      Hard_Area_Address_Offset   = hpFieldOffset(fiFlashSector_Last_Form_t,Hard_Area_Address) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
    os_bit32      Hard_Loop_Address_Offset   = hpFieldOffset(fiFlashSector_Last_Form_t,Hard_Loop_Address) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Hard_Domain_Address_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Hard_Domain_Address);
    os_bit32      Hard_Area_Address_Offset   = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Hard_Area_Address);
    os_bit32      Hard_Loop_Address_Offset   = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Hard_Loop_Address);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    if (CThread->flashPresent == agTRUE)
    {
        *Hard_Domain_Address = fiFlashReadBit8(
                                                hpRoot,
                                                Hard_Domain_Address_Offset
                                              );

        *Hard_Area_Address   = fiFlashReadBit8(
                                                hpRoot,
                                                Hard_Area_Address_Offset
                                              );

        *Hard_Loop_Address   = fiFlashReadBit8(
                                                hpRoot,
                                                Hard_Loop_Address_Offset
                                              );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Indicate no Hard Domain/Area/Loop Address */

        *Hard_Domain_Address = fiFlash_Card_Unassigned_Domain_Address;
        *Hard_Area_Address   = fiFlash_Card_Unassigned_Area_Address;
        *Hard_Loop_Address   = fiFlash_Card_Unassigned_Loop_Address;
    }
}

void fiFlashGet_Card_WWN(
                          agRoot_t           *hpRoot,
                          fiFlash_Card_WWN_t *Card_WWN
                        )
{
    CThread_t *CThread         = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Card_WWN_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Card_WWN) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Card_WWN_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Card_WWN);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    if (CThread->flashPresent == agTRUE)
    {
        fiFlashReadBlock(
                          hpRoot,
                          Card_WWN_Offset,
                          (void *)Card_WWN,
                          sizeof(fiFlash_Card_WWN_t)
                        );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Manufacture reasonable WWN */

        (*Card_WWN)[0] = fiFlash_Card_WWN_0_DEFAULT(hpRoot);
        (*Card_WWN)[1] = fiFlash_Card_WWN_1_DEFAULT(hpRoot);
        (*Card_WWN)[2] = fiFlash_Card_WWN_2_DEFAULT(hpRoot);
        (*Card_WWN)[3] = fiFlash_Card_WWN_3_DEFAULT(hpRoot);
        (*Card_WWN)[4] = fiFlash_Card_WWN_4_DEFAULT(hpRoot);
        (*Card_WWN)[5] = fiFlash_Card_WWN_5_DEFAULT(hpRoot);
        (*Card_WWN)[6] = fiFlash_Card_WWN_6_DEFAULT(hpRoot);
        (*Card_WWN)[7] = fiFlash_Card_WWN_7_DEFAULT(hpRoot);
    }
}

void fiFlashGet_Card_SVID(
                           agRoot_t            *hpRoot,
                           fiFlash_Card_SVID_t *Card_SVID
                         )
{
    CThread_t *CThread          = CThread_ptr(hpRoot);
    os_bit32      Chip_DEVID       = CThread->DEVID;
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Card_SVID_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Card_SVID) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Card_SVID_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Card_SVID);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    if (CThread->flashPresent == agTRUE)
    {
        *Card_SVID = fiFlashReadBit32(
                                       hpRoot,
                                       Card_SVID_Offset
                                     );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Determine appropriate SVID */

        if (Chip_DEVID == ChipConfig_DEVID_TachyonTL)
        {
            /* Card contains TachyonTL - assume it is an HHBA-5100A or an HHBA-5101A */

            *Card_SVID = ChipConfig_SubsystemID_HHBA5100A_or_HHBA5101A | ChipConfig_SubsystemVendorID_Hewlett_Packard;
        }
        else if (Chip_DEVID == ChipConfig_DEVID_TachyonTS)
        {
            /* Card contains TachyonTS - assume it is an HHBA-5121A */

            *Card_SVID = ChipConfig_SubsystemID_HHBA5121A | ChipConfig_SubsystemVendorID_Hewlett_Packard;
        }
        else /* Unknown CThread->DEVID */
        {
            *Card_SVID = 0;

            fiLogDebugString(
                              hpRoot,
                              FlashSvcLogConsoleLevel,
                              "fiFlashGet_Card_SVID(): Unknown DEVID (0x%04X) - no known HBA SVID applies !!!",
                             (char *)agNULL,(char *)agNULL,
                             (void *)agNULL,(void *)agNULL,
                              (Chip_DEVID >> 16),
                              0,0,0,0,0,0,0
                            );
        }
    }
}

void fiFlashSet_Assembly_Info(
                               agRoot_t                     *hpRoot,
                               fiFlash_Card_Assembly_Info_t *Assembly_Info
                             )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Assembly_Info( Last_Sector,
                               Assembly_Info
                             );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashSet_Hard_Address(
                              agRoot_t *hpRoot,
                              os_bit8      Hard_Domain_Address,
                              os_bit8      Hard_Area_Address,
                              os_bit8      Hard_Loop_Address
                            )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Hard_Address( Last_Sector,
                              Hard_Domain_Address,
                              Hard_Area_Address,
                              Hard_Loop_Address
                            );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashSet_Card_WWN(
                          agRoot_t           *hpRoot,
                          fiFlash_Card_WWN_t *Card_WWN
                        )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Card_WWN( Last_Sector,
                          Card_WWN
                        );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashSet_Card_SVID(
                           agRoot_t            *hpRoot,
                           fiFlash_Card_SVID_t  Card_SVID
                         )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Card_SVID( Last_Sector,
                           Card_SVID
                         );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashUpdate_Last_Sector(
                                agRoot_t                  *hpRoot,
                                fiFlashSector_Last_Form_t *Last_Sector
                              )
{
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32 Last_Sector_Offset = fiFlashSector_Last * sizeof(fiFlashSector_t);
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32 Last_Sector_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last]);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    fiFlashEraseSector(
                        hpRoot,
                        fiFlashSector_Last
                      );

    fiFlashWriteBlock(
                       hpRoot,
                       Last_Sector_Offset,
                       (void *)Last_Sector,
                       sizeof(fiFlashSector_Last_Form_t)
                     );
}

void fiFlashEraseChip(
                       agRoot_t *hpRoot
                     )
{
#ifdef OSLayer_Stub
    os_bit32 flashOffset  = 0;
    os_bit32 flashChipLen = Am29F010_Num_Sectors * Am29F010_Sector_SIZE;

    while (flashChipLen > 0)
    {
        fiFlashWriteBit8(
                          hpRoot,
                          flashOffset,
                          0xFF
                        );

        flashOffset  += sizeof(os_bit8);
        flashChipLen -= sizeof(os_bit8);
    }
#else /* OSLayer_Stub was not defined */
    os_bit8  Toggle_1;
    os_bit8  Toggle_2;

    /* Kick-off Embedded Program Sector Erase */

    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd1_OFFSET,
                        Am29F010_Chip_Erase_Cmd1_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd2_OFFSET,
                        Am29F010_Chip_Erase_Cmd2_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd3_OFFSET,
                        Am29F010_Chip_Erase_Cmd3_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd4_OFFSET,
                        Am29F010_Chip_Erase_Cmd4_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd5_OFFSET,
                        Am29F010_Chip_Erase_Cmd5_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd6_OFFSET,
                        Am29F010_Chip_Erase_Cmd6_DATA
                      );

    /* Use Toggle Bit Algorithm to know when Chip Erase is done */

    Toggle_1 = osCardRomReadBit8(
                                  hpRoot,
                                  Am29F010_Chip_Erase_Cmd6_OFFSET
                                );

    while(1)
    {
        Toggle_2 = osCardRomReadBit8(
                                      hpRoot,
                                      Am29F010_Chip_Erase_Cmd6_OFFSET
                                    );

        if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
        {
            /* Successfully Programmed */

            return;
        }

        if ((Toggle_2 & Am29F010_Exceeded_Timing_Limits_MASK) == Am29F010_Exceeded_Timing_Limits_MASK)
        {
            Toggle_1 = osCardRomReadBit8(
                                          hpRoot,
                                          Am29F010_Chip_Erase_Cmd6_OFFSET
                                        );
            Toggle_2 = osCardRomReadBit8(
                                          hpRoot,
                                          Am29F010_Chip_Erase_Cmd6_OFFSET
                                        );

            if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
            {
                /* Successfully Programmed */

                return;
            }

            /* Programming Failed - Reset Chip */

            osCardRomWriteBit8(
                                hpRoot,
                                Am29F010_Reset_Cmd1_OFFSET,
                                Am29F010_Reset_Cmd1_DATA
                              );

            return;
        }

        Toggle_1 = Toggle_2;
    }
#endif /* OSLayer_Stub was not defined */
}

void fiFlashEraseSector(
                         agRoot_t *hpRoot,
                         os_bit32     EraseSector
                       )
{
#ifdef OSLayer_Stub
    os_bit32 flashOffset    = Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Number(EraseSector);
    os_bit32 flashSectorLen = Am29F010_Sector_SIZE;

    while (flashSectorLen > 0)
    {
        fiFlashWriteBit8(
                          hpRoot,
                          flashOffset,
                          0xFF
                        );

        flashOffset    += sizeof(os_bit8);
        flashSectorLen -= sizeof(os_bit8);
    }
#else /* OSLayer_Stub was not defined */
    os_bit32 flashOffset = Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Number(EraseSector);
    os_bit8  Toggle_1;
    os_bit8  Toggle_2;

    /* Kick-off Embedded Program Sector Erase */

    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd1_OFFSET,
                        Am29F010_Sector_Erase_Cmd1_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd2_OFFSET,
                        Am29F010_Sector_Erase_Cmd2_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd3_OFFSET,
                        Am29F010_Sector_Erase_Cmd3_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd4_OFFSET,
                        Am29F010_Sector_Erase_Cmd4_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd5_OFFSET,
                        Am29F010_Sector_Erase_Cmd5_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        flashOffset,
                        Am29F010_Sector_Erase_Cmd6_DATA
                      );

    /* Use Toggle Bit Algorithm to know when Sector Erase is done */

    Toggle_1 = osCardRomReadBit8(
                                  hpRoot,
                                  flashOffset
                                );

    while(1)
    {
        Toggle_2 = osCardRomReadBit8(
                                      hpRoot,
                                      flashOffset
                                    );

        if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
        {
            /* Successfully Programmed */

            return;
        }

        if ((Toggle_2 & Am29F010_Exceeded_Timing_Limits_MASK) == Am29F010_Exceeded_Timing_Limits_MASK)
        {
            Toggle_1 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );
            Toggle_2 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );

            if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
            {
                /* Successfully Programmed */

                return;
            }

            /* Programming Failed - Reset Chip */

            osCardRomWriteBit8(
                                hpRoot,
                                Am29F010_Reset_Cmd1_OFFSET,
                                Am29F010_Reset_Cmd1_DATA
                              );

            return;
        }

        Toggle_1 = Toggle_2;
    }
#endif /* OSLayer_Stub was not defined */
}

os_bit8 fiFlashReadBit8(
                      agRoot_t *hpRoot,
                      os_bit32     flashOffset
                    )
{
    return osCardRomReadBit8(
                              hpRoot,
                              flashOffset
                            );
}

os_bit16 fiFlashReadBit16(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset
                      )
{
    fiFlashBit16ToBit8s_t fiFlashBit16ToBit8s;

    fiFlashBit16ToBit8s.bit_8s_form[0] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset
                                                       );
    fiFlashBit16ToBit8s.bit_8s_form[1] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 1
                                                       );

    return fiFlashBit16ToBit8s.bit_16_form;
}

os_bit32 fiFlashReadBit32(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset
                      )
{
    fiFlashBit32ToBit8s_t fiFlashBit32ToBit8s;

    fiFlashBit32ToBit8s.bit_8s_form[0] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset
                                                       );
    fiFlashBit32ToBit8s.bit_8s_form[1] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 1
                                                       );
    fiFlashBit32ToBit8s.bit_8s_form[2] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 2
                                                       );
    fiFlashBit32ToBit8s.bit_8s_form[3] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 3
                                                       );

    return fiFlashBit32ToBit8s.bit_32_form;
}

void fiFlashReadBlock(
                       agRoot_t *hpRoot,
                       os_bit32     flashOffset,
                       void     *flashBuffer,
                       os_bit32     flashBufLen
                     )
{
    while (flashBufLen > 0)
    {
        *((os_bit8 *)flashBuffer) = fiFlashReadBit8(
                                                  hpRoot,
                                                  flashOffset
                                                );

        flashOffset += sizeof(os_bit8);
        flashBuffer  = (void *)((os_bit8 *)flashBuffer + 1);
        flashBufLen -= sizeof(os_bit8);
    }
}

void fiFlashWriteBit8(
                       agRoot_t *hpRoot,
                       os_bit32     flashOffset,
                       os_bit8      flashValue
                     )
{
#ifdef OSLayer_Stub
    osCardRomWriteBit8(
                        hpRoot,
                        flashOffset,
                        flashValue
                      );
#else /* OSLayer_Stub was not defined */
    os_bit8 Toggle_1;
    os_bit8 Toggle_2;

    /* Kick-off Embedded Program Write */

    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Program_Cmd1_OFFSET,
                        Am29F010_Program_Cmd1_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Program_Cmd2_OFFSET,
                        Am29F010_Program_Cmd2_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Program_Cmd3_OFFSET,
                        Am29F010_Program_Cmd3_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        flashOffset,
                        flashValue
                      );

    /* Use Toggle Bit Algorithm to know when Write is done */

    Toggle_1 = osCardRomReadBit8(
                                  hpRoot,
                                  flashOffset
                                );

    while(1)
    {
        Toggle_2 = osCardRomReadBit8(
                                      hpRoot,
                                      flashOffset
                                    );

        if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
        {
            /* Successfully Programmed */

            return;
        }

        if ((Toggle_2 & Am29F010_Exceeded_Timing_Limits_MASK) == Am29F010_Exceeded_Timing_Limits_MASK)
        {
            Toggle_1 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );
            Toggle_2 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );

            if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
            {
                /* Successfully Programmed */

                return;
            }

            /* Programming Failed - Reset Chip */

            osCardRomWriteBit8(
                                hpRoot,
                                Am29F010_Reset_Cmd1_OFFSET,
                                Am29F010_Reset_Cmd1_DATA
                              );

            return;
        }

        Toggle_1 = Toggle_2;
    }
#endif /* OSLayer_Stub was not defined */
}

void fiFlashWriteBit16(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset,
                        os_bit16     flashValue
                      )
{
    fiFlashBit16ToBit8s_t fiFlashBit16ToBit8s;

    fiFlashBit16ToBit8s.bit_16_form = flashValue;

    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset,
                      fiFlashBit16ToBit8s.bit_8s_form[0]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 1,
                      fiFlashBit16ToBit8s.bit_8s_form[1]
                    );
}

void fiFlashWriteBit32(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset,
                        os_bit32     flashValue
                      )
{
    fiFlashBit32ToBit8s_t fiFlashBit32ToBit8s;

    fiFlashBit32ToBit8s.bit_32_form = flashValue;

    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset,
                      fiFlashBit32ToBit8s.bit_8s_form[0]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 1,
                      fiFlashBit32ToBit8s.bit_8s_form[1]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 2,
                      fiFlashBit32ToBit8s.bit_8s_form[2]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 3,
                      fiFlashBit32ToBit8s.bit_8s_form[3]
                    );
}

void fiFlashWriteBlock(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset,
                        void     *flashBuffer,
                        os_bit32     flashBufLen
                      )
{
    while (flashBufLen > 0)
    {
        fiFlashWriteBit8(
                          hpRoot,
                          flashOffset,
                          *((os_bit8 *)flashBuffer)
                        );

        flashOffset += sizeof(os_bit8);
        flashBuffer  = (void *)((os_bit8 *)flashBuffer + 1);
        flashBufLen -= sizeof(os_bit8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fwspec.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FWSpec.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/14/00 6:46p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  used to communicate via the Embedded Firmware API

--*/

#ifndef __FWSpec_H__

#define __FWSpec_H__

#ifdef _DvrArch_1_20_
typedef struct agRpcInbound_s
               agRpcInbound_t;

struct agRpcInbound_s
       {
         os_bit32 ReqControl;
         os_bit32 ReqAddrLo;
         os_bit32 ReqAddrHi;
       };

#define agRpcInbound_ReqControl_ReqID_MASK       (os_bit32)0xFFFF0000
#define agRpcInbound_ReqControl_ReqID_SHIFT      (os_bit32)0x10

#define agRpcInbound_ReqControl_ReqAddr64        (os_bit32)0x00008000

#define agRpcInbound_ReqControl_ReqLocal         (os_bit32)0x00004000

#define agRpcInbound_ReqControl_ReqSGL           (os_bit32)0x00002000

#define agRpcInbound_ReqControl_ReqLen_MASK      (os_bit32)0x00000FFF
#define agRpcInbound_ReqControl_ReqLen_SHIFT     (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcInbound_s
               hpRpcInbound_t;

struct hpRpcInbound_s
       {
         bit32 ReqControl;
         bit32 ReqAddrLo;
         bit32 ReqAddrHi;
       };

#define hpRpcInbound_ReqControl_ReqID_MASK       (bit32)0xFFFF0000
#define hpRpcInbound_ReqControl_ReqID_SHIFT      (bit32)0x10

#define hpRpcInbound_ReqControl_ReqAddr64        (bit32)0x00008000

#define hpRpcInbound_ReqControl_ReqLocal         (bit32)0x00004000

#define hpRpcInbound_ReqControl_ReqSGL           (bit32)0x00002000

#define hpRpcInbound_ReqControl_ReqLen_MASK      (bit32)0x00000FFF
#define hpRpcInbound_ReqControl_ReqLen_SHIFT     (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit32 agRpcInboundFast_t;

#define agRpcInboundFast_ReqID_MASK              (os_bit32)0xFFFF0000
#define agRpcInboundFast_ReqID_SHIFT             (os_bit32)0x10

#define agRpcInboundFast_ReqLen_MASK             (os_bit32)0x0000FFFF
#define agRpcInboundFast_ReqLen_SHIFT            (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef bit32 hpRpcInboundFast_t;

#define hpRpcInboundFast_ReqID_MASK              (bit32)0xFFFF0000
#define hpRpcInboundFast_ReqID_SHIFT             (bit32)0x10

#define hpRpcInboundFast_ReqLen_MASK             (bit32)0x0000FFFF
#define hpRpcInboundFast_ReqLen_SHIFT            (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit32 agRpcOutbound_t;

#define agRpcOutbound_ReqID_MASK                 (os_bit32)0xFFFF0000
#define agRpcOutbound_ReqID_SHIFT                (os_bit32)0x10

#define agRpcOutbound_ReqType_MASK               (os_bit32)0x0000FF00
#define agRpcOutbound_ReqType_SHIFT              (os_bit32)0x08

#define agRpcOutbound_ReqStatus_MASK             (os_bit32)0x000000FF
#define agRpcOutbound_ReqStatus_SHIFT            (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef bit32 hpRpcOutbound_t;

#define hpRpcOutbound_ReqID_MASK                 (bit32)0xFFFF0000
#define hpRpcOutbound_ReqID_SHIFT                (bit32)0x10

#define hpRpcOutbound_ReqType_MASK               (bit32)0x0000FF00
#define hpRpcOutbound_ReqType_SHIFT              (bit32)0x08

#define hpRpcOutbound_ReqStatus_MASK             (bit32)0x000000FF
#define hpRpcOutbound_ReqStatus_SHIFT            (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agRpcPortIDStickyOff                     (os_bit32)0x0

typedef os_bit32 agRpcPortID_t;

#define agRpcPortID_StickyID_MASK                (os_bit32)0xF0000000
#define agRpcPortID_StickyID_SHIFT               (os_bit32)0x1C

#define agRpcPortID_ChannelID_MASK               (os_bit32)0x0F000000
#define agRpcPortID_ChannelID_SHIFT              (os_bit32)0x18

#define agRpcPortID_PortID_MASK                  (os_bit32)0x00FFFFFF
#define agRpcPortID_PortID_SHIFT                 (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef bit32 hpRpcPortID_t;

#define hpRpcPortID_StickyID_MASK                (bit32)0xF0000000
#define hpRpcPortID_StickyID_SHIFT               (bit32)0x1C
#define hpRpcPortIDStickyOff                     0x0

#define hpRpcPortID_ChannelID_MASK               (bit32)0x0F000000
#define hpRpcPortID_ChannelID_SHIFT              (bit32)0x18

#define hpRpcPortID_PortID_MASK                  (bit32)0x00FFFFFF
#define hpRpcPortID_PortID_SHIFT                 (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit16 agRpcReqID_t;

#define agRpcReqIDNone                           (agRpcReqID_t)0x0000
#define agRpcReqIDFast                           (agRpcReqID_t)0x8000
#else  /* _DvrArch_1_20_ was not defined */
typedef bit16 hpRpcReqID_t;

#define hpRpcReqIDNone                           (hpRpcReqID_t)0x0000
#define hpRpcReqIDFast                           (hpRpcReqID_t)0x8000
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agRpcReqStatusOK                         (agRpcReqStatus_t)0x00
#define agRpcReqStatusBadInbound                 (agRpcReqStatus_t)0x01
#define agRpcReqStatusBadRequest                 (agRpcReqStatus_t)0x02
#define agRpcReqStatusLinkEvent                  (agRpcReqStatus_t)0x03
#define agRpcReqStatusBadReqID                   (agRpcReqStatus_t)0x04
#define agRpcReqStatusOK_Info                    (agRpcReqStatus_t)0x05
#define agRpcReqStatusPortStale                  (agRpcReqStatus_t)0x06
#define agRpcReqStatusIOAborted                  (agRpcReqStatus_t)0x07
#define agRpcReqStatusIOPortGone                 (agRpcReqStatus_t)0x08
#define agRpcReqStatusIOPortReset                (agRpcReqStatus_t)0x09
#define agRpcReqStatusIOInfoBad                  (agRpcReqStatus_t)0x0A
#define agRpcReqStatusIOOverUnder                (agRpcReqStatus_t)0x0B
#define agRpcReqStatusIOFailed                   (agRpcReqStatus_t)0x0C
#define agRpcReqStatusBadChannelID               (agRpcReqStatus_t)0x0D
#define agRpcReqStatusBadPortID                  (agRpcReqStatus_t)0x0E
#define agRpcReqStatusGetPortsNeedRoom           (agRpcReqStatus_t)0x0F
#define agRpcReqStatusBusy                       (agRpcReqStatus_t)0x10

typedef os_bit8 agRpcReqStatus_t;
#else  /* _DvrArch_1_20_ was not defined */
typedef bit8 hpRpcReqStatus_t;

#define hpRpcReqStatusOK                         (hpRpcReqStatus_t)0x00
#define hpRpcReqStatusBadInbound                 (hpRpcReqStatus_t)0x01
#define hpRpcReqStatusBadRequest                 (hpRpcReqStatus_t)0x02
#define hpRpcReqStatusLinkEvent                  (hpRpcReqStatus_t)0x03
#define hpRpcReqStatusBadReqID                   (hpRpcReqStatus_t)0x04
#define hpRpcReqStatusOK_Info                    (hpRpcReqStatus_t)0x05
#define hpRpcReqStatusPortStale                  (hpRpcReqStatus_t)0x06
#define hpRpcReqStatusIOAborted                  (hpRpcReqStatus_t)0x07
#define hpRpcReqStatusIOPortGone                 (hpRpcReqStatus_t)0x08
#define hpRpcReqStatusIOPortReset                (hpRpcReqStatus_t)0x09
#define hpRpcReqStatusIOInfoBad                  (hpRpcReqStatus_t)0x0A
#define hpRpcReqStatusIOOverUnder                (hpRpcReqStatus_t)0x0B
#define hpRpcReqStatusIOFailed                   (hpRpcReqStatus_t)0x0C
#define hpRpcReqStatusBadChannelID               (hpRpcReqStatus_t)0x0D
#define hpRpcReqStatusBadPortID                  (hpRpcReqStatus_t)0x0E
#define hpRpcReqStatusGetPortsNeedRoom           (hpRpcReqStatus_t)0x0F
#define hpRpcReqStatusBusy                       (hpRpcReqStatus_t)0x10
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit8 agRpcReqType_t;

#define agRpcReqTypeNone                         (agRpcReqType_t)0x00
#define agRpcReqTypeAbort                        (agRpcReqType_t)0x01
#define agRpcReqTypeDoSCSI                       (agRpcReqType_t)0x02
#define agRpcReqTypeGetChannelInfo               (agRpcReqType_t)0x03
#define agRpcReqTypeGetPortInfo                  (agRpcReqType_t)0x04
#define agRpcReqTypeGetPorts                     (agRpcReqType_t)0x05
#define agRpcReqTypeResetChannel                 (agRpcReqType_t)0x06
#define agRpcReqTypeResetPort                    (agRpcReqType_t)0x07
#define agRpcReqTypeSetupFastPath                (agRpcReqType_t)0x08
#else  /* _DvrArch_1_20_ was not defined */
typedef bit8 hpRpcReqType_t;

#define hpRpcReqTypeNone                         (hpRpcReqType_t)0x00
#define hpRpcReqTypeAbort                        (hpRpcReqType_t)0x01
#define hpRpcReqTypeDoSCSI                       (hpRpcReqType_t)0x02
#define hpRpcReqTypeGetChannelInfo               (hpRpcReqType_t)0x03
#define hpRpcReqTypeGetPortInfo                  (hpRpcReqType_t)0x04
#define hpRpcReqTypeGetPorts                     (hpRpcReqType_t)0x05
#define hpRpcReqTypeResetChannel                 (hpRpcReqType_t)0x06
#define hpRpcReqTypeResetPort                    (hpRpcReqType_t)0x07
#define hpRpcReqTypeSetupFastPath                (hpRpcReqType_t)0x08
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcSGL_s
               agRpcSGL_t;

struct agRpcSGL_s
       {
         os_bit32 Control;
         os_bit32 AddrLo;
         os_bit32 AddrHi;
       };

#define agRpcSGL_Control_Addr64                  (os_bit32)0x80000000

#define agRpcSGL_Control_Local                   (os_bit32)0x40000000

#define agRpcSGL_Control_Len_MASK                (os_bit32)0x0FFFFFFF
#define agRpcSGL_Control_Len_SHIFT               (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcSGL_s
               hpRpcSGL_t;

struct hpRpcSGL_s
       {
         bit32 Control;
         bit32 AddrLo;
         bit32 AddrHi;
       };

#define hpRpcSGL_Control_Addr64                  (bit32)0x80000000

#define hpRpcSGL_Control_Local                   (bit32)0x40000000

#define hpRpcSGL_Control_Len_MASK                (bit32)0x0FFFFFFF
#define hpRpcSGL_Control_Len_SHIFT               (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqAbort_s
               agRpcReqAbort_t;

struct agRpcReqAbort_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved;
         agRpcReqID_t   ReqID_to_Abort;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqAbort_s
               hpRpcReqAbort_t;

struct hpRpcReqAbort_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved;
         hpRpcReqID_t   ReqID_to_Abort;
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqDoSCSI_s
               agRpcReqDoSCSI_t;

struct agRpcReqDoSCSI_s
       {
         agRpcReqType_t        ReqType;
         os_bit8               reserved_1[3];
         agRpcPortID_t         PortID;
         os_bit16              reserved_2;
         os_bit16              RespControl;
         os_bit32              RespAddrLo;
         os_bit32              RespAddrHi;
         FC_FCP_CMND_Payload_t FCP_CMND;
         agRpcSGL_t            SGL[1];
       };

#define agRpcReqDoSCSI_RespControl_RespAddr64    (os_bit16)0x8000

#define agRpcReqDoSCSI_RespControl_RespLocal     (os_bit16)0x4000

#define agRpcReqDoSCSI_RespControl_RespSGL       (os_bit16)0x2000

#define agRpcReqDoSCSI_RespControl_RespLen_MASK  (os_bit16)0x0FFF
#define agRpcReqDoSCSI_RespControl_RespLen_SHIFT (os_bit16)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqDoSCSI_s
               hpRpcReqDoSCSI_t;

struct hpRpcReqDoSCSI_s
       {
         hpRpcReqType_t        ReqType;
         bit8                  reserved_1[3];
         hpRpcPortID_t         PortID;
         bit16                 reserved_2;
         bit16                 RespControl;
         bit32                 RespAddrLo;
         bit32                 RespAddrHi;
         FC_FCP_CMND_Payload_t FCP_CMND;
         hpRpcSGL_t            SGL[1];
       };

#define hpRpcReqDoSCSI_RespControl_RespAddr64    (bit16)0x8000

#define hpRpcReqDoSCSI_RespControl_RespLocal     (bit16)0x4000

#define hpRpcReqDoSCSI_RespControl_RespSGL       (bit16)0x2000

#define hpRpcReqDoSCSI_RespControl_RespLen_MASK  (bit16)0x0FFF
#define hpRpcReqDoSCSI_RespControl_RespLen_SHIFT (bit16)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqGetChannelInfo_s
               agRpcReqGetChannelInfo_t;

struct agRpcReqGetChannelInfo_s
       {
         agRpcReqType_t ReqType;
         os_bit8        ChannelID;
         os_bit8        reserved[2];
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqGetChannelInfo_s
               hpRpcReqGetChannelInfo_t;

struct hpRpcReqGetChannelInfo_s
       {
         hpRpcReqType_t ReqType;
         bit8           ChannelID;
         bit8           reserved[2];
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqGetPortInfo_s
               agRpcReqGetPortInfo_t;

struct agRpcReqGetPortInfo_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         agRpcPortID_t  PortID;
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqGetPortInfo_s
               hpRpcReqGetPortInfo_t;

struct hpRpcReqGetPortInfo_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         hpRpcPortID_t  PortID;
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqGetPorts_s
               agRpcReqGetPorts_t;

struct agRpcReqGetPorts_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqGetPorts_s
               hpRpcReqGetPorts_t;

struct hpRpcReqGetPorts_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqResetChannel_s
               agRpcReqResetChannel_t;

struct agRpcReqResetChannel_s
       {
         agRpcReqType_t ReqType;
         os_bit8        ChannelID;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqResetChannel_s
               hpRpcReqResetChannel_t;

struct hpRpcReqResetChannel_s
       {
         hpRpcReqType_t ReqType;
         bit8           ChannelID;
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqResetPort_s
               agRpcReqResetPort_t;

struct agRpcReqResetPort_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         agRpcPortID_t  PortID;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqResetPort_s
               hpRpcReqResetPort_t;

struct hpRpcReqResetPort_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         hpRpcPortID_t  PortID;
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqSetupFastPath_s
               agRpcReqSetupFastPath_t;

struct agRpcReqSetupFastPath_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         os_bit32       PoolEntriesSupplied;
         os_bit32       PoolEntriesUtilized;
         os_bit32       PoolEntrySize;
         os_bit32       PoolEntryOffset;
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqSetupFastPath_s
               hpRpcReqSetupFastPath_t;

struct hpRpcReqSetupFastPath_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         bit32          PoolEntriesSupplied;
         bit32          PoolEntriesUtilized;
         bit32          PoolEntrySize;
         bit32          PoolEntryOffset;
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqUnknown_s
               agRpcReqUnknown_t;

struct agRpcReqUnknown_s
       {
         agRpcReqType_t ReqType;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqUnknown_s
               hpRpcReqUnknown_t;

struct hpRpcReqUnknown_s
       {
         hpRpcReqType_t ReqType;
       };
#endif /* _DvrArch_1_20_ was not defined */

#endif  /* __FWSpec_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fmtfill.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FmtFill.H $

  $Revision: 2 $
      $Date: 3/20/01 3:36p $ (Last Check-In)
   $Modtime:: 8/14/00 6:45p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FmtFill.C

--*/

#ifndef __FmtFill_H__

#define __FmtFill_H__

#ifdef _DvrArch_1_20_
/*+

  agFmtBitXXMaxWidth defines the maximum width supported for each numeric
  format specifier (i.e. 'b', 'o', 'd', 'x', 'X').  For the extreme case
  where the format specifier is 'b' (binary), there are no more than 32
  digits in the binary representation of a os_bit32.  Hence, it is recommended
  that agFmtBitXXMaxWidth be set to 32 - certainly no less than 32.

  The pointer format specifiers ('p' and 'P') are assumed to require no more
  digits than any of the numeric format specifiers mentioned above.  Given
  that pointer formatting is only supported with hex digits, using a value
  of 32 for agFmtBitXXMaxWidth will support 128-bit pointers - certainly beyond
  the needs of any implementation today and in the forseeable future.
  
  Note that string format specifiers ('s') are not limited in width other than
  by the overall length of the target/output string.

-*/

#define agFmtBitXXMaxWidth 32
#else  /* _DvrArch_1_20_ was not defined */
#define hpFmtBitXXMaxWidth 32
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 agFmtFill(
                             char     *targetString,
                             os_bit32  targetLen,
                             char     *formatString,
                             char     *firstString,
                             char     *secondString,
                             void     *firstPtr,
                             void     *secondPtr,
                             os_bit32  firstBit32,
                             os_bit32  secondBit32,
                             os_bit32  thirdBit32,
                             os_bit32  fourthBit32,
                             os_bit32  fifthBit32,
                             os_bit32  sixthBit32,
                             os_bit32  seventhBit32,
                             os_bit32  eighthBit32
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 hpFmtFill(
                        char  *targetString,
                        bit32  targetLen,
                        char  *formatString,
                        char  *firstString,
                        char  *secondString,
                        bit32  firstBit32,
                        bit32  secondBit32,
                        bit32  thirdBit32,
                        bit32  fourthBit32,
                        bit32  fifthBit32,
                        bit32  sixthBit32,
                        bit32  seventhBit32,
                        bit32  eighthBit32
                      );
#endif /* _DvrArch_1_20_ was not defined */

#endif  /* __FmtFill_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fmtfill.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FmtFill.C $

  $Revision: 2 $
      $Date: 3/20/01 3:36p $ (Last Check-In)
   $Modtime:: 9/18/00 1:04p   $ (Last Modified)

Purpose:

  This file implements functions to fill in a
  buffer based on ANSI-style format specifiers.

--*/
#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#endif  /* _New_Header_file_Layout_ */

/*+

   Function: agFmtFill_Single()

    Purpose: Implements the logic to substitute one String, Pointer, or Bit32
             for a format specifier.  At entry, the percent-sign ('%') which
             begins a format specifier has already been "consumed".  The
             remainder of the format specifier needs to be parsed and the
             appropriate value substituted into targetString.

  Called By: agFmtFill_From_Arrays()

      Calls: <none>

-*/

#ifdef _DvrArch_1_20_
osLOCAL void agFmtFill_Single(
                               char      *targetString,
                               os_bit32   targetLen,
                               char      *formatString,
                               char      *stringToFormat,
                               os_bitptr  bitptrToFormat,
                               os_bit32   bit32ToFormat,
                               os_bit32  *targetStringProduced,
                               os_bit32  *formatStringConsumed,
                               os_bit32  *stringsConsumed,
                               os_bit32  *bitptrsConsumed,
                               os_bit32  *bit32sConsumed
                           )
#else  /* _DvrArch_1_20_ was not defined */
LOCAL void hpFmtFill_Single(
                             char  *targetString,
                             bit32  targetLen,
                             char  *formatString,
                             char  *stringToFormat,
                             bit32  bit32ToFormat,
                             bit32 *targetStringProduced,
                             bit32 *formatStringConsumed,
                             bit32 *stringsConsumed,
                             bit32 *bit32sConsumed
                           )
#endif /* _DvrArch_1_20_ was not defined */
{
#ifdef _DvrArch_1_20_
    char     c;
    os_bit32 fmtWidth                        = 0;
    os_bit32 fmtBase;
    os_bit32 formatPos                       = 0;
    char     fillChar                        = ' ';
    os_bit32 charIncBelow10                  = '0';
    os_bit32 charIncAbove9                   = 0;
    os_bit32 digit;
    os_bit32 digits                          = 0;
    char     digitStore[agFmtBitXXMaxWidth];
    os_bit32 chars                           = 0;
#else  /* _DvrArch_1_20_ was not defined */
    char  c;
    bit32 fmtWidth                        = 0;
    bit32 fmtBase;
    bit32 formatPos                       = 0;
    char  fillChar                        = ' ';
    bit32 charIncBelow10                  = '0';
    bit32 charIncAbove9                   = 0;  
    bit32 digit;
    bit32 digits                          = 0;
    char  digitStore[hpFmtBitXXMaxWidth];
    bit32 chars                           = 0;
#endif /* _DvrArch_1_20_ was not defined */

    /* The five return-values initialized below will indicate to the caller how */
    /*   many "units" of each type were consumed or produced during this call.  */
    /* TargetString characters are produced - as many as are needed to format   */
    /*   the String, Pointer, or Bit32 (not to exceed the format specifier's    */
    /*   requested width nor the capacity of TargetString.                      */
    /* FormatString characters are consumed - only up to the last character of  */
    /*   the current format specifier.                                          */
    /* Exactly one String, Pointer, or Bit32 will be consumed.                  */

    *targetStringProduced = 0;
    *formatStringConsumed = 0;
    *stringsConsumed      = 0;
#ifdef _DvrArch_1_20_
    *bitptrsConsumed      = 0;
#endif /* _DvrArch_1_20_ was defined */
    *bit32sConsumed       = 0;

    /* Note that this function assumes the leading '%' has already been eaten */

    if ((c = formatString[0]) == '0')
    {
        /* Zero-fill numerics (on the left) of format specifier begins '%0' */

        fillChar = '0';
        formatPos++;
    }

    /* Fetch format specifier's requested width */

    while (((c = formatString[formatPos++]) >= '0') &&
           (c <= '9'))
    {
        fmtWidth = (fmtWidth * 10) + (c - '0');
    }

    /* While statement above existed once it read "past" fmtWidth   */
    /*   Hence, c contains the Data Type to insert in TargetString. */

    switch (c)
    {
    case '%':
        /* If we get here, the format specifier is for a percent-sign ('%')      */
        /*   (i.e. Caller simply wants a percent-sign inserted in TargetString). */

        if (fillChar == '0')
        {
            /* Zero-filled percent-signs are not allowed */

            return;
        }

        if (fmtWidth != 0)
        {
            /* Field Width for percent-signs are not allowed */

            return;
        }

        if (1 > targetLen)
        {
            /* If we get here, there wasn't enough room in targetString */

            return;
        }

        *targetString = '%';       /* Place percent-sign ('%') in TargetString */

        *targetStringProduced = 1; /* Only produced a single character         */
        *formatStringConsumed = 1; /* Only consumed the (second) percent-sign  */

        return;
    case 's':
        /* If we get here, the format specifier is for a String */

        if (fillChar == '0')
        {
            /* Zero-filled strings are not allowed */

            return;
        }

        /* Copy String to TargetString - not to exceed fmtWidth or targetLen */

        while ((c = *stringToFormat++) != '\0')
        {
            *targetString++ = c;
            chars++;

            if ((chars == fmtWidth) ||
                (chars == targetLen))
            {
                break;
            }
        }

        /* Pad TargetString with fillChar (spaces) if           */
        /*   fmtWidth was specified and not yet fully consumed. */

        while ((chars < fmtWidth) &&
               (chars < targetLen))
        {
            *targetString++ = fillChar;
            chars++;
        }

        *targetStringProduced = chars;     /* Indicate how many chars were inserted in TargetString       */
        *formatStringConsumed = formatPos; /* formatPos indicates how many chars were in format specifier */

        *stringsConsumed      = 1;         /* String format specifier consumes exactly one String         */

        return;
#ifdef _DvrArch_1_20_
    case 'p':
    case 'P':
        /* If we get here, the format specifier is for a Pointer */

        fmtBase = 16;

        if (c == 'p')
        {
            charIncAbove9 = 'a' - 10;
        }
        else /* c == 'P' */
        {
            charIncAbove9 = 'A' - 10;
        }

        if (fmtWidth > agFmtBitXXMaxWidth)
        {
            /* If we get here, the format specifier was malformed */

            return;
        }

        /* Fill digitStore[] with hex digits computed using modulo arithmetic - low order digit first */

        while (bitptrToFormat != 0)
        {
            digit          = (os_bit32)(bitptrToFormat % fmtBase);
            bitptrToFormat = bitptrToFormat / fmtBase;

            digitStore[digits++] = (digit < 10 ? (char)(digit + charIncBelow10) : (char)(digit + charIncAbove9));

            if (digits > agFmtBitXXMaxWidth)
            {
                /* If we get here, there wasn't enough room in digitStore[] */

#ifdef _DvrArch_1_20_
                /* This should never happen for Bit32's
                   so long as agFmtBitXXMaxWidth >= 32  */
#else  /* _DvrArch_1_20_ was not defined */
                /* This should never happen for Bit32's
                   so long as hpFmtBitXXMaxWidth >= 32  */
#endif /* _DvrArch_1_20_ was not defined */

                return;
            }
        }

        if (digits == 0)
        {
            /* Special case - display 'agNULL' as value of pointer (with a space "fillChar") */

            digitStore[5] = 'a'; /* digitStore is read backwards, so 'agNULL' must be inserted backwards */
            digitStore[4] = 'g';
            digitStore[3] = 'N';
            digitStore[2] = 'U';
            digitStore[1] = 'L';
            digitStore[0] = 'L';

            digits        = 6;

            fillChar      = ' ';
        }

        /* Use fmtWidth if supplied, otherwise use minimum required (i.e. what was used in digitStore[]) */

        fmtWidth = (fmtWidth == 0 ? digits : fmtWidth);

        if (digits > fmtWidth)
        {
            /* If we get here, there wasn't enough room in fmtWidth */

            return;
        }

        if (fmtWidth > targetLen)
        {
            /* If we get here, there wasn't enough room in targetString */

            return;
        }

        for (digit = fmtWidth;
             digit > digits;
             digit--)
        {
            *targetString++ = fillChar;
        }

        while (digit > 0)
        {
            *targetString++ = digitStore[--digit];
        }

        *targetStringProduced = fmtWidth;  /* Indicate how many chars were inserted in TargetString       */
        *formatStringConsumed = formatPos; /* formatPos indicates how many chars were in format specifier */

        *bitptrsConsumed      = 1;         /* Pointer format specifier consumes exactly one Pointer       */

        return;
#endif /* _DvrArch_1_20_ was defined */
    case 'b':
        fmtBase = 2;
        break;
    case 'o':
        fmtBase = 8;
        break;
    case 'd':
        fmtBase = 10;
        break;
    case 'x':
        fmtBase = 16;
        charIncAbove9 = 'a' - 10;
        break;
    case 'X':
        fmtBase = 16;
        charIncAbove9 = 'A' - 10;
        break;
    case '\0':
    default:
        /* If we get here, the format specifier was malformed */

        return;
    }

    /* If we get here, the format specifier is for a Bit32 */

#ifdef _DvrArch_1_20_
    if (fmtWidth > agFmtBitXXMaxWidth)
#else  /* _DvrArch_1_20_ was not defined */
    if (fmtWidth > hpFmtBitXXMaxWidth)
#endif /* _DvrArch_1_20_ was not defined */
    {
        /* If we get here, the format specifier was malformed */

        return;
    }

    /* Fill digitStore[] with digits in the requested fmtBase     */
    /*   computed using modulo arithmetic - low order digit first */

    while (bit32ToFormat != 0)
    {
        digit         = bit32ToFormat % fmtBase;
        bit32ToFormat = bit32ToFormat / fmtBase;

        digitStore[digits++] = (digit < 10 ? (char)(digit + charIncBelow10) :(char)( digit + charIncAbove9));

#ifdef _DvrArch_1_20_
        if (digits > agFmtBitXXMaxWidth)
#else  /* _DvrArch_1_20_ was not defined */
        if (digits > hpFmtBitXXMaxWidth)
#endif /* _DvrArch_1_20_ was not defined */
        {
            /* If we get here, there wasn't enough room in digitStore[] */

#ifdef _DvrArch_1_20_
            /* This should never happen for Bit32's
               so long as agFmtBitXXMaxWidth >= 32  */
#else  /* _DvrArch_1_20_ was not defined */
            /* This should never happen for Bit32's
               so long as hpFmtBitXXMaxWidth >= 32  */
#endif /* _DvrArch_1_20_ was not defined */

            return;
        }
    }

    if (digits == 0)
    {
        digitStore[0] = '0';
        digits        = 1;
    }

    /* Use fmtWidth if supplied, otherwise use minimum required (i.e. what was used in digitStore[]) */

    fmtWidth = (fmtWidth == 0 ? digits : fmtWidth);

    if (digits > fmtWidth)
    {
        /* If we get here, there wasn't enough room in fmtWidth */

        return;
    }

    if (fmtWidth > targetLen)
    {
        /* If we get here, there wasn't enough room in targetString */

        return;
    }

    for (digit = fmtWidth;
         digit > digits;
         digit--)
    {
        *targetString++ = fillChar;
    }

    while (digit > 0)
    {
        *targetString++ = digitStore[--digit];
    }

    *targetStringProduced = fmtWidth;  /* Indicate how many chars were inserted in TargetString       */
    *formatStringConsumed = formatPos; /* formatPos indicates how many chars were in format specifier */

    *bit32sConsumed       = 1;         /* Bit32 format specifier consumes exactly one Bit32           */

    return;
}

/*+

   Function: agFmtFill_From_Arrays()

    Purpose: To enable looping, agFmtFill() has assembled arrays to hold the
             Strings, Pointers, and Bit32s which were passed in.  This way,
             loop indexes can simply advance as each data type is consumed as
             requested by format specifiers in formatString.

  Called By: agFmtFill()

      Calls: agFmtFill_Single()

-*/

#ifdef _DvrArch_1_20_
osLOCAL os_bit32 agFmtFill_From_Arrays(
                                        char       *targetString,
                                        os_bit32    targetLen,
                                        char       *formatString,
                                        char      **stringArray,
                                        os_bitptr  *bitptrArray,
                                        os_bit32   *bit32Array
                                      )
#else  /* _DvrArch_1_20_ was not defined */
LOCAL bit32 hpFmtFill_From_Arrays(
                                   char   *targetString,
                                   bit32   targetLen,
                                   char   *formatString,
                                   char  **stringArray,
                                   bit32  *bit32Array
                                 )
#endif /* _DvrArch_1_20_ was not defined */
{
#ifdef _DvrArch_1_20_
    os_bit32 bytesCopied = 0;
    os_bit32 targetStringProduced;
    os_bit32 formatStringConsumed;
    os_bit32 stringsConsumed;
    os_bit32 bitptrsConsumed;
    os_bit32 bit32sConsumed;
    char     c;
#else  /* _DvrArch_1_20_ was not defined */
    bit32 bytesCopied = 0;
    bit32 targetStringProduced;
    bit32 formatStringConsumed;
    bit32 stringsConsumed;
    bit32 bit32sConsumed;
    char  c;
#endif /* _DvrArch_1_20_ was not defined */

    /* Scan formatString until formatString exhaused or targetString is full */

    while (((c = *formatString++) != '\0') &&
           (bytesCopied < targetLen) )
    {
        if (c == '%')
        {
        /* Found a format specifier                                                       */

        /* Call agFmtFill_Single() to substitute the desired String, Pointer, or Bit32    */
        /*   for the format specifier.  Note that agFmtFill_Single() will "consume" the   */
        /*   corresponding array element as well as the remainder of the format specifier */
        /*   in the formatString.                                                         */

#ifdef _DvrArch_1_20_
            agFmtFill_Single(
#else  /* _DvrArch_1_20_ was not defined */
            hpFmtFill_Single(
#endif /* _DvrArch_1_20_ was not defined */
                              targetString,
                              (targetLen - bytesCopied),
                              formatString,
                              *stringArray,
#ifdef _DvrArch_1_20_
                              *bitptrArray,
#endif /* _DvrArch_1_20_ was defined */
                              *bit32Array,
                              &targetStringProduced,
                              &formatStringConsumed,
                              &stringsConsumed,
#ifdef _DvrArch_1_20_
                              &bitptrsConsumed,
#endif /* _DvrArch_1_20_ was defined */
                              &bit32sConsumed
                            );

            formatString += formatStringConsumed;
            targetString += targetStringProduced;
            bytesCopied  += targetStringProduced;
            stringArray  += stringsConsumed;
#ifdef _DvrArch_1_20_
            bitptrArray  += bitptrsConsumed,
#endif /* _DvrArch_1_20_ was defined */
            bit32Array   += bit32sConsumed;
        }
        else
        {
            /* Current character does not start a formatSpecifier - simply copy to targetString */

            *targetString++ = c;
            bytesCopied++;
        }
    }

    /* Terminate string with NULL character if their is room */

    if (bytesCopied < targetLen)
    {
        *targetString = '\0';
    }

    return bytesCopied;
}

#ifdef _DvrArch_1_20_
osLOCAL char      *agFmtFill_NULL_formatString = "agFmtFill(): formatString was NULL";
osLOCAL char      *agFmtFill_NULL_firstString  = "NULL 1st String";
osLOCAL char      *agFmtFill_NULL_secondString = "NULL 2nd String";
#endif /* _DvrArch_1_20_ was defined */

/*+

   Function: agFmtFill()

    Purpose: This function is called to format a string containing up to two
             character strings, two void pointers, and eight Bit32s in the
             manner of the LibC function sprintf().  The first two arguments
             describe the buffer to receive the formatted string.  The formatString
             is the required format string.  Subsequent arguments are required and
             must be either character string pointers, void pointers, or 32-bit
             entities.  Note that the strings are inserted as requested by "%s"
             format specifiers, the pointers are inserted as requested by "%p"
             and "%P" format specifiers, and the Bit32s are inserted as requested
             by numeric format specifiers.  String format specifiers are satisfied
             by the subsequent string arguments.  Pointer format specifiers are
             satisfied by the subsequent pointer arguments.  Numeric specifiers
             are satisfied by the subsequent Bit32 arguments.  A special "%%"
             format specifier will insert the "%" character.  Note that this is
             different from the sprintf() function in standard C libraries which
             consume arguments left to right regardless of format specifier type.

  Called By: osLogString()
             osLogDebugString()

      Calls: agFmtFill_From_Arrays()

-*/

#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 agFmtFill(
                             char     *targetString,
                             os_bit32  targetLen,
                             char     *formatString,
                             char     *firstString,
                             char     *secondString,
                             void     *firstPtr,
                             void     *secondPtr,
                             os_bit32  firstBit32,
                             os_bit32  secondBit32,
                             os_bit32  thirdBit32,
                             os_bit32  fourthBit32,
                             os_bit32  fifthBit32,
                             os_bit32  sixthBit32,
                             os_bit32  seventhBit32,
                             os_bit32  eighthBit32
                           )
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 hpFmtFill(
                        char  *targetString,
                        bit32  targetLen,
                        char  *formatString,
                        char  *firstString,
                        char  *secondString,
                        bit32  firstBit32,
                        bit32  secondBit32,
                        bit32  thirdBit32,
                        bit32  fourthBit32,
                        bit32  fifthBit32,
                        bit32  sixthBit32,
                        bit32  seventhBit32,
                        bit32  eighthBit32
                      )
#endif /* _DvrArch_1_20_ was not defined */
{
    char      *stringArray[2];
#ifdef _DvrArch_1_20_
    os_bitptr  bitptrArray[2];
    os_bit32   bit32Array[8];
#else  /* _DvrArch_1_20_ was not defined */
    bit32      bit32Array[8];
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
    if (    (targetString == (char *)agNULL)
         || (targetLen    == 0)              )
    {
        return (os_bit32)0;
    }

    if (formatString == (char *)agNULL)
    {
        formatString = agFmtFill_NULL_formatString;
    }

    if (firstString  == (char *)agNULL)
    {
        firstString  = agFmtFill_NULL_firstString;
    }

    if (secondString == (char *)agNULL)
    {
        secondString = agFmtFill_NULL_secondString;
    }
#endif /* _DvrArch_1_20_ was defined */

/* Convert to array-form of agFmtFill() to ease implementation */

    stringArray[0] = firstString;
    stringArray[1] = secondString;

#ifdef _DvrArch_1_20_
    if (firstPtr == (void *)agNULL)
    {
        bitptrArray[0] = (os_bitptr)0; /* Make sure agNULL os_bitptr can be detected */
    }
    else
    {
        bitptrArray[0] = (os_bitptr)(firstPtr);
    }

    if (secondPtr == (void *)agNULL)
    {
        bitptrArray[1] = (os_bitptr)0; /* Make sure agNULL os_bitptr can be detected */
    }
    else
    {
        bitptrArray[1] = (os_bitptr)(secondPtr);
    }
#endif /* _DvrArch_1_20_ was defined */

    bit32Array[0]  = firstBit32;
    bit32Array[1]  = secondBit32;
    bit32Array[2]  = thirdBit32;
    bit32Array[3]  = fourthBit32;
    bit32Array[4]  = fifthBit32;
    bit32Array[5]  = sixthBit32;
    bit32Array[6]  = seventhBit32;
    bit32Array[7]  = eighthBit32;

#ifdef _DvrArch_1_20_
    return agFmtFill_From_Arrays(
#else  /* _DvrArch_1_20_ was not defined */
    return hpFmtFill_From_Arrays(
#endif /* _DvrArch_1_20_ was not defined */
                                  targetString,
                                  targetLen,
                                  formatString,
                                  stringArray,
#ifdef _DvrArch_1_20_
                                  bitptrArray,
#endif /* _DvrArch_1_20_ was defined */
                                  bit32Array
                                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fwstub.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FWStub.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/07/00 4:57p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FWStub.C

--*/

#ifndef __FWStub_H__

#define __FWStub_H__

#include "I21554.h"

/*+
    Re-order the following #define/#undef pairs for the desired tuning
-*/

#ifdef  FWStub_Use_Fast_Path 
#undef  FWStub_Use_Fast_Path
#endif  /* FWStub_Use_Fast_Path was defined */

#ifndef FWStub_Use_Fast_Path 
#define FWStub_Use_Fast_Path
#endif  /* FWStub_Use_Fast_Path was defined */

#ifndef FWStub_Tune_for_One_INT_per_IO 
#define FWStub_Tune_for_One_INT_per_IO
#endif  /* FWStub_Tune_for_One_INT_per_IO was defined */

#ifdef  FWStub_Tune_for_One_INT_per_IO 
#undef  FWStub_Tune_for_One_INT_per_IO
#endif  /* FWStub_Tune_for_One_INT_per_IO was defined */

/*+
    Define crude size macros (rather than using osAdjustParameterBit32() calls for now)
-*/

#define FWStub_NumDevices 0x80

#define FWStub_NumIOs     0x400

#define FWStub_MaxSGL     0x20

#define FWStub_MaxInfo    (0x20 + 0x100)

/*+
    Define macros used to send & receive messages to/from Embedded CPU
-*/

#define FWStub_AllocInbound(agR) \
            osChipMemReadBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Inbound_Queue))

#define FWStub_PostInbound(agR,Inb) \
            osChipMemWriteBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Inbound_Queue),Inb)

#define FWStub_FetchOutbound(agR) \
            osChipMemReadBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Outbound_Queue))

#define FWStub_AckOutbound(agR) \
            osChipMemWriteBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Outbound_Queue),0)

/*+
    Declare per-IO Data Structures
-*/

typedef struct FWStub_IO_NonDMA_s
               FWStub_IO_NonDMA_t;

typedef struct FWStub_IO_DMA_s
               FWStub_IO_DMA_t;

struct FWStub_IO_NonDMA_s
       {
         FWStub_IO_NonDMA_t    *Next;
         FWStub_IO_DMA_t       *DMA;
         os_bit32               DMA_Lower32;
         agRpcReqID_t           ReqID;
         agIORequest_t         *agIORequest;
         agBOOLEAN              Active;
         agBOOLEAN              Aborted;
         FC_FCP_CMND_Payload_t *FCP_CMND;
         agRpcSGL_t            *SGL;
         os_bit8               *Info;
       };

struct FWStub_IO_DMA_s
       {
         agRpcReqDoSCSI_t ReqDoSCSI;
         agRpcSGL_t       SGL[FWStub_MaxSGL-1];
         os_bit8          Info[FWStub_MaxInfo];
       };

/*+
    Declare Global Data Structures
-*/

typedef struct FWStub_Global_NonDMA_s
               FWStub_Global_NonDMA_t;

typedef struct FWStub_Global_DMA_s
               FWStub_Global_DMA_t;

struct FWStub_Global_NonDMA_s
       {
         FWStub_Global_DMA_t *DMA;
         os_bit32             DMA_Lower32;
         agBOOLEAN            sysIntsActive;
#ifdef FWStub_Tune_for_One_INT_per_IO
         agRpcOutbound_t      agRpcOutbound;
#endif /* FWStub_Tune_for_One_INT_per_IO was defined */
         FWStub_IO_NonDMA_t  *First_IO;
         FWStub_IO_NonDMA_t   IOs[FWStub_NumIOs];
       };

struct FWStub_Global_DMA_s
       {
         union
         {
           agRpcReqAbort_t          ReqAbort;
           agRpcReqGetChannelInfo_t ReqGetChannelInfo;
           agRpcReqGetPortInfo_t    ReqGetPortInfo;
           agRpcReqGetPorts_t       ReqGetPorts;
           agRpcReqResetChannel_t   ReqResetChannel;
           agRpcReqResetPort_t      ReqResetPort;
           agRpcReqSetupFastPath_t  ReqSetupFastPath;
         }                                                      Request;
         union
         {
           agFCDev_t                Devices[FWStub_NumDevices];
           agFCChanInfo_t           ChanInfo;
           agFCDevInfo_t            DevInfo;
         }                                                      RequestInfo;
         FWStub_IO_DMA_t                                        IOs[FWStub_NumIOs];
       };

/*+
    Declare Miscellaneous Macros to walk Data Structures
-*/

#define FWStub_Global_NonDMA(agR) \
            ((FWStub_Global_NonDMA_t *)(((agRoot_t *)agR)->fcData))

#define FWStub_IO_NonDMA_from_agIORequest(agR) \
            ((FWStub_IO_NonDMA_t *)(((agIORequest_t *)agR)->fcData))

#define FWStub_Global_ReqID \
            ((agRpcReqID_t)(FWStub_NumIOs + 1))

#define FWStub_IO_NonDMA(Glob,ReqID) \
            ((FWStub_IO_NonDMA_t *)(&(((FWStub_Global_NonDMA_t *)(Glob))->IOs[(((ReqID) & ~agRpcReqIDFast) - 1)])))

#define FWStub_IO_DMA(Glob,ReqID) \
            ((FWStub_IO_DMA_t *)(&(((FWStub_Global_DMA_t *)(Glob))->IOs[(((ReqID) & ~agRpcReqIDFast) - 1)])))

#define FWStub_IO_DMA_Lower32(Glob,ReqID) \
            (((os_bit32)(Glob)) + agFieldOffset(FWStub_Global_DMA_t,IOs[(((ReqID) & ~agRpcReqIDFast) - 1)]))

#define FWStub_IO_DMA_FCP_CMND(IO) \
            ((FC_FCP_CMND_Payload_t *)(&(((FWStub_IO_DMA_t *)(IO))->ReqDoSCSI.FCP_CMND)))

#define FWStub_IO_DMA_FCP_CMND_Lower32(IO_Lower32) \
            (((os_bit32)(IO_Lower32)) + agFieldOffset(FWStub_IO_DMA_t,ReqDoSCSI.FCP_CMND))

#define FWStub_IO_DMA_SGL(IO) \
            ((agRpcSGL_t *)(&(((FWStub_IO_DMA_t *)(IO))->ReqDoSCSI.SGL[0])))

#define FWStub_IO_DMA_SGL_Lower32(IO_Lower32) \
            (((os_bit32)(IO_Lower32)) + agFieldOffset(FWStub_IO_DMA_t,ReqDoSCSI.SGL[0]))

#define FWStub_IO_DMA_Info(IO) \
            ((os_bit8 *)(&(((FWStub_IO_DMA_t *)(IO))->Info)))

#define FWStub_IO_DMA_Info_Lower32(IO_Lower32) \
            (((os_bit32)(IO_Lower32)) + agFieldOffset(FWStub_IO_DMA_t,Info))

#define FWStub_IO_DMA_SIZE(NumSGL) \
            ((os_bit32)(sizeof(agRpcReqDoSCSI_t) + (((NumSGL) - 1)*sizeof(agRpcSGL_t))))

/*+
    Resultant Macros to return from fcInitializeDriver()
-*/

#define FWStub_cachedMemoryNeeded   (os_bit32)(sizeof(FWStub_Global_NonDMA_t))
#define FWStub_cachedMemoryPtrAlign (os_bit32)1
#define FWStub_dmaMemoryNeeded      (os_bit32)(sizeof(FWStub_Global_DMA_t))
#define FWStub_dmaMemoryPtrAlign    (os_bit32)1
#define FWStub_dmaMemoryPhyAlign    (os_bit32)1
#define FWStub_nvMemoryNeeded       (os_bit32)0
#define FWStub_usecsPerTick         (os_bit32)1000000

/*+
    Internal Function Prototypes
-*/

#define FWStub_Send_Request_Retries_DEFAULT    (os_bit32)10
#define FWStub_Send_Request_RetryStall_DEFAULT (os_bit32)1000

osLOCAL agBOOLEAN FWStub_Send_Request(
                                       agRoot_t     *agRoot,
                                       agRpcReqID_t  ReqID,
                                       os_bit32      ReqLen,
                                       os_bit32      ReqAddr_Lower32,
                                       os_bit32      Retries,
                                       os_bit32      RetryStall
                                     );

#define FWStub_Poll_Response_RetryStall_DEFAULT (os_bit32)1000

osLOCAL agRpcOutbound_t FWStub_Poll_Response(
                                              agRoot_t     *agRoot,
                                              agRpcReqID_t  ReqID,
                                              agBOOLEAN     DisposeOtherReqIDs,
                                              os_bit32      RetryStall
                                            );

osLOCAL void FWStub_Process_Response(
                                      agRoot_t        *agRoot,
                                      agRpcOutbound_t  RpcOutbound
                                    );

#endif /* __FWStub_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fwstub.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FWStub.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/07/00 6:01p   $ (Last Modified)

Purpose:

  This file implements the main entry points and support functions for the
  Stub FC Layer which implements the FirmWare Specification (FWSpec.DOC).

--*/

#include "../h/globals.h"
#include "../h/fwstub.h"

/*
 * Implement each FC Layer Function
 */

/*+

   Function: fcAbortIO()

    Purpose: This function is called to abort an I/O Request previously initiated by a call
             to fcStartIO().  The OS Layer should not assume that the I/O Request has been
             aborted until a call has been made to osIOCompleted() (presumably with the
             osIOAborted status).  Note that if osIOCompleted() hasn't yet been called for
             an I/O aborted via fcAbortIO(), the FC Layer must ensure that when osIOCompleted()
             is ultimately called that the I/O is marked as having been aborted even if the
             I/O actually had completed successfully.

             For the FWStub FC Layer, the synchronous behavior of the Abort Request must be
             preserved.  Thus, the Abort Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osSingleThreadedLeave()
             FWStub_Send_Request()
             FWStub_Poll_Response()

-*/

osGLOBAL void fcAbortIO(
                         agRoot_t      *agRoot,
                         agIORequest_t *agIORequest
                       )
{
    FWStub_IO_NonDMA_t     *IO_NonDMA;
    FWStub_IO_DMA_t        *IO_DMA;
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqAbort_t        *ReqAbort_DMA;
    os_bit32                ReqAbort_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;

    osSingleThreadedEnter(
                           agRoot
                         );

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    if (    (IO_NonDMA->Active == agFALSE)
         || (IO_NonDMA->Aborted == agTRUE) )
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return;
    }

    IO_DMA = IO_NonDMA->DMA;

    IO_NonDMA->Aborted = agTRUE;

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqAbort_DMA         = &(Global_DMA->Request.ReqAbort);
    ReqAbort_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                               FWStub_Global_DMA_t,
                                                               Request.ReqAbort
                                                             );

    ReqAbort_DMA->ReqType        = agRpcReqTypeAbort;
    ReqAbort_DMA->ReqID_to_Abort = IO_DMA->ReqDoSCSI.PortID;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqAbort_t),
                                                      ReqAbort_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcBindToWorkQs()

    Purpose: This function is used to attach the FC Layer to a pair of Work Queues presumably
             shared with another driver.  Two Work Queues make up an interface between the FC
             Layer and its peer.  Each Work Queue is described by a base address, number of
             entries, and the addresses of producer and consumer indexes.  Any number of Work
             Queue pairs could be supported, but each will have a defined purpose.  Initially,
             only a Work Queue pair for IP is supported.

             For the FWStub FC Layer, this function is not implemented.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

#ifdef _DvrArch_1_30_
osGLOBAL os_bit32 fcBindToWorkQs(
                                  agRoot_t  *agRoot,
                                  os_bit32   agQPairID,
                                  void     **agInboundQBase,
                                  os_bit32   agInboundQEntries,
                                  os_bit32  *agInboundQProdIndex,
                                  os_bit32  *agInboundQConsIndex,
                                  void     **agOutboundQBase,
                                  os_bit32   agOutboundQEntries,
                                  os_bit32  *agOutboundQProdIndex,
                                  os_bit32  *agOutboundQConsIndex
                                )
{
    return (os_bit32)0;
}
#endif /* _DvrArch_1_30_ was defined */

/*+

   Function: fcCardSupported()

    Purpose: This function is called to check to see if the FC Layer supports this card
             corresponding to the value of agRoot passed.  Presumably, the PCI Configuration
             Registers VendorID (bytes 0x00-0x01), DeviceID (bytes 0x02-0x03), RevisionID
             (byte 0x08), ClassCode (bytes 0x09-0x0B), SubsystemVendorID (bytes 0x2C-0x2D),
             and SubsystemID (bytes 0x2E-0x2F) are used in this determination.  Perhaps, the
             WorldWideName (WWN) is used as well.  The function returns agTRUE if the FC
             Layer supports this card and agFALSE if it does not.

             For the FWStub FC Layer, only the DeviceID and VendorID of the Intel 21554
             Bridge Chip on the SA-IOP is verified.

  Called By: <unknown OS Layer functions>

      Calls: osChipConfigReadBit32()

-*/

osGLOBAL agBOOLEAN fcCardSupported(
                                    agRoot_t *agRoot
                                  )
{
    if (osChipConfigReadBit32(
                               agRoot,
                               agFieldOffset(
                                              I21554_Primary_Interface_Config_t,
                                              DeviceID_VendorID
                                            )
                             ) == (I21554_Config_DeviceID_21554 | I21554_Config_VendorID_Intel))
    {
        return agTRUE;
    }
    else
    {
        return agFALSE;
    }
}

/*+

   Function: fcDelayedInterruptHandler()

    Purpose: This function is called following a prior call to fcInterruptHandler() which
             returned agTRUE.  At that time, the Fibre Channel protocol chip (TachyonTL,
             in this case) had raised an interrupt which fcInterruptHandler() masked.  The
             role of fcDelayedInterruptHandler() is to handle the original interrupt (e.g.
             process the I/O completion message in the IMQ), unmask the interrupt and return.
             Now that calls to osSingleThreadedEnter() are allowed (calling osSingleThreadedEnter()
             from fcInterruptHandler() was not allowed), the FC Layer can control access to data
             structures and the chip as needed.

             For the FWStub FC Layer, messages arriving on the Outbound FIFO of the Intel 21554
             Bridge are processed.  Note that only messages using the "Normal Path" are acknowledged.
             In either case, all messages currently in the Outbound FIFO are processed prior to return.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Process_Response()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcDelayedInterruptHandler(
                                         agRoot_t *agRoot
                                       )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    agRpcOutbound_t         RpcOutbound;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

#ifdef FWStub_Tune_for_One_INT_per_IO
    RpcOutbound = Global_NonDMA->agRpcOutbound;

    if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
    {
        /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

        FWStub_AckOutbound(
                            agRoot
                          );
    }

    FWStub_Process_Response(
                             agRoot,
                             RpcOutbound
                           );
#else  /* FWStub_Tune_for_One_INT_per_IO was not defined */
    while ( (RpcOutbound = FWStub_FetchOutbound(
                                                 agRoot
                                               )       ) != 0xFFFFFFFF )
    {
        if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
        {
            /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

            FWStub_AckOutbound(
                                agRoot
                              );
        }

        FWStub_Process_Response(
                                 agRoot,
                                 RpcOutbound
                               );
    }
#endif /* FWStub_Tune_for_One_INT_per_IO was not defined */

    if (Global_NonDMA->sysIntsActive != agFALSE)
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             0
                           );
    }

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcEnteringOS()

    Purpose: This function is called to indicate to the FC Layer that it is being called after
             the OS has switched back (presumably between NetWare and BIOS) from the "other OS".
             The prior switch out of "this OS" was preceded by a call to fcLeavingOS().

             For the FWStub FC Layer, Interrupt Handling is re-enabled if active prior to the
             corresponding call to fcLeavingOS().

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcEnteringOS(
                            agRoot_t *agRoot
                          )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    if (FWStub_Global_NonDMA(agRoot)->sysIntsActive == agFALSE)
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                           );
    }
    else /* FWStub_Global_NonDMA(agRoot)->sysIntsActive == agTRUE */
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             0
                           );
    }

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcGetChannelInfo()

    Purpose: This function is called to return information about the channel.  The information
             returned is described in the agFCChanInfo_t structure.

             For the FWStub FC Layer, the synchronous behavior of the GetChannelInfo Request must
             be preserved.  Thus, the GetChannelInfo Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcGetChannelInfo(
                                    agRoot_t       *agRoot,
                                    agFCChanInfo_t *agFCChanInfo
                                  )
{
    FWStub_Global_NonDMA_t   *Global_NonDMA;
    FWStub_Global_DMA_t      *Global_DMA;
    os_bit32                  Global_DMA_Lower32;
    agRpcReqGetChannelInfo_t *ReqGetChannelInfo_DMA;
    os_bit32                  ReqGetChannelInfo_DMA_Lower32;
    agFCChanInfo_t           *ChanInfo_DMA;
    os_bit32                  ChanInfo_DMA_Lower32;
    agBOOLEAN                 FWStub_Send_Request_RETURN;
    agRpcOutbound_t           RpcOutbound;
    os_bit32                  To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqGetChannelInfo_DMA         = &(Global_DMA->Request.ReqGetChannelInfo);
    ReqGetChannelInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                        FWStub_Global_DMA_t,
                                                                        Request.ReqGetChannelInfo
                                                                      );

    ChanInfo_DMA         = &(Global_DMA->RequestInfo.ChanInfo);
    ChanInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                               FWStub_Global_DMA_t,
                                                               RequestInfo.ChanInfo
                                                             );

    ReqGetChannelInfo_DMA->ReqType        = agRpcReqTypeGetChannelInfo;
    ReqGetChannelInfo_DMA->ChannelID      = 0;
    ReqGetChannelInfo_DMA->SGL[0].Control = (sizeof(agFCChanInfo_t) << agRpcSGL_Control_Len_SHIFT);
    ReqGetChannelInfo_DMA->SGL[0].AddrLo  = ChanInfo_DMA_Lower32;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqGetChannelInfo_t),
                                                      ReqGetChannelInfo_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return ~fcChanInfoReturned;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusOK)
    {
        *agFCChanInfo = *ChanInfo_DMA;

        To_Return = fcChanInfoReturned;
    }
    else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
    {
        To_Return = ~fcChanInfoReturned;
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcGetDeviceHandles()

    Purpose: This function is called to return the device handles for each device currently
             available.  Note that the function returns the number of device slots available
             but will only copy the handles which will fit into the supplied buffer.  Further,
             there are potentially holes in the list where devices once existed but are not
             presently addressable.  Hence, the number of handles actually present in the
             returned list must be determined by the OS Layer.  As the FC Layer is responsible
             for ensuring the persistence of addressing to each device, a particular slot in
             the returned array will always refer to the same device (though the value contained
             in that slot may differ from time to time).

             For the FWStub FC Layer, the synchronous behavior of the GetDeviceHandles Request must
             be preserved.  Thus, the GetDeviceHandles Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcGetDeviceHandles(
                                      agRoot_t  *agRoot,
                                      agFCDev_t  agFCDev[],
                                      os_bit32   maxFCDevs
                                    )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqGetPorts_t     *ReqGetPorts_DMA;
    os_bit32                ReqGetPorts_DMA_Lower32;
    agFCDev_t              *Devices_DMA;
    os_bit32                Devices_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                Device_Index;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqGetPorts_DMA         = &(Global_DMA->Request.ReqGetPorts);
    ReqGetPorts_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                  FWStub_Global_DMA_t,
                                                                  Request.ReqGetPorts
                                                                );

    Devices_DMA         = &(Global_DMA->RequestInfo.Devices[0]);
    Devices_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                              FWStub_Global_DMA_t,
                                                              RequestInfo.Devices[0]
                                                            );

    ReqGetPorts_DMA->ReqType        = agRpcReqTypeGetPorts;
    ReqGetPorts_DMA->SGL[0].Control = ((FWStub_NumDevices * sizeof(agFCDev_t)) << agRpcSGL_Control_Len_SHIFT);
    ReqGetPorts_DMA->SGL[0].AddrLo  = Devices_DMA_Lower32;

    for(
         Device_Index = 0;
         Device_Index < FWStub_NumDevices;
         Device_Index++
       )
    {
        Devices_DMA[Device_Index] = (agFCDev_t)0x00000000;
    }

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqGetPorts_t),
                                                      ReqGetPorts_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return 0;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    To_Return = 0;

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusOK)
    {
        for(
             Device_Index = 0;
             (Device_Index < FWStub_NumDevices);
             Device_Index++
           )
        {
            if (Device_Index < maxFCDevs)
            {
                agFCDev[Device_Index] = Devices_DMA[Device_Index];
            }

            if (Devices_DMA[Device_Index] != (agFCDev_t)0x00000000)
            {
                To_Return = Device_Index + 1;
            }
        }
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcGetDeviceInfo()

    Purpose: This function is called to return information about the specified device handle.
             The information returned is described in the agFCDevInfo_t structure.

             For the FWStub FC Layer, the synchronous behavior of the GetDeviceInfo Request must
             be preserved.  Thus, the GetDeviceInfo Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcGetDeviceInfo(
                                   agRoot_t      *agRoot,
                                   agFCDev_t      agFCDev,
                                   agFCDevInfo_t *agFCDevInfo
                                 )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqGetPortInfo_t  *ReqGetPortInfo_DMA;
    os_bit32                ReqGetPortInfo_DMA_Lower32;
    agFCDevInfo_t          *DevInfo_DMA;
    os_bit32                DevInfo_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqGetPortInfo_DMA         = &(Global_DMA->Request.ReqGetPortInfo);
    ReqGetPortInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                     FWStub_Global_DMA_t,
                                                                     Request.ReqGetPortInfo
                                                                   );

    DevInfo_DMA         = &(Global_DMA->RequestInfo.DevInfo);
    DevInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                              FWStub_Global_DMA_t,
                                                              RequestInfo.DevInfo
                                                            );

    ReqGetPortInfo_DMA->ReqType        = agRpcReqTypeGetPortInfo;
    ReqGetPortInfo_DMA->PortID         = (agRpcPortID_t)agFCDev;
    ReqGetPortInfo_DMA->SGL[0].Control = (sizeof(agFCDevInfo_t) << agRpcSGL_Control_Len_SHIFT);
    ReqGetPortInfo_DMA->SGL[0].AddrLo  = DevInfo_DMA_Lower32;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqGetPortInfo_t),
                                                      ReqGetPortInfo_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return ~fcGetDevInfoReturned;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusOK)
    {
        *agFCDevInfo = *DevInfo_DMA;

        To_Return = fcGetDevInfoReturned;
    }
    else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
    {
        To_Return = ~fcGetDevInfoReturned;
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcInitializeChannel()

    Purpose: This function is called to initialize a particular channel.  Note that channel
             initialization must be preceded by a call to fcInitializeDriver().  In addition
             to indicating memory allocated, the OS Layer specifies the number of microseconds
             between timer ticks (indicated in calls to fcTimerTick()).  If the value of
             usecsPerTick returned is zero, no calls to fcTimerTick() will be made.  Note also
             that this interval may be different from that requested in the return from
             fcInitializeDriver().  Finally, it is possible to request that the initialization
             be completed before returning (fcSyncInit) or asynchronously (fcAsyncInit) followed
             by a callback to osInitializeChannelCallback().  In the asynchronous case, a return
             (from this function) of fcInitializeSuccess simply means that initialization of the
             channel has begun and that the final status (the value osInitializeChannelCallback()
             ultimately returns) should be tested for success.  Should the return (from this
             function) be fcInitializeFailure and fcAsyncInit was specified, no callback to
             osInitializeChannelCallback() will be made.  During initialization, it is often the
             case that interrupts are not yet available.  A parameter, sysIntsActive, indicates
             whether or not interrupts are available.  A subsequent call to fcSystemInterruptsActive()
             will indicate when interrupts become available should they not be at this time.

             For the FWStub FC Layer, the InitializeChannel function simply means that data structures
             internal to FWStub must be initialized.  The Embedded Firmware has already initialized the
             actual FibreChannel Port(s).  In addition, the "Fast Path" for optimized I/O commands is
             set up via a synchronous request (i.e. fcInitializeChannel() polls for completion).
             Finally, the Outbound FIFO is emptied so that subsequent execution will proceed from a
             clean starting point.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             FWStub_Send_Request()
             osInitializeChannelCallback()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcInitializeChannel(
                                       agRoot_t  *agRoot,
                                       os_bit32   initType,
                                       agBOOLEAN  sysIntsActive,
                                       void      *cachedMemoryPtr,
                                       os_bit32   cachedMemoryLen,
                                       os_bit32   dmaMemoryUpper32,
                                       os_bit32   dmaMemoryLower32,
                                       void      *dmaMemoryPtr,
                                       os_bit32   dmaMemoryLen,
                                       os_bit32   nvMemoryLen,
                                       os_bit32   cardRamUpper32,
                                       os_bit32   cardRamLower32,
                                       os_bit32   cardRamLen,
                                       os_bit32   cardRomUpper32,
                                       os_bit32   cardRomLower32,
                                       os_bit32   cardRomLen,
                                       os_bit32   usecsPerTick
                                     )
{
    FWStub_Global_NonDMA_t  *Global_NonDMA;
    FWStub_Global_DMA_t     *Global_DMA;
    os_bit32                 Global_DMA_Lower32;
    agRpcReqSetupFastPath_t *ReqSetupFastPath_DMA;
    os_bit32                 ReqSetupFastPath_DMA_Lower32;
    agBOOLEAN                FWStub_Send_Request_RETURN;
    agRpcOutbound_t          RpcOutbound;
    FWStub_IO_NonDMA_t      *IO_NonDMA;
    FWStub_IO_DMA_t         *IO_DMA;
    os_bit32                 IO_DMA_Lower32;
    agRpcReqID_t             ReqID;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA      = (FWStub_Global_NonDMA_t *)cachedMemoryPtr;
    Global_DMA         = (FWStub_Global_DMA_t *)dmaMemoryPtr;
    Global_DMA_Lower32 = dmaMemoryLower32;

    Global_NonDMA->DMA           = Global_DMA;
    Global_NonDMA->DMA_Lower32   = Global_DMA_Lower32;

    if (sysIntsActive == agFALSE)
    {
        Global_NonDMA->sysIntsActive = agFALSE;

        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                           );
    }
    else /* sysIntsActive == agTRUE */
    {
        Global_NonDMA->sysIntsActive = agTRUE;

        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             0
                           );
    }

#ifdef FWStub_Use_Fast_Path
    /* Setup Fast Path for DoSCSI Request IDs */

    ReqSetupFastPath_DMA         = &(Global_DMA->Request.ReqSetupFastPath);
    ReqSetupFastPath_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                       FWStub_Global_DMA_t,
                                                                       Request.ReqSetupFastPath
                                                                     );

    ReqSetupFastPath_DMA->ReqType             = agRpcReqTypeSetupFastPath;

    ReqSetupFastPath_DMA->PoolEntriesSupplied = FWStub_NumIOs;
    ReqSetupFastPath_DMA->PoolEntriesUtilized = 0;
    ReqSetupFastPath_DMA->PoolEntrySize       = sizeof(FWStub_IO_DMA_t);
    ReqSetupFastPath_DMA->PoolEntryOffset     = (os_bit32)0;

    ReqSetupFastPath_DMA->SGL[0].Control      = (    (FWStub_NumIOs * sizeof(FWStub_IO_DMA_t))
                                                  << agRpcSGL_Control_Len_SHIFT                );
    ReqSetupFastPath_DMA->SGL[0].AddrLo       = Global_DMA_Lower32 + agFieldOffset(
                                                                                    FWStub_Global_DMA_t,
                                                                                    IOs
                                                                                  );
    ReqSetupFastPath_DMA->SGL[0].AddrHi       = (os_bit32)0;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqSetupFastPath_t),
                                                      ReqSetupFastPath_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        if ( (initType & fcSyncAsyncInitMask) == fcAsyncInit )
        {
            osInitializeChannelCallback(
                                         agRoot,
                                         fcInitializeFailure
                                       );
        }

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcInitializeFailure;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agTRUE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         != agRpcReqStatusOK)
    {
        if ( (initType & fcSyncAsyncInitMask) == fcAsyncInit )
        {
            osInitializeChannelCallback(
                                         agRoot,
                                         fcInitializeFailure
                                       );
        }

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcInitializeFailure;
    }

    /* Queue onto DoSCSI Request Free List Fast Path Request IDs to Utilize */
#else /* FWStub_Use_Fast_Path was not defined */
    /* Queue onto DoSCSI Request Free List Normal Path Request IDs to Utilize */
#endif /* FWStub_Use_Fast_Path was not defined */

    for(
         ReqID = 1;
#ifdef FWStub_Use_Fast_Path
         ReqID <= Global_DMA->Request.ReqSetupFastPath.PoolEntriesUtilized;
#else /* FWStub_Use_Fast_Path was not defined */
         ReqID <  FWStub_Global_ReqID;
#endif /* FWStub_Use_Fast_Path was not defined */
         ReqID++
       )
    {
        IO_NonDMA      = FWStub_IO_NonDMA(Global_NonDMA,ReqID);
        IO_DMA         = FWStub_IO_DMA(Global_DMA,ReqID);
        IO_DMA_Lower32 = FWStub_IO_DMA_Lower32(Global_DMA_Lower32,ReqID);

        if (ReqID == 1)
        {
            IO_NonDMA->Next = (FWStub_IO_NonDMA_t *)agNULL;
        }
        else
        {
            IO_NonDMA->Next = Global_NonDMA->First_IO;
        }

        Global_NonDMA->First_IO = IO_NonDMA;

        IO_NonDMA->DMA         = IO_DMA;
        IO_NonDMA->DMA_Lower32 = IO_DMA_Lower32;
#ifdef FWStub_Use_Fast_Path
        IO_NonDMA->ReqID       = ReqID | agRpcReqIDFast;
#else /* FWStub_Use_Fast_Path was not defined */
        IO_NonDMA->ReqID       = ReqID;
#endif /* FWStub_Use_Fast_Path was not defined */
        IO_NonDMA->agIORequest = (agIORequest_t *)agNULL;
        IO_NonDMA->Active      = agFALSE;
        IO_NonDMA->Aborted     = agFALSE;
        IO_NonDMA->FCP_CMND    = FWStub_IO_DMA_FCP_CMND(IO_DMA);
        IO_NonDMA->SGL         = FWStub_IO_DMA_SGL(IO_DMA);
        IO_NonDMA->Info        = FWStub_IO_DMA_Info(IO_DMA);

        IO_DMA->ReqDoSCSI.ReqType     = agRpcReqTypeDoSCSI;
        IO_DMA->ReqDoSCSI.RespControl = (FWStub_MaxInfo << agRpcReqDoSCSI_RespControl_RespLen_SHIFT);
        IO_DMA->ReqDoSCSI.RespAddrLo  = FWStub_IO_DMA_Info_Lower32(IO_DMA_Lower32);
    }

    agRoot->fcData = (void *)Global_NonDMA;

    /* Empty extraneous Outbound FIFO data */

    while ( (RpcOutbound = FWStub_FetchOutbound(
                                                 agRoot
                                               )       ) != 0xFFFFFFFF )
    {
        if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
        {
            /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

            FWStub_AckOutbound(
                                agRoot
                              );
        }
    }

    if ( (initType & fcSyncAsyncInitMask) == fcAsyncInit )
    {
        osInitializeChannelCallback(
                                     agRoot,
                                     fcInitializeSuccess
                                   );
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return fcInitializeSuccess;
}

/*+

   Function: fcInitializeDriver()

    Purpose: This function is called to initialize the FC Layer's portion of the driver.  While
             the agRoot structure is passed as an argument, it is only useful as a handle to pass
             back to the OS Layer (presumably in calls to osAdjustParameterXXX() in determining
             how much memory is needed by each instance of the driver) as no non-stack memory is
             available to preserve the contents of agRoot.  The amount and alignment of memory
             needed by each instance of the driver (i.e. for each channel) is returned by
             fcInitializeDriver() in the reference arguments provided.  The three types of memory
             requested are cached, non-cached (a.k.a. dma), and non-volatile.  Note that the
             non-cached memory (a.k.a. "dma memory") is constrained to be physically contiguous
             memory.  In addition to memory needs, the FC Layer specifies the number of microseconds
             between timer ticks (indicated in calls to fcTimerTick()).  If the value of usecsPerTick
             returned is zero, no calls to fcTimerTick() will be made.

             For the FWStub FC Layer, all data structures are hard-specified in ..\H\FWStub.H
             rather than computed using calls to osAdjustParameterBit32().

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit32 fcInitializeDriver(
                                      agRoot_t *agRoot,
                                      os_bit32 *cachedMemoryNeeded,
                                      os_bit32 *cachedMemoryPtrAlign,
                                      os_bit32 *dmaMemoryNeeded,
                                      os_bit32 *dmaMemoryPtrAlign,
                                      os_bit32 *dmaMemoryPhyAlign,
                                      os_bit32 *nvMemoryNeeded,
                                      os_bit32 *usecsPerTick
                                    )
{
    *cachedMemoryNeeded   = FWStub_cachedMemoryNeeded;
    *cachedMemoryPtrAlign = FWStub_cachedMemoryPtrAlign;
    *dmaMemoryNeeded      = FWStub_dmaMemoryNeeded;
    *dmaMemoryPtrAlign    = FWStub_dmaMemoryPtrAlign;
    *dmaMemoryPhyAlign    = FWStub_dmaMemoryPhyAlign;
    *nvMemoryNeeded       = FWStub_nvMemoryNeeded;
    *usecsPerTick         = FWStub_usecsPerTick;

    return fcInitializeSuccess;
}

/*+

   Function: fcInterruptHandler()

    Purpose: This function is called from the OS Layer's Interrupt Service Routine in response to
             some PCI device raising an interrupt.  The presumption by the FC Layer is that it is
             possible some thread is currently executing this instance of the driver.  Therefore,
             fcInterruptHandler() must be very cautious in accessing any data structure.  It is
             invalid to call osSingleThreadedEnter() (see Section 8.63 below) from this function.
             Any logic which must be executed requiring single threaded access must be deferred
             until the OS Layer can support a call to osSingleThreadedEnter().  A corresponding
             function, fcDelayedInterruptHandler(), is provided for this case.  If
             fcInterruptHandler() determines that it's chip (TachyonTL, in this case) is raising
             the interrupt, it should mask off the interrupt and return agTRUE.  If the Fibre Channel
             chip is not the source of the interrupt, no further action is required and agFALSE is
             returned.  Note that fcDelayedInterruptHandler() will only be called if agTRUE is returned.

             It is possible for a card to generate interrupts prior to the driver being initialized.
             Should these interrupts get routed to the OS Layer prior to fcInitializeChannel() being
             called, the OS Layer will provide an agRoot with a agNULL fcData field.  In this special
             case, the FC Layer should simply mask the interrupt from the card (using
             osChipConfigRead/WriteBitXXX() function calls) and return agFALSE (indicating that
             fcDelayedInterruptHandler() need not be called at this time to service the extraneous
             interrupt).

             For the FWStub FC Layer, the Outbound FIFO is read or the corresponding Interrupt Bit
             in the Intel 21554 Bridge is checked for message arrival.

  Called By: <unknown OS Layer functions>

      Calls: osChipMemReadBit32()
             osChipMemWriteBit32()

-*/

osGLOBAL agBOOLEAN fcInterruptHandler(
                                       agRoot_t *agRoot
                                     )
{
#ifdef FWStub_Tune_for_One_INT_per_IO
    if ( (FWStub_Global_NonDMA(agRoot)->agRpcOutbound = FWStub_FetchOutbound(
                                                                              agRoot
                                                                            )       ) != 0xFFFFFFFF )
#else  /* FWStub_Tune_for_One_INT_per_IO was not defined */
    if (osChipMemReadBit32(
                            agRoot,
                            agFieldOffset(
                                           I21554_CSR_t,
                                           I2O_Outbound_Post_List_Status
                                         )
                          ) & I21554_CSR_I2O_Outbound_Post_List_Status_Not_Empty)
#endif /* FWStub_Tune_for_One_INT_per_IO was not defined */
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                           );

        return agTRUE;
    }
    else
    {
        return agFALSE;
    }
}

/*+

   Function: fcIOInfoReadBit8()

    Purpose: This function is called to read an 8-bit value from the I/O Info referred to by an
             agIORequest_t.  The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host memory
             or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when part of
             the I/O Info wraps around to the beginning of the Single Frame Queue for TachyonXL2).

             For the FWStub FC Layer, the Response Frame is located and the requested 8-bit value
             extracted and returned.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit8 fcIOInfoReadBit8(
                                   agRoot_t      *agRoot,
                                   agIORequest_t *agIORequest,
                                   os_bit32       fcIOInfoOffset
                                 )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit8            *IOInfo_DMA;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = &(IO_NonDMA->DMA->Info[fcIOInfoOffset]);

    return *IOInfo_DMA;
}

/*+

   Function: fcIOInfoReadBit16()

    Purpose: This function is called to read a 16-bit value from the I/O Info referred to by an
             agIORequest_t. The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host memory
             or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when part of
             the I/O Info wraps around to the beginning of the Single Frame Queue for TachyonXL2).
             Finally, it is assumed that the 2-byte value is read from a 2-byte aligned offset using
             a 2-byte access.

             For the FWStub FC Layer, the Response Frame is located and the requested 16-bit value
             extracted and returned.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit16 fcIOInfoReadBit16(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit16           *IOInfo_DMA;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = (os_bit16 *)(&(IO_NonDMA->DMA->Info[fcIOInfoOffset]));

    return *IOInfo_DMA;
}

/*+

   Function: fcIOInfoReadBit32()

    Purpose: This function is called to read a 32-bit value from the I/O Info referred to by an
             agIORequest_t. The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host
             memory or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when
             part of the I/O Info wraps around to the beginning of the Single Frame Queue for
             TachyonXL2).  Finally, it is assumed that the 4-byte value is read from a 4-byte
             aligned offset using a 4-byte access.

             For the FWStub FC Layer, the Response Frame is located and the requested 32-bit value
             extracted and returned.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit32 fcIOInfoReadBit32(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit32           *IOInfo_DMA;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = (os_bit32 *)(&(IO_NonDMA->DMA->Info[fcIOInfoOffset]));

    return *IOInfo_DMA;
}

/*+

   Function: fcIOInfoReadBlock()

    Purpose: This function is called to read a block of data from the I/O Info referred to by an
             agIORequest_t. The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host memory
             or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when part of
             the I/O Info wraps around to the beginning of the Single Frame Queue for TachyonXL2).

             For the FWStub FC Layer, the Response Frame is located and the requested block is copied
             into the specified buffer.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL void fcIOInfoReadBlock(
                                 agRoot_t      *agRoot,
                                 agIORequest_t *agIORequest,
                                 os_bit32       fcIOInfoOffset,
                                 void          *fcIOInfoBuffer,
                                 os_bit32       fcIOInfoBufLen
                               )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit8            *IOInfo_DMA;
    os_bit8            *IOInfo_DMA_Destination = (os_bit8 *)fcIOInfoBuffer;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = &(IO_NonDMA->DMA->Info[fcIOInfoOffset]);

    while (fcIOInfoBufLen-- > 0)
    {
        *IOInfo_DMA_Destination++ = *IOInfo_DMA++;
    }

    return;
}

/*+

   Function: fcLeavingOS()

    Purpose: This function is called to indicate to the FC Layer that it should prepare for the OS
             to switch (presumably between NetWare and BIOS).  Upon return from the "other OS", a
             corresponding call to fcEnteringOS() will be made.  It is assumed by the OS Layer that
             calling this function causes the FC Layer to stop participation on the Fibre Channel
             until fcEnteringOS() is called.  Further, no interrupts or other PCI bus accesses will
             be required by the card during this time.

             For the FWStub FC Layer, Interrupts are masked (regardless of whether they were
             currently enabled or not).

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcLeavingOS(
                           agRoot_t *agRoot
                         )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    osChipMemWriteBit32(
                         agRoot,
                         agFieldOffset(
                                        I21554_CSR_t,
                                        I2O_Outbound_Post_List_Interrupt_Mask
                                      ),
                         I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                       );

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcProcessInboundQ()

    Purpose: This function is called to instruct the FC Layer to process new elements added to the
             specified Work Queue pair's Inbound Queue.

             For the FWStub FC Layer, this function is not implemented.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

#ifdef _DvrArch_1_30_
osGLOBAL void fcProcessInboundQ(
                                 agRoot_t *agRoot,
                                 os_bit32  agQPairID
                               )
{
}
#endif /* _DvrArch_1_30_ was defined */

/*+

   Function: fcResetChannel()

    Purpose: This function is called to reset the Fibre Channel protocol chip and the channel
             (FC-AL Loop, in this case).  All outstanding I/Os pending on this channel will be
             completed with a status of osIODevReset passed to osIOCompleted().  It is possible
             to request that the reset be completed before returning (fcSyncReset) or
             asynchronously (fcAsyncReset) followed by a callback to osResetChannelCallback().
             In this case, a return (from this function) of fcResetSuccess simply means that a
             reset of the channel has begun and that the final status (the value
             osResetChannelCallback() ultimately returns) should be tested for success.  If this
             function returns fcResetFailure and fcAsyncReset was specified, no call to
             osResetChannelCallback() will be made.

             For the FWStub FC Layer, the synchronous behavior of the ResetChannel Request must
             be preserved.  Thus, the ResetChannel Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             FWStub_Poll_Response()
             osResetChannelCallback()
             osSingleThreadedLeave()

-*/

osGLOBAL os_bit32 fcResetChannel(
                                  agRoot_t *agRoot,
                                  os_bit32  agResetType
                                )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqResetChannel_t *ReqResetChannel_DMA;
    os_bit32                ReqResetChannel_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqResetChannel_DMA         = &(Global_DMA->Request.ReqResetChannel);
    ReqResetChannel_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                      FWStub_Global_DMA_t,
                                                                      Request.ReqResetChannel
                                                                    );

    ReqResetChannel_DMA->ReqType   = agRpcReqTypeResetChannel;
    ReqResetChannel_DMA->ChannelID = 0;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqResetChannel_t),
                                                      ReqResetChannel_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        To_Return = fcResetFailure;
    }
    else /* FWStub_Send_Request_RETURN == agTRUE */
    {
        RpcOutbound = FWStub_Poll_Response(
                                            agRoot,
                                            FWStub_Global_ReqID,
                                            agFALSE,
                                            FWStub_Poll_Response_RetryStall_DEFAULT
                                          );

        if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
             == agRpcReqStatusOK)
        {
            To_Return = fcResetSuccess;
        }
        else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
        {
            To_Return = fcResetFailure;
        }
    }

    if ( (agResetType & fcSyncAsyncResetMask) == fcAsyncReset )
    {
        osResetChannelCallback(
                                agRoot,
                                To_Return
                              );
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcResetDevice()

    Purpose: This function is called to perform a device reset.  All outstanding I/Os pending on
             this device will be completed with a status of osIODevReset passed to osIOCompleted().
             An option allows performing either a Soft Reset (fcSoftReset) or a Hard Reset
             (fcHardReset) of the device.  Also, it is possible to request that the reset be
             completed before returning (fcSyncReset) or asynchronously (fcAsyncReset) followed by
             a callback to osResetDeviceCallback().  In this case, a return (from this function)
             of fcResetSuccess simply means that a reset of the channel has begun and that the
             final status (the value osResetDeviceCallback() ultimately returns) should be tested
             for success.  If this function returns fcResetFailure and fcAsyncReset was specified,
             no call to osResetDeviceCallback() will be made.  Finally, it is possible to request
             that a reset be performed on every known device.  In this case, the status returned
             will indicate success only when all resets succeeded individually.

             For the FWStub FC Layer, the synchronous behavior of the ResetDevice Request must
             be preserved.  Thus, the ResetDevice Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             FWStub_Poll_Response()
             osResetDeviceCallback()
             osSingleThreadedLeave()

-*/

osGLOBAL os_bit32 fcResetDevice(
                                 agRoot_t  *agRoot,
                                 agFCDev_t  agFCDev,
                                 os_bit32   agResetType
                               )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqResetPort_t    *ReqResetPort_DMA;
    os_bit32                ReqResetPort_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqResetPort_DMA         = &(Global_DMA->Request.ReqResetPort);
    ReqResetPort_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                   FWStub_Global_DMA_t,
                                                                   Request.ReqResetPort
                                                                 );

    ReqResetPort_DMA->ReqType = agRpcReqTypeResetPort;
    ReqResetPort_DMA->PortID  = (agRpcPortID_t)agFCDev;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqResetPort_t),
                                                      ReqResetPort_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        To_Return = fcResetFailure;
    }
    else /* FWStub_Send_Request_RETURN == agTRUE */
    {
        RpcOutbound = FWStub_Poll_Response(
                                            agRoot,
                                            FWStub_Global_ReqID,
                                            agFALSE,
                                            FWStub_Poll_Response_RetryStall_DEFAULT
                                          );

        if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
             == agRpcReqStatusOK)
        {
            To_Return = fcResetSuccess;
        }
        else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
        {
            To_Return = fcResetFailure;
        }
    }

    if ( (agResetType & fcSyncAsyncResetMask) == fcAsyncReset )
    {
        osResetDeviceCallback(
                               agRoot,
                               agFCDev,
                               To_Return
                             );
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcShutdownChannel()

    Purpose: This function is called to discontinue use of a particular channel.  Upon return, the
             card should not generate any interrupts or any other PCI accesses.  In addition, all
             host resources (i.e. both cached and non-cached memory) are no longer owned by the
             FC Layer.  Upon return, the state of the FC Layer (for this particular channel) is
             identical to the state just prior to the call to fcInitializeChannel().

             For the FWStub FC Layer, Interrupts are masked (regardless of whether they were
             currently enabled or not).

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcShutdownChannel(
                                 agRoot_t *agRoot
                               )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    osChipMemWriteBit32(
                         agRoot,
                         agFieldOffset(
                                        I21554_CSR_t,
                                        I2O_Outbound_Post_List_Interrupt_Mask
                                      ),
                         I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                       );

    agRoot->fcData = (void *)agNULL;

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcStartIO()

    Purpose: This function is called to initiate an I/O Request.  If there are sufficient resources
             to launch the request (assuming it is executable), fcIOStarted will be returned and the
             I/O will be initiated on the Fibre Channel.  If resources are not available, fcIOBusy
             will be returned and the OS Layer should try again later (perhaps when a prior I/O still
             outstanding completes freeing up resources).  Currently, only a CDB (SCSI-3) request is
             defined by passing the agCDBRequest_t variant of an agIORequestBody_t.

             For the FWStub FC Layer, the CDB Request is bundled up into a single message and sent
             to the Embedded Firmware via the Inbound FIFO of the Intel 21554 Bridge.  In Interrupts
             are currently disabled, fcStartIO() will poll for completion.  In either case, any
             messages which have arrived in the Outbound FIFO are processed immediately to avoid
             unnecessary calls to fcInterruptHandler()/fcDelayedInterruptHandler().

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osSingleThreadedLeave()
             osGetSGLChunk()
             FWStub_Send_Request()
             FWStub_Poll_Response()
             FWStub_Process_Response()

-*/

osGLOBAL os_bit32 fcStartIO(
                             agRoot_t          *agRoot,
                             agIORequest_t     *agIORequest,
                             agFCDev_t          agFCDev,
                             os_bit32           agRequestType,
                             agIORequestBody_t *agRequestBody
                           )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_IO_NonDMA_t     *IO_NonDMA;
    FWStub_IO_DMA_t        *IO_DMA;
    os_bit32                FCP_DL;
    os_bit32                FCP_RO                     = 0;
    os_bit32                SGL_Count                  = 0;
    agRpcSGL_t             *SGL_Slot;
    os_bit32                agChunkUpper32;
    os_bit32                agChunkLen;
    os_bit32                ReqLen;
#ifdef FWStub_Use_Fast_Path
#else /* FWStub_Use_Fast_Path was not defined */
    agBOOLEAN               FWStub_Send_Request_RETURN;
#endif /* FWStub_Use_Fast_Path was not defined */
    agRpcOutbound_t         RpcOutbound;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(agRoot);

    if ( (IO_NonDMA = Global_NonDMA->First_IO) == (FWStub_IO_NonDMA_t *)agNULL )
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return fcIOBusy;
    }

    Global_NonDMA->First_IO = IO_NonDMA->Next;

    IO_DMA = IO_NonDMA->DMA;

    IO_DMA->ReqDoSCSI.PortID   = (agRpcPortID_t)agFCDev;
    IO_DMA->ReqDoSCSI.FCP_CMND = *((FC_FCP_CMND_Payload_t *)(&(agRequestBody->CDBRequest.FcpCmnd)));

    FCP_DL =   (agRequestBody->CDBRequest.FcpCmnd.FcpDL[0] << 24)
             + (agRequestBody->CDBRequest.FcpCmnd.FcpDL[1] << 16)
             + (agRequestBody->CDBRequest.FcpCmnd.FcpDL[2] <<  8)
             + (agRequestBody->CDBRequest.FcpCmnd.FcpDL[3] <<  0);

    SGL_Slot = IO_NonDMA->SGL;

    while (    (FCP_RO    < FCP_DL)
            && (SGL_Count < FWStub_MaxSGL)
            && (osGetSGLChunk(
                               agRoot,
                               agIORequest,
                               FCP_RO,
                               &agChunkUpper32,
                               &(SGL_Slot->AddrLo),
                               &agChunkLen
                             ) == osSGLSuccess) )
    {
        SGL_Slot->Control = agChunkLen << agRpcSGL_Control_Len_SHIFT;

        FCP_RO    += agChunkLen;
        SGL_Count += 1;
        SGL_Slot  += 1;
    }

    if (FCP_RO != FCP_DL)
    {
        IO_NonDMA->Next         = Global_NonDMA->First_IO;
        Global_NonDMA->First_IO = IO_NonDMA;

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcIONoSupport;
    }

    IO_NonDMA->agIORequest = agIORequest;
    IO_NonDMA->Active      = agTRUE;

    agIORequest->fcData = (void *)IO_NonDMA;

    ReqLen =   sizeof(agRpcReqDoSCSI_t)
             - sizeof(agRpcSGL_t)
             + (   SGL_Count
                 * sizeof(agRpcSGL_t) );

#ifdef FWStub_Use_Fast_Path
    FWStub_PostInbound(
                        agRoot,
                        (   (IO_NonDMA->ReqID << agRpcInboundFast_ReqID_SHIFT)
                          | (ReqLen           << agRpcInboundFast_ReqLen_SHIFT) )
                      );
#else /* FWStub_Use_Fast_Path was not defined */
    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      IO_NonDMA->ReqID,
                                                      ReqLen,
                                                      IO_NonDMA->DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        IO_NonDMA->agIORequest = (agIORequest_t *)agNULL;
        IO_NonDMA->Active      = agFALSE;

        agIORequest->fcData = (void *)agNULL;

        IO_NonDMA->Next         = Global_NonDMA->First_IO;
        Global_NonDMA->First_IO = IO_NonDMA;

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcIOBusy;
    }
#endif /* FWStub_Use_Fast_Path was not defined */

    if (Global_NonDMA->sysIntsActive == agFALSE)
    {
        RpcOutbound = FWStub_Poll_Response(
                                            agRoot,
                                            IO_NonDMA->ReqID,
                                            agFALSE,
                                            FWStub_Poll_Response_RetryStall_DEFAULT
                                          );

        FWStub_Process_Response(
                                 agRoot,
                                 RpcOutbound
                               );
    }
#ifndef FWStub_Tune_for_One_INT_per_IO
    else /* Global_NonDMA->sysIntsActive == agTRUE */
    {
        while ( (RpcOutbound = FWStub_FetchOutbound(
                                                     agRoot
                                                   )       ) != 0xFFFFFFFF )
        {
            if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
            {
                /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

                FWStub_AckOutbound(
                                    agRoot
                                  );
            }

            FWStub_Process_Response(
                                     agRoot,
                                     RpcOutbound
                                   );
        }
    }
#endif /* FWStub_Tune_for_One_INT_per_IO was not defined */

    osSingleThreadedLeave(
                           agRoot
                         );

    return fcIOStarted;
}

/*+

   Function: fcSystemInterruptsActive()

    Purpose: This function is called to indicate to the FC Layer whether interrupts are available
             or not.  The parameter sysIntsActive indicates whether or not interrupts are available
             at this time.  Similarly, sysIntsActive, as passed to fcInitializeChannel(), specified
             if interrupts were available during channel initialization.  It is often the case that
             interrupts are not yet available during initialization.  In that case, sysIntsActive
             should be agFALSE in the call to fcInitializeChannel().  Initialization would then
             proceed using polling techniques as opposed to waiting for interrupts.  Later, when
             interrupts can be supported, fcSystemInterruptsActive() would be called with sysIntsActive
             set to agTRUE.
    
             For the FWStub FC Layer, the Interrupt corresponding to the Outbound FIFO of the Intel
             21554 Bridge is enabled or disabled based on the value of sysIntsActive argument.
    
  Called By: <unknown OS Layer function>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcSystemInterruptsActive(
                                        agRoot_t  *agRoot,
                                        agBOOLEAN  sysIntsActive
                                      )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(agRoot);

    if (Global_NonDMA->sysIntsActive != sysIntsActive)
    {
        if (sysIntsActive == agFALSE)
        {
            osChipMemWriteBit32(
                                 agRoot,
                                 agFieldOffset(
                                                I21554_CSR_t,
                                                I2O_Outbound_Post_List_Interrupt_Mask
                                              ),
                                 I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                               );

            Global_NonDMA->sysIntsActive = agFALSE;
        }
        else /* sysIntsActive == agTRUE */
        {
            Global_NonDMA->sysIntsActive = agTRUE;

            osChipMemWriteBit32(
                                 agRoot,
                                 agFieldOffset(
                                                I21554_CSR_t,
                                                I2O_Outbound_Post_List_Interrupt_Mask
                                              ),
                                 0
                               );
        }
    }

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcTimerTick()

    Purpose: This function is called periodically based on the number of microseconds ultimately
             specified in the fcInitializeChannel() usecsPerTick argument.  Presumably, this time
             tick is used to implement timed operations within the FC Layer.  Note that this
             function is only called if usecsPerTick was non-zero.  The OS Layer is required to
             call this function at a time when the FC Layer can call any function, particularly
             osSingleThreadedEnter().

             For the FWStub FC Layer, this function is currently not utilized.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcTimerTick(
                           agRoot_t *agRoot
                         )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*
 * Internal Functions
 */

/*+

   Function: FWStub_Send_Request()

    Purpose: Posts message to Inbound FIFO of Intel 21554 Bridge.

  Called By: fcAbortIO()
             fcGetChannelInfo()
             fcGetDeviceHandles()
             fcGetDeviceInfo()
             fcInitializeChannel()
             fcResetChannel()
             fcResetDevice()
             fcStartIO()

      Calls: osChipMemWriteBit32()
             osStallThread()

-*/

osLOCAL agBOOLEAN FWStub_Send_Request(
                                       agRoot_t     *agRoot,
                                       agRpcReqID_t  ReqID,
                                       os_bit32      ReqLen,
                                       os_bit32      ReqAddr_Lower32,
                                       os_bit32      Retries,
                                       os_bit32      RetryStall
                                     )
{
    os_bit32 Retry;
    os_bit32 RpcInbound_Offset;

    for(
         Retry = 0;
         Retry < Retries;
         Retry++
       )
    {
        if ( (RpcInbound_Offset = FWStub_AllocInbound(
                                                       agRoot
                                                     )       ) != 0xFFFFFFFF )
        {
            osChipMemWriteBit32(
                                 agRoot,
                                 (RpcInbound_Offset + agFieldOffset(
                                                                     agRpcInbound_t,
                                                                     ReqControl
                                                                   )                ),
                                 (   (ReqID  << agRpcInbound_ReqControl_ReqID_SHIFT)
                                   | (ReqLen << agRpcInbound_ReqControl_ReqLen_SHIFT) )
                               );

            osChipMemWriteBit32(
                                 agRoot,
                                 (RpcInbound_Offset + agFieldOffset(
                                                                     agRpcInbound_t,
                                                                     ReqAddrLo
                                                                   )                ),
                                 ReqAddr_Lower32
                               );

            FWStub_PostInbound(
                                agRoot,
                                RpcInbound_Offset
                              );

            return agTRUE;
        }

        osStallThread(
                       agRoot,
                       RetryStall
                     );
    }

    return agFALSE;
}

/*+

   Function: FWStub_Poll_Response()

    Purpose: Polls until the desired ReqID-tagged message arrives in the Outbound FIFO of
             the Intel 21554 Bridge.  Messages which arrive in the meantime (i.e. while
             polling for the desired ReqID) are also processed immediately.

  Called By: fcAbortIO()
             fcGetChannelInfo()
             fcGetDeviceHandles()
             fcGetDeviceInfo()
             fcInitializeChannel()
             fcResetChannel()
             fcResetDevice()
             fcStartIO()

      Calls: FWStub_Process_Response()
             osStallThread()

-*/

osLOCAL agRpcOutbound_t FWStub_Poll_Response(
                                              agRoot_t     *agRoot,
                                              agRpcReqID_t  ReqID,
                                              agBOOLEAN     DisposeOtherReqIDs,
                                              os_bit32      RetryStall
                                            )
{
    agRpcOutbound_t RpcOutbound;

    while(1)
    {
        if ( (RpcOutbound = FWStub_FetchOutbound(
                                                  agRoot
                                                )       ) != 0xFFFFFFFF )
        {
            if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
            {
                /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

                FWStub_AckOutbound(
                                    agRoot
                                  );
            }

            if (    ( (RpcOutbound & agRpcOutbound_ReqID_MASK) >> agRpcOutbound_ReqID_SHIFT )
                 == ReqID                                                                     )
            {
                return RpcOutbound;
            }
            else /* RpcOutbound[ReqID] != ReqID */
            {
                if (DisposeOtherReqIDs == agFALSE)
                {
                    FWStub_Process_Response(
                                             agRoot,
                                             RpcOutbound
                                           );
                }
            }
        }
        else /* RpcOutbound == 0xFFFFFFFF */
        {
            osStallThread(
                           agRoot,
                           RetryStall
                         );
        }
    }
}

/*+

   Function: FWStub_Process_Response()

    Purpose: Processes a message which has just arrived on the Outbound FIFO of the Intel 21554
             Bridge.  At this time, usually only CDB Completions are actually processed (all others
             having been synchronously processed prior to return from a FWStub_Poll_Response()
             call which polled awaiting a specific ReqID).  Hence, most messages result in a call
             to osIOCompleted().  The lone exception is the LinkUp message which is communicated
             to the OS Layer via a call to osFCLayerAsyncEvent().

  Called By: fcDelayedInterruptHandler()
             fcStartIO()
             FWStub_Poll_Response()

      Calls: osFCLayerAsyncEvent()
             osIOCompleted()

-*/

osLOCAL void FWStub_Process_Response(
                                      agRoot_t        *agRoot,
                                      agRpcOutbound_t  RpcOutbound
                                    )
{
    FWStub_Global_NonDMA_t  *Global_NonDMA;
    FWStub_IO_NonDMA_t      *IO_NonDMA;
    agIORequest_t           *agIORequest;
    agRpcReqStatus_t         IO_Status;
    agFcpRspHdr_t           *IO_Response_Hdr;
    FC_FCP_RSP_FCP_STATUS_t *IO_Response_Status;
    os_bit32                 IO_Info_Len;

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusLinkEvent                                                           )
    {
        osFCLayerAsyncEvent(
                             agRoot,
                             osFCLinkUp
                           );

        return;
    }

    Global_NonDMA = FWStub_Global_NonDMA(agRoot);

    IO_NonDMA = FWStub_IO_NonDMA(
                                  Global_NonDMA,
                                  ( (RpcOutbound & agRpcOutbound_ReqID_MASK) >> agRpcOutbound_ReqID_SHIFT )
                                );

    agIORequest = IO_NonDMA->agIORequest;

    if (IO_NonDMA->Aborted == agFALSE)
    {
        IO_Status = ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT );

        if (IO_Status == agRpcReqStatusOK)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOSuccess,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusOK_Info)
        {
            IO_Response_Hdr = (agFcpRspHdr_t *)(IO_NonDMA->Info);

            IO_Response_Status = (FC_FCP_RSP_FCP_STATUS_t *)(IO_Response_Hdr->FcpStatus);

            IO_Info_Len = sizeof(agFcpRspHdr_t);

            if (IO_Response_Status->ValidityStatusIndicators & FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_SNS_LEN_VALID)
            {
                IO_Info_Len +=   (IO_Response_Hdr->FcpSnsLen[0] << 24)
                               + (IO_Response_Hdr->FcpSnsLen[1] << 16)
                               + (IO_Response_Hdr->FcpSnsLen[2] <<  8)
                               + (IO_Response_Hdr->FcpSnsLen[3] <<  0);
            }

            if (IO_Response_Status->ValidityStatusIndicators & FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RSP_LEN_VALID)
            {
                IO_Info_Len +=   (IO_Response_Hdr->FcpRspLen[0] << 24)
                               + (IO_Response_Hdr->FcpRspLen[1] << 16)
                               + (IO_Response_Hdr->FcpRspLen[2] <<  8)
                               + (IO_Response_Hdr->FcpRspLen[3] <<  0);
            }

            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOSuccess,
                           IO_Info_Len
                         );
        }
        else if (IO_Status == agRpcReqStatusIOPortGone)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIODevGone,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusIOPortReset)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIODevReset,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusIOInfoBad)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOInfoBad,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusIOOverUnder)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOOverUnder,
                           0
                         );
        }
        else /* IO_Status == ?? */
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOFailed,
                           0
                         );
        }
    }
    else /* IO_NonDMA->Aborted == agTRUE */
    {
        osIOCompleted(
                       agRoot,
                       agIORequest,
                       osIOAborted,
                       0
                     );

        IO_NonDMA->Aborted = agFALSE;
    }

    IO_NonDMA->agIORequest = (agIORequest_t *)agNULL;
    IO_NonDMA->Active      = agFALSE;

    agIORequest->fcData = (void *)agNULL;

    IO_NonDMA->Next         = Global_NonDMA->First_IO;
    Global_NonDMA->First_IO = IO_NonDMA;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\hbaapi.h ===
/**********************************************************************************

   hbaapi.h

   Author:        Benjamin F. Kuo, Troika Networks Inc.
   Description:   Header file for the SNIA HBA API Proposal
   Version:       0.8
   
   Changes:       03/09/2000 Initial Draft
                  05/12/2000 Updated to Version 0.3 of Proposal   
				  06/20/2000 Updated to Version 0.6 of Proposal
				  06/27/2000 Updated to Version 0.7 of Proposal
				  07/17/2000 Updated to Version 0.8 of Proposal
				  07/26/2000 Updated to Version 0.9 of Proposal
				  08/01/2000 Updated to Version 1.0 of Proposal
				  08/19/2000 Updated to Version 1.0A of Proposal
				  09/12/2000 1.0 Final

***********************************************************************************/


#ifdef __cplusplus
extern "C" {
#endif


#ifndef HBA_API_H
#define HBA_API_H

/* Library version string */
#define HBA_LIBVERSION 1

/* DLL imports for WIN32 operation */
#ifdef WIN32
#ifdef HBAAPI_EXPORTS
#define HBA_API __declspec(dllexport)
#else
#define HBA_API __declspec(dllimport)
#endif
#else
#define HBA_API
#endif

/* OS specific definitions */

#ifdef WIN32
typedef unsigned char    HBA_UINT8;	   // Unsigned  8 bits
typedef          char    HBA_INT8;      // Signed    8 bits
typedef unsigned short   HBA_UINT16;	   // Unsigned 16 bits
typedef          short   HBA_INT16;	   // Signed   16 bits
typedef unsigned int     HBA_UINT32;    // Unsigned 32 bits
typedef          int     HBA_INT32;     // Signed   32 bits
typedef void*            HBA_PVOID;     // Pointer  to void
typedef HBA_UINT32   HBA_VOID32;    // Opaque   32 bits


#ifdef _WIN32

typedef 		 _int64		HBA_INT64;
typedef 		 _int64		HBA_UINT64;
#else
typedef struct {
	TN_UINT32	lo_val;
	TN_UINT32	hi_val;
} HBA_INT64;

typedef struct {
	TN_UINT32	lo_val;
	TN_UINT32	hi_val;
} HBA_UINT64;
#endif	/*	#ifdef _WIN32	*/


#else

/* Note this section needs to be cleaned up for various Unix platforms */
typedef unsigned char    HBA_UINT8;	   /* Unsigned  8 bits */
typedef          char    HBA_INT8;      /* Signed    8 bits */
typedef unsigned short   HBA_UINT16;	   /* Unsigned 16 bits */
typedef          short   HBA_INT16;	   /* Signed   16 bits */
typedef unsigned int     HBA_UINT32;    /*Unsigned 32 bits */
typedef          int     HBA_INT32;     /* Signed   32 bits */
typedef void*            HBA_PVOID;     /* Pointer  to void */
typedef HBA_UINT32   HBA_VOID32;    /* Opaque   32 bits */
typedef long long   HBA_INT64;
typedef long long   HBA_UINT64;

#endif  /*  #ifdef WIN32 */


/* 4.2.1	Handle to Device */
typedef HBA_UINT32  HBA_HANDLE;

/* 4.2.2	Status Return Values */
typedef HBA_UINT32 HBA_STATUS;

#define HBA_STATUS_OK        				0
#define HBA_STATUS_ERROR 					1   /* Error */
#define HBA_STATUS_ERROR_NOT_SUPPORTED    	2   /* Function not supported.*/
#define HBA_STATUS_ERROR_INVALID_HANDLE		3   /* invalid handle */
#define HBA_STATUS_ERROR_ARG      	 		4   /* Bad argument */
#define HBA_STATUS_ERROR_ILLEGAL_WWN       	5   /* WWN not recognized */
#define HBA_STATUS_ERROR_ILLEGAL_INDEX		6   /* Index not recognized */
#define HBA_STATUS_ERROR_MORE_DATA			7   /* Larger buffer required */



/* 4.2.3	Port Operational Modes Values */

typedef HBA_UINT32 HBA_PORTTYPE; 		

#define HBA_PORTTYPE_UNKNOWN        	1 /* Unknown */
#define HBA_PORTTYPE_OTHER              2 /* Other */
#define HBA_PORTTYPE_NOTPRESENT         3 /* Not present */
#define HBA_PORTTYPE_NPORT          	5 /* Fabric  */
#define HBA_PORTTYPE_NLPORT 			6 /* Public Loop */
#define HBA_PORTTYPE_FLPORT				7
#define HBA_PORTTYPE_FPORT	           	8 /* Fabric Port */
#define HBA_PORTTYPE_EPORT				9 /* Fabric expansion port */
#define HBA_PORTTYPE_GPORT				10 /* Generic Fabric Port */
#define HBA_PORTTYPE_LPORT          	20 /* Private Loop */
#define HBA_PORTTYPE_PTP  				21 /* Point to Point */


typedef HBA_UINT32 HBA_PORTSTATE; 		
#define HBA_PORTSTATE_UNKNOWN 			1 /* Unknown */
#define HBA_PORTSTATE_ONLINE			2 /* Operational */
#define HBA_PORTSTATE_OFFLINE 			3 /* User Offline */
#define HBA_PORTSTATE_BYPASSED          4 /* Bypassed */
#define HBA_PORTSTATE_DIAGNOSTICS       5 /* In diagnostics mode */
#define HBA_PORTSTATE_LINKDOWN 			6 /* Link Down */
#define HBA_PORTSTATE_ERROR 			7 /* Port Error */
#define HBA_PORTSTATE_LOOPBACK 			8 /* Loopback */


typedef HBA_UINT32 HBA_PORTSPEED;
#define HBA_PORTSPEED_1GBIT				1 /* 1 GBit/sec */
#define HBA_PORTSPEED_2GBIT				2 /* 2 GBit/sec */
#define HBA_PORTSPEED_10GBIT			4 /* 10 GBit/sec */



/* 4.2.4	Class of Service Values - See GS-2 Spec.*/

typedef HBA_UINT32 HBA_COS;


/* 4.2.5	Fc4Types Values */

typedef struct HBA_fc4types {
	HBA_UINT8 bits[32]; /* 32 bytes of FC-4 per GS-2 */
} HBA_FC4TYPES, *PHBA_FC4TYPES;

/* 4.2.6	Basic Types */

typedef struct HBA_wwn {
	HBA_UINT8 wwn[8];
} HBA_WWN, *PHBA_WWN;

typedef struct HBA_ipaddress {
	int	ipversion;		/* see enumerations in RNID */
	union
	{
		unsigned char ipv4address[4];
		unsigned char ipv6address[16];
	} ipaddress;
} HBA_IPADDRESS, *PHBA_IPADDRESS;

/* 4.2.7	Adapter Attributes */
typedef struct hba_AdapterAttributes {
	char 			Manufacturer[64];  		/*Emulex */
	char 			SerialNumber[64];  		/* A12345 */
	char 			Model[256];            	/* QLA2200 */
    char 			ModelDescription[256];  /* Agilent TachLite */
	HBA_WWN 		NodeWWN; 
	char 			NodeSymbolicName[256];	/* From GS-3 */
	char 			HardwareVersion[256];	/* Vendor use */
	char 			DriverVersion[256]; 	/* Vendor use */
    char 			OptionROMVersion[256]; 	/* Vendor use  - i.e. hardware boot ROM*/
	char 			FirmwareVersion[256];	/* Vendor use */
	HBA_UINT32 		VendorSpecificID;		/* Vendor specific */
    HBA_UINT32 		NumberOfPorts;
	char			DriverName[256];		/* Binary path and/or name of driver file. */
} HBA_ADAPTERATTRIBUTES, *PHBA_ADAPTERATTRIBUTES;

/* 4.2.8	Port Attributes */
typedef struct HBA_PortAttributes {
    HBA_WWN 		NodeWWN;
	HBA_WWN 		PortWWN;
	HBA_UINT32 		PortFcId;
	HBA_PORTTYPE 	PortType; 		/*PTP, Fabric, etc. */
	HBA_PORTSTATE 	PortState;
	HBA_COS 		PortSupportedClassofService;
	HBA_FC4TYPES	PortSupportedFc4Types;
	HBA_FC4TYPES	PortActiveFc4Types;
	char			PortSymbolicName[256];
	char 			OSDeviceName[256]; 	/* \device\ScsiPort3  */
    HBA_PORTSPEED	PortSupportedSpeed;
	HBA_PORTSPEED	PortSpeed; 
	HBA_UINT32		PortMaxFrameSize;
	HBA_WWN			FabricName;
	HBA_UINT32		NumberofDiscoveredPorts;
} HBA_PORTATTRIBUTES, *PHBA_PORTATTRIBUTES;



/* 4.2.9	Port Statistics */

typedef struct HBA_PortStatistics {
	HBA_INT64		SecondsSinceLastReset;
	HBA_INT64		TxFrames;
	HBA_INT64		TxWords;
   	HBA_INT64		RxFrames;
   	HBA_INT64		RxWords;
	HBA_INT64		LIPCount;
	HBA_INT64		NOSCount;
	HBA_INT64		ErrorFrames;
	HBA_INT64		DumpedFrames;
	HBA_INT64		LinkFailureCount;
	HBA_INT64		LossOfSyncCount;
	HBA_INT64		LossOfSignalCount;
	HBA_INT64		PrimitiveSeqProtocolErrCount;
	HBA_INT64		InvalidTxWordCount;
	HBA_INT64		InvalidCRCCount;
} HBA_PORTSTATISTICS, *PHBA_PORTSTATISTICS;



/* 4.2.10	FCP Attributes */

typedef enum HBA_fcpbindingtype { TO_D_ID, TO_WWN } HBA_FCPBINDINGTYPE;

typedef struct HBA_ScsiId {
	char 			OSDeviceName[256]; 	/* \device\ScsiPort3  */
	HBA_UINT32		ScsiBusNumber;		/* Bus on the HBA */
	HBA_UINT32		ScsiTargetNumber;	/* SCSI Target ID to OS */
	HBA_UINT32		ScsiOSLun;	
} HBA_SCSIID, *PHBA_SCSIID;

typedef struct HBA_FcpId {
	HBA_UINT32 		FcId;
	HBA_WWN			NodeWWN;
	HBA_WWN			PortWWN;
	HBA_UINT64		FcpLun;
} HBA_FCPID, *PHBA_FCPID;

typedef struct HBA_FcpScsiEntry {
	HBA_SCSIID 		ScsiId;
	HBA_FCPID		FcpId;
} HBA_FCPSCSIENTRY, *PHBA_FCPSCSIENTRY;

typedef struct HBA_FCPTargetMapping {
	HBA_UINT32			NumberOfEntries;
	HBA_FCPSCSIENTRY 	entry[1];  	/* Variable length array containing mappings*/
} HBA_FCPTARGETMAPPING, *PHBA_FCPTARGETMAPPING;

typedef struct HBA_FCPBindingEntry {
	HBA_FCPBINDINGTYPE	type;
	HBA_SCSIID		ScsiId;
	HBA_FCPID		FcpId;	/* WWN valid only if type is to WWN, FcpLun always valid */
	HBA_UINT32		FcId;	/* Used only if type is to DID */
} HBA_FCPBINDINGENTRY, *PHBA_FCPBINDINGENTRY;

typedef struct HBA_FCPBinding {
	HBA_UINT32						NumberOfEntries;
	HBA_FCPBINDINGENTRY	entry[1]; /* Variable length array */
} HBA_FCPBINDING, *PHBA_FCPBINDING;

/* 4.2.11	FC-3 Management Atrributes */

typedef enum HBA_wwntype { NODE_WWN, PORT_WWN } HBA_WWNTYPE;

typedef struct HBA_MgmtInfo {
	HBA_WWN 			wwn;
	HBA_UINT32 			unittype;
	HBA_UINT32 			PortId;
	HBA_UINT32 			NumberOfAttachedNodes;
	HBA_UINT16 			IPVersion;
	HBA_UINT16 			UDPPort;
	HBA_UINT8			IPAddress[16];
	HBA_UINT16			reserved;
	HBA_UINT16 			TopologyDiscoveryFlags;
} HBA_MGMTINFO, *PHBA_MGMTINFO;

#define HBA_EVENT_LIP_OCCURRED			1
#define HBA_EVENT_LINK_UP				2
#define HBA_EVENT_LINK_DOWN			3
#define HBA_EVENT_LIP_RESET_OCCURRED		4
#define HBA_EVENT_RSCN				5
#define HBA_EVENT_PROPRIETARY                    	     0xFFFF

typedef struct HBA_Link_EventInfo {
	HBA_UINT32 PortFcId; 	/* Port which this event occurred */
	HBA_UINT32 Reserved[3];
} HBA_LINK_EVENTINFO, *PHBA_LINK_EVENTINFO;

typedef struct HBA_RSCN_EventInfo {
	HBA_UINT32 PortFcId; 	/* Port which this event occurred */
	HBA_UINT32 NPortPage;   /* Reference FC-FS for  RSCN ELS "Affected N-Port Pages"*/
	HBA_UINT32 Reserved[2];
} HBA_RSCN_EVENTINFO, *PHBA_RSCN_EVENTINFO;

typedef struct HBA_Pty_EventInfo {
	HBA_UINT32 PtyData[4];  /* Proprietary data */
} HBA_PTY_EVENTINFO, *PHBA_PTY_EVENTINFO;

typedef struct HBA_EventInfo {
	HBA_UINT32 EventCode;
	union {
	HBA_LINK_EVENTINFO Link_EventInfo;
	HBA_RSCN_EVENTINFO RSCN_EventInfo;
	HBA_PTY_EVENTINFO Pty_EventInfo;
	} Event;
} HBA_EVENTINFO, *PHBA_EVENTINFO;



/* 4.2.12 HBA Library Function Table */

typedef HBA_UINT32  ( * HBAGetVersionFunc)();
typedef HBA_STATUS  ( * HBALoadLibraryFunc)();
typedef HBA_STATUS  ( * HBAFreeLibraryFunc)();
typedef HBA_UINT32  ( * HBAGetNumberOfAdaptersFunc)();
typedef HBA_STATUS  ( * HBAGetAdapterNameFunc)(HBA_UINT32, char*);
typedef HBA_HANDLE 	( * HBAOpenAdapterFunc)(char*);
typedef void	  	( * HBACloseAdapterFunc)(HBA_HANDLE);
typedef HBA_STATUS	( * HBAGetAdapterAttributesFunc)(HBA_HANDLE, PHBA_ADAPTERATTRIBUTES);
typedef HBA_STATUS 	( * HBAGetAdapterPortAttributesFunc)(HBA_HANDLE, HBA_UINT32, PHBA_PORTATTRIBUTES);
typedef HBA_STATUS 	( * HBAGetPortStatisticsFunc)(HBA_HANDLE, HBA_UINT32, PHBA_PORTSTATISTICS);
typedef HBA_STATUS	( * HBAGetDiscoveredPortAttributesFunc)(HBA_HANDLE, HBA_UINT32, HBA_UINT32, PHBA_PORTATTRIBUTES);
typedef HBA_STATUS 	( * HBAGetPortAttributesByWWNFunc)(HBA_HANDLE, HBA_WWN, PHBA_PORTATTRIBUTES);
typedef HBA_STATUS 	( * HBASendCTPassThruFunc)(HBA_HANDLE, void *,  HBA_UINT32,  void *,  HBA_UINT32);
typedef void	 	( * HBARefreshInformationFunc)(HBA_HANDLE);
typedef void	   	( * HBAResetStatisticsFunc)(HBA_HANDLE, HBA_UINT32);
typedef HBA_STATUS 	( * HBAGetFcpTargetMappingFunc) (HBA_HANDLE, PHBA_FCPTARGETMAPPING );
typedef HBA_STATUS 	( * HBAGetFcpPersistentBindingFunc) (HBA_HANDLE, PHBA_FCPBINDING );
typedef HBA_STATUS 	(* HBAGetEventBufferFunc)(HBA_HANDLE, PHBA_EVENTINFO, HBA_UINT32 *);
typedef HBA_STATUS 	(* HBASetRNIDMgmtInfoFunc) (HBA_HANDLE, PHBA_MGMTINFO);
typedef HBA_STATUS 	(* HBAGetRNIDMgmtInfoFunc)(HBA_HANDLE, PHBA_MGMTINFO);
typedef HBA_STATUS 	(* HBASendRNIDFunc) (HBA_HANDLE, HBA_WWN, HBA_WWNTYPE, void *, HBA_UINT32 *);
typedef HBA_STATUS 	(* HBASendScsiInquiryFunc) (HBA_HANDLE,HBA_WWN,HBA_UINT64,HBA_UINT8, HBA_UINT32, void *, HBA_UINT32,void *,HBA_UINT32 );
typedef HBA_STATUS 	(* HBASendReportLUNsFunc) (HBA_HANDLE,	HBA_WWN,void *, HBA_UINT32,void *,HBA_UINT32 );
typedef HBA_STATUS 	(* HBASendReadCapacityFunc) (HBA_HANDLE, HBA_WWN,HBA_UINT64,	void *, HBA_UINT32,void *,HBA_UINT32);


typedef struct HBA_EntryPoints {
	HBAGetVersionFunc						GetVersionHandler;
	HBALoadLibraryFunc                      LoadLibraryHandler;
	HBAFreeLibraryFunc                      FreeLibraryHandler;
	HBAGetNumberOfAdaptersFunc				GetNumberOfAdaptersHandler;
	HBAGetAdapterNameFunc					GetAdapterNameHandler;
	HBAOpenAdapterFunc						OpenAdapterHandler;
	HBACloseAdapterFunc						CloseAdapterHandler;
	HBAGetAdapterAttributesFunc				GetAdapterAttributesHandler;
	HBAGetAdapterPortAttributesFunc			GetAdapterPortAttributesHandler;
	HBAGetPortStatisticsFunc				GetPortStatisticsHandler;
	HBAGetDiscoveredPortAttributesFunc		GetDiscoveredPortAttributesHandler;
	HBAGetPortAttributesByWWNFunc			GetPortAttributesByWWNHandler;
	HBASendCTPassThruFunc					SendCTPassThruHandler;
	HBARefreshInformationFunc				RefreshInformationHandler;
	HBAResetStatisticsFunc					ResetStatisticsHandler;
	HBAGetFcpTargetMappingFunc				GetFcpTargetMappingHandler;
	HBAGetFcpPersistentBindingFunc			GetFcpPersistentBindingHandler;
	HBAGetEventBufferFunc					GetEventBufferHandler;
	HBASetRNIDMgmtInfoFunc					SetRNIDMgmtInfoHandler;
	HBAGetRNIDMgmtInfoFunc					GetRNIDMgmtInfoHandler;
	HBASendRNIDFunc							SendRNIDHandler;
	HBASendScsiInquiryFunc					ScsiInquiryHandler;
	HBASendReportLUNsFunc					ReportLUNsHandler;
	HBASendReadCapacityFunc					ReadCapacityHandler;
} HBA_ENTRYPOINTS, *PHBA_ENTRYPOINTS;

/* Function Prototypes */

HBA_API HBA_UINT32 HBA_GetVersion();

HBA_API HBA_STATUS HBA_LoadLibrary();

HBA_API HBA_STATUS HBA_FreeLibrary();

HBA_API HBA_UINT32 HBA_GetNumberOfAdapters();

HBA_API HBA_STATUS HBA_GetAdapterName(HBA_UINT32 adapterindex, char *adaptername);

HBA_API HBA_HANDLE HBA_OpenAdapter(
	char* adaptername
	);

HBA_API void HBA_CloseAdapter(
	HBA_HANDLE handle
	);

HBA_API HBA_STATUS HBA_GetAdapterAttributes(
	HBA_HANDLE handle, 
	HBA_ADAPTERATTRIBUTES *hbaattributes	
	);

HBA_API HBA_STATUS HBA_GetAdapterPortAttributes(
	HBA_HANDLE handle, 
	HBA_UINT32 portindex,
	HBA_PORTATTRIBUTES *portattributes
	);

HBA_API HBA_STATUS HBA_GetPortStatistics(
	HBA_HANDLE				handle,
	HBA_UINT32				portindex,
	HBA_PORTSTATISTICS			*portstatistics
	);

HBA_API HBA_STATUS HBA_GetDiscoveredPortAttributes(
	HBA_HANDLE handle, 
	HBA_UINT32 portindex,
	HBA_UINT32 discoveredportindex,
	HBA_PORTATTRIBUTES *portattributes
	);

HBA_API HBA_STATUS HBA_GetPortAttributesByWWN(
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_PORTATTRIBUTES *portattributes
	);

HBA_API HBA_STATUS HBA_SendCTPassThru(
	HBA_HANDLE handle, 
	void * pReqBuffer,
	HBA_UINT32 ReqBufferSize,
	void * pRspBuffer,  
	HBA_UINT32 RspBufferSize
	);


HBA_API HBA_STATUS HBA_GetEventBuffer(
	HBA_HANDLE handle, 
	PHBA_EVENTINFO EventBuffer, 
	HBA_UINT32 *EventBufferCount);

HBA_API HBA_STATUS HBA_SetRNIDMgmtInfo(
	HBA_HANDLE handle, 
	HBA_MGMTINFO *pInfo);

HBA_API HBA_STATUS HBA_GetRNIDMgmtInfo(
	HBA_HANDLE handle, 
	HBA_MGMTINFO *pInfo);
	
HBA_API HBA_STATUS HBA_SendRNID(
	HBA_HANDLE handle,
	HBA_WWN wwn,
	HBA_WWNTYPE wwntype,
	void * pRspBuffer,
	HBA_UINT32 *RspBufferSize
	);

HBA_API void HBA_RefreshInformation(
	HBA_HANDLE handle);

HBA_API void HBA_ResetStatistics(
	HBA_HANDLE handle,
	HBA_UINT32 portindex
	);

HBA_API HBA_STATUS HBA_GetFcpTargetMapping(
	HBA_HANDLE handle, 
	PHBA_FCPTARGETMAPPING mapping
	);

HBA_API HBA_STATUS HBA_GetFcpPersistentBinding(
	HBA_HANDLE handle, 
	PHBA_FCPBINDING binding
	);

HBA_API HBA_STATUS HBA_SendScsiInquiry (	
	HBA_HANDLE handle,	
	HBA_WWN PortWWN, 
	HBA_UINT64 fcLUN, 
	HBA_UINT8 EVPD, 
	HBA_UINT32 PageCode, 
	void * pRspBuffer, 
	HBA_UINT32 RspBufferSize, 
	void * pSenseBuffer, 
	HBA_UINT32 SenseBufferSize
	);

HBA_API HBA_STATUS HBA_SendReportLUNs (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	void * pRspBuffer, 
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
	);

HBA_API HBA_STATUS HBA_SendReadCapacity (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	HBA_UINT64 fcLUN,
	void * pRspBuffer, 
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
	);



#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\hotplug4.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   HotPlug4.c

Abstract:

   This is the miniport driver for the Agilent
   PCI to Fibre Channel Host Bus Adapter (HBA). 
   
   This module is specific to the NT 4.0 PCI Hot Plug feature 
   support routines. The PCI Hot Plug implementation is based 
   on Compaq PCI HoT Plug implementation.

Authors:
   Ie Wei Njoo
 
Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/C/HotPlug4.c $

Revision History:

   $Revision: 4 $
   $Date: 10/23/00 5:45p $
   $Modtime::  $

Notes:

--*/

#include "buildop.h"        //LP021100 build switches

#if defined(HP_PCI_HOT_PLUG)

#include "osflags.h"
#include "TLStruct.H"
#include "HotPlug4.h"    // PCI Hot-Plug header file

VOID
RcmcSendEvent(
   IN PCARD_EXTENSION pCard,
   IN OUT PHR_EVENT pEvent
   )
/*++

Routine Description:

   Handles event reporting to PCI Hot Plug rcmc service.
    
Arguments:

   pCard   - Pointer to adapter storage area.
   pEvent  - Pointer to event log record.

Return Value:

   None.

--*/

{
  
   if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
   {
      if (pCard->rcmcData.healthCallback) 
      {
         if (!pEvent->ulEventId) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\t!ulEventId! - assume HR_DD_STATUS_CHANGE_EVENT\n"));
            pEvent->ulEventId = HR_DD_STATUS_CHANGE_EVENT;
         }

         if (!pEvent->ulData1) 
         {
            osDEBUGPRINT( (ALWAYS_PRINT, "\t!ulData1 - assume CBS_HBA_STATUS_NORMAL\n"));
            pEvent->ulData1 = CBS_HBA_STATUS_NORMAL;
         }

         pEvent->ulSenderId = pCard->rcmcData.driverId; 
         pEvent->ulData2 = (ULONG) pCard->IoLBase;
         osDEBUGPRINT( (ALWAYS_PRINT,
            "\tulEventId: %x\tulSenderId: %x\tulData1: %x\tulData2: %x\n",
            pEvent->ulEventId,
            pEvent->ulSenderId,
            pEvent->ulData1,
            pEvent->ulData2));

         pCard->rcmcData.healthCallback (pEvent);
      }
      
      else
         osDEBUGPRINT((ALWAYS_PRINT, "\tRcmcSendEvent: CallBack address is NULL!\n"));
   }
   else
      osDEBUGPRINT((ALWAYS_PRINT, "\tRcmcSendEvent: Service not available!\n"));
}


PCARD_EXTENSION FindExtByPort(
   PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
   ULONG port
   ) 
/*++

 Routine Description:

   Support routine for Hot-Plug PCI. Find the pCard extension
   for the corresponding port address.

 Arguments:

   pPseudoExtension - Pointer to pseudo adapter storage area.
   port - port address of the HBA.

 Return Value:

   pCard - pointer to the actual pCard.

--*/
{
    UCHAR i;
    PCARD_EXTENSION pCard;

    pCard = 0;
  
    if (port) 
    {
        for (i = 1; i <= pPsuedoExtension->extensions[0]; i++) 
        {
            pCard = (PCARD_EXTENSION) pPsuedoExtension->extensions[i];
            if(port == (ULONG)pCard->IoLBase)
                break;
            else
                pCard = 0;
        }
    }
    return pCard;
}


ULONG
HppProcessIoctl(
   IN PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
   PVOID pIoctlBuffer,
   IN PSCSI_REQUEST_BLOCK pSrb
   )

/*++

 Routine Description:

   This is routine is called by PseudoStartIo to handle controller
   IOCTLs specific for the support of Hot-Plug PCI

 Arguments:

   pPseudoExtension - Pointer to adapter storage area.
   pIoctlBuffer - Pointer to INOUT IOCTL data buffer.
   pSrb - Pointer to the request to be processed.

 Return Value:

   status - status of IOCTL request (COMPLETED, PENDING, INVALID)

--*/

{
   ULONG status;
   PIOCTL_TEMPLATE pHppIoctl = pIoctlBuffer;
   PCARD_EXTENSION pCard;
   UCHAR i;

   //
   // Set status here so that exceptions need only be handled later
   //

   pHppIoctl->Header.ReturnCode = IOS_HPP_SUCCESS;
   status = IOP_HPP_COMPLETED;

   //
   // Act according to request.
   //

   switch(pHppIoctl->Header.ControlCode) 
   {
      case IOC_HPP_RCMC_INFO: 
      {     // 0x1
         PHPP_RCMC_INFO pRcmcInfo;     // Pointer to Hot Plug RCMC info record
         HR_EVENT event;

         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO:\n"));
         //
         // Verify that indicated buffer length is adequate
         //    
         if (pHppIoctl->Header.Length < sizeof(HPP_RCMC_INFO)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_RCMC_INFO)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         } 
         pRcmcInfo = (PHPP_RCMC_INFO) pHppIoctl->ReturnData;
         //
         // Locate pointer to associated device extension from pool
         //
         pCard = FindExtByPort(pPsuedoExtension, pRcmcInfo->sControllerID.ulIOBaseAddress);
         
         //
         // Did we find the targeted extension?
         //
         
         if (pCard) 
         {
            switch (pRcmcInfo->eServiceStatus) 
            {
            case HPRS_SERVICE_STARTING:
               osDEBUGPRINT((ALWAYS_PRINT, "\tHPRS_SERVICE_STARTING\n"));
               //
               // Verify that Hot Plug unique driver id is supplied.
               //
               if (pRcmcInfo->ulDriverID) 
               {
                  //
                  // Verify that Hot Plug Health driver call-back address was provided.
                  //
                  if (pRcmcInfo->vpCallbackAddress) 
                  {
                     //
                     // Record service data in device extension.
                     //
                     pCard->stateFlags |= PCS_HPP_SERVICE_READY;
                     pCard->rcmcData.driverId = pRcmcInfo->ulDriverID;
                     pCard->rcmcData.healthCallback = pRcmcInfo->vpCallbackAddress;
                     pCard->rcmcData.slot = (UCHAR) pRcmcInfo->ulPhysicalSlot;
                     pCard->rcmcData.controllerChassis = pRcmcInfo->ulCntrlChassis;                  
                  }
                  else  // Call back address not given.
                     pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CALLBACK;
               }
               else 
               {     // No id, no Hot Plug service...
                  osDEBUGPRINT((ALWAYS_PRINT, "\tIOS_HPP_INVALID_CONTROLLER\n"));
                  pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
               }
               break;

            case HPRS_SERVICE_STOPPING:
               osDEBUGPRINT((ALWAYS_PRINT, "\tHPRS_SERVICE_STOPPING\n"));
               if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
               {
                  //
                  // Assume that service had been up...
                  //
                  pCard->rcmcData.driverId = 0;
                  pCard->stateFlags &= ~PCS_HPP_SERVICE_READY;
                  pCard->rcmcData.healthCallback = 0;
                  pCard->stateFlags &= ~PCS_HPP_HOT_PLUG_SLOT;
               }
               else 
               {
                  osDEBUGPRINT((ALWAYS_PRINT, "\tIOS_HPP_NO_SERVICE\n"));
                  pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_SERVICE_STATUS; 
               }
               break;
         
            default:
               osDEBUGPRINT((ALWAYS_PRINT, "\tUnknown case status: %x\n",
                  pRcmcInfo->eServiceStatus)); 
               pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_SERVICE_STATUS;
            } // end switch on service status  
         } // end if (pCard) 
         else 
         {  // Invalid IO address extension not valid
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO: Invalid controller: %x\n",
               pRcmcInfo->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
         
         break;
      } // end case IOC_HPP_RCMC_INFO:


      case IOC_HPP_HBA_INFO: 
      {     // 0x03, used to be 0x2
         PHPP_CTRL_INFO pHbaInfo;      // Pointer to HBA info record.
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_HBA_INFO:\n"));
      
         //
         // Verify that indicated buffer length is adequate.
         //
         if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_INFO)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_CTRL_INFO)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }  
         pHbaInfo = (PHPP_CTRL_INFO) pHppIoctl->ReturnData;
      
         //
         // Locate pointer to associated device extension from pool.
         //
         pCard = FindExtByPort(pPsuedoExtension, pHbaInfo->sControllerID.ulIOBaseAddress);
      
         //
         // Did we find the targeted extension?
         //
      
         if (pCard) 
         {
            pHbaInfo->eSupportClass = HPSC_MINIPORT_STORAGE;
            pHbaInfo->ulSupportVersion = HPP_VERSION;
      
            pHbaInfo->sController.eBusType = HPPBT_PCI_BUS_TYPE;
            pHbaInfo->sController.sPciDescriptor.ucBusNumber = (UCHAR)pCard->SystemIoBusNumber;
            pHbaInfo->sController.sPciDescriptor.fcDeviceNumber = (UCHAR)pCard->SlotNumber;
            pHbaInfo->sController.sPciDescriptor.fcFunctionNumber = 0;
            pHbaInfo->sController.ulSlotNumber = 0;
      
            pHbaInfo->sController.ulProductID = 
               *((PULONG)(((PUCHAR)pCard->pciConfigData) + 0));      // Use PCI DeviceID and VendorID
      
            osStringCopy(pHbaInfo->sController.szControllerDesc, 
               HBA_DESCRIPTION, HPPStrLen(HBA_DESCRIPTION));
      
            pHbaInfo->sController.asCtrlAddress[0].fValid = TRUE;
            pHbaInfo->sController.asCtrlAddress[0].eAddrType = HPPAT_IO_ADDR;
            pHbaInfo->sController.asCtrlAddress[0].ulStart = (ULONG) pCard->IoLBase;
            pHbaInfo->sController.asCtrlAddress[0].ulLength = pCard->rcmcData.accessRangeLength[0];
      
            pHbaInfo->sController.asCtrlAddress[1].fValid = TRUE;
            pHbaInfo->sController.asCtrlAddress[1].eAddrType = HPPAT_IO_ADDR;
            pHbaInfo->sController.asCtrlAddress[1].ulStart = (ULONG) pCard->IoUpBase;
            pHbaInfo->sController.asCtrlAddress[1].ulLength = pCard->rcmcData.accessRangeLength[1];
      
            pHbaInfo->sController.asCtrlAddress[2].fValid = TRUE;
            pHbaInfo->sController.asCtrlAddress[2].eAddrType = HPPAT_MEM_ADDR;
            pHbaInfo->sController.asCtrlAddress[2].ulStart = (ULONG) pCard->MemIoBase;
            pHbaInfo->sController.asCtrlAddress[2].ulLength = pCard->rcmcData.accessRangeLength[2];
            
            pHbaInfo->sController.asCtrlAddress[3].fValid = FALSE;      // Default
            pHbaInfo->sController.asCtrlAddress[4].fValid = FALSE;      // Default
            if ( pCard->RamLength != 0)
            {
               pHbaInfo->sController.asCtrlAddress[3].fValid = TRUE;
               pHbaInfo->sController.asCtrlAddress[3].eAddrType = HPPAT_MEM_ADDR;
               pHbaInfo->sController.asCtrlAddress[3].ulStart = (ULONG)pCard->RamBase;
               pHbaInfo->sController.asCtrlAddress[3].ulLength = pCard->RamLength;
               if (pCard->RomLength !=0 )
               {
                  pHbaInfo->sController.asCtrlAddress[4].fValid = TRUE;
                  pHbaInfo->sController.asCtrlAddress[4].eAddrType = HPPAT_MEM_ADDR;
                  pHbaInfo->sController.asCtrlAddress[4].ulStart = (ULONG) pCard->RomBase;
                  pHbaInfo->sController.asCtrlAddress[4].ulLength = pCard->RomLength;
               }
            }
            else 
               if ( pCard->RomLength != 0)
               {
                  pHbaInfo->sController.asCtrlAddress[3].fValid = TRUE;
                  pHbaInfo->sController.asCtrlAddress[3].eAddrType = HPPAT_MEM_ADDR;
                  pHbaInfo->sController.asCtrlAddress[3].ulStart = (ULONG) pCard->RomBase;
                  pHbaInfo->sController.asCtrlAddress[3].ulLength = pCard->RomLength;
               }
      
            pHbaInfo->sController.asCtrlAddress[5].fValid = FALSE;
         }
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_HBA_INFO: Invalid controller: %x\n",
               pHbaInfo->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
         }
   
         break;
      } // end case IOC_HPP_HBA_INFO
   
   
      case IOC_HPP_HBA_STATUS:  
      {     // 0x2, used to be 0x3
         PHPP_CTRL_STATUS pHbaStatus;
   
         //
         // Verify that indicated buffer length is adequate.
         //
         if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_STATUS)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_CTRL_STATUS)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pHbaStatus = (PHPP_CTRL_STATUS) pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pHbaStatus->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            pHbaStatus->ulStatus = pCard->stateFlags;
   //       osDEBUGPRINT((ALWAYS_PRINT, "\tstateFlags: %x\n", pCard->stateFlags));
         }
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO: Invalid controller: %x\n",
               pHbaStatus->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
         }
         break;
      } // end case IOC_HPP_HBA_STATUS
   
   
      case IOC_HPP_SLOT_TYPE:  
      {     // 0x4
         PHPP_CTRL_SLOT_TYPE pSlotType;
   
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_SLOT_TYPE\n"));
   
         if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_SLOT_TYPE)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_CTRL_SLOT_TYPE)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pSlotType = (PHPP_CTRL_SLOT_TYPE) pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pSlotType->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\teSlotType: %x\n", pSlotType->eSlotType));
   
            if (pSlotType->eSlotType == HPPST_HOTPLUG_PCI_SLOT) 
            {
               pCard->stateFlags |= PCS_HPP_HOT_PLUG_SLOT;
            }
            else 
            {
               osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_SLOT_TYPE: Reset HOT_PLUG_SLOT\n"));
               pCard->stateFlags &= ~PCS_HPP_HOT_PLUG_SLOT; 
            }
         } // end if (pCard) 
   
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO: Invalid controller: %x\n",
               pSlotType->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
         break;
      } // end case IOC_HPP_SLOT_TYPE
   
   
      case IOC_HPP_SLOT_EVENT: 
      {     // 0x6
         PHPP_SLOT_EVENT            pSlotEvent;
         HR_EVENT rcmcEvent =    {0,0,0,0};
         BOOLEAN rcmcEventFlag =    FALSE;
   
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_SLOT_EVENT:  "));
   
         // Verify that indicated buffer length is adequate.
   
         if (pHppIoctl->Header.Length < sizeof(HPP_SLOT_EVENT)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_SLOT_EVENT)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pSlotEvent = (PHPP_SLOT_EVENT) pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pSlotEvent->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
            {
               osDEBUGPRINT((ALWAYS_PRINT, "\tPCS_HPP_SERVICE_READY.\n"));
   
               if (pCard->stateFlags & PCS_HPP_HOT_PLUG_SLOT) 
               {
                  osDEBUGPRINT((ALWAYS_PRINT, "\tPCS_HPP_HOT_PLUG_SLOT.\n"));
   
                  switch (pSlotEvent->eSlotStatus) 
                  {
                  case HPPSS_NORMAL_OPERATION:
   
                     if ((pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE) ||
                        (pCard->stateFlags & PCS_HPP_POWER_DOWN)) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
                     }
                     else 
                     {
                        osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_NORMAL_OPERATION\n"));
                        //
                        // Let timer init controller and report results to Hot Plug rcmc.
                        //
                        osDEBUGPRINT((ALWAYS_PRINT, "\tUNFAIL Flags Set\n"));
                        PCS_SET_UNFAIL(pCard->stateFlags);
                        pCard->controlFlags |= LCS_HPP_POWER_UP; 
                     }
                     break;
   
                  case HPPSS_SIMULATED_FAILURE:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_SIMULATED_FAILURE\n"));
                     if (pCard->stateFlags & PCS_HBA_FAILED) 
                     {
                        osDEBUGPRINT((ALWAYS_PRINT, "\tSlot already failed\n"));
                     }
                     else if (pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
                     }
                     else if (pCard->stateFlags & PCS_HBA_EXPANDING) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_EXPANDING;
                     }
                     else 
                     {
                        // Change for TL code, ignore the PCS_HBA_CACHE_IN_USE flag.
                        HOLD_IO(pCard);
                        // Set to fail....
                        PCS_SET_USER_FAIL(pCard->stateFlags);
                        // Complete outstanding SP requests with reset status.
                        ScsiPortCompleteRequest(pCard,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SRB_STATUS_BUS_RESET);
   
                        pCard->controlFlags |= LCS_HBA_FAIL_ACTIVE;
                     }
   
                     break;
   
                  case HPPSS_POWER_FAULT: 
   
                     // Set state flags to power-fault
                     PCS_SET_PWR_FAULT(pCard->stateFlags);
                     // Let timer know about this....
                     pCard->controlFlags |= LCS_HPP_POWER_FAULT;
                     break;
   
                  case HPPSS_POWER_OFF_WARNING:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_OFF_WARNING\n"));
                     if (pCard->stateFlags & PCS_HBA_EXPANDING) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_EXPANDING;
                     }
                     else if (pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
                     }
                     else if (!(pCard->stateFlags & PCS_HPP_POWER_DOWN)) 
                     {
                        // Change for TL code, ignore PCS_HBA_CACHE_IN_USE.
                        HOLD_IO(pCard);
                        // Set physical flags to stall io at the active controller.
                        PCS_SET_PWR_OFF(pCard->stateFlags);
                        // Complete outstanding SP requests with reset status.
                        ScsiPortCompleteRequest(pCard,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SRB_STATUS_BUS_RESET);
   
                        // Set control flag to schedule timer based maintenance for
                        // the powered down controller.  
                        pCard->controlFlags |= LCS_HPP_POWER_DOWN;
                     
                        // The original SDK model disable the HBA interrupt 
                        // in HotPlugFailController in timer context.
                        // But it seems that this is the better place since
                        // the PCI power maight be turned off already by the time
                        // the timer kicks in.
   
                        //
                        // Shut down all interrupts on the adapter. 
                        //
                     #ifdef __REGISTERFORSHUTDOWN__
                     if (!pCard->AlreadyShutdown)
                        fcShutdownChannel(&pCard->hpRoot);
                     pCard->AlreadyShutdown++;
                     #else
                        fcShutdownChannel(&pCard->hpRoot);
                     #endif   
                        
                     }
                     break;
   
                  case HPPSS_POWER_OFF:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_OFF\n"));
   
                     // Verify that we received a prior power off warning.  If not, we
                     // are in fault state.
   
                     if (!(pCard->stateFlags & PCS_HPP_POWER_DOWN)) 
                     {
                        // This is a fault condition....  Schedule event.
                        osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_OFF: FAULT\n"));
                        PCS_SET_PWR_FAULT(pCard->stateFlags);
                        pCard->controlFlags |= LCS_HPP_POWER_FAULT;
                     } 
   
                     break;
   
                  case HPPSS_POWER_ON_WARNING:
   
                     // This warning is not needed or acted upon.
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_ON_WARNING\n"));
   
                     break;
   
                  case HPPSS_RESET:
                  case HPPSS_POWER_ON:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_ON:\n"));
   
                     // Complete outstanding SP requests with reset status.
                     ScsiPortCompleteRequest(pCard,
                        SP_UNTAGGED,
                        SP_UNTAGGED,
                        SP_UNTAGGED,
                        SRB_STATUS_BUS_RESET);
   
                     PCS_SET_UNFAIL(pCard->stateFlags);
                     PCS_SET_PWR_ON(pCard->stateFlags);
                     
                     // Reset Countdown for returning SRB_STATUS_BUSY in StartIo.
                     pCard->IoHeldRetTimer = 0; 
                     
                     // Set Logical Flag to schedule power-up operations...
                     pCard->controlFlags |= LCS_HPP_POWER_UP;
   
                     // Not able to guess results of power-on process, so event will
                     // be handled by timer.
   
                     break;
   
                  case HPPSS_RESET_WARNING:  // Not implemented by service
                     break;
   
                  default:
                     pHppIoctl->Header.ReturnCode = IOS_HPP_BAD_REQUEST;
                     break;
   
                  } // end switch (pSlotEvent->eSlotStatus)
   
               } // end if for hot-plug slot
   
               else 
               {        // Not hot-plug slot
                  osDEBUGPRINT((ALWAYS_PRINT, "\tNot Hot-Plug slot\n"));
                  pHppIoctl->Header.ReturnCode = IOS_HPP_NOT_HOTPLUGABLE; 
               }
   
            } // end if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
   
            else 
            {
               osDEBUGPRINT((ALWAYS_PRINT, "\tService not started\n"));
               pHppIoctl->Header.ReturnCode = IOS_HPP_NO_SERVICE; 
            }
   
         } // end if (pCard) 
   
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tInvalid IO address: %x\n",
               pSlotEvent->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
   
         if (rcmcEventFlag) 
         {
            RcmcSendEvent(pCard, &rcmcEvent);
         }
   
         break;
   
      } // end case IOC_HPP_SLOT_EVENT:
   
      case IOC_HPP_PCI_CONFIG_MAP: 
      {
         PHPP_PCI_CONFIG_MAP pPciConfig;
         ULONG j;
   
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_PCI_CONFIG_MAP.\n"));
         //
         // Verify that indicated buffer length is adequate.
         //
   
         if (pHppIoctl->Header.Length < sizeof(HPP_PCI_CONFIG_MAP)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_PCI_CONFIG_MAP)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pPciConfig = (PHPP_PCI_CONFIG_MAP) &pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pPciConfig->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            pPciConfig->ulPciConfigMapVersion = HPP_VERSION;
            pPciConfig->ulNumberOfPciDevices = 1;
   
            pPciConfig->sDeviceInfo[0].sPciDescriptor.ucBusNumber = (UCHAR)pCard->SystemIoBusNumber;
            pPciConfig->sDeviceInfo[0].sPciDescriptor.fcDeviceNumber = (UCHAR)pCard->SlotNumber;
            pPciConfig->sDeviceInfo[0].sPciDescriptor.fcFunctionNumber = 0;
            pPciConfig->sDeviceInfo[0].ucBaseAddrVerifyCount = pCard->rcmcData.numAccessRanges;
   
            // 
            // The pCard->rcmcData values are set in FindAdapter.C
            // 
   
            for (j = 0; j < pCard->rcmcData.numAccessRanges; j++) 
            {
               pPciConfig->sDeviceInfo[0].ulBaseAddrLength[j] = pCard->rcmcData.accessRangeLength[j];
            }
            
            // Adopted fron the Hot Plug SDK, may need to change ulNumberOfRanges value, 
            // this is not NUMBER_ACCESS_RANGES.
            //
            pPciConfig->sDeviceInfo[0].ulNumberOfRanges = 2;
            
            // These ranges are adopted from Hot Plug SDK, 
            // may need to change these values.
            //
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[0].ucStart = 6; 
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[0].ucEnd = 63;
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[1].ucStart = 4;
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[1].ucEnd = 5;
   
         } // end if (pCard) 
         
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tInvalid IO address: %x\n",
               pPciConfig->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
   
         break;
      }
   
      case IOC_HPP_DIAGNOSTICS:
      default:
         pHppIoctl->Header.ReturnCode = IOS_HPP_BAD_REQUEST;
         break;
   
   } // end switch
   
   return (status);
} // end HppProcessIoctl


BOOLEAN
PsuedoInit(
   IN PVOID pPsuedoExtension
   )

/*++

Routine Description:

    This function is called by the system during initialization to
    prepare the controller to receive requests.  In this case, we are
    dealing with a virtual controller that is utilized to receive and
    process side-band requests to all installed Hot Plug controllers.
   NT does not currently support IOCTL requests (other than INQ) 
   to controllers that do not posesse configured LUNS, so we introduced 
   the pseudo device to allow access to these adapters.

Arguments:

    pPsuedoExtension - Pointer to the psuedo device extension.

Return Value:

    TRUE

--*/

{
   ULONG i;
   PPSUEDO_DEVICE_EXTENSION pPsuedoExt = pPsuedoExtension;
   PCARD_EXTENSION pDevExt;

   osDEBUGPRINT((ALWAYS_PRINT,"PsuedoInit:Enter function...\n"));

   //
   // Set current Hot-Plug version.
   //

   pPsuedoExt->hotplugVersion = SUPPORT_VERSION_10;

   for (i = 1; i <= pPsuedoExt->extensions[0]; i++) 
   {
      pDevExt = (PCARD_EXTENSION) pPsuedoExt->extensions[i];
      pDevExt->pPsuedoExt = pPsuedoExt;
   }

   return TRUE;
} // end PsuedoInit()


BOOLEAN PsuedoStartIo(
   IN PVOID HwDeviceExtension,
   IN PSCSI_REQUEST_BLOCK pSrb
   )

/*++

  Routine Description:

  This routine is called by the system to start a request on the adapter.

  Arguments:

  HwDeviceExtension - Address of adapter storage area.
  pSrb - Address of the request to be started.

  Return Value:

  TRUE - The request has been started.
  FALSE - The controller was busy.

  --*/

{
   PPSUEDO_DEVICE_EXTENSION pPsuedoExtension = HwDeviceExtension;
   PLU_EXTENSION pLunExtension;
   ULONG i;
   ULONG tmp;
   UCHAR status;
   UCHAR tid = 0;

// osDEBUGPRINT((ALWAYS_PRINT, "PsuedoStartIo: Enter Routine:\n"));

   switch (pSrb->Function) 
   {
      case SRB_FUNCTION_RESET_BUS:
         status = SRB_STATUS_SUCCESS;
         break;

      case SRB_FUNCTION_EXECUTE_SCSI:
         switch (pSrb->Cdb[0]) 
         {
            case SCSIOP_TEST_UNIT_READY:
               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_TEST_UNIT_READY:\n"));
               status = SRB_STATUS_SUCCESS;
               break;

            case SCSIOP_READ_CAPACITY:
               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_TEST_UNIT_READY:\n"));
   
               //
               // Get logical unit extension.
               //
               pLunExtension = ScsiPortGetLogicalUnit(pPsuedoExtension,
                  pSrb->PathId,
                  pSrb->TargetId,
                  pSrb->Lun);

               if (pLunExtension) 
               {
                  ULONG blockSize = 0;
                  ULONG numberOfBlocks = 0;

                  //
                  // Get blocksize and number of blocks from identify data.
                  //
                  REVERSE_BYTES(
                     &((PREAD_CAPACITY_DATA) pSrb->DataBuffer)->BytesPerBlock,
                     &blockSize
                     );

                  REVERSE_BYTES(
                     &((PREAD_CAPACITY_DATA) pSrb->DataBuffer)->LogicalBlockAddress,
                     &numberOfBlocks);
                  status = SRB_STATUS_SUCCESS;
               }
               else 
               {
                  status = SRB_STATUS_ERROR;
               }

               break;

            case SCSIOP_INQUIRY:
               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_INQUIRY:\n"));
               osDEBUGPRINT((ALWAYS_PRINT, "\tLUN: %x  TID: %x\n", pSrb->Lun, pSrb->TargetId));

               //
               // Only respond at logical unit 0;
               //
               if (pSrb->Lun != 0) 
               {
                  //
                  // Indicate no device found at this address.
                  //
                  status = SRB_STATUS_SELECTION_TIMEOUT;
                  break;
               }

               //
               // Check if this is for one of the known controllers.
               //
               if (pSrb->TargetId >= 1) 
               {
                  //
                  // Indicate no device found at this address.
                  //
                  status = SRB_STATUS_SELECTION_TIMEOUT;
                  break;
               }

               //
               // Zero INQUIRY data structure.
               //
               for (i = 0; i < pSrb->DataTransferLength; i++) 
               {
                  ((PUCHAR) pSrb->DataBuffer)[i] = 0;
               }

               //
               // Set to funky device type to hide from windisk.
               //
               ((PINQUIRYDATA) pSrb->DataBuffer)->DeviceType = DEVICE_QUALIFIER_NOT_SUPPORTED;

               //
               // Fill in vendor identification fields.
               //
               tid = pSrb->TargetId + 0x30;

               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_INQUIRY: tid: %x lun: %c\n", pSrb->TargetId, tid));

               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[0] = 'H';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[1] = 'o';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[2] = 't';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[3] = 'P';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[4] = 'l';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[5] = 'u';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[6] = 'g';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[7] = ' ';

               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[0]  = 'P';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[1]  = 'S';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[2]  = 'E';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[3]  = 'U';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[4]  = 'D';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[5]  = 'O';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[6]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[7]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[8]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[9]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[10] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[11] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[12] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[13] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[14] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[15] = ' ';

               tmp = pPsuedoExtension->hotplugVersion;

               for (i = 0; i < 4; i++) 
               {
                  ((PINQUIRYDATA) pSrb->DataBuffer)->ProductRevisionLevel[i] = (UCHAR) tmp + 0x30;
                  tmp >>= 8;
               }

               status = SRB_STATUS_SUCCESS;
               break;

            case SCSIOP_VERIFY:

               //
               // Just return success.
               //
               status = SRB_STATUS_SUCCESS;
               break;

            default:
               osDEBUGPRINT((ALWAYS_PRINT, "\tpSrb->Cdb[0]: %x\n", pSrb->Cdb[0]));
               status = SRB_STATUS_INVALID_REQUEST;
               break;

         } // end switch (pSrb->Cdb[0])

      break;

      //
      // Issue FLUSH/DISABLE if shutdown command.
      //

      case SRB_FUNCTION_SHUTDOWN:
         osDEBUGPRINT((ALWAYS_PRINT, "\tSRB_FUNCTION_SHUTDOWN\n"));
         osDEBUGPRINT((ALWAYS_PRINT, "\tpPsuedoExtension: %x\n", pPsuedoExtension));
         status = SRB_STATUS_SUCCESS;
         break;

      case SRB_FUNCTION_FLUSH:
         //
         // Just return success.
         //
         status = SRB_STATUS_SUCCESS;
         break;

      case SRB_FUNCTION_IO_CONTROL: 
      {
         PIOCTL_TEMPLATE pIoctlBuffer;

//       osDEBUGPRINT((ALWAYS_PRINT, "\tSRB_FUNCTION_IO_CONTROL\n"));
         pIoctlBuffer = (PIOCTL_TEMPLATE) pSrb->DataBuffer;

         //
         // Status is returned mainly in 2 fields to the calling thread.
         // These 2 fields determine if other status fields are valid to
         // check. If the request is not a valid request for this driver
         // then the Header.ReturnCode is not modified and the
         // pSrb->SrbStatus is set to SRB_STATUS_INVALID_REQUEST.  If
         // the request is valid for this driver then pSrb->SrbStatus
         // is always returned as SRB_STATUS_SUCCESS and the
         // Header.ReturnCode contains information concerning the
         // status of the particular request.
         //

         if (osStringCompare(pIoctlBuffer->Header.Signature, CPQ_HPP_SIGNATURE)) 
         {
            if (HppProcessIoctl(pPsuedoExtension, pIoctlBuffer, pSrb) == IOP_HPP_ISSUED) 
            {
               status = SRB_STATUS_PENDING;
            }
            else 
            {
               status = SRB_STATUS_SUCCESS;
            }
         }
         else 
         {
            status = SRB_STATUS_INVALID_REQUEST;
         }

         break;
      }

      default:
         osDEBUGPRINT((ALWAYS_PRINT, "\tFunction: %x\n", pSrb->Function));
         status = SRB_STATUS_INVALID_REQUEST;

   } // end switch

   //
   // Indicate to system that the controller can take another request
   // for this device.
   //
   ScsiPortNotification(NextLuRequest,
      pPsuedoExtension,
      pSrb->PathId,
      pSrb->TargetId,
      pSrb->Lun);
   
   //
   // Check if SRB should be completed.
   //

   if (status != SRB_STATUS_PENDING) 
   {
      //
      // Set status in SRB.
      //
      pSrb->SrbStatus = status;

      //
      // Inform system that this request is complete.
      //
      ScsiPortNotification(RequestComplete,
         pPsuedoExtension,
         pSrb);
   }

   return TRUE;
  
}  // end PseudoStartIo()


ULONG
PsuedoFind(
   IN OUT PVOID pDeviceExtension,
   IN OUT PVOID pContext,
   IN PVOID pBusInformation,
   IN PCHAR pArgumentString,
   IN OUT PPORT_CONFIGURATION_INFORMATION pConfigInfo,
   OUT PBOOLEAN pAgain
   )

/*++

Routine Description:

   This routine is called by the SCSI port driver to find the
   controllers on the system's PCI buses.  The function fills out
   the controller's resource requirements in the port configuration
   information and begins the initialization process for the controller.


Arguments:

   pPseudoExtension - pointer to the miniport driver's per-controller
                      storage area
   pContext - pointer  to the context value passed to ScsiPortInitialize()
   pBusInformation - pointer to bus type specific information
   pArgumentString - pointer to null-terminated ASCII string
   pConfigInfo - pointer to SCSI port configuration information


Return Values:

   pPseudoExtension - Minport driver's per-controller storage area
   pContext - Context value passed to ScsiPortInitialize()
   pConfigInfo - pointer to SCSI port configuration information
   pAgain - Indicates to call function again to find more controllers.

   Function Return Values:

   SP_RETURN_FOUND - Indicates a host adapter was found and the configuration
                     information was successfully determined.

   SP_RETURN_ERROR - Indicates a host adapter was found but an error occurred
                     obtaining the configuration information.

   SP_RETURN_NOT_FOUND - Indicates no host adapter was found for the supplied
                         configuration information.

   SP_RETURN_BAD_CONFIG - Indicates the supplied configuration information
                          was invalid.

-- */

{
   PPSUEDO_DEVICE_EXTENSION pPsuedoExtension;
   PHOT_PLUG_CONTEXT pHotPlugContext = (PHOT_PLUG_CONTEXT) pContext;
   UCHAR i;

   UNREFERENCED_PARAMETER(pBusInformation);
   UNREFERENCED_PARAMETER(pArgumentString);

   pPsuedoExtension = (PPSUEDO_DEVICE_EXTENSION) pDeviceExtension;
   osDEBUGPRINT((ALWAYS_PRINT, "\nPsuedoFind:  Enter function...\n"));
   *pAgain = FALSE;

   //
   // We will be called once for every PCI bus found on the system....  
   // We want to return a device only once.
   //

   if (((PHOT_PLUG_CONTEXT) pContext)->psuedoDone)
      return (SP_RETURN_NOT_FOUND);

   //
   // Copy known logical device extensions to pseudo extension
   //
   for (i = 0; i <= pHotPlugContext->extensions[0]; i++)
      pPsuedoExtension->extensions[i] = pHotPlugContext->extensions[i];

   //
   // Now put psuedo extension at the end of the list
   //
   pPsuedoExtension->extensions[pHotPlugContext->extensions[0]+1] = (ULONG) pPsuedoExtension;

   //
   // Supply required device info
   //
   pConfigInfo->MaximumTransferLength = 0x400;
   pConfigInfo->NumberOfPhysicalBreaks = 0;
   pConfigInfo->NumberOfBuses = 1;
   pConfigInfo->ScatterGather = FALSE;
   pConfigInfo->Master = FALSE;
   pConfigInfo->Dma32BitAddresses = FALSE;
   pConfigInfo->MaximumNumberOfTargets = 1;
   pConfigInfo->CachesData = FALSE;
   pConfigInfo->InitiatorBusId[0] = (UCHAR) INITIATOR_BUS_ID;
   ((PHOT_PLUG_CONTEXT) pContext)->psuedoDone = TRUE;
   return (SP_RETURN_FOUND);

} // end PseudoFind()


BOOLEAN
PsuedoResetBus(
   IN PVOID HwDeviceExtension, 
   IN ULONG PathId 
   )

/*++

Routine Description:

   This routine resets the controller and completes outstanding requests.

Arguments:

   HwDeviceExtension - Address of adapter storage area.
   PathId - Indicates adapter to reset.

Return Value:

   TRUE

--*/

{
   osDEBUGPRINT((ALWAYS_PRINT, "PsuedoResetBus: Enter function...\n"));
   return TRUE;
}


VOID
HotPlugFailController(
   PCARD_EXTENSION pCard
   ) 

/*++

Routine Description:

   Fails active controller
    
Arguments:

   pCard  - Pointer to active controller device extension.

Return Value:

   Nothing

--*/

{
   agRoot_t * phpRoot = &pCard->hpRoot;
   HR_EVENT rcmcEvent = {0, 0, 0, 0 };

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugFailController: Enter\n"));

   // We need to actually disable the Tachyon TL HBA and 
   // Shut down all interrupts on the adapter.
   //

   fcShutdownChannel(phpRoot);

   //
   // Send event notification of failure with status corresponding to
   // physical_HBA status flags.
   //
   // Note:  if we are handling a simple power-off, the event sent will
   // indicate normal.  There are no currently defined messages for
   // power related issues.  For now....let's not send the normal case,
   // as the set Not Ready message will be removed in the Hot Plug UI.
   //
   
   rcmcEvent.ulEventId = HR_DD_STATUS_CHANGE_EVENT;
   RCMC_SET_STATUS(pCard->stateFlags, rcmcEvent.ulData1);

   //
   // It seems that the Intel version of Hot Plug software always 
   // requires event to be sent.
   //

// if (rcmcEvent.ulData1 != CBS_HBA_STATUS_NORMAL) 
// {
      // Send Hot Plug rcmc event.
      osDEBUGPRINT((ALWAYS_PRINT, "\tCall RcmcSendEvent\n"));
      RcmcSendEvent(pCard, &rcmcEvent);
// } 

   //
   // Clear fail control bit so the Timer will not call
   // this routine again.
   //

   osDEBUGPRINT((ALWAYS_PRINT, "\tClear FAIL_ACTIVE controlFlags\n"));
   pCard->controlFlags &= ~LCS_HBA_FAIL_ACTIVE;
   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugFailController: Exit\n"));

}


VOID
HotPlugInitController(
   PCARD_EXTENSION pCard
   )

/*++

Routine Description:

   Initializes controller 
    
Arguments:

   pCard  - Pointer to active controller device extension.

Return Value:

   Nothing

--*/

{
   agRoot_t * phpRoot = &pCard->hpRoot;
   ULONG   return_value;
   
   osDEBUGPRINT((ALWAYS_PRINT, "\tEnter HotPlugInitController Slot: %d\n", pCard->rcmcData.slot));

   // 
   // Re-Initilaize the HBA.
   //
   return_value = fcInitializeChannel(  phpRoot,
                                         fcSyncInit,
                                         agTRUE, // sysIntsActive
                                         pCard->cachedMemoryPtr,
                                         pCard->cachedMemoryNeeded,
                                         pCard->dmaMemoryUpper32,
                                         pCard->dmaMemoryLower32,
                                         pCard->dmaMemoryPtr,
                                         pCard->dmaMemoryNeeded,
                                         pCard->nvMemoryNeeded,
                                         pCard->cardRamUpper,
                                         pCard->cardRamLower,
                                         pCard->RamLength ,
                                         pCard->cardRomUpper,
                                         pCard->cardRomLower,
                                         pCard->RomLength,
                                         pCard->usecsPerTick );

   if (return_value != fcInitializeSuccess) 
   {
      // Re-initializing HBA failed.
      pCard->controlFlags |= LCS_HBA_FAIL_ACTIVE;     
      #ifdef _DEBUG_EVENTLOG_
      LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_INITIALIZECHANNELFAILED,
                  NULL, 
                  0, 
                  "%xx", return_value);
      #endif
      osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController: fcInitializeChannel FAILED error code : %x.\n", 
         return_value ));
   }
   else
   {
      // Re-initializing HBA successfull.
      osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController OK.\n"));
      // Clear LCS_HBA_INIT startup bit so Timer will not call again.
      osDEBUGPRINT((ALWAYS_PRINT, "\tClear LCS_HBA_INIT startup control\n"));
      pCard->controlFlags &= ~LCS_HBA_INIT;
   }

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController : Exit\n"));
   #ifdef _DEBUG_EVENTLOG_
   {
   LogHBAInformation(pCard);
   }
   #endif

}


VOID
HotPlugReadyController(
   PCARD_EXTENSION pCard
   )

/*++

Routine Description:

   Readies controller for system use
    
Arguments:

   pCard  - Pointer to active controller device extension.

Return Value:

   Nothing

--*/

{
   HR_EVENT rcmcEvent = {0,0,0,0};
   UCHAR    targetId;
   PLU_EXTENSION pLunExtension;

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugReadyController : Enter Slot %d\n", pCard->rcmcData.slot));

   ScsiPortCompleteRequest(pCard,
      SP_UNTAGGED,
      SP_UNTAGGED,
      SP_UNTAGGED,
      SRB_STATUS_BUS_RESET);

   //
   // Clear ready control bits, so the timer routine will not call again.
   //
   pCard->controlFlags &= ~LCS_HBA_READY_ACTIVE;

   //
   // Although Tachyon TL does not have cache, just enable the flag
   // to indicate that cache is safe to be enable.
   //

   // Commented out, avoid unnecessary complication.
   // pCard->stateFlags |= PCS_HBA_CACHE_IN_USE;

   pCard->stateFlags &= ~PCS_HBA_OFFLINE;

   osDEBUGPRINT((ALWAYS_PRINT, "\tNotify ready to port driver\n"));

   ScsiPortNotification(NextRequest, pCard, NULL);

   #ifndef YAM2_1
   for (targetId = 0; targetId < MAXIMUM_TID; targetId++) 
   #else
   for (targetId = 0; targetId < gMaximumTargetIDs; targetId++) 
   #endif
   {
      pLunExtension = ScsiPortGetLogicalUnit(pCard, 0, targetId, 0);
      if (pLunExtension) 
      {
         ScsiPortNotification(NextLuRequest, pCard, 0, targetId, 0); 
      }
   }

   // Send Hot Plug rcmc event. 
   rcmcEvent.ulEventId = HR_DD_STATUS_CHANGE_EVENT;
   RCMC_SET_STATUS(pCard->stateFlags, rcmcEvent.ulData1);
   RcmcSendEvent(pCard, &rcmcEvent);

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugReadyController : Exit\n"));

}


BOOLEAN
HotPlugTimer(
   PCARD_EXTENSION pCard
   )
/*++

Routine Description:

   Handles all Hot-Plug related state transitions and monitoring 
   responsibilities. This routine is called by the Timer routine.

Arguments:

   pCard - Address of adapter storage area.

Return Value:

   TRUE - PCI Hot Plug related activities were done.
   FALSE - No PCI Hot Plug task to do, normal operation.

--*/

{
   BOOLEAN  hotPlugTask = FALSE;
   ULONG controlFlags = pCard->controlFlags;
   ULONG stateFlags = pCard->stateFlags;

   if ( (pCard->stateFlags & PCS_HPP_POWER_DOWN) && !(pCard->stateFlags & PCS_HBA_FAILED) ) 
   {
      hotPlugTask = TRUE;
      osDEBUGPRINT((ALWAYS_PRINT, 
         "\nHotPlugTimer slot [%d] reports ResetDetected: IoHeldRetTimer = %d\n", 
         pCard->rcmcData.slot, pCard->IoHeldRetTimer ));
      
      // Increment countdown for returning SRB_STATUS_BUSY in StartIo.
      pCard->IoHeldRetTimer++;   
   
      //
      // This is different from the Hot Plug SDK, we only inform ResetDetected
      // if the PCI slot power is down.
      //
      ScsiPortNotification(ResetDetected, pCard, NULL);
   }  

   if (controlFlags & LCS_HBA_FAIL_ACTIVE) 
   {
      hotPlugTask = TRUE;
      osDEBUGPRINT((ALWAYS_PRINT, "\tTimer calling HotPlugFailController\n"));
      HotPlugFailController(pCard);
   }
   else 
      if (controlFlags & LCS_HBA_INIT) 
      {
         hotPlugTask = TRUE;
         osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController requested - Slot %d\n", pCard->rcmcData.slot));
         HotPlugInitController(pCard);
      }
      else 
         if (pCard->controlFlags & LCS_HBA_READY_ACTIVE) 
         {
            hotPlugTask = TRUE;
            osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugReadyController requested - Slot %d\n", pCard->rcmcData.slot));
            HotPlugReadyController(pCard);
         } 

   if ( hotPlugTask == TRUE)
      osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugTimer TRUE on Slot: %x in controlFlags: %x, out controlFlags: %x, stateFlags: %x\n",
         pCard->rcmcData.slot, controlFlags, pCard->controlFlags, pCard->stateFlags));

   return hotPlugTask;
  
} // end HotPlugTimer


ULONG
HPPStrLen(
   IN PUCHAR p
   ) 
/*++

Routine Description:

   This routine determines string length

Arguments:

   p - Pointer to string

Return Value:

   ULONG length - length of string

--*/
{
   PUCHAR tp = p;
   ULONG length = 0;

   while (*tp++)
      length++;

   return length;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\globals.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/Globals.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 3/20/01 3:32p   $ (Last Modified)

Purpose:

  This is the Master Include File for the Fibre Channel HBA Source Code.

  This file should be included by every module to ensure a uniform definition
  of all data types, data structures, and externals.

  This file includes six separate files:

    ..\..\OSLayer\H\OSTypes.H
        - defines basic data types in the OS-specific environment
    FCStruct.H
        - defines Fibre Channel Standards data types
    FmtFill.H
        - defines API of hpFmtFill()
    FcApi.H
        - allows FCLayer-specific overrides to its API
    ..\..\OSLayer\H\OsApi.H
        - allows OSLayer-specific overrides to its API
    FWSpec.H
        - defines API shared with Embedded Firmware implementations

--*/

#ifndef __Globals_H__

#define __Globals_H__

#ifdef _DvrArch_1_20_
/*
 * Include OSLayer-specific data types .H File
 *
 * This file must provide definitions for:
 *
 *    os_bit8   - unsigned 8-bit value
 *    os_bit16  - unsigned 16-bit value
 *    os_bit32  - unsigned 32-bit value
 *    os_bitptr - unsigned value identical in width to a pointer
 *    osGLOBAL  - used to declare a 'C' item external to a module
 *    osLOCAL   - used to declare a 'C' item local to a module
 */
#else  /* _DvrArch_1_20_ was not defined */
/*
 * Include OSLayer-specific data types .H File
 *
 * This file must provide definitions for:
 *
 *    bit8    - unsigned 8-bit value
 *    bit16   - unsigned 16-bit value
 *    bit32   - unsigned 32-bit value
 *    pbit8   - pointer to an unsigned 8-bit value
 *    pbit16  - pointer to an unsigned 16-bit value
 *    pbit32  - pointer to an unsigned 32-bit value
 *    NULL    - used to declare a wildcard pointer which is empty
 *    BOOLEAN - logical value (TRUE or FALSE)
 *    TRUE    - will always satisfy an <if> condition
 *    FALSE   - will never satisfy an <if> condition
 *    GLOBAL  - used to declare a 'C' function external to a module
 *    LOCAL   - used to declare a 'C' function local to a module
 */
#endif /* _DvrArch_1_20_ was not defined */
#ifndef _New_Header_file_Layout_

#include "../../oslayer/h/ostypes.h"
#else /* _New_Header_file_Layout_ */

#include "ostypes.h"
#endif  /* _New_Header_file_Layout_ */

/*
 * Include Fibre Channel Standards .H File
 */

#include "fcstruct.h"

/*
 * Define each Global Data Structure
 */

#ifdef _DvrArch_1_20_
#define agBOOLEAN os_bit32

#define agTRUE    (agBOOLEAN)1
#define agFALSE   (agBOOLEAN)0

#define agNULL    (void *)0
#endif /* _DvrArch_1_20_ was defined */

/* SNIA defines */

#ifndef HBA_API_H

#define HBA_PORTTYPE_UNKNOWN            1 /* Unknown */
#define HBA_PORTTYPE_OTHER              2 /* Other */
#define HBA_PORTTYPE_NOTPRESENT         3 /* Not present */
#define HBA_PORTTYPE_NPORT              5 /* Fabric  */
#define HBA_PORTTYPE_NLPORT             6 /* Public Loop */
#define HBA_PORTTYPE_FLPORT             7
#define HBA_PORTTYPE_FPORT              8 /* Fabric Port */
#define HBA_PORTTYPE_EPORT              9 /* Fabric expansion port */
#define HBA_PORTTYPE_GPORT              10 /* Generic Fabric Port */
#define HBA_PORTTYPE_LPORT              20 /* Private Loop */
#define HBA_PORTTYPE_PTP                21 /* Point to Point */


#define HBA_PORTSTATE_UNKNOWN           1 /* Unknown */
#define HBA_PORTSTATE_ONLINE            2 /* Operational */
#define HBA_PORTSTATE_OFFLINE           3 /* User Offline */
#define HBA_PORTSTATE_BYPASSED          4 /* Bypassed */
#define HBA_PORTSTATE_DIAGNOSTICS       5 /* In diagnostics mode */
#define HBA_PORTSTATE_LINKDOWN          6 /* Link Down */
#define HBA_PORTSTATE_ERROR             7 /* Port Error */
#define HBA_PORTSTATE_LOOPBACK          8 /* Loopback */


#define HBA_PORTSPEED_1GBIT             1 /* 1 GBit/sec */
#define HBA_PORTSPEED_2GBIT             2 /* 2 GBit/sec */
#define HBA_PORTSPEED_10GBIT            4 /* 10 GBit/sec */

#define HBA_EVENT_LIP_OCCURRED          1
#define HBA_EVENT_LINK_UP               2
#define HBA_EVENT_LINK_DOWN             3
#define HBA_EVENT_LIP_RESET_OCCURRED    4
#define HBA_EVENT_RSCN                  5
#define HBA_EVENT_PROPRIETARY           0xFFFF

/* End  SNIA defines */
#endif /* HBA_API_H */


#ifdef _DvrArch_1_20_
typedef struct agFCChanInfo_s
               agFCChanInfo_t;

struct agFCChanInfo_s
        {
            os_bit8                  NodeWWN[8];
            os_bit8                  PortWWN[8];
            struct
            {
                os_bit8 reserved;
                os_bit8 Domain;
                os_bit8 Area;
                os_bit8 AL_PA;
            }                        CurrentAddress;
            struct
            {
                os_bit8 reserved;
                os_bit8 Domain;
                os_bit8 Area;
                os_bit8 AL_PA;
            }                        HardAddress;
            agBOOLEAN                LinkUp;
            os_bit32                 MaxFrameSize;
            os_bit32                 ReadsRequested;
            os_bit32                 ReadsCompleted;
            os_bit32                 ReadFailures;
            os_bit32                 BytesReadUpper32;
            os_bit32                 BytesReadLower32;
            os_bit32                 WritesRequested;
            os_bit32                 WritesCompleted;
            os_bit32                 WriteFailures;
            os_bit32                 BytesWrittenUpper32;
            os_bit32                 BytesWrittenLower32;
            os_bit32                 NonRWRequested;
            os_bit32                 NonRWCompleted;
            os_bit32                 NonRWFailures;
            FC_N_Port_Common_Parms_t N_Port_Common_Parms;
            FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
            FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
            FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;

    /* SNIA port attributes */
            os_bit8                 FabricName[8];
            os_bit32                PortType;                       /*PTP, Fabric, etc. */
            os_bit32                PortState;
            os_bit32                PortSupportedClassofService;    /* Class of Service Values - See GS-2 Spec.*/
            os_bit8                 PortSupportedFc4Types[32];      /* 32 bytes of FC-4 per GS-2 */
            os_bit8                 PortActiveFc4Types[32];         /* 32 bytes of FC-4 per GS-2 */
            os_bit32                PortSupportedSpeed;
            os_bit32                PortSpeed;

    /* SNIA port statistics */
            os_bit32                TxFramesUpper;
            os_bit32                TxFramesLower;
            os_bit32                TxWordsUpper;
            os_bit32                TxWordsLower;
            os_bit32                RxFramesUpper;
            os_bit32                RxFramesLower;
            os_bit32                RxWordsUpper;
            os_bit32                RxWordsLower;
            os_bit32                LIPCountUpper;
            os_bit32                LIPCountLower;
            os_bit32                NOSCountUpper;
            os_bit32                NOSCountLower;
            os_bit32                ErrorFramesUpper;
            os_bit32                ErrorFramesLower;                   /* Link_Status_3_Exp_Frm Link_Status_2_Rx_EOFa */
            os_bit32                DumpedFramesUpper;
            os_bit32                DumpedFramesLower;                  /* Link_Status_2_Dis_Frm */
            os_bit32                LinkFailureCountUpper;
            os_bit32                LinkFailureCountLower;              /* Link_Status_1_Link_Fail */
            os_bit32                LossOfSyncCountUpper;
            os_bit32                LossOfSyncCountLower;               /* Link_Status_1_Loss_of_Sync */
            os_bit32                LossOfSignalCountUpper;
            os_bit32                LossOfSignalCountLower;             /* Link_Status_1_Loss_of_Signal */
            os_bit32                PrimitiveSeqProtocolErrCountUpper;
            os_bit32                PrimitiveSeqProtocolErrCountLower;  /* Link_Status_2_Proto_Err */
            os_bit32                InvalidRxWordCountUpper;
            os_bit32                InvalidRxWordCountLower;            /* Link_Status_1_Bad_RX_Char */
            os_bit32                InvalidCRCCountUpper;
            os_bit32                InvalidCRCCountLower;               /* Link_Status_2_Bad_CRC */

       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpFCChanInfo_s
               hpFCChanInfo_t;

struct hpFCChanInfo_s {
                        bit8                     NodeWWN[8];
                        bit8                     PortWWN[8];
                        struct {
                                 bit8 reserved;
                                 bit8 Domain;
                                 bit8 Area;
                                 bit8 AL_PA;
                               }                 CurrentAddress;
                        struct {
                                 bit8 reserved;
                                 bit8 Domain;
                                 bit8 Area;
                                 bit8 AL_PA;
                               }                 HardAddress;
                        BOOLEAN                  LinkUp;
                        bit32                    MaxFrameSize;
                        bit32                    ReadsRequested;
                        bit32                    ReadsCompleted;
                        bit32                    ReadFailures;
                        bit32                    BytesReadUpper32;
                        bit32                    BytesReadLower32;
                        bit32                    WritesRequested;
                        bit32                    WritesCompleted;
                        bit32                    WriteFailures;
                        bit32                    BytesWrittenUpper32;
                        bit32                    BytesWrittenLower32;
                        bit32                    NonRWRequested;
                        bit32                    NonRWCompleted;
                        bit32                    NonRWFailures;
                        FC_N_Port_Common_Parms_t N_Port_Common_Parms;
                        FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
                        FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
                        FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;
                      };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef void * agFCDev_t;
#else  /* _DvrArch_1_20_ was not defined */
typedef void * hpFCDev_t;
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agDevUnknown       0x00000000
#define agDevSelf          0x00000001
#define agDevSCSIInitiator 0x00000002
#define agDevSCSITarget    0x00000004

typedef struct agFCDevInfo_s
               agFCDevInfo_t;

struct agFCDevInfo_s
       {
         os_bit8                  NodeWWN[8];
         os_bit8                  PortWWN[8];
         struct
         {
           os_bit8 reserved;
           os_bit8 Domain;
           os_bit8 Area;
           os_bit8 AL_PA;
         }                        CurrentAddress;
         struct
         {
           os_bit8 reserved;
           os_bit8 Domain;
           os_bit8 Area;
           os_bit8 AL_PA;
         }                        HardAddress;
         agBOOLEAN                Present;
         agBOOLEAN                LoggedIn;
         os_bit32                 LoginRetries;
         os_bit32                 ClassOfService;
         os_bit32                 MaxFrameSize;
         os_bit32                 DeviceType;
         os_bit32                 ReadsRequested;
         os_bit32                 ReadsCompleted;
         os_bit32                 ReadFailures;
         os_bit32                 BytesReadUpper32;
         os_bit32                 BytesReadLower32;
         os_bit32                 WritesRequested;
         os_bit32                 WritesCompleted;
         os_bit32                 WriteFailures;
         os_bit32                 BytesWrittenUpper32;
         os_bit32                 BytesWrittenLower32;
         os_bit32                 NonRWRequested;
         os_bit32                 NonRWCompleted;
         os_bit32                 NonRWFailures;
         FC_N_Port_Common_Parms_t N_Port_Common_Parms;
         FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
         FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
         FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;
    /* SNIA port attributes */
         os_bit8                 FabricName[8];
         os_bit32                PortType;                       /*PTP, Fabric, etc. */
         os_bit32                PortState;
         os_bit32                PortSupportedClassofService;    /* Class of Service Values - See GS-2 Spec.*/
         os_bit8                 PortSupportedFc4Types[32];      /* 32 bytes of FC-4 per GS-2 */
         os_bit8                 PortActiveFc4Types[32];         /* 32 bytes of FC-4 per GS-2 */
         os_bit32                PortSupportedSpeed;
         os_bit32                PortSpeed;

       };
#else  /* _DvrArch_1_20_ was not defined */
#define hpDevUnknown       0x00000000
#define hpDevSelf          0x00000001
#define hpDevSCSIInitiator 0x00000002
#define hpDevSCSITarget    0x00000004

typedef struct hpFCDevInfo_s
               hpFCDevInfo_t;

struct hpFCDevInfo_s {
                       bit8                     NodeWWN[8];
                       bit8                     PortWWN[8];
                       struct {
                                bit8 reserved;
                                bit8 Domain;
                                bit8 Area;
                                bit8 AL_PA;
                              }                 CurrentAddress;
                       struct {
                                bit8 reserved;
                                bit8 Domain;
                                bit8 Area;
                                bit8 AL_PA;
                              }                 HardAddress;
                       BOOLEAN                  Present;
                       BOOLEAN                  LoggedIn;
                       bit32                    LoginRetries;
                       bit32                    ClassOfService;
                       bit32                    MaxFrameSize;
                       bit32                    DeviceType;
                       bit32                    ReadsRequested;
                       bit32                    ReadsCompleted;
                       bit32                    ReadFailures;
                       bit32                    BytesReadUpper32;
                       bit32                    BytesReadLower32;
                       bit32                    WritesRequested;
                       bit32                    WritesCompleted;
                       bit32                    WriteFailures;
                       bit32                    BytesWrittenUpper32;
                       bit32                    BytesWrittenLower32;
                       bit32                    NonRWRequested;
                       bit32                    NonRWCompleted;
                       bit32                    NonRWFailures;
                       FC_N_Port_Common_Parms_t N_Port_Common_Parms;
                       FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
                       FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
                       FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;
                     };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agFcpCntlReadData  0x02
#define agFcpCntlWriteData 0x01

typedef struct agFcpCmnd_s
               agFcpCmnd_t;

struct agFcpCmnd_s
       {
         os_bit8 FcpLun[8];
         os_bit8 FcpCntl[4];
         os_bit8 FcpCdb[16];
         os_bit8 FcpDL[4];
       };
#else  /* _DvrArch_1_20_ was not defined */

#define hpFcpCntlReadData        0x02
#define hpFcpCntlWriteData       0x01

typedef struct hpFcpCmnd_s
               hpFcpCmnd_t;

struct hpFcpCmnd_s {
                     bit8 FcpLun[8];
                     bit8 FcpCntl[4];
                     bit8 FcpCdb[16];
                     bit8 FcpDL[4];
                   };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agCDBRequest_s
               agCDBRequest_t;

struct agCDBRequest_s
       {
         agFcpCmnd_t FcpCmnd;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpCDBRequest_s
               hpCDBRequest_t;

struct hpCDBRequest_s {
                        hpFcpCmnd_t FcpCmnd;
                      };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agFcpRspHdr_s
               agFcpRspHdr_t;

struct agFcpRspHdr_s
       {
         os_bit32 FrameHeader[8];
         os_bit8  reserved[8];
         os_bit8  FcpStatus[4];
         os_bit8  FcpResId[4];
         os_bit8  FcpSnsLen[4];
         os_bit8  FcpRspLen[4];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpFcpRspHdr_s
               hpFcpRspHdr_t;

struct hpFcpRspHdr_s {
                       bit32 FrameHeader[8];
                       bit8  reserved[8];
                       bit8  FcpStatus[4];
                       bit8  FcpResId[4];
                       bit8  FcpSnsLen[4];
                       bit8  FcpRspLen[4];
                     };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agIORequest_s
               agIORequest_t;

struct agIORequest_s
       {
         void *fcData;
         void *osData;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpIORequest_s
               hpIORequest_t;

struct hpIORequest_s {
                       void *fcData;
                       void *osData;
                     };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef union agIORequestBody_u
              agIORequestBody_t;

union agIORequestBody_u
      {
        agCDBRequest_t CDBRequest;
      };
#else  /* _DvrArch_1_20_ was not defined */
typedef union hpIORequestBody_u
              hpIORequestBody_t;

union hpIORequestBody_u {
                          hpCDBRequest_t CDBRequest;
                        };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRoot_s
               agRoot_t;

struct agRoot_s
       {
         void *fcData;
         void *osData;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRoot_s
               hpRoot_t;

struct hpRoot_s {
                  void *fcData;
                  void *osData;
                };
#endif /* _DvrArch_1_20_ was not defined */

/*+
Data Type/Structure Addressing & Bit-Manipulation Macros
-*/

/* Begin: Big_Endian_Code */
#ifndef hpBigEndianCPU   /* hpBigEndianCPU */

#ifdef _DvrArch_1_20_

#define hpSwapBit16(toSwap)                       \
            ( ((((os_bit16)toSwap) & 0x00FF) << 8) | \
              ((((os_bit16)toSwap) & 0xFF00) >> 8) )

#define hpSwapBit32(toSwap)                            \
            ( ((((os_bit32)toSwap) & 0x000000FF) << 24) | \
              ((((os_bit32)toSwap) & 0x0000FF00) <<  8) | \
              ((((os_bit32)toSwap) & 0x00FF0000) >>  8) | \
              ((((os_bit32)toSwap) & 0xFF000000) >> 24) )

#else  /* _DvrArch_1_20_ was not defined */

#define hpSwapBit16(toSwap)                       \
            ( ((((bit16)toSwap) & 0x00FF) << 8) | \
              ((((bit16)toSwap) & 0xFF00) >> 8) )

#define hpSwapBit32(toSwap)                            \
            ( ((((bit32)toSwap) & 0x000000FF) << 24) | \
              ((((bit32)toSwap) & 0x0000FF00) <<  8) | \
              ((((bit32)toSwap) & 0x00FF0000) >>  8) | \
              ((((bit32)toSwap) & 0xFF000000) >> 24) )

#endif /* _DvrArch_1_20_ was not defined */

#else                    /* hpBigEndianCPU */

#define hpSwapBit16(NottoSwap)  NottoSwap
#define hpSwapBit32(NottoSwap)  NottoSwap

#endif                   /* hpBigEndianCPU */
/* End: Big_Endian_Code */

#ifdef _DvrArch_1_20_

#define hpFieldOffset(baseType,fieldName) \
            ((os_bit32)((os_bitptr)(&(((baseType *)0)->fieldName))))

#define hpObjectBase(baseType,fieldName,fieldPtr) \
            ((baseType *)((os_bit8 *)(fieldPtr) - ((os_bitptr)(&(((baseType *)0)->fieldName)))))

#define agFieldOffset(baseType,fieldName) \
            ((os_bit32)((os_bitptr)(&(((baseType *)0)->fieldName))))

#define agObjectBase(baseType,fieldName,fieldPtr) \
            ((baseType *)((os_bit8 *)(fieldPtr) - ((os_bitptr)(&(((baseType *)0)->fieldName)))))

#else  /* _DvrArch_1_20_ was not defined */

#define hpFieldOffset(baseType,fieldName) \
            ((bit32)(&(((baseType *)0)->fieldName)))

#define hpObjectBase(baseType,fieldName,fieldPtr) \
            ((baseType *)((bit8 *)fieldPtr - hpFieldOffset(baseType,fieldName)))

#endif /* _DvrArch_1_20_ was not defined */

/*
 * Include hpFmtFill() API .H File
 */

#include "fmtfill.h"

/*
 * Include FCLayer-specific API .H File
 */

#include "fcapi.h"

/*
 * Define (default) FCLayer API
 */

typedef void * fiFrameHandle_t;

#ifdef _DvrArch_1_20_
typedef void (*fiFrameProcessorFunction_t)(
                                            agRoot_t        *agRoot,
                                            os_bit32         fiD_ID,
                                            os_bit16         fiOX_ID,
                                            fiFrameHandle_t  fiFrame
                                          );
#else  /* _DvrArch_1_20_ was not defined */
typedef void (*fiFrameProcessorFunction_t)(
                                            hpRoot_t        *hpRoot,
                                            bit32            fiD_ID,
                                            bit16            fiOX_ID,
                                            fiFrameHandle_t  fiFrame
                                          );
#endif /* _DvrArch_1_20_ was not defined */

#ifndef fcAbortIO
#ifdef _DvrArch_1_20_
osGLOBAL void fcAbortIO(
                         agRoot_t      *agRoot,
                         agIORequest_t *agIORequest
                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcAbortIO(
                       hpRoot_t      *hpRoot,
                       hpIORequest_t *hpIORequest
                     );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcAbortIO */

#ifdef _DvrArch_1_30_

#define FC_CMND_STATUS_SUCCESS     0x00
#define FC_CMND_STATUS_TIMEDOUT    0x01
#define FC_CMND_STATUS_CANCELED    0x02

#define fcQPairID_IP     0x00000000

#define fcBindQSuccess   0x00000000
#define fcBindQInvalidID 0x00000001

#if 0
#ifndef fcBindToWorkQs
osGLOBAL os_bit32 fcBindToWorkQs(
                                  agRoot_t  *agRoot,
                                  os_bit32   agQPairID,
                                  void     **agInboundQBase,
                                  os_bit32   agInboundQEntries,
                                  os_bit32  *agInboundQProdIndex,
                                  os_bit32  *agInboundQConsIndex,
                                  void     **agOutboundQBase,
                                  os_bit32   agOutboundQEntries,
                                  os_bit32  *agOutboundQProdIndex,
                                  os_bit32  *agOutboundQConsIndex
                                );

#endif  /* ~fcBindToWorkQs */

#endif /* 0 */

#endif /* _DvrArch_1_30_ was defined */

#ifndef fcCardSupported
#ifdef _DvrArch_1_20_
osGLOBAL agBOOLEAN fcCardSupported(
                                    agRoot_t *agRoot
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL BOOLEAN fcCardSupported(
                                hpRoot_t *hpRoot
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcCardSupported */

#ifndef fcDelayedInterruptHandler
#ifdef _DvrArch_1_20_
osGLOBAL void fcDelayedInterruptHandler(
                                         agRoot_t *agRoot
                                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcDelayedInterruptHandler(
                                       hpRoot_t *hpRoot
                                     );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcDelayedInterruptHandler */

#ifndef fcEnteringOS
#ifdef _DvrArch_1_20_
osGLOBAL void fcEnteringOS(
                            agRoot_t *agRoot
                          );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcEnteringOS(
                          hpRoot_t *hpRoot
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcEnteringOS */

#define fcChanInfoReturned 0x00000000

#ifndef fcGetChannelInfo
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcGetChannelInfo(
                                    agRoot_t       *agRoot,
                                    agFCChanInfo_t *agFCChanInfo
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcGetChannelInfo(
                               hpRoot_t       *hpRoot,
                               hpFCChanInfo_t *hpFCChanInfo
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcGetChannelInfo */

#ifndef fcGetDeviceHandles
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcGetDeviceHandles(
                                      agRoot_t  *agRoot,
                                      agFCDev_t  agFCDev[],
                                      os_bit32   maxFCDevs
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcGetDeviceHandles(
                                 hpRoot_t  *hpRoot,
                                 hpFCDev_t  hpFCDev[],
                                 bit32      maxFCDevs
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcGetDeviceHandles */

#define fcGetDevInfoReturned 0x00000000
#define fcGetDevInfoFailed   0x00000001

#ifndef fcGetDeviceInfo
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcGetDeviceInfo(
                                   agRoot_t      *agRoot,
                                   agFCDev_t      agFCDev,
                                   agFCDevInfo_t *agFCDevInfo
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcGetDeviceInfo(
                              hpRoot_t      *hpRoot,
                              hpFCDev_t      hpFCDev,
                              hpFCDevInfo_t *hpFCDevInfo
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcGetDeviceInfo */

#define fcSyncInit          0x00000000
#define fcAsyncInit         0x00000001
#define fcSyncAsyncInitMask (fcSyncInit | fcAsyncInit)

#define fcInitializeSuccess 0x00000000
#define fcInitializeFailure 0x00000001

#ifndef fcInializeChannel
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcInitializeChannel(
                                       agRoot_t  *agRoot,
                                       os_bit32   initType,
                                       agBOOLEAN  sysIntsActive,
                                       void      *cachedMemoryPtr,
                                       os_bit32   cachedMemoryLen,
                                       os_bit32   dmaMemoryUpper32,
                                       os_bit32   dmaMemoryLower32,
                                       void      *dmaMemoryPtr,
                                       os_bit32   dmaMemoryLen,
                                       os_bit32   nvMemoryLen,
                                       os_bit32   cardRamUpper32,
                                       os_bit32   cardRamLower32,
                                       os_bit32   cardRamLen,
                                       os_bit32   cardRomUpper32,
                                       os_bit32   cardRomLower32,
                                       os_bit32   cardRomLen,
                                       os_bit32   usecsPerTick
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcInitializeChannel(
                                  hpRoot_t *hpRoot,
                                  bit32     initType,
                                  BOOLEAN   sysIntsActive,
                                  void     *cachedMemoryPtr,
                                  bit32     cachedMemoryLen,
                                  bit32     dmaMemoryUpper32,
                                  bit32     dmaMemoryLower32,
                                  void     *dmaMemoryPtr,
                                  bit32     dmaMemoryLen,
                                  bit32     nvMemoryLen,
                                  bit32     cardRamUpper32,
                                  bit32     cardRamLower32,
                                  bit32     cardRamLen,
                                  bit32     cardRomUpper32,
                                  bit32     cardRomLower32,
                                  bit32     cardRomLen,
                                  bit32     usecsPerTick
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcInializeChannel */

#ifndef fcInitializeDriver
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcInitializeDriver(
                                      agRoot_t *agRoot,
                                      os_bit32 *cachedMemoryNeeded,
                                      os_bit32 *cachedMemoryPtrAlign,
                                      os_bit32 *dmaMemoryNeeded,
                                      os_bit32 *dmaMemoryPtrAlign,
                                      os_bit32 *dmaMemoryPhyAlign,
                                      os_bit32 *nvMemoryNeeded,
                                      os_bit32 *usecsPerTick
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcInitializeDriver(
                                 hpRoot_t *hpRoot,
                                 bit32    *cachedMemoryNeeded,
                                 bit32    *cachedMemoryPtrAlign,
                                 bit32    *dmaMemoryNeeded,
                                 bit32    *dmaMemoryPtrAlign,
                                 bit32    *dmaMemoryPhyAlign,
                                 bit32    *nvMemoryNeeded,
                                 bit32    *usecsPerTick
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcInitializeDriver */

#ifndef fcInterruptHandler
#ifdef _DvrArch_1_20_
osGLOBAL agBOOLEAN fcInterruptHandler(
                                       agRoot_t *agRoot
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL BOOLEAN fcInterruptHandler(
                                   hpRoot_t *hpRoot
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcInterruptHandler */

#ifndef fcIOInfoReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 fcIOInfoReadBit8(
                                   agRoot_t      *agRoot,
                                   agIORequest_t *agIORequest,
                                   os_bit32       fcIOInfoOffset
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 fcIOInfoReadBit8(
                              hpRoot_t      *hpRoot,
                              hpIORequest_t *hpIORequest,
                              bit32          fcIOInfoOffset
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBit8 */

#ifndef fcIOInfoReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 fcIOInfoReadBit16(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 fcIOInfoReadBit16(
                                hpRoot_t      *hpRoot,
                                hpIORequest_t *hpIORequest,
                                bit32          fcIOInfoOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBit16 */

#ifndef fcIOInfoReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcIOInfoReadBit32(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcIOInfoReadBit32(
                                hpRoot_t      *hpRoot,
                                hpIORequest_t *hpIORequest,
                                bit32          fcIOInfoOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBit32 */

#ifndef fcIOInfoReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void fcIOInfoReadBlock(
                                 agRoot_t      *agRoot,
                                 agIORequest_t *agIORequest,
                                 os_bit32       fcIOInfoOffset,
                                 void          *fcIOInfoBuffer,
                                 os_bit32       fcIOInfoBufLen
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcIOInfoReadBlock(
                               hpRoot_t      *hpRoot,
                               hpIORequest_t *hpIORequest,
                               bit32          fcIOInfoOffset,
                               void          *fcIOInfoBuffer,
                               bit32          fcIOInfoBufLen
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBlock */

#ifndef fcLeavingOS
#ifdef _DvrArch_1_20_
osGLOBAL void fcLeavingOS(
                           agRoot_t *agRoot
                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcLeavingOS(
                         hpRoot_t *hpRoot
                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcLeavingOS */

#ifdef _DvrArch_1_30_
#ifndef fcProcessInboundQ
osGLOBAL void fcProcessInboundQ(
                                 agRoot_t  *agRoot,
                                 os_bit32   agQPairID
                               );
#endif  /* ~fcProcessInboundQ */
#endif /* _DvrArch_1_30_ was defined */

#define fcSyncReset          0x00000000
#define fcAsyncReset         0x00000001
#define fcSyncAsyncResetMask (fcSyncReset | fcAsyncReset)

#define fcResetSuccess       0x00000000
#define fcResetFailure       0x00000001

#ifndef fcResetChannel
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcResetChannel(
                                  agRoot_t *agRoot,
                                  os_bit32  agResetType
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcResetChannel(
                             hpRoot_t *hpRoot,
                             bit32     hpResetType
                           );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcResetChannel */




#ifdef _DvrArch_1_20_
#define fcResetAllDevs       (agFCDev_t)(-1)    /* changed to avoid compilation error on IA64 0xFFFFFFFF  */
#else  /* _DvrArch_1_20_ was not defined */
#define fcResetAllDevs       (hpFCDev_t)(-1)    /* changed to avoid compilation error on IA64 0xFFFFFFFF  */
#endif /* _DvrArch_1_20_ was not defined */

#define fcHardReset          0x00000000
#define fcSoftReset          0x00000002
#define fcHardSoftResetMask  (fcHardReset | fcSoftReset)

#ifndef fcResetDevice
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcResetDevice(
                                 agRoot_t  *agRoot,
                                 agFCDev_t  agFCDev,
                                 os_bit32   agResetType
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcResetDevice(
                            hpRoot_t  *hpRoot,
                            hpFCDev_t  hpFCDev,
                            bit32      hpResetType
                          );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcResetDevice */

#ifndef fcShutdownChannel
#ifdef _DvrArch_1_20_
osGLOBAL void fcShutdownChannel(
                                 agRoot_t *agRoot
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcShutdownChannel(
                               hpRoot_t  *hpRoot
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcShutdownChannel */

#define fcIOStarted        0x00000000
#define fcIOBusy           0x00000001
#define fcIOBad            0x00000002
#define fcIONoDevice       0x00000003
#define fcIONoSupport      0x00000004

#define fcCDBRequest       0x00000000

#ifndef fcStartIO
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcStartIO(
                             agRoot_t          *agRoot,
                             agIORequest_t     *agIORequest,
                             agFCDev_t          agFCDev,
                             os_bit32           agRequestType,
                             agIORequestBody_t *agRequestBody
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcStartIO(
                        hpRoot_t          *hpRoot,
                        hpIORequest_t     *hpIORequest,
                        hpFCDev_t          hpFCDev,
                        bit32              hpRequestType,
                        hpIORequestBody_t *hpRequestBody
                      );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcStartIO */

#ifndef fcSystemInterruptsActive
#ifdef _DvrArch_1_20_
osGLOBAL void fcSystemInterruptsActive(
                                        agRoot_t  *agRoot,
                                        agBOOLEAN  sysIntsActive
                                      );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcSystemInterruptsActive(
                                      hpRoot_t *hpRoot,
                                      BOOLEAN   sysIntsActive
                                    );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcSystemInterruptsActive */

#ifndef fcTimerTick
#ifdef _DvrArch_1_20_
osGLOBAL void fcTimerTick(
                           agRoot_t *agRoot
                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcTimerTick(
                         hpRoot_t *hpRoot
                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcTimerTick */

#define fiAllocOxIDSuccess 0x00000000
#define fiAllocOxIDBusy    0x00000001

#ifndef fiAllocOxID
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fiAllocOxID(
                               agRoot_t                   *agRoot,
                               os_bit32                    fiD_ID,
                               os_bit16                   *fiOX_ID,
                               fiFrameProcessorFunction_t  fiCallBack
                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fiAllocOxID(
                          hpRoot_t                   *hpRoot,
                          bit32                       fiD_ID,
                          bit16                      *fiOX_ID,
                          fiFrameProcessorFunction_t  fiCallBack
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiAllocOxID */

#ifndef fiFrameReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 fiFrameReadBit8(
                                  agRoot_t        *agRoot,
                                  fiFrameHandle_t  fiFrame,
                                  os_bit32         fiFrameOffset
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 fiFrameReadBit8(
                             hpRoot_t        *hpRoot,
                             fiFrameHandle_t  fiFrame,
                             bit32            fiFrameOffset
                           );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBit8 */

#ifndef fiFrameReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 fiFrameReadBit16(
                                    agRoot_t        *agRoot,
                                    fiFrameHandle_t  fiFrame,
                                    os_bit32         fiFrameOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 fiFrameReadBit16(
                               hpRoot_t        *hpRoot,
                               fiFrameHandle_t  fiFrame,
                               bit32            fiFrameOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBit16 */

#ifndef fiFrameReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fiFrameReadBit32(
                                    agRoot_t        *agRoot,
                                    fiFrameHandle_t  fiFrame,
                                    os_bit32         fiFrameOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fiFrameReadBit32(
                               hpRoot_t        *hpRoot,
                               fiFrameHandle_t  fiFrame,
                               bit32            fiFrameOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBit32 */

#ifndef fiFrameReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void fiFrameReadBlock(
                                agRoot_t        *agRoot,
                                fiFrameHandle_t  fiFrame,
                                os_bit32         fiFrameOffset,
                                void            *fiFrameBuffer,
                                os_bit32         fiFrameBufLen
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fiFrameReadBlock(
                              hpRoot_t        *hpRoot,
                              fiFrameHandle_t  fiFrame,
                              bit32            fiFrameOffset,
                              void            *fiFrameBuffer,
                              bit32            fiFrameBufLen
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBlock */

#ifndef fiReturnOxID
#ifdef _DvrArch_1_20_
osGLOBAL void fiReturnOxID(
                            agRoot_t *agRoot,
                            os_bit32  fiD_ID,
                            os_bit16  fiOX_ID
                          );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fiReturnOxID(
                          hpRoot_t                   *hpRoot,
                          bit32                       fiD_ID,
                          bit16                       fiOX_ID
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiReturnOxID */

#define fiSendFrameSuccess 0x00000000
#define fiSendFrameBusy    0x00000001

#ifndef fiSendSingleFrame
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fiSendSingleFrame(
                                     agRoot_t *agRoot,
                                     void     *fiFrame,
                                     os_bit32  fiFrameLen
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fiSendSingleFrame(
                                hpRoot_t *hpRoot,
                                void     *fiFrame,
                                bit32     fiFrameLen
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiSendSingleFrame */

#ifdef _DvrArch_1_30_

os_bit32 fcIPSend(
                   agRoot_t          *hpRoot,
                   os_bit8           *DestAddress,
                   void              *osData,
           os_bit32           PacketLength
                 );

os_bit32 fcIPReceive(
                      agRoot_t          *hpRoot,
                      void              *osData
                    );

os_bit32 fcIPCancel(
                      agRoot_t          *hpRoot,
                      void              *osData,
              void              *CancelItem
                    );

os_bit32 fcIPStatus(
                      agRoot_t          *hpRoot,
                      void              *osData
                    );

#endif /* _DvrArch_1_30_ was defined */

/*
 * Include OSLayer-specific API .H File
 */
#ifndef _New_Header_file_Layout_
#include "../../oslayer/h/osapi.h"

#else /* _New_Header_file_Layout_ */
#include "osapi.h"

#endif  /* _New_Header_file_Layout_ */


/*
 * Define (default) OSLayer API
 */

#ifndef osAdjustParameterBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osAdjustParameterBit32(
                                          agRoot_t *agRoot,
                                          char     *paramName,
                                          os_bit32  paramDefault,
                                          os_bit32  paramMin,
                                          os_bit32  paramMax
                                        );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osAdjustParameterBit32(
                                     hpRoot_t *hpRoot,
                                     char     *paramName,
                                     bit32     paramDefault,
                                     bit32     paramMin,
                                     bit32     paramMax
                                   );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osAdjustParameterBit32 */

#ifndef osAdjustParameterBuffer
#ifdef _DvrArch_1_20_
osGLOBAL void osAdjustParameterBuffer(
                                       agRoot_t *agRoot,
                                       char     *paramName,
                                       void     *paramBuffer,
                                       os_bit32  paramBufLen
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osAdjustParameterBuffer(
                                     hpRoot_t *hpRoot,
                                     char     *paramName,
                                     void     *paramBuffer,
                                     bit32     paramBufLen
                                   );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osAdjustParameterBuffer */

#ifndef osCardRamReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osCardRamReadBit8(
                                    agRoot_t *agRoot,
                                    os_bit32  cardRamOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osCardRamReadBit8(
                               hpRoot_t *hpRoot,
                               bit32     cardRamOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBit8 */

#ifndef osCardRamReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osCardRamReadBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRamOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osCardRamReadBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBit16 */

#ifndef osCardRamReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osCardRamReadBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRamOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osCardRamReadBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBit32 */

#ifndef osCardRamReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamReadBlock(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRamOffset,
                                  void     *cardRamBuffer,
                                  os_bit32  cardRamBufLen
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamReadBlock(
                                hpRoot_t *hpRoot,
                                bit32     cardRamOffset,
                                void     *cardRamBuffer,
                                bit32     cardRamBufLen
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBlock */

#ifndef osCardRamWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRamOffset,
                                  os_bit8   cardRamValue
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBit8(
                                hpRoot_t *hpRoot,
                                bit32     cardRamOffset,
                                bit8      cardRamValue
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBit8 */

#ifndef osCardRamWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBit16(
                                   agRoot_t *agRoot,
                                   os_bit32     cardRamOffset,
                                   os_bit16     cardRamValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset,
                                 bit16     cardRamValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBit16 */

#ifndef osCardRamWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBit32(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRamOffset,
                                   os_bit32  cardRamValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset,
                                 bit32     cardRamValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBit32 */

#ifndef osCardRamWriteBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBlock(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRamOffset,
                                   void     *cardRamBuffer,
                                   os_bit32  cardRamBufLen
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBlock(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset,
                                 void     *cardRamBuffer,
                                 bit32     cardRamBufLen
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBlock */

#ifndef osCardRomReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osCardRomReadBit8(
                                    agRoot_t *agRoot,
                                    os_bit32  cardRomOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osCardRomReadBit8(
                               hpRoot_t *hpRoot,
                               bit32     cardRomOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBit8 */

#ifndef osCardRomReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osCardRomReadBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRomOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osCardRomReadBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBit16 */

#ifndef osCardRomReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osCardRomReadBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRomOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osCardRomReadBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBit32 */

#ifndef osCardRomReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomReadBlock(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRomOffset,
                                  void     *cardRomBuffer,
                                  os_bit32  cardRomBufLen
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomReadBlock(
                                hpRoot_t *hpRoot,
                                bit32     cardRomOffset,
                                void     *cardRomBuffer,
                                bit32     cardRomBufLen
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBlock */

#ifndef osCardRomWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRomOffset,
                                  os_bit8   cardRomValue
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBit8(
                                hpRoot_t *hpRoot,
                                bit32     cardRomOffset,
                                bit8      cardRomValue
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBit8 */

#ifndef osCardRomWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBit16(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRomOffset,
                                   os_bit16  cardRomValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset,
                                 bit16     cardRomValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBit16 */

#ifndef osCardRomWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBit32(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRomOffset,
                                   os_bit32  cardRomValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset,
                                 bit32     cardRomValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBit32 */

#ifndef osCardRomWriteBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBlock(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRomOffset,
                                   void     *cardRomBuffer,
                                   os_bit32  cardRomBufLen
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBlock(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset,
                                 void     *cardRomBuffer,
                                 bit32     cardRomBufLen
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBlock */

#ifndef osChipConfigReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipConfigReadBit8(
                                       agRoot_t *agRoot,
                                       os_bit32  chipConfigOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipConfigReadBit8(
                                  hpRoot_t *hpRoot,
                                  bit32     chipConfigOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigReadBit8 */

#ifndef osChipConfigReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipConfigReadBit16(
                                         agRoot_t *agRoot,
                                         os_bit32  chipConfigOffset
                                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipConfigReadBit16(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigReadBit16 */

#ifndef osChipConfigReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipConfigReadBit32(
                                         agRoot_t *agRoot,
                                         os_bit32  chipConfigOffset
                                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipConfigReadBit32(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigReadBit32 */

#ifndef osChipConfigWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipConfigWriteBit8(
                                     agRoot_t *agRoot,
                                     os_bit32  chipConfigOffset,
                                     os_bit8   chipConfigValue
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipConfigWriteBit8(
                                   hpRoot_t *hpRoot,
                                   bit32     chipConfigOffset,
                                   bit8      chipConfigValue
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigWriteBit8 */

#ifndef osChipConfigWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipConfigWriteBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  chipConfigOffset,
                                      os_bit16  chipConfigValue
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipConfigWriteBit16(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset,
                                    bit16     chipConfigValue
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigWriteBit16 */

#ifndef osChipConfigWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipConfigWriteBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  chipConfigOffset,
                                      os_bit32  chipConfigValue
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipConfigWriteBit32(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset,
                                    bit32     chipConfigValue
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigWriteBit32 */

#ifndef osChipIOLoReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipIOLoReadBit8(
                                     agRoot_t *agRoot,
                                     os_bit32  chipIOLoOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipIOLoReadBit8(
                                hpRoot_t *hpRoot,
                                bit32     chipIOLoOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoReadBit8 */

#ifndef osChipIOLoReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipIOLoReadBit16(
                                       agRoot_t *agRoot,
                                       os_bit32  chipIOLoOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipIOLoReadBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoReadBit16 */

#ifndef osChipIOLoReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipIOLoReadBit32(
                                       agRoot_t *agRoot,
                                       os_bit32  chipIOLoOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipIOLoReadBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoReadBit32 */

#ifndef osChipIOLoWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOLoWriteBit8(
                                   agRoot_t *agRoot,
                                   os_bit32  chipIOLoOffset,
                                   os_bit8   chipIOLoValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOLoWriteBit8(
                                 hpRoot_t *hpRoot,
                                 bit32     chipIOLoOffset,
                                 bit8      chipIOLoValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoWriteBit8 */

#ifndef osChipIOLoWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOLoWriteBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOLoOffset,
                                    os_bit16  chipIOLoValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOLoWriteBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset,
                                  bit16     chipIOLoValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoWriteBit16 */

#ifndef osChipIOLoWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOLoWriteBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOLoOffset,
                                    os_bit32  chipIOLoValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOLoWriteBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset,
                                  bit32     chipIOLoValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoWriteBit32 */

#ifndef osChipIOUpReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipIOUpReadBit8(
                                     agRoot_t *agRoot,
                                     os_bit32  chipIOUpOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipIOUpReadBit8(
                                hpRoot_t *hpRoot,
                                bit32     chipIOUpOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpReadBit8 */

#ifndef osChipIOUpReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipIOUpReadBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOUpOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipIOUpReadBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpReadBit16 */

#ifndef osChipIOUpReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipIOUpReadBit32(
                                       agRoot_t *agRoot,
                                       os_bit32  chipIOUpOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipIOUpReadBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpReadBit32 */

#ifndef osChipIOUpWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOUpWriteBit8(
                                   agRoot_t *agRoot,
                                   os_bit32  chipIOUpOffset,
                                   os_bit8   chipIOUpValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOUpWriteBit8(
                                 hpRoot_t *hpRoot,
                                 bit32     chipIOUpOffset,
                                 bit8      chipIOUpValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpWriteBit8 */

#ifndef osChipIOUpWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOUpWriteBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOUpOffset,
                                    os_bit16  chipIOUpValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOUpWriteBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset,
                                  bit16     chipIOUpValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpWriteBit16 */

#ifndef osChipIOUpWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOUpWriteBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOUpOffset,
                                    os_bit32  chipIOUpValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOUpWriteBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset,
                                  bit32     chipIOUpValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpWriteBit32 */

#ifndef osChipMemReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipMemReadBit8(
                                    agRoot_t *agRoot,
                                    os_bit32  chipMemOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipMemReadBit8(
                               hpRoot_t *hpRoot,
                               bit32     chipMemOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemReadBit8 */

#ifndef osChipMemReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipMemReadBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  chipMemOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipMemReadBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemReadBit16 */

#ifndef osChipMemReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipMemReadBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  chipMemOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipMemReadBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemReadBit32 */

#ifndef osChipMemWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipMemWriteBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  chipMemOffset,
                                  os_bit8   chipMemValue
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipMemWriteBit8(
                                hpRoot_t *hpRoot,
                                bit32     chipMemOffset,
                                bit8      chipMemValue
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemWriteBit8 */

#ifndef osChipMemWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipMemWriteBit16(
                                   agRoot_t *agRoot,
                                   os_bit32  chipMemOffset,
                                   os_bit16  chipMemValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipMemWriteBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset,
                                 bit16     chipMemValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemWriteBit16 */

#ifndef osChipMemWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipMemWriteBit32(
                                   agRoot_t *agRoot,
                                   os_bit32  chipMemOffset,
                                   os_bit32  chipMemValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipMemWriteBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset,
                                 bit32     chipMemValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemWriteBit32 */

#ifndef osDebugBreakpoint
#ifdef _DvrArch_1_20_
osGLOBAL void osDebugBreakpoint(
                                 agRoot_t  *agRoot,
                                 agBOOLEAN  BreakIfTrue,
                                 char      *DisplayIfTrue
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osDebugBreakpoint(
                               hpRoot_t *hpRoot,
                               BOOLEAN   BreakIfTrue,
                               char     *DisplayIfTrue
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osDebugBreakpoint */

#define osFCConfused    0x00000001
#define osFCConfusedPER 0x00000002
#define osFCConfusedMPE 0x00000003
#define osFCConfusedCRS 0x00000004
#define osFCConfusedDER 0x00000005

#ifndef osFCLayerAsyncError
#ifdef _DvrArch_1_20_
osGLOBAL void osFCLayerAsyncError(
                                   agRoot_t *agRoot,
                                   os_bit32  fcLayerError
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osFCLayerAsyncError(
                                 hpRoot_t *hpRoot,
                                 bit32     fcLayerError
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osFCLayerAsyncError */

#define osFCLinkUp      0x00000000
#define osFCLinkFalling 0x00000001
#define osFCLinkDown    0x00000002
#define osFCLinkDead    0x00000003
#define osFCLinkRising  0x00000004

#ifndef osFCLayerAsyncEvent
#ifdef _DvrArch_1_20_
osGLOBAL void osFCLayerAsyncEvent(
                                   agRoot_t *agRoot,
                                   os_bit32  fcLayerEvent
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osFCLayerAsyncEvent(
                                 hpRoot_t *hpRoot,
                                 bit32     fcLayerEvent
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osFCLayerAsyncEvent */

#ifndef osGetDataBufferPtr
#ifdef _DvrArch_1_20_
osGLOBAL void *osGetDataBufferPtr(
                                   agRoot_t      *agRoot,
                                   agIORequest_t *agIORequest
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void *osGetDataBufferPtr(
                                 hpRoot_t      *hpRoot,
                                 hpIORequest_t *hpIORequest
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osGetDataBufferPtr */

#define osSGLSuccess 0x00000000
#define osSGLInvalid 0x00000001

#ifndef osGetSGLChunk
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osGetSGLChunk(
                                 agRoot_t      *agRoot,
                                 agIORequest_t *agIORequest,
                                 os_bit32       agChunkOffset,
                                 os_bit32      *agChunkUpper32,
                                 os_bit32      *agChunkLower32,
                                 os_bit32      *agChunkLen
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osGetSGLChunk(
                            hpRoot_t      *hpRoot,
                            hpIORequest_t *hpIORequest,
                            bit32          hpChunkOffset,
                            bit32         *hpChunkUpper32,
                            bit32         *hpChunkLower32,
                            bit32         *hpChunkLen
                          );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osGetSGLChunk */

#ifndef osInitializeChannelCallback
#ifdef _DvrArch_1_20_
osGLOBAL void osInitializeChannelCallback(
                                           agRoot_t *agRoot,
                                           os_bit32  agInitializeStatus
                                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osInitializeChannelCallback(
                                         hpRoot_t *hpRoot,
                                         bit32     hpInitializeStatus
                                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osInitializeChannelCallback */

#define osIOSuccess     0x00000000
#define osIOAborted     0x00000001
#define osIOAbortFailed 0x00000002
#define osIODevGone     0x00000003
#define osIODevReset    0x00000004
#define osIOInfoBad     0x00000005
#define osIOOverUnder   0x00000006
#define osIOFailed      0x00000007
#define osIOInvalid     0x000001FF


#ifndef osIOCompleted
#ifdef _DvrArch_1_20_
osGLOBAL void osIOCompleted(
                             agRoot_t      *agRoot,
                             agIORequest_t *agIORequest,
                             os_bit32       agIOStatus,
                             os_bit32       agIOInfoLen
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osIOCompleted(
                           hpRoot_t      *hpRoot,
                           hpIORequest_t *hpIORequest,
                           bit32          hpIOStatus,
                           bit32          hpIOInfoLen
                         );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osIOCompleted */

#ifndef osLogBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osLogBit32(
                          agRoot_t *agRoot,
                          os_bit32  agBit32
                        );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osLogBit32(
                        hpRoot_t *hpRoot,
                        bit32     hpBit32
                      );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osLogBit32 */

#define osLogLevel_Always    0x00000000
#define osLogLevel_Error_MIN 0x00000001
#define osLogLevel_Error_MAX 0x0000000F
#define osLogLevel_Info_MIN  0x00000010
#define osLogLevel_Info_MAX  0xFFFFFFFE
#define osLogLevel_Never     0xFFFFFFFF

#ifndef osLogDebugString
#ifdef _DvrArch_1_20_
osGLOBAL void osLogDebugString(
                                agRoot_t *agRoot,
                                os_bit32  detailLevel,
                                char     *formatString,
                                char     *firstString,
                                char     *secondString,
                                void     *firstPtr,
                                void     *secondPtr,
                                os_bit32  firstBit32,
                                os_bit32  secondBit32,
                                os_bit32  thirdBit32,
                                os_bit32  fourthBit32,
                                os_bit32  fifthBit32,
                                os_bit32  sixthBit32,
                                os_bit32  seventhBit32,
                                os_bit32  eighthBit32
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osLogDebugString(
                              hpRoot_t *hpRoot,
                              bit32     consoleLevel,
                              bit32     traceLevel,
                              char     *formatString,
                              char     *firstString,
                              char     *secondString,
                              bit32     firstBit32,
                              bit32     secondBit32,
                              bit32     thirdBit32,
                              bit32     fourthBit32,
                              bit32     fifthBit32,
                              bit32     sixthBit32,
                              bit32     seventhBit32,
                              bit32     eighthBit32
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osLogDebugString */

#ifndef osLogString
#ifdef _DvrArch_1_20_
osGLOBAL void osLogString(
                           agRoot_t *agRoot,
                           char     *formatString,
                           char     *firstString,
                           char     *secondString,
                           void     *firstPtr,
                           void     *secondPtr,
                           os_bit32  firstBit32,
                           os_bit32  secondBit32,
                           os_bit32  thirdBit32,
                           os_bit32  fourthBit32,
                           os_bit32  fifthBit32,
                           os_bit32  sixthBit32,
                           os_bit32  seventhBit32,
                           os_bit32  eighthBit32
                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osLogString(
                         hpRoot_t *hpRoot,
                         char     *formatString,
                         char     *firstString,
                         char     *secondString,
                         bit32     firstBit32,
                         bit32     secondBit32,
                         bit32     thirdBit32,
                         bit32     fourthBit32,
                         bit32     fifthBit32,
                         bit32     sixthBit32,
                         bit32     seventhBit32,
                         bit32     eighthBit32
                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osLogString */

#ifndef osNvMemReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osNvMemReadBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  nvMemOffset
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osNvMemReadBit8(
                             hpRoot_t *hpRoot,
                             bit32     nvMemOffset
                           );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBit8 */

#ifndef osNvMemReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osNvMemReadBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  nvMemOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osNvMemReadBit16(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBit16 */

#ifndef osNvMemReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osNvMemReadBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  nvMemOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osNvMemReadBit32(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBit32 */

#ifndef osNvMemReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemReadBlock(
                                agRoot_t *agRoot,
                                os_bit32  nvMemOffset,
                                void     *nvMemBuffer,
                                os_bit32  nvMemBufLen
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemReadBlock(
                              hpRoot_t *hpRoot,
                              bit32     nvMemOffset,
                              void     *nvMemBuffer,
                              bit32     nvMemBufLen
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBlock */

#ifndef osNvMemWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBit8(
                                agRoot_t *agRoot,
                                os_bit32  nvMemOffset,
                                os_bit8   nvMemValue
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBit8(
                              hpRoot_t *hpRoot,
                              bit32     nvMemOffset,
                              bit8      nvMemValue
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBit8 */

#ifndef osNvMemWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBit16(
                                 agRoot_t *agRoot,
                                 os_bit32  nvMemOffset,
                                 os_bit16  nvMemValue
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBit16(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset,
                               bit16     nvMemValue
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBit16 */

#ifndef osNvMemWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBit32(
                                 agRoot_t *agRoot,
                                 os_bit32  nvMemOffset,
                                 os_bit32  nvMemValue
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBit32(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset,
                               bit32     nvMemValue
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBit32 */

#ifndef osNvMemWriteBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBlock(
                                 agRoot_t *agRoot,
                                 os_bit32  nvMemOffset,
                                 void     *nvMemBuffer,
                                 os_bit32  nvMemBufLen
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBlock(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset,
                               void     *nvMemBuffer,
                               bit32     nvMemBufLen
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBlock */

#ifndef osResetChannelCallback
#ifdef _DvrArch_1_20_
osGLOBAL void osResetChannelCallback(
                                      agRoot_t *agRoot,
                                      os_bit32  agResetStatus
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osResetChannelCallback(
                                    hpRoot_t *hpRoot,
                                    bit32     hpResetStatus
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osResetChannelCallback */

#ifndef osResetDeviceCallback
#ifdef _DvrArch_1_20_
osGLOBAL void osResetDeviceCallback(
                                     agRoot_t  *agRoot,
                                     agFCDev_t  agFCDev,
                                     os_bit32   agResetStatus
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osResetDeviceCallback(
                                   hpRoot_t  *hpRoot,
                                   hpFCDev_t  hpFCDev,
                                   bit32      hpResetStatus
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osResetDeviceCallback */

#ifdef _DvrArch_1_30_
#ifndef osSignalOutboundQ
osGLOBAL void osSignalOutboundQ(
                                 agRoot_t  *agRoot,
                                 os_bit32   agQPairID
                               );
#endif  /* ~osSignalOutboundQ */
#endif /* _DvrArch_1_30_ was defined */

#ifndef osSingleThreadedEnter
#ifdef _DvrArch_1_20_
osGLOBAL void osSingleThreadedEnter(
                                     agRoot_t *agRoot
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSingleThreadedEnter(
                                   hpRoot_t *hpRoot
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSingleThreadedEnter */

#ifndef osSingleThreadedLeave
#ifdef _DvrArch_1_20_
osGLOBAL void osSingleThreadedLeave(
                                     agRoot_t *agRoot
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSingleThreadedLeave(
                                   hpRoot_t *hpRoot
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSingleThreadedLeave */

#ifndef osStallThread
#ifdef _DvrArch_1_20_
osGLOBAL void osStallThread(
                             agRoot_t *agRoot,
                             os_bit32  microseconds
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osStallThread(
                           hpRoot_t *hpRoot,
                           bit32 microseconds
                         );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osStallThread */

#ifndef osTimeStamp
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osTimeStamp(
                               agRoot_t *agRoot
                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osTimeStamp(
                          hpRoot_t *hpRoot
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osTimeStamp */

/* Begin: Big_Endian_Code */
#ifndef hpMustSwapDmaMem   /* hpMustSwapDmaMem */

#define osSwapDownwardPayloadToTachLiteEndian(x, y)
#define osSwapDownwardNonPayloadToTachLiteEndian(x, y)
#define osSwapUpwardNonPayloadToSystemEndian(x, y)
#define osSwapUpwardPayloadToFcLinkEndian(x, y)
#define osSwapBit16TachLiteToSystemEndian(x) x
#define osSwapBit32TachLiteToSystemEndian(x) x
#define osSwapBit16ToTachLiteEndian(x) x
#define osSwapBit32ToTachLiteEndian(x) x

#else                      /* hpMustSwapDmaMem */

#ifndef osSwapDownwardPayloadToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapDownwardPayloadToTachLiteEndian(
                                                     void     *Payload,
                                                     os_bit32  Payload_len
                                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapDownwardPayloadToTachLiteEndian(
                                                   void  *Payload,
                                                   bit32  Payload_len
                                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapDownwardPayloadToTachLiteEndian */

#ifndef osSwapUpwardPayloadToFcLinkEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapUpwardPayloadToFcLinkEndian(
                                                 void     *Payload,
                                                 os_bit32  Payload_len
                                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapUpwardPayloadToFcLinkEndian(
                                               void  *Payload,
                                               bit32  Payload_len
                                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapUpwardPayloadToFcLinkEndian */

#ifndef osSwapDownwardNonPayloadToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapDownwardNonPayloadToTachLiteEndian(
                                                        void     *NonPayload,
                                                        os_bit32  NonPayload_len
                                                      );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapDownwardNonPayloadToTachLiteEndian(
                                                      void  *NonPayload,
                                                      bit32  NonPayload_len
                                                    );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapDownwardNonPayloadToTachLiteEndian */

#ifndef osSwapUpwardNonPayloadToSystemEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapUpwardNonPayloadToSystemEndian(
                                                    void     *NonPayload,
                                                    os_bit32  NonPayload_len
                                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapUpwardNonPayloadToSystemEndian(
                                                  void  *NonPayload,
                                                  bit32  NonPayload_len
                                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapUpwardNonPayloadToSystemEndian */

#ifndef osSwapBit32TachLiteToSystemEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osSwapBit32TachLiteToSystemEndian(
                                                     os_bit32 Bit32Value
                                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osSwapBit32TachLiteToSystemEndian(
                                                bit32 Bit32Value
                                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit32TachLiteToSystemEndian */

#ifndef osSwapBit16TachLiteToSystemEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osSwapBit16TachLiteToSystemEndian(
                                                     os_bit16 Bit32Value
                                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osSwapBit16TachLiteToSystemEndian(
                                                bit16 Bit32Value
                                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit32TachLiteToSystemEndian */

#ifndef osSwapBit32ToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osSwapBit32ToTachLiteEndian(
                                               os_bit32 Bit32Value
                                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osSwapBit32ToTachLiteEndian(
                                          bit32 Bit32Value
                                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit32ToTachLiteEndian */

#ifndef osSwapBit16ToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osSwapBit16ToTachLiteEndian(
                                               os_bit16 Bit32Value
                                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osSwapBit16ToTachLiteEndian(
                                          bit16 Bit32Value
                                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit16ToTachLiteEndian */

#endif                     /* ~hpMustSwapDmaMem */
/* End: Big_Endian_Code */

#ifdef _DvrArch_1_30_
osGLOBAL void osFcNetIoctlCompleted(
                                     agRoot_t *hpRoot,
                     void *osData,
                     os_bit32 status
                   );
#endif /* _DvrArch_1_30_ was defined */

/*
 * Include Embedded Firmware API .H File
 */

#include "fwspec.h"

/*
This is the structure which is at the offset 0x18000 from the base address of the SPI ROM.
*/

typedef struct agBiosConfig_s
               agBiosConfig_t;

#define agBIOS_Config_OffSet                0x18000

struct agBiosConfig_s
{
    os_bit8     Valid;      /*A5-----First byte to validate the structure*/
    os_bit8     Reserved_1;
    os_bit8     Reserved_2;
    os_bit8     Reserved_3;
    os_bit32    Struct_Size;
    os_bit8     agBiosConfig_Version;
    os_bit8     H_Alpa;         /*Hard Alpa     */
    os_bit8     H_Area;         /*Hard Area     */
    os_bit8     H_Domain;       /*Hard Domain   */

    os_bit8     B_Alpa;         /*Boot Alpa     */
    os_bit8     B_Area;         /*Boot Area     */
    os_bit8     B_Domain;       /*Boot Domain   */

    os_bit8     B_WWN[8];       /*Boot WWN       */

    os_bit8     BackwardScan;   /* 1 backward, 0: forward*/
    os_bit8     BiosEnabled;    /* 1 enabled,  0: disabled*/
    os_bit8     MaxDevice;      /* Max No. of device      */
    os_bit8     FLport;         /* 1: FL port, 0: F port  */

    os_bit8     Alpa_WWN;       /* 0:bootID=Alpa, 1:bootID=WWN*/
    os_bit8     ToggleXL2;      /*0 1Gig Mode, 1:2Gig Mode*/
    os_bit8     RevMajor;       /*BIOS_REV*/
    os_bit8     RevMinorL;      /*BIOS_SUB_REV_L*/

    os_bit8     RevMinorH;      /*BIOS_SUB_REV_H*/
    os_bit8     RevType;        /*BIOS_REV_TYPE*/
    os_bit8     Reserved_4;     /**/
    os_bit8     Reserved_5;     /**/
    os_bit8     End_Sig;         /* 55h------Last byte to validate the structure */
};

#define agBIOS_Config_Size                  sizeof(agBiosConfig_s)
#define agBIOS_Config_VALID                 0xA5
#define agBIOS_Config_EndSig                0x55
#define agBIOS_Fport                        0
#define agBIOS_Enabled                      1
#define agBIOS_FLport                       1
#define agBIOS_ToggleXL2_Link_Speed_1_gig   0   /* 1 GBit/sec */
#define agBIOS_ToggleXL2_Link_Speed_2_gig   1   /* 2 GBit/sec */
#define agBIOS_ToggleXL2_Link_Speed_1_RX_2_TX 3
#define agBIOS_ToggleXL2_Link_Speed_2_RX_1_TX 4

#endif  /* __Globals_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\hotplug4.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   HotPlug4.H

Abstract:

   This is the miniport driver for the Agilent 
   PCI to Fibre Channel Host Bus Adapter (HBA). 
   
   This module is specific to the NT 4.0 PCI Hot Plug feature 
   support routine header file. 

Authors:
   Ie Wei Njoo
 
Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/HotPlug4.H $

Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:16a $
   $Modtime::  $

Notes:

--*/

#ifndef __HOTPLUG_H__
#define __HOTPLUG_H__


// The BYTE, WORD, DWORD, INT, STATIC definitions are used by 
// the PCI Hot-Plug SDK header file.

#ifndef BYTE
#define BYTE unsigned char
#endif

#ifndef WORD
#define WORD unsigned short
#endif

#ifndef DWORD
#define DWORD unsigned long
#endif

#ifndef INT
#define INT int
#endif

#ifndef STATIC
#if DBG
#define STATIC
#else
#define STATIC static
#endif
#endif

#include "hppif3p.h"        // PCI Hot-Plug SDK header file

typedef struct _IOCTL_TEMPLATE {
   SRB_IO_CONTROL Header;
   UCHAR               ReturnData[1];
}IOCTL_TEMPLATE, *PIOCTL_TEMPLATE;

#define RET_VAL_MAX_ITER          30       // 30 second default wait while returning
                                           // SRB_STATUS_BUSY in StartIo
typedef struct _HOT_PLUG_CONTEXT {
   ULONG     extensions[MAX_CONTROLLERS];
   BOOLEAN   psuedoDone;
} HOT_PLUG_CONTEXT, *PHOT_PLUG_CONTEXT;

//
// Function prototypes for PCI Hot Plug support routines
//

VOID
RcmcSendEvent(
    IN PCARD_EXTENSION pCard,
    IN OUT PHR_EVENT pEvent
    );

PCARD_EXTENSION FindExtByPort(
    PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
    ULONG port
    );

ULONG
HppProcessIoctl(
    IN PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
    PVOID pIoctlBuffer,
    IN PSCSI_REQUEST_BLOCK pSrb
    );

BOOLEAN
PsuedoInit(
    IN PVOID pPsuedoExtension
    );

BOOLEAN PsuedoStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK pSrb
    );

ULONG
PsuedoFind(
    IN OUT PVOID pDeviceExtension,
    IN OUT PVOID pContext,
    IN PVOID pBusInformation,
    IN PCHAR pArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION pConfigInfo,
    OUT PBOOLEAN pAgain
    );

BOOLEAN
PsuedoResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    );

VOID
HotPlugFailController(
    PCARD_EXTENSION pCard
    );

VOID
HotPlugInitController(
    PCARD_EXTENSION pCard
    );

VOID
HotPlugReadyController(
    PCARD_EXTENSION pCard
    );

BOOLEAN 
HotPlugTimer(
    PCARD_EXTENSION pCard
    );

ULONG
HPPStrLen(
    IN PUCHAR p
    ) ;

#endif // #define __HOTPLUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\hpfcctl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   hpfcctl.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/hpfcctl.h $


Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:29a $
   $Modtime:: 8/31/00 3:31p            $

Notes:


--*/

#ifndef _HPFCCTL_
#define _HPFCCTL_

//#ifndef bit8
//#define bit8 unsigned char
//#endif

//#ifndef bit16
//#define bit16 unsigned short
//#endif

//#ifndef bit32
//#define bit32 unsigned int
//#endif

/* IOCTL Signature */
#define HP_FC_IOCTL_SIGNATURE "HHBA5100"

/* List of Control Codes */
#define HP_FC_IOCTL_GET_DRIVER_INFO			1
#define HP_FC_IOCTL_GET_CARD_CONFIG			2
#define HP_FC_IOCTL_GET_DEVICE_CONFIG		3
#define HP_FC_IOCTL_GET_LINK_STATISTICS		4
#define HP_FC_IOCTL_GET_DEVICE_STATISTICS	5
#define HP_FC_IOCTL_LINK_RESET				6
#define HP_FC_IOCTL_DEVICE_RESET			7
#define HP_FC_IOCTL_REG_READ				8
#define HP_FC_IOCTL_REG_WRITE				9

/* Data structure for Control Code HP_FC_IOCTL_GET_DRIVER_INFO */
#define MAX_HP_FC_DRIVER_NAME_SIZE			16
#define MAX_HP_FC_DRIVER_DESC_SIZE			64

typedef struct hpFcDriverInformation_s {
	os_bit8		DriverName[MAX_HP_FC_DRIVER_NAME_SIZE];
	os_bit8		DriverDescription[MAX_HP_FC_DRIVER_DESC_SIZE];
	os_bit16	MajorRev;
	os_bit16	MinorRev;
} hpFcDriverInformation_t;

/* Data structure for Control Code HP_FC_IOCTL_GET_CARD_CONFIG */
typedef struct hpFcCardConfiguration_s {
	os_bit8		PCIBusNumber;
	os_bit8		PCIDeviceNumber;
	os_bit8		PCIFunctionNumber;
	os_bit32	PCIBaseAddress0;
	os_bit32	PCIBaseAddress0Size;
	os_bit32	PCIBaseAddress1;
	os_bit32	PCIBaseAddress1Size;
	os_bit32	PCIBaseAddress2;
	os_bit32	PCIBaseAddress2Size;
	os_bit32	PCIBaseAddress3;
	os_bit32	PCIBaseAddress3Size;
	os_bit32	PCIBaseAddress4;
	os_bit32	PCIBaseAddress4Size;
	os_bit32	PCIBaseAddress5;
	os_bit32	PCIBaseAddress5Size;
	os_bit32	PCIRomBaseAddress;
	os_bit32	PCIRomSize;
	os_bit8		NodeName[8];
	os_bit8		PortName[8];
	os_bit8		Topology;
	os_bit8		HardAddress;
	os_bit32	NportId;
} hpFcCardConfiguration_t;

/* Possible definitions for Topology */
#define HP_FC_TOPO_UNKNOWN		0
#define HP_FC_POINT_TO_POINT	1
#define HP_FC_FABRIC			2
#define HP_FC_PRIVATE_LOOP		3
#define HP_FC_PUBLIC_LOOP		4

/* Data structures for Control Code HP_FC_IOCTL_GET_DEVICE_CONFIG */
typedef	struct hpFcNPortCmnParam_s {
    os_bit32 FC_PH_Version__BB_Credit;
    os_bit32 Common_Features__BB_Recv_Data_Field_Size;
    os_bit32 N_Port_Total_Concurrent_Sequences__RO_by_Info_Category;
    os_bit32 E_D_TOV;
} hpFcNPortCmnParam_t;

typedef	struct hpFcNPortClassParam_s {
    os_bit32 Class_Validity__Service_Options__Initiator_Control_Flags;
    os_bit32 Recipient_Control_Flags__Receive_Data_Size;
    os_bit32 Concurrent_Sequences__EE_Credit;
    os_bit32 Open_Sequences_per_Exchange;
} hpFcNPortClassParam_t;

typedef struct hpFcDeviceConfiguration_s {
	SCSI_ADDRESS	DeviceAddress;
	os_bit8			NodeName[8];
	os_bit8			PortName[8];
	os_bit32		NportId;
	os_bit8			HardAddress;
	os_bit8			Present;
	os_bit8			LoggedIn;
	os_bit32		ClassOfService;
	os_bit32		MaxFrameSize;
	os_bit8			Lun[8];         //Store the FCP Lun data
	hpFcNPortCmnParam_t CmnParams;
	hpFcNPortClassParam_t Class1Params;
	hpFcNPortClassParam_t Class2Params;
	hpFcNPortClassParam_t Class3Params;
} hpFcDeviceConfiguration_t;

/* Data structure for Control Code HP_FC_IOCTL_GET_LINK_STATISTICS */
typedef	struct hpFcLinkStatistics_s {
	os_bit8		LinkState;
	os_bit32	LinkDownCount;
	os_bit32	ResetCount;
} hpFcLinkStatistics_t;

/* Data structure for Control Code HP_FC_IOCTL_LINK_RESET */
typedef struct hpFcDeviceStatistics_s {
	SCSI_ADDRESS	DeviceAddress;
	os_bit32		LoginRetries;
	os_bit32		ReadsRequested;
	os_bit32		ReadsCompleted;
	os_bit32		ReadsFailed;
	os_bit32		BytesReadUpper32;
	os_bit32		BytesReadLower32;
	os_bit32		WritesRequested;
	os_bit32		WritesCompleted;
	os_bit32		WritesFailed;
	os_bit32		BytesWrittenUpper32;
	os_bit32		BytesWrittenLower32;
	os_bit32		NonRWRequested;
	os_bit32		NonRWCompleted;
	os_bit32		NonRWFailures;
} hpFcDeviceStatistics_t;

/* Data structure for Control Code HP_FC_IOCTL_DEVICE_RESET */
typedef struct hpFcDeviceReset_s {
	SCSI_ADDRESS	DeviceAddress;
} hpFcDeviceReset_t;

/* Data structure for Control Code HP_FC_IOCTL_REG_READ */
typedef struct hpFcRegRead_s {
	os_bit32	RegOffset;
	os_bit32	RegData;
} hpFcRegRead_t;

/* Data structure for Control Code HP_FC_IOCTL_REG_WRITE */
typedef struct hpFcRegWrite_s {
	os_bit32	RegOffset;
	os_bit32	RegData;
} hpFcRegWrite_t;

/* Return Codes */
#define HP_FC_RTN_OK					0
#define HP_FC_RTN_FAILED				1
#define HP_FC_RTN_BAD_CTL_CODE			2
#define HP_FC_RTN_INSUFFICIENT_BUFFER	3
#define HP_FC_RTN_INVALID_DEVICE		4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\i21285.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/I21285.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  specific to the Intel 21285 StrongARM SA-110 to PCI Bridge

Reference Documents:

  21285 Core Logic for SA-110 Microprocessor
    Datasheet - September 1998

--*/

#ifndef __I21285_H__
#define __I21285_H__

/*+
PCI Configuration Mapping
-*/

typedef struct I21285_Config_s
               I21285_Config_t;

struct I21285_Config_s
       {
         os_bit32 DeviceID_VendorID;
         os_bit32 Status_Command;
         os_bit32 ClassCode_RevisionID;
         os_bit32 BIST_HeaderType_LatencyTimer_CacheLineSize;
         os_bit32 CSR_Memory_Base_Address;
         os_bit32 CSR_IO_Base_Address;
         os_bit32 SDRAM_Base_Address;
         os_bit32 reserved_1;
         os_bit32 reserved_2;
         os_bit32 reserved_3;
         os_bit32 CardBus_CIS_Pointer;
         os_bit32 SubsystemID_SubsystemVendorID;
         os_bit32 Expansion_ROM_Base_Address;
         os_bit32 reserved_CapPtr;
         os_bit32 reserved_4;
         os_bit32 MaxLat_MinGnt_InterruptPin_InterruptLine;
         os_bit8  reserved_5[0x70-0x40];
         os_bit32 PMCapabilities_PMCapabilityIdentifier;
         os_bit32 Data_reserved_PMControlAndStatus;
       };

#define I21285_Config_DeviceID_MASK                                                  (os_bit32)0xFFFF0000
#define I21285_Config_DeviceID_21285                                                 (os_bit32)0x10650000

#define I21285_Config_VendorID_MASK                                                  (os_bit32)0x0000FFFF
#define I21285_Config_VendorID_Intel                                                 (os_bit32)0x00001011

#define I21285_Config_Status_MASK                                                    (os_bit32)0xFFFF0000

#define I21285_Config_Status_Parity_Error                                            (os_bit32)0x80000000
#define I21285_Config_Status_Signaled_System_Error                                   (os_bit32)0x40000000
#define I21285_Config_Status_Received_Master_Abort                                   (os_bit32)0x20000000
#define I21285_Config_Status_Received_Target_Abort                                   (os_bit32)0x10000000
#define I21285_Config_Status_Signaled_Target_Abort                                   (os_bit32)0x08000000

#define I21285_Config_Status_DEVSEL_Timing_MASK                                      (os_bit32)0x06000000
#define I21285_Config_Status_DEVSEL_Timing_Medium                                    (os_bit32)0x02000000

#define I21285_Config_Status_Data_Parity_Error_Detected                              (os_bit32)0x01000000
#define I21285_Config_Status_Fast_Back_To_Back_Capable                               (os_bit32)0x00800000
#define I21285_Config_Status_UDF_Supported                                           (os_bit32)0x00400000
#define I21285_Config_Status_66MHz_Capable                                           (os_bit32)0x00200000

#define I21285_Config_Command_MASK                                                   (os_bit32)0x0000FFFF
#define I21285_Config_Command_Fast_Back_To_Back_Enable                               (os_bit32)0x00000200
#define I21285_Config_Command_SERR_Enable                                            (os_bit32)0x00000100
#define I21285_Config_Command_Wait_Cycle_Control                                     (os_bit32)0x00000080
#define I21285_Config_Command_Parity_Error_Response                                  (os_bit32)0x00000040
#define I21285_Config_Command_VGA_Palette_Snoop_Enable                               (os_bit32)0x00000020
#define I21285_Config_Command_Memory_Write_And_Invalidate_Enable                     (os_bit32)0x00000010
#define I21285_Config_Command_Special_Cycle_Enable                                   (os_bit32)0x00000008
#define I21285_Config_Command_Master_Enable                                          (os_bit32)0x00000004
#define I21285_Config_Command_Memory_Space_Enable                                    (os_bit32)0x00000002
#define I21285_Config_Command_IO_Space_Enable                                        (os_bit32)0x00000001

#define I21285_Config_ClassCode_MASK                                                 (os_bit32)0xFFFFFF00
#define I21285_Config_ClassCode_BaseClassCode_MASK                                   (os_bit32)0xFF000000
#define I21285_Config_ClassCode_BaseClassCode_SHIFT                                  (os_bit32)0x18
#define I21285_Config_ClassCode_SubClassCode_MASK                                    (os_bit32)0x00FF0000
#define I21285_Config_ClassCode_SubClassCode_SHIFT                                   (os_bit32)0x10
#define I21285_Config_ClassCode_ProgIF_MASK                                          (os_bit32)0x0000FF00
#define I21285_Config_ClassCode_ProgIF_SHIFT                                         (os_bit32)0x08

#define I21285_Config_RevisionID_MASK                                                (os_bit32)0x000000FF
#define I21285_Config_RevisionID_SHIFT                                               (os_bit32)0x00

#define I21285_Config_BIST_MASK                                                      (os_bit32)0xFF000000
#define I21285_Config_BIST_SHIFT                                                     (os_bit32)0x18
#define I21285_Config_HeaderType_MASK                                                (os_bit32)0x00FF0000
#define I21285_Config_HeaderType_SHIFT                                               (os_bit32)0x10
#define I21285_Config_LatencyTimer_MASK                                              (os_bit32)0x0000FF00
#define I21285_Config_LatencyTimer_SHIFT                                             (os_bit32)0x08
#define I21285_Config_CacheLineSize_MASK                                             (os_bit32)0x000000FF
#define I21285_Config_CacheLineSize_SHIFT                                            (os_bit32)0x00

#define I21285_Config_CapPtr_MASK                                                    (os_bit32)0x000000FF
#define I21285_Config_CapPtr_SHIFT                                                   (os_bit32)0x00

#define I21285_Config_SubsystemID_MASK                                               (os_bit32)0xFFFF0000
#define I21285_Config_SubsystemVendorID_MASK                                         (os_bit32)0x0000FFFF

#define I21285_Config_MaxLat_MASK                                                    (os_bit32)0xFF000000
#define I21285_Config_MaxLat_SHIFT                                                   (os_bit32)0x18

#define I21285_Config_MinGnt_MASK                                                    (os_bit32)0x00FF0000
#define I21285_Config_MinGnt_SHIFT                                                   (os_bit32)0x10

#define I21285_Config_InterruptPin_MASK                                              (os_bit32)0x0000FF00
#define I21285_Config_InterruptPin_SHIFT                                             (os_bit32)0x08

#define I21285_Config_InterruptLine_MASK                                             (os_bit32)0x000000FF
#define I21285_Config_InterruptLine_SHIFT                                            (os_bit32)0x00

#define I21285_Config_PMCapabilities_MASK                                            (os_bit32)0xFFFF0000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D3_Cold                       (os_bit32)0x80000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D3_Hot                        (os_bit32)0x40000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D2                            (os_bit32)0x20000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D1                            (os_bit32)0x10000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D0                            (os_bit32)0x08000000
#define I21285_Config_PMCapabilities_PME_D2_Supported                                (os_bit32)0x04000000
#define I21285_Config_PMCapabilities_PME_D1_Supported                                (os_bit32)0x02000000
#define I21285_Config_PMCapabilities_DSI_Required                                    (os_bit32)0x00200000
#define I21285_Config_PMCapabilities_Aux_Power_Source                                (os_bit32)0x00100000
#define I21285_Config_PMCapabilities_PME_Clock                                       (os_bit32)0x00080000
#define I21285_Config_PMCapabilities_PM_Version_MASK                                 (os_bit32)0x00070000
#define I21285_Config_PMCapabilities_PM_Version_SHIFT                                (os_bit32)0x10

#define I21285_Config_PMCapabilityIdentifier_NextItemPtr_MASK                        (os_bit32)0x0000FF00
#define I21285_Config_PMCapabilityIdentifier_NextItemPtr_SHIFT                       (os_bit32)0x08

#define I21285_Config_PMCapabilityIdentifier_CapID_MASK                              (os_bit32)0x000000FF
#define I21285_Config_PMCapabilityIdentifier_CapID_SHIFT                             (os_bit32)0x00
#define I21285_Config_PMCapabilityIdentifier_CapID_PM                                (os_bit32)0x00000001

#define I21285_Config_Data_MASK                                                      (os_bit32)0xFF000000
#define I21285_Config_Data_SHIFT                                                     (os_bit32)0x18

#define I21285_Config_PMControlAndStatus_MASK                                        (os_bit32)0x0000FFFF
#define I21285_Config_PMControlAndStatus_PME_Status                                  (os_bit32)0x00008000
#define I21285_Config_PMControlAndStatus_Data_Scale_MASK                             (os_bit32)0x00006000
#define I21285_Config_PMControlAndStatus_Data_Scale_SHIFT                            (os_bit32)0x0D
#define I21285_Config_PMControlAndStatus_Data_Select_MASK                            (os_bit32)0x00001E00
#define I21285_Config_PMControlAndStatus_Data_Select_SHIFT                           (os_bit32)0x09
#define I21285_Config_PMControlAndStatus_PME_En                                      (os_bit32)0x00000100
#define I21285_Config_PMControlAndStatus_Power_State_MASK                            (os_bit32)0x00000003
#define I21285_Config_PMControlAndStatus_Power_State_D0                              (os_bit32)0x00000000
#define I21285_Config_PMControlAndStatus_Power_State_D1                              (os_bit32)0x00000001
#define I21285_Config_PMControlAndStatus_Power_State_D2                              (os_bit32)0x00000002
#define I21285_Config_PMControlAndStatus_Power_State_D3                              (os_bit32)0x00000003

/*+
PCI Control and Status Registers
-*/

typedef struct I21285_PCI_CSR_s
               I21285_PCI_CSR_t;

struct I21285_PCI_CSR_s
       {
         os_bit8  reserved_1[0x30-0x00];
         os_bit32 Outbound_Interrupt_Status;
         os_bit32 Outbound_Interrupt_Mask;
         os_bit8  reserved_2[0x40-0x38];
         os_bit32 Inbound_FIFO;
         os_bit32 Outbound_FIFO;
         os_bit8  reserved_3[0x50-0x48];
         os_bit32 Mailbox_0;
         os_bit32 Mailbox_1;
         os_bit32 Mailbox_2;
         os_bit32 Mailbox_3;
         os_bit32 Doorbell;
         os_bit32 Doorbell_Setup;
         os_bit32 ROM_Write_Byte_Address;
         os_bit8  reserved_4[0x80-0x6C];
       };

#define I21285_PCI_CSR_Outbound_Interrupt_Status_Outbound_Post_List_Interrupt        (os_bit32)0x00000008
#define I21285_PCI_CSR_Outbound_Interrupt_Status_Doorbell_Interrupt                  (os_bit32)0x00000004

#define I21285_PCI_CSR_Outbound_Interrupt_Mask_Outbound_Post_List_Interrupt          (os_bit32)0x00000008
#define I21285_PCI_CSR_Outbound_Interrupt_Mask_Doorbell_Interrupt                    (os_bit32)0x00000004

#define I21285_PCI_CSR_ROM_Write_Byte_Address_MASK                                   (os_bit32)0x00000003
#define I21285_PCI_CSR_ROM_Write_Byte_Address_SHIFT                                  (os_bit32)0x00

/*+
SA-110 Control and Status Registers
-*/

typedef struct I21285_SA110_CSR_s
               I21285_SA110_CSR_t;

struct I21285_SA110_CSR_s
       {
         os_bit8  reserved_01[0x080-0x000];
         os_bit32 DMA_Channel_1_Byte_Count;
         os_bit32 DMA_Channel_1_PCI_Address;
         os_bit32 DMA_Channel_1_SDRAM_Address;
         os_bit32 DMA_Channel_1_Descriptor_Pointer;
         os_bit32 DMA_Channel_1_Control;
         os_bit32 DMA_Channel_1_DAC_Address;
         os_bit8  reserved_02[0x0A0-0x098];
         os_bit32 DMA_Channel_2_Byte_Count;
         os_bit32 DMA_Channel_2_PCI_Address;
         os_bit32 DMA_Channel_2_SDRAM_Address;
         os_bit32 DMA_Channel_2_Descriptor_Pointer;
         os_bit32 DMA_Channel_2_Control;
         os_bit32 DMA_Channel_2_DAC_Address;
         os_bit8  reserved_03[0x0F8-0x0B8];
         os_bit32 CSR_Base_Address_Mask;
         os_bit32 CSR_Base_Address_Offset;
         os_bit32 SDRAM_Base_Address_Mask;
         os_bit32 SDRAM_Base_Address_Offset;
         os_bit32 Expansion_ROM_Base_Address_Mask;
         os_bit32 SDRAM_Timing;
         os_bit32 SDRAM_Address_And_Size_Array_0;
         os_bit32 SDRAM_Address_And_Size_Array_1;
         os_bit32 SDRAM_Address_And_Size_Array_2;
         os_bit32 SDRAM_Address_And_Size_Array_3;
         os_bit32 Inbound_Free_List_Head_Pointer;
         os_bit32 Inbound_Post_List_Tail_Pointer;
         os_bit32 Outbound_Post_List_Head_Pointer;
         os_bit32 Outbound_Free_List_Tail_Pointer;
         os_bit32 Inbound_Free_List_Count;
         os_bit32 Outbound_Post_List_Count;
         os_bit32 Inbound_Post_List_Count;
         os_bit32 SA110_Control;
         os_bit32 PCI_Address_Extension;
         os_bit32 Prefetchable_Memory_Range;
         os_bit32 XBus_Cycle_Arbiter;
         os_bit32 XBus_IO_Strobe_Mask;
         os_bit32 Doorbell_PCI_Mask;
         os_bit32 Doorbell_SA110_Mask;
         os_bit8  reserved_04[0x160-0x158];
         os_bit32 UARTDR;
         os_bit32 RXSTAT;
         os_bit32 H_UBRLCR;
         os_bit32 M_UBRLCR;
         os_bit32 L_UBRLCR;
         os_bit32 UARTCON;
         os_bit32 UARTFLG;
         os_bit32 reserved_05;
         os_bit32 IRQStatus;
         os_bit32 IRQRawStatus;
         os_bit32 IRQEnable_IRQEnableSet;
         os_bit32 IRQEnableClear;
         os_bit32 IRQSoft;
         os_bit8  reserved_06[0x200-0x194];
         os_bit32 SA110_DAC_Address_1;
         os_bit32 SA110_DAC_Address_2;
         os_bit32 SA110_DAC_Control;
         os_bit32 PCI_Address_31_Alias;
         os_bit8  reserved_07[0x280-0x210];
         os_bit32 FIQStatus;
         os_bit32 FIQRawStatus;
         os_bit32 FIQEnable_FIQEnableSet;
         os_bit32 FIQEnableClear;
         os_bit32 FIQSoft;
         os_bit8  reserved_08[0x300-0x294];
         os_bit32 Timer1Load;
         os_bit32 Timer1Value;
         os_bit32 Timer1Control;
         os_bit32 Timer1Clear;
         os_bit8  reserved_09[0x320-0x310];
         os_bit32 Timer2Load;
         os_bit32 Timer2Value;
         os_bit32 Timer2Control;
         os_bit32 Timer2Clear;
         os_bit8  reserved_10[0x340-0x330];
         os_bit32 Timer3Load;
         os_bit32 Timer3Value;
         os_bit32 Timer3Control;
         os_bit32 Timer3Clear;
         os_bit8  reserved_11[0x360-0x350];
         os_bit32 Timer4Load;
         os_bit32 Timer4Value;
         os_bit32 Timer4Control;
         os_bit32 Timer4Clear;
         os_bit8  reserved_12[0x800-0x370];
       };

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_End_Of_Chain                       (os_bit32)0x80000000

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Direction_MASK                     (os_bit32)0x40000000
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Direction_PCI_To_SDRAM             (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Direction_SDRAM_To_PCI             (os_bit32)0x40000000

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Interburst_Delay_MASK              (os_bit32)0x3F000000
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Interburst_Delay_SHIFT             (os_bit32)0x18

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_MASK                               (os_bit32)0x00FFFFFF
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_SHIFT                              (os_bit32)0x00

#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_Control_MASK                    (os_bit32)0x80000000
#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_Control_Next_Descriptor         (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_Control_DAC_Address             (os_bit32)0x80000000

#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_MASK                            (os_bit32)0x0FFFFFFF
#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_SHIFT                           (os_bit32)0x00

#define I21285_SA110_CSR_DMA_Channel_n_Descriptor_Pointer_MASK                       (os_bit32)0x0FFFFFF0
#define I21285_SA110_CSR_DMA_Channel_n_Descriptor_Pointer_SHIFT                      (os_bit32)0x00

#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_MASK                (os_bit32)0x00070000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_1_DWORD             (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_2_DWORD             (os_bit32)0x00010000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_4_DWORD             (os_bit32)0x00020000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_8_DWORD             (os_bit32)0x00030000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_16_DWORD            (os_bit32)0x00040000

#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Length_MASK                  (os_bit32)0x00008000
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Length_8_DWORDS              (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Length_16_DWORDS             (os_bit32)0x00008000

#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_MASK        (os_bit32)0x00000300
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_4           (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_8           (os_bit32)0x00000100
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_16          (os_bit32)0x00000200
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_32          (os_bit32)0x00000300

#define I21285_SA110_CSR_DMA_Channel_n_Control_Chain_Done                            (os_bit32)0x00000080

#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_MASK                    (os_bit32)0x00000060
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read             (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read_Line        (os_bit32)0x00000020
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read_Multiple_10 (os_bit32)0x00000040
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read_Multiple_11 (os_bit32)0x00000060

#define I21285_SA110_CSR_DMA_Channel_n_Control_Initial_Descriptor_In_Register        (os_bit32)0x00000010

#define I21285_SA110_CSR_DMA_Channel_n_Control_Channel_Error                         (os_bit32)0x00000008

#define I21285_SA110_CSR_DMA_Channel_n_Control_Channel_Transfer_Done                 (os_bit32)0x00000004

#define I21285_SA110_CSR_DMA_Channel_n_Control_Channel_Enable                        (os_bit32)0x00000001

#define I21285_SA110_CSR_CSR_Base_Address_Mask_MASK                                  (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_128B                                  (os_bit32)0x00000000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_512KB                                 (os_bit32)0x00040000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_1MB                                   (os_bit32)0x000C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_2MB                                   (os_bit32)0x001C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_4MB                                   (os_bit32)0x003C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_8MB                                   (os_bit32)0x007C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_16MB                                  (os_bit32)0x00FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_32MB                                  (os_bit32)0x01FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_64MB                                  (os_bit32)0x03FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_128MB                                 (os_bit32)0x07FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_256MB                                 (os_bit32)0x0FFC0000

#define I21285_SA110_CSR_CSR_Base_Address_Offset_MASK                                (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_CSR_Base_Address_Offset_SHIFT                               (os_bit32)0x00

#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_Window_Disable                      (os_bit32)0x80000000

#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_MASK                                (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_256KB                               (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_512KB                               (os_bit32)0x00040000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_1MB                                 (os_bit32)0x000C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_2MB                                 (os_bit32)0x001C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_4MB                                 (os_bit32)0x003C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_8MB                                 (os_bit32)0x007C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_16MB                                (os_bit32)0x00FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_32MB                                (os_bit32)0x01FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_64MB                                (os_bit32)0x03FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_128MB                               (os_bit32)0x07FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_256MB                               (os_bit32)0x0FFC0000

#define I21285_SA110_CSR_SDRAM_Base_Address_Offset_MASK                              (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Offset_SHIFT                             (os_bit32)0x00

#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_Window_Disable              (os_bit32)0x80000000

#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_MASK                        (os_bit32)0x00F00000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_1MB                         (os_bit32)0x00000000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_2MB                         (os_bit32)0x00100000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_4MB                         (os_bit32)0x00300000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_8MB                         (os_bit32)0x00700000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_16MB                        (os_bit32)0x00F00000

#define I21285_SA110_CSR_SDRAM_Timing_Refresh_Interval_MASK                          (os_bit32)0x003F0000
#define I21285_SA110_CSR_SDRAM_Timing_Refresh_Interval_SHIFT                         (os_bit32)0x10

#define I21285_SA110_CSR_SDRAM_Timing_SA110_Prime                                    (os_bit32)0x00002000

#define I21285_SA110_CSR_SDRAM_Timing_Parity_Enable                                  (os_bit32)0x00001000

#define I21285_SA110_CSR_SDRAM_Timing_Command_Drive_Time_MASK                        (os_bit32)0x00000800
#define I21285_SA110_CSR_SDRAM_Timing_Command_Drive_Time_Same_Cycle                  (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Timing_Command_Drive_Time_1_Cycle                     (os_bit32)0x00000800

#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_MASK                            (os_bit32)0x00000700
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_4_Cycles                        (os_bit32)0x00000100
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_5_Cycles                        (os_bit32)0x00000200
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_6_Cycles                        (os_bit32)0x00000300
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_7_Cycles                        (os_bit32)0x00000400
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_8_Cycles                        (os_bit32)0x00000500
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_9_Cycles                        (os_bit32)0x00000600
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_10_Cycles                       (os_bit32)0x00000700

#define I21285_SA110_CSR_SDRAM_Timing_CAS_Latency_MASK                               (os_bit32)0x000000C0
#define I21285_SA110_CSR_SDRAM_Timing_CAS_Latency_2_Cycles                           (os_bit32)0x00000080
#define I21285_SA110_CSR_SDRAM_Timing_CAS_Latency_3_Cycles                           (os_bit32)0x000000C0

#define I21285_SA110_CSR_SDRAM_Timing_RAS_To_CAS_Delay_MASK                          (os_bit32)0x00000030
#define I21285_SA110_CSR_SDRAM_Timing_RAS_To_CAS_Delay_2_Cycles                      (os_bit32)0x00000020
#define I21285_SA110_CSR_SDRAM_Timing_RAS_To_CAS_Delay_3_Cycles                      (os_bit32)0x00000030

#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_MASK                      (os_bit32)0x0000000C
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_2_Cycles                  (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_3_Cycles                  (os_bit32)0x00000004
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_4_Cycles                  (os_bit32)0x00000008
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_5_Cycles                  (os_bit32)0x0000000C

#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_MASK                        (os_bit32)0x00000003
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_1_Cycle                     (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_2_Cycles                    (os_bit32)0x00000001
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_3_Cycles                    (os_bit32)0x00000002
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_4_Cycles                    (os_bit32)0x00000003

#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Base_MASK                    (os_bit32)0x0FF00000
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Base_SHIFT                   (os_bit32)0x00

#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Address_Multiplex_MASK       (os_bit32)0x00000070
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Address_Multiplex_SHIFT      (os_bit32)0x04

#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_MASK                    (os_bit32)0x00000007
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_Disabled                (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_1MB                     (os_bit32)0x00000001
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_2MB                     (os_bit32)0x00000002
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_4MB                     (os_bit32)0x00000003
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_8MB                     (os_bit32)0x00000004
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_16MB                    (os_bit32)0x00000005
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_32MB                    (os_bit32)0x00000006
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_64MB                    (os_bit32)0x00000007

#define I21285_SA110_CSR_Inbound_Free_List_Head_Pointer_MASK                         (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Inbound_Free_List_Head_Pointer_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_Inbound_Post_List_Head_Pointer_MASK                         (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Inbound_Post_List_Head_Pointer_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_Outbound_Post_List_Head_Pointer_MASK                        (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Outbound_Post_List_Head_Pointer_SHIFT                       (os_bit32)0x00

#define I21285_SA110_CSR_Outbound_Free_List_Head_Pointer_MASK                        (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Outbound_Free_List_Head_Pointer_SHIFT                       (os_bit32)0x00

#define I21285_SA110_CSR_Inbound_Free_List_Count_MASK                                (os_bit32)0x0000FFFF
#define I21285_SA110_CSR_Inbound_Free_List_Count_SHIFT                               (os_bit32)0x00

#define I21285_SA110_CSR_Outbound_Post_List_Count_MASK                               (os_bit32)0x0000FFFF
#define I21285_SA110_CSR_Outbound_Post_List_Count_SHIFT                              (os_bit32)0x00

#define I21285_SA110_CSR_Inbound_Post_List_Count_MASK                                (os_bit32)0x0000FFFF
#define I21285_SA110_CSR_Inbound_Post_List_Count_SHIFT                               (os_bit32)0x00

#define I21285_SA110_CSR_SA110_Control_PCI_Central_Function                          (os_bit32)0x80000000

#define I21285_SA110_CSR_SA110_Control_XCS_Direction_MASK                            (os_bit32)0x70000000
#define I21285_SA110_CSR_SA110_Control_XCS_Direction_SHIFT                           (os_bit32)0x1C

#define I21285_SA110_CSR_SA110_Control_ROM_Tristate_Time_MASK                        (os_bit32)0x0F000000
#define I21285_SA110_CSR_SA110_Control_ROM_Tristate_Time_SHIFT                       (os_bit32)0x18

#define I21285_SA110_CSR_SA110_Control_ROM_Burst_Time_MASK                           (os_bit32)0x00F00000
#define I21285_SA110_CSR_SA110_Control_ROM_Burst_Time_SHIFT                          (os_bit32)0x14

#define I21285_SA110_CSR_SA110_Control_ROM_Access_Time_MASK                          (os_bit32)0x000F0000
#define I21285_SA110_CSR_SA110_Control_ROM_Access_Time_SHIFT                         (os_bit32)0x10

#define I21285_SA110_CSR_SA110_Control_ROM_Width_MASK                                (os_bit32)0x0000C000
#define I21285_SA110_CSR_SA110_Control_ROM_Width_Byte_Width                          (os_bit32)0x0000C000
#define I21285_SA110_CSR_SA110_Control_ROM_Width_Word_Width                          (os_bit32)0x00004000
#define I21285_SA110_CSR_SA110_Control_ROM_Width_Dword_Width                         (os_bit32)0x00008000

#define I21285_SA110_CSR_SA110_Control_Watchdog_Enable                               (os_bit32)0x00002000

#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_MASK                            (os_bit32)0x00001C00
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_256_Entries                     (os_bit32)0x00000000
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_512_Entries                     (os_bit32)0x00000400
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_1K_Entries                      (os_bit32)0x00000800
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_2K_Entries                      (os_bit32)0x00000C00
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_4K_Entries                      (os_bit32)0x00001000
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_8K_Entries                      (os_bit32)0x00001400
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_16K_Entries                     (os_bit32)0x00001800
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_32K_Entries                     (os_bit32)0x00001C00

#define I21285_SA110_CSR_SA110_Control_PCI_Not_Reset                                 (os_bit32)0x00000200

#define I21285_SA110_CSR_SA110_Control_Discard_Timer_Expired                         (os_bit32)0x00000100

#define I21285_SA110_CSR_SA110_Control_DMA_SDRAM_Parity_Error                        (os_bit32)0x00000040

#define I21285_SA110_CSR_SA110_Control_PCI_SDRAM_Parity_Error                        (os_bit32)0x00000020

#define I21285_SA110_CSR_SA110_Control_SA110_SDRAM_Parity_Error                      (os_bit32)0x00000010

#define I21285_SA110_CSR_SA110_Control_Received_SERR                                 (os_bit32)0x00000008

#define I21285_SA110_CSR_SA110_Control_Assert_SERR                                   (os_bit32)0x00000002

#define I21285_SA110_CSR_SA110_Control_Initialize_Complete                           (os_bit32)0x00000001

#define I21285_SA110_CSR_PCI_Address_Extension_PCI_IO_Upper_Address_Field_MASK       (os_bit32)0xFFFF0000
#define I21285_SA110_CSR_PCI_Address_Extension_PCI_IO_Upper_Address_Field_SHIFT      (os_bit32)0x00

#define I21285_SA110_CSR_PCI_Address_Extension_PCI_Memory_Bit_31_MASK                (os_bit32)0x00008000
#define I21285_SA110_CSR_PCI_Address_Extension_PCI_Memory_Bit_31_SHIFT               (os_bit32)0x0F

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Base_Address_MASK                 (os_bit32)0x7FF00000
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Base_Address_SHIFT                (os_bit32)0x00

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Mask_MASK                         (os_bit32)0x0007FF00
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Mask_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_MASK              (os_bit32)0x0000001C
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_1_DWORD           (os_bit32)0x00000000
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_2_DWORDS          (os_bit32)0x00000004
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_4_DWORDS          (os_bit32)0x00000008
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_8_DWORDS          (os_bit32)0x0000000C
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_16_DWORDS         (os_bit32)0x00000010
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_32_DWORDS         (os_bit32)0x00000014

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Type_MASK                (os_bit32)0x00000002
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Type_Read_Line           (os_bit32)0x00000000
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Type_Read_Multiple       (os_bit32)0x00000002

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Range_Enable             (os_bit32)0x00000001

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_PCI_Interrupt_Request                    (os_bit32)0x80000000

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_XBus_Chip_Select_MASK                    (os_bit32)0x70000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_XBus_Chip_Select_SHIFT                   (os_bit32)0x1C

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Interrupt_Input_Level_MASK               (os_bit32)0x0F000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Interrupt_Input_Level_SHIFT              (os_bit32)0x18

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_PCI_Arbiter                              (os_bit32)0x00800000

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_21285_MASK                      (os_bit32)0x00000010
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_21285_Low                       (os_bit32)0x00000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_21285_High                      (os_bit32)0x00000010

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_Requests_MASK                   (os_bit32)0x0000000F

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_MASK                (os_bit32)0x00003000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_1                   (os_bit32)0x00000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_2                   (os_bit32)0x00001000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_3                   (os_bit32)0x00002000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_4                   (os_bit32)0x00003000

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_n_Cycle_Length_MASK               (os_bit32)0x00000E00
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_n_Cycle_Length_SHIFT              (os_bit32)0x09

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_2_Cycle_Length_MASK               (os_bit32)0x000001C0
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_2_Cycle_Length_SHIFT              (os_bit32)0x06

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_1_Cycle_Length_MASK               (os_bit32)0x00000038
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_1_Cycle_Length_SHIFT              (os_bit32)0x03

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_0_Cycle_Length_MASK               (os_bit32)0x00000007
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_0_Cycle_Length_SHIFT              (os_bit32)0x00

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_n_Strobe_Mask_MASK                (os_bit32)0xFF000000
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_n_Strobe_Mask_SHIFT               (os_bit32)0x18

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_2_Strobe_Mask_MASK                (os_bit32)0x00FF0000
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_2_Strobe_Mask_SHIFT               (os_bit32)0x10

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_1_Strobe_Mask_MASK                (os_bit32)0x0000FF00
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_1_Strobe_Mask_SHIFT               (os_bit32)0x08

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_0_Strobe_Mask_MASK                (os_bit32)0x000000FF
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_0_Strobe_Mask_SHIFT               (os_bit32)0x00

#define I21285_SA110_CSR_UARTDR_Data_MASK                                            (os_bit32)0x000000FF
#define I21285_SA110_CSR_UARTDR_Data_SHIFT                                           (os_bit32)0x00

#define I21285_SA110_CSR_RXSTAT_Overrun_Error                                        (os_bit32)0x00000004
#define I21285_SA110_CSR_RXSTAT_Parity_Error                                         (os_bit32)0x00000002
#define I21285_SA110_CSR_RXSTAT_Frame_Error                                          (os_bit32)0x00000001

#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_MASK                              (os_bit32)0x00000060
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_8_Bits                            (os_bit32)0x00000060
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_7_Bits                            (os_bit32)0x00000040
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_6_Bits                            (os_bit32)0x00000020
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_5_Bits                            (os_bit32)0x00000000

#define I21285_SA110_CSR_H_UBRLCR_Enable_FIFO                                        (os_bit32)0x00000010

#define I21285_SA110_CSR_H_UBRLCR_Stop_Bit_Select                                    (os_bit32)0x00000008

#define I21285_SA110_CSR_H_UBRLCR_Stop_Odd_Even_Select_MASK                          (os_bit32)0x00000004
#define I21285_SA110_CSR_H_UBRLCR_Stop_Odd_Even_Select_Even                          (os_bit32)0x00000004
#define I21285_SA110_CSR_H_UBRLCR_Stop_Odd_Even_Select_Odd                           (os_bit32)0x00000000

#define I21285_SA110_CSR_H_UBRLCR_Parity_Enable                                      (os_bit32)0x00000002

#define I21285_SA110_CSR_H_UBRLCR_Break                                              (os_bit32)0x00000001

#define I21285_SA110_CSR_M_UBRLCR_High_Baud_Rate_Divisor_MASK                        (os_bit32)0x0000000F
#define I21285_SA110_CSR_M_UBRLCR_High_Baud_Rate_Divisor_SHIFT                       (os_bit32)0x00

#define I21285_SA110_CSR_L_UBRLCR_Low_Baud_Rate_Divisor_MASK                         (os_bit32)0x000000FF
#define I21285_SA110_CSR_M_UBRLCR_Low_Baud_Rate_Divisor_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_UARTCON_IrDA_0_Encoding_MASK                                (os_bit32)0x00000004
#define I21285_SA110_CSR_UARTCON_IrDA_0_Encoding_3_16ths_Of_115000bps                (os_bit32)0x00000004
#define I21285_SA110_CSR_UARTCON_IrDA_0_Encoding_3_16ths_Of_Bit_Rate_Period          (os_bit32)0x00000000

#define I21285_SA110_CSR_UARTCON_SIREN_HP_SIR_Enable                                 (os_bit32)0x00000002

#define I21285_SA110_CSR_UARTCON_UART_Enable                                         (os_bit32)0x00000001

#define I21285_SA110_CSR_UARTFLG_Transmit_FIFO_Status_Busy                           (os_bit32)0x00000020

#define I21285_SA110_CSR_UARTFLG_Receive_FIFO_Status_Empty                           (os_bit32)0x00000010

#define I21285_SA110_CSR_UARTFLG_Transmitter_Busy                                    (os_bit32)0x00000008

#define I21285_SA110_CSR_TimerNLoad_MASK                                             (os_bit32)0x00FFFFFF

#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY_PER_MICROSECOND                    (os_bit32)50
#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY                                    (I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY * 1000000)
#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY_DIV_16                             (I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY / 16)
#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY_DIV_256                            (I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY / 256)

#define I21285_SA110_CSR_TimerNControl_Prescaler_MASK                                (os_bit32)0x0000000C
#define I21285_SA110_CSR_TimerNControl_Prescaler_FCLK_IN                             (os_bit32)0x00000000
#define I21285_SA110_CSR_TimerNControl_Prescaler_FCLK_IN_DIV_16                      (os_bit32)0x00000004
#define I21285_SA110_CSR_TimerNControl_Prescaler_FCLK_IN_DIV_256                     (os_bit32)0x00000008
#define I21285_SA110_CSR_TimerNControl_Prescaler_IRQ_IN_I_N                          (os_bit32)0x0000000C

#define I21285_SA110_CSR_TimerNControl_Mode_MASK                                     (os_bit32)0x00000040
#define I21285_SA110_CSR_TimerNControl_Mode_Wrap_To_00FFFFFF                         (os_bit32)0x00000000
#define I21285_SA110_CSR_TimerNControl_Mode_Wrap_To_Load_Value                       (os_bit32)0x00000040

#define I21285_SA110_CSR_TimerNControl_Enable                                        (os_bit32)0x00000080

/*+
Address Map Partitioning
-*/

#define I21285_Address_Map_SDRAM                                                     (os_bit32)0x00000000
#define I21285_Address_Map_SDRAM_Array_0_Mode_Register                               (os_bit32)0x40000000
#define I21285_Address_Map_SDRAM_Array_1_Mode_Register                               (os_bit32)0x40004000
#define I21285_Address_Map_SDRAM_Array_2_Mode_Register                               (os_bit32)0x40008000
#define I21285_Address_Map_SDRAM_Array_3_Mode_Register                               (os_bit32)0x4000C000
#define I21285_Address_Map_XBus_XCS0                                                 (os_bit32)0x40010000
#define I21285_Address_Map_XBus_XCS1                                                 (os_bit32)0x40011000
#define I21285_Address_Map_XBus_XCS2                                                 (os_bit32)0x40012000
#define I21285_Address_Map_XBus_NoCS                                                 (os_bit32)0x40013000
#define I21285_Address_Map_ROM                                                       (os_bit32)0x41000000
#define I21285_Address_Map_CSR_Space                                                 (os_bit32)0x42000000
#define I21285_Address_Map_SA110_Cache_Flush                                         (os_bit32)0x50000000
#define I21285_Address_Map_Outbound_Write_Flush                                      (os_bit32)0x78000000
#define I21285_Address_Map_PCI_IACK_Special_Space                                    (os_bit32)0x79000000
#define I21285_Address_Map_PCI_Type_1_Configuration                                  (os_bit32)0x7A000000
#define I21285_Address_Map_PCI_Type_0_Configuration                                  (os_bit32)0x7B000000
#define I21285_Address_Map_PCI_Type_0_Configuration_Address_Generation               (os_bit32)0x00C00000
#define I21285_Address_Map_PCI_Type_0_Configuration_Address_Spacing                  (os_bit32)0x00000800
#define I21285_Address_Map_PCI_Type_0_Configuration_Address_Limit                    (os_bit32)0x00010000
#define I21285_Address_Map_PCI_IO_Space                                              (os_bit32)0x7C000000
#define I21285_Address_Map_PCI_IO_Space_Offset_MASK                                  (os_bit32)0x0000FFFF
#define I21285_Address_Map_PCI_Memory_Space                                          (os_bit32)0x80000000
#define I21285_Address_Map_PCI_Memory_Space_Offset_MASK                              (os_bit32)0x7FFFFFFF

#endif /* __I21285_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\hppifevt.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
        Systems Engineering -- System Software Development (NT Dev)
        Copyright 1996-98 Compaq Computer Corporation.
        All rights reserved.

  Date:         1 August 1996 

  File:         HPPIFEVT.H  - Generic Hot Plug Event Structures

  Purpose:      This file contains all the event specific information
                  necessary to interface to a hot plug device driver.
                
                  This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Created:  11/4/97         mib       Split off of hppif3p

  Verison: 1.0
***********************************************************************/

#ifndef _HPPIFEVT_H_
#define _HPPIFEVT_H_


#pragma pack(1)

//**********************************************************************
//              EVENT MESSAGE DEFINITIONS 
//**********************************************************************


//====================================================================
//                      CPQRCMC EVENT TYPES
//====================================================================
//
//  CPQRCMC event types are used when passing events to
//    the CPQRCMC Service.
//  Events passed from drivers to the service are sent by passing
//  the events via the call back address provided in the rcmc Info 
//  struct. The driver Id from the same structure should be used 
//  for the sender id
    
//Event ID's

//   00-FF  RESERVED BY COMPAQ
#define HR_DD_STATUS_CHANGE_EVENT        0x20     
#define HR_DD_DEVICE_STATUS_EVENT        0x21
#define HR_DD_LOG_EVENT                  0x30   


#ifndef _HR_H_

//====================================================================
//            SUPPORT STRUCTURES AND DEFINES FOR MESSAGING
//====================================================================

#define HR_MAX_EVENTS         16
#define HR_EVENT_DATA_SIZE    64 

//
//  HR event types are used when passing events to the CPQRCMC Service.  
//   
#define HR_CPQRCMC_COMMAND_EXIT_EVENT    0x01    


typedef struct _HREvent {
   ULONG                 ulEventId;    // @field . 
   ULONG                 ulSenderId;   // @field .
   
   union {                               
       ULONG   ulData1;          // @field .
       
       struct {
               UCHAR  ucEventSeverity;        //@field .
               UCHAR  ucRes;                  //@field .
               USHORT usEventDataLength;      //@field .
       };     
   };        
    
   union {                        
       ULONG   ulData2;          // @field .
       
       struct {
               USHORT  usEventClass;          //@field .
               USHORT  usEventCode;           //@field .
       };     
   };        
   
   UCHAR     ulEventData[HR_EVENT_DATA_SIZE];   // @field .
   
} HR_EVENT, *PHR_EVENT;

#endif _HR_H_



/* Eventlog revision supported by this file (bHdrRev in the header structure) */

#define EVT_LOG_REVISION         0x01

/* Time stamp of event (creation or last update) */

typedef struct _evtTimeStamp
{
   BYTE     bCentury;            /* hi-order two digits of year (19 of 1996) */
   BYTE     bYear;               /* lo-order two digits of year (96 of 1996) */
   BYTE     bMonth;              /* one-based month number (1-12) */
   BYTE     bDay;                /* one-based day number (1-31) */
   BYTE     bHour;               /* zero-based hour (0-23) */
   BYTE     bMinute;             /* zero-based minute (0-59) */
} EVT_TIME_STAMP, *PEVT_TIME_STAMP;


/* Eventlog severity codes */

#define EVT_STAT_INFO            0x02     /* Status or informational message */
#define EVT_STAT_POPUP           0x03     /* Status with popup on LCD */
#define EVT_STAT_REPAIRED        0x06     /* Degraded or worse cond repaired */
#define EVT_STAT_CAUTION         0x09     /* Component in degraded condition */
#define EVT_STAT_FAILED          0x0F     /* Failed with loss of functionality */
#define EVT_STAT_CRITICAL        EVT_STAT_FAILED /* Same as Failed */

/* Chassis type defines */
#define EVT_CHASSIS_SYSTEM          0x01
#define EVT_CHASSIS_EXTERN_STORAGE  0x02
#define EVT_CHASSIS_INTERN_STORAGE  0x03

typedef struct _evtChassis
{
   UCHAR     bType;               /* Chassis Type (System==1; Extern==2) */
   UCHAR    bId;                 /* Chassis id */
                                 /*   for type 1 - chassis id (0 is system) */
                                 /*   for type 2 or 3 - adapter slot */
   UCHAR    bPort;               /* Chassis port or bus number */
} EVT_CHASSIS, *PEVT_CHASSIS;


/* Eventlog Header -- common to all event log entries */

typedef struct _evtLogHdr
{
   WORD     wEvtLength;          /* Length of event including header */
   DWORD    dwEvtNumber;         /* Unique event number (can wrap) */
   BYTE     bHdrRev;             /* Header version (see EVT_LOG_REVISION) */
   BYTE     bSeverity;           /* Event severity code */
   WORD     wClass;              /* Event class or sub-system */
   WORD     wCode;               /* Event code for event in the class */
   EVT_TIME_STAMP InitTime;      /* Time of initial event */
   EVT_TIME_STAMP UpdateTime;    /* Time of last update */
   DWORD    dwCount;             /* Occurrence count (at least 1) */
} EVT_HEADER, *PEVT_HEADER;


#define EVT_CLASS_EXPANSION_SLOT    0x09
   #define EVT_SLOT_SWITCH_OPEN        0x01
   #define EVT_SLOT_SWITCH_CLOSED      0x02
   #define EVT_SLOT_POWER_ON           0x03
   #define EVT_SLOT_POWER_OFF          0x04
   #define EVT_SLOT_FATAL_POWER_FAULT  0x05
   #define EVT_SLOT_POWER_UP_FAULT     0x06
   #define EVT_SLOT_POWER_LOSS         0x07
   #define EVT_SLOT_CANNOT_CONFIG      0x08
   #define EVT_SLOT_BOARD_FAILURE      0x09

/* Eventlog Expansion Slot structs */

typedef struct _evtExpansionSlot
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   BYTE     bSlot;               /* 0 is embedded */
} EVT_EXPANSION_SLOT, *PEVT_EXPANSION_SLOT;

#define EVT_HOT_PLUG_BUS   EVT_EXPANSION_SLOT
#define PEVT_HOT_PLUG_BUS  PEVT_EXPANSION_SLOT

#define EVT_SLOT_WRONG_TYPE         0x01
#define EVT_SLOT_WRONG_REVISION     0x02
#define EVT_SLOT_GENERAL_FAULT      0x03
#define EVT_SLOT_OUT_OF_RESOURCES   0x04

typedef struct _evtExpansionSlotConfigErr
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   BYTE     bSlot;               /* 0 is embedded */
   BYTE     bError;              /* Board configuration error */
} EVT_EXPANSION_SLOT_CONFIG_ERR, *PEVT_EXPANSION_SLOT_CONFIG_ERR;


#define EVT_NETWORK_ADAPTER         0x11
   #define EVT_NIC_ADAPTER_CHECK       0x01
   #define EVT_NIC_LINK_DOWN           0x02
   #define EVT_NIC_XMIT_TIMEOUT        0x03
   
typedef struct _evtNicError
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   UCHAR    bSlot;               /* Slot number */
   CHAR     cChassisName[1];     /* Chassis name; '\0' if undefined */
} EVT_NIC_ERROR, *PEVT_NIC_ERROR;

/* Eventlog free form data union */

typedef union _evtFreeForm
{
   EVT_NIC_ERROR                    NicErr;
} EVT_FREE_FORM, *PEVT_FREE_FORM;


/* Eventlog Entry */

typedef struct _evtLogEntry
{
   EVT_HEADER        Hdr;        /* Common header */
   EVT_FREE_FORM     Data;       /* Free form entry specific */
} EVT_LOG_ENTRY, *PEVT_LOG_ENTRY;





#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\i21554.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/I21554.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  specific to the Intel 21554 PCI to PCI Bridge

Reference Documents:

  21554 PCI-to-PCI Bridge for Embedded Applications
    Hardware Reference Manual - September 1998

--*/

#ifndef __I21554_H__
#define __I21554_H__

/*+
Configuration Space Address Map
-*/

typedef struct I21554_Primary_Interface_Config_s
               I21554_Primary_Interface_Config_t;

struct I21554_Primary_Interface_Config_s
       {
         os_bit32 DeviceID_VendorID;
         os_bit32 PrimaryStatus_PrimaryCommand;
         os_bit32 PrimaryClassCode_RevID;
         os_bit32 BIST_HeaderType_PrimaryMLT_PrimaryCLS;
         os_bit32 Primary_CSR_and_Downstream_Memory_0_BAR;
         os_bit32 Primary_CSR_IO_BAR;
         os_bit32 Downstream_IO_or_Memory_1_BAR;
         os_bit32 Downstream_Memory_2_BAR;
         os_bit32 Downstream_Memory_3_BAR;
         os_bit32 Upper_32_Bits_Downstream_Memory_3_BAR;
         os_bit32 reserved_1;
         os_bit32 SubsystemID_SubsystemVendorID;
         os_bit32 Primary_Expansion_ROM_Base_Address;
         os_bit32 reserved_CapabilitiesPointer;
         os_bit32 reserved_2;
         os_bit32 PrimaryMaxLat_PrimaryMinGnt_PrimaryInterruptPin_PrimaryInterruptLine;
       };

typedef struct I21554_Secondary_Interface_Config_s
               I21554_Secondary_Interface_Config_t;

struct I21554_Secondary_Interface_Config_s
       {
         os_bit32 DeviceID_VendorID;
         os_bit32 SecondaryStatus_SecondaryCommand;
         os_bit32 SecondaryClassCode_RevID;
         os_bit32 BIST_HeaderType_SecondaryMLT_SecondaryCLS;
         os_bit32 Secondary_CSR_Memory_BAR;
         os_bit32 Secondary_CSR_IO_BAR;
         os_bit32 Upstream_IO_or_Memory_0_BAR;
         os_bit32 Upstream_Memory_1_BAR;
         os_bit32 Upstream_Memory_2_BAR;
         os_bit32 reserved_1;
         os_bit32 reserved_2;
         os_bit32 SubsystemID_SubsystemVendorID;
         os_bit32 reserved_3;
         os_bit32 reserved_CapabilitiesPointer;
         os_bit32 reserved_4;
         os_bit32 SecondaryMaxLat_SecondaryMinGnt_SecondaryInterruptPin_SecondaryInterruptLine;
       };

typedef struct I21554_Device_Specific_Config_s
               I21554_Device_Specific_Config_t;

struct I21554_Device_Specific_Config_s
       {
         os_bit32 Downstream_Configuration_Address;
         os_bit32 Downstream_Configuration_Data;
         os_bit32 Upstream_Configuration_Address;
         os_bit32 Upstream_Configuration_Data;
         os_bit32 ConfigurationControlAndStatus_ConfigurationOwnBits;
         os_bit32 Downstream_Memory_0_Translated_Base;
         os_bit32 Downstream_IO_or_Memory_1_Translated_Base;
         os_bit32 Downstream_Memory_2_Translated_Base;
         os_bit32 Downstream_Memory_3_Translated_Base;
         os_bit32 Upstream_IO_or_Memory_0_Translated_Base;
         os_bit32 Upstream_Memory_1_Translated_Base;
         os_bit32 Downstream_Memory_0_Setup_Register;
         os_bit32 Downstream_IO_or_Memory_1_Setup_Register;
         os_bit32 Downstream_Memory_2_Setup_Register;
         os_bit32 Downstream_Memory_3_Setup_Register;
         os_bit32 Upper_32_Bits_Downstream_Memory_3_Setup_Register;
         os_bit32 Primary_Expansion_ROM_Setup_Register;
         os_bit32 Upstream_IO_or_Memory_0_Setup_Register;
         os_bit32 Upstream_Memory_1_Setup_Register;
         os_bit32 ChipControl1_ChipControl0;
         os_bit32 ArbiterControl_ChipStatus;
         os_bit32 reserved_SecondarySERRDisables_PrimarySERRDisables;
         os_bit32 Reset_Control;
         os_bit32 PowerManagementCapabilities_NextItemPtr_CapabilityID;
         os_bit32 PMData_PMCSRBSE_PowerManagementCSR;
         os_bit32 VPDAddress_NextItemPtr_CapabilityID;
         os_bit32 VPD_Data;
         os_bit32 reserved_HostSwapControl_NextItemPtr_CapabilityID;
         os_bit8  reserved[0x100-0x0F0];
       };

typedef struct I21554_Primary_Config_s
               I21554_Primary_Config_t;

struct I21554_Primary_Config_s
       {
         I21554_Primary_Interface_Config_t   Primary_Interface;
         I21554_Secondary_Interface_Config_t Secondary_Interface;
         I21554_Device_Specific_Config_t     Device_Specific;
       };

typedef struct I21554_Secondary_Config_s
               I21554_Secondary_Config_t;

struct I21554_Secondary_Config_s
       {
         I21554_Secondary_Interface_Config_t Secondary_Interface;
         I21554_Primary_Interface_Config_t   Primary_Interface;
         I21554_Device_Specific_Config_t     Device_Specific;
       };

#define I21554_Config_VendorID_MASK                                                      (os_bit32)0x0000FFFF
#define I21554_Config_VendorID_Intel                                                     (os_bit32)0x00001011

#define I21554_Config_DeviceID_MASK                                                      (os_bit32)0xFFFF0000
#define I21554_Config_DeviceID_21554                                                     (os_bit32)0x00460000

#define I21554_Config_Command_MASK                                                       (os_bit32)0x0000FFFF
#define I21554_Config_Command_IO_Space_Enable                                            (os_bit32)0x00000001
#define I21554_Config_Command_Memory_Space_Enable                                        (os_bit32)0x00000002
#define I21554_Config_Command_Master_Enable                                              (os_bit32)0x00000004
#define I21554_Config_Command_Special_Cycle_Enable                                       (os_bit32)0x00000008
#define I21554_Config_Command_Memory_Write_and_Invalidate_Enable                         (os_bit32)0x00000010
#define I21554_Config_Command_VGA_Snoop_Enable                                           (os_bit32)0x00000020
#define I21554_Config_Command_Parity_Error_Response                                      (os_bit32)0x00000040
#define I21554_Config_Command_Wait_Cycle_Control                                         (os_bit32)0x00000080
#define I21554_Config_Command_SERR_Enable                                                (os_bit32)0x00000100
#define I21554_Config_Fast_Back_to_Back_Enable                                           (os_bit32)0x00000200

#define I21554_Config_Status_MASK                                                        (os_bit32)0xFFFF0000

#define I21554_Config_Status_ECP_Support                                                 (os_bit32)0x00100000
#define I21554_Config_Status_66_MHz_Capable                                              (os_bit32)0x00200000
#define I21554_Config_Status_Fast_Back_to_Back_Capable                                   (os_bit32)0x00800000
#define I21554_Config_Status_Data_Parity_Detected                                        (os_bit32)0x01000000

#define I21554_Config_Status_DEVSEL_timing_MASK                                          (os_bit32)0x06000000
#define I21554_Config_Status_DEVSEL_timing_SHIFT                                         (os_bit32)0x19

#define I21554_Config_Status_Signaled_Target_Abort                                       (os_bit32)0x08000000
#define I21554_Config_Status_Received_Target_Abort                                       (os_bit32)0x10000000
#define I21554_Config_Status_Received_Master_Abort                                       (os_bit32)0x20000000
#define I21554_Config_Status_Signaled_System_Error                                       (os_bit32)0x40000000
#define I21554_Config_Status_Detected_Parity_Error                                       (os_bit32)0x80000000

#define I21554_Config_RevID_MASK                                                         (os_bit32)0x000000FF
#define I21554_Config_RevID_SHIFT                                                        (os_bit32)0x00

#define I21554_Config_ClassCode_MASK                                                     (os_bit32)0xFFFFFF00

#define I21554_Config_ClassCode_BaseClassCode_MASK                                       (os_bit32)0xFF000000
#define I21554_Config_ClassCode_BaseClassCode_SHIFT                                      (os_bit32)0x18
#define I21554_Config_ClassCode_BaseClassCode_Bridge                                     (os_bit32)0x06

#define I21554_Config_ClassCode_SubClassCode_MASK                                        (os_bit32)0x00FF0000
#define I21554_Config_ClassCode_SubClassCode_SHIFT                                       (os_bit32)0x10
#define I21554_Config_ClassCode_SubClassCode_Other                                       (os_bit32)0x80

#define I21554_Config_ClassCode_ProgIF_MASK                                              (os_bit32)0x0000FF00
#define I21554_Config_ClassCode_ProgIF_SHIFT                                             (os_bit32)0x08
#define I21554_Config_ClassCode_ProgIF_Reads_as_zero                                     (os_bit32)0x00

#define I21554_Config_CLS_MASK                                                           (os_bit32)0x000000FF
#define I21554_Config_CLS_SHIFT                                                          (os_bit32)0x00

#define I21554_Config_MLT_MASK                                                           (os_bit32)0x0000FF00
#define I21554_Config_MLT_SHIFT                                                          (os_bit32)0x08

#define I21554_Config_HeaderType_MASK                                                    (os_bit32)0x00FF0000
#define I21554_Config_HeaderType_Type_0                                                  (os_bit32)0x00000000

#define I21554_Config_BIST_MASK                                                          (os_bit32)0xFF000000

#define I21554_Config_BIST_Completion_Code_MASK                                          (os_bit32)0x0F000000
#define I21554_Config_BIST_Completion_Code_Passed                                        (os_bit32)0x00000000

#define I21554_Config_BIST_Self_Test                                                     (os_bit32)0x40000000

#define I21554_Config_BIST_BiST_Supported                                                (os_bit32)0x80000000

#define I21554_Config_BAR_Space_Indicator_MASK                                           (os_bit32)0x00000001
#define I21554_Config_BAR_Space_Indicator_Memory                                         (os_bit32)0x00000000
#define I21554_Config_BAR_Space_Indicator_IO                                             (os_bit32)0x00000001

#define I21554_Config_Memory_BAR_Type_MASK                                               (os_bit32)0x00000006
#define I21554_Config_Memory_BAR_Type_20_bit                                             (os_bit32)0x00000002
#define I21554_Config_Memory_BAR_Type_32_bit                                             (os_bit32)0x00000000
#define I21554_Config_Memory_BAR_Type_64_bit                                             (os_bit32)0x00000004

#define I21554_Config_Memory_BAR_Prefetchable                                            (os_bit32)0x00000008

#define I21554_Config_BAR_Base_Address_MASK                                              (os_bit32)0xFFFFFFF0
#define I21554_Config_BAR_Base_Address_SHIFT                                             (os_bit32)0x00

#define I21554_Config_SubsystemVendorID_MASK                                             (os_bit32)0x0000FFFF
#define I21554_Config_SubsystemID_MASK                                                   (os_bit32)0xFFFF0000

#define I21554_Config_Expansion_ROM_Enable                                               (os_bit32)0x00000001

#define I21554_Config_Expansion_ROM_Base_Address_MASK                                    (os_bit32)0xFFFFF000
#define I21554_Config_Expansion_ROM_Base_Address_SHIFT                                   (os_bit32)0x00

#define I21554_Config_CapabilitiesPointer_MASK                                           (os_bit32)0x000000FF
#define I21554_Config_CapabilitiesPointer_SHIFT                                          (os_bit32)0x00

#define I21554_Config_InterruptLine_MASK                                                 (os_bit32)0x000000FF
#define I21554_Config_InterruptLine_SHIFT                                                (os_bit32)0x00

#define I21554_Config_InterruptPin_MASK                                                  (os_bit32)0x0000FF00
#define I21554_Config_InterruptPin_SHIFT                                                 (os_bit32)0x08

#define I21554_Config_MinGnt_MASK                                                        (os_bit32)0x00FF0000
#define I21554_Config_MinGnt_SHIFT                                                       (os_bit32)0x10

#define I21554_Config_MaxLat_MASK                                                        (os_bit32)0xFF000000
#define I21554_Config_MaxLat_SHIFT                                                       (os_bit32)0x18

#define I21554_Config_ConfigurationOwnBits_MASK                                          (os_bit32)0x0000FFFF
#define I21554_Config_ConfigurationOwnBits_Downstream_Own_Bit                            (os_bit32)0x00000001
#define I21554_Config_ConfigurationOwnBits_Upstream_Own_Bit                              (os_bit32)0x00000100

#define I21554_Config_ConfigurationControlAndStatus_MASK                                 (os_bit32)0xFFFF0000
#define I21554_Config_ConfigurationControlAndStatus_Downstream_Own_Status                (os_bit32)0x00010000
#define I21554_Config_ConfigurationControlAndStatus_Downstream_Control                   (os_bit32)0x00020000
#define I21554_Config_ConfigurationControlAndStatus_Upstream_Own_Status                  (os_bit32)0x01000000
#define I21554_Config_ConfigurationControlAndStatus_Upstream_Control                     (os_bit32)0x02000000

#define I21554_Config_Memory_or_IO_Setup_Indicator_MASK                                  (os_bit32)0x00000001
#define I21554_Config_Memory_or_IO_Setup_Space_Indicator_Memory                          (os_bit32)0x00000000
#define I21554_Config_Memory_or_IO_Setup_Space_Indicator_IO                              (os_bit32)0x00000001

#define I21554_Config_Memory_Setup_Type_MASK                                             (os_bit32)0x00000006
#define I21554_Config_Memory_Setup_Type_20_bit                                           (os_bit32)0x00000002
#define I21554_Config_Memory_Setup_Type_32_bit                                           (os_bit32)0x00000000
#define I21554_Config_Memory_Setup_Type_64_bit                                           (os_bit32)0x00000004

#define I21554_Config_Memory_Setup_Prefetchable                                          (os_bit32)0x00000008

#define I21554_Config_Memory_or_IO_Setup_Size_MASK                                       (os_bit32)0x7FFFFFC0
#define I21554_Config_Memory_or_IO_Setup_Size_SHIFT                                      (os_bit32)0x00

#define I21554_Config_Memory_or_IO_Setup_BAR_Enable                                      (os_bit32)0x80000000

#define I21554_Config_Upper_32_Bits_Downstream_Memory_3_Setup_Size_MASK                  (os_bit32)0x7FFFFFFF
#define I21554_Config_Upper_32_Bits_Downstream_Memory_3_Setup_Size_SHIFT                 (os_bit32)0x00
#define I21554_Config_Upper_32_Bits_Downstream_Memory_3_Setup_BAR_Enable                 (os_bit32)0x80000000

#define I21554_Config_Primary_Expansion_ROM_Setup_Size_MASK                              (os_bit32)0x00FFF000
#define I21554_Config_Primary_Expansion_ROM_Setup_Size_SHIFT                             (os_bit32)0x00FFF000
#define I21554_Config_Primary_Expansion_ROM_Setup_BAR_Enable                             (os_bit32)0x01000000

#define I21554_Config_ChipControl0_MASK                                                  (os_bit32)0x0000FFFF

#define I21554_Config_ChipControl0_Master_Abort_Mode                                     (os_bit32)0x00000001
#define I21554_Config_ChipControl0_Memory_Write_Disconnect_Control                       (os_bit32)0x00000002

#define I21554_Config_ChipControl0_Primary_Master_Timeout_MASK                           (os_bit32)0x00000004
#define I21554_Config_ChipControl0_Primary_Master_Timeout_32768_clocks                   (os_bit32)0x00000000
#define I21554_Config_ChipControl0_Primary_Master_Timeout_1024_clocks                    (os_bit32)0x00000004

#define I21554_Config_ChipControl0_Secondary_Master_Timeout_MASK                         (os_bit32)0x00000008
#define I21554_Config_ChipControl0_Secondary_Master_Timeout_32768_clocks                 (os_bit32)0x00000000
#define I21554_Config_ChipControl0_Secondary_Master_Timeout_1024_clocks                  (os_bit32)0x00000008

#define I21554_Config_ChipControl0_Primary_Master_Timeout_Disable                        (os_bit32)0x00000010
#define I21554_Config_ChipControl0_Secondary_Master_Timeout_Disable                      (os_bit32)0x00000020
#define I21554_Config_ChipControl0_Delayed_Transaction_Order_Control                     (os_bit32)0x00000040
#define I21554_Config_ChipControl0_SERR_Forward_Enable                                   (os_bit32)0x00000080
#define I21554_Config_ChipControl0_Upstream_DAC_Prefetch_Disable                         (os_bit32)0x00000100
#define I21554_Config_ChipControl0_Multiple_Device_Enable                                (os_bit32)0x00000200
#define I21554_Config_ChipControl0_Primary_Access_Lockout                                (os_bit32)0x00000400
#define I21554_Config_ChipControl0_Secondary_Clock_Disable                               (os_bit32)0x00000800

#define I21554_Config_ChipControl0_VGA_Mode_MASK                                         (os_bit32)0x0000C000
#define I21554_Config_ChipControl0_VGA_Mode_Neither_Forwarded                            (os_bit32)0x00000000
#define I21554_Config_ChipControl0_VGA_Mode_Primary_Forwarded                            (os_bit32)0x00004000
#define I21554_Config_ChipControl0_VGA_Mode_Secondary_Forwarded                          (os_bit32)0x00008000

#define I21554_Config_ChipControl1_MASK                                                  (os_bit32)0xFFFF0000

#define I21554_Config_ChipControl1_Primary_Posted_Write_Threshold_MASK                   (os_bit32)0x00010000
#define I21554_Config_ChipControl1_Primary_Posted_Write_Threshold_Full_Cache_Line        (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Primary_Posted_Write_Threshold_Half_Cache_Line        (os_bit32)0x00010000

#define I21554_Config_ChipControl1_Secondary_Posted_Write_Threshold_MASK                 (os_bit32)0x00020000
#define I21554_Config_ChipControl1_Secondary_Posted_Write_Threshold_Full_Cache_Line      (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Secondary_Posted_Write_Threshold_Half_Cache_Line      (os_bit32)0x00020000

#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_MASK                   (os_bit32)0x000C0000
#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_8_DWords               (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_Mixture                (os_bit32)0x00080000
#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_Cache_Line             (os_bit32)0x000C0000

#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_MASK                 (os_bit32)0x00300000
#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_8_DWords             (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_Mixture              (os_bit32)0x00200000
#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_Cache_Line           (os_bit32)0x00300000

#define I21554_Config_ChipControl1_Subtractive_Decode_Enable_MASK                        (os_bit32)0x00C00000
#define I21554_Config_ChipControl1_Subtractive_Decode_Off                                (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Subtractive_Decode_IO_on_Primary                      (os_bit32)0x00400000
#define I21554_Config_ChipControl1_Subtractive_Decode_IO_on_Secondary                    (os_bit32)0x00800000

#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_MASK                      (os_bit32)0x0F000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_Disable                   (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_256B                      (os_bit32)0x01000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_512B                      (os_bit32)0x02000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_1KB                       (os_bit32)0x03000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_2KB                       (os_bit32)0x04000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_4KB                       (os_bit32)0x05000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_8KB                       (os_bit32)0x06000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_16KB                      (os_bit32)0x07000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_32KB                      (os_bit32)0x08000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_64KB                      (os_bit32)0x09000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_128KB                     (os_bit32)0x0A000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_256KB                     (os_bit32)0x0B000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_512KB                     (os_bit32)0x0C000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_1MB                       (os_bit32)0x0D000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_2MB                       (os_bit32)0x0E000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_4MB                       (os_bit32)0x0F000000

#define I21554_Config_ChipControl1_I2O_ENA                                               (os_bit32)0x10000000

#define I21554_Config_ChipControl1_I20_SIZE_MASK                                         (os_bit32)0xE0000000
#define I21554_Config_ChipControl1_I20_SIZE_256_entries                                  (os_bit32)0x00000000
#define I21554_Config_ChipControl1_I20_SIZE_512_entries                                  (os_bit32)0x20000000
#define I21554_Config_ChipControl1_I20_SIZE_1K_entries                                   (os_bit32)0x40000000
#define I21554_Config_ChipControl1_I20_SIZE_2K_entries                                   (os_bit32)0x60000000
#define I21554_Config_ChipControl1_I20_SIZE_4K_entries                                   (os_bit32)0x80000000
#define I21554_Config_ChipControl1_I20_SIZE_8K_entries                                   (os_bit32)0xA0000000
#define I21554_Config_ChipControl1_I20_SIZE_16K_entries                                  (os_bit32)0xC0000000
#define I21554_Config_ChipControl1_I20_SIZE_32K_entries                                  (os_bit32)0xE0000000

#define I21554_Config_ChipStatus_MASK                                                    (os_bit32)0x0000FFFF
#define I21554_Config_ChipStatus_Downstream_Delayed_Transaction_Master_TimeOut           (os_bit32)0x00000001
#define I21554_Config_ChipStatus_Downstream_Delayed_Read_Transaction_Discarded           (os_bit32)0x00000002
#define I21554_Config_ChipStatus_Downstream_Delayed_Write_Transaction_Discarded          (os_bit32)0x00000004
#define I21554_Config_ChipStatus_Downstream_Posted_Write_Data_Discarded                  (os_bit32)0x00000008
#define I21554_Config_ChipStatus_Upstream_Delayed_Transaction_Master_TimeOut             (os_bit32)0x00000100
#define I21554_Config_ChipStatus_Upstream_Delayed_Read_Transaction_Discarded             (os_bit32)0x00000200
#define I21554_Config_ChipStatus_Upstream_Delayed_Write_Transaction_Discarded            (os_bit32)0x00000400
#define I21554_Config_ChipStatus_Upstream_Posted_Write_Data_Discarded                    (os_bit32)0x00000800

#define I21554_Config_ArbiterControl_MASK                                                (os_bit32)0x03FF0000

#define I21554_Config_PrimarySERRDisables_MASK                                           (os_bit32)0x000000FF
#define I21554_Config_PrimarySERRDisables_Downstream_Delayed_Transaction_Master_TimeOut  (os_bit32)0x00000001
#define I21554_Config_PrimarySERRDisables_Downstream_Delayed_Read_Transaction_Discarded  (os_bit32)0x00000002
#define I21554_Config_PrimarySERRDisables_Downstream_Delayed_Write_Transaction_Discarded (os_bit32)0x00000004
#define I21554_Config_PrimarySERRDisables_Downstream_Posted_Write_Data_Discarded         (os_bit32)0x00000008
#define I21554_Config_PrimarySERRDisables_Target_Abort_during_Downstream_Posted_Write    (os_bit32)0x00000010
#define I21554_Config_PrimarySERRDisables_Master_Abort_during_Downstream_Posted_Write    (os_bit32)0x00000020
#define I21554_Config_PrimarySERRDisables_Downstream_Posted_Write_Parity_Error           (os_bit32)0x00000040

#define I21554_Config_SecondarySERRDisables_MASK                                         (os_bit32)0x0000FF00
#define I21554_Config_SecondarySERRDisables_Upstream_Delayed_Transaction_Master_TimeOut  (os_bit32)0x00000100
#define I21554_Config_SecondarySERRDisables_Upstream_Delayed_Read_Transaction_Discarded  (os_bit32)0x00000200
#define I21554_Config_SecondarySERRDisables_Upstream_Delayed_Write_Transaction_Discarded (os_bit32)0x00000400
#define I21554_Config_SecondarySERRDisables_Upstream_Posted_Write_Data_Discarded         (os_bit32)0x00000800
#define I21554_Config_SecondarySERRDisables_Target_Abort_during_Upstream_Posted_Write    (os_bit32)0x00001000
#define I21554_Config_SecondarySERRDisables_Master_Abort_during_Upstream_Posted_Write    (os_bit32)0x00002000
#define I21554_Config_SecondarySERRDisables_Upstream_Posted_Write_Parity_Error           (os_bit32)0x00004000

#define I21554_Config_Reset_Control_Secondary_Reset                                      (os_bit32)0x00000001
#define I21554_Config_Reset_Control_Chip_Reset                                           (os_bit32)0x00000002
#define I21554_Config_Reset_Control_Subsystem_Status                                     (os_bit32)0x00000004
#define I21554_Config_Reset_Control_I_stat_Status                                        (os_bit32)0x00000008

#define I21554_Config_CapabilityID_MASK                                                  (os_bit32)0x000000FF
#define I21554_Config_CapabilityID_PM_ECP                                                (os_bit32)0x00000001
#define I21554_Config_CapabilityID_VPD                                                   (os_bit32)0x00000003
#define I21554_Config_CapabilityID_HS_ECP                                                (os_bit32)0x00000006

#define I21554_Config_NextItemPtr_MASK                                                   (os_bit32)0x0000FF00
#define I21554_Config_NextItemPtr_SHIFT                                                  (os_bit32)0x08

#define I21554_Config_PowerManagementCapabilities_MASK                                   (os_bit32)0xFFFF0000

#define I21554_Config_PowerManagementCapabilities_PM_Version_MASK                        (os_bit32)0x00070000
#define I21554_Config_PowerManagementCapabilities_PM_Version_1_0                         (os_bit32)0x00010000

#define I21554_Config_PowerManagementCapabilities_PME_Clock                              (os_bit32)0x00080000
#define I21554_Config_PowerManagementCapabilities_APS                                    (os_bit32)0x00100000
#define I21554_Config_PowerManagementCapabilities_DSI                                    (os_bit32)0x00200000
#define I21554_Config_PowerManagementCapabilities_D1_Support                             (os_bit32)0x02000000
#define I21554_Config_PowerManagementCapabilities_D2_Support                             (os_bit32)0x04000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D0                   (os_bit32)0x08000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D1                   (os_bit32)0x10000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D2                   (os_bit32)0x20000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D3_Hot               (os_bit32)0x40000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D3_Cold              (os_bit32)0x80000000

#define I21554_Config_PowerManagementCSR_MASK                                            (os_bit32)0x0000FFFF

#define I21554_Config_PowerManagementCSR_PWR_State_MASK                                  (os_bit32)0x00000003
#define I21554_Config_PowerManagementCSR_PWR_State_D0                                    (os_bit32)0x00000000
#define I21554_Config_PowerManagementCSR_PWR_State_D1                                    (os_bit32)0x00000001
#define I21554_Config_PowerManagementCSR_PWR_State_D2                                    (os_bit32)0x00000002
#define I21554_Config_PowerManagementCSR_PWR_State_D3                                    (os_bit32)0x00000003

#define I21554_Config_PowerManagementCSR_DYN_DATA                                        (os_bit32)0x00000010

#define I21554_Config_PowerManagementCSR_PME_EN                                          (os_bit32)0x00000100

#define I21554_Config_PowerManagementCSR_DATA_SEL                                        (os_bit32)0x00001E00

#define I21554_Config_PowerManagementCSR_Data_Scale_MASK                                 (os_bit32)0x00006000
#define I21554_Config_PowerManagementCSR_Data_Scale_SHIFT                                (os_bit32)0x0D

#define I21554_Config_PowerManagementCSR_PME_Status                                      (os_bit32)0x00008000

#define I21554_Config_PMCSRBSE_MASK                                                      (os_bit32)0x00FF0000
#define I21554_Config_PMCSRBSE_SHIFT                                                     (os_bit32)0x10

#define I21554_Config_PMData_MASK                                                        (os_bit32)0xFF000000
#define I21554_Config_PMData_SHIFT                                                       (os_bit32)0x18

#define I21554_Config_VPDAddress_MASK                                                    (os_bit32)0xFFFF0000

#define I21554_Config_VPDAddress_Addr_MASK                                               (os_bit32)0x01FF0000
#define I21554_Config_VPDAddress_Addr_SHIFT                                              (os_bit32)0x10

#define I21554_Config_VPDAddress_Flag                                                    (os_bit32)0x80000000

#define I21554_Config_HostSwapControl_MASK                                               (os_bit32)0x00FF0000
#define I21554_Config_HostSwapControl_ENUM_MASK                                          (os_bit32)0x00020000
#define I21554_Config_HostSwapControl_LED_On                                             (os_bit32)0x00080000
#define I21554_Config_HostSwapControl_REM_STAT                                           (os_bit32)0x00400000
#define I21554_Config_HostSwapControl_INS_STAT                                           (os_bit32)0x00800000

/*+
CSR Address Map
-*/

typedef struct I21554_CSR_s
               I21554_CSR_t;

struct I21554_CSR_s
       {
         os_bit32 Downstream_Configuration_Address;
         os_bit32 Downstream_Configuration_Data;
         os_bit32 Upstream_Configuration_Address;
         os_bit32 Upstream_Configuration_Data;
         os_bit32 ConfigurationControlAndStatus_ConfigurationOwnBits;
         os_bit32 Downstream_IO_Address;
         os_bit32 Downstream_IO_Data;
         os_bit32 Upstream_IO_Address;
         os_bit32 Upstream_IO_Data;
         os_bit32 IOControlAndStatus_IOOwnBits;
         os_bit32 reserved_LookupTableOffset;
         os_bit32 Lookup_Table_Data;
         os_bit32 I2O_Outbound_Post_List_Status;
         os_bit32 I2O_Outbound_Post_List_Interrupt_Mask;
         os_bit32 I2O_Inbound_Post_List_Status;
         os_bit32 I2O_Inbound_Post_List_Interrupt_Mask;
         os_bit32 I2O_Inbound_Queue;
         os_bit32 I2O_Outbound_Queue;
         os_bit32 I2O_Inbound_Free_List_Head_Pointer;
         os_bit32 I2O_Inbound_Post_List_Tail_Pointer;
         os_bit32 I2O_Outbound_Free_List_Tail_Pointer;
         os_bit32 I2O_Outbound_Post_List_Head_Pointer;
         os_bit32 I2O_Inbound_Post_List_Counter;
         os_bit32 I2O_Inbound_Free_List_Counter;
         os_bit32 I2O_Outbound_Post_List_Counter;
         os_bit32 I2O_Outbound_Free_List_Counter;
         os_bit32 Downstream_Memory_0_Translated_Base;
         os_bit32 Downstream_IO_or_Memory_1_Translated_Base;
         os_bit32 Downstream_Memory_2_Translated_Base;
         os_bit32 Downstream_Memory_3_Translated_Base;
         os_bit32 Upstream_IO_or_Memory_0_Translated_Base;
         os_bit32 Upstream_Memory_1_Translated_Base;
         os_bit32 ChipStatusCSR_reserved;
         os_bit32 ChipClearIRQMaskRegister_ChipSetIRQMaskRegister;
         os_bit32 Upstream_Page_Boundary_IRQ_0_Register;
         os_bit32 Upstream_Page_Boundary_IRQ_1_Register;
         os_bit32 Upstream_Page_Boundary_IRQ_Mask_0_Register;
         os_bit32 Upstream_Page_Boundary_IRQ_Mask_1_Register;
         os_bit32 SecondaryClearIRQ_PrimaryClearIRQ;
         os_bit32 SecondarySetIRQ_PrimarySetIRQ;
         os_bit32 SecondaryClearIRQMask_PrimaryClearIRQMask;
         os_bit32 SecondarySetIRQMask_PrimarySetIRQMask;
         os_bit32 Scratchpad_0;
         os_bit32 Scratchpad_1;
         os_bit32 Scratchpad_2;
         os_bit32 Scratchpad_3;
         os_bit32 Scratchpad_4;
         os_bit32 Scratchpad_5;
         os_bit32 Scratchpad_6;
         os_bit32 Scratchpad_7;
         os_bit32 reserved_ROMData_ROMSetup;
         os_bit32 ROMControl_ROMAddress;
         os_bit8  reserved_1[0x0100-0x00D0];
         os_bit8  Upstream_Memory_2_Lookup_Table[0x0200-0x0100];
         os_bit8  reserved_2[0x1000-0x0200];
       };

#define I21554_CSR_ConfigurationOwnBits_MASK                                             (os_bit32)0x0000FFFF
#define I21554_CSR_ConfigurationOwnBits_Downstream_IO_Own_Bit                            (os_bit32)0x00000001
#define I21554_CSR_ConfigurationOwnBits_Upstream_IO_Own_Bit                              (os_bit32)0x00000100

#define I21554_CSR_ConfigurationControlAndStatus_MASK                                    (os_bit32)0xFFFF0000
#define I21554_CSR_ConfigurationControlAndStatus_Downstream_IO_Own_Bit_Status            (os_bit32)0x00010000
#define I21554_CSR_ConfigurationControlAndStatus_Downstream_IO_Control                   (os_bit32)0x00020000
#define I21554_CSR_ConfigurationControlAndStatus_Upstream_IO_Own_Bit_Status              (os_bit32)0x01000000
#define I21554_CSR_ConfigurationControlAndStatus_Upstream_IO_Control                     (os_bit32)0x02000000

#define I21554_CSR_IOOwnBits_MASK                                                        (os_bit32)0x0000FFFF
#define I21554_CSR_IOOwnBits_Downstream_IO_Own_Bit                                       (os_bit32)0x00000001
#define I21554_CSR_IOOwnBits_Upstream_IO_Own_Bit                                         (os_bit32)0x00000100

#define I21554_CSR_IOControlAndStatus_MASK                                               (os_bit32)0xFFFF0000
#define I21554_CSR_IOControlAndStatus_Downstream_IO_Own_Bit_Status                       (os_bit32)0x00010000
#define I21554_CSR_IOControlAndStatus_Downstream_IO_Control                              (os_bit32)0x00020000
#define I21554_CSR_IOControlAndStatus_Upstream_IO_Own_Bit_Status                         (os_bit32)0x01000000
#define I21554_CSR_IOControlAndStatus_Upstream_IO_Control                                (os_bit32)0x02000000

#define I21554_CSR_LookupTableOffset_MASK                                                (os_bit32)0x000000FF
#define I21554_CSR_LookupTableOffset_SHIFT                                               (os_bit32)0x00

#define I21554_CSR_Lookup_Table_Data_Valid_Bit                                           (os_bit32)0x00000001
#define I21554_CSR_Lookup_Table_Data_Prefetchable                                        (os_bit32)0x00000008
#define I21554_CSR_Lookup_Table_Data_Translated_Base_MASK                                (os_bit32)0xFFFFFF00

#define I21554_CSR_I2O_Outbound_Post_List_Status_MASK                                    (os_bit32)0x00000008
#define I21554_CSR_I2O_Outbound_Post_List_Status_Empty                                   (os_bit32)0x00000000
#define I21554_CSR_I2O_Outbound_Post_List_Status_Not_Empty                               (os_bit32)0x00000008

#define I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask                                 (os_bit32)0x00000008

#define I21554_CSR_I2O_Inbound_Post_List_Status_MASK                                     (os_bit32)0x00000008
#define I21554_CSR_I2O_Inbound_Post_List_Status_Empty                                    (os_bit32)0x00000000
#define I21554_CSR_I2O_Inbound_Post_List_Status_Not_Empty                                (os_bit32)0x00000008

#define I21554_CSR_I2O_Inbound_Post_List_Interrupt_Mask                                  (os_bit32)0x00000008

#define I21554_CSR_I2O_Inbound_Free_List_Head_Pointer_MASK                               (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Inbound_Free_List_Head_Pointer_SHIFT                              (os_bit32)0x00

#define I21554_CSR_I2O_Inbound_Post_List_Tail_Pointer_MASK                               (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Inbound_Post_List_Tail_Pointer_SHIFT                              (os_bit32)0x00

#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_MASK                              (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_SHIFT                             (os_bit32)0x00

#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_MASK                              (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_SHIFT                             (os_bit32)0x00

#define I21554_CSR_I2O_Outbound_Post_List_Head_Pointer_MASK                              (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Outbound_Post_List_Head_Pointer_SHIFT                             (os_bit32)0x00

#define I21554_CSR_I2O_Inbound_Post_List_Counter_MASK                                    (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Inbound_Post_List_Counter_Set_or_Decrement_MASK                   (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Post_List_Counter_Set                                     (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Post_List_Counter_Decrement                               (os_bit32)0x00000000

#define I21554_CSR_I2O_Inbound_Free_List_Counter_MASK                                    (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Inbound_Free_List_Counter_Set_or_Increment_MASK                   (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Free_List_Counter_Set                                     (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Free_List_Counter_Increment                               (os_bit32)0x00000000

#define I21554_CSR_I2O_Outbound_Post_List_Counter_MASK                                   (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Outbound_Post_List_Counter_Set_or_Increment_MASK                  (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Post_List_Counter_Set                                    (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Post_List_Counter_Increment                              (os_bit32)0x00000000

#define I21554_CSR_I2O_Outbound_Free_List_Counter_MASK                                   (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Outbound_Free_List_Counter_Set_or_Decrement_MASK                  (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Free_List_Counter_Set                                    (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Free_List_Counter_Decrement                              (os_bit32)0x00000000

#define I21554_CSR_ChipStatusCSR_MASK                                                    (os_bit32)0xFFFF0000
#define I21554_CSR_ChipStatusCSR_PM_D0                                                   (os_bit32)0x00010000
#define I21554_CSR_ChipStatusCSR_Subsystem_Event                                         (os_bit32)0x00020000

#define I21554_CSR_ChipSetIRQMaskRegister_MASK                                           (os_bit32)0x0000FFFF
#define I21554_CSR_ChipSetIRQMaskRegister_Set_D0M                                        (os_bit32)0x00000001
#define I21554_CSR_ChipSetIRQMaskRegister_Set_Sstat                                      (os_bit32)0x00000002

#define I21554_CSR_ChipClearIRQMaskRegister_MASK                                         (os_bit32)0xFFFF0000
#define I21554_CSR_ChipClearIRQMaskRegister_Clr_D0M                                      (os_bit32)0x00010000
#define I21554_CSR_ChipClearIRQMaskRegister_Clr_Sstat                                    (os_bit32)0x00020000

#define I21554_CSR_PrimaryClearIRQ_MASK                                                  (os_bit32)0x0000FFFF
#define I21554_CSR_PrimaryClearIRQ_SHIFT                                                 (os_bit32)0x00

#define I21554_CSR_SecondaryClearIRQ_MASK                                                (os_bit32)0xFFFF0000
#define I21554_CSR_SecondaryClearIRQ_SHIFT                                               (os_bit32)0x10

#define I21554_CSR_PrimarySetIRQ_MASK                                                    (os_bit32)0x0000FFFF
#define I21554_CSR_PrimarySetIRQ_SHIFT                                                   (os_bit32)0x00

#define I21554_CSR_SecondarySetIRQ_MASK                                                  (os_bit32)0xFFFF0000
#define I21554_CSR_SecondarySetIRQ_SHIFT                                                 (os_bit32)0x10

#define I21554_CSR_PrimaryClearIRQMask_MASK                                              (os_bit32)0x0000FFFF
#define I21554_CSR_PrimaryClearIRQMask_SHIFT                                             (os_bit32)0x00

#define I21554_CSR_SecondaryClearIRQMask_MASK                                            (os_bit32)0xFFFF0000
#define I21554_CSR_SecondaryClearIRQMask_SHIFT                                           (os_bit32)0x10

#define I21554_CSR_PrimarySetIRQMask_MASK                                                (os_bit32)0x0000FFFF
#define I21554_CSR_PrimarySetIRQMask_SHIFT                                               (os_bit32)0x00

#define I21554_CSR_SecondarySetIRQMask_MASK                                              (os_bit32)0xFFFF0000
#define I21554_CSR_SecondarySetIRQMask_SHIFT                                             (os_bit32)0x10

#define I21554_CSR_ROMSetup_MASK                                                         (os_bit32)0x0000FFFF

#define I21554_CSR_ROMSetup_Access_Time_MASK                                             (os_bit32)0x00000003
#define I21554_CSR_ROMSetup_Access_Time_8_clocks                                         (os_bit32)0x00000000
#define I21554_CSR_ROMSetup_Access_Time_16_clocks                                        (os_bit32)0x00000001
#define I21554_CSR_ROMSetup_Access_Time_64_clocks                                        (os_bit32)0x00000002
#define I21554_CSR_ROMSetup_Access_Time_256_clocks                                       (os_bit32)0x00000003

#define I21554_CSR_ROMSetup_Strobe_Mask_MASK                                             (os_bit32)0x0000FF00
#define I21554_CSR_ROMSetup_Strobe_Mask_8_clocks                                         (os_bit32)0x00000000
#define I21554_CSR_ROMSetup_Strobe_Mask_16_clocks                                        (os_bit32)0x00000100
#define I21554_CSR_ROMSetup_Strobe_Mask_64_clocks                                        (os_bit32)0x00000200
#define I21554_CSR_ROMSetup_Strobe_Mask_256_clocks                                       (os_bit32)0x00000300

#define I21554_CSR_ROMData_MASK                                                          (os_bit32)0x00FF0000
#define I21554_CSR_ROMData_SHIFT                                                         (os_bit32)0x10

#define I21554_CSR_ROMAddress_MASK                                                       (os_bit32)0x00FFFFFF

#define I21554_CSR_ROMAddress_Byte_Address_MASK                                          (os_bit32)0x000001FF

#define I21554_CSR_ROMAddress_Sub_Opcode_MASK                                            (os_bit32)0x00000180
#define I21554_CSR_ROMAddress_Sub_Opcode_Write_Disable                                   (os_bit32)0x00000000
#define I21554_CSR_ROMAddress_Sub_Opcode_Write_All                                       (os_bit32)0x00000080
#define I21554_CSR_ROMAddress_Sub_Opcode_Erase_All                                       (os_bit32)0x00000100
#define I21554_CSR_ROMAddress_Sub_Opcode_Write_Enable                                    (os_bit32)0x00000180

#define I21554_CSR_ROMAddress_Opcode_MASK                                                (os_bit32)0x00000600
#define I21554_CSR_ROMAddress_Opcode_Do_Sub_Opcode                                       (os_bit32)0x00000000
#define I21554_CSR_ROMAddress_Opcode_Write                                               (os_bit32)0x00000200
#define I21554_CSR_ROMAddress_Opcode_Read                                                (os_bit32)0x00000400
#define I21554_CSR_ROMAddress_Opcode_Erase                                               (os_bit32)0x00000600

#define I21554_CSR_ROMControl_MASK                                                       (os_bit32)0xFF000000
#define I21554_CSR_ROMControl_Serial_ROM_Start_Busy                                      (os_bit32)0x01000000
#define I21554_CSR_ROMControl_Parallel_ROM_Start_Busy                                    (os_bit32)0x02000000
#define I21554_CSR_ROMControl_Read_Write_Control                                         (os_bit32)0x04000000
#define I21554_CSR_ROMControl_SROM_POLL                                                  (os_bit32)0x08000000

#endif /* __I21554_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\hppif3p.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
        Systems Engineering -- System Software Development (NT Dev)
        Copyright 1996-98 Compaq Computer Corporation.
        All rights reserved.

  Date:         1 August 1996 

  File:         HPPIF3P.H   Hot Plug Interface MINIPORT Defs

  Purpose:      This file contains all miniport specific information necessary
                to interface to a hot plug device driver.
                
                  This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Revision History:
   11/4/97        mib       Split into hppifio (IOCTLs) and hppifevt (Event) Defs
    06/11/98            Added PCS_HBA_OFFLINE_PENDING for cpqarray
  Version: 1.2

***********************************************************************/

#ifndef _HPPIF3P_H_
#define _HPPIF3P_H_

#include "hppifio.h"        // defines for driver hotplug interfaces
#include <ntddscsi.h>       // Scsi Miniport Interface (See SDK)

#pragma pack(1)


//**********************************************************************
//            DEFINES FOR MINIPORT DRIVERS
//**********************************************************************

// NIC Controller Status Defines

#define NIC_STATUS_NORMAL             0x00
#define NIC_STATUS_MEDIA_FAILURE      0x01
#define NIC_STATUS_ADAPTER_CHECK      0x02

#define NIC_STATUS_USER_SIMULATED_FAILURE  0x10
#define NIC_STATUS_POWER_OFF_PENDING       0x20
#define NIC_STATUS_POWER_OFF               0x30
#define NIC_STATUS_POWER_OFF_FAULT         0x40
#define NIC_STATUS_POWER_ON_PENDING        0x50
#define NIC_STATUS_POWER_ON           0x60
#define NIC_STATUS_POWER_FAULT             0x70



// IOCTL defines supporting Compaq Hot Plug PCI for SCSI Miniport

//#define HPP_BASE_SCSI_ADDRESS_DEFAULT    0x0004d008

#define CPQ_HPP_SIGNATURE                  "CPQHPP"
#define CPQ_HPP_TIMEOUT                         180

// Defines for completion codes
#define IOP_HPP_ISSUED                0x1
#define IOP_HPP_COMPLETED             0x2
#define IOP_HPP_CMDBUILT              0x3
#define IOP_HPP_NONCONTIGUOUS         0x4
#define IOP_HPP_ERROR                 0x5

// IOCTL control codes

#define IOC_HPP_RCMC_INFO           0x1
#define IOC_HPP_HBA_STATUS          0x2
#define IOC_HPP_HBA_INFO            0x3
#define IOC_HPP_SLOT_TYPE           0x4
#define IOC_HPP_SLOT_EVENT          0x5
#define IOC_HPP_PCI_CONFIG_MAP      0x6
#define IOC_HPP_DIAGNOSTICS         0x7

// IOCTL Status

#define IOS_HPP_SUCCESS                 0x0000
#define IOS_HPP_BUFFER_TOO_SMALL        0x2001
#define IOS_HPP_INVALID_CONTROLLER      0x2002
#define IOS_HPP_INVALID_BUS_TYPE        0x2003
#define IOS_HPP_INVALID_CALLBACK        0x2004
#define IOS_HPP_INVALID_SLOT_TYPE       0x2005
#define IOS_HPP_INVALID_SLOT_EVENT      0x2006
#define IOS_HPP_NOT_HOTPLUGABLE         0x2007
#define IOS_HPP_NO_SERVICE              0x2008
#define IOS_HPP_HBA_FAILURE             0x2009
#define IOS_HPP_INVALID_SERVICE_STATUS  0x200a
#define IOS_HPP_HBA_BUSY                0x200b
#define IOS_HPP_NO_DIAGNOSTICS          0x200c



// Health Driver Status Codes

#define CBS_HBA_FAIL_MESSAGE_COUNT     0x8 // Number of failure health messages.
                                                   // This must be updated if messages are
                                           // added or removed.
                                           // This is a compile time check.

#define CBS_HBA_STATUS_NORMAL          0x0000
#define CBS_HBA_STATUS_FAILED          0x1001
#define CBS_HBA_POWER_FAULT            0x1002
#define CBS_HBA_CABLE_CHECK            0x1003
#define CBS_HBA_MEDIA_CHECK            0x1004
#define CBS_HBA_USER_FAILED            0x1005
#define CBS_HBA_FAILED_CACHE_IN_USE    0x1006
#define CBS_HBA_PWR_FAULT_CACHE_IN_USE 0x1007

//Compaq reserves values 0x1010 and 0x1011

// IOCTL buffer data structures

typedef struct _HPP_RCMC_INFO_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_RCMC_INFO   RcmcInfo;
} HPP_RCMC_INFO_BUFFER, *PHPP_RCMC_INFO_BUFFER;

typedef struct _HPP_CTRL_INFO_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_CTRL_INFO   CtrlInfo;
} HPP_CTRL_INFO_BUFFER, *PHPP_CTRL_INFO_BUFFER;

typedef struct _HPP_CTRL_STATUS_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_CTRL_STATUS CtrlStatus;
} HPP_CTRL_STATUS_BUFFER, *PHPP_CTRL_STATUS_BUFFER;

typedef struct _HPP_CTRL_SLOT_TYPE_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_CTRL_SLOT_TYPE  CtrlSlotType;
} HPP_CTRL_SLOT_TYPE_BUFFER, *PHPP_CTRL_SLOT_TYPE_BUFFER;

typedef struct _HPP_SLOT_EVENT_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_SLOT_EVENT      SlotEvent;
} HPP_SLOT_EVENT_BUFFER, *PHPP_SLOT_EVENT_BUFFER;

typedef struct _HPP_PCI_CONFIG_MAP_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_PCI_CONFIG_MAP  PciConfigMap;
} HPP_PCI_CONFIG_MAP_BUFFER, *PHPP_PCI_CONFIG_MAP_BUFFER;

// Physical Controller State flags:
//
// Flags utilized to maintain controller state for Hot-Plug
//___________________________________________________________________________ 

// state flags 

#define PCS_HBA_OFFLINE       0x00000001 // Adaptor has been taken off-line
#define PCS_HBA_FAILED        0x00000002 // Adaptor is considered faulted
#define PCS_HBA_TEST          0x00000004 // Adaptor is being tested
#define PCS_HBA_CABLE_CHECK   0x00000008 // Failure due to cable fault
#define PCS_HBA_MEDIA_CHECK   0x00000010 // Failure due to media fault
#define PCS_HBA_EXPANDING     0x00000020 // Indicates that one or more LUNS is expanding
#define PCS_HBA_USER_FAILED   0x00000040 // Indicates user failed slot
#define PCS_HBA_CACHE_IN_USE  0x00000080 // Lazy write cache active
#define PCS_HPP_HOT_PLUG_SLOT 0x00000400 // Slot is Hot-Plugable
#define PCS_HPP_SERVICE_READY 0x00000800 // RCMC service is running
#define PCS_HPP_POWER_DOWN    0x00001000 // Normal power down on slot
#define PCS_HPP_POWER_LOST    0x00002000 // Slot power was lost
#define PCS_HBA_EVENT_SUBMIT  0x0000100     // Stall IO while AEV req submitted
#define PCS_HBA_IO_QUEUED     0x0000200     // IO is queuing.  
#define PCS_HBA_UNFAIL_PENDING 0x00010000 // Return error until PCS_HBA_OFFLINE is reset

//Macros related to Hot Plug Support

// The below defined macro can be used to determine active controller
// state.  Its use would be appropriate when deciding whether to
// handle a request via the startio entry point.

#define PCS_HBA_NOT_READY(FLAGS) (FLAGS & (PCS_HBA_FAILED       |   \
                          PCS_HBA_TEST         |     \
                          PCS_HBA_OFFLINE      |     \
                          PCS_HBA_EVENT_SUBMIT |     \
                          PCS_HPP_POWER_DOWN))

// Note that the following set does *not* flip the offline bit. It is the
// responsibility  of the initialization routine to bring a controller
// online if startup is successful.

#define PCS_SET_UNFAIL(FLAGS)        (FLAGS &= ~(PCS_HBA_FAILED      |   \
                             PCS_HBA_USER_FAILED))

#define PCS_SET_PWR_OFF(FLAGS)       (FLAGS |= (PCS_HPP_POWER_DOWN |     \
                            PCS_HBA_OFFLINE))

#define PCS_SET_PWR_FAULT(FLAGS)     (FLAGS |= (PCS_HPP_POWER_DOWN |     \
                            PCS_HPP_POWER_LOST |     \
                            PCS_HBA_OFFLINE))


#define PCS_SET_PWR_ON(FLAGS)        (FLAGS &= ~(PCS_HPP_POWER_DOWN |    \
                             PCS_HPP_POWER_LOST))

#define PCS_SET_USER_FAIL(FLAGS)     (FLAGS |= (PCS_HBA_FAILED      |    \
                            PCS_HBA_USER_FAILED |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_VERIFY(FLAGS)        (FLAGS |= (PCS_HBA_OFFLINE))

#define PCS_SET_CABLE_CHECK(FLAGS)   (FLAGS |= (PCS_HBA_FAILED      |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_ADAPTER_CHECK(FLAGS) (FLAGS |= (PCS_HBA_FAILED |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_MEDIA_CHECK(FLAGS)   (FLAGS |= (PCS_HBA_MEDIA_CHECK |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_TEST(FLAGS)          (FLAGS |= (PCS_HBA_TEST |      \
                            PCS_HBA_OFFLINE))

#define PCS_SET_NO_TEST(FLAGS)       (FLAGS &= ~(PCS_HBA_TEST |          \
                            PCS_HBA_OFFLINE))

// The following macro is used by the array driver to set the status member
// of the RCMC event structure.

#define RCMC_SET_STATUS(FLAGS, EVENTCODE)  \
if (FLAGS & PCS_HPP_POWER_LOST) {          \
  if (FLAGS & PCS_HBA_CACHE_IN_USE) {      \
    EVENTCODE = CBS_HBA_PWR_FAULT_CACHE_IN_USE; \
  } else {                       \
    EVENTCODE = CBS_HBA_POWER_FAULT;       \
  }                              \
} else if (FLAGS & PCS_HBA_MEDIA_CHECK) {  \
  EVENTCODE = CBS_HBA_MEDIA_CHECK;         \
} else if (FLAGS & PCS_HBA_CABLE_CHECK) {  \
  EVENTCODE = CBS_HBA_CABLE_CHECK;         \
} else if (FLAGS & PCS_HBA_USER_FAILED) {  \
  EVENTCODE = CBS_HBA_USER_FAILED;         \
} else if (FLAGS & PCS_HBA_FAILED) {       \
  if (FLAGS & PCS_HBA_CACHE_IN_USE) {      \
    EVENTCODE = CBS_HBA_FAILED_CACHE_IN_USE;    \
  } else {                       \
    EVENTCODE = CBS_HBA_STATUS_FAILED;          \
  }                              \
} else {                         \
  EVENTCODE = CBS_HBA_STATUS_NORMAL;       \
}


// Logical Controller State Flags:
//
// Flags utilized to signal driver internal procedures relevant to the
// maintenance of Hot-Plug.
//___________________________________________________________________________

// control flags

#define LCS_HBA_FAIL_ACTIVE  0x00000001 // Fail active controller
#define LCS_HBA_READY_ACTIVE 0x00000002 // Un-Fail active controller
#define LCS_HBA_TEST         0x00000004 // Perform tests on controller
#define LCS_HBA_OFFLINE      0x00000008 // Take adaptor off-line
#define LCS_HBA_TIMER_ACTIVE 0x00000010 // Timer routine running
#define LCS_HBA_INIT         0x00000020 // Used for power-up
#define LCS_HBA_IDENTIFY     0x00000040 // Send Indentify command
#define LCS_HBA_READY        0x00000080 // Free controller 
#define LCS_HBA_GET_EVENT    0x00000100 // Send async event req
#define LCS_HBA_HOLD_TIMER   0x00000200    // Don't process timer now
#define LCS_HBA_CHECK_CABLES 0x00000400    // Verify cables are secure
#define LCS_HPP_STOP_SERVICE 0x00001000    // Request stop of RCMC Service
#define LCS_HPP_SLOT_RESET   0x00002000    // Service reseting slot power


#define LCS_HPP_POWER_DOWN  LCS_HBA_FAIL_ACTIVE // Put adaptor in Hot-Plug
                            // Stall 

#define LCS_HPP_POWER_FAULT LCS_HBA_FAIL_ACTIVE // Send power-fault event

// The followimg macro is used in the array driver to setup the sequence of
// events required to initialize a powered-up controller to working
// condition.  Bits are flipped by each process until they are clear.

#define LCS_HPP_POWER_UP (LCS_HBA_INIT               |    \
               LCS_HBA_READY_ACTIVE)



//
// SRB Return codes.
// 

#define RETURN_BUSY                     0x00 // default value
#define RETURN_NO_HBA                   0x01
#define RETURN_ABORTED                  0x02
#define RETURN_ABORT_FAILED             0x03
#define RETURN_ERROR                    0x04
#define RETURN_INVALID_PATH_ID          0x05
#define RETURN_NO_DEVICE                0x06
#define RETURN_TIMEOUT                  0x07
#define RETURN_COMMAND_TIMEOUT          0x08
#define RETURN_MESSAGE_REJECTED         0x09
#define RETURN_BUS_RESET                0x0A
#define RETURN_PARITY_ERROR             0x0B
#define RETURN_REQUEST_SENSE_FAILED     0x0C
#define RETURN_DATA_OVERRUN             0x0D
#define RETURN_UNEXPECTED_BUS_FREE      0x0E
#define RETURN_INVALID_LUN              0x0F
#define RETURN_INVALID_TARGET_ID        0x10
#define RETURN_BAD_FUNCTION             0x11
#define RETURN_ERROR_RECOVERY           0x12
#define RETURN_PENDING                  0x13


#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\hppifio.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
        Systems Engineering -- System Software Development (NT Dev)
        Copyright 1996-98 Compaq Computer Corporation.
        All rights reserved.

  Date:         1 August 1996 

  File:         HPPIFIO.H   - Hot Plug Interface IOCTLs Defs

  Purpose:      This file contains all the hot plug IOCTL specific information 
                  necessary to interface to a hot plug device driver.
                
                  This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Created:        11/4/97        Split off of hppif3p

  Version: 1.0
***********************************************************************/

#ifndef _HPPIFIO_H_
#define _HPPIFIO_H_

#include "hppifevt.h"  // Hot Plug Event Messages.

#pragma pack(1)



//**********************************************************************
//                  IOCTL DEFINITIONS         
//**********************************************************************

//====================================================================
//                      Common Defines & Structs
//====================================================================/

//
// Security defines
//

#define HPP_SECURITY_SIGNATURE  0x53505058      // Service Stop security flag 
                            // "HPPS"


//
// Hot Plug OIDs
// Each OID for NICs is relative to a base address value.
// The offset for the specific OID is added to the base value 
// to get the specific OID address value.
//
// The following is a list of OIDs which HPP compliant 
// drivers must respond to.  
//
// These offset values are also used to construct the Completion Codes.
// Each IOCTL has a specific family of completion codes.
//
// *** CAUTION ***
// Always update the 'HPP_IOCTL_COUNT' when adding/deleting IOCTLs.
//
//      Name                                    Offset          Get     Set
//--------------------------------------------------------------------------
#define HPP_IOCTL_RCMC_INFO_OFFSET              0x01    //      X       X
#define HPP_IOCTL_CONTROLLER_INFO_OFFSET        0x02    //      X
#define HPP_IOCTL_CONTROLLER_STATUS_OFFSET      0x03    //      X
#define HPP_IOCTL_SLOT_TYPE_OFFSET              0x04    //      X       X
#define HPP_IOCTL_SLOT_EVENT_OFFSET             0x05    //      X       X
#define HPP_IOCTL_PCI_CONFIG_MAP_OFFSET         0x06    //      X
#define HPP_IOCTL_STOP_RCMC_OFFSET              0x07    //              X
#define HPP_IOCTL_RUN_DIAGS_OFFSET              0x08    //              X

#define HPP_IOCTL_COUNT                         0x08


//
// Completion Codes.
// The following completion codes are defined from the 
// the driver IOCTLS.
//
// Completion codes are broken into families.  Each IOCTL will
// have its own family of completion codes.  This allows for easier
// debug at the cost of some extra code.
//
// The generic form of the completion codes is as follows:
//      0xrrrrIICC
//        --------
//        |   |  |
//        |   |  +-- CC == Individual Completion Code.
//        |   +----- II == IOCTL Offset (see above)
//        +--------- rrrr == Reserved at this time.
//
// Each IOCTL is assigned a specific family code.  All completion
// codes are defined relative to the IOCTL.
//
//  IOCTL               Offset:
//--------------------------------------------------------------------------
//  Service Info        0x000001xx
//  Controller Info     0x000002xx
//  Controller Status   0x000003xx
//  Slot Type           0x000004xx
//  Slot Status         0x000005xx
//  PCI Config Space    0x000006xx
//  Stop RCMC           0x000007xx



//
// Successful completion.  All IOCTLs will return success (HPP_SUCCESS)
// unless something fails.
//


#define HPP_SUCCESS                             0x00000000
#define HPP_INSUFICIENT_BUFFER_SPACE            0x00000001
#define HPP_INVALID_CONTROLLER                  0x00000002

#define HPP_INVALID_SERVICE_STATUS              0x00000101
#define HPP_INVALID_DRIVER_ID                   0x00000102
#define HPP_INVALID_CALLBACK_ADDR               0x00000103

#define HPP_INVALID_SLOT_TYPE                   0x00000401

#define HPP_INVALID_SLOT_EVENT                  0x00000501
#define HPP_INVALID_SIMULATED_FAILURE           0x00000502

#define HPP_DIAGS_NOT_SUPPORTED                      0x00000801



//----------------------------------------------------------------------
// Structure Name:      PCI Device/Function number
//
// Description:         Describes a PCI device.
//                      This is a general purpose PCI definition.
//                      It is used by many of the following requests.
//
// Example:             PCI_DESC        PciDescription
//
//                              PciDescription.ucBusNumber
//                              PciDescription.ucPCIDevFuncNum
//                              PciDescription.fcFunctionNumber
//                              PciDescription.fcDeviceNumber
//
// Note:                This structure is used by many IOCTLs.
//---------------------------------------------------------------------

typedef struct  _pci_descriptor
{
  UCHAR ucBusNumber;            // PCI Bus # (0-255)
  union
  {
    struct
    {
      UCHAR fcDeviceNumber:5;   // PCI Device # (0-31)
      UCHAR fcFunctionNumber:3; // PCI Function # (0-7)
    };
    UCHAR   ucPciDevFuncNum;    // Combined Dev and Func #
  };
} PCI_DESC, *PPCI_DESC;




//----------------------------------------------------------------------
// Structure Name:      HPP Controller Identification
//
// Description:         Specifies which controller an IOCTL is referring
//                      to.  HPP IOCTLs can be sent to any driver instance
//                      for any controller (for SCSI miniport).
//
// Note:                This structure is used by many IOCTLs.
//---------------------------------------------------------------------

typedef enum _hpp_controller_id_method
{
    // COMPAQ RESERVES VALUES 0x0 - 0x4 
   HPCID_PCI_DEV_FUNC = 0x5,      // 5 --  req PciDescriptor field
   HPCID_IO_BASE_ADDR = 0x6     // 6 --  req IOBaseAddress field
} E_HPP_CTRL_ID_METHOD;


typedef struct  _hpp_controller_id
{
  E_HPP_CTRL_ID_METHOD eController;             // Controller Selection
  union
  {
    struct
    {
      PCI_DESC  sPciDescriptor;                 // Used if 'eController'
      USHORT    reserved;                       // is set to: 'PCIDevFunc'
    };
    ULONG ulIOBaseAddress;                      // Used if 'eController'
  };                                            // is set to: 'IOBaseAddress'
} HPP_CTRL_ID, *PHPP_CTRL_ID;


//
// Common 'Template' header which can be applied to all
// Hot Plug PCI IOCTLs.
//

typedef struct  _hpp_common_header              // Get          Set
{                                               // -------------------
   ULONG           ulCompletionStatus;               // Output       Output
   HPP_CTRL_ID     sControllerID;                    // Input        Input
} HPP_HDR, *PHPP_HDR;


//====================================================================
//              SPECIFIC IOCTL: STRUCTS
//====================================================================/

//----------------------------------------------------------------------
// Structure Name:      HPP Service Info
//
// Description:         Called by the HPP RCMC to get or set
//                      the HPP's status.
//                      Service will notify when it starts and stops.
//
//                      IOCTL:          HPP_IOCTL_RCMC_INFO_OFFSET
//
//---------------------------------------------------------------------


//
// Service status information.
// The service will call the driver and notify it of
// Service Start and Stop.
//

typedef enum _hpp_rcmc_status
{
   HPRS_UNKNOWN_STATUS,    // 0
   HPRS_SERVICE_STARTING,  // 1
   HPRS_SERVICE_STOPPING,  // 2
} E_HPP_RCMC_STATUS;





// Callback prototype for service async messaging.

typedef 
ULONG 
(*PHR_CALLBACK) (
    PHR_EVENT pEvent
    );

typedef struct _hpp_rcmc_info                           // Get          Set
{                                                       // ------------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        Input
   E_HPP_RCMC_STATUS       eServiceStatus;         // Output       Input
   ULONG                   ulDriverID;             // Output       Input
   PHR_CALLBACK             vpCallbackAddress;      // Output       Input
   ULONG                   ulCntrlChassis;         // Output       Input
   ULONG                   ulPhysicalSlot;         // Output       Input
} HPP_RCMC_INFO, *PHPP_RCMC_INFO;


//----------------------------------------------------------------------
// Structure Name:      HPP Controller Info
//
// Description:         Called by the HPP RCMC to get 
//                      configuration information of the all controllers
//                      controlled by the instance of the driver.
//
//
//                      IOCTL:          HPP_IOCTL_CONTROLLER_INFO_OFFSET
//
//---------------------------------------------------------------------

//
// Defines for the Support Version
//
//      Version information:
//      0xrrrrMMmm
//      ----------
//          | |  |
//          | |  +-- Minor Version information
//          | +----- Major Version information
//          +------- Currently reserved
//
// The RCMC service will consider minor revisions within the same
// Major version compatible (i.e. all structures are the same size,
// etc.).  If the service encounters an unknown Major Version
// it should consider the interface incompatible.
//

#define SUPPORT_VERSION_10      0x00000100              // Version 1.00


//
// Description of the various support classes
//

typedef enum _hpp_support_class
{
   HPSC_UNKNOWN_CLASS = 0,             // 0
   HPSC_MINIPORT_NIC = 1,              // 1
   HPSC_MINIPORT_STORAGE = 3,          // 3
   HPSC_GNR_MONOLITHIC   = 5,              // 5
   //COMPAQ RESERVES VALUES 0x2, 0x4, 0x6 TO 0xF
} E_HPP_SUPPORT_CLASS;



typedef enum    _hpp_bus_type           // Duplicates of the NT definition
{                                       // Copied from MINIPORT.H
   HPPBT_EISA_BUS_TYPE = 2,
   HPPBT_PCI_BUS_TYPE  = 5,
} E_HPP_BUS_TYPE;


// NIC Miniport
typedef struct _nic_miniport_class_config_info
{
   ULONG   ulPhyType;
   ULONG   ulMaxMediaSpeed;
} NICM_CLASS_CONFIG_INFO, *PNICM_CLASS_COFNIG_INFO;


//
// Address descriptors.
// Used to describe either an IO or Memory Address used
// by the controller.
//

typedef enum    _hpp_addr_type
{
   HPPAT_UNKNOWN_ADDR_TYPE,                // 0
   HPPAT_IO_ADDR,                          // 1 -- IO Port Address
   HPPAT_MEM_ADDR,                         // 2 -- Memory Address
} E_HPP_ADDR_TYPE;

typedef struct  _hpp_ctrl_address_descriptor
{
//IWN   BOOLEAN         fValid;                 // TRUE iff entry is valid
   UCHAR           fValid;                 // TRUE iff entry is valid    E_HPP_ADDR_TYPE eAddrType;              // IOAddress or Memory
   E_HPP_ADDR_TYPE eAddrType;              // IOAddress or Memory
   ULONG           ulStart;                // Starting address
   ULONG           ulLength;               // Length of addresses
} HPP_CTRL_ADDR, *PHPP_CTRL_ADDR;



//
// Definition of the Controller configuration.
//

typedef struct _hpp_controller_config_info
{
   E_HPP_BUS_TYPE  eBusType;               // PCI or EISA
   PCI_DESC        sPciDescriptor;         // Bus #, DevFunc
   ULONG           ulSlotNumber;           // EISA or PCI slot num
   ULONG           ulProductID;            // 32-Bit EISA ID,
                                                     // PCI Vendor or Device ID
   HPP_CTRL_ADDR   asCtrlAddress [16];     // IO/Memory Address
   ULONG           ulIRQ;                  // Controller Interrupt
   UCHAR           szControllerDesc [256]; // Text description
   NICM_CLASS_CONFIG_INFO  sNICM;               // NIC Miniport
} HPP_CTRL_CONFIG_INFO, *PHPP_CTRL_CONFIG_INFO;


//
// Information returned by the Controller Configuration Query.
//

typedef struct _hpp_controller_info                     // Get          Set
{                                                       // ----------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        N/A
   E_HPP_SUPPORT_CLASS     eSupportClass;          // Output       N/A
   ULONG                   ulSupportVersion;       // Output       N/A
   HPP_CTRL_CONFIG_INFO    sController;            // Output       N/A
} HPP_CTRL_INFO, *PHPP_CTRL_INFO;




//----------------------------------------------------------------------
// Structure Name:      HPP Controller Status
//
// Description:         Called by the HPP RCMC to determine the status
//                      information of the all controllers controlled 
//                      by the instance of the driver.
//
//                      IOCTL:          HPP_IOCTL_CONTROLLER_STATUS_OFFSET
//
//---------------------------------------------------------------------

//
// Information returned by the Controller Status Query.
// Each support class will return different information.
// 

//HOT PLUG DRIVER STATUS Defines

#define HPP_STATUS_NORMAL                       0x00
#define HPP_STATUS_ADAPTER_CHECK           0x01
#define HPP_STATUS_LINK_FAILURE                 0x02
#define HPP_STATUS_MEDIA_FAILURE           0x03


#define HPP_STATUS_USER_SIMULATED_FAILURE  0x10
#define HPP_STATUS_POWER_OFF_FAULT              0x40
#define HPP_STATUS_ADAPTER_BUSY                 0x50



typedef struct _hpp_controller_status           // Get          Set
{                                               // -------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // Input        N/A
   ULONG           ulStatus;               // Output       N/A
} HPP_CTRL_STATUS, *PHPP_CTRL_STATUS;


//----------------------------------------------------------------------
// Structure Name:      HPP Controller Slot Type
//
// Description:         Called by the HPP RCMC to get or set
//                      what type of slot the controller is installed in.
//
//                      Can also be used to query slot information.
//
//                      IOCTL:          HPP_IOCTL_SLOT_TYPE_OFFSET
//
//---------------------------------------------------------------------

//
// Controller slot type definition
//

typedef enum    _hpp_slot_type
{
   HPPST_UNKNOWN_SLOT,             // 0
   HPPST_NORMAL_SLOT,              // 1 -- Could PCI or EISA
   HPPST_HOTPLUG_PCI_SLOT,         // 2 -- PCI only
} E_HPP_SLOT_TYPE;


typedef struct _hpp_controller_slot_type        // Get          Set
{                                               // -------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // Input        Input
   E_HPP_SLOT_TYPE eSlotType;              // Output       Input
} HPP_CTRL_SLOT_TYPE, *PHPP_CTRL_SLOT_TYPE;



//----------------------------------------------------------------------
// Structure Name:      HPP Controller Slot Event
//
// Description:         Called by the HPP Service to get or set
//                      the Controller's slot status.
//                                           
//
//                      IOCTL:          HPP_IOCTL_SLOT_EVENT_OFFSET
//
//---------------------------------------------------------------------

//
// Each of the following are mutually exclusive.  If two 
// status events occur simultaneously, the service will serialize
// them to the drivers.
//

typedef enum    _hpp_slot_status
{
   HPPSS_UNKNOWN,          // 0

   HPPSS_NORMAL_OPERATION, // 1    // Restore from Simulated Failure
   HPPSS_SIMULATED_FAILURE,// 2    // Enter Simulated Failure Mode

   HPPSS_POWER_FAULT,      // 3    // Power fault occured, error!!!!

   HPPSS_POWER_OFF_WARNING,// 4    // Power On/Off conditions
   HPPSS_POWER_OFF,        // 5
   HPPSS_POWER_ON_WARNING, // 6
   HPPSS_POWER_ON,         // 7
   //The following defines are for the SCSI miniport drivers
   HPPSS_RESET_WARNING,    // 8    // PCI level slot reset
   HPPSS_RESET,            // 9  
    // Compaq reserves A to F
} E_HPP_SLOT_STATUS;


typedef struct _hpp_slot_event                          // Get          Set
{                                                       // -------------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        Input
   E_HPP_SLOT_STATUS       eSlotStatus;            // Output       Input
} HPP_SLOT_EVENT, *PHPP_SLOT_EVENT;


//----------------------------------------------------------------------
// Structure Name:      HPP PCI Configuration Map
//
// Description:         Called by the HPP Service to get the
//                      device's PCI configuration map.
//
//                      IOCTL:          HPP_IOCTL_PCI_CONFIG_MAP_OFFSET
//
//---------------------------------------------------------------------



//
// Defines for the Map Version
//
//      Version information:
//      0xrrrrMMmm
//      ----------
//          | |  |
//          | |  +-- Minor Version information
//          | +----- Major Version information
//          +------- Currently reserved
//
// The RCMC service will consider minor revisions within the same
// Major version compatible (i.e. all structures are the same size,
// etc.).  If the service encounters an unknown Major Version
// it should consider the interface incompatible.
//



#define HPP_CONFIG_MAP_VERSION_10       0x00000100      // Version 1.00




typedef struct _hpp_pci_config_range
{
   UCHAR   ucStart;        // Start Offset of PCI config space.
   UCHAR   ucEnd;          // Ending Offset of PCI config space.
   ULONG   ulControlFlags; // RCMC flags, not for driver's use.

   ULONG   ulReserved [4]; // Reserved for Future use
} HPP_PCI_CONFIG_RANGE, *PHPP_PCI_CONFIG_RANGE;

typedef struct _hpp_device_info
{
   PCI_DESC                sPciDescriptor; // Bus Number, Dev/Func #
   ULONG                   ulReserved [4]; // Reserved for Future use.

   UCHAR                         ucBaseAddrVerifyCount;   //Number of base address register lengths to verify
   ULONG                         ulBaseAddrLength[6];     //Base address lengths for each device
                                                               //the hot plug service verifys the new length on a powered on
                                                               //board to be <= what is saved here by the driver at init
                                                               //The verify is done on each device that has a non-zero count
                                                               //from length[0] to length[count-1]
   ULONG                   ulNumberOfRanges;// Number of ranges for this device
   HPP_PCI_CONFIG_RANGE    sPciConfigRangeDesc [16];
   void *                  pPciConfigSave [16];//used by RCMC service to save config values
                                                          //not for driver's use.
} HPP_DEVICE_INFO, *PHPP_DEVICE_INFO;

typedef struct _hpp_pci_config_map              // Get          Set
{                                               // --------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // Input        N/A

   ULONG           ulPciConfigMapVersion;  // Output       N/A
   ULONG           ulReserved [4];         // N/A          N/A

   ULONG           ulNumberOfPciDevices;   // Output       N/A
   HPP_DEVICE_INFO sDeviceInfo [3];        // Output       N/A
} HPP_PCI_CONFIG_MAP, *PHPP_PCI_CONFIG_MAP;




//----------------------------------------------------------------------
// Structure Name:      HPP Stop RCMC Service
//
// Description:         Called by an application to request the driver
//                      issue the 'Stop Service' IOCTL to the RCMC.
//
//                      IOCTL:          HPP_IOCTL_STOP_RCMC_OFFSET
//
//---------------------------------------------------------------------

typedef struct  _hpp_stop_service               // Get          Set
{                                               // ---------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // N/A          Input
   ULONG           ulHppSecuritySignature; // N/A          Input
} HPP_STOP_RCMC, *PHPP_STOP_RCMC;



//----------------------------------------------------------------------
// Structure Name:      HPP Run Diagnostics
//
// Description:         Called by the HPP Service to start diagnostics
//                      on the given controller.
//
//                      The service will request the diags to begin
//                          and expect the driver to return immediately with
//                          SUCCESS if the diags are supported or with
//                          HPP_DIAGS_NOT_SUPPORTED  if diags are not supported.
//
//                          Once the diags are completed, the drivers will 
//                          send an event via Sysmgmt to inform the service
//                          of the outcome of the diags.
//
//                      IOCTL:     #define HPP_IOCTL_RUN_DIAGS_OFFSET              0x08    //              X

//
//---------------------------------------------------------------------

//
// List of modes of diags to run.
//

typedef enum    _hpp_diag_mode
{
   HPPDT_ON_LINE,          // 0
   HPPDT_OFF_LINE,               // 1
} E_HPP_DIAG_MODE;


typedef struct _hpp_start_diags                     // Get          Set
{                                                   // -------------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        Input
   E_HPP_DIAG_MODE             eDiagMode;              // Input        Input
} HPP_RUN_DIAGS, *PHPP_RUN_DIAGS;



//----------------------------------------------------------------------
// Structure Name:     SetOIDValue
//
// Description:   
//
//           NT's miniport architecture doesn't allow
//           an application to issue a 'Set' request
//           to the driver. This is a very nice and
//           needed functionality.  Therefore we have
//           implemented this jumbo hack.
//           This OID is a 'Get' OID, but it calls the
//           'Set' handler within the driver.  Therefore
//           it will work with whatever OID we support via
//           sets.
//
//           
//---------------------------------------------------------------------

typedef struct _set_oid_value
{
   ULONG     Signature;          
   ULONG     OID;
   PVOID     InformationBuffer;
   ULONG     InformationBufferLength;
   PULONG    BytesRead;
   PULONG    BytesNeeded;
} SET_OID_VALUE, *PSET_OID_VALUE;

//
// 'Security' signature used for the 'Set' OID.  Since this
// is accessed through the 'Get' handler, we don't just want
// anyone using it.
//

#define OID_SECURITY_SIGNATURE                  0x504D4450
#define HPP_OID_BASE_ADDRESS_DEFAULT          0xff020400
#define OID_NETFLEX3_SET_OID_VALUE_RELATIVE          0xff020316
#define NETFLEX3_OID_SECURITY_SIGNATURE         0x504D4450


#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ioctl.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Ioctl.c

Abstract:

    Ioctl Handler

Author:

    

Revision History:

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/ioctl.c $

Revision History:

    $Revision: 8 $
    $Date: 11/10/00 5:51p $
    $Modtime:: $

Note: See Agilent's IOCTL specification for further detail
--*/

#include "buildop.h"
#include "osflags.h"
#include "hhba5100.ver"

#ifdef _SAN_IOCTL_
#include "sanioctl.h"
#endif

#ifdef _FCCI_SUPPORT
ULONG FCCIIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN    *LinkResetPerformed,
    BOOLEAN    *DeviceResetPerformed,
    UCHAR       *srb_status,
    UCHAR       *PathId, 
    UCHAR       *TargetId
    );
#endif

void
HPFillDriverInfo(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDriverInformation_t *hpFcDriverInfo,
    UCHAR *status
    )
{
    osStringCopy(hpFcDriverInfo->DriverName, DRIVER_NAME, MAX_HP_FC_DRIVER_NAME_SIZE);
    osStringCopy(hpFcDriverInfo->DriverDescription, DRIVER_DESCRIPTION,
            MAX_HP_FC_DRIVER_DESC_SIZE);
    hpFcDriverInfo->MajorRev = DRIVER_MAJOR_REV;
    hpFcDriverInfo->MinorRev = DRIVER_MINOR_REV;
}

void
HPFillCardConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcCardConfiguration_t *hpFcCardConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agFCChanInfo_t  chanInfo;
    agRoot_t        *hpRoot=&pCard->hpRoot;

    fcGetChannelInfo (hpRoot, &chanInfo);

    hpFcCardConfig->PCIBusNumber = (UCHAR)pCard->SystemIoBusNumber;
    hpFcCardConfig->PCIDeviceNumber = (UCHAR)pCard->SlotNumber;
    hpFcCardConfig->PCIFunctionNumber = 0;
    hpFcCardConfig->PCIBaseAddress0 = 0;        /* Reserved field in Tachlite */
    hpFcCardConfig->PCIBaseAddress0Size = 0;    /* Reserved field in Tachlite */

#if defined(HP_NT50)
   //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress1 = PtrToUlong(pCard->IoLBase);
#else
    hpFcCardConfig->PCIBaseAddress1 = (ULONG)(pCard->IoLBase);
#endif

    hpFcCardConfig->PCIBaseAddress1Size = 256;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress2 = PtrToUlong(pCard->IoUpBase);
#else
    hpFcCardConfig->PCIBaseAddress2 = (ULONG)(pCard->IoUpBase);
#endif
    
    hpFcCardConfig->PCIBaseAddress2Size = 256;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress3 = PtrToUlong(pCard->MemIoBase);
#else    
    hpFcCardConfig->PCIBaseAddress3 = (ULONG)(pCard->MemIoBase);
#endif

    hpFcCardConfig->PCIBaseAddress3Size = 512;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress4 = PtrToUlong(pCard->RamBase);
#else
    hpFcCardConfig->PCIBaseAddress4 = (ULONG)(pCard->RamBase);
#endif    
   
    hpFcCardConfig->PCIBaseAddress4Size = pCard->RamLength;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress5 = PtrToUlong(pCard->RomBase);
#else 
    hpFcCardConfig->PCIBaseAddress5 = (ULONG)(pCard->RomBase);
#endif
    
    hpFcCardConfig->PCIBaseAddress5Size = pCard->RomLength;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIRomBaseAddress = PtrToUlong(pCard->AltRomBase);
#else
    hpFcCardConfig->PCIRomBaseAddress = (ULONG)(pCard->AltRomBase);
#endif
    
    hpFcCardConfig->PCIRomSize = pCard->AltRomLength;
    osCopy(hpFcCardConfig->NodeName, chanInfo.NodeWWN, 8);
    osCopy(hpFcCardConfig->PortName, chanInfo.PortWWN, 8);
    hpFcCardConfig->Topology = HP_FC_PRIVATE_LOOP;
    hpFcCardConfig->HardAddress = chanInfo.HardAddress.AL_PA;
    hpFcCardConfig->NportId = (ULONG) chanInfo.CurrentAddress.AL_PA;

}

void
HPFillDeviceConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceConfiguration_t *hpFcDeviceConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{   
    agFCDev_t hpFcDev;
    agFCDevInfo_t hpFcDevInfo;
    UCHAR PathId, TargetId, Lun;
    agRoot_t * hpRoot=&pCard->hpRoot;
    PLU_EXTENSION pLunExt = NULL; /* added for YAM21 support */
    LUN tempLun;                        /* added for FCP Lun data */
    PLUN ptempLun = &tempLun;

    PathId = hpFcDeviceConfig->DeviceAddress.PathId;
    TargetId = hpFcDeviceConfig->DeviceAddress.TargetId;
    Lun = hpFcDeviceConfig->DeviceAddress.Lun;
   
    /* Grab the Lun Extension, to be used in MapToHandle */
    pLunExt = ScsiPortGetLogicalUnit(pCard,
                                        PathId,
                                        TargetId,
                                        Lun );
                                        
    hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
    if (hpFcDev != NULL) 
    {
        fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
        osCopy(hpFcDeviceConfig->NodeName, hpFcDevInfo.NodeWWN, 8);
        osCopy(hpFcDeviceConfig->PortName, hpFcDevInfo.PortWWN, 8);
        hpFcDeviceConfig->HardAddress = hpFcDevInfo.HardAddress.AL_PA;
        hpFcDeviceConfig->NportId = hpFcDevInfo.CurrentAddress.AL_PA;
        hpFcDeviceConfig->Present = (os_bit8)hpFcDevInfo.Present;
        hpFcDeviceConfig->LoggedIn = (os_bit8)hpFcDevInfo.LoggedIn;
        hpFcDeviceConfig->ClassOfService = hpFcDevInfo.ClassOfService;
        hpFcDeviceConfig->MaxFrameSize = hpFcDevInfo.MaxFrameSize;
        /*fill common parameters*/
        hpFcDeviceConfig->CmnParams.FC_PH_Version__BB_Credit =
          hpFcDevInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit;
        hpFcDeviceConfig->CmnParams.Common_Features__BB_Recv_Data_Field_Size =
          hpFcDevInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size;
        hpFcDeviceConfig->CmnParams.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category =
          hpFcDevInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category;
        hpFcDeviceConfig->CmnParams.E_D_TOV = hpFcDevInfo.N_Port_Common_Parms.E_D_TOV;
        /*fill class1 parameters*/
        hpFcDeviceConfig->Class1Params.Class_Validity__Service_Options__Initiator_Control_Flags =
          hpFcDevInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags;
        hpFcDeviceConfig->Class1Params.Recipient_Control_Flags__Receive_Data_Size =
          hpFcDevInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size;
        hpFcDeviceConfig->Class1Params.Concurrent_Sequences__EE_Credit =
          hpFcDevInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit;
        hpFcDeviceConfig->Class1Params.Open_Sequences_per_Exchange =
          hpFcDevInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange;
        /*fill class2 parameters*/
        hpFcDeviceConfig->Class2Params.Class_Validity__Service_Options__Initiator_Control_Flags =
          hpFcDevInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags;
        hpFcDeviceConfig->Class2Params.Recipient_Control_Flags__Receive_Data_Size =
          hpFcDevInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size;
        hpFcDeviceConfig->Class2Params.Concurrent_Sequences__EE_Credit =
          hpFcDevInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit;
        hpFcDeviceConfig->Class2Params.Open_Sequences_per_Exchange =
          hpFcDevInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange;
        /*fill class3 parameters*/
        hpFcDeviceConfig->Class3Params.Class_Validity__Service_Options__Initiator_Control_Flags =
          hpFcDevInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags;
        hpFcDeviceConfig->Class3Params.Recipient_Control_Flags__Receive_Data_Size =
          hpFcDevInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size;
        hpFcDeviceConfig->Class3Params.Concurrent_Sequences__EE_Credit =
          hpFcDevInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit;
        hpFcDeviceConfig->Class3Params.Open_Sequences_per_Exchange =
          hpFcDevInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange;
          
        /* Get the FCP lun data */
       
        memset(ptempLun, 0, sizeof(LUN));
        #ifdef YAM2_1
        if(pLunExt)
        {
            switch(pLunExt->Mode)
            {
                case PA_DEVICE_TRY_MODE_VS:
                    SET_VS_LUN(ptempLun, PathId, TargetId, Lun)
                    break;
         
                case PA_DEVICE_TRY_MODE_LU:
                    SET_LU_LUN(ptempLun, PathId, TargetId, Lun)
                    break;
            
                case PA_DEVICE_TRY_MODE_PA:
                    SET_PA_LUN(ptempLun, PathId, TargetId, Lun)
                    break;
            } // end switch
        } // end if ( pLunExt )
        memcpy(&(hpFcDeviceConfig->Lun), ptempLun, sizeof(LUN)); 
        #endif
    }
    else 
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPFillLinkStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcLinkStatistics_t *hpFcLinkStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    hpFcLinkStat->ResetCount = pCard->External_ResetCount + pCard->Internal_ResetCount;
    hpFcLinkStat->LinkDownCount = hpFcLinkStat->ResetCount + pCard->LIPCount;
    hpFcLinkStat->LinkState = (pCard->LinkState == LS_LINK_UP) ? TRUE : FALSE;
}
 
void
HPFillDevStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceStatistics_t *hpFcDevStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agFCDev_t hpFcDev;
    agFCDevInfo_t hpFcDevInfo;
    UCHAR PathId, TargetId, Lun;
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    PathId = hpFcDevStat->DeviceAddress.PathId;
    TargetId = hpFcDevStat->DeviceAddress.TargetId;
    Lun = hpFcDevStat->DeviceAddress.Lun;
    hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, NULL);
    if (hpFcDev != NULL) 
    {
        fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
        hpFcDevStat->LoginRetries = hpFcDevInfo.LoginRetries;
        hpFcDevStat->ReadsRequested = hpFcDevInfo.ReadsRequested;
        hpFcDevStat->ReadsCompleted = hpFcDevInfo.ReadsCompleted;
        hpFcDevStat->ReadsFailed = hpFcDevInfo.ReadFailures;
        hpFcDevStat->BytesReadUpper32 = hpFcDevInfo.BytesReadUpper32;
        hpFcDevStat->BytesReadLower32 = hpFcDevInfo.BytesReadLower32;
        hpFcDevStat->WritesRequested = hpFcDevInfo.WritesRequested;
        hpFcDevStat->WritesCompleted = hpFcDevInfo.WritesCompleted;
        hpFcDevStat->WritesFailed = hpFcDevInfo.WriteFailures;
        hpFcDevStat->BytesWrittenUpper32 = hpFcDevInfo.BytesWrittenUpper32;
        hpFcDevStat->BytesWrittenLower32 = hpFcDevInfo.BytesWrittenLower32;
        hpFcDevStat->NonRWRequested = hpFcDevInfo.NonRWRequested;
        hpFcDevStat->NonRWCompleted = hpFcDevInfo.NonRWCompleted;
        hpFcDevStat->NonRWFailures = hpFcDevInfo.NonRWFailures;
    }
    else 
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPDoLinkReset(
    PSRB_IO_CONTROL srbIoCtl,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    pCard->State |= CS_DURING_RESET_ADAPTER;
    pCard->External_ResetCount++;
 
    fcResetChannel (hpRoot, fcSyncReset);
 
    ScsiPortNotification(ResetDetected, pCard, NULL);
 
    pCard->State &= ~CS_DURING_RESET_ADAPTER;
  
}

void
HPDoDevReset(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceReset_t *hpFcDevReset,
    PCARD_EXTENSION pCard,
    UCHAR *PathId,
    UCHAR *TargetId,
    UCHAR *status
    )
{   
    agRoot_t * hpRoot=&pCard->hpRoot;
    agFCDev_t hpFcDev;
    ULONG ResetStatus;
    UCHAR Lun;
 
    *PathId = hpFcDevReset->DeviceAddress.PathId;
    *TargetId = hpFcDevReset->DeviceAddress.TargetId;
    Lun = hpFcDevReset->DeviceAddress.Lun;
    hpFcDev = MapToHandle(pCard, *PathId, *TargetId, Lun, NULL);
    if (hpFcDev == NULL ||
       (ResetStatus = fcResetDevice(hpRoot, hpFcDev, fcHardReset)) != fcResetSuccess) 
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPDoRegRead(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegRead_t *hpFcRegRead,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    if (hpFcRegRead->RegOffset <= 0x1ff) 
    {
        hpFcRegRead->RegData = osChipMemReadBit32(
                                                 hpRoot,
                                                 hpFcRegRead->RegOffset
                                                );
    }
    else 
    {
       srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPDoRegWrite(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegWrite_t *hpFcRegWrite,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    if (hpFcRegWrite->RegOffset <= 0x1ff) 
    {
        osChipMemWriteBit32(
                           hpRoot,
                           hpFcRegWrite->RegOffset,
                           hpFcRegWrite->RegData
                           );
    }
    else 
    {
       srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}



ULONG HPIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN     *LinkResetPerformed,
    BOOLEAN     *DeviceResetPerformed,
    UCHAR    *srb_status,
    UCHAR    *PathId, 
    UCHAR    *TargetId
    )
{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    PSRB_IO_CONTROL srbIoCtl;
    UCHAR status;
//  PSRB_IO_CONTROL srbIoCtl;
// ULONG    done = FALSE;
//   UCHAR    srbPathId = Srb->PathId;
//   UCHAR    srbTargetId = Srb->TargetId;
//   UCHAR    srbLun = Srb->Lun;

    status = *srb_status;
    srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    
    switch (srbIoCtl->ControlCode) 
    {
        case HP_FC_IOCTL_GET_DRIVER_INFO : 
        {
            hpFcDriverInformation_t *hpFcDriverInfo;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                               sizeof(hpFcDriverInformation_t))) &&
                                              (srbIoCtl->Length >= sizeof(hpFcDriverInformation_t))) 
            {
                hpFcDriverInfo = (hpFcDriverInformation_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillDriverInfo(srbIoCtl, hpFcDriverInfo, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_CARD_CONFIG : 
        {
            hpFcCardConfiguration_t *hpFcCardConfig;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                               sizeof(hpFcCardConfiguration_t))) &&
                        (srbIoCtl->Length >= sizeof(hpFcCardConfiguration_t))) 
            {
                hpFcCardConfig = (hpFcCardConfiguration_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillCardConfig(srbIoCtl, hpFcCardConfig, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_DEVICE_CONFIG : 
        {
            hpFcDeviceConfiguration_t *hpFcDeviceConfig;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                           sizeof(hpFcDeviceConfiguration_t))) &&
                       (srbIoCtl->Length >= sizeof(hpFcDeviceConfiguration_t))) 
            {
                hpFcDeviceConfig = (hpFcDeviceConfiguration_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillDeviceConfig(srbIoCtl, hpFcDeviceConfig, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_LINK_STATISTICS : 
        {
            hpFcLinkStatistics_t *hpFcLinkStat;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                     sizeof(hpFcLinkStatistics_t))) &&
                   (srbIoCtl->Length >= sizeof(hpFcLinkStatistics_t))) 
            {
                hpFcLinkStat = (hpFcLinkStatistics_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillLinkStat(srbIoCtl, hpFcLinkStat, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_DEVICE_STATISTICS : 
        {
            hpFcDeviceStatistics_t *hpFcDevStat;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                              sizeof(hpFcDeviceStatistics_t))) &&
                   (srbIoCtl->Length >= sizeof(hpFcDeviceStatistics_t))) 
            {
                hpFcDevStat = (hpFcDeviceStatistics_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillDevStat(srbIoCtl, hpFcDevStat, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_LINK_RESET : 
        {
            HPDoLinkReset(srbIoCtl, pCard, &status);
            *LinkResetPerformed = TRUE;
            break;
        }

        case HP_FC_IOCTL_DEVICE_RESET : 
        {
            hpFcDeviceReset_t *hpFcDevReset;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                sizeof(hpFcDeviceReset_t))) &&
                   (srbIoCtl->Length >= sizeof(hpFcDeviceReset_t))) 
            {
                hpFcDevReset = (hpFcDeviceReset_t *)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPDoDevReset(
                    srbIoCtl,
                    hpFcDevReset,
                    pCard,
                    PathId,
                    TargetId,
                    &status
                    );
                *DeviceResetPerformed = TRUE;
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_REG_READ : 
        {
            hpFcRegRead_t *hpFcRegRead;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                     sizeof(hpFcRegRead_t))) &&
                    (srbIoCtl->Length >= sizeof(hpFcRegRead_t))) 
            {
                hpFcRegRead = (hpFcRegRead_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPDoRegRead(srbIoCtl, hpFcRegRead, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_REG_WRITE : 
        {
            hpFcRegWrite_t *hpFcRegWrite;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                     sizeof(hpFcRegWrite_t))) &&
                    (srbIoCtl->Length >= sizeof(hpFcRegWrite_t))) 
            {
                hpFcRegWrite = (hpFcRegWrite_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPDoRegWrite(srbIoCtl, hpFcRegWrite, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        default :
            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: MiniportIOCtl not supported\n"));
            srbIoCtl->ReturnCode = HP_FC_RTN_BAD_CTL_CODE;
    } // end IOCTL switch
           
    *srb_status = status;
    return 0;
           
}



ULONG DoIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    SCSI_NOTIFICATION_TYPE  notify_type = NextRequest;
    UCHAR status;
    PSRB_IO_CONTROL srbIoCtl;
    BOOLEAN LinkResetPerformed = FALSE;
    BOOLEAN DeviceResetPerformed = FALSE;
    UCHAR PathId, TargetId;
    ULONG    done = FALSE;
    UCHAR    srbPathId = Srb->PathId;
    UCHAR    srbTargetId = Srb->TargetId;
    UCHAR    srbLun = Srb->Lun;
 
    status = SRB_STATUS_SUCCESS;
    if (Srb->DataTransferLength < sizeof(SRB_IO_CONTROL)) 
    {
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIO: MiniportIOCtl insufficient DataTransferLength\n"));

        pSrbExt->SRB_State = RS_COMPLETE;
        status = SRB_STATUS_INVALID_REQUEST;
        done = TRUE;
    }   
       
    if (done == FALSE)
    {
        srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
 
        /* Agilent Standard IOCTL */      
        if (osMemCompare(srbIoCtl->Signature, HP_FC_IOCTL_SIGNATURE, sizeof(srbIoCtl->Signature)) == TRUE) 
        {
            srbIoCtl->ReturnCode = HP_FC_RTN_OK;
            HPIoctl(pCard, Srb, &LinkResetPerformed, &DeviceResetPerformed, &status, &PathId, &TargetId);
            done = TRUE;
        } //Signature matched

        /* FCCI Standard IOCTL */      
        #ifdef _FCCI_SUPPORT
        if (osMemCompare(srbIoCtl->Signature, FCCI_SIGNATURE, sizeof(srbIoCtl->Signature)) == TRUE) 
        {
            srbIoCtl->ReturnCode = HP_FC_RTN_OK;
            FCCIIoctl(pCard, Srb, &LinkResetPerformed, &DeviceResetPerformed, &status, &PathId, &TargetId);
            done = TRUE;
        } //Signature matched
        #endif
      
        /* Agilent SAN IOCTL */     
        #ifdef _SAN_IOCTL_
        if (osMemCompare(srbIoCtl->Signature, AG_SAN_IOCTL_SIGNATURE, sizeof(srbIoCtl->Signature)) == TRUE) 
        {
            srbIoCtl->ReturnCode = HP_FC_RTN_OK;
            AgSANIoctl(pCard, Srb, &LinkResetPerformed, &DeviceResetPerformed, &status, &PathId, &TargetId);
            done = TRUE;
        } //Signature matched
        #endif
      
        /* Add additional IOCTL signature here */
      
        /* None of the signatures is found, reort error */
        if (done == FALSE)
        {
            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: MiniportIOCtl not supported:%s != %s\n",
                srbIoCtl->Signature, HP_FC_IOCTL_SIGNATURE));

            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIO: MiniportIOCtl not supported\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            status = SRB_STATUS_INVALID_REQUEST;
        }
    } //end case SRB_FUNCTION_IO_CONTROL

    Srb->SrbStatus = status;
    pSrbExt->SRB_State = RS_COMPLETE;

    ScsiPortNotification(notify_type,
                                 pCard,
                                 srbPathId,
                                 srbTargetId,
                                 srbLun);

    ScsiPortNotification(RequestComplete,
                             pCard,
                             Srb);

    if (LinkResetPerformed == TRUE) 
    {
        doPostResetProcessing (pCard);
    }
    if (DeviceResetPerformed == TRUE) 
    {
        completeRequests (pCard, PathId, TargetId, SRB_STATUS_BUS_RESET);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ip.h ===
/*++

Purpose:

  This file defines the macros, types, and data structures used by ../C/IP.C

--*/

#ifndef __IP_H__
#define __IP_H__

#ifdef _DvrArch_1_30_

#define fiComputeBroadcast_D_ID(CThread)            \
    (   CThread->ChanInfo.CurrentAddress.Domain     \
     || CThread->ChanInfo.CurrentAddress.Area   ?   \
       FC_Well_Known_Port_ID_Broadcast_Alias_ID :   \
       FC_Broadcast_Replicate_AL_PA               )
       

void fiFillInIPFrameHeader_OffCard(
                                    PktThread_t *PktThread,
                                    os_bit32       D_ID
                                  );

void fiFillInIPNetworkHeader_OffCard(
                                      PktThread_t *PktThread
                                    );

os_bit32 fiFillInIPData(
                         PktThread_t *PktThread
                       );

os_bit32 fiFillInIPData_OnCard(
                                PktThread_t *PktThread
                              );

os_bit32 fiFillInIPData_OffCard(
                                 PktThread_t *PktThread
                               );

#define fiIP_Cmd_Status_Incoming         0x00000030
#define fiIP_Cmd_Status_Confused         0xFFFFFFFF 

osGLOBAL os_bit32 fiIPProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t  SFQConsIndex,
                                  os_bit32        Frame_Length,
                                  fi_thread__t    **Thread_to_return
                                );

osGLOBAL os_bit32 fiIPProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t  SFQConsIndex,
                                         os_bit32        Frame_Length,
                                         fi_thread__t    **Thread_to_return
                                       );

osGLOBAL os_bit32 fiIPProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t  SFQConsIndex,
                                          os_bit32        Frame_Length,
                                          fi_thread__t    **Thread_to_return
                                        );

osGLOBAL void fiIPProcess_Incoming_OffCard(
                                            agRoot_t *hpRoot,
                                            os_bit32  Frame_Length,
                                            FCHS_t   *FCHS,
                                            os_bit8  *Payload,
                                            os_bit32  Payload_Wrap_Offset,
                                            os_bit8  *Payload_Wrapped
                                          );
#endif /* _DvrArch_1_30_ was defined */
#endif /*  __IP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ip.c ===
/*++

Purpose:

  This file implements IP specific services for the FC Layer.

--*/
#ifdef _DvrArch_1_30_

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/ipstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/ip.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "ipstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "ip.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */



void fiFillInIPFrameHeader_OffCard(
                                     PktThread_t *PktThread,
                                     os_bit32     D_ID
                                   )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t    *hpRoot       = PktThread->thread_hdr.hpRoot;
    DevThread_t *DevThread    = PktThread->Device;
    CThread_t   *CThread      = CThread_ptr(hpRoot);
    FCHS_t      *IP_Header    = PktThread->Pkt_CMND_Ptr;
    os_bit32     R_CTL__D_ID;
    os_bit32     S_ID = 0;
    os_bit32     TYPE__F_CTL;
    os_bit32     OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(CThread);

    R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                   | FC_Frame_Header_R_CTL_Lo_Unsolicited_Data
                   | D_ID                                             );

    TYPE__F_CTL = (  FC_Frame_Header_TYPE_8802_2_LLC_SNAP
                   | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                   | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                   | (DevThread->NewIPExchange ? FC_Frame_Header_F_CTL_First_Sequence : 0 )
                   | FC_Frame_Header_F_CTL_End_Sequence);

    OX_ID__RX_ID = (  (DevThread->IP_X_ID << FCHS_OX_ID_SHIFT)
                    | (0xFFFF             << FCHS_RX_ID_SHIFT));

    IP_Header->MBZ1                                        = 0;
    IP_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp = FCHS_SOF_SOFi3
                                                           | FCHS_EOF_EOFn
                                                           | FCHS_CLS
							   | 1 << FCHS_LCr_SHIFT;
    IP_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    IP_Header->CS_CTL__S_ID                                = S_ID;
    IP_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    IP_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_Network_Header;
    IP_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    IP_Header->RO                                          = 0;

    fiLogDebugString(
                      hpRoot,
                      PktStateLogConsoleLevel,
                      " <<< IPData -- 0x%06X -> 0x%06X >>>",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      S_ID,
                      D_ID,
                      0,0,0,0,0,0
                    );

#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiFillInIPNetworkHeader_OffCard(
                                      PktThread_t *PktThread
                                    )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot                  = PktThread->thread_hdr.hpRoot;
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    os_bit8   *pNetwork_Header         = (os_bit8 *) PktThread->Pkt_CMND_Ptr + sizeof(FCHS_t);
    os_bit32   Bit8_Index;

/*+
Fill in Network Destination Address
-*/
    for (Bit8_Index = 0; Bit8_Index < sizeof(FC_N_Port_Name_t); Bit8_Index++)
        *pNetwork_Header++ = PktThread->Device->DevInfo.PortWWN[Bit8_Index];

/*+
Fill in Network Source Address
-*/
    for (Bit8_Index = 0; Bit8_Index < sizeof(FC_N_Port_Name_t); Bit8_Index++)
        *pNetwork_Header++ = CThread->ChanInfo.PortWWN[Bit8_Index];

#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInIPData(
                         PktThread_t *PktThread
                       )
{
    if (CThread_ptr(PktThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.Pkt_CMND.memLoc == inCardRam)
    {
        return fiFillInIPData_OnCard( PktThread );
    }
    else /* CThread_ptr(PktThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.Pkt_CMND.memLoc == inDmaMemory */
    {
        return fiFillInIPData_OffCard( PktThread );
    }
}

os_bit32 fiFillInIPData_OnCard(
                               PktThread_t *PktThread
                              )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    return (os_bit32)0;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInIPData_OffCard(
                                 PktThread_t *PktThread
                               )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *pCThread     = CThread_ptr(PktThread->thread_hdr.hpRoot);
    DevThread_t           *pDevThread   = PktThread->Device;
    FCHS_t                *IP_Header    = PktThread->Pkt_CMND_Ptr;
    os_bit8               *IP_Payload   = (os_bit8 *)IP_Header + sizeof(FCHS_t) + 2 * sizeof(FC_N_Port_Name_t);
    os_bit32               D_ID=0;

/*+
Fill in IP Frame Header
-*/
    if (pDevThread == (DevThread_t *)pCThread->IP)
        D_ID = fiComputeBroadcast_D_ID( pCThread ); 
    else
        D_ID = fiComputeDevThread_D_ID( pDevThread ); 

    fiFillInIPFrameHeader_OffCard(
                                   PktThread,
                                   D_ID
                                 );
/*+
Fill in IP Network Header
-*/
    fiFillInIPNetworkHeader_OffCard(
                                     PktThread
                                   );
/*+
Fill in IP Device Data Payload
-*/
    osFcNetGetData((void* )IP_Payload, (void *) PktThread->osData, PktThread->DataLength);

/*+
Return length of IP Data Frame (including FCHS, Network Header and Payload)
-*/

    return sizeof(FCHS_t) + 2 * sizeof(FC_N_Port_Name_t) + PktThread->DataLength;
#endif /* __MemMap_Force_On_Card__ was not defined */
}



osGLOBAL os_bit32 fiIPProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t  SFQConsIndex,
                                  os_bit32        Frame_Length,
                                  fi_thread__t    **Thread_to_return
                                )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiIPProcessSFQ_OnCard(
                                      hpRoot,
                                      SFQConsIndex,
                                      Frame_Length,
                                      Thread_to_return
                                    );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiIPProcessSFQ_OffCard(
                                       hpRoot,
                                       SFQConsIndex,
                                       Frame_Length,
                                       Thread_to_return
                                     );
    }
}


osGLOBAL os_bit32 fiIPProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t  SFQConsIndex,
                                         os_bit32        Frame_Length,
                                         fi_thread__t    **Thread_to_return
                                       )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    return fiIP_Cmd_Status_Confused;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}


osGLOBAL os_bit32 fiIPProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t  SFQConsIndex,
                                          os_bit32        Frame_Length,
                                          fi_thread__t    **Thread_to_return
                                        )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                       = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    os_bit8                    *Payload                    = (os_bit8 *)FCHS + sizeof(FCHS_t);
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit8                    *Payload_Wrapped            = (os_bit8 *)Payload - SFQ_MemoryDescriptor->objectSize;
    os_bit32                    R_CTL__D_ID                = FCHS->R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL                = FCHS->TYPE__F_CTL;

    *Thread_to_return = (fi_thread__t *)agNULL;

    /* Note the assumption is that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */
    if ( (R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK) ==
                    (FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame |
	            FC_Frame_Header_R_CTL_Lo_Unsolicited_Data)
            && (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_8802_2_LLC_SNAP )
    {
        fiIPProcess_Incoming_OffCard(
                                      hpRoot,
                                      Frame_Length,
                                      FCHS,
                                      Payload,
                                      Payload_Wrap_Offset,
                                      Payload_Wrapped
                                    );

        return fiIP_Cmd_Status_Incoming;
    }

    return fiIP_Cmd_Status_Confused;

#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiIPProcess_Incoming_OffCard(
                                   agRoot_t *hpRoot,
                                   os_bit32  Frame_Length,
                                   FCHS_t   *FCHS,
                                   os_bit8  *Payload,
                                   os_bit32  Payload_Wrap_Offset,
                                   os_bit8  *Payload_Wrapped
                                 )
{
    os_bit32                    D_ID                       = FCHS->R_CTL__D_ID & FC_Frame_Header_D_ID_MASK;
    os_bit32                    S_ID                       = FCHS->CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;
    IPThread_t                 *IPThread                   = CThread_ptr(hpRoot)->IP;
    void                       *osData;

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "fiIP_Incoming S_ID = %06X D_ID = %06X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      S_ID,
                      D_ID,
                      0,0,0,0,0,0
                    );

    fiListDequeueFromHead( &osData, &IPThread->IncomingBufferLink );

    osFcNetPutData( Payload, Payload_Wrap_Offset, Payload_Wrapped, osData, Frame_Length - sizeof(FCHS_t) );

    IPThread->osData = osData;

    fiSendEvent( &(IPThread->thread_hdr), IPEventIncoming );
}

#endif /* _DvrArch_1_30_ was defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\mapping.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    mapping.c

Abstract:

    YAMS 2.1 implementation

Authors:

    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/mapping.c $

Revision History:
    $Revision: 7 $
    $Date: 11/10/00 5:51p $
    $Modtime: 10/23/00 5:13p $

Notes:

--*/


#include "buildop.h"        //LP021100 build switches

#include "osflags.h"
#include "err_code.h"
#include "mapping.h"

#ifdef YAM2_1

REG_SETTING gRegSetting = 
   {DEFAULT_PaPathIdWidth,
    DEFAULT_VoPathIdWidth,
    DEFAULT_LuPathIdWidth,
    DEFAULT_LuTargetWidth,
    MAXIMUM_TID
   };
   
WWN_TABLE   *gWWNTable=NULL;
ULONG       gMaxPaDevices = MAX_PA_DEVICE;
int         gDeviceExtensionSize;
int         gMaximumTargetIDs = MAXIMUM_TID;

extern ULONG gMultiMode;

#ifdef WWN_TABLE_ENABLE
/*++

Routine Description:

    Read the registry to get WWn and PID-TID assignment
    (NOT Implemented yet) - for Persistent Binding/Fail-Over

Arguments:


Return Value:

    currently always -1

--*/

void ReadDesiredWWNMapping()
{
    ULONG    count=0, x;
    WCHAR    name[64];
   
    RegGetNumberOfPorts();
    if (count)
    {
        gDesiredWWNMapping = (WWN_TABLE *) ExAllocatePool(NonPagedPool, 
        sizeof(WWN_TABLE) + (count -1)*sizeof(WWN_ENTRY) );
    }
    else
    {
      
    }
    return;
}
#endif

/*++

Routine Description:

    Find in the WWN table a WWN entry.
    (Not implemented) - for persistent Binding/Fail Over

Arguments:


Return Value:

    Currently always return a -1 (not Found)

--*/
ULONG FindInWWNTable (PCARD_EXTENSION pCard, UCHAR *nodeWWN)
{
    return (-1L);
}


/*++

Routine Description:

    Search in the device extension, the index in PaTable containing an FChandle Index

Arguments:

    pcard = the DeviceExtension
    fcDeviceIndex = FCDevice handle index to search

Return Value:

    0 to (gMaxPaDevices-1) Good handle 
    gMaxPaDevices and higher represent non existing handle

--*/
ULONG FindInPaDeviceTable(PCARD_EXTENSION pCard, ULONG fcDeviceIndex)
{
    ULONG x;
    PA_DEVICE   *pa = pCard->Dev->PaDevice;
   
    for (x=0; x < gMaxPaDevices; x++) 
    {
        if (pa->Index.Pa.FcDeviceIndex == fcDeviceIndex)
            break;
        pa++;
    }

    return x;
}


/*++

Routine Description:

    Fill the pCard->Dev.PaDevice from the FChandles built from LinkUp events

Arguments:

    pcard = the deviceExtension

Return Value:
    none
   
--*/
void FillPaDeviceTable(PCARD_EXTENSION pCard)
{
    agRoot_t       *hpRoot = &pCard->hpRoot;
    agFCDevInfo_t  devinfo;
    ULONG          x;
    ULONG          here;
    PA_DEVICE      *pa = pCard->Dev->PaDevice; 

    for (x=0; x < gMaxPaDevices; x++) 
    {
        if (pCard->hpFCDev[x]) 
        {
            /* First see if we have this device in our table already */
            here = FindInPaDeviceTable(pCard, x);  
            if (here < gMaxPaDevices  )
            {
                /* found the entry, reactivate*/
                (pa+here)->EntryState = PA_DEVICE_ACTIVE;
                osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Reactivating device at handle %d\n", here ));
            }
            else
            {
                /* don't find the entry */
                fcGetDeviceInfo (hpRoot, pCard->hpFCDev[x], &devinfo );
            
                /* check if this is our card */
                if (devinfo.DeviceType & agDevSelf) 
                {
                    pCard->Dev->CardHandleIndex = x;
                    osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: DevSelf at slot %d\n", x ));
                    continue;
                }

                /* make sure that it is scsi device */
                if (devinfo.DeviceType & agDevSCSITarget)
                {
                    if (FindInWWNTable (pCard,devinfo.NodeWWN) == -1L)
                    {
                        /* Don't find in WWN table, assign our own PID, TID */
                        here = FindInPaDeviceTable(pCard, PA_DEVICE_NO_ENTRY);   /* find an empty slot */
                        if (here < gMaxPaDevices  )
                        {
                            (pa+here)->EntryState = PA_DEVICE_ACTIVE;
                            osCopy((pa+here)->DevInfo.PortWWN, devinfo.PortWWN, 8);
                            osCopy((pa+here)->DevInfo.NodeWWN, devinfo.NodeWWN, 8);
                            (pa+here)->Index.Pa.FcDeviceIndex = (USHORT) x;
                            osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: New device at slot %d assigned handle %d %02x%02x%02x%02x%02x%02x%02x%02x\n", 
                                x, here ,
                                devinfo.NodeWWN[0], devinfo.NodeWWN[1], 
                                devinfo.NodeWWN[2], devinfo.NodeWWN[3], 
                                devinfo.NodeWWN[4], devinfo.NodeWWN[5], 
                                devinfo.NodeWWN[6], devinfo.NodeWWN[7] ));
                        }
                        else
                        {
                            osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Running out of slot\n"));
                            /* Running out of slot
                            * 1. Log the status
                            * 2. don't enable this device
                            */
                        }
                    }
                    else
                    {
                        /* Find an Entry in WWN, use this PID, TID mapping - NOT IMPLEMENTED (YAM2.2)*/
                        osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Found in WWN Table\n"));
                    }
                }
                else
                {
                    osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Found Non agDevSCSITarget at slot %d device type = %x\n",x, devinfo.DeviceType));
                }
            }
        }
    }

    return;
}

/*++

Routine Description:

    setting/resetting a PA handle data struct

Arguments:

    pcard       = the deviceExtension
    devIndex    - PA device index
    flag        - value to set

Return Value:
    none
   
--*/
void SetPaDeviceTable(PCARD_EXTENSION pCard, ULONG devIndex, ULONG flag)
{
    PA_DEVICE      *pa = pCard->Dev->PaDevice;
    ULONG          x; 
    if (devIndex == ALL_DEVICE)
    {
        for (x=0; x < gMaxPaDevices; x++) 
        {
            if ((pa+x)->Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY)   
                (pa+x)->EntryState = (UCHAR)flag;
        }
    }
    else
    {
        if ((pa+devIndex)->Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY)
            (pa+devIndex)->EntryState = (UCHAR)flag;
    }
   
    return ;

}


/*++

Routine Description:

    get the index to paDevice table.

Arguments:

    pcard       = the deviceExtension
    pathId      - SP pathID
    targetId    - SP target ID
    lun         - SP lun
    *addrMode   - (out) addessing mode of this device


Return Value:
    if this number is > gMaxPaDevices, the value is not valid.   
   
--*/
USHORT MapToPaIndex(PCARD_EXTENSION pCard,
    ULONG            pathId,
    ULONG            targetId,
    ULONG            lun,
    CHAR             *addrMode)
{
    REG_SETTING *pRegSetting = &pCard->Dev->Reg;
    ULONG       paDevIndex;
    ULONG       vsDevIndex;
    ULONG       luDevIndex;
   
    /* if not assigned, use the global setting */
    if ( !(pRegSetting->PaPathIdWidth + pRegSetting->VoPathIdWidth + pRegSetting->LuPathIdWidth))
        pRegSetting = &gRegSetting;

    /* initialize Luns */
    paDevIndex = gMaxPaDevices;      /* this will make it invalid index */
   
    /* check addressing mode */
    if ((pathId) < pRegSetting->PaPathIdWidth)
    {
        /* Peripheral Device addressing mode */
        paDevIndex = pathId*pRegSetting->MaximumTids + targetId;
      
        /* fill LUN */
        *addrMode = PA_DEVICE_TRY_MODE_PA;
    }
    else
    {
        if ((pathId) < (pRegSetting->PaPathIdWidth + pRegSetting->VoPathIdWidth) )
        {
            /* Volume Set addressing mode */
            vsDevIndex = (pathId-pRegSetting->PaPathIdWidth)*pRegSetting->MaximumTids + targetId;
            if (vsDevIndex < MAX_VS_DEVICE)
            {
                paDevIndex = pCard->Dev->VsDevice[vsDevIndex].Vs.PaDeviceIndex;
                if (paDevIndex == PA_DEVICE_NO_ENTRY)  
                paDevIndex = gMaxPaDevices;      /* this will make it invalid index */
            }
            *addrMode = PA_DEVICE_TRY_MODE_VS;
        }
        else
        {
            /* logical Unit addressing mode 
            *  PathId is used to index to the array
            */
            *addrMode = PA_DEVICE_TRY_MODE_LU;
            luDevIndex = pathId - pRegSetting->PaPathIdWidth - pRegSetting->VoPathIdWidth;
            if (luDevIndex < MAX_LU_DEVICE)
            {
                paDevIndex = pCard->Dev->LuDevice[luDevIndex].Lu.PaDeviceIndex;
                if (paDevIndex == PA_DEVICE_NO_ENTRY) 
                    paDevIndex = gMaxPaDevices;      /* this will make it invalid index */
            }
        }  
    }
   
    return (USHORT) paDevIndex;
}

/*++

Routine Description:

    get the index to paDevice table.

Arguments:

    pcard       = the deviceExtension
    pathId      - SP pathID
    targetId    - SP target ID
    lun         - SP lun
    pLunExt     - lun extension
    *ret_padevindex   - the device index 


Return Value:
    0    - good
    else - failed
   
--*/
ULONG GetPaDeviceHandle(
    PCARD_EXTENSION pCard,
    ULONG          pathId,
    ULONG          targetId,
    ULONG          lun,
    PLU_EXTENSION  pLunExt,
    USHORT         *ret_paDevIndex)
{
    PA_DEVICE      *dev;
    CHAR           addrmode;
    USHORT         paDevIndex;
    PLUN           plun; 
    CHAR           *pPa, *pVs, *pLu;
   
    /* use registry setting to find the index */ 
    paDevIndex = MapToPaIndex(pCard, pathId,targetId,lun, &addrmode);
   
    /* over the range, fault it */
    if ((ULONG)paDevIndex >= gMaxPaDevices)
    {
//      osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: handle not valid\n"));
        *ret_paDevIndex = 0; /* make sure if used will not BugCheck caller */
        return (-1L);
    }                                
      
    *ret_paDevIndex = paDevIndex;
    /* have it in our array */
    if (pLunExt)
    {
        pLunExt->PaDeviceIndex = paDevIndex;
        dev = pCard->Dev->PaDevice + paDevIndex;   
      
        /* see if there is FC handle */
        if (dev->Index.Pa.FcDeviceIndex == PA_DEVICE_NO_ENTRY)
            return (-1L);
         
        if ( !(dev->ModeFlag & PA_DEVICE_ALL_LUN_FIELDS_BUILT) )
        {
            dev->ModeFlag |= PA_DEVICE_BUILDING_DEVICE_MAP;
         
            dev->ModeFlag |= PA_DEVICE_ALL_LUN_FIELDS_BUILT;
        }
      
        if ( (addrmode ==  PA_DEVICE_TRY_MODE_PA) && (lun == 0) )
        {
            /* Find out any addressing mode only for LUN 0 and PA device*/
            if ( (dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK) < PA_DEVICE_TRY_MODE_ALL) 
            {
                addrmode = dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK;
                /* this device has not been queried for VS or LU addressing Mode */
                switch(addrmode)
                {
                    case PA_DEVICE_TRY_MODE_NONE:
                    {
                        dev->ModeFlag = (dev->ModeFlag & ~PA_DEVICE_TRY_MODE_MASK) |
                                             PA_DEVICE_TRY_MODE_VS;
                        pLunExt->Mode = PA_DEVICE_TRY_MODE_VS;
                        osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: Try mode VS for device %d\n", paDevIndex));
                        break;
                    }
               
                    case PA_DEVICE_TRY_MODE_VS:
                    {
                        dev->ModeFlag = (dev->ModeFlag & ~PA_DEVICE_TRY_MODE_MASK) |
                                                PA_DEVICE_TRY_MODE_LU;
                        pLunExt->Mode = PA_DEVICE_TRY_MODE_LU;
                        osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: Try mode LU for device %d\n", paDevIndex));
                        break;
                    }
               
                    case PA_DEVICE_TRY_MODE_LU:
                    {
                        dev->ModeFlag = (dev->ModeFlag & ~PA_DEVICE_TRY_MODE_MASK) |
                                                PA_DEVICE_TRY_MODE_PA;
                        pLunExt->Mode = PA_DEVICE_TRY_MODE_PA;
                        osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: Try mode PA for device %d\n", paDevIndex));
                        break;
                    }
                }
            }
            else
            {
                /* this device is already prep'ed to run */
            }
        }
        else
        {
            /** Non Zero LUNs OR non PA device**/
            pLunExt->Mode = addrmode;
        }
    }
    return 0;
}


/*++

Routine Description:

    Try a different FC addresing mode for this device to determine
    device addressing capabilities

Arguments:

    pcard          = the deviceExtension
    pHPIorequest   - Agilent Common IO request structure
    pSrbExt        - srb extension
    flag           -  CHECK_STATUS (determine after status is checked)
                     DON"T_CHECK_STATUS (disregard status)


Return Value:
    TRUE  - need to process this command, put the io back in the retry Q
    FALSE - complete this SRB back to SP
   
--*/
int  TryOtherAddressingMode(
    PCARD_EXTENSION   pCard, 
    agIORequest_t     *phpIORequest,
    PSRB_EXTENSION    pSrbExt, 
    ULONG             flag)
{
    PSCSI_REQUEST_BLOCK        pSrb;
    PLU_EXTENSION              plunExtension;
    int                        resend = FALSE;
    CHAR                       support;
    PA_DEVICE                  *dev;
    CHAR                       addrmode;
    int                        inqDevType;
    char                       *vid;
    char                       *pid;
    char                       inqData[24];
    ULONG                      *lptr;
      
    plunExtension = pSrbExt->pLunExt;
    dev = pCard->Dev->PaDevice + plunExtension->PaDeviceIndex;
    pSrb = pSrbExt->pSrb;
   
// osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Will try handle %d type ModeFlag=%x\n",
 //         plunExtension->PaDeviceIndex, dev->PaDevice.ModeFlag));
         
    if (  ( (dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK) < PA_DEVICE_TRY_MODE_ALL) &&
         (pSrb->Lun == 0) )
    {
        osCopy(inqData, ((char*)pSrb->DataBuffer)+8, sizeof(inqData)-1);
        inqData[sizeof(inqData)-1] = '\0';
      
        inqDevType = (int) (*((CHAR *)pSrb->DataBuffer) & 0x1F);
        osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Found (%s) handle %d type=%x Mode = %x PID=%d TID=%d LUN=%d\n",
            inqData, plunExtension->PaDeviceIndex, inqDevType, dev->ModeFlag, 
            pSrb->PathId,pSrb->TargetId, pSrb->Lun ));
      
        /* need to try  next mode */
        if (flag == CHECK_STATUS)
        {
            switch (pSrb->SrbStatus)
            {
                case SRB_STATUS_DATA_OVERRUN:
                case SRB_STATUS_SUCCESS:
                    if (inqDevType != 0x1f)
                        support=TRUE;
                    else
                        support=FALSE;
                    break;
            
                case SRB_STATUS_SELECTION_TIMEOUT:
                    support= FALSE;
                    break;
               
                default:
                    support = FALSE;
                    break;
            }
        }
        else
        {
            if (inqDevType != 0x1f)
            {
                support=TRUE;
            
                /* sanity check. Clarion return all zeros data */
                lptr = (ULONG *)pSrb->DataBuffer;
                if ( !(*lptr++) && !(*lptr++) && !(*lptr++) && !(*lptr++) )
                    support = FALSE;
            }
            else
                support=FALSE;
         
        }
   
        addrmode = dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK;

        if (addrmode == PA_DEVICE_TRY_MODE_PA)
        {
            if (support)
                dev->ModeFlag |= PA_DEVICE_SUPPORT_PA;
            /* 
            * Done testing all modes, now prepare VsDevice and LuDevice tables.......
            */
            /* No need to test anymore */
            dev->ModeFlag |= PA_DEVICE_TRY_MODE_ALL;
         
            /* let all non zero LUNs to continue */
            dev->ModeFlag &= ~PA_DEVICE_BUILDING_DEVICE_MAP;
         
            osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Done trying handle %d on all modes \n",   plunExtension->PaDeviceIndex));
            resend = FALSE;
        }
        else
        {
            if (addrmode == PA_DEVICE_TRY_MODE_VS)
            {
                if (support)
                {
                    dev->ModeFlag |= PA_DEVICE_SUPPORT_VS;
                    if (pCard->Dev->VsDeviceIndex < MAX_VS_DEVICE)
                    {
                        pCard->Dev->VsDevice[pCard->Dev->VsDeviceIndex].Vs.PaDeviceIndex = plunExtension->PaDeviceIndex;
                        pCard->Dev->VsDeviceIndex++;
                        osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Adding handle %d to VS Device\n",   plunExtension->PaDeviceIndex));
                    }
                }
            }
            else
            {
                if (support)
                {
                    dev->ModeFlag |= PA_DEVICE_SUPPORT_LU;
                    if (pCard->Dev->LuDeviceIndex < MAX_LU_DEVICE)
                    {
                        pCard->Dev->LuDevice[pCard->Dev->LuDeviceIndex].Lu.PaDeviceIndex = plunExtension->PaDeviceIndex;
                        pCard->Dev->LuDeviceIndex++;
                        osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Adding handle %d to LU Device\n",   plunExtension->PaDeviceIndex));
                    }
                }
            }
         
            
            /* try next mode */
            dev->ModeFlag++;
            plunExtension->Mode++;
            osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: ModeFlag for Device %d Now %xx plun->mode=%xx\n",     plunExtension->PaDeviceIndex, dev->ModeFlag, plunExtension->Mode));
         
            /* reinitialize param to send back to the queue */
            phpIORequest->osData = pSrbExt;
            pSrbExt->SRB_State =  RS_WAITING;
            pSrb->SrbStatus = SRB_STATUS_SUCCESS;
            pSrb->ScsiStatus = SCSISTAT_GOOD;
         
            /* requeue it */
            SrbEnqueueHead (&pCard->RetryQ, pSrb);
            resend = TRUE;
        }
    }
    else
    {
        resend = FALSE;
    }
      
    return (resend);
}


/*++

Routine Description:

    Update the FC LUN payload before sening the command to FC layer
   
Arguments:

    pcard          = the deviceExtension
    pHPIorequest   - Agilent Common IO request structure
    pSrbExt        - srb extension

Return Value:
    none
--*/
void SetFcpLunBeforeStartIO (
    PLU_EXTENSION           pLunExt,
    agIORequestBody_t *     pHpio_CDBrequest,
    PSCSI_REQUEST_BLOCK     pSrb)
{
    PLUN plun;

    plun = (PLUN)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0];
   
    switch(pLunExt->Mode)
    {
        case PA_DEVICE_TRY_MODE_VS:
            SET_VS_LUN(plun, pSrb->PathId, pSrb->TargetId, pSrb->Lun)
            break;
      
        case PA_DEVICE_TRY_MODE_LU:
            SET_LU_LUN(plun, pSrb->PathId, pSrb->TargetId, pSrb->Lun)
            break;
         
        case PA_DEVICE_TRY_MODE_PA:
            SET_PA_LUN(plun, pSrb->PathId, pSrb->TargetId, pSrb->Lun)
            break;
    }
    #ifdef OLD     
    osDEBUGPRINT((ALWAYS_PRINT, "ModifyModeBeforeStartIO: Lun %02x%02x Mode Flag %xx \n",    
        pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0],
        pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[1],
        pLunExt->Mode));        
    #endif
    return;
}


/*++

Routine Description:

    Initialize all YAM tables
Arguments:

    pcard          = the deviceExtension


Return Value:
    none
   
--*/
void InitializeDeviceTable(PCARD_EXTENSION pCard)
{
    ULONG x;
   
    for (x = 0; x < MAX_VS_DEVICE;x++)
    {
        pCard->Dev->VsDevice[x].Vs.PaDeviceIndex = PA_DEVICE_NO_ENTRY;
    }
   
    #ifdef _ENABLE_PSEUDO_DEVICE_
    if (gEnablePseudoDevice)
        pCard->Dev->VsDeviceIndex = 1;
    #endif
   
    for (x = 0; x < MAX_LU_DEVICE;x++)
    {
        pCard->Dev->LuDevice[x].Lu.PaDeviceIndex = PA_DEVICE_NO_ENTRY;
    }
      
    for (x = 0; x < gMaxPaDevices;x++)
    {
        pCard->Dev->PaDevice[x].Index.Pa.FcDeviceIndex = PA_DEVICE_NO_ENTRY;
      
        /* if onlu single addressing mode support, default to PA mode */
        if (gMultiMode == FALSE)
            pCard->Dev->PaDevice[x].ModeFlag = 
                (CHAR) (PA_DEVICE_TRY_MODE_ALL | PA_DEVICE_TRY_MODE_MASK |PA_DEVICE_ALL_LUN_FIELDS_BUILT | PA_DEVICE_SUPPORT_PA);
      
    }
      
    return ;
   
}



/*++

Routine Description:

    Get a device table mapping
Arguments:

    pcard          = the deviceExtension
    pathId         - SP bus id
    targetId       - SP target ID
    lun            - SP lun 
    *addrmode      - (OUT) addressing mode of this device
    *paIndex       - (OUT) pa device index
   
Return Value:
    device map location or NULL
   
--*/
DEVICE_MAP  *GetDeviceMapping(PCARD_EXTENSION pCard,
    ULONG            pathId,
    ULONG            targetId,
    ULONG            lun, 
    CHAR             *addrmode,
    USHORT           *paIndex)
    
{
    DEVICE_MAP  *devmap;
    USHORT         paDevIndex;
    ULONG          x;
   
    paDevIndex = MapToPaIndex(pCard, pathId,targetId,lun, addrmode);
   
    if ((ULONG)paDevIndex < gMaxPaDevices)
    {
        *paIndex = paDevIndex;
      
        switch (*addrmode)
        {
            case PA_DEVICE_TRY_MODE_VS:
                for (x=0; x< MAX_VS_DEVICE;x++)
                {
                    if (pCard->Dev->VsDevice[x].Vs.PaDeviceIndex == paDevIndex)  
                    {
                        return (&pCard->Dev->VsDevice[x]);
                    }
                }
            
                break;
                        
            case PA_DEVICE_TRY_MODE_LU:
                for (x=0; x< MAX_LU_DEVICE;x++)
                {
                    if (pCard->Dev->LuDevice[x].Lu.PaDeviceIndex == paDevIndex)  
                    {
                        return (&pCard->Dev->LuDevice[x]);
                    }
                 }
                break;
                     
            case PA_DEVICE_TRY_MODE_PA:
                return (&pCard->Dev->PaDevice[paDevIndex].Index);
        }
    }
    return NULL;
}



/*++

Routine Description:

    Setting the maximum number of luns supported by this device
   
Arguments:

    pcard          = the deviceExtension
    pathId         - SP bus id
    targetId       - SP target ID
    lun            - SP lun 

Return Value:
    none
   
--*/
void SetLunCount(
    PCARD_EXTENSION pCard,
    ULONG            pathId,
    ULONG            targetId,
    ULONG            lun)
{
    DEVICE_MAP     *devmap;
    CHAR           addrmode;
    USHORT         padev;   
   
    devmap = GetDeviceMapping(pCard,pathId,targetId,lun, &addrmode, &padev);
    if (devmap)
    {
        if (devmap->Com.MaxLuns < (USHORT)lun)
        {
            osDEBUGPRINT((ALWAYS_PRINT, "SetLunCount: %s device at paDevIndex %d Max Lun = %d\n", 
                ((addrmode == PA_DEVICE_TRY_MODE_PA) ? "PA" : ((addrmode == PA_DEVICE_TRY_MODE_VS) ? "VS" : "LU") ), 
                padev, lun));
            devmap->Com.MaxLuns = (USHORT)lun;
        }
    }
   
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ipstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/IPState.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/19/00 9:10a   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/IPState.C

--*/

#ifndef __IPState_H__
#define __IPState_H__

#define IPStateConfused                 0
#define IPStateIdle                     1
#define IPStateReportLinkStatus         2
#define IPStateOutgoingComplete         3
#define IPStateIncoming                 4

#define IPStateMAXState                 IPStateIncoming

#define IPEventConfused                 0
#define IPEventReportLinkStatus         1
#define IPEventOutgoingComplete         2
#define IPEventIncoming                 3
#define IPEventDone                     4

#define IPEventMAXEvent                 IPEventDone

STATE_PROTO(IPActionConfused);
STATE_PROTO(IPActionIdle);
STATE_PROTO(IPActionReportLinkStatus);
STATE_PROTO(IPActionOutgoingComplete);
STATE_PROTO(IPActionIncoming);
STATE_PROTO(IPActionDone);

stateTransitionMatrix_t IPStateTransitionMatrix;
stateActionScalar_t IPStateActionScalar;

#endif /*  __IPState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ipstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/IPState.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 8/16/00 4:43p   $

Purpose:

  This file implements the FC Layer State Machine for the single IP Thread.
  This thread is responsible for managing NDIS-client Queues (both directions).

--*/
#ifdef _DvrArch_1_30_

#include <stdio.h>
#include <stdlib.h>


#include "../h/globals.h"
#include "../h/state.h"
#include "../h/fcstruct.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"

/* <<<<<<<<<<<< Testing >>>>>>>>> */
#include "../h/sfstate.h"

#include "../h/ipstate.h"
#include "../h/pktstate.h"
#include "../h/queue.h"
#include "../h/ip.h"

stateTransitionMatrix_t IPStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...            */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 1 IPEventReportLinkStatus                             */
    0,IPStateReportLinkStatus,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 2 IPEventOutgoingComplete                             */
    0,IPStateOutgoingComplete,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 3 IPEventIncoming                                     */
    0,IPStateIncoming,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 4 IPEventDone                                         */
    0,0,IPStateIdle,IPStateIdle,IPStateIdle, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 5                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 20                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 30                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

stateTransitionMatrix_t copiedIPStateTransitionMatrix;

stateActionScalar_t IPStateActionScalar = {
    &IPActionConfused,
    &IPActionIdle,
    &IPActionReportLinkStatus,
    &IPActionOutgoingComplete,
    &IPActionIncoming,
    &IPActionConfused
    };

stateActionScalar_t copiedIPStateActionScalar;

#ifdef USESTATEMACROS

IPSTATE_FUNCTION_TERMINATE(IPActionConfused);

#endif /* USESTATEMACROS */

#define testIPCompareBase 0x00000110


/* IPStateConfused 0  */
extern void IPActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    fiLogString(thread->hpRoot,
                    "IPActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull( eventRecord );
}

extern void IPActionIdle( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiSetEventRecordNull(eventRecord);
}

extern void IPActionReportLinkStatus( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t       *hpRoot      = thread->hpRoot;
    IPThread_t     *pIPThread  = (IPThread_t *) thread;

    fiLogDebugString(hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionReportLinkStatus",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    if (pIPThread->LinkStatus.osData != agNULL &&
            pIPThread->LinkStatus.LastReported != pIPThread->LinkStatus.MostRecent)
    {
        osFcNetIoctlCompleted( hpRoot, pIPThread->LinkStatus.osData, pIPThread->LinkStatus.MostRecent );

        pIPThread->LinkStatus.LastReported = pIPThread->LinkStatus.MostRecent;
        pIPThread->LinkStatus.osData = agNULL;
    }

    fiSetEventRecord( eventRecord, thread, IPEventDone );
}

extern void IPActionOutgoingComplete( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        *hpRoot      = thread->hpRoot;
    PktThread_t     *pPktThread  = ((IPThread_t *)thread)->CompletedPkt;

    fiLogDebugString(hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionOutgoingComplete",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiListDequeueThis(pPktThread);

    PktThreadFree( hpRoot, pPktThread );

    osFcNetIoctlCompleted( hpRoot, pPktThread->osData, pPktThread->status );

    fiSetEventRecord( eventRecord, thread, IPEventDone );
}

extern void IPActionIncoming( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t       *hpRoot      = thread->hpRoot;
    IPThread_t     *pIPThread  = (IPThread_t *) thread;

    fiLogDebugString(hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionIncoming",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    osFcNetIoctlCompleted( hpRoot, pIPThread->osData, FC_CMND_STATUS_SUCCESS );

    fiSetEventRecord( eventRecord, thread, IPEventDone );
}

#endif /* _DvrArch_1_30_ was defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\linksvc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/LinkSvc.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/14/00 5:53p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/LinkSvc.C

--*/

#ifndef __LinkSvc_H__
#define __LinkSvc_H__

/* SF_CMND_Type(SF_CMND_Class==SFThread_SF_CMND_Class_LinkSvc) Declarations */

#define SFThread_SF_CMND_LinkSvc_Type_ABTS      0x01
#define SFThread_SF_CMND_LinkSvc_Type_BA_RJT    0x02
#define SFThread_SF_CMND_LinkSvc_Type_LS_RJT    0x03
#define SFThread_SF_CMND_LinkSvc_Type_PLOGI     0x04
#define SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC 0x05
#define SFThread_SF_CMND_LinkSvc_Type_FLOGI     0x06
#define SFThread_SF_CMND_LinkSvc_Type_LOGO      0x07
#define SFThread_SF_CMND_LinkSvc_Type_ELS_ACC   0x08
#define SFThread_SF_CMND_LinkSvc_Type_RRQ       0x09
#define SFThread_SF_CMND_LinkSvc_Type_PRLI      0x0A
#define SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC  0x0B
#define SFThread_SF_CMND_LinkSvc_Type_PRLO      0x0C
#define SFThread_SF_CMND_LinkSvc_Type_ADISC     0x0D
#define SFThread_SF_CMND_LinkSvc_Type_SCR       0x0E
#define SFThread_SF_CMND_LinkSvc_Type_SRR       0x0F
#define SFThread_SF_CMND_LinkSvc_Type_REC       0x10
#define SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC 0x11
#ifdef _DvrArch_1_30_
#define SFThread_SF_CMND_LinkSvc_Type_FARP_REQ   0x12
#define SFThread_SF_CMND_LinkSvc_Type_FARP_REPLY 0x13
#endif /* _DvrArch_1_30_ was defined */


/* SF_CMND_State(SF_CMND_Class==SFThread_SF_CMND_Class_LinkSvc,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_LinkSvc_State_Started  0x01
#define SFThread_SF_CMND_LinkSvc_State_Finished 0x02

/* SF_CMND_Status(SF_CMND_Class==SFThread_SF_CMND_Class_LinkSvc,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_LinkSvc_Status_Good 0x01
#define SFThread_SF_CMND_LinkSvc_Status_Bad  0x02

/* Function Prototypes */

osGLOBAL void fiLinkSvcInit(
                           agRoot_t *hpRoot
                         );

osGLOBAL os_bit32 fiFillInBA_RJT(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           );

osGLOBAL os_bit32 fiFillInBA_RJT_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       OX_ID,
                                    os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                  );

osGLOBAL os_bit32 fiFillInBA_RJT_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       OX_ID,
                                     os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                   );

osGLOBAL os_bit32 fiFillInABTS(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInABTS_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInABTS_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_ABTS_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_ABTS_Response_OffCard(
                                                    SFThread_t          *SFThread,
                                                    os_bit32                Frame_Length,
                                                    FCHS_t              *FCHS,
                                                    FC_BA_ACC_Payload_t *Payload,
                                                    os_bit32                Payload_Wrap_Offset,
                                                    FC_BA_ACC_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL void fiFillInELSFrameHeader_OnCard(
                                           SFThread_t *SFThread,
                                           os_bit32       D_ID,
                                           os_bit32       X_ID,
                                           os_bit32       F_CTL_Exchange_Context
                                         );

osGLOBAL void fiFillInELSFrameHeader_OffCard(
                                            SFThread_t *SFThread,
                                            os_bit32       D_ID,
                                            os_bit32       X_ID,
                                            os_bit32       F_CTL_Exchange_Context
                                          );

osGLOBAL os_bit32 fiFillInLS_RJT(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           );

osGLOBAL os_bit32 fiFillInLS_RJT_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       OX_ID,
                                    os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                  );

osGLOBAL os_bit32 fiFillInLS_RJT_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       OX_ID,
                                     os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                   );

osGLOBAL os_bit32 fiFillInPLOGI(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInPLOGI_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInPLOGI_OffCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL void fiLinkSvcProcess_PLOGI_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL void fiLinkSvcProcess_PLOGI_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                                   );

osGLOBAL os_bit32 fiLinkSvcProcess_PLOGI_Request_OnCard(
                                                    agRoot_t  *hpRoot,
                                                    X_ID_t     OX_ID,
                                                    os_bit32      Frame_Length,
                                                    os_bit32      Offset_to_FCHS,
                                                    os_bit32      Offset_to_Payload,
                                                    os_bit32      Payload_Wrap_Offset,
                                                    os_bit32      Offset_to_Payload_Wrapped,
                                                    fi_thread__t **Thread_to_return
                                                  );

osGLOBAL os_bit32 fiLinkSvcProcess_PLOGI_Request_OffCard(
                                                     agRoot_t                *hpRoot,
                                                     X_ID_t                   OX_ID,
                                                     os_bit32                    Frame_Length,
                                                     FCHS_t                  *FCHS,
                                                     FC_ELS_PLOGI_Payload_t  *Payload,
                                                     os_bit32                    Payload_Wrap_Offset,
                                                     FC_ELS_PLOGI_Payload_t  *Payload_Wrapped,
                                                     fi_thread__t               **Thread_to_return
                                                   );

osGLOBAL os_bit32 fiFillInPLOGI_ACC(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              );

osGLOBAL os_bit32 fiFillInPLOGI_ACC_OnCard(
                                       SFThread_t *SFThread,
                                       os_bit32       D_ID,
                                       os_bit32       OX_ID
                                     );

osGLOBAL os_bit32 fiFillInPLOGI_ACC_OffCard(
                                        SFThread_t *SFThread,
                                        os_bit32       D_ID,
                                        os_bit32       OX_ID
                                      );

osGLOBAL os_bit32 fiFillInFLOGI(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInFLOGI_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInFLOGI_OffCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL void fiLinkSvcProcess_FLOGI_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL void fiLinkSvcProcess_FLOGI_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_FLOGI_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_FLOGI_Payload_t *Payload_Wrapped
                                                   );

osGLOBAL os_bit32 fiFillInLOGO(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInLOGO_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInLOGO_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_LOGO_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_LOGO_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiFillInSRR(
                           SFThread_t *SFThread,
                           os_bit32    OXID,
                           os_bit32    RXID,
                           os_bit32    Relative_Offset,
                           os_bit32    R_CTL
                         );

osGLOBAL os_bit32 fiFillInSRR_OnCard(
                                  SFThread_t *SFThread,
                                  os_bit32      OXID,
                                  os_bit32      RXID,
                                  os_bit32      Relative_Offset,
                                  os_bit32      R_CTL
                                );

osGLOBAL os_bit32 fiFillInSRR_OffCard(
                                   SFThread_t *SFThread,
                                   os_bit32       OXID,
                                   os_bit32       RXID,
                                   os_bit32       Relative_Offset,
                                   os_bit32       R_CTL
                                 );

osGLOBAL void fiLinkSvcProcess_SRR_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_SRR_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload_Wrapped
                                                  );
osGLOBAL os_bit32 fiFillInREC(
                           SFThread_t *SFThread,
                           os_bit32       OXID,
                           os_bit32       RXID
                         );

osGLOBAL os_bit32 fiFillInREC_OnCard(
                                  SFThread_t *SFThread,
                                  os_bit32     OXID,
                                  os_bit32     RXID
                                );

osGLOBAL os_bit32 fiFillInREC_OffCard(
                                   SFThread_t *SFThread,
                                   os_bit32    OXID,
                                   os_bit32    RXID
                                 );

osGLOBAL void fiLinkSvcProcess_REC_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_REC_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_REC_ACC_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_REC_ACC_Payload_t *Payload_Wrapped
                                                  );


osGLOBAL os_bit32 fiFillInELS_ACC(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             );

osGLOBAL os_bit32 fiFillInELS_ACC_OnCard(
                                      SFThread_t *SFThread,
                                      os_bit32       D_ID,
                                      os_bit32       OX_ID
                                    );

osGLOBAL os_bit32 fiFillInELS_ACC_OffCard(
                                       SFThread_t *SFThread,
                                       os_bit32       D_ID,
                                       os_bit32       OX_ID
                                     );

osGLOBAL void fiLinkSvcProcess_LILP_OnCard(
                                          agRoot_t *hpRoot,
                                          os_bit32     Frame_Length,
                                          os_bit32     Offset_to_FCHS,
                                          os_bit32     Offset_to_Payload,
                                          os_bit32     Payload_Wrap_Offset,
                                          os_bit32     Offset_to_Payload_Wrapped
                                        );

osGLOBAL void fiLinkSvcProcess_LILP_OffCard(
                                           agRoot_t                                     *hpRoot,
                                           os_bit32                                         Frame_Length,
                                           FCHS_t                                       *FCHS,
                                           FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload,
                                           os_bit32                                         Payload_Wrap_Offset,
                                           FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload_Wrapped
                                         );

osGLOBAL os_bit32 fiFillInRRQ(
                          SFThread_t *SFThread
                        );

osGLOBAL os_bit32 fiFillInRRQ_OnCard(
                                 SFThread_t *SFThread
                               );

osGLOBAL os_bit32 fiFillInRRQ_OffCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL void fiLinkSvcProcess_RRQ_Response_OnCard(
                                                  SFThread_t *SFThread,
                                                  os_bit32       Frame_Length,
                                                  os_bit32       Offset_to_FCHS,
                                                  os_bit32       Offset_to_Payload,
                                                  os_bit32       Payload_Wrap_Offset,
                                                  os_bit32       Offset_to_Payload_Wrapped
                                                );

osGLOBAL void fiLinkSvcProcess_RRQ_Response_OffCard(
                                                   SFThread_t               *SFThread,
                                                   os_bit32                     Frame_Length,
                                                   FCHS_t                   *FCHS,
                                                   FC_ELS_ACC_RRQ_Payload_t *Payload,
                                                   os_bit32                     Payload_Wrap_Offset,
                                                   FC_ELS_ACC_RRQ_Payload_t *Payload_Wrapped
                                                 );

osGLOBAL os_bit32 fiFillInPRLI(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInPRLI_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInPRLI_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_PRLI_Response_Either(
                                                   DevThread_t *DevThread
                                                 );

osGLOBAL void fiLinkSvcProcess_PRLI_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_PRLI_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_ACC_PRLI_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_ACC_PRLI_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiFillInPRLI_ACC(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             );

osGLOBAL os_bit32 fiFillInPRLI_ACC_OnCard(
                                      SFThread_t *SFThread,
                                      os_bit32       D_ID,
                                      os_bit32       OX_ID
                                    );

osGLOBAL os_bit32 fiFillInPRLI_ACC_OffCard(
                                       SFThread_t *SFThread,
                                       os_bit32       D_ID,
                                       os_bit32       OX_ID
                                     );

osGLOBAL os_bit32 fiFillInPRLO(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInPRLO_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInPRLO_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_PRLO_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_PRLO_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_ACC_PRLO_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_ACC_PRLO_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiFillInADISC(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInADISC_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInADISC_OffCard(
                                    SFThread_t *SFThread
                                  );


osGLOBAL os_bit32 fiLinkSvcProcess_ADISC_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiLinkSvcProcess_ADISC_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_ADISC_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_ADISC_Payload_t *Payload_Wrapped
                                                   );

#ifdef _DvrArch_1_30_
os_bit32 fiFillInFARP_REQ_OffCard(
                                   SFThread_t *SFThread
                                 );

os_bit32 fiFillInFARP_REPLY_OffCard(
                                     SFThread_t *SFThread
                                   );

os_bit32 fiLinkSvcProcess_FARP_Request_OffCard(
                                                agRoot_t                    *hpRoot,
                                                X_ID_t                       OX_ID,
                                                os_bit32                     Frame_Length,
                                                FCHS_t                      *FCHS,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload,
                                                os_bit32                     Payload_Wrap_Offset,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload_Wrapped,
                                                fi_thread__t               **Thread_to_return
                                              );
void fiLinkSvcProcess_FARP_Response_OffCard(
                                             SFThread_t                  * SFThread,
                                             os_bit32                      Frame_Length,
                                             FCHS_t                      * FCHS,
                                             FC_ELS_FARP_REPLY_Payload_t * Payload,
                                             os_bit32                      Payload_Wrap_Offset,
                                             FC_ELS_FARP_REPLY_Payload_t * Payload_Wrapped
                                           );
#endif /* _DvrArch_1_30_ was defined */

osGLOBAL os_bit32 fiFillInADISC_ACC(
                            SFThread_t *SFThread,
                            os_bit32       D_ID,
                            os_bit32       OX_ID
                           );

osGLOBAL os_bit32 fiFillInADISC_ACC_OffCard(
                                   SFThread_t *SFThread,
                                   os_bit32       D_ID,
                                   os_bit32       OX_ID
                                  );
osGLOBAL os_bit32 fiFillInADISC_ACC_OnCard(
                                   SFThread_t *SFThread,
                                   os_bit32       D_ID,
                                   os_bit32       OX_ID
                                 );



osGLOBAL os_bit32 fiFillInSCR(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInSCR_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInSCR_OffCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL void fiLinkSvcProcess_SCR_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL void fiLinkSvcProcess_SCR_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_SCR_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_SCR_Payload_t *Payload_Wrapped
                                                   );


osGLOBAL void fiLinkSvcProcess_TargetRequest_OnCard(
                                                   agRoot_t *hpRoot,
                                                   os_bit32     Frame_Length,
                                                   os_bit32     Offset_to_FCHS,
                                                   os_bit32     Offset_to_Payload,
                                                   os_bit32     Payload_Wrap_Offset,
                                                   os_bit32     Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_TargetRequest_OffCard(
                                                    agRoot_t *hpRoot,
                                                    os_bit32     Frame_Length,
                                                    FCHS_t   *FCHS,
                                                    void     *Payload,
                                                    os_bit32     Payload_Wrap_Offset,
                                                    void     *Payload_Wrapped
                                                  );

#define fiLinkSvc_Cmd_Status_ACC              0x00000010
#define fiLinkSvc_Cmd_Status_RJT              0x00000011
#define fiLinkSvc_Cmd_Status_PLOGI_From_Self  0x00000012
#define fiLinkSvc_Cmd_Status_PLOGI_From_Twin  0x00000013
#define fiLinkSvc_Cmd_Status_PLOGI_From_Other 0x00000014
#define fiLinkSvc_Cmd_Status_TargetRequest    0x00000015
#define fiLinkSvc_Cmd_Status_Position_Map     0x00000016
#ifdef _DvrArch_1_30_
#define fiLinkSvc_Cmd_Status_FARP_From_Self   0x00000017
#define fiLinkSvc_Cmd_Status_FARP_From_Twin   0x00000018
#define fiLinkSvc_Cmd_Status_FARP_From_Other  0x00000019
#endif /* _DvrArch_1_30_ was defined */
#define fiLinkSvc_Cmd_Status_FC_Tape_XRDY     0x0000001A
#define fiLinkSvc_Cmd_Status_Confused         0xFFFFFFFF 

osGLOBAL os_bit32 fiLinkSvcProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                );

osGLOBAL os_bit32 fiLinkSvcProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t   SFQConsIndex,
                                         os_bit32            Frame_Length,
                                         fi_thread__t       **Thread_to_return
                                       );

osGLOBAL os_bit32 fiLinkSvcProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t   SFQConsIndex,
                                          os_bit32            Frame_Length,
                                          fi_thread__t       **Thread_to_return
                                        );


osGLOBAL os_bit32 fiFillInFAN(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInFAN_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInFAN_OffCard(
                                    SFThread_t *SFThread
                                  );

#endif /* __LinkSvc_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\memmap.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/MemMap.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:30a  $ (Last Modified)

Purpose:

  This file implements the laying out of memory (on and off card).

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/flashsvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "flashsvc.h"
#endif  /* _New_Header_file_Layout_ */

/*+
Function:  fiMemMapGetParameterBit32()

Purpose:   Allows OS Layer to adjust the specified parameter.

Algorithm: If EnforceDefaults is agTRUE (meaning fiMemMapCalculate
           was called specifying that all parameters be set to their
           defaults) or if ADJUSTABLE is agFALSE (meaning this particular
           PARAMETER is not adjustable), then this function simply
           returns the DEFAULT.

           Otherwise, osAdjustParameterBit32() is called to allow the
           OS Layer a chance to adjust the value of this PARAMETER.  The
           value returned from osAdjustParameterBit32() is bounds checked
           (if less than MIN, MIN is used; if more than MAX, MAX is used).
           If POWER_OF_2 is agTRUE (meaning the value must be a power of 2),
           the value is truncated to be a power of 2 if necessary.
-*/

os_bit32 fiMemMapGetParameterBit32(
                                 agRoot_t *hpRoot,
                                 char     *PARAMETER,
                                 os_bit32     MIN,
                                 os_bit32     MAX,
                                 agBOOLEAN   ADJUSTABLE,
                                 agBOOLEAN   POWER_OF_2,
                                 os_bit32     DEFAULT,
                                 agBOOLEAN   EnforceDefaults
                               )
{
    os_bit32 power_of_2 = 0x80000000;
    os_bit32 to_return;

    if (EnforceDefaults == agTRUE)
    {
        /* If enforcing defaults, simply return the default value */
        
        return DEFAULT;
    }

    if (ADJUSTABLE == agFALSE)
    {
        /* If not adjustable, simply return the default value */
        
        return DEFAULT;
    }

    /* Call OS Layer to see if parameter needs to be adjusted */
    
    to_return = osAdjustParameterBit32(
                                        hpRoot,
                                        PARAMETER,
                                        DEFAULT,
                                        MIN,
                                        MAX
                                      );

    if (to_return < MIN)
    {
        /* Enforce minimum value for parameter */
        
        return MIN;
    }

    if (to_return > MAX)
    {
        /* Enforce maximum value for parameter */
        
        return MAX;
    }

    if (POWER_OF_2 != agTRUE)
    {
        /* If not needed to be a power of 2, to_return is okay */
        
        return to_return;
    }

    if (to_return == (to_return & ~(to_return-1)))
    {
        /* Above calculation is true if to_return is a power of 2 */
        
        return to_return;
    }

    /* Need to truncate value to make it a power of 2 */
    
    while ((power_of_2 & to_return) != power_of_2)
    {
        power_of_2 = power_of_2 >> 1;
    }

    return power_of_2;
}

/*+
Function:  fiMemMapGetParameters()

Purpose:   Allows OS Layer to adjust all parameters.

Algorithm: This function simply calls fiMemMapGetParameterBit32()
           for each parameter.  Each value returned is placed in
           the Calculation->Parameters structure.
-*/

void fiMemMapGetParameters(
                            agRoot_t              *hpRoot,
                            fiMemMapCalculation_t *Calculation,
                            agBOOLEAN                EnforceDefaults
                          )
{
    Calculation->Parameters.NumDevSlotsPerArea
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumDevSlotsPerArea_PARAMETER,
                                     MemMap_NumDevSlotsPerArea_MIN,
                                     MemMap_NumDevSlotsPerArea_MAX,
                                     MemMap_NumDevSlotsPerArea_ADJUSTABLE,
                                     MemMap_NumDevSlotsPerArea_POWER_OF_2,
                                     MemMap_NumDevSlotsPerArea_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumAreasPerDomain
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumAreasPerDomain_PARAMETER,
                                     MemMap_NumAreasPerDomain_MIN,
                                     MemMap_NumAreasPerDomain_MAX,
                                     MemMap_NumAreasPerDomain_ADJUSTABLE,
                                     MemMap_NumAreasPerDomain_POWER_OF_2,
                                     MemMap_NumAreasPerDomain_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumDomains
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumDomains_PARAMETER,
                                     MemMap_NumDomains_MIN,
                                     MemMap_NumDomains_MAX,
                                     MemMap_NumDomains_ADJUSTABLE,
                                     MemMap_NumDomains_POWER_OF_2,
                                     MemMap_NumDomains_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumDevices
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumDevices_PARAMETER,
                                     MemMap_NumDevices_MIN,
                                     MemMap_NumDevices_MAX,
                                     MemMap_NumDevices_ADJUSTABLE,
                                     MemMap_NumDevices_POWER_OF_2,
                                     MemMap_NumDevices_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumIOs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumIOs_PARAMETER,
                                     MemMap_NumIOs_MIN,
                                     MemMap_NumIOs_MAX,
                                     MemMap_NumIOs_ADJUSTABLE,
                                     MemMap_NumIOs_POWER_OF_2,
                                     MemMap_NumIOs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SizeSGLs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SizeSGLs_PARAMETER,
                                     MemMap_SizeSGLs_MIN,
                                     MemMap_SizeSGLs_MAX,
                                     MemMap_SizeSGLs_ADJUSTABLE,
                                     MemMap_SizeSGLs_POWER_OF_2,
                                     MemMap_SizeSGLs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumSGLs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumSGLs_PARAMETER,
                                     MemMap_NumSGLs_MIN,
                                     MemMap_NumSGLs_MAX,
                                     MemMap_NumSGLs_ADJUSTABLE,
                                     MemMap_NumSGLs_POWER_OF_2,
                                     MemMap_NumSGLs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SizeCachedSGLs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SizeCachedSGLs_PARAMETER,
                                     MemMap_SizeCachedSGLs_MIN,
                                     MemMap_SizeCachedSGLs_MAX,
                                     MemMap_SizeCachedSGLs_ADJUSTABLE,
                                     MemMap_SizeCachedSGLs_POWER_OF_2,
                                     MemMap_SizeCachedSGLs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_CMND_Size_PARAMETER,
                                     MemMap_FCP_CMND_Size_MIN,
                                     MemMap_FCP_CMND_Size_MAX,
                                     MemMap_FCP_CMND_Size_ADJUSTABLE,
                                     MemMap_FCP_CMND_Size_POWER_OF_2,
                                     MemMap_FCP_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_RESP_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_RESP_Size_PARAMETER,
                                     MemMap_FCP_RESP_Size_MIN,
                                     MemMap_FCP_RESP_Size_MAX,
                                     MemMap_FCP_RESP_Size_ADJUSTABLE,
                                     MemMap_FCP_RESP_Size_POWER_OF_2,
                                     MemMap_FCP_RESP_Size_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SF_CMND_Reserve
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SF_CMND_Reserve_PARAMETER,
                                     MemMap_SF_CMND_Reserve_MIN,
                                     (MemMap_SF_CMND_Reserve_MAX - (Calculation->Parameters.NumIOs - MemMap_NumIOs_MIN)),
                                     MemMap_SF_CMND_Reserve_ADJUSTABLE,
                                     MemMap_SF_CMND_Reserve_POWER_OF_2,
                                     MemMap_SF_CMND_Reserve_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SF_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SF_CMND_Size_PARAMETER,
                                     MemMap_SF_CMND_Size_MIN,
                                     MemMap_SF_CMND_Size_MAX,
                                     MemMap_SF_CMND_Size_ADJUSTABLE,
                                     MemMap_SF_CMND_Size_POWER_OF_2,
                                     MemMap_SF_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _DvrArch_1_30_
    Calculation->Parameters.Pkt_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_Pkt_CMND_Size_PARAMETER,
                                     MemMap_Pkt_CMND_Size_MIN,
                                     MemMap_Pkt_CMND_Size_MAX,
                                     MemMap_Pkt_CMND_Size_ADJUSTABLE,
                                     MemMap_Pkt_CMND_Size_POWER_OF_2,
                                     MemMap_Pkt_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _DvrArch_1_30_ was not defined */

    Calculation->Parameters.NumTgtCmnds
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumTgtCmnds_PARAMETER,
                                     MemMap_NumTgtCmnds_MIN,
                                     MemMap_NumTgtCmnds_MAX,
                                     MemMap_NumTgtCmnds_ADJUSTABLE,
                                     MemMap_NumTgtCmnds_POWER_OF_2,
                                     MemMap_NumTgtCmnds_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.TGT_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_TGT_CMND_Size_PARAMETER,
                                     MemMap_TGT_CMND_Size_MIN,
                                     MemMap_TGT_CMND_Size_MAX,
                                     MemMap_TGT_CMND_Size_ADJUSTABLE,
                                     MemMap_TGT_CMND_Size_POWER_OF_2,
                                     MemMap_TGT_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _DvrArch_1_30_
    Calculation->Parameters.NumPktThreads
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumPktThreads_PARAMETER,
                                     MemMap_NumPktThreads_MIN,
                                     MemMap_NumPktThreads_MAX,
                                     MemMap_NumPktThreads_ADJUSTABLE,
                                     MemMap_NumPktThreads_POWER_OF_2,
                                     MemMap_NumPktThreads_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _DvrArch_1_30_ was defined */

    Calculation->Parameters.NumCommandQ
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumCommandQ_PARAMETER,
                                     MemMap_NumCommandQ_MIN,
                                     MemMap_NumCommandQ_MAX,
                                     MemMap_NumCommandQ_ADJUSTABLE,
                                     MemMap_NumCommandQ_POWER_OF_2,
                                     MemMap_NumCommandQ_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumCompletionQ
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumCompletionQ_PARAMETER,
                                     MemMap_NumCompletionQ_MIN,
                                     MemMap_NumCompletionQ_MAX,
                                     MemMap_NumCompletionQ_ADJUSTABLE,
                                     MemMap_NumCompletionQ_POWER_OF_2,
                                     MemMap_NumCompletionQ_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumInboundBufferQ
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumInboundBufferQ_PARAMETER,
                                     MemMap_NumInboundBufferQ_MIN,
                                     MemMap_NumInboundBufferQ_MAX,
                                     MemMap_NumInboundBufferQ_ADJUSTABLE,
                                     MemMap_NumInboundBufferQ_POWER_OF_2,
                                     MemMap_NumInboundBufferQ_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.InboundBufferSize
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_InboundBufferSize_PARAMETER,
                                     MemMap_InboundBufferSize_MIN,
                                     MemMap_InboundBufferSize_MAX,
                                     MemMap_InboundBufferSize_ADJUSTABLE,
                                     MemMap_InboundBufferSize_POWER_OF_2,
                                     MemMap_InboundBufferSize_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CardRamSize
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CardRamSize_PARAMETER,
                                     MemMap_CardRamSize_MIN,
                                     MemMap_CardRamSize_MAX,
                                     MemMap_CardRamSize_ADJUSTABLE,
                                     MemMap_CardRamSize_POWER_OF_2,
                                     MemMap_CardRamSize_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CardRamAlignment
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CardRamAlignment_PARAMETER,
                                     MemMap_CardRamAlignment_MIN,
                                     MemMap_CardRamAlignment_MAX,
                                     MemMap_CardRamAlignment_ADJUSTABLE,
                                     MemMap_CardRamAlignment_POWER_OF_2,
                                     MemMap_CardRamAlignment_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.HostNvRamSize
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_HostNvRamSize_PARAMETER,
                                     MemMap_HostNvRamSize_MIN,
                                     MemMap_HostNvRamSize_MAX,
                                     MemMap_HostNvRamSize_ADJUSTABLE,
                                     MemMap_HostNvRamSize_POWER_OF_2,
                                     MemMap_HostNvRamSize_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.ExchangeTableLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_ExchangeTableLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_ExchangeTableLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_ExchangeTableLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SGLsLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SGLsLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_SGLsLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_SGLsLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_CMND_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_CMND_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_FCP_CMND_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_FCP_CMND_Loc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_RESP_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_RESP_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_FCP_RESP_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_FCP_RESP_Loc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SF_CMND_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SF_CMND_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_SF_CMND_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_SF_CMND_Loc_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _DvrArch_1_30_
    Calculation->Parameters.Pkt_CMND_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_Pkt_CMND_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_Pkt_CMND_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_Pkt_CMND_Loc_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _DvrArch_1_30_ was not defined */

    Calculation->Parameters.CommandQLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CommandQLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CommandQLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CommandQLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CommandQConsLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CommandQConsLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CommandQConsLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CommandQConsLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CompletionQLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CompletionQLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CompletionQLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CompletionQLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CompletionQProdLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CompletionQProdLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CompletionQProdLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CompletionQProdLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.InboundBufferLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_InboundBufferLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_InboundBufferLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_InboundBufferLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.TimerTickInterval
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_TimerTickInterval_PARAMETER,
                                     MemMap_TimerTickInterval_MIN,
                                     MemMap_TimerTickInterval_MAX,
                                     MemMap_TimerTickInterval_ADJUSTABLE,
                                     MemMap_TimerTickInterval_POWER_OF_2,
                                     MemMap_TimerTickInterval_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IO_Mode
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IO_Mode_PARAMETER,
                                     MemMap_IO_Mode_MIN,
                                     MemMap_IO_Mode_MAX,
                                     MemMap_IO_Mode_ADJUSTABLE,
                                     MemMap_IO_Mode_POWER_OF_2,
                                     MemMap_IO_Mode_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayAmount
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayAmount_PARAMETER,
                                     MemMap_IntDelayAmount_MIN,
                                     MemMap_IntDelayAmount_MAX,
                                     MemMap_IntDelayAmount_ADJUSTABLE,
                                     MemMap_IntDelayAmount_POWER_OF_2,
                                     MemMap_IntDelayAmount_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayRateMethod
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayRateMethod_PARAMETER,
                                     MemMap_IntDelayRateMethod_MIN,
                                     MemMap_IntDelayRateMethod_MAX,
                                     MemMap_IntDelayRateMethod_ADJUSTABLE,
                                     MemMap_IntDelayRateMethod_POWER_OF_2,
                                     MemMap_IntDelayRateMethod_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayOnIORate
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayOnIORate_PARAMETER,
                                     MemMap_IntDelayOnIORate_MIN,
                                     MemMap_IntDelayOnIORate_MAX,
                                     MemMap_IntDelayOnIORate_ADJUSTABLE,
                                     MemMap_IntDelayOnIORate_POWER_OF_2,
                                     MemMap_IntDelayOnIORate_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayOffIORate
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayOffIORate_PARAMETER,
                                     MemMap_IntDelayOffIORate_MIN,
                                     MemMap_IntDelayOffIORate_MAX,
                                     MemMap_IntDelayOffIORate_ADJUSTABLE,
                                     MemMap_IntDelayOffIORate_POWER_OF_2,
                                     MemMap_IntDelayOffIORate_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IOsBetweenISRs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IOsBetweenISRs_PARAMETER,
                                     MemMap_IOsBetweenISRs_MIN,
                                     MemMap_IOsBetweenISRs_MAX,
                                     MemMap_IOsBetweenISRs_ADJUSTABLE,
                                     MemMap_IOsBetweenISRs_POWER_OF_2,
                                     MemMap_IOsBetweenISRs_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _Enforce_MaxCommittedMemory_
    Calculation->Parameters.MaxCommittedMemory
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_MaxCommittedMemory_PARAMETER,
                                     MemMap_MaxCommittedMemory_MIN,
                                     MemMap_MaxCommittedMemory_MAX,
                                     MemMap_MaxCommittedMemory_ADJUSTABLE,
                                     MemMap_MaxCommittedMemory_POWER_OF_2,
                                     MemMap_MaxCommittedMemory_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    Calculation->Parameters.FlashUsageModel 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_FlashUsageModel_PARAMETER,
                                    MemMap_FlashUsageModel_MIN,
                                    MemMap_FlashUsageModel_MAX,
                                    MemMap_FlashUsageModel_ADJUSTABLE,
                                    MemMap_FlashUsageModel_POWER_OF_2,
                                    MemMap_FlashUsageModel_DEFAULT,
                                    EnforceDefaults
                                   );

    Calculation->Parameters.InitAsNport 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_InitAsNport_PARAMETER,
                                    MemMap_InitAsNport_MIN,
                                    MemMap_InitAsNport_MAX,
                                    MemMap_InitAsNport_ADJUSTABLE,
                                    MemMap_InitAsNport_POWER_OF_2,
                                    MemMap_InitAsNport_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.RelyOnLossSyncStatus 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_RelyOnLossSyncStatus_PARAMETER,
                                    MemMap_RelyOnLossSyncStatus_MIN,
                                    MemMap_RelyOnLossSyncStatus_MAX,
                                    MemMap_RelyOnLossSyncStatus_ADJUSTABLE,
                                    MemMap_RelyOnLossSyncStatus_POWER_OF_2,
                                    MemMap_RelyOnLossSyncStatus_DEFAULT,
                                    EnforceDefaults
                                   );
/* New to r20 */
    Calculation->Parameters.WolfPack 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_WolfPack_PARAMETER,
                                    MemMap_WolfPack_MIN,
                                    MemMap_WolfPack_MAX,
                                    MemMap_WolfPack_ADJUSTABLE,
                                    MemMap_WolfPack_POWER_OF_2,
                                    MemMap_WolfPack_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.HeartBeat 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_HeartBeat_PARAMETER,
                                    MemMap_HeartBeat_MIN,
                                    MemMap_HeartBeat_MAX,
                                    MemMap_HeartBeat_ADJUSTABLE,
                                    MemMap_HeartBeat_POWER_OF_2,
                                    MemMap_HeartBeat_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.ED_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_ED_TOV_PARAMETER,
                                    MemMap_ED_TOV_MIN,
                                    MemMap_ED_TOV_MAX,
                                    MemMap_ED_TOV_ADJUSTABLE,
                                    MemMap_ED_TOV_POWER_OF_2,
                                    MemMap_ED_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.RT_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_RT_TOV_PARAMETER,
                                    MemMap_RT_TOV_MIN,
                                    MemMap_RT_TOV_MAX,
                                    MemMap_RT_TOV_ADJUSTABLE,
                                    MemMap_RT_TOV_POWER_OF_2,
                                    MemMap_RT_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.LP_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_LP_TOV_PARAMETER,
                                    MemMap_LP_TOV_MIN,
                                    MemMap_LP_TOV_MAX,
                                    MemMap_LP_TOV_ADJUSTABLE,
                                    MemMap_LP_TOV_POWER_OF_2,
                                    MemMap_LP_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.AL_Time 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_AL_Time_PARAMETER,
                                    MemMap_AL_Time_MIN,
                                    MemMap_AL_Time_MAX,
                                    MemMap_AL_Time_ADJUSTABLE,
                                    MemMap_AL_Time_POWER_OF_2,
                                    MemMap_AL_Time_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.R_A_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_R_A_TOV_PARAMETER,
                                    MemMap_R_A_TOV_MIN,
                                    MemMap_R_A_TOV_MAX,
                                    MemMap_R_A_TOV_ADJUSTABLE,
                                    MemMap_R_A_TOV_POWER_OF_2,
                                    MemMap_R_A_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
/* New to r20 */

}

/*+
Function:  fiMemMapAlignUp()

Purpose:   Rounds up (if necessary) "base" to a multiple of "align".

Algorithm: This function simply rounds up "base" to the next "align"
           boundary if it isn't already so aligned.  If "align" is
           ZERO, then "base" is simply rounded up to the next power of 2.
-*/

#define fiMemMapAlignUp_Power_of_2    0
#define fiMemMapAlignUp_None_Required 1

os_bit32 fiMemMapAlignUp(
                          os_bit32 base,
                          os_bit32 align
                        )
{
    os_bit32 to_return;

    if (align == fiMemMapAlignUp_Power_of_2)
    {
        /* Align "base" up to next power of 2 (if necessary) */

        to_return = 0x80000000;

        while (to_return > base)
        {
            to_return = to_return >> 1;
        }

        if (to_return != base)
        {
            to_return = to_return << 1;
        }
    }
    else /* align != fiMemMapAlignUp_Power_of_2 */
    {
        to_return = base + align - 1;

        to_return = to_return / align;

        to_return = to_return * align;
    }

    return to_return;
}

/*+
Function:  fiMemMapAlignUpPtr()

Purpose:   Similar to fiMemMapAlignUp() except works with void pointers.

Algorithm: This function simply rounds up "base" to the next "align"
           boundary if it isn't already so aligned.  An "align" of ZERO
           (requesting rounding up to the next power of 2) is not supported.
-*/

void *fiMemMapAlignUpPtr(
                          void     *base,
                          os_bit32  align
                        )
{
    os_bitptr to_return;

    to_return = (os_bitptr)base + align - 1;

    to_return = to_return / align;

    to_return = to_return * align;

    return (void *)to_return;
}

/*+
Function:  fiMemMapSetupLayoutObjects()

Purpose:   Using the specified parameters, size all FC Layer objects.

Algorithm: This function computes the size and location for all FC Layer
           objects based on the values in the the Calculation->Parameters
           structure.  It also places each object on an unsorted list.
-*/

void fiMemMapSetupLayoutObjects(
                                 agRoot_t              *hpRoot,
                                 fiMemMapCalculation_t *Calculation
                               )
{
    Calculation->MemoryLayout.On_Card_MASK               = ((Calculation->Parameters.ExchangeTableLoc   == MemMap_Alloc_On_Card) ? MemMap_ExchangeTableLoc_MASK : 0)   |
                                                           ((Calculation->Parameters.SGLsLoc            == MemMap_Alloc_On_Card) ? MemMap_SGLsLoc_MASK : 0)            |
                                                           ((Calculation->Parameters.FCP_CMND_Loc       == MemMap_Alloc_On_Card) ? MemMap_FCP_CMND_Loc_MASK : 0)       |
                                                           ((Calculation->Parameters.FCP_RESP_Loc       == MemMap_Alloc_On_Card) ? MemMap_FCP_RESP_Loc_MASK : 0)       |
                                                           ((Calculation->Parameters.SF_CMND_Loc        == MemMap_Alloc_On_Card) ? MemMap_SF_CMND_Loc_MASK : 0)        |

#ifdef _DvrArch_1_30_
                                                           ((Calculation->Parameters.Pkt_CMND_Loc       == MemMap_Alloc_On_Card) ? MemMap_Pkt_CMND_Loc_MASK : 0)       |
#endif /* _DvrArch_1_30_ was not defined */
                                                           ((Calculation->Parameters.CommandQLoc        == MemMap_Alloc_On_Card) ? MemMap_CommandQLoc_MASK : 0)        |
                                                           ((Calculation->Parameters.CompletionQLoc     == MemMap_Alloc_On_Card) ? MemMap_CompletionQLoc_MASK : 0)     |
                                                           ((Calculation->Parameters.CommandQConsLoc    == MemMap_Alloc_On_Card) ? MemMap_CommandQConsLoc_MASK : 0)    |
                                                           ((Calculation->Parameters.CompletionQProdLoc == MemMap_Alloc_On_Card) ? MemMap_CompletionQProdLoc_MASK : 0) |
                                                           ((Calculation->Parameters.InboundBufferLoc   == MemMap_Alloc_On_Card) ? MemMap_InboundBufferLoc_MASK : 0);

    Calculation->MemoryLayout.unsorted                   = &(Calculation->MemoryLayout.SEST);

    Calculation->MemoryLayout.SEST.elements              = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.SEST.elementSize           = sizeof(SEST_t);
    Calculation->MemoryLayout.SEST.objectSize            = Calculation->MemoryLayout.SEST.elements * Calculation->MemoryLayout.SEST.elementSize;
    Calculation->MemoryLayout.SEST.objectAlign           = fiMemMapAlignUp(
                                                                            Calculation->MemoryLayout.SEST.objectSize,
                                                                            fiMemMapAlignUp_Power_of_2
                                                                          );
    Calculation->MemoryLayout.SEST.memLoc                = ((Calculation->Parameters.ExchangeTableLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.SEST.flink                 = &(Calculation->MemoryLayout.ESGL);

    Calculation->MemoryLayout.ESGL.elements              = Calculation->Parameters.NumSGLs;
    Calculation->MemoryLayout.ESGL.elementSize           = Calculation->Parameters.SizeSGLs * sizeof(SG_Element_t);
    Calculation->MemoryLayout.ESGL.objectSize            = Calculation->MemoryLayout.ESGL.elements * Calculation->MemoryLayout.ESGL.elementSize;
    Calculation->MemoryLayout.ESGL.objectAlign           = Calculation->MemoryLayout.ESGL.elementSize;
    Calculation->MemoryLayout.ESGL.memLoc                = ((Calculation->Parameters.SGLsLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.ESGL.flink                 = &(Calculation->MemoryLayout.FCP_CMND);

    Calculation->MemoryLayout.FCP_CMND.elements          = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.FCP_CMND.elementSize       = Calculation->Parameters.FCP_CMND_Size;
    Calculation->MemoryLayout.FCP_CMND.objectSize        = Calculation->MemoryLayout.FCP_CMND.elements * Calculation->MemoryLayout.FCP_CMND.elementSize;
    Calculation->MemoryLayout.FCP_CMND.objectAlign       = Calculation->MemoryLayout.FCP_CMND.elementSize;
    Calculation->MemoryLayout.FCP_CMND.memLoc            = ((Calculation->Parameters.FCP_CMND_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.FCP_CMND.flink             = &(Calculation->MemoryLayout.FCP_RESP);

    Calculation->MemoryLayout.FCP_RESP.elements          = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.FCP_RESP.elementSize       = Calculation->Parameters.FCP_RESP_Size;
    Calculation->MemoryLayout.FCP_RESP.objectSize        = Calculation->MemoryLayout.FCP_RESP.elements * Calculation->MemoryLayout.FCP_RESP.elementSize;
    Calculation->MemoryLayout.FCP_RESP.objectAlign       = Calculation->MemoryLayout.FCP_RESP.elementSize;
    Calculation->MemoryLayout.FCP_RESP.memLoc            = ((Calculation->Parameters.FCP_RESP_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.FCP_RESP.flink             = &(Calculation->MemoryLayout.SF_CMND);

    Calculation->MemoryLayout.SF_CMND.elements           = Calculation->Parameters.SF_CMND_Reserve;
    Calculation->MemoryLayout.SF_CMND.elementSize        = Calculation->Parameters.SF_CMND_Size;
    Calculation->MemoryLayout.SF_CMND.objectSize         = Calculation->MemoryLayout.SF_CMND.elements * Calculation->MemoryLayout.SF_CMND.elementSize;
    Calculation->MemoryLayout.SF_CMND.objectAlign        = Calculation->MemoryLayout.SF_CMND.elementSize;
    Calculation->MemoryLayout.SF_CMND.memLoc             = ((Calculation->Parameters.SF_CMND_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.SF_CMND.flink              = &(Calculation->MemoryLayout.ERQ);
#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.SF_CMND.flink              = &(Calculation->MemoryLayout.Pkt_CMND);

    Calculation->MemoryLayout.Pkt_CMND.elements           = Calculation->Parameters.NumPktThreads;
    Calculation->MemoryLayout.Pkt_CMND.elementSize        = Calculation->Parameters.Pkt_CMND_Size;
    Calculation->MemoryLayout.Pkt_CMND.objectSize         = Calculation->MemoryLayout.Pkt_CMND.elements * Calculation->MemoryLayout.Pkt_CMND.elementSize;
    Calculation->MemoryLayout.Pkt_CMND.objectAlign        = Calculation->MemoryLayout.Pkt_CMND.elementSize;
    Calculation->MemoryLayout.Pkt_CMND.memLoc             = ((Calculation->Parameters.Pkt_CMND_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.Pkt_CMND.flink              = &(Calculation->MemoryLayout.ERQ);
#else
    Calculation->MemoryLayout.SF_CMND.flink              = &(Calculation->MemoryLayout.ERQ);
#endif /* _DvrArch_1_30_ was not defined */

    Calculation->MemoryLayout.ERQ.elements               = Calculation->Parameters.NumCommandQ;
    Calculation->MemoryLayout.ERQ.elementSize            = sizeof(IRB_t);
    Calculation->MemoryLayout.ERQ.objectSize             = Calculation->MemoryLayout.ERQ.elements * Calculation->MemoryLayout.ERQ.elementSize;
    Calculation->MemoryLayout.ERQ.objectAlign            = Calculation->MemoryLayout.ERQ.objectSize;
    Calculation->MemoryLayout.ERQ.memLoc                 = ((Calculation->Parameters.CommandQLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.ERQ.flink                  = &(Calculation->MemoryLayout.ERQConsIndex);

    Calculation->MemoryLayout.ERQConsIndex.elements      = 1;
    Calculation->MemoryLayout.ERQConsIndex.elementSize   = sizeof(ERQConsIndex_t);
    Calculation->MemoryLayout.ERQConsIndex.objectSize    = Calculation->MemoryLayout.ERQConsIndex.elements * Calculation->MemoryLayout.ERQConsIndex.elementSize;
    Calculation->MemoryLayout.ERQConsIndex.objectAlign   = Calculation->MemoryLayout.ERQConsIndex.elementSize * 2;
    Calculation->MemoryLayout.ERQConsIndex.memLoc        = ((Calculation->Parameters.CommandQConsLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.ERQConsIndex.flink         = &(Calculation->MemoryLayout.IMQ);

    Calculation->MemoryLayout.IMQ.elements               = Calculation->Parameters.NumCompletionQ;
    Calculation->MemoryLayout.IMQ.elementSize            = sizeof(Completion_Message_t);
    Calculation->MemoryLayout.IMQ.objectSize             = Calculation->MemoryLayout.IMQ.elements * Calculation->MemoryLayout.IMQ.elementSize;
    Calculation->MemoryLayout.IMQ.objectAlign            = Calculation->MemoryLayout.IMQ.objectSize;
    Calculation->MemoryLayout.IMQ.memLoc                 = ((Calculation->Parameters.CompletionQLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.IMQ.flink                  = &(Calculation->MemoryLayout.IMQProdIndex);

    Calculation->MemoryLayout.IMQProdIndex.elements      = 1;
    Calculation->MemoryLayout.IMQProdIndex.elementSize   = sizeof(IMQProdIndex_t);
    Calculation->MemoryLayout.IMQProdIndex.objectSize    = Calculation->MemoryLayout.IMQProdIndex.elements * Calculation->MemoryLayout.IMQProdIndex.elementSize;
    Calculation->MemoryLayout.IMQProdIndex.objectAlign   = Calculation->MemoryLayout.IMQProdIndex.elementSize * 2;
    Calculation->MemoryLayout.IMQProdIndex.memLoc        = ((Calculation->Parameters.CompletionQProdLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.IMQProdIndex.flink         = &(Calculation->MemoryLayout.SFQ);

    Calculation->MemoryLayout.SFQ.elements               = Calculation->Parameters.NumInboundBufferQ;
    Calculation->MemoryLayout.SFQ.elementSize            = Calculation->Parameters.InboundBufferSize;
    Calculation->MemoryLayout.SFQ.objectSize             = Calculation->MemoryLayout.SFQ.elements * Calculation->MemoryLayout.SFQ.elementSize;
    Calculation->MemoryLayout.SFQ.objectAlign            = Calculation->MemoryLayout.SFQ.objectSize;
    Calculation->MemoryLayout.SFQ.memLoc                 = ((Calculation->Parameters.InboundBufferLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.SFQ.flink                  = &(Calculation->MemoryLayout.FlashSector);

    Calculation->MemoryLayout.FlashSector.elements       = 1;
    Calculation->MemoryLayout.FlashSector.elementSize    = sizeof(fiFlashSector_Last_Form_t);
    Calculation->MemoryLayout.FlashSector.objectSize     = Calculation->MemoryLayout.FlashSector.elements * Calculation->MemoryLayout.FlashSector.elementSize;
    Calculation->MemoryLayout.FlashSector.objectAlign    = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.FlashSector.memLoc         = inCachedMemory;
    Calculation->MemoryLayout.FlashSector.flink          = &(Calculation->MemoryLayout.SlotWWN);

    Calculation->MemoryLayout.SlotWWN.elements           = Calculation->Parameters.NumDevSlotsPerArea * Calculation->Parameters.NumAreasPerDomain * Calculation->Parameters.NumDomains;
    Calculation->MemoryLayout.SlotWWN.elementSize        = sizeof(SlotWWN_t);
    Calculation->MemoryLayout.SlotWWN.objectSize         = Calculation->MemoryLayout.SlotWWN.elements * Calculation->MemoryLayout.SlotWWN.elementSize;
    Calculation->MemoryLayout.SlotWWN.objectAlign        = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SlotWWN.memLoc             = inCachedMemory;
    Calculation->MemoryLayout.SlotWWN.flink              = &(Calculation->MemoryLayout.CThread);

    Calculation->MemoryLayout.CThread.elements           = 1;
    Calculation->MemoryLayout.CThread.elementSize        = sizeof(CThread_t);
    Calculation->MemoryLayout.CThread.objectSize         = Calculation->MemoryLayout.CThread.elements * Calculation->MemoryLayout.CThread.elementSize;
    Calculation->MemoryLayout.CThread.objectAlign        = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CThread.memLoc             = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.CThread.flink              = &(Calculation->MemoryLayout.IPThread);
#else  /* _DvrArch_1_30_ was not defined */
    Calculation->MemoryLayout.CThread.flink              = &(Calculation->MemoryLayout.TgtThread);
#endif /* _DvrArch_1_30_ was not defined */
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.CThread.flink              = &(Calculation->MemoryLayout.CTransitions);

    Calculation->MemoryLayout.CTransitions.elements      = 1;
    Calculation->MemoryLayout.CTransitions.elementSize   = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.CTransitions.objectSize    = Calculation->MemoryLayout.CTransitions.elements * Calculation->MemoryLayout.CTransitions.elementSize;
    Calculation->MemoryLayout.CTransitions.objectAlign   = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CTransitions.memLoc        = inCachedMemory;
    Calculation->MemoryLayout.CTransitions.flink         = &(Calculation->MemoryLayout.CActions);

    Calculation->MemoryLayout.CActions.elements          = 1;
    Calculation->MemoryLayout.CActions.elementSize       = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.CActions.objectSize        = Calculation->MemoryLayout.CActions.elements * Calculation->MemoryLayout.CActions.elementSize;
    Calculation->MemoryLayout.CActions.objectAlign       = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CActions.memLoc            = inCachedMemory;
#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.CActions.flink             = &(Calculation->MemoryLayout.IPThread);
#else  /* _DvrArch_1_30_ was not defined */
    Calculation->MemoryLayout.CActions.flink             = &(Calculation->MemoryLayout.TgtThread);
#endif /* _DvrArch_1_30_ was not defined */
#endif /* __State_Force_Static_State_Tables__ was not defined */

#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.IPThread.elements          = 1;
    Calculation->MemoryLayout.IPThread.elementSize       = sizeof(IPThread_t);
    Calculation->MemoryLayout.IPThread.objectSize        = Calculation->MemoryLayout.IPThread.elements * Calculation->MemoryLayout.IPThread.elementSize;
    Calculation->MemoryLayout.IPThread.objectAlign       = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.IPThread.memLoc            = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.IPThread.flink             = &(Calculation->MemoryLayout.PktThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.IPThread.flink             = &(Calculation->MemoryLayout.IPTransitions);

    Calculation->MemoryLayout.IPTransitions.elements     = 1;
    Calculation->MemoryLayout.IPTransitions.elementSize  = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.IPTransitions.objectSize   = Calculation->MemoryLayout.IPTransitions.elements * Calculation->MemoryLayout.IPTransitions.elementSize;
    Calculation->MemoryLayout.IPTransitions.objectAlign  = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.IPTransitions.memLoc       = inCachedMemory;
    Calculation->MemoryLayout.IPTransitions.flink        = &(Calculation->MemoryLayout.IPActions);

    Calculation->MemoryLayout.IPActions.elements         = 1;
    Calculation->MemoryLayout.IPActions.elementSize      = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.IPActions.objectSize       = Calculation->MemoryLayout.IPActions.elements * Calculation->MemoryLayout.IPActions.elementSize;
    Calculation->MemoryLayout.IPActions.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.IPActions.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.IPActions.flink            = &(Calculation->MemoryLayout.PktThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.PktThread.elements         = Calculation->Parameters.NumPktThreads;
    Calculation->MemoryLayout.PktThread.elementSize      = sizeof(PktThread_t);
    Calculation->MemoryLayout.PktThread.objectSize       = Calculation->MemoryLayout.PktThread.elements * Calculation->MemoryLayout.PktThread.elementSize;
    Calculation->MemoryLayout.PktThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.PktThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.PktThread.flink            = &(Calculation->MemoryLayout.TgtThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.PktThread.flink            = &(Calculation->MemoryLayout.PktTransitions);

    Calculation->MemoryLayout.PktTransitions.elements    = 1;
    Calculation->MemoryLayout.PktTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.PktTransitions.objectSize  = Calculation->MemoryLayout.PktTransitions.elements * Calculation->MemoryLayout.PktTransitions.elementSize;
    Calculation->MemoryLayout.PktTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.PktTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.PktTransitions.flink       = &(Calculation->MemoryLayout.PktActions);

    Calculation->MemoryLayout.PktActions.elements        = 1;
    Calculation->MemoryLayout.PktActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.PktActions.objectSize      = Calculation->MemoryLayout.PktActions.elements * Calculation->MemoryLayout.PktActions.elementSize;
    Calculation->MemoryLayout.PktActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.PktActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.PktActions.flink           = &(Calculation->MemoryLayout.TgtThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */
#endif /* _DvrArch_1_30_ was defined */

    Calculation->MemoryLayout.TgtThread.elements         = Calculation->Parameters.NumTgtCmnds;
    Calculation->MemoryLayout.TgtThread.elementSize      = sizeof(TgtThread_t) + Calculation->Parameters.TGT_CMND_Size - sizeof(FCHS_t);
    Calculation->MemoryLayout.TgtThread.objectSize       = Calculation->MemoryLayout.TgtThread.elements * Calculation->MemoryLayout.TgtThread.elementSize;
    Calculation->MemoryLayout.TgtThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.TgtThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.TgtThread.flink            = &(Calculation->MemoryLayout.DevThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.TgtThread.flink            = &(Calculation->MemoryLayout.TgtTransitions);

    Calculation->MemoryLayout.TgtTransitions.elements    = 1;
    Calculation->MemoryLayout.TgtTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.TgtTransitions.objectSize  = Calculation->MemoryLayout.TgtTransitions.elements * Calculation->MemoryLayout.TgtTransitions.elementSize;
    Calculation->MemoryLayout.TgtTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.TgtTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.TgtTransitions.flink       = &(Calculation->MemoryLayout.TgtActions);

    Calculation->MemoryLayout.TgtActions.elements        = 1;
    Calculation->MemoryLayout.TgtActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.TgtActions.objectSize      = Calculation->MemoryLayout.TgtActions.elements * Calculation->MemoryLayout.TgtActions.elementSize;
    Calculation->MemoryLayout.TgtActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.TgtActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.TgtActions.flink           = &(Calculation->MemoryLayout.DevThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.DevThread.elements         = Calculation->Parameters.NumDevices;
    Calculation->MemoryLayout.DevThread.elementSize      = sizeof(DevThread_t);
    Calculation->MemoryLayout.DevThread.objectSize       = Calculation->MemoryLayout.DevThread.elements * Calculation->MemoryLayout.DevThread.elementSize;
    Calculation->MemoryLayout.DevThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.DevThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.DevThread.flink            = &(Calculation->MemoryLayout.CDBThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.DevThread.flink            = &(Calculation->MemoryLayout.DevTransitions);

    Calculation->MemoryLayout.DevTransitions.elements    = 1;
    Calculation->MemoryLayout.DevTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.DevTransitions.objectSize  = Calculation->MemoryLayout.DevTransitions.elements * Calculation->MemoryLayout.DevTransitions.elementSize;
    Calculation->MemoryLayout.DevTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.DevTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.DevTransitions.flink       = &(Calculation->MemoryLayout.DevActions);

    Calculation->MemoryLayout.DevActions.elements        = 1;
    Calculation->MemoryLayout.DevActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.DevActions.objectSize      = Calculation->MemoryLayout.DevActions.elements * Calculation->MemoryLayout.DevActions.elementSize;
    Calculation->MemoryLayout.DevActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.DevActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.DevActions.flink           = &(Calculation->MemoryLayout.CDBThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.CDBThread.elements         = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.CDBThread.elementSize      = sizeof(CDBThread_t) + ((Calculation->Parameters.SizeCachedSGLs - MemMap_SizeCachedSGLs_MIN) * sizeof(SG_Element_t));
    Calculation->MemoryLayout.CDBThread.objectSize       = Calculation->MemoryLayout.CDBThread.elements * Calculation->MemoryLayout.CDBThread.elementSize;
    Calculation->MemoryLayout.CDBThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CDBThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.CDBThread.flink            = &(Calculation->MemoryLayout.SFThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.CDBThread.flink            = &(Calculation->MemoryLayout.CDBTransitions);

    Calculation->MemoryLayout.CDBTransitions.elements    = 1;
    Calculation->MemoryLayout.CDBTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.CDBTransitions.objectSize  = Calculation->MemoryLayout.CDBTransitions.elements * Calculation->MemoryLayout.CDBTransitions.elementSize;
    Calculation->MemoryLayout.CDBTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CDBTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.CDBTransitions.flink       = &(Calculation->MemoryLayout.CDBActions);

    Calculation->MemoryLayout.CDBActions.elements        = 1;
    Calculation->MemoryLayout.CDBActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.CDBActions.objectSize      = Calculation->MemoryLayout.CDBActions.elements * Calculation->MemoryLayout.CDBActions.elementSize;
    Calculation->MemoryLayout.CDBActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CDBActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.CDBActions.flink           = &(Calculation->MemoryLayout.SFThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.SFThread.elements          = Calculation->Parameters.SF_CMND_Reserve;
    Calculation->MemoryLayout.SFThread.elementSize       = sizeof(SFThread_t);
    Calculation->MemoryLayout.SFThread.objectSize        = Calculation->MemoryLayout.SFThread.elements * Calculation->MemoryLayout.SFThread.elementSize;
    Calculation->MemoryLayout.SFThread.objectAlign       = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SFThread.memLoc            = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.SFThread.flink             = &(Calculation->MemoryLayout.LOOPDeviceMAP);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.SFThread.flink             = &(Calculation->MemoryLayout.SFTransitions);

    Calculation->MemoryLayout.SFTransitions.elements     = 1;
    Calculation->MemoryLayout.SFTransitions.elementSize  = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.SFTransitions.objectSize   = Calculation->MemoryLayout.SFTransitions.elements * Calculation->MemoryLayout.SFTransitions.elementSize;
    Calculation->MemoryLayout.SFTransitions.objectAlign  = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SFTransitions.memLoc       = inCachedMemory;
    Calculation->MemoryLayout.SFTransitions.flink        = &(Calculation->MemoryLayout.SFActions);

    Calculation->MemoryLayout.SFActions.elements         = 1;
    Calculation->MemoryLayout.SFActions.elementSize      = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.SFActions.objectSize       = Calculation->MemoryLayout.SFActions.elements * Calculation->MemoryLayout.SFActions.elementSize;
    Calculation->MemoryLayout.SFActions.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SFActions.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.SFActions.flink            = &(Calculation->MemoryLayout.LOOPDeviceMAP);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.LOOPDeviceMAP.elements         = 1;
    Calculation->MemoryLayout.LOOPDeviceMAP.elementSize      = MemMap_NumLOOPDeviceMAP_DEFAULT;
    Calculation->MemoryLayout.LOOPDeviceMAP.objectSize       = MemMap_NumLOOPDeviceMAP_DEFAULT;
    Calculation->MemoryLayout.LOOPDeviceMAP.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.LOOPDeviceMAP.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.LOOPDeviceMAP.flink            =  &(Calculation->MemoryLayout.FabricDeviceMAP);


    Calculation->MemoryLayout.FabricDeviceMAP.elements         = Calculation->Parameters.NumDevices;
    Calculation->MemoryLayout.FabricDeviceMAP.elementSize      = sizeof(os_bit32);
    Calculation->MemoryLayout.FabricDeviceMAP.objectSize       = sizeof(os_bit32) * Calculation->Parameters.NumDevices;
    Calculation->MemoryLayout.FabricDeviceMAP.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.FabricDeviceMAP.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.FabricDeviceMAP.flink            = (fiMemMapMemoryDescriptor_t *)agNULL;

}

/*+
Function:  fiMemMapSortByAlignThenSize()

Purpose:   Inserts an object into a sorted list based on alignment & size.

Algorithm: This function inserts an object in the specified list.  This
           list is sorted to start with the object requiring the largest
           alignment.  If two objects require the same alignment, the
           larger object will appear first.
-*/

void fiMemMapSortByAlignThenSize(
                                  agRoot_t                    *hpRoot,
                                  fiMemMapMemoryDescriptor_t **listHead,
                                  fiMemMapMemoryDescriptor_t  *listObject
                                )
{
    fiMemMapMemoryDescriptor_t **insertAfter  =  listHead;
    fiMemMapMemoryDescriptor_t  *insertBefore = *listHead;

    while ((insertBefore != (fiMemMapMemoryDescriptor_t *)agNULL) &&
           ((listObject->objectAlign < insertBefore->objectAlign) ||
            ((listObject->objectAlign == insertBefore->objectAlign) &&
             (listObject->objectSize < insertBefore->objectSize))))
    {
        insertAfter  = (fiMemMapMemoryDescriptor_t **)(*insertAfter);
        insertBefore =                                 *insertAfter;
    }

     listObject->flink = *insertAfter;
    *insertAfter       =  listObject;
}

/*+
Function:  fiMemMapSortLayoutObjects()

Purpose:   Creates ordered lists of objects for each memory type.

Algorithm: This function creates a sorted list for each memory type to
           hold objects of decreasing alignment & size.
-*/

void fiMemMapSortLayoutObjects(
                                agRoot_t               *hpRoot,
                                fiMemMapMemoryLayout_t *MemoryLayout
                              )
{
    fiMemMapMemoryDescriptor_t *nextDescriptor;
    
    MemoryLayout->sortedCachedMemory = (fiMemMapMemoryDescriptor_t *)agNULL;
    MemoryLayout->sortedDmaMemory    = (fiMemMapMemoryDescriptor_t *)agNULL;
    MemoryLayout->sortedCardRam      = (fiMemMapMemoryDescriptor_t *)agNULL;

    while (MemoryLayout->unsorted != ((fiMemMapMemoryDescriptor_t *)agNULL))
    {
        nextDescriptor = MemoryLayout->unsorted;

        MemoryLayout->unsorted = nextDescriptor->flink;

        if (nextDescriptor->memLoc == inCachedMemory)
        {
            fiMemMapSortByAlignThenSize(
                                         hpRoot,
                                         &(MemoryLayout->sortedCachedMemory),
                                         nextDescriptor
                                       );
        }
        else if (nextDescriptor->memLoc == inDmaMemory)
        {
            fiMemMapSortByAlignThenSize(
                                         hpRoot,
                                         &(MemoryLayout->sortedDmaMemory),
                                         nextDescriptor
                                       );
        }
        else /* nextDescriptor->memLoc == inCardRam */
        {
            fiMemMapSortByAlignThenSize(
                                         hpRoot,
                                         &(MemoryLayout->sortedCardRam),
                                         nextDescriptor
                                       );
        }
    }
}

/*+
Function:  fiMemMapLayoutObjects()

Purpose:   Allocates memory for each object in the FC Layer.

Algorithm: This function walks each sorted list of objects allocating
           the corresponding type of memory while obeying the alignment
           restrictions of each object.  All addresses & offsets are
           computed along the way based on the supplied base addresses.
-*/

void fiMemMapLayoutObjects(
                            agRoot_t              *hpRoot,
                            fiMemMapCalculation_t *Calculation
                          )
{
    fiMemMapMemoryDescriptor_t *MemoryDescriptor;
    os_bit32                       MemoryOffset;

/*+
Allocate CachedMemory objects
-*/

    MemoryDescriptor = Calculation->MemoryLayout.sortedCachedMemory;

    if (MemoryDescriptor == (fiMemMapMemoryDescriptor_t *)agNULL)
    {
        Calculation->ToRequest.cachedMemoryNeeded          = 0;
        Calculation->ToRequest.cachedMemoryPtrAlignAssumed = fiMemMapAlignUp_None_Required;
    }
    else
    {
        Calculation->ToRequest.cachedMemoryPtrAlignAssumed
            = MemoryDescriptor->objectAlign;
    
        MemoryOffset = 0;

        while (MemoryDescriptor != (fiMemMapMemoryDescriptor_t *)agNULL)
        {
            MemoryOffset = fiMemMapAlignUp(
                                            MemoryOffset,
                                            MemoryDescriptor->objectAlign
                                          );

            MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                = (void *)((os_bit8 *)Calculation->Input.cachedMemoryPtr + MemoryOffset);

            MemoryOffset += MemoryDescriptor->objectSize;

            MemoryDescriptor = MemoryDescriptor->flink;
        }

        Calculation->ToRequest.cachedMemoryNeeded = MemoryOffset;
    }

/*+
Allocate DmaMemory objects
-*/

    MemoryDescriptor = Calculation->MemoryLayout.sortedDmaMemory;

    Calculation->ToRequest.dmaMemoryPtrAlignAssumed     = fiMemMapAlignUp_None_Required;

    if (MemoryDescriptor == (fiMemMapMemoryDescriptor_t *)agNULL)
    {
        Calculation->ToRequest.dmaMemoryNeeded          = 0;
        Calculation->ToRequest.dmaMemoryPhyAlignAssumed = fiMemMapAlignUp_None_Required;
    }
    else
    {
        Calculation->ToRequest.dmaMemoryPhyAlignAssumed
            = MemoryDescriptor->objectAlign;
    
        MemoryOffset = 0;

        while (MemoryDescriptor != (fiMemMapMemoryDescriptor_t *)agNULL)
        {
            MemoryOffset = fiMemMapAlignUp(
                                            MemoryOffset,
                                            MemoryDescriptor->objectAlign
                                          );

            MemoryDescriptor->addr.DmaMemory.dmaMemoryUpper32
                = Calculation->Input.dmaMemoryUpper32;
            MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32
                = Calculation->Input.dmaMemoryLower32 + MemoryOffset;
            MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                = (void *)((os_bit8 *)Calculation->Input.dmaMemoryPtr + MemoryOffset);

            MemoryOffset += MemoryDescriptor->objectSize;

            MemoryDescriptor = MemoryDescriptor->flink;
        }

        Calculation->ToRequest.dmaMemoryNeeded = MemoryOffset;
    }

/*+
Allocate CardRam objects
-*/

    MemoryDescriptor = Calculation->MemoryLayout.sortedCardRam;

    if (MemoryDescriptor == (fiMemMapMemoryDescriptor_t *)agNULL)
    {
        Calculation->ToRequest.cardRamNeeded          = 0;
        Calculation->ToRequest.cardRamPhyAlignAssumed = fiMemMapAlignUp_None_Required;
    }
    else
    {
        Calculation->ToRequest.cardRamPhyAlignAssumed
            = MemoryDescriptor->objectAlign;
    
        MemoryOffset = 0;

        while (MemoryDescriptor != (fiMemMapMemoryDescriptor_t *)agNULL)
        {
            MemoryOffset = fiMemMapAlignUp(
                                            MemoryOffset,
                                            MemoryDescriptor->objectAlign
                                          );

            MemoryDescriptor->addr.CardRam.cardRamUpper32
                = Calculation->Input.cardRamUpper32;
            MemoryDescriptor->addr.CardRam.cardRamLower32
                = Calculation->Input.cardRamLower32 + MemoryOffset;
            MemoryDescriptor->addr.CardRam.cardRamOffset = MemoryOffset;

            MemoryOffset += MemoryDescriptor->objectSize;

            MemoryDescriptor = MemoryDescriptor->flink;
        }

        Calculation->ToRequest.cardRamNeeded = MemoryOffset;
    }

    Calculation->ToRequest.nvMemoryNeeded
        = Calculation->Parameters.HostNvRamSize;

    Calculation->ToRequest.usecsPerTick
        = Calculation->Parameters.TimerTickInterval;
}

/*+
Function:  fiMemMapFinishToRequest()

Purpose:   Completes the ToRequest portion of Calculation.

Algorithm: This function merely fills in the ToRequest portion of
           the Calculation structure with the values unrelated to
           memory objects allocated in fiMemMapLayoutObjects().
-*/

void fiMemMapFinishToRequest(
                              agRoot_t              *hpRoot,
                              fiMemMapCalculation_t *Calculation
                            )
{
    Calculation->ToRequest.nvMemoryNeeded
        = Calculation->Parameters.HostNvRamSize;

    Calculation->ToRequest.usecsPerTick
        = Calculation->Parameters.TimerTickInterval;
}

/*+
Function:  fiMemMapValidate()

Purpose:   Validates the Input portion of Calculation.

Algorithm: This function verifies that the Input portion of
           the Calculation structure satisfies the ToRequest
           portion of the Calculation structure.
-*/

agBOOLEAN fiMemMapValidate(
                          agRoot_t              *hpRoot,
                          fiMemMapCalculation_t *Calculation
                        )
{
    agBOOLEAN to_return = agTRUE;

    if (Calculation->ToRequest.cachedMemoryNeeded > Calculation->Input.cachedMemoryLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cachedMemoryNeeded > cachedMemoryLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }
    
    if (Calculation->Input.cachedMemoryPtr !=
        fiMemMapAlignUpPtr(
                            Calculation->Input.cachedMemoryPtr,
                            Calculation->ToRequest.cachedMemoryPtrAlignAssumed
                          ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cachedMemoryPtr not cachedMemoryPtrAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->ToRequest.dmaMemoryNeeded > Calculation->Input.dmaMemoryLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): dmaMemoryNeeded > dmaMemoryLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }
    
    if (Calculation->Input.dmaMemoryPtr !=
        fiMemMapAlignUpPtr(
                            Calculation->Input.dmaMemoryPtr,
                            Calculation->ToRequest.dmaMemoryPtrAlignAssumed
                          ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): dmaMemoryPtr not dmaMemoryPtrAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->Input.dmaMemoryLower32 !=
        fiMemMapAlignUp(
                         Calculation->Input.dmaMemoryLower32,
                         Calculation->ToRequest.dmaMemoryPhyAlignAssumed
                       ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): dmaMemoryLower32 not dmaMemoryPhyAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->ToRequest.cardRamNeeded > Calculation->Input.cardRamLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cardRamNeeded > cardRamLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }
    
    if (Calculation->Input.cardRamLower32 !=
        fiMemMapAlignUp(
                         Calculation->Input.cardRamLower32,
                         Calculation->ToRequest.cardRamPhyAlignAssumed
                       ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cardRamLower32 not cardRamPhyAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->ToRequest.nvMemoryNeeded > Calculation->Input.nvMemoryLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): nvMemoryNeeded > nvMemoryLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    return to_return;
}

/*+
Function:  fiMemMapDumpBit32()

Purpose:   Shorthand for a call to fiLogDebugString().

Algorithm: This function simply calls fiLogDebugString() logging the
           specified Bit32 value.
-*/

void fiMemMapDumpBit32(
                        agRoot_t *hpRoot,
                        char     *formatString,
                        os_bit32     Bit32
                      )
{
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      formatString,
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      Bit32,
                      0,0,0,0,0,0,0
                    );
}

/*+
Function:  fiMemMapDumpMemoryDescriptor()

Purpose:   Logs the various fields of a MemoryDescriptor.

Algorithm: This function logs each of the fields of a MemoryDescriptor
           object.  MemoryDescriptor objects for each type of memory
           are supported.
-*/

void fiMemMapDumpMemoryDescriptor(
                                   agRoot_t                   *hpRoot,
                                   char                       *headingString,
                                   fiMemMapMemoryDescriptor_t *MemoryDescriptor
                                 )
{
    if (MemoryDescriptor->memLoc == inCachedMemory)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "%40s         va = 0x%p",
                          headingString,(char *)agNULL,
                          MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
    else if (MemoryDescriptor->memLoc == inDmaMemory)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "%40s         pa = 0x%08X",
                          headingString,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32,
                          0,0,0,0,0,0,0
                        );
/*
        fiMemMapDumpBit32(
                           hpRoot,
                           "                                                 va = 0x%08X",
                           (os_bit32)MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                         );
*/
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "                                                 va = 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                         );

    }
    else /* MemoryDescriptor->memLoc == inCardRam */
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "%40s         pa = 0x%08X",
                          headingString,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          MemoryDescriptor->addr.CardRam.cardRamLower32,
                          0,0,0,0,0,0,0
                        );

        fiMemMapDumpBit32(
                           hpRoot,
                           "                                                off = 0x%08X",
                           MemoryDescriptor->addr.CardRam.cardRamOffset
                         );
    }

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                         objectSize = 0x%08X",
                       MemoryDescriptor->objectSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                        objectAlign = 0x%08X",
                       MemoryDescriptor->objectAlign
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                           elements = 0x%08X",
                       MemoryDescriptor->elements
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                        elementSize = 0x%08X",
                       MemoryDescriptor->elementSize
                     );
}

/*+
Function:  fiMemMapDumpCalculation()

Purpose:   Logs the various fields of the entire Calculation structure.

Algorithm: This function logs each of the fields of a Calculation
           structure.  The amount of data logged is quite large, but
           very complete.  The output can be used to understand the
           entire memory layout of the FC Layer in all types of memory.
-*/

void fiMemMapDumpCalculation(
                              agRoot_t              *hpRoot,
                              fiMemMapCalculation_t *Calculation,
                              agBOOLEAN                EnforceDefaults,
                              agBOOLEAN                to_return
                            )
{
    char *agTRUE_str            = "agTRUE";
    char *agFALSE_str           = "agFALSE";
    char *EnforceDefaults_str;
    char *to_return_str;
    char *sysIntsActive_str;

    if (EnforceDefaults == agTRUE)
    {
        EnforceDefaults_str = agTRUE_str;
    }
    else
    {
        EnforceDefaults_str = agFALSE_str;
    }
    
    if (to_return == agTRUE)
    {
        to_return_str = agTRUE_str;
    }
    else
    {
        to_return_str = agFALSE_str;
    }
    
    if (Calculation->Input.sysIntsActive == agTRUE)
    {
        sysIntsActive_str = agTRUE_str;
    }
    else
    {
        sysIntsActive_str = agFALSE_str;
    }
/*    
    fiMemMapDumpBit32(
                       hpRoot,
                       "fiMemMapCalculate( hpRoot          == 0x%08X,",
                       (os_bit32)hpRoot
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "fiMemMapCalculate( hpRoot          == 0x%p,",
                      (char *)agNULL,(char *)agNULL,
                      hpRoot,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

/*
    fiMemMapDumpBit32(
                       hpRoot,
                       "                   Calculation     == 0x%08X,",
                       (os_bit32)Calculation
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   Calculation     == 0x%p,",
                      (char *)agNULL,(char *)agNULL,
                      Calculation,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   EnforceDefaults == %12s) returns %s",
                      EnforceDefaults_str,
                      to_return_str,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.Input.initType         = 0x%08X",
                       (os_bit32)Calculation->Input.initType
                     );

    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   .sysIntsActive    = %s",
                      sysIntsActive_str,
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );
/*
    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cachedMemoryPtr  = 0x%08X",
                       (os_bit32)Calculation->Input.cachedMemoryPtr
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   .cachedMemoryPtr  = 0x%p",
                      (char *)agNULL,(char *)agNULL,
                      Calculation->Input.cachedMemoryPtr,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cachedMemoryLen  = 0x%08X",
                       Calculation->Input.cachedMemoryLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryUpper32 = 0x%08X",
                       Calculation->Input.dmaMemoryUpper32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryLower32 = 0x%08X",
                       Calculation->Input.dmaMemoryLower32
                     );
/*
    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryPtr     = 0x%08X",
                       (os_bit32)Calculation->Input.dmaMemoryPtr
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   .dmaMemoryPtr     = 0x%p",
                      (char *)agNULL,(char *)agNULL,
                      Calculation->Input.dmaMemoryPtr,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryLen     = 0x%08X",
                       Calculation->Input.dmaMemoryLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .nvMemoryLen      = 0x%08X",
                       Calculation->Input.nvMemoryLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRamUpper32   = 0x%08X",
                       Calculation->Input.cardRamUpper32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRamLower32   = 0x%08X",
                       Calculation->Input.cardRamLower32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRamLen       = 0x%08X",
                       Calculation->Input.cardRamLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRomUpper32   = 0x%08X",
                       Calculation->Input.cardRomUpper32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRomLower32   = 0x%08X",
                       Calculation->Input.cardRomLower32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRomLen       = 0x%08X",
                       Calculation->Input.cardRomLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .usecsPerTick     = 0x%08X",
                       Calculation->Input.usecsPerTick
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.Parameters.NumDevSlotsPerArea = 0x%08X",
                       Calculation->Parameters.NumDevSlotsPerArea
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumAreasPerDomain  = 0x%08X",
                       Calculation->Parameters.NumAreasPerDomain
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumDomains         = 0x%08X",
                       Calculation->Parameters.NumDomains
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumDevices         = 0x%08X",
                       Calculation->Parameters.NumDevices
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumIOs             = 0x%08X",
                       Calculation->Parameters.NumIOs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SizeSGLs           = 0x%08X",
                       Calculation->Parameters.SizeSGLs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumSGLs            = 0x%08X",
                       Calculation->Parameters.NumSGLs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SizeCachedSGLs     = 0x%08X",
                       Calculation->Parameters.SizeCachedSGLs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_CMND_Size      = 0x%08X",
                       Calculation->Parameters.FCP_CMND_Size
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_RESP_Size      = 0x%08X",
                       Calculation->Parameters.FCP_RESP_Size
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SF_CMND_Reserve    = 0x%08X",
                       Calculation->Parameters.SF_CMND_Reserve
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SF_CMND_Size       = 0x%08X",
                       Calculation->Parameters.SF_CMND_Size
                     );

#ifdef _DvrArch_1_30_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .Pkt_CMND_Size       = 0x%08X",
                       Calculation->Parameters.Pkt_CMND_Size
                     );
#endif /* _DvrArch_1_30_ was not defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumTgtCmnds        = 0x%08X",
                       Calculation->Parameters.NumTgtCmnds
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .TGT_CMND_Size      = 0x%08X",
                       Calculation->Parameters.TGT_CMND_Size
                     );

#ifdef _DvrArch_1_30_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumPktThreads      = 0x%08X",
                       Calculation->Parameters.NumPktThreads
                     );
#endif /* _DvrArch_1_30_ was defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumCommandQ        = 0x%08X",
                       Calculation->Parameters.NumCommandQ
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumCompletionQ     = 0x%08X",
                       Calculation->Parameters.NumCompletionQ
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumInboundBufferQ  = 0x%08X",
                       Calculation->Parameters.NumInboundBufferQ
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .InboundBufferSize  = 0x%08X",
                       Calculation->Parameters.InboundBufferSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CardRamSize        = 0x%08X",
                       Calculation->Parameters.CardRamSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CardRamAlignment   = 0x%08X",
                       Calculation->Parameters.CardRamAlignment
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .HostNvRamSize      = 0x%08X",
                       Calculation->Parameters.HostNvRamSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .ExchangeTableLoc   = %1d",
                       Calculation->Parameters.ExchangeTableLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SGLsLoc            = %1d",
                       Calculation->Parameters.SGLsLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_CMND_Loc       = %1d",
                       Calculation->Parameters.FCP_CMND_Loc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_RESP_Loc       = %1d",
                       Calculation->Parameters.FCP_RESP_Loc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SF_CMND_Loc        = %1d",
                       Calculation->Parameters.SF_CMND_Loc
                     );

#ifdef _DvrArch_1_30_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .Pkt_CMND_Loc        = %1d",
                       Calculation->Parameters.Pkt_CMND_Loc
                     );

#endif /* _DvrArch_1_30_ was not defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CommandQLoc        = %1d",
                       Calculation->Parameters.CommandQLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CommandQConsLoc    = %1d",
                       Calculation->Parameters.CommandQConsLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CompletionQLoc     = %1d",
                       Calculation->Parameters.CompletionQLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CompletionQProdLoc = %1d",
                       Calculation->Parameters.CompletionQProdLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .InboundBufferLoc   = %1d",
                       Calculation->Parameters.InboundBufferLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .TimerTickInterval  = 0x%08X",
                       Calculation->Parameters.TimerTickInterval
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IO_Mode            = %1d",
                       Calculation->Parameters.IO_Mode
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayAmount     = 0x%08X",
                       Calculation->Parameters.IntDelayAmount
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayRateMethod = %1d",
                       Calculation->Parameters.IntDelayRateMethod
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayOnIORate   = 0x%08X",
                       Calculation->Parameters.IntDelayOnIORate
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayOffIORate  = 0x%08X",
                       Calculation->Parameters.IntDelayOffIORate
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IOsBetweenISRs     = 0x%08X",
                       Calculation->Parameters.IOsBetweenISRs
                     );

#ifdef _Enforce_MaxCommittedMemory_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .MaxCommittedMemory = 0x%08X",
                       Calculation->Parameters.MaxCommittedMemory
                     );
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FlashUsageModel    = %1d",
                       Calculation->Parameters.FlashUsageModel
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .RelyOnLossSyncStatus        = %1d",
                       Calculation->Parameters.RelyOnLossSyncStatus
                     );
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .InitAsNport        = %1d",
                       Calculation->Parameters.InitAsNport
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.ToRequest.cachedMemoryNeeded          = 0x%08X",
                       Calculation->ToRequest.cachedMemoryNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .cachedMemoryPtrAlignAssumed = 0x%08X",
                       Calculation->ToRequest.cachedMemoryPtrAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .dmaMemoryNeeded             = 0x%08X",
                       Calculation->ToRequest.dmaMemoryNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .dmaMemoryPtrAlignAssumed    = 0x%08X",
                       Calculation->ToRequest.dmaMemoryPtrAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .dmaMemoryPhyAlignAssumed    = 0x%08X",
                       Calculation->ToRequest.dmaMemoryPhyAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .cardRamNeeded               = 0x%08X",
                       Calculation->ToRequest.cardRamNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .cardRamPhyAlignAssumed      = 0x%08X",
                       Calculation->ToRequest.cardRamPhyAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .nvMemoryNeeded              = 0x%08X",
                       Calculation->ToRequest.nvMemoryNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .usecsPerTick                = 0x%08X",
                       Calculation->ToRequest.usecsPerTick
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.MemoryLayout.On_Card_MASK             = 0x%08X",
                       Calculation->MemoryLayout.On_Card_MASK
                     );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SEST",
                                  &(Calculation->MemoryLayout.SEST)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .ESGL",
                                  &(Calculation->MemoryLayout.ESGL)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .FCP_CMND",
                                  &(Calculation->MemoryLayout.FCP_CMND)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .FCP_RESP",
                                  &(Calculation->MemoryLayout.FCP_RESP)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SF_CMND",
                                  &(Calculation->MemoryLayout.SF_CMND)
                                );

#ifdef _DvrArch_1_30_
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .Pkt_CMND",
                                  &(Calculation->MemoryLayout.Pkt_CMND)
                                );

#endif /* _DvrArch_1_30_ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .ERQ",
                                  &(Calculation->MemoryLayout.ERQ)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .ERQConsIndex",
                                  &(Calculation->MemoryLayout.ERQConsIndex)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IMQ",
                                  &(Calculation->MemoryLayout.IMQ)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IMQProdIndex",
                                  &(Calculation->MemoryLayout.IMQProdIndex)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFQ",
                                  &(Calculation->MemoryLayout.SFQ)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .FlashSector",
                                  &(Calculation->MemoryLayout.FlashSector)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SlotWWN",
                                  &(Calculation->MemoryLayout.SlotWWN)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CThread",
                                  &(Calculation->MemoryLayout.CThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CTransitions",
                                  &(Calculation->MemoryLayout.CTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CActions",
                                  &(Calculation->MemoryLayout.CActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

#ifdef _DvrArch_1_30_
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IPThread",
                                  &(Calculation->MemoryLayout.IPThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IPTransitions",
                                  &(Calculation->MemoryLayout.IPTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IPActions",
                                  &(Calculation->MemoryLayout.IPActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .PktThread",
                                  &(Calculation->MemoryLayout.PktThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .PktTransitions",
                                  &(Calculation->MemoryLayout.PktTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .PktActions",
                                  &(Calculation->MemoryLayout.PktActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */
#endif /* _DvrArch_1_30_ was defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .TgtThread",
                                  &(Calculation->MemoryLayout.TgtThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .TgtTransitions",
                                  &(Calculation->MemoryLayout.TgtTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .TgtActions",
                                  &(Calculation->MemoryLayout.TgtActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .DevThread",
                                  &(Calculation->MemoryLayout.DevThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .DevTransitions",
                                  &(Calculation->MemoryLayout.DevTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .DevActions",
                                  &(Calculation->MemoryLayout.DevActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CDBThread",
                                  &(Calculation->MemoryLayout.CDBThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CDBTransitions",
                                  &(Calculation->MemoryLayout.CDBTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CDBActions",
                                  &(Calculation->MemoryLayout.CDBActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFThread",
                                  &(Calculation->MemoryLayout.SFThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFTransitions",
                                  &(Calculation->MemoryLayout.SFTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFActions",
                                  &(Calculation->MemoryLayout.SFActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */
}

/*+
Function:  fiMemMapCalculate()

Purpose:   Calculates the memory layout for the entire FC Layer.

Algorithm: This function first calls fiMemMapGetParameters() to
           set the various parameters used in calculating the amount
           and type of memory for each object which is performed in
           fiMemMapSetupLayoutObjects().  Next, the objects are sorted
           by fiMemMapSortLayoutObjects().  Then, the objects are
           allocated by calling fiMemMapLayoutObjects().  Finally, the
           remaining fields in the ToRequest sub-structure are filled
           in by a call to fiMemMapFinishToRequest().  The calculated
           layout is validated by calling fiMemMapValidate.  The results
           of the calculations (i.e. the memory layout for the entire
           FC Layer) are logged by calling fiMemMapDumpCalculation().

Assumes:   Calculation->Input has been initialized to describe the
           memory allocated to the FC Layer (as the arguments to
           fcInitializeChannel() indicate).  In the initial call from
           fcInitializeDriver(), the following values should be used:

                Calculation.Input.initType         = 0;
                Calculation.Input.sysIntsActive    = agFALSE;
                Calculation.Input.cachedMemoryPtr  = agNULL;
                Calculation.Input.cachedMemoryLen  = 0xFFFFFFFF;
                Calculation.Input.dmaMemoryUpper32 = 0;
                Calculation.Input.dmaMemoryLower32 = 0;
                Calculation.Input.dmaMemoryPtr     = agNULL;
                Calculation.Input.dmaMemoryLen     = 0xFFFFFFFF;
                Calculation.Input.nvMemoryLen      = 0xFFFFFFFF;
                Calculation.Input.cardRamUpper32   = 0;
                Calculation.Input.cardRamLower32   = 0;
                Calculation.Input.cardRamLen       = 0xFFFFFFFF;
                Calculation.Input.cardRomUpper32   = 0;
                Calculation.Input.cardRomLower32   = 0;
                Calculation.Input.cardRomLen       = 0xFFFFFFFF;
                Calculation.Input.usecsPerTick     = 0;

Returns:   agTRUE     If the resulting memory layout will fit
                    in the memory specified in Calculation->Input

           agFALSE    If the resulting memory layout will not fit
                    in the memory specified in Calculation->Input
-*/

agBOOLEAN fiMemMapCalculate(
                           agRoot_t              *hpRoot,
                           fiMemMapCalculation_t *Calculation,
                           agBOOLEAN                EnforceDefaults
                         )
{
    agBOOLEAN to_return;

    fiMemMapGetParameters(
                           hpRoot,
                           Calculation,
                           EnforceDefaults
                         );

    fiMemMapSetupLayoutObjects(
                                hpRoot,
                                Calculation
                              );

    fiMemMapSortLayoutObjects(
                               hpRoot,
                               &(Calculation->MemoryLayout)
                             );

    fiMemMapLayoutObjects(
                           hpRoot,
                           Calculation
                         );

    fiMemMapFinishToRequest(
                             hpRoot,
                             Calculation
                           );

    to_return = fiMemMapValidate(
                                  hpRoot,
                                  Calculation
                                );

    fiMemMapDumpCalculation(
                             hpRoot,
                             Calculation,
                             EnforceDefaults,
                             to_return
                           );

    return to_return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\linksvc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/LinkSvc.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/05/00 2:49p  $ (Last Modified)

Purpose:

  This file implements Link Services for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tgtstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/flashsvc.h"
#include "../h/fcmain.h"
#include "../h/cfunc.h"
#include "../h/queue.h"
#include "../h/linksvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tgtstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "flashsvc.h"
#include "fcmain.h"
#include "cfunc.h"
#include "queue.h"
#include "linksvc.h"
#endif  /* _New_Header_file_Layout_ */

void fiLinkSvcInit(
                    agRoot_t *hpRoot
                  )
{
    CThread_t *CThread = CThread_ptr(hpRoot);
    os_bit32   DEVID      = CThread->DEVID;

/*+
Initialize ChanInfo with TachyonTL's Common and Class Parameters
-*/
#ifdef NAME_SERVICES

    if(!(CThread->InitAsNport || CThread->ConnectedToNportOrFPort))
    {
        CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit
            =   (FC_N_Port_Common_Parms_Version_FC_PH_2 << FC_N_Port_Common_Parms_Highest_Version_SHIFT)
              | (FC_N_Port_Common_Parms_Version_4_3 << FC_N_Port_Common_Parms_Lowest_Version_SHIFT)
              | (TachyonTL_BB_Credit << FC_N_Port_Common_Parms_BB_Credit_SHIFT);
    }

    else
    {
#endif  /* NAME_SERVICES */
    CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit
        =   (FC_N_Port_Common_Parms_Version_FC_PH_2 << FC_N_Port_Common_Parms_Highest_Version_SHIFT)
          | (FC_N_Port_Common_Parms_Version_4_3 << FC_N_Port_Common_Parms_Lowest_Version_SHIFT)
          | (TachyonTL_Nport_BB_Credit << FC_N_Port_Common_Parms_BB_Credit_SHIFT);
#ifdef NAME_SERVICES
    }
#endif /* NAME_SERVICES */

    if (CThread_ptr(hpRoot)->DEVID == ChipConfig_DEVID_TachyonXL2)
    {
        if( CThread->InitAsNport)
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management/* MacData  */ 
                  | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);
        }
        else
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management
                  | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);

        }
    }
    else
    {
        if( CThread->InitAsNport)
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management /* MacData */ 
                  | (TachyonTL_Max_Frame_Payload << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);
        }
        else
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management
                  | (TachyonTL_Max_Frame_Payload << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);
        }
    }

    CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        =   (TachyonTL_Total_Concurrent_Sequences << FC_N_Port_Common_Parms_Total_Concurrent_Sequences_SHIFT)
          | TachyonTL_RO_Valid_by_Category;

    CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV = 0;

    CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags = 0;
    CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size               = 0;
    CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit                          = 0;
    CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange                              = 0;

    CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags = 0;
    CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size               = 0;
    CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit                          = 0;
    CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange                              = 0;

    CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
        =   FC_N_Port_Class_Parms_Class_Validity
          | FC_N_Port_Class_Parms_Sequential_Delivery_Requested
          | FC_N_Port_Class_Parms_X_ID_Reassignment_Not_Supported
          | FC_N_Port_Class_Parms_Initial_Process_Associator_Not_Supported;

    if (DEVID == ChipConfig_DEVID_TachyonXL2)
    {
        CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            =   FC_N_Port_Class_Parms_Only_Discard_Supported
              | FC_N_Port_Class_Parms_1_Category_per_Sequence
              | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT);
    }
    else
    {
        CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            =   FC_N_Port_Class_Parms_Only_Discard_Supported
              | FC_N_Port_Class_Parms_1_Category_per_Sequence
              | (TachyonTL_Max_Frame_Payload << FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT);
    }

    CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
        =   (TachyonTL_Total_Concurrent_Sequences << FC_N_Port_Class_Parms_Concurrent_Sequences_SHIFT)
          | (0 << FC_N_Port_Class_Parms_EE_Credit_SHIFT);

    CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange
        = (TachyonTL_Open_Sequences_per_Exchange << FC_N_Port_Class_Parms_Open_Sequences_per_Exchange_SHIFT);
}

os_bit32 fiFillInABTS(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInABTS_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInABTS_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInABTS_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread           = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread         = SFThread->parent.CDB;
    DevThread_t *DevThread         = CDBThread->Device;
    os_bit32        S_ID = 0;
    os_bit32        D_ID;
    X_ID_t       OX_ID;
    X_ID_t       RX_ID;
    os_bit32        ABTS_Frame_Offset = SFThread->SF_CMND_Offset;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ABTS;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;


    D_ID = fiComputeDevThread_D_ID(
                                    DevThread
                                  );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        OX_ID = CDBThread->X_ID | X_ID_Read;
        RX_ID = 0xFFFF;                      /* No way to know what the RX_ID value should be */
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        OX_ID = CDBThread->X_ID | X_ID_Write;

        if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inCardRam)
        {
            RX_ID = (os_bit16) ((osCardRamReadBit32(
                                         hpRoot,
                                         CDBThread->SEST_Offset + hpFieldOffset(
                                                                                 SEST_t,
                                                                                 IWE.MBZ5__RX_ID
                                                                               )
                                       ) & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT);
        }
        else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inDmaMemory */
        {
            RX_ID = (CDBThread->SEST_Ptr->IWE.MBZ5__RX_ID & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT;
        }
    }

/*+
Fill in ABTS Frame (there is no ABTS Frame Payload)
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         (  FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                          | FC_Frame_Header_R_CTL_Lo_BLS_ABTS
                          | D_ID                                           )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         (  FC_Frame_Header_TYPE_BLS
                          | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                          | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                          | FC_Frame_Header_F_CTL_First_Sequence
                          | FC_Frame_Header_F_CTL_End_Sequence
                          | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         (  FC_Frame_Header_SEQ_ID_MASK
                          | FC_Frame_Header_DF_CTL_No_Device_Header )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         (  (OX_ID << FCHS_OX_ID_SHIFT)
                          | (RX_ID << FCHS_RX_ID_SHIFT)         )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );

/*+
Return length of ABTS Frame (there is no ABTS Frame Payload)
-*/

    return sizeof(FCHS_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInABTS_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t    *hpRoot     = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread    = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread  = SFThread->parent.CDB;
    DevThread_t *DevThread  = CDBThread->Device;
    os_bit32        S_ID = 0;
    os_bit32        D_ID;
    X_ID_t       OX_ID;
    X_ID_t       RX_ID;
    FCHS_t      *ABTS_Frame = SFThread->SF_CMND_Ptr;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ABTS;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;


    D_ID = fiComputeDevThread_D_ID(
                                    DevThread
                                  );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        OX_ID = CDBThread->X_ID | X_ID_Read;
        RX_ID = 0xFFFF;                      /* No way to know what the RX_ID value should be */
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        OX_ID = CDBThread->X_ID | X_ID_Write;

        if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inCardRam)
        {
            RX_ID = (os_bit16)((osCardRamReadBit32(
                                         hpRoot,
                                         CDBThread->SEST_Offset + hpFieldOffset(
                                                                                 SEST_t,
                                                                                 IWE.MBZ5__RX_ID
                                                                               )
                                       ) & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT);
        }
        else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inDmaMemory */
        {
            RX_ID = (CDBThread->SEST_Ptr->IWE.MBZ5__RX_ID & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT;
        }
    }

/*+
Fill in ABTS Frame (there is no ABTS Frame Payload)
-*/

    ABTS_Frame->MBZ1                                        = 0;
    ABTS_Frame->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    ABTS_Frame->R_CTL__D_ID                                 =   FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                                                               | FC_Frame_Header_R_CTL_Lo_BLS_ABTS
                                                               | D_ID;
    ABTS_Frame->CS_CTL__S_ID                                = S_ID;
    ABTS_Frame->TYPE__F_CTL                                 =   FC_Frame_Header_TYPE_BLS
                                                               | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                               | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                               | FC_Frame_Header_F_CTL_First_Sequence
                                                               | FC_Frame_Header_F_CTL_End_Sequence
                                                               | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer;
    ABTS_Frame->SEQ_ID__DF_CTL__SEQ_CNT                     =   FC_Frame_Header_SEQ_ID_MASK
                                                               | FC_Frame_Header_DF_CTL_No_Device_Header;
    ABTS_Frame->OX_ID__RX_ID                                =   (OX_ID << FCHS_OX_ID_SHIFT)
                                                               | (RX_ID << FCHS_RX_ID_SHIFT);
    ABTS_Frame->RO                                          = 0;

/*+
Return length of ABTS Frame (there is no ABTS Frame Payload)
-*/

    return sizeof(FCHS_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_ABTS_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_ABTS_Response_OffCard(
                                             SFThread_t          *SFThread,
                                             os_bit32             Frame_Length,
                                             FCHS_t              *FCHS,
                                             FC_BA_ACC_Payload_t *Payload,
                                             os_bit32             Payload_Wrap_Offset,
                                             FC_BA_ACC_Payload_t *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__

    os_bit32           * RawPayLoad    = (os_bit32 *)Payload;

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "%s %p %08X %08X %08X",
                      "ABTS_Response",(char *)agNULL,
                      RawPayLoad,(void *)agNULL,
                      hpSwapBit32( *RawPayLoad ),
                      hpSwapBit32(*(RawPayLoad+1)),
                      hpSwapBit32(*(RawPayLoad+2)),
                      0,0,0,0,0 );


#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInBA_RJT(
                      SFThread_t *SFThread,
                      os_bit32       D_ID,
                      os_bit32       OX_ID__RX_ID,
                      os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                    )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInBA_RJT_OnCard(
                                      SFThread,
                                      D_ID,
                                      OX_ID__RX_ID,
                                      Reason_Code__Reason_Explanation__Vendor_Unique
                                    );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInBA_RJT_OffCard(
                                       SFThread,
                                       D_ID,
                                       OX_ID__RX_ID,
                                       Reason_Code__Reason_Explanation__Vendor_Unique
                                     );
    }
}

os_bit32 fiFillInBA_RJT_OnCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID__RX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread               = CThread_ptr(hpRoot);
    os_bit32        S_ID = 0;
    os_bit32        BA_RJT_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        BA_RJT_Payload_Offset = BA_RJT_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_BA_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

/*+
Fill in BA_RJT Frame Header
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               MBZ1
                                                             ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                             ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               R_CTL__D_ID
                                                             ),
                         (  FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                          | FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT
                          | D_ID                                           )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               CS_CTL__S_ID
                                                             ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               TYPE__F_CTL
                                                             ),
                         (  FC_Frame_Header_TYPE_BLS
                          | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                          | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                          | FC_Frame_Header_F_CTL_Last_Sequence
                          | FC_Frame_Header_F_CTL_End_Sequence)
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               SEQ_ID__DF_CTL__SEQ_CNT
                                                             ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               OX_ID__RX_ID
                                                             ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               RO
                                                             ),
                         0
                       );

/*+
Fill in BA_RJT Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Payload_Offset + hpFieldOffset(
                                                                FC_BA_RJT_Payload_t,
                                                                Reserved__Reason_Code__Reason_Explanation__Vendor_Unique
                                                              ),
                         hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique )
                       );

/*+
Return length of BA_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_BA_RJT_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInBA_RJT_OffCard(
                              SFThread_t *SFThread,
                              os_bit32       D_ID,
                              os_bit32       OX_ID__RX_ID,
                              os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                            )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t            *hpRoot         = SFThread->thread_hdr.hpRoot;
    CThread_t           *CThread        = CThread_ptr(hpRoot);
    os_bit32                S_ID = 0;
    FCHS_t              *BA_RJT_Header  = SFThread->SF_CMND_Ptr;
    FC_BA_RJT_Payload_t *BA_RJT_Payload = (FC_BA_RJT_Payload_t *)((os_bit8 *)BA_RJT_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_BA_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;


    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;



/*+
Fill in BA_RJT Frame Header
-*/

    BA_RJT_Header->MBZ1                                        = 0;
    BA_RJT_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                                  | FCHS_EOF_EOFn
                                                                  | FCHS_CLS;
    BA_RJT_Header->R_CTL__D_ID                                 =   FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                                                                  | FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT
                                                                  | D_ID;
    BA_RJT_Header->CS_CTL__S_ID                                = S_ID;
    BA_RJT_Header->TYPE__F_CTL                                 =   FC_Frame_Header_TYPE_BLS
                                                                  | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                                                  | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                                  | FC_Frame_Header_F_CTL_Last_Sequence
                                                                  | FC_Frame_Header_F_CTL_End_Sequence
                                                                  ;
    BA_RJT_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    BA_RJT_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    BA_RJT_Header->RO                                          = 0;

/*+
Fill in BA_RJT Frame Payload
-*/

    BA_RJT_Payload->Reserved__Reason_Code__Reason_Explanation__Vendor_Unique
        = hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique );

/*+
Return length of BA_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_BA_RJT_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiFillInELSFrameHeader_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       X_ID,
                                    os_bit32       F_CTL_Exchange_Context
                                  )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t  *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread           = CThread_ptr(hpRoot);
    os_bit32      ELS_Header_Offset = SFThread->SF_CMND_Offset;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID = 0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;



    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         R_CTL__D_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         TYPE__F_CTL
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiFillInELSFrameHeader_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       X_ID,
                                     os_bit32       F_CTL_Exchange_Context
                                   )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot       = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread      = CThread_ptr(hpRoot);
    FCHS_t    *ELS_Header   = SFThread->SF_CMND_Ptr;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID =0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(CThread);

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    ELS_Header->MBZ1                                        = 0;
    ELS_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    ELS_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    ELS_Header->CS_CTL__S_ID                                = S_ID;
    ELS_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    ELS_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    ELS_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    ELS_Header->RO                                          = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInLS_RJT(
                      SFThread_t *SFThread,
                      os_bit32       D_ID,
                      os_bit32       OX_ID,
                      os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                    )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInLS_RJT_OnCard(
                                      SFThread,
                                      D_ID,
                                      OX_ID,
                                      Reason_Code__Reason_Explanation__Vendor_Unique
                                    );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInLS_RJT_OffCard(
                                       SFThread,
                                       D_ID,
                                       OX_ID,
                                       Reason_Code__Reason_Explanation__Vendor_Unique
                                     );
    }
}

os_bit32 fiFillInLS_RJT_OnCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    os_bit32        LS_RJT_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        LS_RJT_Payload_Offset = LS_RJT_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LS_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in LS_RJT Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in LS_RJT Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         LS_RJT_Payload_Offset + hpFieldOffset(
                                                                FC_ELS_LS_RJT_Payload_t,
                                                                ELS_Type
                                                              ),
                         hpSwapBit32( FC_ELS_Type_LS_RJT )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         LS_RJT_Payload_Offset + hpFieldOffset(
                                                                FC_ELS_LS_RJT_Payload_t,
                                                                Reason_Code__Reason_Explanation__Vendor_Unique
                                                              ),
                         hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique )
                       );

/*+
Return length of LS_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LS_RJT_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInLS_RJT_OffCard(
                              SFThread_t *SFThread,
                              os_bit32       D_ID,
                              os_bit32       OX_ID,
                              os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                            )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                  *LS_RJT_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_LS_RJT_Payload_t *LS_RJT_Payload = (FC_ELS_LS_RJT_Payload_t *)((os_bit8 *)LS_RJT_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LS_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in LS_RJT Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                  );

/*+
Fill in LS_RJT Frame Payload
-*/

    LS_RJT_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_LS_RJT );

    LS_RJT_Payload->Reason_Code__Reason_Explanation__Vendor_Unique
        = hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique );

/*+
Return length of LS_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LS_RJT_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPLOGI(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPLOGI_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPLOGI_OffCard(
                                      SFThread
                                    );
    }
}

os_bit32 fiFillInPLOGI_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t               *hpRoot                  = SFThread->thread_hdr.hpRoot;
    CThread_t              *CThread                 = CThread_ptr(hpRoot);
    DevThread_t            *DevThread               = SFThread->parent.Device;
    os_bit32                   PLOGI_Header_Offset     = SFThread->SF_CMND_Offset;
    os_bit32                   PLOGI_Payload_Offset    = PLOGI_Header_Offset + sizeof(FCHS_t);
    FC_ELS_PLOGI_Payload_t *PLOGI_Payload_Dummy_Ptr = (FC_ELS_PLOGI_Payload_t *)agNULL;
    os_bit32                   Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    DevThread->DevInfo.Present    = agFALSE;
    DevThread->DevInfo.LoggedIn   = agFALSE;
    DevThread->DevInfo.DeviceType = agDevUnknown;

/*+
Fill in PLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in PLOGI Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_PLOGI )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.E_D_TOV
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  N_Port_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  Node_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_Payload_Dummy_Ptr->Reserved);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  Reserved[Bit8_Index]
                                                                ),
                            0
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  Vendor_Version_Level[Bit8_Index]
                                                                ),
                            0
                          );
    }

/*+
Return length of PLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_PLOGI_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPLOGI_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread       = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t            *DevThread     = SFThread->parent.Device;
    FCHS_t                 *PLOGI_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_PLOGI_Payload_t *PLOGI_Payload = (FC_ELS_PLOGI_Payload_t *)((os_bit8 *)PLOGI_Header + sizeof(FCHS_t));
    os_bit32                Bit8_Index;
    os_bit32              * Payload       = (os_bit32 *)PLOGI_Payload;


    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    DevThread->DevInfo.Present    = agFALSE;
    DevThread->DevInfo.LoggedIn   = agFALSE;
    DevThread->DevInfo.DeviceType = agDevUnknown;

/*+
Fill in PLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in PLOGI Frame Payload
-*/

    PLOGI_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_PLOGI );
    PLOGI_Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit );

    PLOGI_Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size );

    PLOGI_Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category );

    PLOGI_Payload->Common_Service_Parameters.E_D_TOV
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        PLOGI_Payload->N_Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        PLOGI_Payload->Node_Name[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }

    PLOGI_Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange );

    PLOGI_Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange );

    PLOGI_Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_Payload->Reserved);
         Bit8_Index++)
    {
        PLOGI_Payload->Reserved[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        PLOGI_Payload->Vendor_Version_Level[Bit8_Index] = 0;
    }


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload   %X ",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                sizeof(FC_ELS_PLOGI_Payload_t),
                0,0,0,0,0,0,0 );


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload   0 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+0)),
                hpSwapBit32(*(Payload+1)),
                hpSwapBit32(*(Payload+2)),
                hpSwapBit32(*(Payload+3)),
                hpSwapBit32(*(Payload+4)),
                hpSwapBit32(*(Payload+5)),
                hpSwapBit32(*(Payload+6)),
                hpSwapBit32(*(Payload+7)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload   8 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+8)),
                hpSwapBit32(*(Payload+9)),
                hpSwapBit32(*(Payload+10)),
                hpSwapBit32(*(Payload+11)),
                hpSwapBit32(*(Payload+12)),
                hpSwapBit32(*(Payload+13)),
                hpSwapBit32(*(Payload+14)),
                hpSwapBit32(*(Payload+15)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  16 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+16)),
                hpSwapBit32(*(Payload+17)),
                hpSwapBit32(*(Payload+18)),
                hpSwapBit32(*(Payload+19)),
                hpSwapBit32(*(Payload+20)),
                hpSwapBit32(*(Payload+21)),
                hpSwapBit32(*(Payload+22)),
                hpSwapBit32(*(Payload+23)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  24 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+24)),
                hpSwapBit32(*(Payload+25)),
                hpSwapBit32(*(Payload+26)),
                hpSwapBit32(*(Payload+27)),
                hpSwapBit32(*(Payload+28)),
                hpSwapBit32(*(Payload+29)),
                hpSwapBit32(*(Payload+30)),
                hpSwapBit32(*(Payload+31)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  32 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+32)),
                hpSwapBit32(*(Payload+33)),
                hpSwapBit32(*(Payload+34)),
                hpSwapBit32(*(Payload+35)),
                hpSwapBit32(*(Payload+36)),
                hpSwapBit32(*(Payload+37)),
                hpSwapBit32(*(Payload+38)),
                hpSwapBit32(*(Payload+39)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  40 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+40)),
                hpSwapBit32(*(Payload+41)),
                hpSwapBit32(*(Payload+42)),
                hpSwapBit32(*(Payload+43)),
                hpSwapBit32(*(Payload+44)),
                hpSwapBit32(*(Payload+45)),
                hpSwapBit32(*(Payload+46)),
                hpSwapBit32(*(Payload+47)) );

/*+
Return length of PLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_PLOGI_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
os_bit32 fiFillInFARP_REQ_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                 *CThread       = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t               *DevThread     = SFThread->parent.Device;
    FCHS_t                    *FARP_REQ_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_FARP_REQ_Payload_t *FARP_REQ_Payload = (FC_ELS_FARP_REQ_Payload_t *)((os_bit8 *)FARP_REQ_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;
    os_bit32                   S_ID = 0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FARP_REQ;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    DevThread->DevInfo.Present    = agFALSE;
    DevThread->DevInfo.LoggedIn   = agFALSE;
    DevThread->DevInfo.DeviceType = agDevUnknown;

/*+
Fill in FARP_REQ Frame Header
-*/
    S_ID = fiComputeCThread_S_ID( CThread );
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    /* (S_ID > 0xff ? FC_Well_Known_Port_ID_Broadcast_Alias_ID : 0xff), */
				    S_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in FARP_REQ Frame Payload
-*/

    FARP_REQ_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_FARP_REQ );

    FARP_REQ_Payload->Match_Code_Requester_Port_ID =  hpSwapBit32( S_ID |
            FC_ELS_FARP_REQ_Match_Code_Points_Match_WW_PN << FC_ELS_FARP_REQ_Match_Code_Points_SHIFT);

    FARP_REQ_Payload->Flags_Responder_Port_ID = hpSwapBit32(
            (FC_ELS_FARP_REQ_Responder_Flags_Init_Plogi |
            FC_ELS_FARP_REQ_Responder_Flags_Init_Reply) << FC_ELS_FARP_REQ_Responder_Flags_SHIFT);

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        FARP_REQ_Payload->Port_Name_of_Requester[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
        FARP_REQ_Payload->Port_Name_of_Responder[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        FARP_REQ_Payload->Node_Name_of_Requester[Bit8_Index] = 0;
        FARP_REQ_Payload->Node_Name_of_Responder[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < 16;
         Bit8_Index++)
    {
        FARP_REQ_Payload->IP_Address_of_Requester[Bit8_Index] = 0;
        FARP_REQ_Payload->IP_Address_of_Responder[Bit8_Index] = 0;
    }

/*+
Return length of FARP_REQ Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FARP_REQ_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInFARP_REPLY_OffCard(
                                     SFThread_t *SFThread
                                   )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread         = CThread_ptr(SFThread->thread_hdr.hpRoot);
    TgtThread_t                *TgtThread       = SFThread->parent.Target;
    FCHS_t                     *TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
    FC_ELS_FARP_REQ_Payload_t  *TgtCmnd_Payload = (FC_ELS_FARP_REQ_Payload_t *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));
    FCHS_t                     *REPLY_Header    = SFThread->SF_CMND_Ptr;
    FC_ELS_FARP_REPLY_Payload_t *REPLY_Payload  = (FC_ELS_FARP_REPLY_Payload_t *)((os_bit8 *)REPLY_Header + sizeof(FCHS_t));
    os_bit32                    Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FARP_REPLY;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in FARP_REPLY Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    TgtCmnd_FCHS->CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK,
                                    (TgtCmnd_FCHS->OX_ID__RX_ID & FC_Frame_Header_OX_ID_MASK)
				            >> FC_Frame_Header_OX_ID_SHIFT,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence
                                  );

/*+
Fill in FARP_REPLY Frame Payload
-*/

    REPLY_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_FARP_REPLY );

    REPLY_Payload->Match_Code_Requester_Port_ID = TgtCmnd_Payload->Match_Code_Requester_Port_ID;

    REPLY_Payload->Flags_Responder_Port_ID =   TgtCmnd_Payload->Flags_Responder_Port_ID
	                                          & FC_ELS_FARP_REQ_Responder_Flags_MASK
                                                  | hpSwapBit32(fiComputeCThread_S_ID(CThread));
    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        REPLY_Payload->Port_Name_of_Requester[Bit8_Index] = TgtCmnd_Payload->Port_Name_of_Requester[Bit8_Index];
        REPLY_Payload->Port_Name_of_Responder[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        REPLY_Payload->Node_Name_of_Requester[Bit8_Index] = 0;
        REPLY_Payload->Node_Name_of_Responder[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < 16;
         Bit8_Index++)
    {
        REPLY_Payload->IP_Address_of_Requester[Bit8_Index] = 0;
        REPLY_Payload->IP_Address_of_Responder[Bit8_Index] = 0;
    }
/*+
Return length of FARP_REPLY Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FARP_REPLY_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}
#endif /* _DvrArch_1_30_ was defined */

void fiLinkSvcProcess_PLOGI_Response_OnCard(
                                             SFThread_t *SFThread,
                                             os_bit32       Frame_Length,
                                             os_bit32       Offset_to_FCHS,
                                             os_bit32       Offset_to_Payload,
                                             os_bit32       Payload_Wrap_Offset,
                                             os_bit32       Offset_to_Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t      *hpRoot     = SFThread->thread_hdr.hpRoot;
    agFCDevInfo_t *DevInfo    = &(SFThread->parent.Device->DevInfo);
    os_bit32          Bit8_Index;

    DevInfo->Present = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_PLOGI_Payload_t,
                                                                        N_Port_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_PLOGI_Payload_t,
                                                                                N_Port_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Node_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_PLOGI_Payload_t,
                                                                        Node_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_PLOGI_Payload_t,
                                                                                Node_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_PLOGI_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                            )
{
#ifndef __MemMap_Force_On_Card__
    agFCDevInfo_t *DevInfo    = &(SFThread->parent.Device->DevInfo);
    os_bit32          Bit8_Index;

    DevInfo->Present = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload->Common_Service_Parameters.E_D_TOV);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.E_D_TOV);
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->PortWWN[Bit8_Index] = Payload->N_Port_Name[Bit8_Index];
        }
        else
        {
            DevInfo->PortWWN[Bit8_Index] = Payload_Wrapped->N_Port_Name[Bit8_Index];
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Node_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->NodeWWN[Bit8_Index] = Payload->Node_Name[Bit8_Index];
        }
        else
        {
            DevInfo->NodeWWN[Bit8_Index] = Payload_Wrapped->Node_Name[Bit8_Index];
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Open_Sequences_per_Exchange);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
#ifdef __TACHYON_XL_CLASS2

        /* Channel Info sets the validity bits based on the FLOGI with the fabric. We need to make sure the device or the fabric does FLOGI */
        if (CThread->FlogiSucceeded)
        {
            DevThread->GoingClass2 = 
                (DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags & FC_N_Port_Class_Parms_Class_Validity &&
                 CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags & FC_F_Port_Class_Parms_Class_Validity) 
                                    ? agTRUE : agFALSE; 
        }
        else
        {
            DevThread->GoingClass2 =
                (DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags & FC_N_Port_Class_Parms_Class_Validity) 
                                    ? agTRUE : agFALSE; 
                
        } 
#endif

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Open_Sequences_per_Exchange);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Open_Sequences_per_Exchange);
    }

    SFThread->parent.Device->OtherAgilentHBA = agFALSE;

    if( Payload->N_Port_Name[0] == fiFlash_Card_WWN_0)
    { 
        if( Payload->N_Port_Name[1] == fiFlash_Card_WWN_1_HP)
        { 
            if( Payload->N_Port_Name[2] == fiFlash_Card_WWN_2_HP)
            { 
                if( Payload->N_Port_Name[3] == fiFlash_Card_WWN_3_HP)
                { 
                    SFThread->parent.Device->OtherAgilentHBA = agTRUE;
                }
            }
        }
        if( Payload->N_Port_Name[1] == fiFlash_Card_WWN_1_Agilent)
        { 
            if( Payload->N_Port_Name[2] == fiFlash_Card_WWN_2_Agilent)
            { 
                if( Payload->N_Port_Name[3] == fiFlash_Card_WWN_2_Agilent)
                { 
                    SFThread->parent.Device->OtherAgilentHBA = agTRUE;
                }
            }
        }

        if( Payload->N_Port_Name[1] == fiFlash_Card_WWN_1_Adaptec)
        { 
            if( Payload->N_Port_Name[2] == fiFlash_Card_WWN_2_Adaptec)
            { 
                if( Payload->N_Port_Name[3] == fiFlash_Card_WWN_3_Adaptec)
                { 
                    SFThread->parent.Device->OtherAgilentHBA = agTRUE;
                }
            }
        }
    }

    if( SFThread->parent.Device->OtherAgilentHBA )
    {
        fiLogString(SFThread->thread_hdr.hpRoot,
                        "%s Found %X",
                        "OtherAgilentHBA",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(SFThread->parent.Device),
                        0,0,0,0,0,0,0);
/*
        fiLogString(SFThread->thread_hdr.hpRoot,
                        "%s %02X %02X %02X %02X %02X %02X %02X %02X",
                        "Self",(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[0]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[1]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[2]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[3]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[4]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[5]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[6]),
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[7])
                        );
*/
        fiLogString(SFThread->thread_hdr.hpRoot,
                        "%s %02X %02X %02X %02X %02X %02X %02X %02X",
                        "Pay ",(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        (os_bit32)Payload->N_Port_Name[0], 
                        (os_bit32)Payload->N_Port_Name[1], 
                        (os_bit32)Payload->N_Port_Name[2], 
                        (os_bit32)Payload->N_Port_Name[3], 
                        (os_bit32)Payload->N_Port_Name[4], 
                        (os_bit32)Payload->N_Port_Name[5], 
                        (os_bit32)Payload->N_Port_Name[6], 
                        (os_bit32)Payload->N_Port_Name[7] 
                        );

    }

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Plogi Response Credit %08X BB %08X N %08X EDTOV %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit,
                DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size,
                DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category,
                DevInfo->N_Port_Common_Parms.E_D_TOV,
                0,0,0,0 );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Response Credit %08X BB %08X N %08X EDTOV %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.E_D_TOV,
                0,0,0,0 );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Plogi Response Class 3  %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags,
                DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size,
                DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit,
                DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange,
                0,0,0,0 );
 
    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Response Class 3  %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange,
                0,0,0,0 );


#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiLinkSvcProcess_PLOGI_Request_OnCard(
                                             agRoot_t  *hpRoot,
                                             X_ID_t     OX_ID,
                                             os_bit32      Frame_Length,
                                             os_bit32      Offset_to_FCHS,
                                             os_bit32      Offset_to_Payload,
                                             os_bit32      Payload_Wrap_Offset,
                                             os_bit32      Offset_to_Payload_Wrapped,
                                             fi_thread__t **Thread_to_return
                                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_X_ID_Max         = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    os_bit32                       D_ID;
    os_bit32                       S_ID;
    os_bit32                       Bit8_Index;

    D_ID = (osCardRamReadBit32(
                                hpRoot,
                                Offset_to_FCHS + hpFieldOffset(
                                                                FCHS_t,
                                                                R_CTL__D_ID
                                                              )
                              ) & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;

    S_ID = (osCardRamReadBit32(
                                hpRoot,
                                Offset_to_FCHS + hpFieldOffset(
                                                                FCHS_t,
                                                                CS_CTL__S_ID
                                                              )
                              ) & FCHS_S_ID_MASK) >> FCHS_S_ID_SHIFT;

    if (D_ID != S_ID)
    {
        /* Some other port is trying to PLOGI into us */

        *Thread_to_return = (fi_thread__t *)agNULL;

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvc_Cmd_Status_PLOGI_From_Other [S_ID = %06X] [D_ID = %06X]",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          S_ID,
                          D_ID,
                          0,0,0,0,0,0
                        );

        fiLinkSvcProcess_TargetRequest_OnCard(
                                               hpRoot,
                                               Frame_Length,
                                               Offset_to_FCHS,
                                               Offset_to_Payload,
                                               Payload_Wrap_Offset,
                                               Offset_to_Payload_Wrapped
                                             );

        return fiLinkSvc_Cmd_Status_PLOGI_From_Other;
    }

    /* Some port with our Port_ID is trying to PLOGI into us - is it us? */

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index]
                    != osCardRamReadBit8(
                                          hpRoot,
                                          Offset_to_Payload + hpFieldOffset(
                                                                             FC_ELS_PLOGI_Payload_t,
                                                                             N_Port_Name[Bit8_Index]
                                                                           )
                                        ))
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
        else
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index]
                    != osCardRamReadBit8(
                                          hpRoot,
                                          Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                     FC_ELS_PLOGI_Payload_t,
                                                                                     N_Port_Name[Bit8_Index]
                                                                                   )
                                        ))
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
    }

    /* PortWWN's matched, so this must be our own PLOGI attempt into ourself */

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_PLOGI_Request_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLogConsoleLevel,
                      "fiLinkSvc_Cmd_Status_PLOGI_From_Self",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    *Thread_to_return = (fi_thread__t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                     + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    return fiLinkSvc_Cmd_Status_PLOGI_From_Self;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiLinkSvcProcess_PLOGI_Request_OffCard(
                                              agRoot_t                *hpRoot,
                                              X_ID_t                   OX_ID,
                                              os_bit32                    Frame_Length,
                                              FCHS_t                  *FCHS,
                                              FC_ELS_PLOGI_Payload_t  *Payload,
                                              os_bit32                    Payload_Wrap_Offset,
                                              FC_ELS_PLOGI_Payload_t  *Payload_Wrapped,
                                              fi_thread__t               **Thread_to_return
                                            )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_X_ID_Max         = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    os_bit32                       D_ID                      = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;
    os_bit32                       S_ID                      = (FCHS->CS_CTL__S_ID & FCHS_S_ID_MASK) >> FCHS_S_ID_SHIFT;
    os_bit32                       Bit8_Index;

    if (D_ID != S_ID)
    {
        /* Some other port is trying to PLOGI into us */

        *Thread_to_return = (fi_thread__t *)agNULL;

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvc_Cmd_Status_PLOGI_From_Other S_ID = %06X D_ID = %06X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          S_ID,
                          D_ID,
                          0,0,0,0,0,0
                        );

        fiLinkSvcProcess_TargetRequest_OffCard(
                                                hpRoot,
                                                Frame_Length,
                                                FCHS,
                                                (void *)Payload,
                                                Payload_Wrap_Offset,
                                                (void *)Payload_Wrapped
                                              );

        return fiLinkSvc_Cmd_Status_PLOGI_From_Other;
    }

    /* Some port with our Port_ID is trying to PLOGI into us - is it us? */

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload->N_Port_Name[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
        else
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload_Wrapped->N_Port_Name[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
    }

    /* PortWWN's matched, so this must be our own PLOGI attempt into ourself */

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvcProcess_PLOGI_Request_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLogConsoleLevel + 0xb,
                      "fiLinkSvc_Cmd_Status_PLOGI_From_Self",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    *Thread_to_return = (fi_thread__t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                     + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    return fiLinkSvc_Cmd_Status_PLOGI_From_Self;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
os_bit32 fiLinkSvcProcess_FARP_Request_OffCard(
                                                agRoot_t                    *hpRoot,
                                                X_ID_t                       OX_ID,
                                                os_bit32                     Frame_Length,
                                                FCHS_t                      *FCHS,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload,
                                                os_bit32                     Payload_Wrap_Offset,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload_Wrapped,
                                                fi_thread__t               **Thread_to_return
                                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                    SFThread_X_ID_Max         = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    os_bit32                    S_ID                      = (FCHS->CS_CTL__S_ID & FCHS_S_ID_MASK) >> FCHS_S_ID_SHIFT;
    os_bit32                    D_ID                      = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;
    os_bit32                    Bit8_Index;

    if (S_ID != (os_bit32) fiComputeCThread_S_ID(CThread))
    {
        /* Some other port is trying to FARP to us */

        *Thread_to_return = (fi_thread__t *)agNULL;

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvc_Cmd_Status_FARP_From_Other S_ID = %06X D_ID = %06X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          S_ID,
                          D_ID,
                          0,0,0,0,0,0
                        );

        fiLinkSvcProcess_TargetRequest_OffCard(
                                                hpRoot,
                                                Frame_Length,
                                                FCHS,
                                                (void *)Payload,
                                                Payload_Wrap_Offset,
                                                (void *)Payload_Wrapped
                                              );

        return fiLinkSvc_Cmd_Status_FARP_From_Other;
    }

    /* Some port with our Port_ID is trying to FARP to us - is it us? */

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_FARP_REQ_Payload_t,Port_Name_of_Requester[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload->Port_Name_of_Requester[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_FARP_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_FARP_From_Twin;
            }
        }
        else
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload_Wrapped->Port_Name_of_Requester[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_FARP_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_FARP_From_Twin;
            }
        }
    }

    /* PortWWN's matched, so this must be our own FARP attempt to ourselves */

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvcProcess_FARP_Request_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLogConsoleLevel + 0xb,
                      "fiLinkSvc_Cmd_Status_FARP_From_Self",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    *Thread_to_return = (fi_thread__t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                     + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    return fiLinkSvc_Cmd_Status_FARP_From_Self;
#endif /* __MemMap_Force_On_Card__ was not defined */
}
#endif /* _DvrArch_1_30_ was defined */

os_bit32 fiFillInPLOGI_ACC(
                         SFThread_t *SFThread,
                         os_bit32       D_ID,
                         os_bit32       OX_ID
                       )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPLOGI_ACC_OnCard(
                                         SFThread,
                                         D_ID,
                                         OX_ID
                                       );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPLOGI_ACC_OffCard(
                                          SFThread,
                                          D_ID,
                                          OX_ID
                                        );
    }
}

os_bit32 fiFillInPLOGI_ACC_OnCard(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t                   *hpRoot                      = SFThread->thread_hdr.hpRoot;
    CThread_t                  *CThread                     = CThread_ptr(hpRoot);
    os_bit32                    PLOGI_ACC_Header_Offset     = SFThread->SF_CMND_Offset;
    os_bit32                    PLOGI_ACC_Payload_Offset    = PLOGI_ACC_Header_Offset + sizeof(FCHS_t);
    FC_ELS_ACC_PLOGI_Payload_t *PLOGI_ACC_Payload_Dummy_Ptr = (FC_ELS_ACC_PLOGI_Payload_t *)agNULL;
    os_bit32                    Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PLOGI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in PLOGI_ACC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   ELS_Type
                                                                 ),
                         hpSwapBit32( FC_ELS_Type_ACC )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.E_D_TOV
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      N_Port_Name[Bit8_Index]
                                                                    ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      Node_Name[Bit8_Index]
                                                                    ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_ACC_Payload_Dummy_Ptr->Reserved);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      Reserved[Bit8_Index]
                                                                    ),
                            0
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      Vendor_Version_Level[Bit8_Index]
                                                                    ),
                            0
                          );
    }

/*+
Return length of PLOGI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ACC_PLOGI_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPLOGI_ACC_OffCard(
                                 SFThread_t *SFThread,
                                 os_bit32       D_ID,
                                 os_bit32       OX_ID
                               )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread           = CThread_ptr(SFThread->thread_hdr.hpRoot);
    FCHS_t                     *PLOGI_ACC_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_ACC_PLOGI_Payload_t *PLOGI_ACC_Payload = (FC_ELS_ACC_PLOGI_Payload_t *)((os_bit8 *)PLOGI_ACC_Header + sizeof(FCHS_t));
    os_bit32                       Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PLOGI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence
                                  );

/*+
Fill in PLOGI_ACC Frame Payload
-*/

    PLOGI_ACC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_ACC );

    PLOGI_ACC_Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit );

    PLOGI_ACC_Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size );

    PLOGI_ACC_Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category );

    PLOGI_ACC_Payload->Common_Service_Parameters.E_D_TOV
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->N_Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->Node_Name[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_ACC_Payload->Reserved);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->Reserved[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->Vendor_Version_Level[Bit8_Index] = 0;
    }

/*+
Return length of PLOGI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ACC_PLOGI_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInFLOGI(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInFLOGI_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInFLOGI_OffCard(
                                      SFThread
                                    );
    }
}

os_bit32 fiFillInFLOGI_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t               *hpRoot                  = SFThread->thread_hdr.hpRoot;
    CThread_t              *CThread                 = CThread_ptr(hpRoot);
    os_bit32                   FLOGI_Header_Offset     = SFThread->SF_CMND_Offset;
    os_bit32                   FLOGI_Payload_Offset    = FLOGI_Header_Offset + sizeof(FCHS_t);
    FC_ELS_FLOGI_Payload_t *FLOGI_Payload_Dummy_Ptr = (FC_ELS_FLOGI_Payload_t *)agNULL;
    os_bit32                   Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in FLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   FC_Well_Known_Port_ID_Fabric_F_Port,
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in FLOGI Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_FLOGI )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category )
                       );

    /*McData switch enforces the parameter - reserved for NPORT */
    if(CThread->InitAsNport)
    {
        osCardRamWriteBit32(
                             hpRoot,
                             FLOGI_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_FLOGI_Payload_t,
                                                                   Common_Service_Parameters.E_D_TOV
                                                                 ),
                             0
                           );
    }
    else
    {
        osCardRamWriteBit32(
                             hpRoot,
                             FLOGI_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_FLOGI_Payload_t,
                                                                   Common_Service_Parameters.E_D_TOV
                                                                 ),
                             hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV )
                           );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  N_Port_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  Node_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FLOGI_Payload_Dummy_Ptr->Reserved);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  Reserved[Bit8_Index]
                                                                ),
                            0
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  Vendor_Version_Level[Bit8_Index]
                                                                ),
                            0
                          );
    }

/*+
Return length of FLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FLOGI_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInFLOGI_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread       = CThread_ptr(SFThread->thread_hdr.hpRoot);
    FCHS_t                 *FLOGI_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_FLOGI_Payload_t *FLOGI_Payload = (FC_ELS_FLOGI_Payload_t *)((os_bit8 *)FLOGI_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;

    os_bit32               * Payload= (os_bit32 *)FLOGI_Payload;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in FLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    FC_Well_Known_Port_ID_Fabric_F_Port,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                        LinkSvcLogConsoleLevel,
                        "FCHS %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FLOGI_Header->MBZ1,
                        FLOGI_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FLOGI_Header->R_CTL__D_ID,
                        FLOGI_Header->CS_CTL__S_ID,
                        FLOGI_Header->TYPE__F_CTL,
                        FLOGI_Header->SEQ_ID__DF_CTL__SEQ_CNT,
                        FLOGI_Header->OX_ID__RX_ID,
                        FLOGI_Header->RO );

/*+
Fill in FLOGI Frame Payload
-*/

    FLOGI_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_FLOGI );

    FLOGI_Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit );

    FLOGI_Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size );

    FLOGI_Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category );

    /*McData switch enforces the parameter - reserved for NPORT */
    if(CThread->InitAsNport)
    {
        FLOGI_Payload->Common_Service_Parameters.E_D_TOV =0;
    }
    else
    {
        FLOGI_Payload->Common_Service_Parameters.E_D_TOV
            = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        FLOGI_Payload->N_Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        FLOGI_Payload->Node_Name[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }

    FLOGI_Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    FLOGI_Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size );

    FLOGI_Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit );

    FLOGI_Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange );

    FLOGI_Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    FLOGI_Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size );

    FLOGI_Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit );

    FLOGI_Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange );

    FLOGI_Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    FLOGI_Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size );

    FLOGI_Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit );

    FLOGI_Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FLOGI_Payload->Reserved);
         Bit8_Index++)
    {
        FLOGI_Payload->Reserved[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        FLOGI_Payload->Vendor_Version_Level[Bit8_Index] = 0;
    }

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload   %X ",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                sizeof(FC_ELS_FLOGI_Payload_t),
                0,0,0,0,0,0,0 );


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload   0 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+0)),
                hpSwapBit32(*(Payload+1)),
                hpSwapBit32(*(Payload+2)),
                hpSwapBit32(*(Payload+3)),
                hpSwapBit32(*(Payload+4)),
                hpSwapBit32(*(Payload+5)),
                hpSwapBit32(*(Payload+6)),
                hpSwapBit32(*(Payload+7)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload   8 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+8)),
                hpSwapBit32(*(Payload+9)),
                hpSwapBit32(*(Payload+10)),
                hpSwapBit32(*(Payload+11)),
                hpSwapBit32(*(Payload+12)),
                hpSwapBit32(*(Payload+13)),
                hpSwapBit32(*(Payload+14)),
                hpSwapBit32(*(Payload+15)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  16 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+16)),
                hpSwapBit32(*(Payload+17)),
                hpSwapBit32(*(Payload+18)),
                hpSwapBit32(*(Payload+19)),
                hpSwapBit32(*(Payload+20)),
                hpSwapBit32(*(Payload+21)),
                hpSwapBit32(*(Payload+22)),
                hpSwapBit32(*(Payload+23)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  24 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+24)),
                hpSwapBit32(*(Payload+25)),
                hpSwapBit32(*(Payload+26)),
                hpSwapBit32(*(Payload+27)),
                hpSwapBit32(*(Payload+28)),
                hpSwapBit32(*(Payload+29)),
                hpSwapBit32(*(Payload+30)),
                hpSwapBit32(*(Payload+31)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  32 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+32)),
                hpSwapBit32(*(Payload+33)),
                hpSwapBit32(*(Payload+34)),
                hpSwapBit32(*(Payload+35)),
                hpSwapBit32(*(Payload+36)),
                hpSwapBit32(*(Payload+37)),
                hpSwapBit32(*(Payload+38)),
                hpSwapBit32(*(Payload+39)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  40 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+40)),
                hpSwapBit32(*(Payload+41)),
                hpSwapBit32(*(Payload+42)),
                hpSwapBit32(*(Payload+43)),
                hpSwapBit32(*(Payload+44)),
                hpSwapBit32(*(Payload+45)),
                hpSwapBit32(*(Payload+46)),
                hpSwapBit32(*(Payload+47)) );


/*+
Return length of FLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FLOGI_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_FLOGI_Response_OnCard(
                                             SFThread_t *SFThread,
                                             os_bit32       Frame_Length,
                                             os_bit32       Offset_to_FCHS,
                                             os_bit32       Offset_to_Payload,
                                             os_bit32       Payload_Wrap_Offset,
                                             os_bit32       Offset_to_Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t       *hpRoot     = SFThread->thread_hdr.hpRoot;
    CThread_t      *CThread    = CThread_ptr(hpRoot);
    agFCChanInfo_t *SelfInfo   = &(CThread->ChanInfo);
    os_bit32           My_ID;
    os_bit32           Bit8_Index;

/*+
Extract Full (24-bit) My_ID from D_ID of Frame Header and update My_ID register in TachyonTL
-*/

    My_ID = (osCardRamReadBit32(
                                 hpRoot,
                                 ( Offset_to_FCHS
                                   + hpFieldOffset(
                                                    FCHS_t,
                                                    R_CTL__D_ID
                                                  ) )
                               ) & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, My_ID );
/*
    if(D_ID  != 0 && D_ID != 0xff)
    {

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, D_ID);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                ( D_ID <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));


        Port_ID.Struct_Form.Domain = 0;
        Port_ID.Struct_Form.Area   = 0;
        Port_ID.Struct_Form.AL_PA  = (os_bit8)D_ID;

        pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

        pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                    Port_ID.Struct_Form.Domain,
                                                    Port_ID.Struct_Form.Area,
                                                    Port_ID.Struct_Form.AL_PA,
                                                   (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

        fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
        fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

        pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)D_ID;
    }

*/
    SelfInfo->CurrentAddress.reserved = 0;
    SelfInfo->CurrentAddress.Domain = (My_ID & 0x00FF0000) >> 16;
    SelfInfo->CurrentAddress.Area   = (My_ID & 0x0000FF00) >>  8;
    SelfInfo->CurrentAddress.AL_PA  = (My_ID & 0x000000FF) >>  0;

/*+
Process FLOGI ACC Payload
-*/

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.R_A_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.R_A_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.R_A_TOV
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_F_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,F_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->F_Port_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_FLOGI_Payload_t,
                                                                        F_Port_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            CThread->F_Port_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_FLOGI_Payload_t,
                                                                                F_Port_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Fabric_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Fabric_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->Fabric_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_FLOGI_Payload_t,
                                                                        Fabric_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            CThread->Fabric_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_FLOGI_Payload_t,
                                                                                Fabric_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_FLOGI_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_ELS_ACC_FLOGI_Payload_t *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_ELS_ACC_FLOGI_Payload_t *Payload_Wrapped
                                            )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t       *hpRoot      = SFThread->thread_hdr.hpRoot;
    CThread_t      *CThread     = CThread_ptr(hpRoot);
    agFCChanInfo_t *SelfInfo    = &(CThread->ChanInfo);
	DevThread_t   * pDevThread  = CThread->DeviceSelf;
    os_bit32        My_ID;
    os_bit32        Bit8_Index;
    os_bit32        BB_Credit   = 0;
    os_bit32      * pPayload    = (os_bit32 *)Payload;


/*+
Extract Full (24-bit) My_ID from D_ID of Frame Header and update My_ID register in TachyonTL
-*/

    My_ID = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, My_ID );

    SelfInfo->CurrentAddress.Domain = (My_ID & 0x00FF0000) >> 16;
    SelfInfo->CurrentAddress.Area   = (My_ID & 0x0000FF00) >>  8;
    SelfInfo->CurrentAddress.AL_PA  = (My_ID & 0x000000FF) >>  0;

	pDevThread->DevInfo.CurrentAddress.Domain = SelfInfo->CurrentAddress.Domain;
	pDevThread->DevInfo.CurrentAddress.Area   = SelfInfo->CurrentAddress.Area;
	pDevThread->DevInfo.CurrentAddress.AL_PA  = SelfInfo->CurrentAddress.AL_PA;


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "SELF %p Setting Aquired ID My_ID %08X ComputeSID %08X Self %02X%02X%02X" ,
                (char *)agNULL,(char *)agNULL,
                CThread->DeviceSelf,(void *)agNULL,
                My_ID,
                fiComputeCThread_S_ID(CThread),
                pDevThread->DevInfo.CurrentAddress.Domain,
                pDevThread->DevInfo.CurrentAddress.Area,
                pDevThread->DevInfo.CurrentAddress.AL_PA ,
                0,0,0 );



/*+
Process FLOGI ACC Payload
-*/

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
    else
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }
    else
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.R_A_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(Payload->Common_Service_Parameters.R_A_TOV);
    }
    else
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.R_A_TOV);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload->Common_Service_Parameters.E_D_TOV);
    }
    else
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.E_D_TOV);
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_F_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,F_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->F_Port_Name[Bit8_Index] = Payload->F_Port_Name[Bit8_Index];
        }
        else
        {
            CThread->F_Port_Name[Bit8_Index] = Payload_Wrapped->F_Port_Name[Bit8_Index];
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Fabric_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->Fabric_Name[Bit8_Index] = Payload->Fabric_Name[Bit8_Index];
        }
        else
        {
            CThread->Fabric_Name[Bit8_Index] = Payload_Wrapped->Fabric_Name[Bit8_Index];
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Class_Validity__Service_Options);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Class_Validity__Service_Options);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Reserved_1);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Reserved_1);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Reserved_2);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Reserved_2);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(Payload->Class_1_Service_Parameters.CR_TOV);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.CR_TOV);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Class_Validity__Service_Options);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Class_Validity__Service_Options);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Reserved_1);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Reserved_1);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Reserved_2);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Reserved_2);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(Payload->Class_2_Service_Parameters.CR_TOV);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.CR_TOV);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Class_Validity__Service_Options);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Class_Validity__Service_Options);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Reserved_1);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Reserved_1);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Reserved_2);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Reserved_2);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(Payload->Class_3_Service_Parameters.CR_TOV);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.CR_TOV);
    }
    /* Pull out switch credit */
    BB_Credit = CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit & FC_N_Port_Common_Parms_BB_Credit_MASK;
    /* Use lessor of TL credit and switch credit */
    BB_Credit = TachyonTL_Nport_BB_Credit < BB_Credit  ?  TachyonTL_Nport_BB_Credit : BB_Credit;
    CThread->AquiredCredit_Shifted = BB_CREDIT_SHIFTED( BB_Credit );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Setting Aquired credit Flogi %X  Calc %X Shifted %X" ,
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit,
                BB_Credit,
                CThread->AquiredCredit_Shifted,
                0,0,0,0,0 );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload   0 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+0)),
                hpSwapBit32(*(pPayload+1)),
                hpSwapBit32(*(pPayload+2)),
                hpSwapBit32(*(pPayload+3)),
                hpSwapBit32(*(pPayload+4)),
                hpSwapBit32(*(pPayload+5)),
                hpSwapBit32(*(pPayload+6)),
                hpSwapBit32(*(pPayload+7)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload   8 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+8)),
                hpSwapBit32(*(pPayload+9)),
                hpSwapBit32(*(pPayload+10)),
                hpSwapBit32(*(pPayload+11)),
                hpSwapBit32(*(pPayload+12)),
                hpSwapBit32(*(pPayload+13)),
                hpSwapBit32(*(pPayload+14)),
                hpSwapBit32(*(pPayload+15)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  16 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+16)),
                hpSwapBit32(*(pPayload+17)),
                hpSwapBit32(*(pPayload+18)),
                hpSwapBit32(*(pPayload+19)),
                hpSwapBit32(*(pPayload+20)),
                hpSwapBit32(*(pPayload+21)),
                hpSwapBit32(*(pPayload+22)),
                hpSwapBit32(*(pPayload+23)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  24 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+24)),
                hpSwapBit32(*(pPayload+25)),
                hpSwapBit32(*(pPayload+26)),
                hpSwapBit32(*(pPayload+27)),
                hpSwapBit32(*(pPayload+28)),
                hpSwapBit32(*(pPayload+29)),
                hpSwapBit32(*(pPayload+30)),
                hpSwapBit32(*(pPayload+31)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  32 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+32)),
                hpSwapBit32(*(pPayload+33)),
                hpSwapBit32(*(pPayload+34)),
                hpSwapBit32(*(pPayload+35)),
                hpSwapBit32(*(pPayload+36)),
                hpSwapBit32(*(pPayload+37)),
                hpSwapBit32(*(pPayload+38)),
                hpSwapBit32(*(pPayload+39)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  40 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+40)),
                hpSwapBit32(*(pPayload+41)),
                hpSwapBit32(*(pPayload+42)),
                hpSwapBit32(*(pPayload+43)),
                hpSwapBit32(*(pPayload+44)),
                hpSwapBit32(*(pPayload+45)),
                hpSwapBit32(*(pPayload+46)),
                hpSwapBit32(*(pPayload+47)) );


#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInLOGO(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInLOGO_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInLOGO_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInLOGO_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        LOGO_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        LOGO_Payload_Offset = LOGO_Header_Offset + sizeof(FCHS_t);
    os_bit32        Bit8_Index;
    os_bit32        S_ID=0;
    os_bit32        D_ID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LOGO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in LOGO Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in LOGO Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         LOGO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_LOGO_Payload_t,
                                                              ELS_Type
                                                            ),
                         hpSwapBit32( FC_ELS_Type_LOGO )
                       );

    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         LOGO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_LOGO_Payload_t,
                                                              N_Port_Identifier
                                                            ),
                         hpSwapBit32(S_ID)
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            LOGO_Payload_Offset + hpFieldOffset(
                                                                 FC_ELS_LOGO_Payload_t,
                                                                 Port_Name[Bit8_Index]
                                                               ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

/*+
Return length of LOGO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LOGO_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInLOGO_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t           *DevThread    = SFThread->parent.Device;
    FCHS_t                *LOGO_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_LOGO_Payload_t *LOGO_Payload = (FC_ELS_LOGO_Payload_t *)((os_bit8 *)LOGO_Header + sizeof(FCHS_t));
    os_bit32                  Bit8_Index;
    os_bit32                  S_ID=0;
    os_bit32                  D_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LOGO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in LOGO Frame Header
-*/

    D_ID =  fiComputeDevThread_D_ID( DevThread); 
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in LOGO Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    
    LOGO_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_LOGO );

    LOGO_Payload->N_Port_Identifier
        = hpSwapBit32(S_ID);

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Port_Name_t);
         Bit8_Index++)
    {
        LOGO_Payload->Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

/*+
Return length of LOGO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LOGO_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_LOGO_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_LOGO_Response_OffCard(
                                             SFThread_t                     *SFThread,
                                             os_bit32                          Frame_Length,
                                             FCHS_t                         *FCHS,
                                             FC_ELS_GENERIC_ACC_Payload_t   *Payload,
                                             os_bit32                          Payload_Wrap_Offset,
                                             FC_ELS_GENERIC_ACC_Payload_t   *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__
#endif /* __MemMap_Force_On_Card__ was not defined */
}
 
os_bit32 fiFillInELS_ACC(
                        SFThread_t *SFThread,
                        os_bit32       D_ID,
                        os_bit32       OX_ID
                      )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInELS_ACC_OnCard(
                                        SFThread,
                                        D_ID,
                                        OX_ID
                                      );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInELS_ACC_OffCard(
                                         SFThread,
                                         D_ID,
                                         OX_ID
                                       );
    }
}

os_bit32 fiFillInELS_ACC_OnCard(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                  = SFThread->thread_hdr.hpRoot;
    os_bit32        ELS_ACC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        ELS_ACC_Payload_Offset = ELS_ACC_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ELS_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in ELS_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in ELS_ACC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_GENERIC_ACC_Payload_t,
                                                                  ELS_Type
                                                                ),
                         hpSwapBit32(
                                      FC_ELS_Type_ACC
                                    )
                       );

/*+
Return length of ELS_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_GENERIC_ACC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInELS_ACC_OffCard(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                    *ELS_ACC_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_GENERIC_ACC_Payload_t *ELS_ACC_Payload = (FC_ELS_GENERIC_ACC_Payload_t *)((os_bit8 *)ELS_ACC_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ELS_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in ELS_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                  );

/*+
Fill in ELS_ACC Frame Payload
-*/

    ELS_ACC_Payload->ELS_Type
        = hpSwapBit32(
                       FC_ELS_Type_ACC
                     );

/*+
Return length of ELS_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_GENERIC_ACC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_LILP_OnCard(
                                   agRoot_t *hpRoot,
                                   os_bit32     Frame_Length,
                                   os_bit32     Offset_to_FCHS,
                                   os_bit32     Offset_to_Payload,
                                   os_bit32     Payload_Wrap_Offset,
                                   os_bit32     Offset_to_Payload_Wrapped
                                 )
{
#ifndef __MemMap_Force_Off_Card__
    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *LILP_Payload  = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    os_bit32                                         LILP_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         LILP_Payload_To_Copy;
    os_bit32                                         Bit8_Index;

    if (LILP_Payload_Size < FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE)
    {
        LILP_Payload_To_Copy = LILP_Payload_Size;
    }
    else /* LILP_Payload_Size >= FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE */
    {
        LILP_Payload_To_Copy = FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE;
    }

    for (Bit8_Index = 0;
         Bit8_Index < LILP_Payload_To_Copy;
         Bit8_Index++)
    {
        if (Bit8_Index <= Payload_Wrap_Offset)
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index)
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + Bit8_Index
                                   );
        }
        else /* Bit8_Index > Payload_Wrap_Offset */
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index)
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + Bit8_Index
                                   );
        }
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_LILP_OffCard(
                                    agRoot_t                                     *hpRoot,
                                    os_bit32                                         Frame_Length,
                                    FCHS_t                                       *FCHS,
                                    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload,
                                    os_bit32                                         Payload_Wrap_Offset,
                                    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__

    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * LILP_Payload  = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    os_bit32                                       LILP_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                       LILP_Payload_To_Copy;
    os_bit32                                       Bit8_Index;

    if (LILP_Payload_Size < FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE)
    {
        LILP_Payload_To_Copy = LILP_Payload_Size;
    }
    else /* LILP_Payload_Size >= FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE */
    {
        LILP_Payload_To_Copy = FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE;
    }

    for (Bit8_Index = 0;
         Bit8_Index < LILP_Payload_To_Copy;
         Bit8_Index++)
    {
        if (Bit8_Index <= Payload_Wrap_Offset)
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index) = *((os_bit8 *)Payload + Bit8_Index);
        }
        else /* Bit8_Index > Payload_Wrap_Offset */
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index) = *((os_bit8 *)Payload_Wrapped + Bit8_Index);
        }
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInRRQ(
                   SFThread_t *SFThread
                 )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInRRQ_OnCard(
                                   SFThread
                                 );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInRRQ_OffCard(
                                    SFThread
                                  );
    }
}

os_bit32 fiFillInRRQ_OnCard(
                          SFThread_t *SFThread
                        )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot             = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread            = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread          = SFThread->parent.CDB;
    DevThread_t *DevThread          = CDBThread->Device;
    os_bit32        RRQ_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        RRQ_Payload_Offset = RRQ_Header_Offset + sizeof(FCHS_t);
    X_ID_t       Masked_OX_ID;
    os_bit32        D_ID;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_RRQ;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Read;
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Write;
    }

/*+
Fill in RRQ Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in RRQ Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             ELS_Type
                                                           ),
                         hpSwapBit32( FC_ELS_Type_RRQ )
                       );

    D_ID    =   fiComputeDevThread_D_ID(DevThread);

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             Originator_S_ID
                                                           ),
                         hpSwapBit32(
                                      fiComputeCThread_S_ID(
                                                             CThread
                                                           )
                                    )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             OX_ID__RX_ID
                                                           ),
                         hpSwapBit32(
                                      (   (Masked_OX_ID << FC_ELS_RRQ_OX_ID_SHIFT)
                                        | (      0xFFFF << FC_ELS_RRQ_RX_ID_SHIFT) )
                                    )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             Association_Header.Validity_Bits
                                                           ),
                         hpSwapBit32( 0 )
                       );

/*+
Return length of RRQ Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_RRQ_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInRRQ_OffCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t            *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    CDBThread_t          *CDBThread    = SFThread->parent.CDB;
    DevThread_t          *DevThread    = CDBThread->Device;
    FCHS_t               *RRQ_Header   = SFThread->SF_CMND_Ptr;
    FC_ELS_RRQ_Payload_t *RRQ_Payload  = (FC_ELS_RRQ_Payload_t *)((os_bit8 *)RRQ_Header + sizeof(FCHS_t));
    X_ID_t                Masked_OX_ID;
    os_bit32                 S_ID=0;
    os_bit32                 D_ID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_RRQ;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Read;
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Write;
    }

    D_ID =  fiComputeDevThread_D_ID( DevThread );
/*+
Fill in RRQ Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in RRQ Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    RRQ_Payload->ELS_Type
        = hpSwapBit32( FC_ELS_Type_RRQ );

    RRQ_Payload->Originator_S_ID
        = hpSwapBit32( S_ID
                     );

    RRQ_Payload->OX_ID__RX_ID
        = hpSwapBit32(
                       (   (Masked_OX_ID << FC_ELS_RRQ_OX_ID_SHIFT)
                         | (      0xFFFF << FC_ELS_RRQ_RX_ID_SHIFT) )
                     );

    RRQ_Payload->Association_Header.Validity_Bits
        = hpSwapBit32( 0 );

/*+
Return length of RRQ Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_RRQ_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_RRQ_Response_OnCard(
                                           SFThread_t *SFThread,
                                           os_bit32       Frame_Length,
                                           os_bit32       Offset_to_FCHS,
                                           os_bit32       Offset_to_Payload,
                                           os_bit32       Payload_Wrap_Offset,
                                           os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_RRQ_Response_OffCard(
                                            SFThread_t               *SFThread,
                                            os_bit32                     Frame_Length,
                                            FCHS_t                   *FCHS,
                                            FC_ELS_ACC_RRQ_Payload_t *Payload,
                                            os_bit32                     Payload_Wrap_Offset,
                                            FC_ELS_ACC_RRQ_Payload_t *Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_On_Card__
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPRLI(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPRLI_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPRLI_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInPRLI_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        PRLI_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        PRLI_Payload_Offset = PRLI_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLI Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in PRLI Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              ELS_Type__Page_Length__Payload_Length
                                                            ),
                         hpSwapBit32(   FC_ELS_Type_PRLI
                                     | (sizeof(FC_ELS_PRLI_Parm_Page_t) << FC_ELS_PRLI_Page_Length_SHIFT)
                                     | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)) << FC_ELS_PRLI_Payload_Length_SHIFT) )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Type__Type_Extension__Flags
                                                            ),
                         hpSwapBit32(   FC_ELS_PRLI_Parm_Type_SCSI_FCP
                                      | FC_ELS_PRLI_Parm_Establish_Image_Pair )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Originator_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Responder_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Service_Parameters
                                                            ),
                         hpSwapBit32(   FC_ELS_PRLI_Parm_Initiator_Function
                                      | FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled )
                       );

/*+
Return length of PRLI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPRLI_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    DevThread_t           *DevThread    = SFThread->parent.Device;
    FCHS_t                *PRLI_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_PRLI_Payload_t *PRLI_Payload = (FC_ELS_PRLI_Payload_t *)((os_bit8 *)PRLI_Header + sizeof(FCHS_t));
    os_bit32                 *pPayload      = (os_bit32   *)PRLI_Payload;
    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLI Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in PRLI Frame Payload
-*/

    PRLI_Payload->ELS_Type__Page_Length__Payload_Length
        = hpSwapBit32(   FC_ELS_Type_PRLI
                       | (sizeof(FC_ELS_PRLI_Parm_Page_t) << FC_ELS_PRLI_Page_Length_SHIFT)
                       | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)) << FC_ELS_PRLI_Payload_Length_SHIFT) );

    PRLI_Payload->Parm_Page[0].Type__Type_Extension__Flags
        = hpSwapBit32(   FC_ELS_PRLI_Parm_Type_SCSI_FCP
                       | FC_ELS_PRLI_Parm_Establish_Image_Pair);

    PRLI_Payload->Parm_Page[0].Originator_Process_Associator = 0;

    PRLI_Payload->Parm_Page[0].Responder_Process_Associator  = 0;

    if(DevThread->PRLI_rejected)
    {
        PRLI_Payload->Parm_Page[0].Service_Parameters
            = hpSwapBit32(   FC_ELS_PRLI_Parm_Initiator_Function
                           | FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled );
    }
    else
    {
        PRLI_Payload->Parm_Page[0].Service_Parameters
            = hpSwapBit32(   FC_ELS_PRLI_Parm_Initiator_Function
                           | FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled 
                           | FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed );
    }
/*+
Return length of PRLI Frame (including FCHS and Payload)
-*/

    fiLogDebugString(
                      SFThread->thread_hdr.hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                      "Sent PRLI Payload",
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+0)),
                      hpSwapBit32( *(pPayload+1)),
                      hpSwapBit32( *(pPayload+2)),
                      hpSwapBit32( *(pPayload+3)),
                      hpSwapBit32( *(pPayload+4)),
                      hpSwapBit32( *(pPayload+5)),
                      hpSwapBit32( *(pPayload+6)),
                      hpSwapBit32( *(pPayload+7)));


    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_PRLI_Response_Either(
                                            DevThread_t *DevThread
                                          )
{
    CThread_t   *CThread           = CThread_ptr(DevThread->thread_hdr.hpRoot);
    os_bit32        FCHS_LCr;
    os_bit32        Receive_Data_Size;
    os_bit32        IWE_FL;
    FCHS_t      *FCHS              = &(DevThread->Template_FCHS);
    IRE_t       *IRE               = &(DevThread->Template_SEST_IRE);
    IWE_t       *IWE               = &(DevThread->Template_SEST_IWE);
    os_bit32    DEVID=CThread->DEVID;

    /* Fill in DevThread->Template_FCHS */
/*
    FCHS_LCr = ( ( ( (   DevThread->DevInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit
                       & FC_N_Port_Common_Parms_BB_Credit_MASK                           )
                     >> FC_N_Port_Common_Parms_BB_Credit_SHIFT                             )
                   << FCHS_LCr_SHIFT                                                         )
                 & FCHS_LCr_MASK                                                               );

*/
    FCHS_LCr = ( ( ( (   0
                       & FC_N_Port_Common_Parms_BB_Credit_MASK                           )
                     >> FC_N_Port_Common_Parms_BB_Credit_SHIFT                             )
                   << FCHS_LCr_SHIFT                                                         )
                 & FCHS_LCr_MASK                                                               );

    FCHS->MBZ1                                        = 0;

#ifdef __TACHYON_XL_CLASS2
    /* Depending on the device support of class 2, set the class 2 vs class 3 SOF */
    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp = (DevThread->GoingClass2) ? FCHS_SOF_SOFi2 : FCHS_SOF_SOFi3
                                                        | FCHS_EOF_EOFn
                                                        | FCHS_LCr;
#else

    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                        | FCHS_EOF_EOFn
                                                        | FCHS_LCr;
#endif

    FCHS->R_CTL__D_ID                                 =   FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                                                        | FC_Frame_Header_R_CTL_Lo_Unsolicited_Command
                                                        | fiComputeDevThread_D_ID(
                                                                                   DevThread
                                                                                 );
    if( (DevThread->DevInfo.CurrentAddress.Domain == 0) &&
        (DevThread->DevInfo.CurrentAddress.Area == 0) )
    {
        FCHS->CS_CTL__S_ID                            = CThread->ChanInfo.CurrentAddress.AL_PA;
    }
    else
    {
        FCHS->CS_CTL__S_ID                            = fiComputeCThread_S_ID(CThread);
    }

#ifdef __TACHYON_XL_CLASS2
   FCHS->TYPE__F_CTL                                 =  (DevThread->GoingClass2) ? 
                                                         FC_Frame_Header_F_CTL_ACK_Form_ACK_0_Required
                                                        | FC_Frame_Header_TYPE_SCSI_FCP
                                                        | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                        | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                        | FC_Frame_Header_F_CTL_First_Sequence
                                                        | FC_Frame_Header_F_CTL_End_Sequence
                                                        | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer
                                                        | FC_Frame_Header_F_CTL_Relative_Offset_Present :
                                                        FC_Frame_Header_TYPE_SCSI_FCP
                                                        | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                        | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                        | FC_Frame_Header_F_CTL_First_Sequence
                                                        | FC_Frame_Header_F_CTL_End_Sequence
                                                        | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer
                                                        | FC_Frame_Header_F_CTL_Relative_Offset_Present;
#else

    FCHS->TYPE__F_CTL                                 =   FC_Frame_Header_TYPE_SCSI_FCP
                                                        | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                        | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                        | FC_Frame_Header_F_CTL_First_Sequence
                                                        | FC_Frame_Header_F_CTL_End_Sequence
                                                        | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer
                                                        | FC_Frame_Header_F_CTL_Relative_Offset_Present;
#endif

    FCHS->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    FCHS->OX_ID__RX_ID                                = (0xFFFF << FCHS_RX_ID_SHIFT);
    FCHS->RO                                          = 0;

    /* Fill in DevThread->Template_SEST_IRE */

    IRE->Bits_MBZ1_EQL_MBZ2                           =   IRE_VAL
                                                        | IRE_DIR
                                                        | IRE_INI
                                                        | IRE_DAT
                                                        | IRE_RSP;
    IRE->MBZ3                                         = 0;
    IRE->Remote_Node_ID__RSP_Len                      =   (DevThread->DevInfo.CurrentAddress.Domain << (IRE_Remote_Node_ID_SHIFT + 16))
                                                        | (DevThread->DevInfo.CurrentAddress.Area   << (IRE_Remote_Node_ID_SHIFT +  8))
                                                        | (DevThread->DevInfo.CurrentAddress.AL_PA  <<  IRE_Remote_Node_ID_SHIFT      )
                                                        | (CThread->Calculation.MemoryLayout.FCP_RESP.elementSize << IRE_RSP_Len_SHIFT);
    IRE->RSP_Addr                                     = 0;
    IRE->LOC__MBZ4__Buff_Off                          = IRE_LOC;
    IRE->Buff_Index__MBZ5                             = 0;
    IRE->Exp_RO                                       = 0;
    IRE->Byte_Count                                   = 0;
    IRE->MBZ6                                         = 0;
    IRE->Exp_Byte_Cnt                                 = 0;
    IRE->First_SG.U32_Len                             = 0;
    IRE->First_SG.L32                                 = 0;
    IRE->Second_SG.U32_Len                            = 0;
    IRE->Second_SG.L32                                = 0;
    IRE->Third_SG.U32_Len                             = 0;
    IRE->Third_SG.L32                                 = 0;

    /* Fill in DevThread->Template_SEST_IWE */

#ifdef __TACHYON_XL_CLASS2
    Receive_Data_Size = ( ( (DevThread->GoingClass2) ? DevThread->DevInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
                            & FC_N_Port_Class_Parms_Receive_Data_Size_MASK : DevThread->DevInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
                            & FC_N_Port_Class_Parms_Receive_Data_Size_MASK                                       )
                          >> FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT                                         );
#else
    Receive_Data_Size = ( (   DevThread->DevInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
                            & FC_N_Port_Class_Parms_Receive_Data_Size_MASK                                       )
                          >> FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT                                         );
#endif

    if ((DEVID == ChipConfig_DEVID_TachyonXL2) && Receive_Data_Size >= 2048)
    {
        IWE_FL = IWE_FL_2048_Bytes;

        fiLogDebugString(
                  DevThread->thread_hdr.hpRoot,
                  LinkSvcLogConsoleLevel,
                  "DEVID 0x%08X Setting IWE to be 2048 bytes",
                  (char *)agNULL,(char *)agNULL,
                  (void *)agNULL,(void *)agNULL,
                  (os_bit32)DEVID,
                  0,0,0,0,0,0,0
                );

        
    }
    else if (Receive_Data_Size >= 1024)
    {
        IWE_FL = IWE_FL_1024_Bytes;
    }
    else if (Receive_Data_Size >= 512)
    {
        IWE_FL = IWE_FL_512_Bytes;
    }
    else /* Receive_Data_Size >= 128 */
    {
        IWE_FL = IWE_FL_128_Bytes;
    }

    IWE->Bits__MBZ1__LNK__MBZ2__FL__MBZ3__Hdr_Len     =   IWE_VAL
                                                        | IWE_INI
                                                        | IWE_DAT
                                                        | IWE_RSP
                                                        | IWE_FL
                                                        | (sizeof(FCHS_t) << IWE_Hdr_Len_SHIFT);
    IWE->Hdr_Addr                                     = 0;
    IWE->Remote_Node_ID__RSP_Len                      =   (DevThread->DevInfo.CurrentAddress.Domain << (IRE_Remote_Node_ID_SHIFT + 16))
                                                        | (DevThread->DevInfo.CurrentAddress.Area   << (IRE_Remote_Node_ID_SHIFT +  8))
                                                        | (DevThread->DevInfo.CurrentAddress.AL_PA  <<  IRE_Remote_Node_ID_SHIFT      )
                                                        | (CThread->Calculation.MemoryLayout.FCP_RESP.elementSize << IRE_RSP_Len_SHIFT);
    IWE->RSP_Addr                                     = 0;
    IWE->LOC__0xF__MBZ4__Buff_Off                     = ( IWE_LOC | IWE_0xF_ALWAYS );
    IWE->Buff_Index__Link                             = IWE_Link_Initializer;
    IWE->MBZ5__RX_ID                                  = 0xFFFF << IWE_RX_ID_SHIFT;
    IWE->Data_Len                                     = 0;
    IWE->Exp_RO                                       = 0;
    IWE->Exp_Byte_Cnt                                 = 0;
    IWE->First_SG.U32_Len                             = 0;
    IWE->First_SG.L32                                 = 0;
    IWE->Second_SG.U32_Len                            = 0;
    IWE->Second_SG.L32                                = 0;
    IWE->Third_SG.U32_Len                             = 0;
    IWE->Third_SG.L32                                 = 0;
}

void fiLinkSvcProcess_PRLI_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t      *hpRoot                                = SFThread->thread_hdr.hpRoot;
    DevThread_t   *DevThread                             = SFThread->parent.Device;
    agFCDevInfo_t *DevInfo                               = &(DevThread->DevInfo);
    os_bit32          ELS_Type__Page_Length__Payload_Length;
    os_bit32          Type__Type_Extension__Flags;
    os_bit32          Service_Parameters;

    DevInfo->LoggedIn = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,ELS_Type__Page_Length__Payload_Length)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 ELS_Type__Page_Length__Payload_Length
                                                               ) )
                                            ));
    }
    else
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 ELS_Type__Page_Length__Payload_Length
                                                               ) )
                                            ));
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Page_Length_MASK) >> FC_ELS_ACC_PRLI_Page_Length_SHIFT) != (sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Payload_Length_MASK) >> FC_ELS_ACC_PRLI_Payload_Length_SHIFT) != (sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Type__Type_Extension__Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Type__Type_Extension__Flags
                                                               ) )
                                            ));
    }
    else
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Type__Type_Extension__Flags
                                                               ) )
                                            ));
    }

    if ((Type__Type_Extension__Flags & FC_ELS_ACC_PRLI_Parm_Type_MASK) != FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP)
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Service_Parameters)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Service_Parameters
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Service_Parameters
                                                               ) )
                                            ));
    }
    else
    {
        Service_Parameters
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Service_Parameters
                                                               ) )
                                            ));
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Initiator_Function)
    {
        DevInfo->DeviceType |= agDevSCSIInitiator;
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Target_Function)
    {
        DevInfo->DeviceType |= agDevSCSITarget;
    }

    if (Service_Parameters & FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed)
    {
        DevThread->FC_TapeDevice = agTRUE;
    }
    else
    {
        DevThread->FC_TapeDevice = agFALSE;
    }




    fiLinkSvcProcess_PRLI_Response_Either(
                                           DevThread
                                         );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_PRLI_Response_OffCard(
                                             SFThread_t                *SFThread,
                                             os_bit32                      Frame_Length,
                                             FCHS_t                    *FCHS,
                                             FC_ELS_ACC_PRLI_Payload_t *Payload,
                                             os_bit32                      Payload_Wrap_Offset,
                                             FC_ELS_ACC_PRLI_Payload_t *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t      *hpRoot                   = SFThread->thread_hdr.hpRoot;
    DevThread_t   *DevThread                = SFThread->parent.Device;
    agFCDevInfo_t *DevInfo                  = &(DevThread->DevInfo);
    os_bit32       ELS_Type__Page_Length__Payload_Length;
    os_bit32       Type__Type_Extension__Flags;
    os_bit32       Service_Parameters;
    os_bit32     * pPayload = (os_bit32 *)Payload;

    DevInfo->LoggedIn = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,ELS_Type__Page_Length__Payload_Length)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(Payload->ELS_Type__Page_Length__Payload_Length);
    }
    else
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(Payload_Wrapped->ELS_Type__Page_Length__Payload_Length);
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Page_Length_MASK) >> FC_ELS_ACC_PRLI_Page_Length_SHIFT) != (sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Payload_Length_MASK) >> FC_ELS_ACC_PRLI_Payload_Length_SHIFT) != (sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Type__Type_Extension__Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(Payload->Parm_Page[0].Type__Type_Extension__Flags);
    }
    else
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(Payload_Wrapped->Parm_Page[0].Type__Type_Extension__Flags);
    }

    if ((Type__Type_Extension__Flags & FC_ELS_ACC_PRLI_Parm_Type_MASK) != FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP)
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Service_Parameters)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Service_Parameters
            = hpSwapBit32(Payload->Parm_Page[0].Service_Parameters);
    }
    else
    {
        Service_Parameters
            = hpSwapBit32(Payload_Wrapped->Parm_Page[0].Service_Parameters);
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Initiator_Function)
    {
        DevInfo->DeviceType |= agDevSCSIInitiator;
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Target_Function)
    {
        DevInfo->DeviceType |= agDevSCSITarget;
    }


    if (Service_Parameters & FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed)
    {
        DevThread->FC_TapeDevice = agTRUE;
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "%s  agTRUE !!!!",
                          "FC_TapeDevice",
                          (char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0);

    }
    else
    {
        DevThread->FC_TapeDevice = agFALSE;
    }

/*   pPayload    +=  8; */

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                      "PRLI Response Payload",
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+0)),
                      hpSwapBit32( *(pPayload+1)),
                      hpSwapBit32( *(pPayload+2)),
                      hpSwapBit32( *(pPayload+3)),
                      hpSwapBit32( *(pPayload+4)),
                      hpSwapBit32( *(pPayload+5)),
                      hpSwapBit32( *(pPayload+6)),
                      hpSwapBit32( *(pPayload+7)));


    fiLinkSvcProcess_PRLI_Response_Either(
                                           DevThread
                                         );
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPRLI_ACC(
                        SFThread_t *SFThread,
                        os_bit32       D_ID,
                        os_bit32       OX_ID
                      )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPRLI_ACC_OnCard(
                                        SFThread,
                                        D_ID,
                                        OX_ID
                                      );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPRLI_ACC_OffCard(
                                         SFThread,
                                         D_ID,
                                         OX_ID
                                       );
    }
}

os_bit32 fiFillInPRLI_ACC_OnCard(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                  = SFThread->thread_hdr.hpRoot;
    os_bit32     PRLI_ACC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32     PRLI_ACC_Payload_Offset = PRLI_ACC_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PRLI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in PRLI_ACC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  ELS_Type__Page_Length__Payload_Length
                                                                ),
                         hpSwapBit32(   FC_ELS_Type_ACC
                                     | (sizeof(FC_ELS_ACC_PRLI_Parm_Page_t) << FC_ELS_ACC_PRLI_Page_Length_SHIFT)
                                     | ((sizeof(os_bit32) + sizeof(FC_ELS_ACC_PRLI_Parm_Page_t)) << FC_ELS_ACC_PRLI_Payload_Length_SHIFT) )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Type__Type_Extension__Flags
                                                                ),
                         hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP
                                      | FC_ELS_ACC_PRLI_Parm_Image_Pair_Established 
                                      | FC_ELS_ACC_PRLI_Parm_Flags_Response_Request_Executed )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Originator_Process_Associator
                                                                ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Responder_Process_Associator
                                                                ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Service_Parameters
                                                                ),
                         hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Initiator_Function
                                      | FC_ELS_ACC_PRLI_Parm_Read_XFER_RDY_Disabled )
                       );

/*+
Return length of PRLI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPRLI_ACC_OffCard(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */

    FCHS_t                    *PRLI_ACC_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_ACC_PRLI_Payload_t *PRLI_ACC_Payload = (FC_ELS_ACC_PRLI_Payload_t *)((os_bit8 *)PRLI_ACC_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PRLI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence

                                  );

/*+
Fill in PRLI_ACC Frame Payload
-*/

    PRLI_ACC_Payload->ELS_Type__Page_Length__Payload_Length
        = hpSwapBit32(   FC_ELS_Type_ACC
                       | (sizeof(FC_ELS_ACC_PRLI_Parm_Page_t) << FC_ELS_ACC_PRLI_Page_Length_SHIFT)
                       | ((sizeof(os_bit32) + sizeof(FC_ELS_ACC_PRLI_Parm_Page_t)) << FC_ELS_ACC_PRLI_Payload_Length_SHIFT) );

    PRLI_ACC_Payload->Parm_Page[0].Type__Type_Extension__Flags
        = hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP
                       | FC_ELS_ACC_PRLI_Parm_Image_Pair_Established 
                       | FC_ELS_ACC_PRLI_Parm_Flags_Response_Request_Executed );

    PRLI_ACC_Payload->Parm_Page[0].Originator_Process_Associator = 0;

    PRLI_ACC_Payload->Parm_Page[0].Responder_Process_Associator  = 0;

    PRLI_ACC_Payload->Parm_Page[0].Service_Parameters
        = hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Initiator_Function
                       | FC_ELS_ACC_PRLI_Parm_Read_XFER_RDY_Disabled );

/*+
Return length of PRLI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPRLO(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPRLO_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPRLO_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInPRLO_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        PRLO_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        PRLO_Payload_Offset = PRLO_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLO Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in PRLO Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              ELS_Type__Page_Length__Payload_Length
                                                            ),
                         hpSwapBit32(   FC_ELS_Type_PRLO
                                     | (sizeof(FC_ELS_PRLO_Parm_Page_t) << FC_ELS_PRLO_Page_Length_SHIFT)
                                     | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLO_Parm_Page_t)) << FC_ELS_PRLO_Payload_Length_SHIFT) )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Type__Type_Extension__Flags
                                                            ),
                         hpSwapBit32( FC_ELS_PRLI_Parm_Type_SCSI_FCP )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Originator_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Responder_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Reserved
                                                            ),
                         0
                       );

/*+
Return length of PRLO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLO_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPRLO_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    DevThread_t           *DevThread    = SFThread->parent.Device;
    FCHS_t                *PRLO_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_PRLO_Payload_t *PRLO_Payload = (FC_ELS_PRLO_Payload_t *)((os_bit8 *)PRLO_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLO Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in PRLO Frame Payload
-*/

    PRLO_Payload->ELS_Type__Page_Length__Payload_Length
        = hpSwapBit32(   FC_ELS_Type_PRLO
                       | (sizeof(FC_ELS_PRLO_Parm_Page_t) << FC_ELS_PRLO_Page_Length_SHIFT)
                       | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLO_Parm_Page_t)) << FC_ELS_PRLO_Payload_Length_SHIFT) );

    PRLO_Payload->Parm_Page[0].Type__Type_Extension__Flags
        = hpSwapBit32( FC_ELS_PRLO_Parm_Type_SCSI_FCP );

    PRLO_Payload->Parm_Page[0].Originator_Process_Associator = 0;

    PRLO_Payload->Parm_Page[0].Responder_Process_Associator  = 0;

    PRLO_Payload->Parm_Page[0].Reserved                      = 0;

/*+
Return length of PRLO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLO_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_PRLO_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_PRLO_Response_OffCard(
                                             SFThread_t                *SFThread,
                                             os_bit32                      Frame_Length,
                                             FCHS_t                    *FCHS,
                                             FC_ELS_ACC_PRLO_Payload_t *Payload,
                                             os_bit32                      Payload_Wrap_Offset,
                                             FC_ELS_ACC_PRLO_Payload_t *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInADISC(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInADISC_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInADISC_OffCard(
                                      SFThread
                                    );
    }
}

os_bit32 fiFillInADISC_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot               = SFThread->thread_hdr.hpRoot; /* NW BUG */
    DevThread_t *DevThread            = SFThread->parent.Device;
    os_bit32        ADISC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        ADISC_Payload_Offset = ADISC_Header_Offset + sizeof(FCHS_t);
    os_bit32        Bit8_Index;
    os_bit32        D_ID;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );
    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );


/*+
Fill in ADISC Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread_ptr(hpRoot) );
    else
        S_ID =     CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.AL_PA;
    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_ADISC )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               Hard_Address_of_Originator
                                                             ),
                         hpSwapBit32(   (CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.Domain << 16)
                                      | (CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.Area   <<  8)
                                      | CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.AL_PA          )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Port_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread_ptr(hpRoot)->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Node_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread_ptr(hpRoot)->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               N_Port_ID_of_Originator
                                                             ),
                         hpSwapBit32(S_ID )
                       );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInADISC_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread             = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t            *DevThread           = SFThread->parent.Device;
    FCHS_t                 *ADISC_Header        = SFThread->SF_CMND_Ptr;
    FC_ELS_ADISC_Payload_t *ADISC_Payload       = (FC_ELS_ADISC_Payload_t *)((os_bit8 *)ADISC_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;
    os_bit32                   S_ID=0;
    os_bit32                   D_ID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    D_ID  = fiComputeDevThread_D_ID(DevThread);
                                                           
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in ADISC Frame Payload
-*/

    ADISC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_ADISC );

    ADISC_Payload->Hard_Address_of_Originator
        = hpSwapBit32(   (CThread->ChanInfo.CurrentAddress.Domain << 16)
                       | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                       |  CThread->ChanInfo.CurrentAddress.AL_PA         );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Port_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Node_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    ADISC_Payload->N_Port_ID_of_Originator
        = hpSwapBit32( S_ID
                     );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiLinkSvcProcess_ADISC_Response_OnCard(
                                             SFThread_t *SFThread,
                                             os_bit32       Frame_Length,
                                             os_bit32       Offset_to_FCHS,
                                             os_bit32       Offset_to_Payload,
                                             os_bit32       Payload_Wrap_Offset,
                                             os_bit32       Offset_to_Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t      *hpRoot                    = SFThread->thread_hdr.hpRoot;
    agFCDevInfo_t *DevInfo                   = &(SFThread->parent.Device->DevInfo);
    os_bit32          Hard_Address_of_Responder;
    os_bit32          Bit8_Index;

    if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Hard_Address_of_Responder)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Hard_Address_of_Responder
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_ADISC_Payload_t,
                                                                 Hard_Address_of_Responder
                                                               ) )
                                            ));
    }
    else
    {
        Hard_Address_of_Responder
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_ADISC_Payload_t,
                                                                 Hard_Address_of_Responder
                                                               ) )
                                            ));
    }

    DevInfo->HardAddress.Domain = (Hard_Address_of_Responder & 0x00FF0000) >> 16;
    DevInfo->HardAddress.Area   = (Hard_Address_of_Responder & 0x0000FF00) >>  8;
    DevInfo->HardAddress.AL_PA  = (Hard_Address_of_Responder & 0x000000FF);

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Port_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_ADISC_Payload_t,
                                                                        Port_Name_of_Responder[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_ADISC_Payload_t,
                                                                                Port_Name_of_Responder[Bit8_Index]
                                                                              )
                                   );
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Node_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_ADISC_Payload_t,
                                                                        Node_Name_of_Responder[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_ADISC_Payload_t,
                                                                                Node_Name_of_Responder[Bit8_Index]
                                                                              )
                                   );
        }
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
    return fiLinkSvc_Cmd_Status_ACC;
}

os_bit32 fiLinkSvcProcess_ADISC_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_ELS_ACC_ADISC_Payload_t *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_ELS_ACC_ADISC_Payload_t *Payload_Wrapped
                                            )
{
#ifndef __MemMap_Force_On_Card__
    agFCDevInfo_t *DevInfo                   = &(SFThread->parent.Device->DevInfo);
    os_bit32          Hard_Address_of_Responder;
    os_bit32          Bit8_Index;
    os_bit32          N_Port_ID_of_Responder;
/*
**    agRoot_t      *hpRoot                    = SFThread->thread_hdr.hpRoot;
*/
    if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Hard_Address_of_Responder)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Hard_Address_of_Responder = hpSwapBit32(Payload->Hard_Address_of_Responder);
    }
    else
    {
        Hard_Address_of_Responder = hpSwapBit32(Payload_Wrapped->Hard_Address_of_Responder);
    }

    if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,N_Port_ID_of_Responder)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        N_Port_ID_of_Responder = hpSwapBit32(Payload->N_Port_ID_of_Responder);
    }
    else
    {
        N_Port_ID_of_Responder = hpSwapBit32(Payload_Wrapped->N_Port_ID_of_Responder);
    }

/*
    fiLogDebugString(hpRoot,
                0,
                "  Domain %02X %02X Area %02X %02X AL_PA %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                DevInfo->CurrentAddress.Domain,
                (N_Port_ID_of_Responder & 0x00FF0000) >> 16,
                DevInfo->CurrentAddress.Area,
                (N_Port_ID_of_Responder & 0x0000FF00) >>  8,
                DevInfo->CurrentAddress.AL_PA,
                (N_Port_ID_of_Responder & 0x000000FF),
                0,0);
*/
/*Add verification here ...... */
    if( DevInfo->CurrentAddress.Domain != ((N_Port_ID_of_Responder & 0x00FF0000) >> 16))
    {
        return fiLinkSvc_Cmd_Status_RJT;
    }

    if( DevInfo->CurrentAddress.Area   != ((N_Port_ID_of_Responder & 0x0000FF00) >>  8))
    {
        return fiLinkSvc_Cmd_Status_RJT;
    }

    if( DevInfo->CurrentAddress.AL_PA  != ((N_Port_ID_of_Responder & 0x000000FF)))
    {
        return fiLinkSvc_Cmd_Status_RJT;
    }


    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Port_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if( DevInfo->PortWWN[Bit8_Index] != Payload->Port_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }

        }
        else
        {
            if( DevInfo->PortWWN[Bit8_Index] != Payload_Wrapped->Port_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Node_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if( DevInfo->NodeWWN[Bit8_Index] != Payload->Node_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }
        }
        else
        {
            if( DevInfo->NodeWWN[Bit8_Index] != Payload_Wrapped->Node_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }
        }
    }

    return fiLinkSvc_Cmd_Status_ACC;

#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInSCR(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInSCR_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInSCR_OffCard(
                                      SFThread
                                    );
    }
}


os_bit32 fiFillInSCR_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot               = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread              = CThread_ptr(hpRoot);
    os_bit32        SCR_Header_Offset    = SFThread->SF_CMND_Offset;
    os_bit32        SCR_Payload_Offset   = SCR_Header_Offset + sizeof(FCHS_t);
    os_bit32        D_ID;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SCR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SCR Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   FC_Well_Known_Port_ID_Fabric_Controller,
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );
    D_ID = FC_Well_Known_Port_ID_Fabric_Controller;


/*+
Fill in SCR Frame Payload
-*/
    S_ID = fiComputeCThread_S_ID(CThread );

    osCardRamWriteBit32(
                         hpRoot,
                         SCR_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_SCR_Payload_t,
                                                               ELS_Type_Command
                                                             ),
                         hpSwapBit32( FC_ELS_Type_SCR )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         SCR_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_SCR_Payload_t,
                                                               Reserved_Registration_Function
                                                             ),
                         hpSwapBit32(FC_ELS_SCR_Full_Registration)
                       );


/*+
Return length of SCR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SCR_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInSCR_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                 *SCR_Header          = SFThread->SF_CMND_Ptr;
    FC_ELS_SCR_Payload_t   *SCR_Payload         = (FC_ELS_SCR_Payload_t *)((os_bit8 *)SCR_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SCR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SCR Frame Header
-*/

                                                           
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    FC_Well_Known_Port_ID_Fabric_Controller,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in SCR Frame Payload
-*/

    SCR_Payload->ELS_Type_Command = hpSwapBit32( FC_ELS_Type_SCR );

    SCR_Payload->Reserved_Registration_Function = hpSwapBit32(FC_ELS_SCR_Full_Registration);

/*+
Return length of SCR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SCR_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}



void fiLinkSvcProcess_TargetRequest_OnCard(
                                            agRoot_t *hpRoot,
                                            os_bit32     Frame_Length,
                                            os_bit32     Offset_to_FCHS,
                                            os_bit32     Offset_to_Payload,
                                            os_bit32     Payload_Wrap_Offset,
                                            os_bit32     Offset_to_Payload_Wrapped
                                          )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32        TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32        TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32        TgtCmnd_Payload_To_Copy;
    os_bit32        Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OnCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        osCardRamReadBlock(
                            hpRoot,
                            Offset_to_FCHS,
                            (void *)TgtCmnd_FCHS,
                            sizeof(FCHS_t)
                          );

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload + Bit8_Index
                                       );
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload_Wrapped + Bit8_Index
                                       );
            }
        }

        fiSendEvent( &(TgtThread->thread_hdr),TgtEventIncoming );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OnCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

void fiLinkSvcProcess_TargetRequest_OffCard(
                                             agRoot_t *hpRoot,
                                             os_bit32     Frame_Length,
                                             FCHS_t   *FCHS,
                                             void     *Payload,
                                             os_bit32     Payload_Wrap_Offset,
                                             void     *Payload_Wrapped
                                           )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32        TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32        TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32        TgtCmnd_Payload_To_Copy;
    os_bit32        Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OffCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        *TgtCmnd_FCHS = *FCHS;

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload + Bit8_Index);
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload_Wrapped + Bit8_Index);
            }
        }

        fiSendEvent( &(TgtThread->thread_hdr), TgtEventIncoming );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OffCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

os_bit32 fiLinkSvcProcessSFQ(
                           agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           fi_thread__t       **Thread_to_return
                         )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiLinkSvcProcessSFQ_OnCard(
                                           hpRoot,
                                           SFQConsIndex,
                                           Frame_Length,
                                           Thread_to_return
                                         );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiLinkSvcProcessSFQ_OffCard(
                                            hpRoot,
                                            SFQConsIndex,
                                            Frame_Length,
                                            Thread_to_return
                                          );
    }
}

os_bit32 fiLinkSvcProcessSFQ_OnCard(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    os_bit32                       Offset_to_FCHS             = SFQ_MemoryDescriptor->addr.CardRam.cardRamOffset
                                                             + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize);
    os_bit32                       Offset_to_Payload          = Offset_to_FCHS + sizeof(FCHS_t);
    os_bit32                       Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit32                       Offset_to_Payload_Wrapped  = Offset_to_Payload
                                                             - SFQ_MemoryDescriptor->objectSize;
    os_bit32                       R_CTL__D_ID;
    os_bit32                       TYPE__F_CTL;
    os_bit32                       Recv_BLS_Type;
    os_bit32                       Recv_ELS_Type;
    os_bit32                       Sent_LinkSvc_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    os_bit32                       SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    R_CTL__D_ID = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                    );

    TYPE__F_CTL = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                    );

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_BLS)
    {
        /* Process Basic Link Service Frame */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands BLS Responses */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        Recv_BLS_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK;

        if ((Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
            && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC))
        {
            /* Starting here, this function only understands BLS Responses (i.e. Rejects and Accepts) */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT) && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    Recv_BLS_Type==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_BLS_Type,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        if (OX_ID > CDBThread_X_ID_Max)
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (OX_ID > CDBThread_X_ID_Max)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    OX_ID==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              OX_ID,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (OX_ID * CDBThread_MemoryDescriptor->elementSize));

        SFThread = CDBThread->SFThread_Request.SFThread;

        *Thread_to_return = (fi_thread__t *)SFThread;

        if( SFThread == (SFThread_t *) agNULL )
        {
            return fiLinkSvc_Cmd_Status_Confused;
        }

        Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

        if (Recv_BLS_Type == FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
        {
            /* Simply indicate that the command was rejected */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): BLS Command [0x%08X] rejected",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            return fiLinkSvc_Cmd_Status_RJT;
        }

        switch(Sent_LinkSvc_Type)
        {
            case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                fiLinkSvcProcess_ABTS_Response_OnCard(
                                                       SFThread,
                                                       Frame_Length,
                                                       Offset_to_FCHS,
                                                       Offset_to_Payload,
                                                       Payload_Wrap_Offset,
                                                       Offset_to_Payload_Wrapped
                                                     );
                break;

            default:
                /* Unknown LinkSvc Command recorded in SFThread */

                fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                              );

                return fiLinkSvc_Cmd_Status_Confused;
        }

        return fiLinkSvc_Cmd_Status_ACC;
    }

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS)
    {
        /* Starting here, this function only understands ELS Frames */

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "A    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type) + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Recv_ELS_Type = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload + hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type)
                                                      ));
    }
    else
    {
        Recv_ELS_Type = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload_Wrapped + hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type)
                                                      ));
    }

    if ((Recv_ELS_Type & FC_ELS_Type_LoopInit_Code_MASK) == FC_ELS_Type_LoopInit_Code_LILP)
    {
        fiLinkSvcProcess_LILP_OnCard(
                                      hpRoot,
                                      Frame_Length,
                                      Offset_to_FCHS,
                                      Offset_to_Payload,
                                      Payload_Wrap_Offset,
                                      Offset_to_Payload_Wrapped
                                    );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Position_Map;
    }

    Recv_ELS_Type &= FC_ELS_Type_MASK;

    if ((TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        if (Recv_ELS_Type == FC_ELS_Type_PLOGI)
        {
            return fiLinkSvcProcess_PLOGI_Request_OnCard(
                                                          hpRoot,
                                                          OX_ID,
                                                          Frame_Length,
                                                          Offset_to_FCHS,
                                                          Offset_to_Payload,
                                                          Payload_Wrap_Offset,
                                                          Offset_to_Payload_Wrapped,
                                                          Thread_to_return
                                                        );
        }
        else /* Recv_ELS_Type != FC_ELS_Type_PLOGI */
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogTraceHideLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): Recv_ELS_Type(=0x%08X) != FC_ELS_Type_PLOGI",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_ELS_Type,
                              0,0,0,0,0,0,0
                            );

            fiLinkSvcProcess_TargetRequest_OnCard(
                                                   hpRoot,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_TargetRequest;
        }
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        /* Starting here, this function only understands ELS Responses */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((Recv_ELS_Type != FC_ELS_Type_LS_RJT)
        && (Recv_ELS_Type != FC_ELS_Type_ACC))
    {
        /* Starting here, this function only understands ELS Responses (i.e. Rejects and Accepts) */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (Recv_ELS_Type != FC_ELS_Type_LS_RJT) && (Recv_ELS_Type != FC_ELS_Type_ACC)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    Recv_ELS_Type==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Recv_ELS_Type,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;

    Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

    if (Recv_ELS_Type == FC_ELS_Type_LS_RJT)
    {
        /* Simply indicate that the command was rejected */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard(): ELS Command [0x%08X] rejected",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Sent_LinkSvc_Type,
                          0,0,0,0,0,0,0
                        );

        return fiLinkSvc_Cmd_Status_RJT;
    }

    switch(Sent_LinkSvc_Type)
    {
        case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
            fiLinkSvcProcess_PLOGI_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
            fiLinkSvcProcess_FLOGI_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_RRQ:
            fiLinkSvcProcess_RRQ_Response_OnCard(
                                                  SFThread,
                                                  Frame_Length,
                                                  Offset_to_FCHS,
                                                  Offset_to_Payload,
                                                  Payload_Wrap_Offset,
                                                  Offset_to_Payload_Wrapped
                                                );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_LOGO:
            fiLinkSvcProcess_LOGO_Response_OnCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLI:
            fiLinkSvcProcess_PRLI_Response_OnCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLO:
            fiLinkSvcProcess_PRLO_Response_OnCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_ADISC:
            /* ADISC can fail verification */
            return (fiLinkSvcProcess_ADISC_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  ));

        case SFThread_SF_CMND_LinkSvc_Type_SCR:
            /* We just recieve an ACCept or a REJect from SCR. No processing of the payload
               is required. */
            break;

        case SFThread_SF_CMND_LinkSvc_Type_SRR:
            /*
            fiLinkSvcProcess_SRR_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            */
            break;

        case SFThread_SF_CMND_LinkSvc_Type_REC:
            fiLinkSvcProcess_REC_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            break;

        default:
            /* Unknown LinkSvc Command recorded in SFThread */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            return fiLinkSvc_Cmd_Status_Confused;
    }

    return fiLinkSvc_Cmd_Status_ACC;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiLinkSvcProcessSFQ_OffCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32            Frame_Length,
                                   fi_thread__t       **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                       = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    FC_ELS_Unknown_Payload_t   *Payload                    = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    FC_ELS_Unknown_Payload_t   *Payload_Wrapped            = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)Payload
                                                                                          - SFQ_MemoryDescriptor->objectSize);
    os_bit32                    R_CTL__D_ID                = FCHS->R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL                = FCHS->TYPE__F_CTL;
    os_bit32                    Recv_BLS_Type;
    os_bit32                    Recv_ELS_Type;
    os_bit32                    RejectReason               = 0;
    os_bit32                    Sent_LinkSvc_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                    CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    os_bit32                    SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;
    os_bit32 * DisplayPayload = (os_bit32 * )Payload;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "   (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

    }

    
    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_BLS)
    {
        /* Process Basic Link Service Frame */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands BLS Responses */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        Recv_BLS_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK;

        if(Recv_BLS_Type == FC_ELS_Type_ECHO)
        {
            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_TargetRequest;

        }


        if ((Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
            && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC))
        {
            /* Starting here, this function only understands BLS Responses (i.e. Rejects and Accepts) */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT) && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    Recv_BLS_Type==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_BLS_Type,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        if (OX_ID > CDBThread_X_ID_Max)
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (OX_ID > CDBThread_X_ID_Max)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    OX_ID==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              OX_ID,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

    if ((OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "   (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          " CDB   OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

    }


        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (OX_ID * CDBThread_MemoryDescriptor->elementSize));

        SFThread = CDBThread->SFThread_Request.SFThread;

        *Thread_to_return = (fi_thread__t *)SFThread;

        if( SFThread == (SFThread_t *) agNULL )
        {   /* Maybe Status No SF Thread ???? */
            return fiLinkSvc_Cmd_Status_Confused;
        }

        Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

        if (Recv_BLS_Type == FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
        {
            /* Simply indicate that the command was rejected */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard(): BLS Command [0x%08X] rejected",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            return fiLinkSvc_Cmd_Status_RJT;
        }

        switch(Sent_LinkSvc_Type)
        {
            case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                fiLinkSvcProcess_ABTS_Response_OffCard(
                                                        SFThread,
                                                        Frame_Length,
                                                        FCHS,
                                                        (FC_BA_ACC_Payload_t *)Payload,
                                                        Payload_Wrap_Offset,
                                                        (FC_BA_ACC_Payload_t *)Payload_Wrapped
                                                      );
                break;

            default:
                /* Unknown LinkSvc Command recorded in SFThread */

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLogConsoleLevel,
                                  "fiLinkSvcProcessSFQ_OffCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  Sent_LinkSvc_Type,
                                  0,0,0,0,0,0,0
                                );
                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLogConsoleLevel,
                                  "A SFThread %p  LinkSvc Command [0x%02X] Class [0x%02X] State [0x%02X]",
                                  (char *)agNULL,(char *)agNULL,
                                  SFThread,(void *)agNULL,
                                  (os_bit32)SFThread->SF_CMND_Class,
                                  (os_bit32)SFThread->SF_CMND_Type,
                                  (os_bit32)SFThread->SF_CMND_State,
                                  0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_Confused;
        }

        return fiLinkSvc_Cmd_Status_ACC;
    }

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS)
    {
        /* Starting here, this function only understands ELS Frames */

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "B    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );
    /* SRR's can cause a FC4 Link Data Reply RCtl  So its a FCP response to a SF request */
        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(DisplayPayload+0),
                        *(DisplayPayload+1),
                        *(DisplayPayload+2),
                        *(DisplayPayload+3),
                        *(DisplayPayload+4),
                        *(DisplayPayload+5),
                        *(DisplayPayload+6),
                        *(DisplayPayload+7));

        if( ( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ) == 0x33000000)
        {
            OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

            if (OX_ID > CDBThread_X_ID_Max && OX_ID < SFThread_X_ID_Max)
            {

                SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                          + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

                *Thread_to_return = (fi_thread__t *)SFThread;

                Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

                SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

                if( *(DisplayPayload+0) == 0x01000000)
                {
                    return fiLinkSvc_Cmd_Status_RJT;
                }
                else
                {
                    return fiLinkSvc_Cmd_Status_ACC;
                }

            }
        }
        else
        {
            if( ( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ) == 0x05000000)
            {    /* Xfer ready */

                OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

                if (OX_ID < CDBThread_X_ID_Max )
                {

                    CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                                + (OX_ID * CDBThread_MemoryDescriptor->elementSize));

                    fiLogDebugString(hpRoot,
                                    SF_FCP_LogConsoleLevel,
                                    "XRDY CDB %p X_ID %X",
                                    (void *)agNULL,(char *)agNULL,
                                    CDBThread,(void *)agNULL,
                                    OX_ID,
                                    0,0,0,0,0,0,0);


                    *Thread_to_return = (fi_thread__t *)CDBThread;

                    CDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY;
                    CDBThread->CDB_CMND_Status= SFThread_SF_CMND_Status_CDB_FC_TapeInitiatorReSend_Data;

                    return fiLinkSvc_Cmd_Status_FC_Tape_XRDY;

                }

            }
            else
            {
                fiLogDebugString(hpRoot,
                            SF_FCP_LogConsoleLevel,
                            "( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ) == %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            ( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ),
                            0,0,0,0,0,0,0);

                *Thread_to_return = (fi_thread__t *)agNULL;
                return fiLinkSvc_Cmd_Status_Confused;
            }
        }
    }

    if ((hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type) + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Recv_ELS_Type = hpSwapBit32(Payload->ELS_Type);
    }
    else
    {
        Recv_ELS_Type = hpSwapBit32(Payload_Wrapped->ELS_Type);
    }

    if ((Recv_ELS_Type & FC_ELS_Type_LoopInit_Code_MASK) == FC_ELS_Type_LoopInit_Code_LILP)
    {
        fiLinkSvcProcess_LILP_OffCard(
                                       hpRoot,
                                       Frame_Length,
                                       FCHS,
                                       (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)Payload,
                                       Payload_Wrap_Offset,
                                       (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)Payload_Wrapped
                                     );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Position_Map;
    }

    Recv_ELS_Type &= FC_ELS_Type_MASK;

    if ((TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        if (Recv_ELS_Type == FC_ELS_Type_PLOGI)
        {
            return fiLinkSvcProcess_PLOGI_Request_OffCard(
                                                           hpRoot,
                                                           OX_ID,
                                                           Frame_Length,
                                                           FCHS,
                                                           (FC_ELS_PLOGI_Payload_t *)Payload,
                                                           Payload_Wrap_Offset,
                                                           (FC_ELS_PLOGI_Payload_t *)Payload_Wrapped,
                                                           Thread_to_return
                                                         );
        }
#ifdef _DvrArch_1_30_
        else if (Recv_ELS_Type == FC_ELS_Type_FARP_REQ)
	{
            return fiLinkSvcProcess_FARP_Request_OffCard(
                                                           hpRoot,
                                                           OX_ID,
                                                           Frame_Length,
                                                           FCHS,
                                                           (FC_ELS_FARP_REQ_Payload_t *)Payload,
                                                           Payload_Wrap_Offset,
                                                           (FC_ELS_FARP_REQ_Payload_t *)Payload_Wrapped,
                                                           Thread_to_return
                                                         );
	}
#endif /* _DvrArch_1_30_ was defined */
        else /* Recv_ELS_Type != FC_ELS_Type_PLOGI or FC_ELS_Type_FARP_REQ */
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard(): Recv_ELS_Type(=0x%08X) != FC_ELS_Type_PLOGI",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_ELS_Type,
                              0,0,0,0,0,0,0
                            );

            fiLinkSvcProcess_TargetRequest_OffCard(
                                                    hpRoot,
                                                    Frame_Length,
                                                    FCHS,
                                                    (void *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (void *)Payload_Wrapped
                                                  );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_TargetRequest;
        }
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        /* Starting here, this function only understands ELS Responses */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                          );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "R_CTL__D_ID 0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          R_CTL__D_ID,
                          0,0,0,0,0,0,0
                         );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((Recv_ELS_Type != FC_ELS_Type_LS_RJT)
#ifdef _DvrArch_1_30_
        && (Recv_ELS_Type != FC_ELS_Type_FARP_REPLY)
#endif /* _DvrArch_1_30_ was defined */
        && (Recv_ELS_Type != FC_ELS_Type_ACC))
    {
        /* Starting here, this function only understands ELS Responses (i.e. Rejects and Accepts) */
        if(Frame_Length == 0x20)
        { /* Find where this is spec'd out - F_RJT Link control frames */
            if( (R_CTL__D_ID & 0xff000000) == 0xC3000000 )
            {

                    if ( (OX_ID > SFThread_X_ID_Max))
                    {
                        fiLogDebugString(
                                          hpRoot,
                                          LinkSvcLogConsoleLevel,
                                          "fiLinkSvcProcessSFQ_OffCard():",
                                          (char *)agNULL,(char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          0,0,0,0,0,0,0,0
                                        );

                        fiLogDebugString(
                                          hpRoot,
                                          LinkSvcLogConsoleLevel,
                                          "   (OX_ID > SFThread_X_ID_Max)",
                                          (char *)agNULL,(char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          0,0,0,0,0,0,0,0
                                        );

                        fiLogDebugString(
                                          hpRoot,
                                          LinkSvcLogConsoleLevel,
                                          " SF Rej    OX_ID==0x%08X",
                                          (char *)agNULL,(char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          OX_ID,
                                          0,0,0,0,0,0,0
                                        );
                    }

                SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                          + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

                *Thread_to_return = (fi_thread__t *)SFThread;

                Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

                SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

                return fiLinkSvc_Cmd_Status_RJT;
            }
            else
            {   /* With Vixel should not take this branch */
                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLogConsoleLevel,
                                  "Fail R_CTL__D_ID 0x%08X",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  R_CTL__D_ID,
                                  0,0,0,0,0,0,0
                                 );
                if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
                {
                    fiLogDebugString(
                                      hpRoot,
                                      LinkSvcLogConsoleLevel,
                                      "fiLinkSvcProcessSFQ_OffCard():",
                                      (char *)agNULL,(char *)agNULL,
                                      (void *)agNULL,(void *)agNULL,
                                      0,0,0,0,0,0,0,0
                                    );

                    fiLogDebugString(
                                      hpRoot,
                                      LinkSvcLogConsoleLevel,
                                      "   (OX_ID > SFThread_X_ID_Max)",
                                      (char *)agNULL,(char *)agNULL,
                                      (void *)agNULL,(void *)agNULL,
                                      0,0,0,0,0,0,0,0
                                    );

                    fiLogDebugString(
                                      hpRoot,
                                      LinkSvcLogConsoleLevel,
                                      "B    OX_ID==0x%08X",
                                      (char *)agNULL,(char *)agNULL,
                                      (void *)agNULL,(void *)agNULL,
                                      OX_ID,
                                      0,0,0,0,0,0,0
                                    );

                }

                SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                          + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

                *Thread_to_return = (fi_thread__t *)SFThread;

                Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

                SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;


                return fiLinkSvc_Cmd_Status_RJT;
            }

        }


        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (Recv_ELS_Type != FC_ELS_Type_LS_RJT) && (Recv_ELS_Type != FC_ELS_Type_ACC)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    Recv_ELS_Type==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Recv_ELS_Type,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "R_CTL__D_ID 0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          R_CTL__D_ID,
                          0,0,0,0,0,0,0
                         );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "%s %p %08X %08X %08X",
                          "REJ_Response",(char *)agNULL,
                          DisplayPayload,(void *)agNULL,
                          hpSwapBit32(* DisplayPayload ),
                          hpSwapBit32(*(DisplayPayload+1)),
                          hpSwapBit32(*(DisplayPayload+2)),
                          0,0,0,0,0 );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;

    Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

    if (Recv_ELS_Type == FC_ELS_Type_LS_RJT)
    {
        /* Simply indicate that the command was rejected */
        RejectReason = hpSwapBit32( *(DisplayPayload+1));
        SFThread->RejectReasonCode = (os_bit8)((RejectReason & FC_ELS_LS_RJT_Reason_Code_MASK ) >>  FC_ELS_LS_RJT_Reason_Code_Shift);
        SFThread->RejectExplanation = (os_bit8)((RejectReason & FC_ELS_LS_RJT_Reason_Explanation_MASK ) >> FC_ELS_LS_RJT_Reason_Explanation_Shift );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard(): ELS Command [0x%08X] rejected %08X %08X %x %x %x",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Sent_LinkSvc_Type,
                          hpSwapBit32( *(DisplayPayload+0)),
                          hpSwapBit32( *(DisplayPayload+1)),
                          RejectReason,
                          SFThread->RejectReasonCode,
                          SFThread->RejectExplanation,
                          0,0 );

        fiLogDebugString(hpRoot,
                        LinkSvcLogConsoleLevel,
                        "FCHS %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard(): Frame_Length %X ",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Frame_Length,
                          0,0,0,0,0,0,0
                        );

        return fiLinkSvc_Cmd_Status_RJT;
    }

    switch(Sent_LinkSvc_Type)
    {
        case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
            fiLinkSvcProcess_PLOGI_Response_OffCard(
                                                     SFThread,
                                                     Frame_Length,
                                                     FCHS,
                                                     (FC_ELS_ACC_PLOGI_Payload_t *)Payload,
                                                     Payload_Wrap_Offset,
                                                     (FC_ELS_ACC_PLOGI_Payload_t *)Payload_Wrapped
                                                   );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
            fiLinkSvcProcess_FLOGI_Response_OffCard(
                                                     SFThread,
                                                     Frame_Length,
                                                     FCHS,
                                                     (FC_ELS_ACC_FLOGI_Payload_t *)Payload,
                                                     Payload_Wrap_Offset,
                                                     (FC_ELS_ACC_FLOGI_Payload_t *)Payload_Wrapped
                                                   );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_LOGO:
            fiLinkSvcProcess_LOGO_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_RRQ:
            fiLinkSvcProcess_RRQ_Response_OffCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   FCHS,
                                                   (FC_ELS_ACC_RRQ_Payload_t *)Payload,
                                                   Payload_Wrap_Offset,
                                                   (FC_ELS_ACC_RRQ_Payload_t *)Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLI:
            fiLinkSvcProcess_PRLI_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_ACC_PRLI_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_ACC_PRLI_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLO:
            fiLinkSvcProcess_PRLO_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_ACC_PRLO_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_ACC_PRLO_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_ADISC:
            /* ADISC can fail verification */
            return ( fiLinkSvcProcess_ADISC_Response_OffCard(
                                                     SFThread,
                                                     Frame_Length,
                                                     FCHS,
                                                     (FC_ELS_ACC_ADISC_Payload_t *)Payload,
                                                     Payload_Wrap_Offset,
                                                     (FC_ELS_ACC_ADISC_Payload_t *)Payload_Wrapped
                                                   ));

        case SFThread_SF_CMND_LinkSvc_Type_SCR:
               /* We just recieve an ACCept or a REJect from SCR. No processing of the payload
               is required. */
            break;

        case SFThread_SF_CMND_LinkSvc_Type_SRR:
            fiLinkSvcProcess_SRR_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_REC:
            fiLinkSvcProcess_REC_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_REC_ACC_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_REC_ACC_Payload_t *)Payload_Wrapped
                                                  );
            break;
#ifdef _DvrArch_1_30_
        case SFThread_SF_CMND_LinkSvc_Type_FARP_REQ:
            fiLinkSvcProcess_FARP_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_FARP_REPLY_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_FARP_REPLY_Payload_t *)Payload_Wrapped
                                                  );
            break;
#endif /* _DvrArch_1_30_ was defined */
        default:
            /* Unknown LinkSvc Command recorded in SFThread */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                            hpRoot,
                            LinkSvcLogConsoleLevel,
                            "B SFThread %p LinkSvc Command [0x%02X] Class [0x%02X] State [0x%02X]",
                            (char *)agNULL,(char *)agNULL,
                            SFThread,(void *)agNULL,
                            (os_bit32)SFThread->SF_CMND_Class,
                            (os_bit32)SFThread->SF_CMND_Type,
                            (os_bit32)SFThread->SF_CMND_State,
                            0,0,0,0,0
                            );
            return fiLinkSvc_Cmd_Status_Confused;
    }

    return fiLinkSvc_Cmd_Status_ACC;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInADISC_ACC(
                                   SFThread_t *SFThread,
                                   os_bit32       D_ID,
                                   os_bit32       OX_ID
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInADISC_ACC_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInADISC_ACC_OffCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID
                                    );
    }

}

os_bit32 fiFillInADISC_ACC_OnCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot               = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread              = CThread_ptr(hpRoot);
    os_bit32        ADISC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        ADISC_Payload_Offset = ADISC_Header_Offset + sizeof(FCHS_t);
    os_bit32        Bit8_Index;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );


/*+
Fill in ADISC Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_ACC )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               Hard_Address_of_Originator
                                                             ),
                         hpSwapBit32(   (CThread->ChanInfo.CurrentAddress.Domain << 16)
                                      | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                                      | CThread->ChanInfo.CurrentAddress.AL_PA          )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Port_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Node_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               N_Port_ID_of_Originator
                                                             ),
                         hpSwapBit32(S_ID )
                       );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInADISC_ACC_OffCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread             = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t            *DevThread           = SFThread->parent.Device;
    FCHS_t                 *ADISC_Header        = SFThread->SF_CMND_Ptr;
    FC_ELS_ADISC_Payload_t *ADISC_Payload       = (FC_ELS_ADISC_Payload_t *)((os_bit8 *)ADISC_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;
    os_bit32                   S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    D_ID  = fiComputeDevThread_D_ID(DevThread);
                                                           
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence
                                  );

/*+
Fill in ADISC Frame Payload
-*/

    ADISC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_ACC );

    ADISC_Payload->Hard_Address_of_Originator
        = hpSwapBit32(   (CThread->ChanInfo.CurrentAddress.Domain << 16)
                       | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                       | CThread->ChanInfo.CurrentAddress.AL_PA          );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Port_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Node_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    ADISC_Payload->N_Port_ID_of_Originator
        = hpSwapBit32( S_ID
                     );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInSRR(
                    SFThread_t *SFThread,
                    os_bit32       OXID,
                    os_bit32       RXID,
                    os_bit32       Relative_Offset,
                    os_bit32       R_CTL
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInSRR_OnCard(
                                    SFThread,
                                    OXID, 
                                    RXID,
                                    Relative_Offset,
                                    R_CTL
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInSRR_OffCard(
                                     SFThread,
                                     OXID,
                                     RXID,
                                     Relative_Offset,
                                     R_CTL
                                   );
    }
}

os_bit32 fiFillInSRR_OnCard(
                           SFThread_t *SFThread,
                           os_bit32       OXID,
                           os_bit32       RXID,
                           os_bit32       Relative_Offset,
                           os_bit32       R_CTL
                        )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        SRR_Header_Offset   = SFThread->SF_CMND_Offset;
    os_bit32        SRR_Payload_Offset  = SRR_Header_Offset + sizeof(FCHS_t);
    os_bit32        S_ID=0;
    os_bit32        D_ID;
    os_bit32        OXID_RXID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SRR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SRR Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in SRR Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         SRR_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_SRR_Payload_t,
                                                              ELS_Type
                                                            ),
                         hpSwapBit32( FC_ELS_Type_SRR )
                       );

    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         SRR_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_SRR_Payload_t,
                                                              Relative_Offset
                                                            ),
                         hpSwapBit32(Relative_Offset)
                       );

    OXID_RXID       =       (OXID << FC_ELS_SRR_OXID_SHIFT) | RXID;

    osCardRamWriteBit32(
                        hpRoot,
                        SRR_Payload_Offset + hpFieldOffset(
                                                            FC_ELS_SRR_Payload_t,
                                                            OXID_RXID
                                                           ),
                        hpSwapBit32(OXID_RXID)
                        );
 

/*+
Return length of SRR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SRR_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInSRR_OffCard(
                            SFThread_t *SFThread,
                            os_bit32       OXID,
                            os_bit32       RXID,
                            os_bit32       Relative_Offset,
                            os_bit32       R_CTL
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    CDBThread_t           *CdbThread    = SFThread->parent.CDB;
    DevThread_t           *DevThread    = CdbThread->Device;
    FCHS_t                *SRR_Header   = SFThread->SF_CMND_Ptr;
    FC_ELS_SRR_Payload_t  *SRR_Payload  = (FC_ELS_SRR_Payload_t *)((os_bit8 *)SRR_Header + sizeof(FCHS_t));
/*    os_bit32                  Bit8_Index; */
    os_bit32                  S_ID=0;
    os_bit32                  D_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SRR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SRR Frame Header
-*/

    D_ID =  fiComputeDevThread_D_ID( DevThread); 
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in SRR Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    
    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "Out %s D_ID %X S_ID %0X OXID %X RXID %X",
                    "fiFillInSRR_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    D_ID,
                    S_ID,
                    OXID,
                    RXID,
                    0,0,0,0);

    OXID = 0xFFFF;

    SRR_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_SRR );

/* ??????? Switched oxid and rxid */
    SRR_Payload->OXID_RXID     = hpSwapBit32(( RXID << FC_ELS_SRR_OXID_SHIFT) |OXID);

/* Was this
    SRR_Payload->OXID_RXID = hpSwapBit32((OXID << FC_ELS_SRR_OXID_SHIFT) | RXID);
*/        

    SRR_Payload->Relative_Offset       =  hpSwapBit32(Relative_Offset);
    SRR_Payload->R_CTL_For_IU_Reserved =  hpSwapBit32(R_CTL << FC_ELS_R_CTL_FOR_IU_SHIFT);

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "Out %s OXID_RXID %08X Relative_Offset %08X R_CTL_For_IU_Reserved %08X",
                    "fiFillInSRR_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SRR_Payload->OXID_RXID,
                    SRR_Payload->Relative_Offset,
                    SRR_Payload->R_CTL_For_IU_Reserved,
                    0,0,0,0,0);
/*+
Return length of SRR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SRR_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_SRR_Response_OnCard(
                                   SFThread_t *SFThread,
                                   os_bit32     Frame_Length,
                                   os_bit32     Offset_to_FCHS,
                                   os_bit32     Offset_to_Payload,
                                   os_bit32     Payload_Wrap_Offset,
                                   os_bit32     Offset_to_Payload_Wrapped
                                 )
{
#ifndef __MemMap_Force_Off_Card__
/* 
    os_bit32                                         SRR_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         SRR_Payload_To_Copy;
    os_bit32                                         Bit8_Index;
*/
#endif /* __MemMap_Force_Off_Card__ */
 }

void fiLinkSvcProcess_SRR_Response_OffCard(
                                    SFThread_t                                    *SFThread,
                                    os_bit32                                         Frame_Length,
                                    FCHS_t                                       *FCHS,
                                    FC_ELS_GENERIC_ACC_Payload_t                 *Payload,
                                    os_bit32                                         Payload_Wrap_Offset,
                                    FC_ELS_GENERIC_ACC_Payload_t                 *Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__
/*
    os_bit32                                         SRR_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         SRR_Payload_To_Copy;
    os_bit32                                         Bit8_Index;
*/
 
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInREC(
                    SFThread_t *SFThread,
                    os_bit32       OXID,
                    os_bit32       RXID
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInREC_OnCard(
                                    SFThread,
                                    OXID,
                                    RXID
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInREC_OffCard(
                                     SFThread,
                                    OXID,
                                    RXID
                                   );
    }
}

os_bit32 fiFillInREC_OnCard(
                           SFThread_t *SFThread,
                           os_bit32       OXID,
                           os_bit32       RXID
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    CDBThread_t           *CdbThread    = SFThread->parent.CDB;
    DevThread_t           *DevThread    = CdbThread->Device;
    os_bit32        REC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        REC_Payload_Offset = REC_Header_Offset + sizeof(FCHS_t);
/*    os_bit32        Bit8_Index; */
    os_bit32        S_ID=0;
    os_bit32        D_ID;
    os_bit32        OXID_RXID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_REC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    OXID_RXID   = (OXID << FC_ELS_SRR_OXID_SHIFT) | RXID;
/*+
Fill in REC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in REC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         REC_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_REC_Payload_t,
                                                              ELS_Type
                                                            ),
                         hpSwapBit32( FC_ELS_Type_REC )
                       );

    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         REC_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_REC_Payload_t,
                                                              Reserved_ExChOriginatorSid
                                                            ),
                         hpSwapBit32(S_ID)
                       );

    
    osCardRamWriteBit32(
                         hpRoot,
                         REC_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_REC_Payload_t,
                                                              OXID_RXID
                                                            ),
                         hpSwapBit32(OXID_RXID)
                       );

    

/*+
Return length of REC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_REC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInREC_OffCard(
                            SFThread_t *SFThread,
                            os_bit32       OXID,
                            os_bit32       RXID
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    CDBThread_t           *CDBThread    = SFThread->parent.CDB;
    DevThread_t           *DevThread    = CDBThread->Device;
    FCHS_t                *REC_Header   = SFThread->SF_CMND_Ptr;
    FC_ELS_REC_Payload_t  *REC_Payload  = (FC_ELS_REC_Payload_t *)((os_bit8 *)REC_Header + sizeof(FCHS_t));
    os_bit32                  S_ID=0;
    os_bit32                  D_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_REC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in REC Frame Header
-*/

    D_ID =  fiComputeDevThread_D_ID( DevThread); 
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in REC Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    
    REC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_REC );

    REC_Payload->Reserved_ExChOriginatorSid  = hpSwapBit32(S_ID);
/* ??????? Switched oxid and rxid */

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        RXID = CDBThread->X_ID | X_ID_Read;
        REC_Payload->OXID_RXID     = hpSwapBit32(( RXID << FC_ELS_SRR_OXID_SHIFT) |OXID);
    }
    REC_Payload->OXID_RXID     = hpSwapBit32(( RXID << FC_ELS_SRR_OXID_SHIFT) |OXID);

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "Out %s ExChOriginatorSid %08X OX_ID RX_ID %08X OXID %x RXID %x",
                    "fiFillInREC_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    REC_Payload->Reserved_ExChOriginatorSid,
                    REC_Payload->OXID_RXID,
                    OXID,
                    RXID,
                    0,0,0,0);

   

/*+
Return length of REC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_REC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_REC_Response_OnCard(
                                   SFThread_t *SFThread,
                                   os_bit32     Frame_Length,
                                   os_bit32     Offset_to_FCHS,
                                   os_bit32     Offset_to_Payload,
                                   os_bit32     Payload_Wrap_Offset,
                                   os_bit32     Offset_to_Payload_Wrapped
                                 )
{
#ifndef __MemMap_Force_Off_Card__
/*    
    os_bit32                                         REC_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         REC_Payload_To_Copy;
    os_bit32                                         Bit8_Index;
*/
 
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_REC_Response_OffCard(
                                    SFThread_t               * SFThread,
                                    os_bit32                   Frame_Length,
                                    FCHS_t                   * FCHS,
                                    FC_ELS_REC_ACC_Payload_t * Payload,
                                    os_bit32                   Payload_Wrap_Offset,
                                    FC_ELS_REC_ACC_Payload_t * Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__
/*      
    os_bit32   REC_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32   REC_Payload_To_Copy;
    os_bit32   Bit8_Index;
*/
    CDBThread_t           *CdbThread    = SFThread->parent.CDB;

    os_bit32 * REC_Payload= (os_bit32 *) Payload;

    CdbThread->FC_Tape_ExchangeStatusBlock = hpSwapBit32(* (REC_Payload + 5));
    /*
    CdbThread->FC_Tape_ExchangeStatusBlock &= FC_REC_ESTAT_Mask;
    */
    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "%s %08X %08X %08X",
                    "fiLinkSvcProcess_REC_Response_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(* (REC_Payload + 0)),
                    hpSwapBit32(* (REC_Payload + 1)),
                    hpSwapBit32(* (REC_Payload + 2)),
                    0,0,0,0,0);

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "%s %08X XFER %08X ESTAT %08X",
                    "fiLinkSvcProcess_REC_Response_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(* (REC_Payload + 3)),
                    hpSwapBit32(* (REC_Payload + 4)),
                    hpSwapBit32(* (REC_Payload + 5)),
                    0,0,0,0,0);


#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
void fiLinkSvcProcess_FARP_Response_OffCard(
                                    SFThread_t                  * SFThread,
                                    os_bit32                      Frame_Length,
                                    FCHS_t                      * FCHS,
                                    FC_ELS_FARP_REPLY_Payload_t * Payload,
                                    os_bit32                      Payload_Wrap_Offset,
                                    FC_ELS_FARP_REPLY_Payload_t * Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__
    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "fiLinkSvcProcess_FARP_Response_OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#endif /* __MemMap_Force_On_Card__ was not defined */
}
#endif /* _DvrArch_1_30_ was defined */

/* void linksvc_c(void){}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\isr.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    ISR.c

Abstract:

    This is the Interrupt service routine for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only
 
Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/ISR.C $
 
Revision History:

    $Revision: 6 $
    $Date: 10/30/00 4:59p $
    $Modtime:: 10/30/00 2:31p          $
 
--*/

#include "buildop.h"
#include "osflags.h"

#ifdef _DEBUG_EVENTLOG_
BOOLEAN LogScsiError(agRoot_t            *hpRoot,
                     PSCSI_REQUEST_BLOCK pSrb ,
                     agFcpRspHdr_t  * pResponseHeader,
                     ULONG           hpIOInfoLen);
#endif

#ifdef DOUBLE_BUFFER_CRASHDUMP
extern ULONG gCrashDumping;
#endif

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)       //+++++++++++++++++++++++++
void _DebugStall_(IN PCARD_EXTENSION pCard)
{
    ULONG   x;
    for (x=0; x < STALL_COUNT_MAX;x++)
    {
        if ( pCard->StallData[x].Address && pCard->StallData[x].MicroSec)
            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreInterrupt: _DebugStall_ %d mis at %x\n",
                pCard->StallData[x].MicroSec,
                pCard->StallData[x].Address));
    }
    return;
}
#endif

BOOLEAN
HPFibreInterrupt(
    IN PCARD_EXTENSION pCard
    )

/*++

Routine Description:

    This is the interrupt service routine for the HBA. It reads the
    interrupt register and the IMQ indices to determine if the adapter
    is indeed the source of the interrupt and clears the interrupt at
    the device.

Arguments:

    CardExtension - HBA miniport driver's adapter data storage
 
Return Value:

    TRUE  - if interrupt handled by this routine
    FALSE - if a spurious interrupt occured

/--*/

{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    pCard->State |= CS_DURING_ISR;
 
    // pCard->Perf_ptr->inOsIsr      = get_hi_time_stamp();
 
    osDEBUGPRINT((DMOD,"IN HPFibreInterrupt  pCard %lx osData %lx fcData %lx\n", pCard,hpRoot->osData,hpRoot->fcData ));
 
    // pCard->Perf_ptr->inFcIsr      = get_hi_time_stamp();
 
    if(!fcInterruptHandler( hpRoot ))
    {
        osDEBUGPRINT((DMOD,"Not my interrupt pCard %lx\n", pCard ));
        pCard->State &= ~CS_DURING_ISR;
        return(FALSE); // Not my interrupt
    }
   
    pCard->Number_interrupts++;

    // pCard->Perf_ptr->outFcIsr     = get_hi_time_stamp();
    // pCard->Perf_ptr->inFcDIsr     = get_hi_time_stamp();

    #if defined(_DEBUG_STALL_ISSUE_) && defined(i386)       //+++++++++++++++++++++++++
    memset( pCard->StallData, 0, sizeof(pCard->StallData) );
    pCard->StallCount=0;
    #endif                                                  //-------------------------
    
    fcDelayedInterruptHandler( hpRoot  );

    if (pCard->LinkState == LS_LINK_UP && pCard->AdapterQ.Head)
        Startio (pCard);

    // pCard->Perf_ptr->outFcDIsr    = get_hi_time_stamp();
    // pCard->Perf_ptr->outOsIsr     = get_hi_time_stamp();
    
    #if defined(_DEBUG_STALL_ISSUE_) && defined(i386)       //++++++++++++++++++++++++++
    if (pCard->StallCount > 450*1000)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreInterrupt: osStallThread total in ISR %d ms\n",pCard->StallCount));
        _DebugStall_(pCard);
    }
    #endif                                                  //--------------------------

    pCard->State &= ~CS_DURING_ISR;
    return TRUE;

} // end HPFibreInterrupt()



/*++

Routine Description:

    This is a callback from FC layer to indicate IO completion
 
Arguments:

    hpRoot      - HBA miniport driver's adapter data storage
    hpIORequest - Agilent IO request structure
    hpIOStatus  - IO status
    hpIOInfoLen - the length of available FC status payload

Return Value:

    none
 
/--*/

osGLOBAL void osIOCompleted(
    agRoot_t      *hpRoot,
    agIORequest_t *phpIORequest,
    os_bit32       hpIOStatus,
    os_bit32       hpIOInfoLen
    )
{
    PCARD_EXTENSION pCard = NULL;
    PSRB_EXTENSION pSrbExt = NULL;
    PSCSI_REQUEST_BLOCK pSrb = NULL;
    PLU_EXTENSION plunExtension = NULL;
   
    #ifdef YAM2_1
    PA_DEVICE                  *dev;
    BOOLEAN                    cmdTypeInquiry=FALSE;
    ULONG                      srbDataLength;
    #endif
    agFcpRspHdr_t * pFcResponse=NULL;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
 
    pCard->State |= CS_DURING_OSCOMPLETE;
    
    #ifdef _DEBUG_LOSE_IOS_
    if(pCard->Srb_IO_Count > (1024*60) && !(pCard->Srb_IO_Count % 1024  ))
    {
        osDEBUGPRINT((ALWAYS_PRINT,"Losing this IO Request !!!! %lx Count %x  SrbExt %lx\n",
                            phpIORequest,
                            pCard->Srb_IO_Count,
                            phpIORequest->osData ));
        return;
    }

    osDEBUGPRINT((DMOD,"IN osIOCompleted hpRoot %lx Request %lx  Status %x len %x\n", hpRoot, phpIORequest, hpIOStatus,hpIOInfoLen));

    #endif // _DEBUG_LOSE_IOS_

    // get the SRBextension 
    pSrbExt = hpObjectBase(SRB_EXTENSION,hpIORequest,phpIORequest);
    pSrbExt->SRB_State = RS_COMPLETE;

    if( ! phpIORequest->osData )
    {
        osDEBUGPRINT((ALWAYS_PRINT,"phpIORequest->osData is NULL  GOODBYE !\n" ));
        return;
    }

    phpIORequest->osData = NULL;
    pSrb = pSrbExt->pSrb;
    // PERF pSrbExt->Perf_ptr->inOsIOC      = get_hi_time_stamp();
 
    if( phpIORequest != &pSrbExt->hpIORequest)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"phpIORequest %lx != &pSrbExt->hpIORequest %xlx\n",
        phpIORequest, &pSrbExt->hpIORequest ));
    }



    // get the lu extension
    plunExtension = pSrbExt->pLunExt;

    osDEBUGPRINT((DMOD,"pSrb %lx pFcResponse %lx LUext %lx\n", pSrb, pFcResponse, plunExtension  ));
 
    osDEBUGPRINT((DMOD,"osIOCompleted: CDB %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x pCDB %lx\n",
                 pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                 pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], &pSrb->Cdb[0] ));
    osDEBUGPRINT((DMOD, "osIOCompleted: hpIOStatus = %d, PathId = %d, TargetId %d, Lun = %d\n",
                 hpIOStatus, pSrb->PathId, pSrb->TargetId, pSrb->Lun));
 
    #ifdef DOUBLE_BUFFER_CRASHDUMP
    // if we are in the crashdump path
    // then we will copy back the buffer before further
    // processing..
    if(gCrashDumping)
    {
        if(pSrb->Cdb[0] == 0x2a)
        {
            if(pSrbExt->orgDataBuffer)
            {
                // we would have made a local copy
                pSrb->DataBuffer = pSrbExt->orgDataBuffer;
                // re-init pointers..
                pSrbExt->orgDataBuffer = NULL;
                osZero(pCard->localDataBuffer, ( 8 * 1024 ));
            }
        }
    }

    #endif //  DOUBLE_BUFFER

    // get the IO status
    switch(hpIOStatus)
    {
        case osIOSuccess:

            #ifdef _DEBUG_REPORT_LUNS_
            {
                if ((pSrb->Cdb[0] == 0xa0) && (hpIOInfoLen == 0)) 
                {
                    PrintReportLunData(pSrb);
                }
            }
            #endif
            pSrb->SrbStatus = SRB_STATUS_SUCCESS;

            // check for inquiry commands
            if ((pSrb->Cdb[0] == SCSIOP_INQUIRY) && (hpIOInfoLen == 0)) 
            {
                #ifndef YAM2_1
                if (pSrb->DataTransferLength >= 1)
                    plunExtension->deviceType = (*((UCHAR *)(pSrb->DataBuffer))) & 0x1f;

                if ((pSrb->PathId < 4) && (pSrb->Lun == 0) && (pSrb->DataTransferLength >= 32))
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                #else
                // handle any devices that requires special attention
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                cmdTypeInquiry = TRUE;
                #endif               
                    
                #ifdef _DEBUG_EVENTLOG_
                #ifndef YAM2_1
                {
                if (MapToHandle(pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun, NULL))
                {
                    osCopy(plunExtension->InquiryData, pSrb->DataBuffer, MIN(pSrb->DataTransferLength, 36) );
                    plunExtension->InquiryData[36] = 0; 
                    fcGetDeviceInfo (hpRoot, plunExtension->phandle, &plunExtension->devinfo );
                    if (!osMemCompare(plunExtension->devinfo.NodeWWN, plunExtension->WWN, 8) )
                    {
                        LogEvent(pCard, NULL, HPFC_MSG_SHOWDEVICENAME, NULL, 0,
                            "%02x%02x%02x%02x %02x%02x%02x%02x (%s)",
                            plunExtension->devinfo.NodeWWN[0],plunExtension->devinfo.NodeWWN[1],
                            plunExtension->devinfo.NodeWWN[2],plunExtension->devinfo.NodeWWN[3],
                            plunExtension->devinfo.NodeWWN[4],plunExtension->devinfo.NodeWWN[5],
                            plunExtension->devinfo.NodeWWN[6],plunExtension->devinfo.NodeWWN[7],
                            plunExtension->InquiryData+8);
                        osCopy(plunExtension->WWN, plunExtension->devinfo.NodeWWN, 8);
                    }
                }
                }
                #endif
                #endif
            }

            if (hpIOInfoLen == 0)
            {
                #ifdef YAM2_1
            
                if (TryOtherAddressingMode(pCard, phpIORequest, pSrbExt, DONT_CHECK_STATUS))
                {
                    return;
                }
                else
                {
                }

                /* now count the number of LUNs */
            
                if ( (cmdTypeInquiry == TRUE) && ( (*(char*)pSrb->DataBuffer) & 0x1f) != 0x1f )
                {
                    SetLunCount(pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);
                  
                    #ifdef _DEBUG_EVENTLOG_
                    dev = pCard->Dev->PaDevice + plunExtension->PaDeviceIndex;
                    if ( ! (plunExtension->LogFlags & PA_DEVICE_ALREADY_LOGGED) )
                    {
                        UCHAR    msg[24];
                        USHORT   *sPtr;
                     
                        osCopy(dev->DevInfo.InquiryData, pSrb->DataBuffer, MIN(pSrb->DataTransferLength, 36) );
                        dev->DevInfo.InquiryData[36] = 0; 
                     
                        osCopy(msg, dev->DevInfo.NodeWWN, 8);
                        msg[8] = pSrb->PathId;
                        msg[9] = pSrb->TargetId;
                        msg[10] = pSrb->Lun;
                        msg[11] = (UCHAR)dev->ModeFlag;                    
                  
                        sPtr = (USHORT *)&msg[12];
                        *sPtr = dev->Index.Pa.FcDeviceIndex;
                  
                        /* unused */
                        msg[14] = 0xaa;
                        msg[15] = 0xaa;
                  
                        osCopy(&msg[16], dev->DevInfo.InquiryData, 8);
                  
                        LogEvent(pCard, NULL, HPFC_MSG_SHOWDEVICENAME, (ULONG*)msg, sizeof(msg)/sizeof(ULONG),
                            "%d:%d:%d (%s)",
                            pSrb->PathId,
                            pSrb->TargetId,
                            pSrb->Lun,
                            dev->DevInfo.InquiryData+8);
                         plunExtension->LogFlags |= PA_DEVICE_ALREADY_LOGGED;
                    }
                    #endif
                }
                #endif
                break;
            }
            // +++++ fall thru.

        case osIOOverUnder:
            #ifdef YAM2_1
            if (pSrb->Cdb[0] == SCSIOP_INQUIRY)  
            cmdTypeInquiry = TRUE;
            #endif
        
        case osIOFailed:
            #ifdef YAM2_1
            srbDataLength = pSrb->DataTransferLength;
            #endif
   
            // Map error sets directly....
            // SrbStatus and ScsiStatus
            // SenseInfoBuffer and SenseInfoBufferLength
            // DataTransferLength
            // Log error as per A.4.11
            osDEBUGPRINT((DMOD,"osIOFailed pSrb %lx pFcResponse %lx LUext %lx Len %x CDB %02x\n", pSrb, pFcResponse, plunExtension, hpIOInfoLen, pSrb->Cdb[0]    ));

            if(hpIOInfoLen)
            {
                // Our response buffer size is only HP_FC_RESPONSE_BUFFER_LEN (128) bytes.
                if (hpIOInfoLen > HP_FC_RESPONSE_BUFFER_LEN)
                    hpIOInfoLen = HP_FC_RESPONSE_BUFFER_LEN;

                pFcResponse = (agFcpRspHdr_t * )&pCard->Response_Buffer[0];


                fcIOInfoReadBlock( hpRoot,
                    phpIORequest,
                    0,
                    pFcResponse,
                    hpIOInfoLen
                    );
               }

            if(Map_FC_ScsiError( pSrbExt->phpRoot,
                              &pSrbExt->hpIORequest,
                              pFcResponse,
                              hpIOInfoLen,
                              pSrb ))
            {
                osDEBUGPRINT((DMOD,"Map Error SRB Status %02x scsi status %02x\n", pSrb->SrbStatus, pSrb->ScsiStatus ));
            }

            #ifdef YAM2_1
            if (TryOtherAddressingMode(pCard,phpIORequest, pSrbExt, CHECK_STATUS))
            {
                pSrb->DataTransferLength = srbDataLength;       /* restore the length, MAP_FC_ScsisError modifies this field */
//              ModifyModeBeforeStartIO (plunExtension, &pSrbExt->hpRequestBody);
                return;
            }
            else
            {
//          osDEBUGPRINT((ALWAYS_PRINT,"TryOtherAddressingMode: no need to resend 2\n"));
            }
        
            if ( (cmdTypeInquiry == TRUE) && ( (*(char*)pSrb->DataBuffer) & 0x1f) != 0x1f )
            {
                SetLunCount(pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);
              
                #ifdef _DEBUG_EVENTLOG_
                dev = pCard->Dev->PaDevice + plunExtension->PaDeviceIndex;
                if ( ! (plunExtension->LogFlags & PA_DEVICE_ALREADY_LOGGED) )
                {
                    UCHAR    msg[24];
                    USHORT   *sPtr;
                 
                    osCopy(dev->DevInfo.InquiryData, pSrb->DataBuffer, MIN(pSrb->DataTransferLength, 36) );
                    dev->DevInfo.InquiryData[36] = 0; 
                 
                    osCopy(msg, dev->DevInfo.NodeWWN, 8);
                    msg[8] = pSrb->PathId;
                    msg[9] = pSrb->TargetId;
                    msg[10] = pSrb->Lun;
                    msg[11] = (UCHAR)dev->ModeFlag;                    
              
                    sPtr = (USHORT *)&msg[12];
                    *sPtr = dev->Index.Pa.FcDeviceIndex;
              
                    /* unused */
                    msg[14] = 0xaa;
                    msg[15] = 0xaa;
              
                    osCopy(&msg[16], dev->DevInfo.InquiryData, 8);
              
                    LogEvent(pCard, NULL, HPFC_MSG_SHOWDEVICENAME, (ULONG*)msg, sizeof(msg)/sizeof(ULONG),
                        "%d:%d:%d (%s)",
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        dev->DevInfo.InquiryData+8);
                    plunExtension->LogFlags |= PA_DEVICE_ALREADY_LOGGED;
                }
                #endif
            }
            #endif
        
            //
            // MUX replies to Inquiry commands sent to non existing targets (behind the MUX)
            // with GOOD fcp status but residue set to fcp data length.
            // Looks like port driver can't deal with this well.
            // To work-around this problem here we convert the SrbStatus to selection timeout.
            //
            if ((pSrb->Cdb[0] == SCSIOP_INQUIRY) && 
                (pSrb->SrbStatus == SRB_STATUS_DATA_OVERRUN) && (pSrb->DataTransferLength == 0))
                pSrb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;

            if (( (pSrb->SrbStatus == SRB_STATUS_SUCCESS) ||
                (pSrb->SrbStatus == SRB_STATUS_DATA_OVERRUN)) &&
                (pSrb->Cdb[0] == SCSIOP_INQUIRY)) 
            {
                if (pSrb->DataTransferLength >= 1)
                    plunExtension->deviceType = (*((UCHAR *)(pSrb->DataBuffer))) & 0x1f;

                #ifndef YAM2_1
                if ((pSrb->PathId < 4) && (pSrb->Lun == 0) && (pSrb->DataTransferLength >= 32))
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                #else
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                #endif
            }

            #ifndef DONT_RETRY_IOS
            if((SRB_STATUS(pSrb->SrbStatus) == SRB_STATUS_ERROR) && 
                (pSrb->ScsiStatus == SCSISTAT_BUSY || pSrb->ScsiStatus == SCSISTAT_QUEUE_FULL) && (RetrySrbOK(pSrb) == TRUE)) 
            {
                phpIORequest->osData = pSrbExt;
                pSrbExt->SRB_State =  RS_WAITING;
                osDEBUGPRINT((ALWAYS_PRINT,"Keeping SCSI status Busy/QueueFull Srb on RetryQ: %08x on pCard: %08x \n", pSrb, pCard));
           
                // Clear status before retrying.
                pSrb->SrbStatus = SRB_STATUS_SUCCESS;
                pSrb->ScsiStatus = SCSISTAT_GOOD;

                SrbEnqueueHead (&pCard->RetryQ, pSrb);
                return;
            }
            #endif //DONT_RETRY_IOS

            #if DBG > 2
            if( pSrbExt->SRB_State & RS_TIMEOUT )
                osDEBUGPRINT((ALWAYS_PRINT,"Failed Completion for a TIMEOUT IO %lx State %08x\n", phpIORequest, pSrbExt->SRB_State  ));
            #endif

            #ifdef _DEBUG_EVENTLOG_
            LogScsiError( pSrbExt->phpRoot,
                              pSrb,
                      pFcResponse,
                       hpIOInfoLen);

            #endif    
            break;
            
        case osIOAborted:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", "osIOAborted" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IO_ABORTED , 
                    NULL, 
                    0, 
                    NULL);
            #endif

            if (pSrbExt->SRB_State ==  RS_TO_BE_ABORTED)
            {
                pSrb->SrbStatus = SRB_STATUS_ABORTED;

            }
            else 
                if(RetrySrbOK(pSrb) == TRUE)
                {
                    phpIORequest->osData = pSrbExt;
                    pSrbExt->SRB_State =  RS_WAITING;
                    osDEBUGPRINT((ALWAYS_PRINT,"Keeping osIOAborted Srb on RetryQ: %08x on pCard: %08x \n", pSrb, pCard));
              
                    // Clear status before retrying.
                    pSrb->SrbStatus = SRB_STATUS_SUCCESS;
                    pSrb->ScsiStatus = SCSISTAT_GOOD;

                    SrbEnqueueHead (&pCard->RetryQ, pSrb);
                    return;
                }
                else
                {
                    pSrb->SrbStatus = SRB_STATUS_ABORTED;
                }
        
           
            break;
            
        case osIOAbortFailed:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", "osIOAbortfailed" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IO_ABORTED , 
                    NULL, 
                    0, 
                    NULL);
              #endif
            pSrb->SrbStatus = SRB_STATUS_ABORTED;
            break;

        case osIODevReset:
            #ifdef DONT_RETRY_IOS                                                    
            pSrb->SrbStatus = SRB_STATUS_BUS_RESET;
            pSrb->ScsiStatus = 0;
            #else
        
            if ((pCard->State & CS_DURING_RESET_ADAPTER) || (RetrySrbOK(pSrb) == FALSE))
            {
                pSrb->SrbStatus = SRB_STATUS_BUS_RESET;
                pSrb->ScsiStatus = 0;
            }
            else
            {
                phpIORequest->osData = pSrbExt;

                pSrbExt->SRB_State =  RS_WAITING;
                osDEBUGPRINT((ALWAYS_PRINT,"Retrying Srb: %08x on pCard: %08x \n", pSrb, pCard));
                SrbEnqueueHead (&pCard->AdapterQ, pSrb);
                return;
            }
            #endif
            break;
        
        case osIODevGone:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", 
                 (hpIOStatus == osIODevGone) ? "osIODevGone" : "osIOInfoBad" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IOCOMPLETION_OTHER_ERROR , 
                    NULL, 
                    0, 
                    "%08x", hpIOStatus);
            #endif
            pSrb->SrbStatus = SRB_STATUS_NO_DEVICE;
            pSrb->ScsiStatus = 0;
            break;

        case osIOInfoBad:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", 
                 (hpIOStatus == osIODevGone) ? "osIODevGone" : "osIOInfoBad" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IOCOMPLETION_OTHER_ERROR , 
                    NULL, 
                    0, 
                    "%08x", hpIOStatus);
            #endif
//            if(gCrashDumping)
//            {   
//                if (!pCard->CDResetCount)
//                {
//                    pCard->CDResetCount++;
//                    pSrb->SrbStatus = SRB_STATUS_BUS_RESET;
//                }
//                else
//                    pSrb->SrbStatus = SRB_STATUS_ERROR;
//            }
//           else
//                pSrb->SrbStatus = SRB_STATUS_ERROR;
            pSrb->SrbStatus = SRB_STATUS_ERROR;
            pSrb->ScsiStatus = 0;
            break;

        
        default:
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IOCOMPLETION_OTHER_ERROR , 
                    NULL, 
                    0, 
                    "%08x", hpIOStatus);
            #endif
            osDEBUGPRINT((ALWAYS_PRINT,"osIO UNKNOWN Failed pSrb %lx pFcResponse %lx LUext %lx CDB %02x\n", pSrb, pFcResponse, plunExtension, pSrb->Cdb[0]  ));

            pSrb->SrbStatus = SRB_STATUS_NO_DEVICE;
            pSrb->ScsiStatus = 0;

    }

    plunExtension->OutstandingIOs--;
    // PERF if(plunExtension->OutstandingIOs < 0)
    // PERF Bad_Things_Happening

    // PERF if(!remove_Srbext( pCard,  pSrbExt))
    // PERF Bad_Things_Happening


    #ifdef DBGPRINT_IO         
    if (gDbgPrintIo & DBGPRINT_DONE )
    {
        static   count;
        UCHAR    *uptr;
        ULONG    paDeviceIndex = 0;
      
        #ifdef YAM2_1
        paDeviceIndex = plunExtension->PaDeviceIndex;
        #endif

        osDEBUGPRINT((ALWAYS_PRINT, " Done(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Sta %x.%x FCP0 %02x%02x PAIx=%d FCHndl=%08x ",
                        count++,
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                        pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9],          
                        pSrb->SrbStatus,
                        pSrb->ScsiStatus,
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[0],
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[1],
                        paDeviceIndex,
                        pSrbExt->pLunExt->phandle));
        if (pSrb->DataTransferLength)
        {
            ULONG x,y;
            ULONG count;
            uptr = (UCHAR *)pSrb->DataBuffer;
            count = pSrb->DataTransferLength/4;
            osDEBUGPRINT((ALWAYS_PRINT, "DATA "));
            for (x=0,y=0; x < MIN(count,4); x++ )
            {
                osDEBUGPRINT((ALWAYS_PRINT, "%02x%02x%02x%02x ", uptr[y],uptr[y+1],uptr[y+2],uptr[y+3]));
                y+=4;
            }
        }
         
        osDEBUGPRINT((ALWAYS_PRINT, "\n"));
      
    }
    #endif   

    pSrbExt->SRB_State = RS_COMPLETE;

    ScsiPortNotification(RequestComplete,
                         pCard,
                         pSrb);

    
    #ifdef DBG
    if ((pSrb->SrbStatus != SRB_STATUS_SUCCESS) && (pSrb->SrbStatus != SRB_STATUS_DATA_OVERRUN))
    {
        osDEBUGPRINT((ALWAYS_PRINT," (in osIOCompleted) Srb Status: %02x for Srb: %08x on Target: %02x\n", pSrb->SrbStatus, pSrb, pSrb->TargetId));
    }
    #endif
    osDEBUGPRINT((DLOW,"OUT osIOCompleted\n" ));

    pCard->State &= ~CS_DURING_OSCOMPLETE;

    // PERF pSrbExt->Perf_ptr->outOsIOC     = get_hi_time_stamp();
} // End osIOCompleted

/*++

Routine Description:

    Checks the inquiry data for any of the special device types like 
    MUX, EMC, HP "OPEN-"(Hitachi DF400) or DLT.
    If the device is any one of the special devices then the device is registered in
    pCard->specialDev[] if the device is not already registered.

Arguments:

    CardExtension  - HBA miniport driver's adapter data storage
    pathID         - SP path ID
    targetID       - SP target ID
    inquiryData    - Inquiry data

Return Value:

    none

/--*/

#ifndef YAM2_1
void
RegisterIfSpecialDev (PCARD_EXTENSION pCard, ULONG pathId, ULONG targetId, char *inquiryData)
{
    char *vendorId, *productId;
    USHORT  devType;
    USHORT  addrMode;
    ULONG   i;
    ULONG   slot;
    ULONG   inqDevType;

    vendorId = inquiryData + 8;
    productId = inquiryData + 16;
    inqDevType = (int)(*inquiryData) & 0x1f;

    if ( (  osMemCompare (vendorId, "CROSSRDS", 8) == TRUE &&
            osMemCompare (productId, "CP4400", 6) == TRUE) ||
         (  osMemCompare (vendorId, "HP      ", 8) == TRUE &&
            osMemCompare (productId, "HPA3308", 7) == TRUE)) 
    {
        // Device is a MUX
        devType = DEV_MUX;
        addrMode = LUN_ADDRESS;
    } 
    else 
        if ( (  osMemCompare (vendorId, "EMC     ", 8) == TRUE &&
                  osMemCompare (productId, "SYMMETRIX", 9) == TRUE) ||
               (  osMemCompare (vendorId, "HP      ", 8) == TRUE &&
                  osMemCompare (productId, "OPEN-", 5) == TRUE)      ||
               (  osMemCompare (vendorId, "HP      ", 8) == TRUE &&
                  osMemCompare (productId, "A5277A", 6) == TRUE) )
        {
            // 
            // Device is of type VOLUME Set, i.e. EMC array or HP's OEM version of the Hitachi DF4000
            //
            devType = DEV_VOLUMESET; // Formerly known as DEV_EMC
            addrMode = VOLUME_SET_ADDRESS;
        }  
        else 
            if (inqDevType == 0xc &&
                osMemCompare (vendorId, "COMPAQ  ", 8) == TRUE) 
            {
                // Device is a COMPAQ disk array
                devType = DEV_COMPAQ;
                addrMode = VOLUME_SET_ADDRESS;
            } 
            else
                devType = DEV_NONE;

    if (devType != DEV_NONE) 
    {
        slot = BUILD_SLOT(pathId, targetId);

        // Check if this device is already registered.
        for (i = 0; i < MAX_SPECIAL_DEVICES; i++) 
        {
            if (pCard->specialDev[i].devType != DEV_NONE &&
                pCard->specialDev[i].devHandleIndex == slot)
                // This device is already registered.
                return;
        }

        // Look for an empty slot in specialDev array
        for (i = 0; i < MAX_SPECIAL_DEVICES; i++) 
        {
            if (pCard->specialDev[i].devType == DEV_NONE)
                break;
        }
    
        if (i == MAX_SPECIAL_DEVICES) 
        {
            // There is no empty slot in specialDev array.
            // Look for a slot where no device is present curretly. It can
            // if there was a device present in the past and is currently
            // removed.
            for (i = 0; i < MAX_SPECIAL_DEVICES; i++) 
            {
                if (pCard->hpFCDev [pCard->specialDev[i].devHandleIndex] == NULL)
                    break;
            }
        }
    
        if (i < MAX_SPECIAL_DEVICES) 
        {
            pCard->specialDev[i].devType = devType;
            pCard->specialDev[i].addrMode = addrMode;
             pCard->specialDev[i].devHandleIndex = slot;
        }
    }
}
#else
void
RegisterIfSpecialDev (PCARD_EXTENSION pCard, ULONG pathId, ULONG targetId, char *inquiryData)
{
    char *vendorId, *productId;
    USHORT  devType;
    USHORT  addrMode;
    ULONG   i;
    ULONG   slot;
    ULONG   inqDevType;

    vendorId = inquiryData + 8;
    productId = inquiryData + 16;
    inqDevType = (int)(*inquiryData) & 0x1f;

    if ((osMemCompare (vendorId, "DGC     ", 8) == TRUE &&
       osMemCompare (productId, "RAID", 4) == TRUE) )
        inquiryData[3] |=0x10;
   
}

#endif
// This structure is not currently used.
UCHAR sense_buffer_data[24]={
//     0    1    2    3    4    5    6    7    8    9
    0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//    10   11   12   13   14   15   16   17   18   19
    0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//    20   21   22   23
    0x00,0x00,0x00,0x00 };



/*++

Routine Description:

    Decode FC Status payload to a corresponding NT status
   
Arguments:

    hpRoot            - HBA miniport driver's adapter data storage
    phpIORequest      - Agilent Common IO request structure
    pResponseHeader   - status payload
    hpIOInfoLen       - payload len
    Srb               - SRB



Return Value:

    TRUE
    FALSE

/--*/

BOOLEAN Map_FC_ScsiError( 
    agRoot_t             *hpRoot,
    agIORequest_t        *phpIORequest,
    agFcpRspHdr_t        *pResponseHeader,
    ULONG                hpIOInfoLen,
    PSCSI_REQUEST_BLOCK  Srb )
{
    UCHAR   valid_fields=0;
    ULONG   Sense_Length=0;
    ULONG   Rsp_Length=0;
    ULONG   Resid_Len=0;
    ULONG   tmp32=0;
    PULONG  ptmp32;
    PUCHAR  ptmp8;
    PUCHAR  psensebuffer=NULL;
    PUCHAR  prspbuffer=NULL;
    PSRB_EXTENSION   pSrbExt;
    PCARD_EXTENSION  pCard;
    ULONG   done = FALSE;

    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    pSrbExt = Srb->SrbExtension;

    osDEBUGPRINT((DMOD,"IN Map_FC_ScsiError root %lx req %lx rsp %lx %x srb %lx\n",
                                   hpRoot, phpIORequest,pResponseHeader,hpIOInfoLen,pSrbExt ));

    // Sanity Check
    if (hpIOInfoLen >= sizeof(agFcpRspHdr_t)) 
    {
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Srb->ScsiStatus  = pResponseHeader->FcpStatus[osFCP_STATUS_SCSI_STATUS];

        #if DBG > 4
        ptmp32 = (PULONG)pResponseHeader;

        if(hpIOInfoLen > 32)
            osDEBUGPRINT((ALWAYS_PRINT,"Rsp %08x %08x %08x %08x %08x %08x %08x %08x\n",
                    *(ptmp32+ 0),*(ptmp32+ 1),*(ptmp32+ 2),*(ptmp32+ 3),
                    *(ptmp32+ 4),*(ptmp32+ 5),*(ptmp32+ 6),*(ptmp32+ 7) ));
        if(hpIOInfoLen > 55)
            osDEBUGPRINT((ALWAYS_PRINT,"Rsp %08x %08x %08x %08x %08x %08x\n",
                   *(ptmp32+ 8),*(ptmp32+ 9),*(ptmp32+10),*(ptmp32+11),
                   *(ptmp32+12), *(ptmp32+13)));
        if(hpIOInfoLen > 95)
            osDEBUGPRINT((ALWAYS_PRINT,"Rsp %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n",
                    *(ptmp32+14),*(ptmp32+15),*(ptmp32+16),*(ptmp32+17),*(ptmp32+18),
                    *(ptmp32+19),*(ptmp32+20),*(ptmp32+21),*(ptmp32+22),*(ptmp32+23)));
        #endif

        valid_fields = pResponseHeader->FcpStatus[osFCP_STATUS_VALID_FLAGS];
        prspbuffer  = &pResponseHeader->FcpRspLen[4]; // go one over

        // verify that the status is valid
        if (valid_fields & osFCP_RSP_LEN_VALID) 
        {
            ptmp32  = (PULONG)&pResponseHeader->FcpRspLen[0];
            Rsp_Length = SWAPDWORD(*ptmp32);
            osDEBUGPRINT((DMOD,"Rsp len valid Rsp %lx (%x) Length %08x\n", prspbuffer, *prspbuffer,Rsp_Length ));
            //
            // Check response code.
            // FcpRspLen[7] is response code.
            //
            if ((Rsp_Length >= 4) && (pResponseHeader->FcpRspLen[7] != 0)) 
            {
                Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                Srb->ScsiStatus = 0;
                done = TRUE;
            }
        }

        // verify that sense buffer is valid
        if ((done == FALSE) && (valid_fields & osFCP_SNS_LEN_VALID)) 
        {
            // status check condition
            if (Srb->ScsiStatus == 2) 
            {
                ptmp32  = (PULONG)&pResponseHeader->FcpSnsLen[0];
                Sense_Length = SWAPDWORD(*ptmp32);
                psensebuffer  = &pResponseHeader->FcpRspLen[4]; // go one over
                if( Rsp_Length ) 
                    psensebuffer += Rsp_Length;

                osDEBUGPRINT((ALWAYS_PRINT,"Sense length valid Sns %lx (%x) Length %08x\n",
                psensebuffer, *psensebuffer, Sense_Length  ));

                Srb->SrbStatus = SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_ERROR;
                done = TRUE;

                osDEBUGPRINT((DMOD,"FcResponse %lx Valid Flags %02x SCSI STATUS  %02x\n",
                            pResponseHeader,
                            pResponseHeader->FcpStatus[osFCP_STATUS_VALID_FLAGS],
                            pResponseHeader->FcpStatus[osFCP_STATUS_SCSI_STATUS]));

                tmp32 = hpIOInfoLen - sizeof(agFcpRspHdr_t) - Rsp_Length;

                if (tmp32 < Sense_Length)
                    Sense_Length = tmp32;

                if (Srb->SenseInfoBufferLength > Sense_Length)
                    Srb->SenseInfoBufferLength = (UCHAR) Sense_Length;

                osCopy (Srb->SenseInfoBuffer, (ULONG *)psensebuffer, Srb->SenseInfoBufferLength);


                ptmp8  = (PUCHAR) psensebuffer;
                osDEBUGPRINT((ALWAYS_PRINT,"SENSE OS %02x %02x [SK %02x] %02x %02x %02x %02x %02x %02x %02x %02x %02x [ASC %02x ASCQ %02x] %02x %02x %02x %02x\n",
                    *(ptmp8+ 0),*(ptmp8+ 1),*(ptmp8+ 2),*(ptmp8+ 3),*(ptmp8+ 4),*(ptmp8+ 5),*(ptmp8+ 6),*(ptmp8+ 7),*(ptmp8+ 8),*(ptmp8+ 9),
                    *(ptmp8+10),*(ptmp8+11),*(ptmp8+12),*(ptmp8+13),*(ptmp8+14),*(ptmp8+15),*(ptmp8+16),*(ptmp8+17) ));

            } 
            else 
            {
                // unexpected status - SNS_LEN_VALID but not a check condition
                osDEBUGPRINT((ALWAYS_PRINT, "osFCP_SNS_LEN_VALID bit set but ScsiStatus != 2\n"));
                Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                Srb->ScsiStatus = 0;
                done = TRUE;
            }
        }

        if (done == FALSE &&
            Srb->ScsiStatus != SCSISTAT_GOOD &&
            Srb->ScsiStatus != SCSISTAT_CONDITION_MET &&
            Srb->ScsiStatus != SCSISTAT_INTERMEDIATE &&
            Srb->ScsiStatus != SCSISTAT_INTERMEDIATE_COND_MET) 
        {
            // good status and its variants
            Srb->SrbStatus = SRB_STATUS_ERROR;
            done = TRUE;
        }

        if ((done == FALSE) && (valid_fields & osFCP_RESID_UNDER)) 
        {
            // Underrun status
            Srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
            done = TRUE;
            ptmp32  = (PULONG)&pResponseHeader->FcpResId[0];
            Resid_Len = SWAPDWORD(*ptmp32);
            osDEBUGPRINT((ALWAYS_PRINT,"Map_FC_ScsiError: Data Overrun Srb->DataTransferLength=%08x new =%08x Residue=%08x\n", 
               Srb->DataTransferLength,
               Srb->DataTransferLength-Resid_Len,
               Resid_Len ));
            if (Resid_Len & 0x80000000)
            {
                // negative residue.... make sure that SP won't crash by setting it to zero data xferred...
                osDEBUGPRINT((ALWAYS_PRINT,"WARNING !!! Map_FC_ScsiError: Data Overrun negative length Srb->DataTransferLength=%08x Residue=%08x. Reporting 0 bytes xferred\n", 
                    Srb->DataTransferLength,
                    Resid_Len ));
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(pCard, (PVOID)pSrbExt, HPFC_MSG_NEGATIVE_DATA_UNDERRUN, NULL, 0, "%x",  Resid_Len);
                #endif  
                Srb->DataTransferLength = 0;
            }
            else
            {
                Srb->DataTransferLength -= Resid_Len;
            }
            osDEBUGPRINT((DMOD,"Residual UNDER Length %08x\n", Resid_Len ));
        }

        if ((done == FALSE) && (valid_fields & osFCP_RESID_OVER)) 
        {
            // Overrun status - treat it as good status
            osDEBUGPRINT((ALWAYS_PRINT,"Map_FC_ScsiError: data overrun.\n"));
            Srb->ScsiStatus = SCSISTAT_GOOD;

            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            done = TRUE;
        }


        osDEBUGPRINT((DHIGH,"scsi status %x psensebuffer %lx prspbuffer %lx\n",
                           Srb->ScsiStatus, psensebuffer, prspbuffer ));
    } 
    else 
    {
        // FC response payload is less than expected. Report no device
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        Srb->ScsiStatus = 0;
    }

    osDEBUGPRINT((DMOD,"SrbStatus %x ScsiStatus %x SrbFlags %x Data len %x Resid %x start %x Delta %x @ %x\n",
                                Srb->SrbStatus,
                                Srb->ScsiStatus,
                                Srb->SrbFlags,
                                Srb->DataTransferLength,
                                Resid_Len,
                                pSrbExt->SRB_StartTime,
                                osTimeStamp(0)-pSrbExt->SRB_StartTime,
                                osTimeStamp(0)));
    return(TRUE);
}

/*++

Routine Description:
    See if we can retry a failed IO request
   
Arguments:

    pSrb  - srb

Return Value:

    TRUE  - yes
    FALSE - no

--*/

int
RetrySrbOK (PSCSI_REQUEST_BLOCK pSrb)
{
    PSRB_EXTENSION pSrbExt = (PSRB_EXTENSION) pSrb->SrbExtension;
    PLU_EXTENSION  plunExtension;
    UCHAR          devType;

    if (pSrbExt)
        plunExtension = pSrbExt->pLunExt;
    else
    {
        osDEBUGPRINT((ALWAYS_PRINT,"%s %s NULL\n","RetrySrbOK", "plunExtension" ));
        return FALSE;
    }
   
    if(plunExtension != NULL )
    {
        devType= pSrbExt->pLunExt->deviceType;
    }
    else
    {
        osDEBUGPRINT((ALWAYS_PRINT,"%s %s NULL\n","RetrySrbOK", "pSrbExt->pLunExt" ));
        return FALSE;
    }

    if (devType == DIRECT_ACCESS_DEVICE ||
        devType == WRITE_ONCE_READ_MULTIPLE_DEVICE || 
        devType == READ_ONLY_DIRECT_ACCESS_DEVICE || 
        devType == OPTICAL_DEVICE) 
    {
    #ifdef MylexWolfpack
        if (pSrb->Cdb[0] == SCSIOP_READ || pSrb->Cdb[0] == SCSIOP_WRITE)
            return FALSE;
    #endif
        return TRUE;
    } 
    else
        // SEQUENTIAL_ACCESS_DEVICE, PRINTER_DEVICE, PROCESSOR_DEVICE
        // SCANNER_DEVICE, MEDIUM_CHANGER, COMMUNICATION_DEVICE
        return FALSE;
}

// for debugging purpose
#ifdef _DEBUG_EVENTLOG_

ULONG gSenseDecode[] =
{
    HPFC_MSG_IO_ERROR_S0,
    HPFC_MSG_IO_ERROR_S1,
    HPFC_MSG_IO_ERROR_S2,
    HPFC_MSG_IO_ERROR_S3,
    HPFC_MSG_IO_ERROR_S4,
    HPFC_MSG_IO_ERROR_S5,
    HPFC_MSG_IO_ERROR_S6,
    HPFC_MSG_IO_ERROR_S7,
    HPFC_MSG_IO_ERROR_S8,
    HPFC_MSG_IO_ERROR_S9,
    HPFC_MSG_IO_ERROR_SA,
    HPFC_MSG_IO_ERROR_SB,
    HPFC_MSG_IO_ERROR_SC,
    HPFC_MSG_IO_ERROR_SD,
    HPFC_MSG_IO_ERROR_SE,
    HPFC_MSG_IO_ERROR_SF
};

SRB_ERROR  gSrbDecode[] = 
    {
    {SRB_STATUS_PENDING,                   HPFC_MSG_IO_ERROR_SRBPENDING},
    {SRB_STATUS_SUCCESS,                   HPFC_MSG_IO_ERROR_SRBSUCCESS},
    {SRB_STATUS_ABORTED,                   HPFC_MSG_IO_ERROR_SRBABORTED},              
    {SRB_STATUS_ABORT_FAILED,              HPFC_MSG_IO_ERROR_SRBABORT_FAILED},         
    {SRB_STATUS_ERROR,                     HPFC_MSG_IO_ERROR_SRBERROR},                
    {SRB_STATUS_BUSY,                      HPFC_MSG_IO_ERROR_SRBBUSY},                 
    {SRB_STATUS_INVALID_REQUEST,           HPFC_MSG_IO_ERROR_SRBINVALID_REQUEST},
    {SRB_STATUS_INVALID_PATH_ID,           HPFC_MSG_IO_ERROR_SRBINVALID_PATH_ID},      
    {SRB_STATUS_NO_DEVICE,                 HPFC_MSG_IO_ERROR_SRBNO_DEVICE},            
    {SRB_STATUS_TIMEOUT,                   HPFC_MSG_IO_ERROR_SRBTIMEOUT},
    {SRB_STATUS_SELECTION_TIMEOUT,         HPFC_MSG_IO_ERROR_SRBSELECTION_TIMEOUT},    
    {SRB_STATUS_COMMAND_TIMEOUT,           HPFC_MSG_IO_ERROR_SRBCOMMAND_TIMEOUT},      
    {SRB_STATUS_MESSAGE_REJECTED,          HPFC_MSG_IO_ERROR_SRBMESSAGE_REJECTED},     
    {SRB_STATUS_BUS_RESET,                 HPFC_MSG_IO_ERROR_SRBBUS_RESET},            
    {SRB_STATUS_PARITY_ERROR,              HPFC_MSG_IO_ERROR_SRBPARITY_ERROR},         
    {SRB_STATUS_REQUEST_SENSE_FAILED,      HPFC_MSG_IO_ERROR_SRBREQUEST_SENSE_FAILED}, 
    {SRB_STATUS_NO_HBA,                    HPFC_MSG_IO_ERROR_SRBNO_HBA},               
    {SRB_STATUS_DATA_OVERRUN,              HPFC_MSG_IO_ERROR_SRBDATA_OVERRUN},         
    {SRB_STATUS_UNEXPECTED_BUS_FREE,       HPFC_MSG_IO_ERROR_SRBUNEXPECTED_BUS_FREE},
    {SRB_STATUS_PHASE_SEQUENCE_FAILURE,    HPFC_MSG_IO_ERROR_SRBPHASE_SEQUENCE_ERROR},
    {SRB_STATUS_BAD_SRB_BLOCK_LENGTH,      HPFC_MSG_IO_ERROR_SRBBAD_SRB_BLOCK_LENGTH},
    {SRB_STATUS_REQUEST_FLUSHED,           HPFC_MSG_IO_ERROR_SRBREQUEST_FLUSHED},
    {SRB_STATUS_INVALID_LUN,               HPFC_MSG_IO_ERROR_SRBINVALID_LUN},
    {SRB_STATUS_INVALID_TARGET_ID,         HPFC_MSG_IO_ERROR_SRBINVALID_TARGET_ID},
    {SRB_STATUS_BAD_FUNCTION,              HPFC_MSG_IO_ERROR_SRBBAD_FUNCTION},
    {SRB_STATUS_ERROR_RECOVERY,            HPFC_MSG_IO_ERROR_SRBERROR_RECOVERY},
    #ifdef HP_NT50
    {SRB_STATUS_NOT_POWERED,               HPFC_MSG_IO_ERROR_SRBNOT_POWERED},
    #endif
    {0xff,                                 HPFC_MSG_IO_ERROR_SRBUNDEFINED_ERROR}
   };

#endif

#ifdef _DEBUG_EVENTLOG_
extern ULONG gSenseDecode[];
extern SRB_ERROR  gSrbDecode[];

ULONG DecodeSrbError(UCHAR err)
{
    SRB_ERROR   *pSrbDecode = gSrbDecode;
   
    while(   !(pSrbDecode->SrbStatus == 0xff)  && 
            !(pSrbDecode->SrbStatus == err) )
       pSrbDecode++;
   
    return(pSrbDecode->LogCode);
   
   
}

BOOLEAN LogScsiError( agRoot_t            *hpRoot,
                      PSCSI_REQUEST_BLOCK pSrb ,
                  agFcpRspHdr_t  * pResponseHeader,
                  ULONG           hpIOInfoLen)
{
    PSRB_EXTENSION    pSrbExt;
    PCARD_EXTENSION   pCard;
    UCHAR             dumpdata[36];
    ULONG             level = HPFC_MSG_IO_ERROR ;
    ULONG             size = sizeof(dumpdata)/sizeof(LONG);
         
    #ifndef DBG  
    if( LogLevel == LOG_LEVEL_NONE ) 
        return (0);
    #endif
      
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    pSrbExt = pSrb->SrbExtension;
    
    osCopy (dumpdata,  pSrb->Cdb, 16);
    dumpdata[16] = pSrb->SrbStatus;
    dumpdata[17] = pSrb->ScsiStatus;
   
    dumpdata[18] = 0xfa;                /* not used */
    dumpdata[19] = 0xce;                /* not used */
   
   
    if (pSrb->ScsiStatus == 2)       /* check condition */
    {
        if (pSrb->SenseInfoBuffer)
        {
            osCopy (dumpdata+20, pSrb->SenseInfoBuffer, 
                (pSrb->SenseInfoBufferLength < 16) ? pSrb->SenseInfoBufferLength : 16 );
            level = gSenseDecode[ (*(((PCHAR)pSrb->SenseInfoBuffer )+2)) & 0xF ];
        }
        else
            osDEBUGPRINT((ALWAYS_PRINT,"LogScsiError: pSrb->SenseInfoBuffer NULL\n"));
    }
    else
    {
        level = DecodeSrbError(pSrb->SrbStatus);
        size = 20/sizeof(ULONG);         /* display the first 20 bytes */
    }
      
    LogEvent(   pCard, 
               (PVOID)pSrbExt, 
               level, 
               (LONG *)dumpdata, 
               size, 
               NULL);
      
    
    
    #if DBG > 0
    {
        ULONG x1,x2,x3,x4;
        PCHAR             pptr;
        pptr = (PCHAR)pSrb->SenseInfoBuffer;

        if( pResponseHeader)
        {
            x1=(ULONG)pResponseHeader->FcpStatus[0];
            x2=(ULONG)pResponseHeader->FcpStatus[1];
            x3=(ULONG)pResponseHeader->FcpStatus[2];
            x4=(ULONG)pResponseHeader->FcpStatus[3];
        }
        else
        {
            x1=x2=x3=x4=0;
        }

        osDEBUGPRINT((ALWAYS_PRINT,"LogScsiError: %d.%d.%d STA %d.%d (FCPSta %x.%02x.%02x.%02x.%02x) ",
            pSrb->PathId, pSrb->TargetId, pSrb->Lun,
            pSrb->SrbStatus, pSrb->ScsiStatus,
            hpIOInfoLen,
            x1,x2,x3,x4));

        osDEBUGPRINT((ALWAYS_PRINT,"CDB %02x%02x%02x%02x%02x %02x%02x%02x%02x%02x pCDB %lx ",
            pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
            pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], &pSrb->Cdb[0]));

        if (pptr)
            osDEBUGPRINT((ALWAYS_PRINT, "SNS %02x%02x[%02x]%02x %02x%02x%02x%02x %02x%02x%02x%02x [%02x][%02x]%02x%02x\n",
                pptr[0],pptr[1],pptr[2],pptr[3],pptr[4],
                pptr[5],pptr[6],pptr[7],pptr[8],pptr[9], 
                pptr[10],pptr[11],pptr[12],pptr[13],pptr[14],pptr[15] ));
    }
    #endif
    return(TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\mapping.h ===
#ifdef YAM2_1
/*++

Copyright (c) 2000 Agilent Technologies

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/mapping.h $

   $Revision: 6 $
   $Date: 11/10/00 5:52p $ (Last Check-In)
   $Modtime:: $ (Last Modified)

Purpose:
   Structures for YAM2.1 Implementation

--*/

#ifndef _MAPPING_H_
#define _MAPPING_H_

#define MAX_VS_DEVICE       128            /* maximum 128 Volume Set device */
#define MAX_LU_DEVICE       8              /* maximum 8 Logical unit (Muxes) supported */
//#define    MAX_PA_DEVICE       256
#define      MAX_PA_DEVICE       MAX_FC_DEVICES
#define      ALL_DEVICE               -1L


#define      DEFAULT_PaPathIdWidth    4
#define      DEFAULT_VoPathIdWidth    2
#define      DEFAULT_LuPathIdWidth    2
#define      DEFAULT_LuTargetWidth    8

#define      CHECK_STATUS             1
#define      DONT_CHECK_STATUS        0

/*
   This structure describe an the coressponding FC handle entry in the OS device entry table
        Index = the FC handle array handle 
        Flags = the state of the FC handle
   Rules:
   1. A value of zero means that there is no corresponding FC handle
   2. Once, the index is set to non zero, it will stay that way until driver unload
   3. A non zero value is active  when the flags is set to MAP_ENTRY_ACTIVE 
   4. During LINKUP and LINKDOWN asynch events, the Index value never change, only the flags do
   5. The Index value IS Unique within the OS Device Entry table 
   6. During LINKUP the entire FC Handle array is scanned to determine if there is any
      NEW entries.  Any new entries   will be assigned to a new PID-TID in the order that 
        FC Handle array is scanned.
*/
typedef struct _WWN_ENTRY
{
   UCHAR          IPortWWN[8];                  /* initiator Port WWN */
   UCHAR          TNodeWWN[8];                  /* target Node WWN */
   UCHAR          TPortWWN[8];                  /* target Port WWN */
   USHORT         Pid;                               /* desired Path ID */
   USHORT         Tid;                               /* desired target ID */
   ULONG          Flags;                             /* undefined */
   void      *agroot;                           /* which card */
} WWN_ENTRY;

typedef struct _WWN_TABLE
{
   ULONG               ElementCount;
   WWN_ENTRY Entry[1];
}  WWN_TABLE;

typedef struct _DEVICE_INFO
{
   UCHAR               InquiryData[40];
   UCHAR               PortWWN[8];
   UCHAR               NodeWWN[8];
// agFCDevInfo_t   devinfo;
} DEVICE_INFO;

typedef struct _VS_DEVICE_IDX
{
   USHORT              PaDeviceIndex;      /* index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this VS device */
} VS_DEVICE_IDX;

typedef struct _LU_DEVICE_IDX
{
   USHORT              PaDeviceIndex;      /* Index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this LU device */
} LU_DEVICE_IDX;

typedef struct _PA_DEVICE_IDX
{
   USHORT              FcDeviceIndex;      /* Index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this LU device */
} PA_DEVICE_IDX;

typedef struct _COMMON_IDX
{

   USHORT              Index;         /* Index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this LU device */
}  COMMON_IDX;


typedef union     _DEVICE_MAP
{
   VS_DEVICE_IDX  Vs;
   LU_DEVICE_IDX  Lu;
   PA_DEVICE_IDX  Pa;
   COMMON_IDX          Com;
} DEVICE_MAP;

#define PA_DEVICE_NO_ENTRY       0xffff

/* this structure describe an NT device PathID-targetID mode */
typedef struct _PA_DEVICE
{
   DEVICE_MAP          Index;
   UCHAR               EntryState;
        #define   PA_DEVICE_EMPTY               0
        #define   PA_DEVICE_ACTIVE         1
        #define   PA_DEVICE_GONEAWAY       2
        #define   PA_DEVICE_TRANSIENT      4

   CHAR           ModeFlag;
        #define   PA_DEVICE_TRY_MODE_MASK            0x07
             #define   PA_DEVICE_TRY_MODE_NONE       0x00      /* new device, has not been tried */
             #define   PA_DEVICE_TRY_MODE_VS         0x01      /* tried VS mode */
             #define   PA_DEVICE_TRY_MODE_LU         0x02      /* tried LU mode */
             #define   PA_DEVICE_TRY_MODE_PA         0x03      /* tried PA mode */
             #define   PA_DEVICE_TRY_MODE_ALL        0x04      /* tried all mode */

        #define PA_DEVICE_BUILDING_DEVICE_MAP   0x08
        #define PA_DEVICE_ALL_LUN_FIELDS_BUILT  0x10
        #define   PA_DEVICE_SUPPORT_PA               0x80
        #define   PA_DEVICE_SUPPORT_VS               0x40
        #define   PA_DEVICE_SUPPORT_LU               0x20

    UCHAR           Padding1;
    UCHAR           Padding2;

    ULONG              OpFlag;             /* operation flags */

   DEVICE_INFO         DevInfo;
} PA_DEVICE;

typedef struct _REG_SETTING
{
   ULONG          PaPathIdWidth;
   ULONG          VoPathIdWidth;
   ULONG          LuPathIdWidth;
   ULONG          LuTargetWidth;
   ULONG          MaximumTids;
} REG_SETTING;


typedef struct _DEVICE_ARRAY
{
   ULONG          Signature;                         /* 'HNDL' */
   ULONG          ElementCount;                 /* maximum structures allocated */
   ULONG          DeviceCount;                  /* Total device reported by FC layer */
   ULONG          CardHandleIndex;         /* index into the devHandle array for card itself */
   ULONG          Num_Devices;
   ULONG          OldNumDevices;
   REG_SETTING    Reg;
   ULONG          VsDeviceIndex;
   ULONG          LuDeviceIndex;
    ULONG       Reserved1;
   DEVICE_MAP     VsDevice[MAX_VS_DEVICE];
   DEVICE_MAP     LuDevice[MAX_LU_DEVICE];
   PA_DEVICE PaDevice[1];
} DEVICE_ARRAY;

#define	DEV_ARRAY_SIZE		(sizeof(DEVICE_ARRAY)) 
#define PADEV_SIZE			(gMaxPaDevices)*sizeof(PA_DEVICE)
#define FCDEV_SIZE			(gMaxPaDevices)*sizeof(agFCDev_t)
#define FCNODE_INFO_SIZE	(gMaxPaDevices)*sizeof(NODE_INFO)
#ifdef _DEBUG_EVENTLOG_
#define EVENTLOG_SIZE       (gEventLogCount ? sizeof(EVENTLOG_BUFFER) +     \
                                (gEventLogCount-1)*sizeof(EVENTLOG_ENTRY) : 0)
#else
#define EVENTLOG_SIZE       (0)
#endif

//#define OSDATA_SIZE (sizeof(CARD_EXTENSION) - sizeof(PA_DEVICE) + PADEV_SIZE + FCDEV_SIZE + FCNODE_INFO_SIZE )
#define OSDATA_SIZE			(sizeof(CARD_EXTENSION))
#define OSDATA_UNCACHED_SIZE (DEV_ARRAY_SIZE-sizeof(PA_DEVICE)+PADEV_SIZE+FCDEV_SIZE+FCNODE_INFO_SIZE+EVENTLOG_SIZE)

#define PADEV_OFFSET		0
#define FCDEV_OFFSET		(DEV_ARRAY_SIZE - sizeof(PA_DEVICE) + PADEV_SIZE)
#define FCNODE_INFO_OFFSET	(FCDEV_OFFSET + FCDEV_SIZE)
#define EVENTLOG_OFFSET     (FCNODE_INFO_OFFSET + FCNODE_INFO_SIZE)   
#define CACHE_OFFSET		(EVENTLOG_OFFSET + EVENTLOG_SIZE)


#define SET_PA_LUN(plun, pathId, targetId, lun) \
             plun->lun_pd[0].Address_mode = PERIPHERAL_ADDRESS; \
             plun->lun_pd[0].Bus_number = 0;    \
             plun->lun_pd[0].Lun = (UCHAR)lun;

#define SET_LU_LUN(plun, pathId, targetId, lun) \
             plun->lun_lu[0].Address_mode = LUN_ADDRESS; \
             plun->lun_lu[0].Target = (UCHAR) (targetId & 0x7); \
             plun->lun_lu[0].Bus_number = (UCHAR) ( (targetId >> 3 ) & 3); \
             plun->lun_lu[0].Lun = (UCHAR) lun;

#define SET_VS_LUN(plun, pathId, targetId, lun) \
             plun->lun_vs[0].Address_mode = VOLUME_SET_ADDRESS; \
             plun->lun_vs[0].Lun_hi = 0; \
             plun->lun_vs[0].Lun = (UCHAR)lun;


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ntdebug.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   ntdebug.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/NTDEBUG.H $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:17a $
   $Modtime:: 8/31/00 3:23p            $

Notes:


--*/

#ifndef __NTDEBUG_H_
#define __NTDEBUG_H_

#if DBG == 0

#define EXTERNAL_DEBUG_LEVEL     0
#define EXTERNAL_HP_DEBUG_LEVEL  6 // 0x00000103

#endif  //  DBG == 0

#if DBG == 1

#define EXTERNAL_DEBUG_LEVEL     ( DBG_JUST_ERRORS | CS_DURING_ANY)
#define EXTERNAL_HP_DEBUG_LEVEL  8

#endif //  DBG == 1

#if DBG == 2

#define EXTERNAL_DEBUG_LEVEL   0 // (DBG_MODERATE_DETAIL | CS_DURING_ANY)
#define EXTERNAL_HP_DEBUG_LEVEL  11

#endif //  DBG == 2


#if DBG > 2

#define EXTERNAL_DEBUG_LEVEL      0 // (DBG_DEBUG_FULL) //
#define EXTERNAL_HP_DEBUG_LEVEL  11 // Log


#endif //  DBG > 2



// CS_DURING_ANY | DBG_LOW_DETAIL
// DBG_DEBUG_FULL show it all
// CS_DURING_ANY | DBG_LOW_DETAIL;
// CS_DRIVER_ENTRY            0x00000100 // Initial Driver load superset
// CS_DURING_DRV_ENTRY        0x00000001 // of DRV_ENTRY FIND and START
// CS_DURING_FINDADAPTER      0x00000002 // Anything during scsiportinit
// CS_DURING_DRV_INIT         0x00000004
// CS_DURING_RESET_ADAPTER    0x00000008
// CS_DURING_STARTIO          0x00000010
// CS_DURING_ISR              0x00000020
// CS_DURING_OSCOMPLETE       0x00000040
// CS_HANDLES_GOOD            0x00000080
// CS_DURING_ANY              0x000001FF
// CS_DUR_ANY_ALL             0xF00001FF

// DBG_VERY_DETAILED          0x10000000  // All debug statements
// DBG_MODERATE_DETAIL        0x20000000  // Most debug statements
// DBG_LOW_DETAIL             0x40000000  // Entry and exit
// DBG_JUST_ERRORS            0x80000000  // Errors
// DBG_DEBUG_MASK             0xF0000000  // Mask debug bits
// DBG_DEBUG_OFF              0xF0000000  // NO debug statements
// DBG_DEBUG_FULL             0x000001FF  // ALL debug statements and CS
// DBG_DEBUG_ALL              0x00000000  // ALL debug statements






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\memmap.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/MemMap.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/13/00 4:07p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/MemMap.C

--*/

#ifndef __MemMap_H__
#define __MemMap_H__

/*+
The following are used to scale the sizes of various data structures
-*/

#define MemMap_NumDevSlotsPerArea_PARAMETER  "NumDevSlotsPerArea"
#define MemMap_NumDevSlotsPerArea_MIN        1
#define MemMap_NumDevSlotsPerArea_MAX        128
#define MemMap_NumDevSlotsPerArea_ADJUSTABLE agTRUE
#define MemMap_NumDevSlotsPerArea_POWER_OF_2 agFALSE
#define MemMap_NumDevSlotsPerArea_DEFAULT    126

#define MemMap_NumAreasPerDomain_PARAMETER   "NumAreasPerDomain"
#define MemMap_NumAreasPerDomain_MIN         1
#define MemMap_NumAreasPerDomain_MAX         256
#define MemMap_NumAreasPerDomain_ADJUSTABLE  agTRUE
#define MemMap_NumAreasPerDomain_POWER_OF_2  agFALSE
#define MemMap_NumAreasPerDomain_DEFAULT     1

#define MemMap_NumDomains_PARAMETER          "NumDomains"
#define MemMap_NumDomains_MIN                1
#define MemMap_NumDomains_MAX                256
#define MemMap_NumDomains_ADJUSTABLE         agTRUE
#define MemMap_NumDomains_POWER_OF_2         agFALSE
#define MemMap_NumDomains_DEFAULT            1

#define MemMap_NumDevices_PARAMETER          "NumDevices"
#define MemMap_NumDevices_MIN                (MemMap_NumDevSlotsPerArea_MIN * MemMap_NumAreasPerDomain_MIN * MemMap_NumDomains_MIN)
#define MemMap_NumDevices_MAX                (MemMap_NumDevSlotsPerArea_MAX * MemMap_NumAreasPerDomain_MAX * MemMap_NumDomains_MAX)
#define MemMap_NumDevices_ADJUSTABLE         agTRUE
#define MemMap_NumDevices_POWER_OF_2         agFALSE
#define MemMap_NumDevices_DEFAULT            128 

#define MemMap_NumLOOPDeviceMAP_PARAMETER    "LOOPDeviceMAP"
#define MemMap_NumLOOPDeviceMAP_MIN          sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t)
#define MemMap_NumLOOPDeviceMAP_MAX          sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t)
#define MemMap_NumLOOPDeviceMAP_ADJUSTABLE   agFALSE
#define MemMap_NumLOOPDeviceMAP_POWER_OF_2   agFALSE
#define MemMap_NumLOOPDeviceMAP_DEFAULT      sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t)

#define MemMap_NumFabricDeviceMAP_PARAMETER  "FabricDeviceMAP"
#define MemMap_NumFabricDeviceMAP_MIN        MemMap_NumDevices_MIN
#define MemMap_NumFabricDeviceMAP_MAX        MemMap_NumDevices_MAX
#define MemMap_NumFabricDeviceMAP_ADJUSTABLE agFALSE
#define MemMap_NumFabricDeviceMAP_POWER_OF_2 agFALSE
#define MemMap_NumFabricDeviceMAP_DEFAULT    MemMap_NumDevices_DEFAULT

#define MemMap_NumIOs_PARAMETER              "NumIOs"
#define MemMap_NumIOs_MIN                    2
#define MemMap_NumIOs_MAX                    0x7FFD
#define MemMap_NumIOs_ADJUSTABLE             agTRUE
#define MemMap_NumIOs_POWER_OF_2             agFALSE
#define MemMap_NumIOs_DEFAULT                512

#define MemMap_SizeSGLs_PARAMETER            "SizeSGLs"
#define MemMap_SizeSGLs_MIN                  4
#define MemMap_SizeSGLs_MAX                  256
#define MemMap_SizeSGLs_ADJUSTABLE           agTRUE
#define MemMap_SizeSGLs_POWER_OF_2           agTRUE
#define MemMap_SizeSGLs_DEFAULT              32

#define MemMap_NumSGLs_PARAMETER             "NumSGLs"
#define MemMap_NumSGLs_MIN                   0
#define MemMap_NumSGLs_MAX                   MemMap_NumIOs_MAX
#define MemMap_NumSGLs_ADJUSTABLE            agTRUE
#define MemMap_NumSGLs_POWER_OF_2            agFALSE
#define MemMap_NumSGLs_DEFAULT               (MemMap_NumIOs_DEFAULT/4)

#define MemMap_SizeCachedSGLs_PARAMETER      "SizeCachedSGLs"
#define MemMap_SizeCachedSGLs_MIN            3
#define MemMap_SizeCachedSGLs_MAX            256
#define MemMap_SizeCachedSGLs_ADJUSTABLE     agTRUE
#define MemMap_SizeCachedSGLs_POWER_OF_2     agFALSE
#define MemMap_SizeCachedSGLs_DEFAULT        17

#define MemMap_FCP_CMND_Size_PARAMETER       "FCP_CMND_Size"
#define MemMap_FCP_CMND_Size_MIN             64
#define MemMap_FCP_CMND_Size_MAX             64
#define MemMap_FCP_CMND_Size_ADJUSTABLE      agFALSE
#define MemMap_FCP_CMND_Size_POWER_OF_2      agTRUE
#define MemMap_FCP_CMND_Size_DEFAULT         64

#define MemMap_FCP_RESP_Size_PARAMETER       "FCP_RESP_Size"
#define MemMap_FCP_RESP_Size_MIN             128
#define MemMap_FCP_RESP_Size_MAX             256
#define MemMap_FCP_RESP_Size_ADJUSTABLE      agTRUE
#define MemMap_FCP_RESP_Size_POWER_OF_2      agTRUE
#define MemMap_FCP_RESP_Size_DEFAULT         128

#define MemMap_SF_CMND_Reserve_PARAMETER     "SF_CMND_Reserve"
#define MemMap_SF_CMND_Reserve_MIN           2
#define MemMap_SF_CMND_Reserve_MAX           0x7FFD
#define MemMap_SF_CMND_Reserve_ADJUSTABLE    agTRUE
#define MemMap_SF_CMND_Reserve_POWER_OF_2    agFALSE
#define MemMap_SF_CMND_Reserve_DEFAULT       64

#define MemMap_SF_CMND_Size_PARAMETER        "SF_CMND_Size"
#define MemMap_SF_CMND_Size_MIN              256
#define MemMap_SF_CMND_Size_MAX              1024
#define MemMap_SF_CMND_Size_ADJUSTABLE       agTRUE
#define MemMap_SF_CMND_Size_POWER_OF_2       agTRUE
#define MemMap_SF_CMND_Size_DEFAULT          256

#define MemMap_NumTgtCmnds_PARAMETER         "NumTgtCmnds"
#define MemMap_NumTgtCmnds_MIN               1
#define MemMap_NumTgtCmnds_MAX               1024
#define MemMap_NumTgtCmnds_ADJUSTABLE        agTRUE
#define MemMap_NumTgtCmnds_POWER_OF_2        agFALSE
#define MemMap_NumTgtCmnds_DEFAULT           128

#define MemMap_TGT_CMND_Size_PARAMETER       "TGT_CMND_Size"
#define MemMap_TGT_CMND_Size_MIN             1056
#define MemMap_TGT_CMND_Size_MAX             1056
#define MemMap_TGT_CMND_Size_ADJUSTABLE      agFALSE
#define MemMap_TGT_CMND_Size_POWER_OF_2      agFALSE
#define MemMap_TGT_CMND_Size_DEFAULT         1056

#ifdef _DvrArch_1_30_
#define MemMap_NumPktThreads_PARAMETER       "NumPktThreads"
#define MemMap_NumPktThreads_MIN             1
#define MemMap_NumPktThreads_MAX             1024
#define MemMap_NumPktThreads_ADJUSTABLE      agTRUE
#define MemMap_NumPktThreads_POWER_OF_2      agFALSE
#define MemMap_NumPktThreads_DEFAULT         32

#define MemMap_Pkt_CMND_Size_PARAMETER       "Pkt_CMND_Size"
#define MemMap_Pkt_CMND_Size_MIN             256
#define MemMap_Pkt_CMND_Size_MAX             1024
#define MemMap_Pkt_CMND_Size_ADJUSTABLE      agTRUE
#define MemMap_Pkt_CMND_Size_POWER_OF_2      agTRUE
#define MemMap_Pkt_CMND_Size_DEFAULT         256

#endif /* _DvrArch_1_30_ was defined */

#define MemMap_NumCommandQ_PARAMETER         "NumCommandQ"     /* Exchange Request Queue ERQ */
#define MemMap_NumCommandQ_MIN               2
#define MemMap_NumCommandQ_MAX               4096
#define MemMap_NumCommandQ_ADJUSTABLE        agTRUE
#define MemMap_NumCommandQ_POWER_OF_2        agTRUE
#define MemMap_NumCommandQ_DEFAULT           MemMap_NumIOs_DEFAULT

#define MemMap_NumCompletionQ_PARAMETER      "NumCompletionQ" /* Inbound Message Queue IMQ */
#define MemMap_NumCompletionQ_MIN            2
#define MemMap_NumCompletionQ_MAX            4096
#define MemMap_NumCompletionQ_ADJUSTABLE     agTRUE
#define MemMap_NumCompletionQ_POWER_OF_2     agTRUE
#define MemMap_NumCompletionQ_DEFAULT        MemMap_NumIOs_DEFAULT

#define MemMap_NumInboundBufferQ_PARAMETER   "NumInboundBufferQ"  /* Single Frame Queue SFQ */
#define MemMap_NumInboundBufferQ_MIN         32
#define MemMap_NumInboundBufferQ_MAX         4096
#define MemMap_NumInboundBufferQ_ADJUSTABLE  agTRUE
#define MemMap_NumInboundBufferQ_POWER_OF_2  agTRUE
#define MemMap_NumInboundBufferQ_DEFAULT     512

#define MemMap_InboundBufferSize_PARAMETER   "InboundBufferSize"
#define MemMap_InboundBufferSize_MIN         64
#define MemMap_InboundBufferSize_MAX         64
#define MemMap_InboundBufferSize_ADJUSTABLE  agFALSE
#define MemMap_InboundBufferSize_POWER_OF_2  agTRUE
#define MemMap_InboundBufferSize_DEFAULT     64

#define MemMap_CardRamSize_PARAMETER         "CardRamSize"
#define MemMap_CardRamSize_MIN               0
#define MemMap_CardRamSize_MAX               (256*1024)
#define MemMap_CardRamSize_ADJUSTABLE        agFALSE
#define MemMap_CardRamSize_POWER_OF_2        agFALSE
#define MemMap_CardRamSize_DEFAULT           (256*1024)

#define MemMap_CardRamAlignment_PARAMETER    "CardRamAlignment"
#define MemMap_CardRamAlignment_MIN          0
#define MemMap_CardRamAlignment_MAX          (256*1024)
#define MemMap_CardRamAlignment_ADJUSTABLE   agFALSE
#define MemMap_CardRamAlignment_POWER_OF_2   agFALSE
#define MemMap_CardRamAlignment_DEFAULT      (256*1024)

#define MemMap_HostNvRamSize_PARAMETER       "HostNvRamSize"
#define MemMap_HostNvRamSize_MIN             0
#define MemMap_HostNvRamSize_MAX             (16*1024)
#define MemMap_HostNvRamSize_ADJUSTABLE      agTRUE
#define MemMap_HostNvRamSize_POWER_OF_2      agFALSE
#define MemMap_HostNvRamSize_DEFAULT         0

/*+
The following are used to locate the various data structures in on-card or host ram
-*/

#define MemMap_Alloc_On_Card                 1
#define MemMap_Alloc_From_Host               0

#if defined(__MemMap_Force_On_Card__)

#define MemMap_DEFAULT_Loc_ADJUSTABLE        agFALSE
#define MemMap_DEFAULT_Loc_DEFAULT           MemMap_Alloc_On_Card

#elif defined (__MemMap_Force_Off_Card__)

#define MemMap_DEFAULT_Loc_ADJUSTABLE        agFALSE
#define MemMap_DEFAULT_Loc_DEFAULT           MemMap_Alloc_From_Host

#else

#define MemMap_DEFAULT_Loc_ADJUSTABLE        agTRUE
#define MemMap_DEFAULT_Loc_DEFAULT           MemMap_Alloc_From_Host

#endif

#define MemMap_ExchangeTableLoc_PARAMETER    "ExchangeTableLoc"
#define MemMap_ExchangeTableLoc_ADJUSTABLE   MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_ExchangeTableLoc_DEFAULT      MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_ExchangeTableLoc_MASK         (MemMap_Alloc_On_Card<<0)

#define MemMap_SGLsLoc_PARAMETER             "SGLsLoc"
#define MemMap_SGLsLoc_ADJUSTABLE            MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_SGLsLoc_DEFAULT               MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_SGLsLoc_MASK                  (MemMap_Alloc_On_Card<<1)

#define MemMap_FCP_CMND_Loc_PARAMETER        "FCP_CMND_Loc"
#define MemMap_FCP_CMND_Loc_ADJUSTABLE       MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_FCP_CMND_Loc_DEFAULT          MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_FCP_CMND_Loc_MASK             (MemMap_Alloc_On_Card<<2)

#define MemMap_FCP_RESP_Loc_PARAMETER        "FCP_RESP_Loc"
#define MemMap_FCP_RESP_Loc_ADJUSTABLE       MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_FCP_RESP_Loc_DEFAULT          MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_FCP_RESP_Loc_MASK             (MemMap_Alloc_On_Card<<3)

#define MemMap_SF_CMND_Loc_PARAMETER         "SF_CMND_Loc"
#define MemMap_SF_CMND_Loc_ADJUSTABLE        MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_SF_CMND_Loc_DEFAULT           MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_SF_CMND_Loc_MASK              (MemMap_Alloc_On_Card<<4)

#ifdef _DvrArch_1_30_
#define MemMap_Pkt_CMND_Loc_PARAMETER        "Pkt_CMND_Loc"
#define MemMap_Pkt_CMND_Loc_ADJUSTABLE       MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_Pkt_CMND_Loc_DEFAULT          MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_Pkt_CMND_Loc_MASK             (MemMap_Alloc_On_Card<<4)
#endif /* _DvrArch_1_30_ was defined */

#define MemMap_CommandQLoc_PARAMETER         "CommandQLoc"
#define MemMap_CommandQLoc_ADJUSTABLE        MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CommandQLoc_DEFAULT           MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CommandQLoc_MASK              (MemMap_Alloc_On_Card<<5)

#define MemMap_CommandQConsLoc_PARAMETER     "CommandQConsLoc"
#define MemMap_CommandQConsLoc_ADJUSTABLE    MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CommandQConsLoc_DEFAULT       MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CommandQConsLoc_MASK          (MemMap_Alloc_On_Card<<6)

#define MemMap_CompletionQLoc_PARAMETER      "CompletionQLoc"
#define MemMap_CompletionQLoc_ADJUSTABLE     MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CompletionQLoc_DEFAULT        MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CompletionQLoc_MASK           (MemMap_Alloc_On_Card<<7)

#define MemMap_CompletionQProdLoc_PARAMETER  "CompletionQProdLoc"
#define MemMap_CompletionQProdLoc_ADJUSTABLE MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CompletionQProdLoc_DEFAULT    MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CompletionQProdLoc_MASK       (MemMap_Alloc_On_Card<<8)

#define MemMap_InboundBufferLoc_PARAMETER    "InboundBufferLoc"
#define MemMap_InboundBufferLoc_ADJUSTABLE   MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_InboundBufferLoc_DEFAULT      MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_InboundBufferLoc_MASK         (MemMap_Alloc_On_Card<<9)

#define MemMap_LOOPMapLoc_PARAMETER         "LOOPMapLoc"
#define MemMap_LOOPMapLoc_ADJUSTABLE        MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_LOOPMapLoc_DEFAULT           MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_LOOPMapLoc_MASK              (MemMap_Alloc_On_Card<<10)

#define MemMap_FabricMapLoc_PARAMETER       "FabricMapLoc"
#define MemMap_FabricMapLoc_ADJUSTABLE      MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_FabricMapLoc_DEFAULT         MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_FabricMapLoc_MASK            (MemMap_Alloc_On_Card<<11)

/*+
The following are used for other FC Layer settings
-*/

#define MemMap_TimerTickInterval_PARAMETER   "TimerTickInterval"
#define MemMap_TimerTickInterval_MIN         0
#define MemMap_TimerTickInterval_MAX         (100*1000*1000)
#define MemMap_TimerTickInterval_ADJUSTABLE  agTRUE
#define MemMap_TimerTickInterval_POWER_OF_2  agFALSE
#define MemMap_TimerTickInterval_DEFAULT     1000000

#define MemMap_Interrupt_IO_Mode             0
#define MemMap_Polling_IO_Mode               1

#define MemMap_IO_Mode_PARAMETER             "IO_Mode"
#define MemMap_IO_Mode_MIN                   MemMap_Interrupt_IO_Mode
#define MemMap_IO_Mode_MAX                   MemMap_Polling_IO_Mode
#define MemMap_IO_Mode_ADJUSTABLE            agTRUE
#define MemMap_IO_Mode_POWER_OF_2            agFALSE
#define MemMap_IO_Mode_DEFAULT               MemMap_Interrupt_IO_Mode

#define MemMap_GPIO_BITS_MASK                (ChipIOUp_TachLite_Control_GP1 | ChipIOUp_TachLite_Control_GP0)

#define MemMap_GPIO_BITS_PAL_Delay_0_00_ms   0x00
#define MemMap_GPIO_BITS_PAL_Delay_0_75_ms   ChipIOUp_TachLite_Control_GP0
#define MemMap_GPIO_BITS_PAL_Delay_1_00_ms   ChipIOUp_TachLite_Control_GP1
#define MemMap_GPIO_BITS_PAL_Delay_1_50_ms   (ChipIOUp_TachLite_Control_GP1 | ChipIOUp_TachLite_Control_GP0)

#define MemMap_IntDelayAmount_PARAMETER      "IntDelayAmount"
#define MemMap_IntDelayAmount_MIN            MemMap_GPIO_BITS_PAL_Delay_0_00_ms
#define MemMap_IntDelayAmount_MAX            MemMap_GPIO_BITS_PAL_Delay_1_50_ms
#define MemMap_IntDelayAmount_ADJUSTABLE     agTRUE
#define MemMap_IntDelayAmount_POWER_OF_2     agFALSE
#define MemMap_IntDelayAmount_DEFAULT        MemMap_GPIO_BITS_PAL_Delay_1_00_ms

#define MemMap_RateMethod_IOsStarted         0
#define MemMap_RateMethod_IOsCompleted       1
#define MemMap_RateMethod_IOsIntCompleted    2
#define MemMap_RateMethod_IOsPollCompleted   3
#define MemMap_RateMethod_IOsActive          4

#define MemMap_IntDelayRateMethod_PARAMETER  "IntDelayRateMethod"
#define MemMap_IntDelayRateMethod_MIN        MemMap_RateMethod_IOsStarted
#define MemMap_IntDelayRateMethod_MAX        MemMap_RateMethod_IOsActive
#define MemMap_IntDelayRateMethod_ADJUSTABLE agTRUE
#define MemMap_IntDelayRateMethod_POWER_OF_2 agFALSE
#define MemMap_IntDelayRateMethod_DEFAULT    MemMap_RateMethod_IOsPollCompleted

#define MemMap_IntDelayOnIORate_PARAMETER    "IntDelayOnIORate"
#define MemMap_IntDelayOnIORate_MIN          0x00000000
#define MemMap_IntDelayOnIORate_MAX          0xFFFFFFFF
#define MemMap_IntDelayOnIORate_ADJUSTABLE   agTRUE
#define MemMap_IntDelayOnIORate_POWER_OF_2   agFALSE
#define MemMap_IntDelayOnIORate_DEFAULT      0x00000100

#define MemMap_IntDelayOffIORate_PARAMETER   "IntDelayOffIORate"
#define MemMap_IntDelayOffIORate_MIN         0x00000000
#define MemMap_IntDelayOffIORate_MAX         0xFFFFFFFF
#define MemMap_IntDelayOffIORate_ADJUSTABLE  agTRUE
#define MemMap_IntDelayOffIORate_POWER_OF_2  agFALSE
#define MemMap_IntDelayOffIORate_DEFAULT     0x00000010

#define MemMap_IOsBetweenISRs_PARAMETER      "IOsBetweenISRs"
#define MemMap_IOsBetweenISRs_MIN            0x00000000
#define MemMap_IOsBetweenISRs_MAX            0xFFFFFFFF
#define MemMap_IOsBetweenISRs_ADJUSTABLE     agTRUE
#define MemMap_IOsBetweenISRs_POWER_OF_2     agFALSE
#define MemMap_IOsBetweenISRs_DEFAULT        0x00000100

#define MemMap_AssumedSGLChunkSize           0x1000

#ifdef _Enforce_MaxCommittedMemory_
#define MemMap_MaxCommittedMemory_PARAMETER  "MaxCommittedMemory"
#define MemMap_MaxCommittedMemory_MIN        0
#define MemMap_MaxCommittedMemory_MAX        0xFFFFFFFF
#define MemMap_MaxCommittedMemory_ADJUSTABLE agTRUE
#define MemMap_MaxCommittedMemory_POWER_OF_2 agFALSE
#define MemMap_MaxCommittedMemory_DEFAULT    (MemMap_SizeSGLs_DEFAULT * MemMap_NumSGLs_DEFAULT * MemMap_AssumedSGLChunkSize)
#endif /* _Enforce_MaxCommittedMemory_ was defined */

#define MemMap_FlashUsageModel_DoNotUse      0
#define MemMap_FlashUsageModel_UseIfGood     1
#define MemMap_FlashUsageModel_InitIfBad     2

#define MemMap_FlashUsageModel_PARAMETER     "FlashUsageModel"
#define MemMap_FlashUsageModel_MIN           MemMap_FlashUsageModel_DoNotUse
#define MemMap_FlashUsageModel_MAX           MemMap_FlashUsageModel_InitIfBad
#define MemMap_FlashUsageModel_ADJUSTABLE    agTRUE
#define MemMap_FlashUsageModel_POWER_OF_2    agFALSE
#define MemMap_FlashUsageModel_DEFAULT       MemMap_FlashUsageModel_UseIfGood

#define MemMap_InitAsNport_PARAMETER         "InitAsNport"
#define MemMap_InitAsNport_MIN               0
#define MemMap_InitAsNport_MAX               1
#define MemMap_InitAsNport_ADJUSTABLE        agTRUE
#define MemMap_InitAsNport_POWER_OF_2        agFALSE
#define MemMap_InitAsNport_DEFAULT           0

#define MemMap_RelyOnLossSyncStatus_PARAMETER         "RelyOnLossSyncStatus"
#define MemMap_RelyOnLossSyncStatus_MIN               0
#define MemMap_RelyOnLossSyncStatus_MAX               1
#define MemMap_RelyOnLossSyncStatus_ADJUSTABLE        agTRUE
#define MemMap_RelyOnLossSyncStatus_POWER_OF_2        agFALSE
#define MemMap_RelyOnLossSyncStatus_DEFAULT           agTRUE

#define MemMap_WolfPack_PARAMETER         "WolfPack"
#define MemMap_WolfPack_MIN               0
#define MemMap_WolfPack_MAX               1
#define MemMap_WolfPack_ADJUSTABLE        agTRUE
#define MemMap_WolfPack_POWER_OF_2        agFALSE
#define MemMap_WolfPack_DEFAULT           agFALSE

#define MemMap_HeartBeat_PARAMETER         "HeartBeat"
#define MemMap_HeartBeat_MIN               0
#define MemMap_HeartBeat_MAX               1
#define MemMap_HeartBeat_ADJUSTABLE        agTRUE
#define MemMap_HeartBeat_POWER_OF_2        agFALSE
#define MemMap_HeartBeat_DEFAULT           agFALSE

#define MemMap_ED_TOV_PARAMETER         "ED_TOV"
#define MemMap_ED_TOV_MIN               1
#define MemMap_ED_TOV_MAX               0xFFFF
#define MemMap_ED_TOV_ADJUSTABLE        agTRUE
#define MemMap_ED_TOV_POWER_OF_2        agFALSE
#define MemMap_ED_TOV_DEFAULT           Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default

#define MemMap_RT_TOV_PARAMETER         "RT_TOV"
#define MemMap_RT_TOV_MIN               1
#define MemMap_RT_TOV_MAX               0x1FF
#define MemMap_RT_TOV_ADJUSTABLE        agTRUE
#define MemMap_RT_TOV_POWER_OF_2        agFALSE
#define MemMap_RT_TOV_DEFAULT           Chip_Frame_Manager_TimeOut_Values_1_RT_TOV_Default_After_Reset

#define MemMap_LP_TOV_PARAMETER         "LP_TOV"
#define MemMap_LP_TOV_MIN               1
#define MemMap_LP_TOV_MAX               0xFFFF
#define MemMap_LP_TOV_ADJUSTABLE        agTRUE
#define MemMap_LP_TOV_POWER_OF_2        agFALSE
#define MemMap_LP_TOV_DEFAULT           Chip_Frame_Manager_TimeOut_Values_2_LP_TOV_Default

#define MemMap_AL_Time_PARAMETER         "AL_Time"
#define MemMap_AL_Time_MIN               1
#define MemMap_AL_Time_MAX               0x1FF
#define MemMap_AL_Time_ADJUSTABLE        agTRUE
#define MemMap_AL_Time_POWER_OF_2        agFALSE
#define MemMap_AL_Time_DEFAULT           Chip_Frame_Manager_TimeOut_Values_2_AL_Time_Default_After_Reset

#define MemMap_R_A_TOV_PARAMETER         "R_A_TOV"
#define MemMap_R_A_TOV_MIN               1
#define MemMap_R_A_TOV_MAX               0xFFFFFFFF
#define MemMap_R_A_TOV_ADJUSTABLE        agTRUE
#define MemMap_R_A_TOV_POWER_OF_2        agFALSE
#define MemMap_R_A_TOV_DEFAULT           7000000 /* was 10,000,000*/


/*+
Data stuctures used to communicate calculations
-*/

typedef struct fiMemMapInput_s
               fiMemMapInput_t;

struct fiMemMapInput_s
       {
         os_bit32    initType;
         agBOOLEAN  sysIntsActive;
         void    *cachedMemoryPtr;
         os_bit32    cachedMemoryLen;
         os_bit32    dmaMemoryUpper32;
         os_bit32    dmaMemoryLower32;
         void    *dmaMemoryPtr;
         os_bit32    dmaMemoryLen;
         os_bit32    nvMemoryLen;
         os_bit32    cardRamUpper32;
         os_bit32    cardRamLower32;
         os_bit32    cardRamLen;
         os_bit32    cardRomUpper32;
         os_bit32    cardRomLower32;
         os_bit32    cardRomLen;
         os_bit32    usecsPerTick;
       };

typedef struct fiMemMapParameters_s
               fiMemMapParameters_t;

struct fiMemMapParameters_s
       {
         os_bit32 NumDevSlotsPerArea;
         os_bit32 NumAreasPerDomain;
         os_bit32 NumDomains;
         os_bit32 NumDevices;
         os_bit32 NumIOs;
         os_bit32 SizeSGLs;
         os_bit32 NumSGLs;
         os_bit32 SizeCachedSGLs;
         os_bit32 FCP_CMND_Size;
         os_bit32 FCP_RESP_Size;
         os_bit32 SF_CMND_Reserve;
         os_bit32 SF_CMND_Size;
         os_bit32 NumTgtCmnds;
         os_bit32 TGT_CMND_Size;
#ifdef _DvrArch_1_30_
         os_bit32 Pkt_CMND_Size;
         os_bit32 NumPktThreads;
#endif /* _DvrArch_1_30_ was defined */
         os_bit32 NumCommandQ;
         os_bit32 NumCompletionQ;
         os_bit32 NumInboundBufferQ;
         os_bit32 InboundBufferSize;
         os_bit32 CardRamSize;
         os_bit32 CardRamAlignment;
         os_bit32 HostNvRamSize;
         os_bit32 ExchangeTableLoc;
         os_bit32 SGLsLoc;
         os_bit32 FCP_CMND_Loc;
         os_bit32 FCP_RESP_Loc;
         os_bit32 SF_CMND_Loc;
#ifdef _DvrArch_1_30_
         os_bit32 Pkt_CMND_Loc;
#endif /* _DvrArch_1_30_ was defined */
         os_bit32 CommandQLoc;
         os_bit32 CommandQConsLoc;
         os_bit32 CompletionQLoc;
         os_bit32 CompletionQProdLoc;
         os_bit32 InboundBufferLoc;
         os_bit32 TimerTickInterval;
         os_bit32 IO_Mode;
         os_bit32 IntDelayAmount;
         os_bit32 IntDelayRateMethod;
         os_bit32 IntDelayOnIORate;
         os_bit32 IntDelayOffIORate;
         os_bit32 IOsBetweenISRs;
#ifdef _Enforce_MaxCommittedMemory_
         os_bit32 MaxCommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */
         os_bit32 FlashUsageModel;
         os_bit32 InitAsNport;
         os_bit32 RelyOnLossSyncStatus;

         os_bit32 WolfPack;
         os_bit32 HeartBeat;
         os_bit32 ED_TOV;
         os_bit32 RT_TOV;
         os_bit32 LP_TOV;
         os_bit32 AL_Time;
         os_bit32 R_A_TOV;
       };

typedef struct fiMemMapToRequest_s
               fiMemMapToRequest_t;

struct fiMemMapToRequest_s
       {
         os_bit32 cachedMemoryNeeded;
         os_bit32 cachedMemoryPtrAlignAssumed;
         os_bit32 dmaMemoryNeeded;
         os_bit32 dmaMemoryPtrAlignAssumed;
         os_bit32 dmaMemoryPhyAlignAssumed;
         os_bit32 cardRamNeeded;
         os_bit32 cardRamPhyAlignAssumed;
         os_bit32 nvMemoryNeeded;
         os_bit32 usecsPerTick;
       };

enum fiMemMapMemoryLocation_e
     {
       inCachedMemory,
       inDmaMemory,
       inCardRam
     };

typedef enum fiMemMapMemoryLocation_e
             fiMemMapMemoryLocation_t;

typedef struct fiMemMapMemoryCachedMemoryAddress_s
               fiMemMapMemoryCachedMemoryAddress_t;

struct fiMemMapMemoryCachedMemoryAddress_s
       {
         void *cachedMemoryPtr;
       };

typedef struct fiMemMapMemoryDmaMemoryAddress_s
               fiMemMapMemoryDmaMemoryAddress_t;

struct fiMemMapMemoryDmaMemoryAddress_s
       {
         os_bit32  dmaMemoryUpper32;
         os_bit32  dmaMemoryLower32;
         void  *dmaMemoryPtr;
       };

typedef struct fiMemMapMemoryCardRamAddress_s
               fiMemMapMemoryCardRamAddress_t;

struct fiMemMapMemoryCardRamAddress_s
       {
         os_bit32 cardRamUpper32;
         os_bit32 cardRamLower32;
         os_bit32 cardRamOffset;
       };

typedef union fiMemMapMemoryAddress_s
              fiMemMapMemoryAddress_t;

union fiMemMapMemoryAddress_s
      {
        fiMemMapMemoryCachedMemoryAddress_t CachedMemory;
        fiMemMapMemoryDmaMemoryAddress_t    DmaMemory;
        fiMemMapMemoryCardRamAddress_t      CardRam;
      };

typedef struct fiMemMapMemoryDescriptor_s
               fiMemMapMemoryDescriptor_t;

struct fiMemMapMemoryDescriptor_s
       {
         fiMemMapMemoryDescriptor_t *flink;       /* Must be first field !!! */
         os_bit32                       objectSize;
         os_bit32                       objectAlign;
         os_bit32                       elements;
         os_bit32                       elementSize;
         fiMemMapMemoryLocation_t    memLoc;
         fiMemMapMemoryAddress_t     addr;
       };

typedef struct fiMemMapMemoryLayout_s
               fiMemMapMemoryLayout_t;

struct fiMemMapMemoryLayout_s
       {
         os_bit32                       On_Card_MASK;
         fiMemMapMemoryDescriptor_t *unsorted;
         fiMemMapMemoryDescriptor_t *sortedCachedMemory;
         fiMemMapMemoryDescriptor_t *sortedDmaMemory;
         fiMemMapMemoryDescriptor_t *sortedCardRam;
         fiMemMapMemoryDescriptor_t  SEST;
         fiMemMapMemoryDescriptor_t  ESGL;
         fiMemMapMemoryDescriptor_t  FCP_CMND;
         fiMemMapMemoryDescriptor_t  FCP_RESP;
         fiMemMapMemoryDescriptor_t  SF_CMND;
#ifdef _DvrArch_1_30_
         fiMemMapMemoryDescriptor_t  Pkt_CMND;
#endif /* _DvrArch_1_30_ was defined */
         fiMemMapMemoryDescriptor_t  ERQ;
         fiMemMapMemoryDescriptor_t  ERQConsIndex;
         fiMemMapMemoryDescriptor_t  IMQ;
         fiMemMapMemoryDescriptor_t  IMQProdIndex;
         fiMemMapMemoryDescriptor_t  SFQ;
         fiMemMapMemoryDescriptor_t  FlashSector;
         fiMemMapMemoryDescriptor_t  SlotWWN;
         fiMemMapMemoryDescriptor_t  FabricDeviceMAP;
         fiMemMapMemoryDescriptor_t  LOOPDeviceMAP;
         fiMemMapMemoryDescriptor_t  CThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  CTransitions;
         fiMemMapMemoryDescriptor_t  CActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
#ifdef _DvrArch_1_30_
         fiMemMapMemoryDescriptor_t  IPThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  IPTransitions;
         fiMemMapMemoryDescriptor_t  IPActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  PktThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  PktTransitions;
         fiMemMapMemoryDescriptor_t  PktActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
#endif /* _DvrArch_1_30_ was defined */
         fiMemMapMemoryDescriptor_t  TgtThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  TgtTransitions;
         fiMemMapMemoryDescriptor_t  TgtActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  DevThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  DevTransitions;
         fiMemMapMemoryDescriptor_t  DevActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  CDBThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  CDBTransitions;
         fiMemMapMemoryDescriptor_t  CDBActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  SFThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  SFTransitions;
         fiMemMapMemoryDescriptor_t  SFActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
       };

typedef struct fiMemMapCalculation_s
               fiMemMapCalculation_t;

struct fiMemMapCalculation_s
       {
         fiMemMapInput_t        Input;
         fiMemMapParameters_t   Parameters;
         fiMemMapToRequest_t    ToRequest;
         fiMemMapMemoryLayout_t MemoryLayout;
       };

/*+
Function prototype
-*/

/*+
Function:  fiMemMapCalculate()

Purpose:   Calculates the memory layout for the entire FC Layer.

Assumes:   Calculation->Input has been initialized to describe the
           memory allocated to the FC Layer (as the arguments to
           fcInitializeChannel() indicate).  In the initial call from
           fcInitializeDriver(), the following values should be used:

                Calculation.Input.initType         = 0;
                Calculation.Input.sysIntsActive    = agFALSE;
                Calculation.Input.cachedMemoryPtr  = agNULL;
                Calculation.Input.cachedMemoryLen  = 0xFFFFFFFF;
                Calculation.Input.dmaMemoryUpper32 = 0;
                Calculation.Input.dmaMemoryLower32 = 0;
                Calculation.Input.dmaMemoryPtr     = agNULL;
                Calculation.Input.dmaMemoryLen     = 0xFFFFFFFF;
                Calculation.Input.nvMemoryLen      = 0xFFFFFFFF;
                Calculation.Input.cardRamUpper32   = 0;
                Calculation.Input.cardRamLower32   = 0;
                Calculation.Input.cardRamLen       = 0xFFFFFFFF;
                Calculation.Input.cardRomUpper32   = 0;
                Calculation.Input.cardRomLower32   = 0;
                Calculation.Input.cardRomLen       = 0xFFFFFFFF;
                Calculation.Input.usecsPerTick     = 0;

Returns:   agTRUE     If the resulting memory layout will fit
                    in the memory specified in Calculation->Input

           agFALSE    If the resulting memory layout will not fit
                    in the memory specified in Calculation->Input
-*/

osGLOBAL agBOOLEAN fiMemMapCalculate(
                                  agRoot_t              *hpRoot,
                                  fiMemMapCalculation_t *Calculation,
                                  agBOOLEAN                EnforceDefaults
                                );

#endif /* __MemMap_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\oscalls.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   oscalls.c

Abstract:

   Contains calls to kernel

Authors:

   Michael Bessire
   Dennis Lindfors FC Layer support

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/MSE/OSLayer/C/OSCALLS.C $


Revision History:

   $Revision: 6 $
   $Date: 12/07/00 3:10p $
   $Modtime:: 12/07/00 3:09p           $

Notes:

--*/


#include "buildop.h"


#ifdef _DEBUG_READ_FROM_REGISTRY

BOOLEAN
ReadFromRegistry (char *paramName, int type, void *data, int len)
{
   return TRUE;
}

void
osBugCheck (ULONG code,
   ULONG param1,
   ULONG param2,
   ULONG param3,
   ULONG param4)
{
}

#endif // 

#ifndef osTimeStamp
#ifndef _SYSTEM_TIMESTAMP_
void
GetSystemTime (
   short int *Year, 
   short int *Month,
   short int *Day, 
   short int *Hour,
   short int *Minute,
   short int *Second,
   short int *Milliseconds)
{
   
}


unsigned long get_time_stamp(void)
{
	return 0;
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\osapi.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Osapi.c

Abstract:

    This file provides OS specific functions to the FCLayer

Authors:

    Dennis Lindfors

Environment:

    kernel mode only


Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/OSAPI.C $

Revision History:

    $Revision: 7 $
    $Date: 12/07/00 1:37p $
    $Modtime:: 12/07/00 1:36p    $


*/

#include "buildop.h"        //LP021100 build switches
#include "osflags.h"
//#include <memory.h>

#if DBG > 0
#include <stdarg.h>
//#include <stdio.h>
#include "ntdebug.h"
#endif // DBG

#if DBG < 2
os_bit32   hpFcConsoleLevel = 0;
os_bit32   hpFcTraceLevel = 0;
#else
os_bit32   hpFcConsoleLevel = EXTERNAL_HP_DEBUG_LEVEL; // NTdebug.h
os_bit32   hpFcTraceLevel = 0;

#endif

extern ULONG gCrashDumping;

void ERROR_CONTEXT(char * file,  int line)
{
    osDEBUGPRINT((ALWAYS_PRINT,"Invalid Context File %s Line %d\n",file, line));
    // Bad_Things_Happening
}

#ifdef NEVEREVER
void * osGetVirtAddress(
    agRoot_t      *hpRoot,
    agIORequest_t *hpIORequest,
    os_bit32      phys_addr
    )
{
    PCARD_EXTENSION pCard;
    PSRB_EXTENSION pSrbExt;
    
    void * Virtaddr = NULL;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    
    osDEBUGPRINT((DHIGH,"IN osGetVirtAddress hpIORequest %lx phys_addr %x\n", hpIORequest,phys_addr ));
    
    //pSrbExt = (PSRB_EXTENSION)hpIORequest->osData;
    pSrbExt = hpObjectBase(SRB_EXTENSION,hpIORequest,hpIORequest);
    
    if( pSrbExt->OrigPhysicalDataAddr == phys_addr)
    {
       Virtaddr = pSrbExt->OrigVirtDataAddr;
    }
    
    if(!Virtaddr ) osDEBUGPRINT((DMOD,"OUT osGetVirtAddress Addr %lx\n", Virtaddr));
    
    return(Virtaddr );
}
#endif // NEVEREVER

os_bit32 osGetSGLChunk(
    agRoot_t         *hpRoot,
    agIORequest_t    *hpIORequest,
    os_bit32          hpChunkOffset,
    os_bit32         *hpChunkUpper32,
    os_bit32         *hpChunkLower32,
    os_bit32         *hpChunkLen
    )
{
	SCSI_PHYSICAL_ADDRESS phys_addr;
	PSRB_EXTENSION pSrbExt;
	os_bit32 length;
	PCARD_EXTENSION pCard;
	ULONG	printLevel;
	PVOID	param;

	pCard   = (PCARD_EXTENSION)hpRoot->osData;
    //pSrbExt = (PSRB_EXTENSION)hpIORequest->osData;
	pSrbExt = hpObjectBase(SRB_EXTENSION,hpIORequest,hpIORequest);

	pSrbExt->SglElements++;

	#ifdef _DEBUG_CRASHDUMP_
	if (gCrashDumping)
		printLevel = ALWAYS_PRINT;
	else
	#endif
		printLevel = DHIGH;

	osDEBUGPRINT((printLevel,"IN osGetSGLChunk hpRoot %lx hpIORequest %lx\n", hpRoot, hpIORequest ));
	osDEBUGPRINT((printLevel,"pCard %lx pSrbExt %lx Data addr %lx Length %x\n", pCard ,
                        pSrbExt,pSrbExt->SglVirtAddr, pSrbExt->SglDataLen ));

	osDEBUGPRINT((printLevel,"Data offset %x U %lx L %x pLen %x\n",hpChunkOffset,*hpChunkUpper32,*hpChunkLower32,*hpChunkLen ));
	
	param = (PSCSI_REQUEST_BLOCK)pSrbExt->pSrb;

	#ifdef DOUBLE_BUFFER_CRASHDUMP
	if (gCrashDumping)
	{
	   if (pSrbExt->orgDataBuffer)
		   param = NULL;
	   length = pSrbExt->SglDataLen;
	}
	#endif
	phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                        // (PSCSI_REQUEST_BLOCK)pSrbExt->pSrb,
										(PSCSI_REQUEST_BLOCK)param,
                                        pSrbExt->SglVirtAddr+hpChunkOffset,
                                        &length);

	osDEBUGPRINT((printLevel,"Length %x High %x Low %x\n",length, phys_addr.HighPart,phys_addr.LowPart ));

	if(phys_addr.LowPart == 0 &&  phys_addr.HighPart == 0 ) return(osSGLInvalid);

	*hpChunkLower32 = phys_addr.LowPart;
	*hpChunkUpper32 = phys_addr.HighPart;

	// WAS pSrbExt->SglVirtAddr += length;

	if(  (int)(pSrbExt->SglDataLen) < (length+hpChunkOffset))
	{
		*hpChunkLen = (int)(pSrbExt->SglDataLen) - hpChunkOffset;
	}
	else
	{
		// pSrbExt->SglDataLen-= length;
		*hpChunkLen = length;
	}

	osDEBUGPRINT((printLevel,"OUT osGetSGLChunk length %lx hpChunkLen %lx Data addr %lx Length %x\n", length , *hpChunkLen,pSrbExt->SglVirtAddr, pSrbExt->SglDataLen ));

	return(osSGLSuccess);
}


char * error_discriptions[25]=
{
   "ERR_MAP_IOBASELADDR   ",
   "ERR_MAP_IOBASEUADDR   ",
   "ERR_UNCACHED_EXTENSION",
   "ERR_RESET_FAILED      ",
   "ERR_ALIGN_QUEUE_BUF   ",
   "ERR_ACQUIRED_ALPA     ",
   "ERR_RECEIVED_LIPF_ALPA",
   "ERR_RECEIVED_BAD_ALPA ",
   "ERR_CM_RECEIVED       ",
   "ERR_INT_STATUS ?IDLE ?",
   "ERR_FM_STATUS         ",
   "ERR_PLOGI             ",
   "ERR_PDISC             ",
   "ERR_ADISC             ",
   "ERR_PRLI              ",
   "ERR_ERQ_FULL          ",
   "ERR_INVALID_LUN_EXT   ",
   "ERR_SEST_INVALIDATION ",
   "ERR_SGL_ADDRESS       ",
   "ERR_SGL_CHUNK_INVALID ",
   "ERR_SGL_DESCRIPTOR    ",
   "ERR_FCP_CONTROL       ",
   "ERR_CACHED_EXTENSION  ",
   "LINK UP DOWN DETECTED ",
   "UNKNOWN ERROR !       "
};

//
// osLogBit32 ()
//
// Logs the value of the input parameter "hpBit32" to event log.
//

osGLOBAL void osLogBit32(
   agRoot_t *hpRoot,
   os_bit32  hpBit32
   )
{
   PCARD_EXTENSION pCard;
   BOOLEAN known_error = FALSE;
   char *tmp = error_discriptions[24];

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   switch(hpBit32)
   {
      case    0xf0000000: tmp=error_discriptions[0];  known_error = TRUE; break;
      case    0xe0000000: tmp=error_discriptions[1];  known_error = TRUE; break;
      case    0xd0000000: tmp=error_discriptions[2];  known_error = TRUE; break;
      case    0xc0000000: tmp=error_discriptions[3];  known_error = TRUE; break;
      case    0xb0000000: tmp=error_discriptions[4];  known_error = TRUE; break;
      case    0xa0000000: tmp=error_discriptions[5];  known_error = TRUE; break;
      case    0x90000000: tmp=error_discriptions[6];  known_error = TRUE; break;
      case    0x80000000: tmp=error_discriptions[7];  known_error = TRUE; break;
      case    0x80000300: tmp=error_discriptions[23]; known_error = TRUE; break;
      case    0x70000000: tmp=error_discriptions[8];  known_error = TRUE; break;
      case    0x70000001: tmp=error_discriptions[24]; known_error = TRUE; break;
      case    0x60000000: tmp=error_discriptions[9];  known_error = TRUE; break;
      case    0x50000000: tmp=error_discriptions[10]; known_error = TRUE; break;
      case    0x40000000: tmp=error_discriptions[11]; known_error = TRUE; break;
      case    0x30000000: tmp=error_discriptions[12]; known_error = TRUE; break;
      case    0x20000000: tmp=error_discriptions[13]; known_error = TRUE; break;
      case    0x10000000: tmp=error_discriptions[14]; known_error = TRUE; break;
      case    0x0f000000: tmp=error_discriptions[15]; known_error = TRUE; break;
      case    0x0e000000: tmp=error_discriptions[16]; known_error = TRUE; break;
      case    0x0d000000: tmp=error_discriptions[17]; known_error = TRUE; break;
      case    0x0c000000: tmp=error_discriptions[18]; known_error = TRUE; break;
      case    0x0b000000: tmp=error_discriptions[19]; known_error = TRUE; break;
      case    0x0a000000: tmp=error_discriptions[20]; known_error = TRUE; break;
      case    0x09000000: tmp=error_discriptions[21]; known_error = TRUE; break;
      case    0xd8000000: tmp=error_discriptions[22]; known_error = TRUE; break;

      // default:
   }
   osDEBUGPRINT((ALWAYS_PRINT,"osLogBit32 %x %s \n", hpBit32,tmp));

   ScsiPortLogError( pCard,
                        NULL,
                        0,
                        0,
                        0,
                        SP_INTERNAL_ADAPTER_ERROR,
                        hpBit32 );

   #ifdef _DEBUG_EVENTLOG_
   LogEvent(pCard, NULL, HPFC_MSG_LOGBIT32, NULL, 0, "hex(%08x) %s", hpBit32, tmp);
   #endif
   
}


#ifdef _DvrArch_1_20_

//
// osLogDebugString ()
//
// Generates a formatted string and logs the formatted string to
// either debug window or trace buffer or both depending on the
// input parameters "detailLevel".
//
// If the input parameter "detailLevel" is less than or equal to
// the global parameter hpFcConsoleLevel then the formatted string is
// logged to the debug window.
//
// If the input parameter "detailLevel" is less than or equal to
// the global parameter hpFcTraceLevel then the formatted string is
// logged to the trace buffer.
//
#ifndef osLogDebugString
osGLOBAL void
osLogDebugString (
   agRoot_t *hpRoot,
   os_bit32  detailLevel,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   void     *firstPtr,
   void     *secondPtr,
   os_bit32  firstBit32,
   os_bit32  secondBit32,
   os_bit32  thirdBit32,
   os_bit32  fourthBit32,
   os_bit32  fifthBit32,
   os_bit32  sixthBit32,
   os_bit32  seventhBit32,
   os_bit32  eighthBit32 )
{
#if DBG
   PCARD_EXTENSION pCard;
   char            *trBufEnd, *srcPtr;
   char            s[256];
   os_bit32        n=0;
   char            *ps;
   CSHORT          year, month, day;
   CSHORT          hour, minute, second, milliseconds;

   ps = &s[0];

   #ifdef testing  
   s[250] = '\0';
   s[251] = 'K';
   s[252] = 'I';
   s[253] = 'L';
   s[254] = 'L';
   s[255] = '\0';
   #endif
   
      
   n = agFmtFill (s, (os_bit32) 255,
                     formatString,
                     firstString, secondString, firstPtr, secondPtr,
                     firstBit32, secondBit32, thirdBit32, fourthBit32,
                     fifthBit32, sixthBit32, seventhBit32, eighthBit32);

   if (n > 255) 
   {
      osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
      n=255;  
   }

   #ifdef TESTING
   if (( s[250] != '\0' ) || 
       ( s[251] != 'K'  ) ||
       ( s[252] != 'I'  ) ||
       ( s[253] != 'L'  ) ||
       ( s[254] != 'L'  ) ||
       ( s[255] != '\0' ) )
   {
      osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: agFmtFill modify end of line signature\n"));
      #ifdef _DEBUG_EVENTLOG_
      LogEvent(   NULL, 
                  NULL,
                  HPFC_MSG_INTERNAL_ERROR,
                  NULL, 
                  0, 
                  "%s",
                  "agFmtFill overrun");
      #endif
   }
   #endif 
      
       
   s[n] = '\0';

   GetSystemTime (&year, &month, &day, &hour, &minute, &second, &milliseconds);

   if (detailLevel <= hpFcConsoleLevel)
   {
      osDEBUGPRINT(((ALWAYS_PRINT),"%02d:%02d:%02d:%03d[%10d]%s\n",
            hour, minute, second, milliseconds, osTimeStamp(0), ps));
   }

   if (hpRoot == NULL || hpRoot->osData == NULL)
        return;

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   if ((detailLevel <= hpFcTraceLevel) && (n > 0)) 
   {
      char    s1[256];

      n = agFmtFill (s1, (os_bit32) 255,
                        "%02d:%02d:%02d:%03d[%10d]%s\n",
                        s, NULL, 0, 0,
                        (os_bit32)hour, (os_bit32)minute, (os_bit32)second, (os_bit32)milliseconds,
                        osTimeStamp(0), 0, 0, 0);

      if (n > 255) 
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
         n=255;  
      }

      s[n] = '\0';

#if DBG_TRACE
      trBufEnd = &pCard->traceBuffer[0] + pCard->traceBufferLen;
      srcPtr = &s1[0];
      while (n--) 
      {
         *pCard->curTraceBufferPtr = *srcPtr;
         srcPtr++;
         pCard->curTraceBufferPtr++;
         if (pCard->curTraceBufferPtr >= trBufEnd)
            pCard->curTraceBufferPtr = &pCard->traceBuffer[0];
      }
      *pCard->curTraceBufferPtr = '\0';
#endif
   }

#endif // DBG
}
#endif /* osLogDebugString was defined */


#else /* _DvrArch_1_20_ was not defined */

//
// osLogDebugString ()
//
// Generates a formatted string and logs the formatted string to
// either debug window or trace buffer or both depending on the
// input parameters "consoleLevel" and "traceLevel".
// If the input parameter "consoleLevel" is less than or equal to
// the global parameter hpFcConsoleLevel then the formatted string is
// logged to the debug window.
// If the input parameter "traceLevel" is less than or equal to
// the global parameter hpFcTraceLevel then the formatted string is
// logged to the trace buffer.
//
#ifndef osLogDebugString
osGLOBAL void
osLogDebugString (
   hpRoot_t *hpRoot,
   bit32  consoleLevel,
   bit32  traceLevel,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   bit32  firstBit32,
   bit32  secondBit32,
   bit32  thirdBit32,
   bit32  fourthBit32,
   bit32  fifthBit32,
   bit32  sixthBit32,
   bit32  seventhBit32,
   bit32  eighthBit32 )
{
#if DBG
   PCARD_EXTENSION pCard;
   char            *trBufEnd, *srcPtr;
   char            s[256];
   bit32         n=0;
   char            *ps;
   CSHORT          year, month, day;
   CSHORT          hour, minute, second, milliseconds;

   ps = &s[0];

   n = hpFmtFill (s, (os_bit32) 255,
                     formatString,
                     firstString, secondString,
                     firstBit32, secondBit32, thirdBit32, fourthBit32,
                     fifthBit32, sixthBit32, seventhBit32, eighthBit32);

   if (n > 255) 
   {
      osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
   }
   s[n] = '\0';

   GetSystemTime (&year, &month, &day, &hour, &minute, &second, &milliseconds);

   if (consoleLevel <= hpFcConsoleLevel)
   {
      osDEBUGPRINT(((ALWAYS_PRINT),"%02d:%02d:%02d:%03d[%10d]%s\n",
            hour, minute, second, milliseconds, osTimeStamp(0), ps));
   }

   if (hpRoot == NULL || hpRoot->osData == NULL)
        return;

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   if ((traceLevel <= hpFcTraceLevel) && (n > 0)) 
   {
      char    s1[256];

      n = hpFmtFill (s1, (os_bit32) 255,
                        "%02d:%02d:%02d:%03d[%10d]%s\n",
                        s, NULL,
                        (os_bit32)hour, (os_bit32)minute, (os_bit32)second, (os_bit32)milliseconds,
                        osTimeStamp(0), 0, 0, 0);

      if (n > 255) 
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
      }

      s[n] = '\0';

#if DBG_TRACE
      trBufEnd = &pCard->traceBuffer[0] + pCard->traceBufferLen;
      srcPtr = &s1[0];
      while (n--) 
      {
         *pCard->curTraceBufferPtr = *srcPtr;
         srcPtr++;
         pCard->curTraceBufferPtr++;
         if (pCard->curTraceBufferPtr >= trBufEnd)
            pCard->curTraceBufferPtr = &pCard->traceBuffer[0];
      }
      *pCard->curTraceBufferPtr = '\0';
#endif
   }

#endif // DBG
}
#endif /* osLogDebugString was defined */

#endif   /* _DvrArch_1_20_ was not defined */



#ifdef _DvrArch_1_20_

void osLogString(
   agRoot_t *hpRoot,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   void     *firstPtr,
   void     *secondPtr,
   os_bit32  firstBit32,
   os_bit32  secondBit32,
   os_bit32  thirdBit32,
   os_bit32  fourthBit32,
   os_bit32  fifthBit32,
   os_bit32  sixthBit32,
   os_bit32  seventhBit32,
   os_bit32  eighthBit32
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;

//   osDEBUGPRINT((ALWAYS_PRINT,"osLogString enter\n"));

   #ifdef LP012800_OLDSTUFF
   ScsiPortLogError( pCard,
                        NULL,
                        0,
                        0,
                        0,
                        fifthBit32,
                        sixthBit32 );
   #endif
                  
   #ifdef _DEBUG_EVENTLOG_
   {
      char            s[256];
      os_bit32           n=0;
      
      if ( LogLevel == LOG_LEVEL_NONE ) 
      {
//       osDEBUGPRINT((ALWAYS_PRINT,"osLogString exit\n"));
         return;
      }
      
      #ifdef TESTING
      s[250] = '\0';
      s[251] = 'K';
      s[252] = 'I';
      s[253] = 'L';
      s[254] = 'L';
      s[255] = '\0';
      #endif
      
      n = agFmtFill (s, (os_bit32) 255,
                         formatString,
                         firstString, secondString, firstPtr, secondPtr,
                         firstBit32, secondBit32, thirdBit32, fourthBit32,
                         fifthBit32, sixthBit32, seventhBit32, eighthBit32);
      if (n > 255) 
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogString: hpFmtFill returned value > target string length"));
         n=255;  
      }
      
          
      s[n] = '\0';
       
      #ifdef TESTING
      if (( s[250] != '\0' ) || 
          ( s[251] != 'K'  ) ||
          ( s[252] != 'I'  ) ||
          ( s[253] != 'L'  ) ||
          ( s[254] != 'L'  ) ||
          ( s[255] != '\0' ) )
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogString: agFmtFill modify end of line signature\n"));
         LogEvent(   NULL, 
                     NULL,
                     HPFC_MSG_INTERNAL_ERROR,
                     NULL, 
                     0, 
                     "%s",
                     "agFmtFill overrun");
//        osDEBUGPRINT((ALWAYS_PRINT,"osLogString enter\n"));
         return;     
      }
      #endif
      
      LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4, NULL, 0, "%s", s);
   }
   #endif      
//    osDEBUGPRINT((ALWAYS_PRINT,"osLogString exit\n"));
   return;     

}


#else /* _DvrArch_1_20_ was not defined */

void osLogString(
   hpRoot_t *hpRoot,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   bit32  firstBit32,
   bit32  secondBit32,
   bit32  thirdBit32,
   bit32  fourthBit32,
   bit32  fifthBit32,
   bit32  sixthBit32,
   bit32  seventhBit32,
   bit32  eighthBit32
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;

//   osDEBUGPRINT((ALWAYS_PRINT,"osLogString enter\n"));

   #ifdef OLDSTUFF
   ScsiPortLogError( pCard,
                       NULL,
                       0,
                       0,
                       0,
                       fifthBit32,
                       sixthBit32 );
   #endif
                  
   #ifdef _DEBUG_EVENTLOG_
   {
      char            s[256];
      bit32           n=0;
      
      n = hpFmtFill (s, (os_bit32) 255,
                         formatString,
                         firstString, secondString,
                         firstBit32, secondBit32, thirdBit32, fourthBit32,
                         fifthBit32, sixthBit32, seventhBit32, eighthBit32);
      if (n > 255)    
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
         n=255;  
      }     
      
      s[n] = '\0';
       
      LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4, NULL, 0, "%s", s);
   }
   #endif      

//    osDEBUGPRINT((ALWAYS_PRINT,"osLogString exit\n"));
}

#endif   /* _DvrArch_1_20_ was not defined */

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)
os_bit32    osStallThreadBrk=0;
ULONG       curAddress=0;
long        curCount=0;
long        curMs=0;
#define     DEBUG_STALL_COUNT  100000

osGLOBAL void osStallThread(
   agRoot_t *hpRoot,
   os_bit32 microseconds
   )
{   
    ULONG            address;
    PCARD_EXTENSION pCard;
    ULONG           x;
    __asm
    {
        ;
        ; c call already push the ebp
        ;   push    ebp
        ;   mov     ebp,esp
        mov     eax, dword ptr [ebp+4]        ; Get returned address
        mov     address, eax
    }
    /* record stall per ISR */
    pCard = (PCARD_EXTENSION)hpRoot->osData;
    for (x=0;x< STALL_COUNT_MAX;x++)
    {
        if ( pCard->StallData[x].Address == address)
        {
            pCard->StallData[x].MicroSec += microseconds;
            break;
        }
    }
    
    
    if (x == STALL_COUNT_MAX)
    {
        for (x=0;x< STALL_COUNT_MAX;x++)
        {
            if ( ! pCard->StallData[x].Address)
            {
                pCard->StallData[x].MicroSec += microseconds;
                pCard->StallData[x].Address = address;
                break;
            }
        }
    }

    pCard->StallCount += microseconds;

    if (curAddress == address)
    {
        curCount+=microseconds;
        curMs+=microseconds;
    }
    else
    {
        curCount= 0;
        curMs = 0;
    }
    curAddress = address;

    if (osStallThreadBrk || (curCount > DEBUG_STALL_COUNT) )
    {
        curCount = curCount % DEBUG_STALL_COUNT;
        osDEBUGPRINT((ALWAYS_PRINT,"osStallThread in address=%x  %d ms\n",address, curMs));
    }
    
    ScsiPortStallExecution(microseconds);
}
#else
osGLOBAL void osStallThread(
   agRoot_t *hpRoot,
   os_bit32 microseconds
   )
{
   //PCARD_EXTENSION pCard;
   //pCard = (PCARD_EXTENSION)hpRoot->osData;
   // osDEBUGPRINT((DLOW,"IN osStallThread %x\n",microseconds));
   ScsiPortStallExecution(microseconds);
}
#endif

// Copy (destin, source, size) in reverse order
void osCopyAndSwap(void * destin, void * source, UCHAR length )
{
   PULONG out= (PULONG)destin;
   PULONG in= (PULONG)source;
   ULONG invalue;
   UCHAR x;
   // osDEBUGPRINT((DVHIGH,"IN osCopyAndSwap %lx %lx %x\n", destin, source,length ));
   // osDEBUGPRINT((DVHIGH,"IN source  %02x %02x %02x %02x %02x\n",((PUCHAR)source)+0,
   //                                                      ((PUCHAR)source)+1,
   //                                                      ((PUCHAR)source)+2,
   //                                                      ((PUCHAR)source)+4,
   //                                                      ((PUCHAR)source)+5 ));
   if(length >= 4) length /= 4;
   for(x=0; x< length; x++)
   {
      invalue = *(in+ x);
      *(out + x) = SWAPDWORD(invalue);
   }

}

void osCopy(void * destin, void * source, os_bit32 length )
{
   ScsiPortMoveMemory( destin, source, length );
}

void osZero(void * destin, os_bit32 length )
{
   memset( destin, 0,length );
}

void osFill(void * destin, os_bit32 length, os_bit8 fill )
{
   PUCHAR out= (PUCHAR)destin;

   // osDEBUGPRINT((DVHIGH,"osZero out %lx in %lx length %x\n", destin, length  ));

   memset( destin, fill,length );

   // PERF  for(x=0; x < length; x++){
   // osDEBUGPRINT((DVHIGH,"osCopy out %lx in %lx %x\n", (out + x)));
   // PERF *(out + x) = fill;
   // PERF}
}

//
// osStringCompare ()
//
// Compares the strings str1 and str2.
// Returns:
//     TRUE    If str1 is equal to str2
//     FALSE   If str1 is not equal to str2
//
BOOLEAN
osStringCompare (
   char *str1,
   char *str2)
{
   while (*str1 !=  '\0' && *str2 != '\0' ) 
   {
      if (*str1 == *str2) 
      {
         str1++;
         str2++;
      } 
      else
         break;
   }

   if (*str1 == *str2)
      return TRUE;
   else
      return FALSE;
}

//
// osMemCompare ()
//
// Compares the strings "str1" and "str2" for "count" number of bytes.
// Returns:
//     TRUE    If str1 is equal to str2
//     FALSE   If str1 is not equal to str2
//
BOOLEAN
osMemCompare (char *str1, char *str2, int count)
{
   while (count--) 
   {
      if (*str1 != *str2)
         return FALSE;
      str1++;
      str2++;
   }

   return TRUE;
}

//
// osStringCopy ()
//
// Parameters:
//     destStr    Pointer to destination string
//     sourceStr  Pointer to source string
//     destStrLen Maximum number of bytes to be copied
//
// Copies bytes from the sourceStr to destStr.
//
void
osStringCopy (
   char *destStr,
   char *sourceStr,
   int  destStrLen)
{
   while (destStrLen--) 
   {
      *destStr = *sourceStr;
      if (*sourceStr == '\0')
         break;
      *destStr++;
      *sourceStr++;
   }
}

os_bit8
osChipConfigReadBit8 (agRoot_t *hpRoot, os_bit32 cardConfigOffset)
{
   PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;

   return *(((os_bit8 *)pCard->pciConfigData) + cardConfigOffset);
}

os_bit16
osChipConfigReadBit16 (agRoot_t *hpRoot, os_bit32 cardConfigOffset)
{
   PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;

   return *((os_bit16 *)(((os_bit8 *)pCard->pciConfigData) + cardConfigOffset));
}

os_bit32
osChipConfigReadBit32 (agRoot_t *hpRoot, os_bit32 cardConfigOffset)
{
   PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;

   return *((PULONG)(((os_bit8 *)pCard->pciConfigData) + cardConfigOffset));
}

void
osChipConfigWriteBit( agRoot_t *hpRoot, os_bit32 cardConfigOffset,os_bit32 chipIOLValue, os_bit32 valuesize)
{
   os_bit32 length;
    PCARD_EXTENSION pCard;

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   osDEBUGPRINT((ALWAYS_PRINT,"osChipConfigWriteBit %lx %x %x\n", hpRoot, cardConfigOffset, chipIOLValue ));

   length = ScsiPortSetBusDataByOffset(pCard,
                               PCIConfiguration,
                               pCard->SystemIoBusNumber,
                               pCard->SlotNumber,
                               &chipIOLValue,
                               cardConfigOffset,
                               (valuesize/8));

   return;
}

osGLOBAL void osResetDeviceCallback(
   agRoot_t  *hpRoot,
   agFCDev_t  hpFCDev,
   os_bit32   hpResetStatus
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;

   osDEBUGPRINT((DLOW,"osResetDeviceCallback %lx Dev %lx\n", hpRoot, hpFCDev ));

}

#if DBG >= 1
osGLOBAL void osSingleThreadedEnter(
   agRoot_t *hpRoot
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;
   pCard->SingleThreadCount++;
   // osDEBUGPRINT((DLOW,"osSingleThreadedEnter %lx\n", hpRoot));

}

osGLOBAL void osSingleThreadedLeave(
   agRoot_t *hpRoot
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;
   pCard->SingleThreadCount--;
   // osDEBUGPRINT((DLOW,"osSingleThreadedLeave %lx\n", hpRoot));
}

#endif

void osFCLayerAsyncError( 
   agRoot_t *hpRoot,
   os_bit32  fcLayerError
   )
{
    PCARD_EXTENSION pCard;
    pCard = (PCARD_EXTENSION)hpRoot->osData;
    osDEBUGPRINT((ALWAYS_PRINT,"osFCLayerAsyncError %lx error\n", hpRoot,fcLayerError));
   
    if (fcLayerError == osFCConfused)
    {
        #ifdef _DEBUG_DETECT_P_ERR
        //WIN64 compliant
        if (gDebugPerr)
        {
        osBugCheck (0xe0000000, fcLayerError, 0, __LINE__, (pCard->SystemIoBusNumber << 16) | pCard->SlotNumber);
        }
        #endif
    }
}

void osFakeInterrupt( agRoot_t *hpRoot )
{
    PCARD_EXTENSION pCard = (PCARD_EXTENSION) hpRoot->osData;
    osDEBUGPRINT((DLOW,"IN osFakeInterrupt %lx @ %x\n", hpRoot, osTimeStamp(0)));

    HPFibreInterrupt( pCard );

    osDEBUGPRINT((DLOW,"OUT osFakeInterrupt %lx @ %x\n", hpRoot, osTimeStamp(0)));

}

#ifndef osTimeStamp

unsigned long get_time_stamp(void);

os_bit32
osTimeStamp (agRoot_t *hpRoot)
{
   return get_time_stamp ();
}

//
// Returns the number of units since the first time get_time_stamp called.
// Each unit is 1.6384 ms.
//

#endif

#ifdef _DEBUG_PERF_DATA_
void dump_perf_data( PCARD_EXTENSION pCard )
{
    int x;

    osDEBUGPRINT((ALWAYS_PRINT,"Dump Performance data start time %08x End time %08x\n",
    pCard->PerfStartTimed,osTimeStamp(0) ));

    for(x=0; x < LOGGED_IO_MAX-1; x++)
        osDEBUGPRINT((ALWAYS_PRINT,"%08x %08x %08x %08x %08x %08x %08x %08x %08x\n",
                   pCard->perf_data[x].inOsStartio,
                   pCard->perf_data[x].inFcStartio,
                   pCard->perf_data[x].outFcStartio,
                   pCard->perf_data[x].outOsStartio,
                   pCard->perf_data[x].inOsIsr,
                   pCard->perf_data[x].inFcDIsr,
                   pCard->perf_data[x].inOsIOC,
                   pCard->perf_data[x].outOsIOC,
                   pCard->perf_data[x].outOsIsr ));
}
#endif
os_bit8  SPReadRegisterUchar( void * x)
{
   os_bit8 tmp;
   tmp = ScsiPortReadRegisterUchar(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadRegisterUchar  %lx %02x\n",x,tmp));
   return( tmp );
}

os_bit16 SPReadRegisterUshort(void * x)
{
   os_bit16 tmp;
   tmp = ScsiPortReadRegisterUshort(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadRegisterUshort %lx %04x\n",x,tmp));
   return( tmp );
}

os_bit32 SPReadRegisterUlong( void * x)
{
   os_bit32 tmp;
   tmp = ScsiPortReadRegisterUlong(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadRegisterUlong %lx %08x\n",x,tmp));
   return( tmp );
}

void SPWriteRegisterUchar(void * x, os_bit8  y)  
{
   ScsiPortWriteRegisterUchar(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WriteRegisterUchar  %lx val %02x\n",x,y));
//   if(x == (void *)0xf888) Debug_Break_Point;
}

void SPWriteRegisterUshort(void * x, os_bit16 y)
{
   ScsiPortWriteRegisterUshort(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WriteRegisterUshort %lx val %04x\n",x,y));
//    if(x == (void *)0xf888) Debug_Break_Point;
}

void SPWriteRegisterUlong(void * x, os_bit32 y)
{
   ScsiPortWriteRegisterUlong(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WriteRegisterUlong  %lx val %08x\n",x,y));
//    if(x == (void *)0xf888) Debug_Break_Point;
}

os_bit8  SPReadPortUchar( void * x)
{
   os_bit8 tmp;
   tmp = ScsiPortReadPortUchar(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadPortUchar  %lx %02x\n",x,tmp));
   return( tmp );
}

os_bit16 SPReadPortUshort(void * x)
{
   os_bit16 tmp;
   tmp =  ScsiPortReadPortUshort(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadPortUshort  %lx %04x\n",x,tmp));
   return( tmp );
}
os_bit32 SPReadPortUlong( void * x)
{
   os_bit32 tmp;
   tmp = ScsiPortReadPortUlong(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadPortUlong   %lx %08x\n",x,tmp));
   return( tmp );
}

void SPWritePortUchar(void * x, os_bit8  y)  
{
   ScsiPortWritePortUchar(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WritePortUchar  %lx val %02x\n",x,y));
}

void SPWritePortUshort(void * x, os_bit16 y) 
{
   ScsiPortWritePortUshort(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WritePortUshort %lx val %04x\n",x,y));
}

void SPWritePortUlong(void * x, os_bit32 y)  
{
   ScsiPortWritePortUlong(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WritePortUlong  %lx val %08x\n",x,y));
}

//
//Moved from OSCALL.C
//
//WIN64 compliant

#ifndef osDebugBreakpoint

void 
osDebugBreakpoint (agRoot_t *hpRoot, agBOOLEAN BreakIfTrue, char *DisplayIfTrue)
{
   if (BreakIfTrue) 
   {
      osDEBUGPRINT((ALWAYS_PRINT,"%s\n", DisplayIfTrue));
      //DbgBreakPoint ();

   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ntdebug.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    ntdebug.c

Abstract:

    Debugging aid
   
Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Notes:

Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/NTDEBUG.C $


Revision History:

    $Revision: 5 $
    $Date: 12/07/00 1:35p $
    $Modtime:: 12/05/00 4:33p           $

Notes:


--*/

#include "globals.h"

#ifdef PVOID
#undef PVOID
#endif

//#ifdef BOOLEAN
//#undef BOOLEAN
//#endif


//#include <miniport.h>
#include <stdarg.h>
//#include <stdio.h>
#include "buildop.h"
#include "cstring.h"

#define SCSIPORT_API

SCSIPORT_API
VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


#define DebugPrint(x) ScsiDebugPrint x

extern ULONG DbgPrint( char * Format, ... );

ULONG Global_Print_Level; // DBG_DEBUG_FULL;

void osDebugPrintString( os_bit32 Print_LEVEL, char *formatString, ... )
{
    char buffer[512];
    ULONG instate;
    ULONG level;
    ULONG glob_level;
    ULONG glob_state;
    va_list ap;
    va_start(ap,formatString );

    // DebugPrint((0,"Print_LEVEL\n",Print_LEVEL));

    instate = Print_LEVEL & CS_DURING_ANY;
    level = Print_LEVEL & DBG_DEBUG_MASK;

    glob_state = Global_Print_Level & CS_DURING_ANY;
    glob_level = Global_Print_Level & DBG_DEBUG_MASK;

    if(Print_LEVEL & ALWAYS_PRINT)
    {
        C_vsprintf(buffer, formatString, ap);
        DebugPrint((1, buffer));

    }
    else
    {
        if( glob_state & instate )
        {
            if( level > glob_level )
            {
                C_vsprintf(buffer, formatString, ap);
                DebugPrint((1, buffer));

            }
        }
    }
    va_end(ap);
}

#if DBG > 2

void  dump_PCI_regs( PPCI_COMMON_CONFIG pciCommonConfig )
{
    osDEBUGPRINT((DVHIGH,"VendorID       %04x\n", pciCommonConfig->VendorID      ));
    osDEBUGPRINT((DVHIGH,"DeviceID       %04x\n", pciCommonConfig->DeviceID      ));
    osDEBUGPRINT((DVHIGH,"Command        %04x\n", pciCommonConfig->Command       ));
    osDEBUGPRINT((DVHIGH,"Status         %04x\n", pciCommonConfig->Status        ));
    osDEBUGPRINT((DVHIGH,"RevisionID     %02x\n", pciCommonConfig->RevisionID    ));
    osDEBUGPRINT((DVHIGH,"ProgIf         %02x\n", pciCommonConfig->ProgIf        ));
    osDEBUGPRINT((DVHIGH,"SubClass       %02x\n", pciCommonConfig->SubClass      ));
    osDEBUGPRINT((DVHIGH,"BaseClass      %02x\n", pciCommonConfig->BaseClass     ));
    osDEBUGPRINT((DVHIGH,"CacheLineSize  %02x\n", pciCommonConfig->CacheLineSize ));
    osDEBUGPRINT((DVHIGH,"LatencyTimer   %02x\n", pciCommonConfig->LatencyTimer  ));
    osDEBUGPRINT((DVHIGH,"HeaderType     %02x\n", pciCommonConfig->HeaderType    ));
    osDEBUGPRINT((DVHIGH,"BIST           %02x\n", pciCommonConfig->BIST          ));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[0] %08x\n", pciCommonConfig->u.type0.BaseAddresses[0]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[1] %08x\n", pciCommonConfig->u.type0.BaseAddresses[1]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[2] %08x\n", pciCommonConfig->u.type0.BaseAddresses[2]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[3] %08x\n", pciCommonConfig->u.type0.BaseAddresses[3]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[4] %08x\n", pciCommonConfig->u.type0.BaseAddresses[4]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[5] %08x\n", pciCommonConfig->u.type0.BaseAddresses[5]));
 
    osDEBUGPRINT((DVHIGH,"CIS            %08x\n", pciCommonConfig->u.type0.CIS           ));
    osDEBUGPRINT((DVHIGH,"SubVendorID    %04x\n", pciCommonConfig->u.type0.SubVendorID   ));
    osDEBUGPRINT((DVHIGH,"SubSystemID    %04x\n", pciCommonConfig->u.type0.SubSystemID   ));
    osDEBUGPRINT((DVHIGH,"ROMBaseAddress %08x\n", pciCommonConfig->u.type0.ROMBaseAddress));

#if defined(HP_NT50)
    osDEBUGPRINT((DVHIGH,"Reserved1[0]   %08x\n", pciCommonConfig->u.type0.Reserved1[0]  ));
    osDEBUGPRINT((DVHIGH,"Reserved1[1]   %08x\n", pciCommonConfig->u.type0.Reserved1[1]  ));
    osDEBUGPRINT((DVHIGH,"Reserved1[2]   %08x\n", pciCommonConfig->u.type0.Reserved1[2]  ));
    osDEBUGPRINT((DVHIGH,"Reserved2   %08x\n", pciCommonConfig->u.type0.Reserved2 ));
#else
    osDEBUGPRINT((DVHIGH,"Reserved2[0]   %08x\n", pciCommonConfig->u.type0.Reserved2[0]  ));
    osDEBUGPRINT((DVHIGH,"Reserved2[1]   %08x\n", pciCommonConfig->u.type0.Reserved2[1]  ));
#endif

    osDEBUGPRINT((DVHIGH,"InterruptLine  %02x\n", pciCommonConfig->u.type0.InterruptLine ));
    osDEBUGPRINT((DVHIGH,"InterruptPin   %02x\n", pciCommonConfig->u.type0.InterruptPin  ));
    osDEBUGPRINT((DVHIGH,"MinimumGrant   %02x\n", pciCommonConfig->u.type0.MinimumGrant  ));
    osDEBUGPRINT((DVHIGH,"MaximumLatency %02x\n", pciCommonConfig->u.type0.MaximumLatency));
 
}


void dump_pCard( IN PCARD_EXTENSION pCard)
{
    ULONG i;

    osDEBUGPRINT(( DHIGH,"pCard                   %lx\n", pCard                   ));
    osDEBUGPRINT(( DHIGH,"hpRoot.fcData          %lx\n", pCard->hpRoot.fcData    ));
    osDEBUGPRINT(( DHIGH,"hpRoot.osData          %lx\n", pCard->hpRoot.osData    ));
    osDEBUGPRINT(( DHIGH,"IoLBase                %lx\n", pCard->IoLBase           ));
    osDEBUGPRINT(( DHIGH,"IoUpBase               %lx\n", pCard->IoUpBase          ));
    osDEBUGPRINT(( DHIGH,"MemIoBase              %lx\n", pCard->MemIoBase         ));
    osDEBUGPRINT(( DHIGH,"RamBase                %lx\n", pCard->RamBase           ));
    osDEBUGPRINT(( DHIGH,"RomBase                %lx\n", pCard->RomBase           ));
    osDEBUGPRINT(( DHIGH,"RamLength               %x\n", pCard->RamLength        ));
    osDEBUGPRINT(( DHIGH,"RomLength               %x\n", pCard->RomLength        ));
    osDEBUGPRINT(( DHIGH,"State                   %x\n", pCard->State             ));
    osDEBUGPRINT(( DHIGH,"SystemIoBusNumber       %x\n", pCard->SystemIoBusNumber ));
    osDEBUGPRINT(( DHIGH,"SlotNumber              %x\n", pCard->SlotNumber        ));
    osDEBUGPRINT(( DHIGH,"cachedMemoryPtr        %lx\n", pCard->cachedMemoryPtr   ));
    osDEBUGPRINT(( DHIGH,"cachedMemoryNeeded      %x\n", pCard->cachedMemoryNeeded));
    osDEBUGPRINT(( DHIGH,"cachedMemoryAlign       %x\n", pCard->cachedMemoryAlign ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryUpper32        %x\n", pCard->dmaMemoryUpper32  ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryLower32        %x\n", pCard->dmaMemoryLower32  ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryPtr           %lx\n", pCard->dmaMemoryPtr      ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryNeeded         %x\n", pCard->dmaMemoryNeeded   ));
    osDEBUGPRINT(( DHIGH,"nvMemoryNeeded          %x\n", pCard->nvMemoryNeeded    ));
    osDEBUGPRINT(( DHIGH,"usecsPerTick            %x\n", pCard->usecsPerTick      ));
    osDEBUGPRINT(( DHIGH,"IsFirstTime             %x\n", pCard->IsFirstTime       ));
    osDEBUGPRINT(( DHIGH,"ResetType               %x\n", pCard->ResetType         ));
    osDEBUGPRINT(( DHIGH,"Num_Devices             %x\n", pCard->Num_Devices       ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[0]              %lx\n", pCard->hpFCDev[0]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[1]              %lx\n", pCard->hpFCDev[1]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[2]              %lx\n", pCard->hpFCDev[2]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[3]              %lx\n", pCard->hpFCDev[3]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[4]              %lx\n", pCard->hpFCDev[4]        ));
 
}




#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ntioctl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   ntioctl.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/NTIOCTL.H $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:17a $
   $Modtime:: 8/31/00 3:23p            $

Notes:


--*/

#ifndef NTIOCTL_H
#define NTIOCTL_H

//
// IOCtl definitions
//



//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0x0000 - 0x7FFF, and 0x8000 - 0xFFFF are
// reserved for use by customers.
//

#define IOCTL_SCSI_MINIPORT_IO_CONTROL  0x8001

//
// Macro definition for defining IOCTL and FSCTL function control codes.
// Note that function codes 0x000 - 0x7FF are reserved for Microsoft
// Corporation, and 0x800 - 0xFFF are reserved for customers.
//

#define RETURNCODE0x0000003F   0x850

#define SMP_RETURN_3F     CTL_CODE(IOCTL_SCSI_MINIPORT_IO_CONTROL, RETURNCODE0x0000003F, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SMP_PRINT_STRING        0x80000001
#define SMP_DUMP_REGISTERS      0x80000002
#define SMP_DUMP_TRACE          0x80000003
#define SMP_WRITE_REGISTER      0x80000004

PCHAR Signature="MyDrvr";
PCHAR DrvrString="This string was placed in the data area by the SCSI miniport driver\n";

typedef struct {
    SRB_IO_CONTROL sic;
    UCHAR          ucDataBuffer[512];
} SRB_BUFFER, *PSRB_BUFFER;




#endif // NTIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\osapi.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/OsApi.H $

   $Revision: 3 $
   $Date: 9/07/00 11:18a $ (Last Check-In)
   $Modtime:: 8/31/00 3:34p         $ (Last Modified)

Purpose:

  This is the NT-specific OS Layer API Include File.

--*/

#ifndef __NT_OsApi_H__

#define __NT_OsApi_H__

#ifndef __OSSTRUCT_H__

#include "osstruct.h"


#endif

/*
 * Define each OS Layer function
 */

#define osChipConfigWriteBit8(  hpRoot,Offset, Value) osChipConfigWriteBit( hpRoot, Offset, (os_bit32)Value, 8 )
#define osChipConfigWriteBit16( hpRoot,Offset, Value) osChipConfigWriteBit( hpRoot, Offset, (os_bit32)Value, 16 )
#define osChipConfigWriteBit32( hpRoot,Offset, Value) osChipConfigWriteBit( hpRoot, Offset, (os_bit32)Value, 32 )

#if DBG >= 1

#define osDEBUGPRINT(x) osDebugPrintString x

#define osBREAKPOINT \
    osDEBUGPRINT(( 0xF00000FF,"BreakPoint Hit ! %s Line %d\n", __FILE__, __LINE__ ))

osGLOBAL void osSingleThreadedEnter(
                                   agRoot_t *hpRoot
                                 );

osGLOBAL void osSingleThreadedLeave(
                                   agRoot_t *hpRoot
                                 );


#else

#define osSingleThreadedEnter( hpRoot )

#define osSingleThreadedLeave( hpRoot )


#define BREAKPOINT
#define osDEBUGPRINT(x)

#endif // DBG

#ifndef osFakeInterrupt

osGLOBAL void osFakeInterrupt( agRoot_t *hpRoot );

osGLOBAL void * osGetVirtAddress(
    agRoot_t      *hpRoot,
    agIORequest_t *hpIORequest,
    os_bit32 phys_addr );

#endif  /* ~osFakeInterrupt */

osGLOBAL void osCopy(void * destin, void * source, os_bit32 length );
osGLOBAL void osZero(void * destin, os_bit32 length );
osGLOBAL void osCopyAndSwap(void * destin, void * source, os_bit8 length );

os_bit8  SPReadRegisterUchar( void * x);
os_bit16 SPReadRegisterUshort(void * x);
os_bit32 SPReadRegisterUlong( void * x);

void SPWriteRegisterUchar(void * x, os_bit8  y);
void SPWriteRegisterUshort(void * x, os_bit16 y);
void SPWriteRegisterUlong(void * x, os_bit32 y);

os_bit8  SPReadPortUchar( void * x);
os_bit16 SPReadPortUshort(void * x);
os_bit32 SPReadPortUlong( void * x);

void SPWritePortUchar(void * x, os_bit8  y);
void SPWritePortUshort(void * x, os_bit16 y);
void SPWritePortUlong(void * x, os_bit32 y);


#define PVOID void *

#ifndef osDebugPrintString

osGLOBAL void osDebugPrintString(
                            os_bit32 Print_LEVEL,
                            char     *formatString,
                            ...
                            );

#endif  /* ~osDebugPrintString */


#if DBG < 1

#ifdef _DvrArch_1_20_
#define osLogDebugString(a,l,f,s1,s2,p1,p2,i1,i2,i3,i4,i5,i6,i7,i8)
#else    /* _DvrArch_1_20_ was not defined */
#define osLogDebugString(h,c,t,f,s1,s2,i1,i2,i3,i4,i5,i6,i7,i8)
#endif  /* _DvrArch_1_20_ was not defined */

#define osDebugBreakpoint(hpRoot, BreakIfTrue, DisplayIfTrue)
#define osTimeStamp(hpRoot)      ((os_bit32)0)

#endif // DBG < 1

#if DBG > 3
#define pCf  (unsigned char * )(( struct _CARD_EXTENSION * )(hpRoot->osData))

#define osCardRamReadBit8(  hpRoot, Offset ) SPReadRegisterUchar( (unsigned char *  )(((unsigned char  * )pCf->RamBase)+Offset))
#define osCardRamReadBit16( hpRoot, Offset ) SPReadRegisterUshort((unsigned short * )(((unsigned char *  )pCf->RamBase)+Offset))
#define osCardRamReadBit32( hpRoot, Offset ) SPReadRegisterUlong( (unsigned int *   )(((unsigned char  * )pCf->RamBase)+Offset))

#define osCardRamWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar(  (unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),(unsigned char )Value)
#define osCardRamWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort( (unsigned short * )(((unsigned char * )pCf->RamBase)+Offset),(unsigned short)Value)
#define osCardRamWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong(  (unsigned int *   )(((unsigned char * )pCf->RamBase)+Offset),(unsigned int ) Value)

#define osCardRamReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)
#define osCardRamWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)

#define osCardRomReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)
#define osCardRomWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)

#define osCardRomReadBit8(  hpRoot, Offset ) SPReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit16( hpRoot, Offset ) SPReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit32( hpRoot, Offset ) SPReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset))


#define osCardRomWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned char )Value)
#define osCardRomWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned short)Value)
#define osCardRomWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned int ) Value)


#define osChipIOLoReadBit8(  hpRoot, Offset ) SPReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit16( hpRoot, Offset ) SPReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit32( hpRoot, Offset ) SPReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset))

#define osChipIOLoWriteBit8(  hpRoot,Offset, Value) SPWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned char )Value)
#define osChipIOLoWriteBit16( hpRoot,Offset, Value) SPWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned short)Value)
#define osChipIOLoWriteBit32( hpRoot,Offset, Value) SPWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned int ) Value)

#define osChipIOUpReadBit8(  hpRoot, Offset ) SPReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit16( hpRoot, Offset ) SPReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit32( hpRoot, Offset ) SPReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset))

#define osChipIOUpWriteBit8(  hpRoot,Offset,Value) SPWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned char )Value)
#define osChipIOUpWriteBit16( hpRoot,Offset,Value) SPWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned short)Value)
#define osChipIOUpWriteBit32( hpRoot,Offset,Value) SPWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned int ) Value)

#define osCardMemReadBit8(  hpRoot, Offset ) SPReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit16( hpRoot, Offset ) SPReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit32( hpRoot, Offset ) SPReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osCardMemWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osCardMemWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osCardMemWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)

#define osNvMemReadBit8(  hpRoot, nvMemOffset ) ((os_bit8)0)
#define osNvMemReadBit16( hpRoot, nvMemOffset ) ((os_bit16)0)
#define osNvMemReadBit32( hpRoot, nvMemOffset ) ((os_bit32)0)
#define osNvMemReadBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )

#define osNvMemWriteBit8(  hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit16( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit32( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )


#define osChipMemReadBit8(hpRoot, Offset)  SPReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit16(hpRoot, Offset) SPReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit32(hpRoot, Offset) SPReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osChipMemWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osChipMemWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osChipMemWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)
// *****************************************************************************************************************************************************************************
#else // Non DBG case
#define pCf  (unsigned char * )(( struct _CARD_EXTENSION * )(hpRoot->osData))

#define osCardRamReadBit8(  hpRoot, Offset ) ScsiPortReadRegisterUchar( (unsigned char *  )(((unsigned char  * )pCf->RamBase)+Offset))
#define osCardRamReadBit16( hpRoot, Offset ) ScsiPortReadRegisterUshort((unsigned short * )(((unsigned char *  )pCf->RamBase)+Offset))
#define osCardRamReadBit32( hpRoot, Offset ) ScsiPortReadRegisterUlong( (unsigned int *   )(((unsigned char  * )pCf->RamBase)+Offset))

#define osCardRamWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar(  (unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),(unsigned char )Value)
#define osCardRamWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort( (unsigned short * )(((unsigned char * )pCf->RamBase)+Offset),(unsigned short)Value)
#define osCardRamWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong(  (unsigned int *   )(((unsigned char * )pCf->RamBase)+Offset),(unsigned int ) Value)

#define osCardRamReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)
#define osCardRamWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)

#define osCardRomReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)
#define osCardRomWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)

#define osCardRomReadBit8(  hpRoot, Offset ) ScsiPortReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit16( hpRoot, Offset ) ScsiPortReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit32( hpRoot, Offset ) ScsiPortReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset))


#define osCardRomWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned char )Value)
#define osCardRomWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned short)Value)
#define osCardRomWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned int ) Value)


#define osChipIOLoReadBit8(  hpRoot, Offset ) ScsiPortReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit16( hpRoot, Offset ) ScsiPortReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit32( hpRoot, Offset ) ScsiPortReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset))

#define osChipIOLoWriteBit8(  hpRoot,Offset, Value) ScsiPortWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned char )Value)
#define osChipIOLoWriteBit16( hpRoot,Offset, Value) ScsiPortWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned short)Value)
#define osChipIOLoWriteBit32( hpRoot,Offset, Value) ScsiPortWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned int ) Value)

#define osChipIOUpReadBit8(  hpRoot, Offset ) ScsiPortReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit16( hpRoot, Offset ) ScsiPortReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit32( hpRoot, Offset ) ScsiPortReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset))

#define osChipIOUpWriteBit8(  hpRoot,Offset,Value) ScsiPortWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned char )Value)
#define osChipIOUpWriteBit16( hpRoot,Offset,Value) ScsiPortWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned short)Value)
#define osChipIOUpWriteBit32( hpRoot,Offset,Value) ScsiPortWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned int ) Value)

#define osCardMemReadBit8(  hpRoot, Offset ) ScsiPortReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit16( hpRoot, Offset ) ScsiPortReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit32( hpRoot, Offset ) ScsiPortReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osCardMemWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osCardMemWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osCardMemWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)

#define osNvMemReadBit8(  hpRoot, nvMemOffset ) ((os_bit8)0)
#define osNvMemReadBit16( hpRoot, nvMemOffset ) ((os_bit16)0)
#define osNvMemReadBit32( hpRoot, nvMemOffset ) ((os_bit32)0)
#define osNvMemReadBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )

#define osNvMemWriteBit8(  hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit16( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit32( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )

#define osChipMemReadBit8(hpRoot, Offset)  ScsiPortReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit16(hpRoot, Offset) ScsiPortReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit32(hpRoot, Offset) ScsiPortReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osChipMemWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osChipMemWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osChipMemWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)



#endif // DBG

#ifdef ScsiPortMoveMemory
#undef ScsiPortMoveMemory
void    ScsiPortMoveMemory( void * WriteBuffer,void * ReadBuffer,os_bit32 Length );
#endif


#ifndef _NTSRB_

os_bit8    ScsiPortReadPortUchar( os_bit8 * Port );
os_bit16 ScsiPortReadPortUshort( os_bit16 * Port );
os_bit32 ScsiPortReadPortUlong( os_bit32 * Port );
void ScsiPortReadPortBufferUchar( os_bit8 * Port, os_bit8 * Buffer, os_bit32  Count );
void ScsiPortReadPortBufferUshort( os_bit16 * Port, os_bit16 * Buffer, os_bit32 Count );
void ScsiPortReadPortBufferUlong( os_bit32 * Port,os_bit32 * Buffer,os_bit32 Count);
os_bit8 ScsiPortReadRegisterUchar( os_bit8 * Register );
os_bit16 ScsiPortReadRegisterUshort( os_bit16 * Register );
os_bit32 ScsiPortReadRegisterUlong( os_bit32 * Register );
void ScsiPortReadRegisterBufferUshort( os_bit16 * Register,os_bit16 * Buffer, os_bit32 Count );
void ScsiPortReadRegisterBufferUlong( os_bit32 * Register, os_bit32 * Buffer, os_bit32 Count );
void ScsiPortStallExecution( os_bit32 Delay );
void ScsiPortWritePortUchar( os_bit8 * Port, os_bit8 Value );
void ScsiPortWritePortUshort( os_bit16 * Port, os_bit16 Value );
void ScsiPortWritePortUlong(  os_bit32 * Port, os_bit32 Value );
void ScsiPortWritePortBufferUchar( os_bit8 * Port, os_bit8 * Buffer, os_bit32  Count );
void ScsiPortWritePortBufferUshort( os_bit16 * Port, os_bit16 * Buffer, os_bit32 Count );
void ScsiPortWritePortBufferUlong( os_bit32 * Port, os_bit32 * Buffer, os_bit32 Count );
void ScsiPortWriteRegisterUchar( os_bit8 * Register,os_bit8 Value );
void ScsiPortWriteRegisterUshort( os_bit16 * Register, os_bit16 Value );
void ScsiPortWriteRegisterUlong( os_bit32 * Register, os_bit32 Value );
void ScsiPortWriteRegisterBufferUshort( os_bit16 * Register, os_bit16 * Buffer,  os_bit32 Count );
void ScsiPortWriteRegisterBufferUlong( os_bit32 * Register, os_bit32 * Buffer, os_bit32 Count );

// #ifdef ScsiPortWriteRegisterBufferUchar

// #undef ScsiPortWriteRegisterBufferUchar

void ScsiPortWriteRegisterBufferUchar( os_bit8 * Register, os_bit8 * Buffer, os_bit32  Count );

#endif

// #ifdef  ScsiPortReadRegisterBufferUchar
// #undef  ScsiPortReadRegisterBufferUchar

#ifndef _NTSRB_
void ScsiPortReadRegisterBufferUchar( os_bit8 * Register, os_bit8 * Buffer,os_bit32  Count );
#endif

#endif  /* ~__NT_OsApi_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\osflags.h ===
#ifndef __OSFLAGS_H__
#define __OSFLAGS_H__

#define  DA_8X_Compliant

// #define OSLayer_NT

// #define USE_EXTENDED_SGL

#include <miniport.h>
#include <scsi.h>
#include <devioctl.h>
#include <ntddscsi.h>
#include "cstring.h"
#include "globals.h"

#include "osstruct.h"
#include "hpfcctl.h"

#ifdef _FCCI_SUPPORT
#include "fccint.h"
#include "fcciimpl.h"
#endif

#include "protos.h"

#endif //  __OSFLAGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\osstruct.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   osstruct.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/Osstruct.h $


Revision History:

   $Revision: 6 $
   $Date: 10/30/00 5:02p $
   $Modtime:: 10/30/00 2:31p           $

Notes:


--*/

#ifndef __OSSTRUCT_H__
#define __OSSTRUCT_H__
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    OSSTRUCTS.H

Abstract:

    This is the Driver structures for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/Osstruct.h $

Revision History:

    $Revision: 6 $
        $Date: 10/30/00 5:02p $
     $Modtime:: 10/30/00 2:31p          $

--*/

#include "buildop.h"

#ifdef _DEBUG_EVENTLOG_
#include "eventlog.h"
#endif
#ifdef YAM2_1
#include "mapping.h"
#endif

#define pNULL ((void *)0)

#define NUMBER_ACCESS_RANGES 5

#define Debug_Break_Point _asm int 3

//
// NT documentation note:
// The registry subkey to specify the maximum number of scatter/gather list
// elements for each device on a given bus is
// \Registry\Machine\System\CurrentControlSet\Services\DriverName\
// Parameters\DeviceN\MaximumSGList
// N is the bus number assigned at initialization. If a value is present in this
// subkey at device initialization, the scsi port driver uses MaximumSGList as the
// initial for NumberOfPhysicalBreaks. The miniport driver's HwScsiFindAdapter
// routine can set NumberOfPhysicalBreaks to a lower value, if appropriate.
// The maximum value for MaximumSGList is 255. MaximumSGList is a REG_DWORD.
//
// As per Ed, FC Layer supports a maximum value of 31 * 0x3e0

#define osSGL_NUM_ENTRYS        256     // Maximum value for MaximumSGList (=255) + 1

#if DBG > 1
#define MULTIPLE_IOS_PER_DEVICE         TRUE
#define OS_STAMP_INTERVAL               1220 // 3050  // 610 per second
#else
#define MULTIPLE_IOS_PER_DEVICE         TRUE
#define OS_STAMP_INTERVAL               1831    // 3 seconds
#endif



#define NUMBER_OF_BUSES 8
#define MAXIMUM_TID     32
#define MAXIMUM_LUN     8
#define MAX_IO_PER_DEVICE 64 // For now Was 8

#define MAX_FC_DEVICES 128  // 127 + one unused slot at the end. Rounding to 128 is necessary
                            // to avoid accidently referring to the 128th entry using BUILD_SLOT macro.
#define MAX_ADAPTERS 32

#define OS_STAMP_PER_SECOND             610 //  per second


#define OS_TIMER_CALL_TO_STAMP_RATIO    1637    // Microseconds to stamp increment

#define OS_TIMER_CALL_INTERVAL (OS_TIMER_CALL_TO_STAMP_RATIO * OS_STAMP_INTERVAL)

#define SWAPDWORD(val) (((val)<<24)|(((val)&0xFF00)<<8)|(((val)&0xFF0000)>>8)|((val)>>24))

#define osFCP_RSP_LEN_VALID   0x1 // For FCP_RSP status byte
#define osFCP_SNS_LEN_VALID   0x2
#define osFCP_RESID_OVER      0x4
#define osFCP_RESID_UNDER     0x8

#define osFCP_STATUS_VALID_FLAGS     0x2
#define osFCP_STATUS_SCSI_STATUS     0x3

#define FCP_RSP_CODE_OK             0x0
#define FCP_RSP_CODE_BURST          0x1
#define FCP_RSP_CODE_CMD_INVALID    0x2
#define FCP_RSP_CODE_RO_MISMATCH    0x3
#define FCP_RSP_CODE_TM_NOT_SUPPORT 0x4
#define FCP_RSP_CODE_TM_FAILED      0x5


#if DBG
#define HP_FC_TRACE_BUFFER_LEN  8192
#define Bad_Things_Happening _asm int 3
#else
#define Bad_Things_Happening _asm nop
#endif



// Macro used to convert bus(0-3),tid(0-31) to a 0-127 tid value
// #define GET_TID(bus,tid) ((bus * MAXIMUM_TID) + tid)

// number of times we'll retry logi commands on busy or unable to perform command
// #define MAX_LOGI_RETRIES 3

#define ERR_MAP_RAMBASE 0xC0001000

#define MIN(x,y)  (((x) < (y)) ? (x) : (y))
#define MAX(x,y)  (((x) > (y)) ? (x) : (y))

#define PCI_SOFTRST             0x00000001

#define SOFT_RESET  CORE_RESET
#define HARD_RESET  PCI_SOFTRST
#define NO_RESET    0x00000000

#define BUILD_SLOT( PathId , TargetId )  ((( (PathId >= 4  ? (PathId - 4) : PathId  ) << 5)) | TargetId)

#define IS_VALID_PTR( p ) (((void *)p) ? (TRUE) : (FALSE))

#define offsetofS(s,m)   (size_t)&(((s *)0)->m)

typedef union LongChar_u LongChar_t;

union LongChar_u{
    UCHAR   bytes[4];
    USHORT  shorts[2];
    ULONG   ul;
    };

typedef struct _OSL_QUEUE {
    void    *Head;
    void    *Tail;
} OSL_QUEUE;


#define PERIPHERAL_ADDRESS  0
#define VOLUME_SET_ADDRESS  1
#define LUN_ADDRESS         2

typedef struct _LUN_LU{   // Logical Unit Addressing SCSI Mux
    UCHAR Target        : 6;
    UCHAR Address_mode  : 2;
    UCHAR Lun           : 5;
    UCHAR Bus_number    : 3;
    } LUN_LU, *pLUN_LU;

typedef struct _LUN_PD{  // Peripheral device Addressing Disk drives
    UCHAR Bus_number    : 6;
    UCHAR Address_mode  : 2;
    UCHAR Lun           : 8;
    } LUN_PD, *pLUN_PD;

typedef struct _LUN_VS{  // Volume Set Addressing Disk Arrays
    UCHAR Lun_hi         :  6;
    UCHAR  Address_mode  :  2;
    UCHAR Lun            :  8;
    } LUN_VS, *pLUN_VS;

typedef union _LUN{
    LUN_PD lun_pd[4];
    LUN_VS lun_vs[4];
    LUN_LU lun_lu[4];
    }LUN,* PLUN;

// Card State
#define  CS_DRIVER_ENTRY            0x00000100 // Initial Driver load superset
#define  CS_FCLAYER_LOST_IO         0x00001000 // IO Lost
#define  CS_DURING_DRV_ENTRY        0x00000001 // of DRV_ENTRY FIND and START
#define  CS_DURING_FINDADAPTER      0x00000002 // Anything during scsiportinit
#define  CS_DURING_DRV_INIT         0x00000004
#define  CS_DURING_RESET_ADAPTER    0x00000008
#define  CS_DURING_STARTIO          0x00000010
#define  CS_DURING_ISR              0x00000020
#define  CS_DURING_OSCOMPLETE       0x00000040
#define  CS_HANDLES_GOOD            0x00000080
#define  CS_DURING_ANY              0x000001FF
#define  CS_DUR_ANY_ALL             0xF00001FF
#define  CS_DUR_ANY_MOD             0x200001FF
#define  CS_DUR_ANY_LOW             0x400001FF

#define  ALWAYS_PRINT               0x01000000  // If statement executes always
#define  DBG_VERY_DETAILED          0x10000000  // All debug statements
#define  DBG_MODERATE_DETAIL        0x20000000  // Most debug statements
#define  DBG_LOW_DETAIL             0x40000000  // Entry and exit
#define  DBG_JUST_ERRORS            0x80000000  // Errors
#define  DBG_DEBUG_MASK             0xF0000000  // Mask debug bits
#define  DBG_DEBUG_OFF              0xF0000000  // NO debug statements
#define  DBG_DEBUG_FULL             0x000001FF  // ALL debug statements and CS
#define  DBG_DEBUG_ALL              0x00000000  // ALL debug statements

//#define DBGSTATE  ((pCard) ? (pCard->State)  : osBREAKPOINT)
#define DBGSTATE  (pCard->State)


#define DENTHIGH    ( CS_DURING_DRV_ENTRY   | DBG_VERY_DETAILED )
#define DENTMOD     ( CS_DURING_DRV_ENTRY   | DBG_MODERATE_DETAIL )
#define DENT        ( CS_DURING_DRV_ENTRY   | DBG_LOW_DETAIL )
#define DVHIGH      ( CS_DURING_ANY         | DBG_VERY_DETAILED )
#define DERROR ( DBG_DEBUG_FULL )
#define DHIGH ( DBGSTATE | DBG_VERY_DETAILED   )
#define DMOD  ( DBGSTATE | DBG_MODERATE_DETAIL )
#define DLOW  ( DBGSTATE | DBG_LOW_DETAIL      )
#define DERR  ( DBGSTATE | DBG_JUST_ERRORS     )

//#define  ALWAYS_PRINT               DBG_DEBUG_OFF

// Request State
#define  RS_STARTIO                 0x00000001
#define  RS_WAITING                 0x00000002
#define  RS_ISR                     0x00000004
#define  RS_COMPLETE                0x00000008
#define  RS_NODEVICE                0x00000010
#define  RS_TIMEOUT                 0x00000020
#define  RS_RESET                   0x00000040
#define  RS_TO_BE_ABORTED           0x00000080

typedef struct _PERFORMANCE    PERFORMANCE;
typedef struct _PERFORMANCE * pPERFORMANCE;

struct _PERFORMANCE {
                    ULONG inOsStartio;
                    ULONG inFcStartio;
                    ULONG outFcStartio;
                    ULONG outOsStartio;
                    ULONG inOsIsr;
                    // ULONG inFcIsr;
                    // ULONG outFcIsr;
                    ULONG inFcDIsr;
                    ULONG inOsIOC;
                    ULONG outOsIOC;
                    // ULONG outFcDIsr;
                    ULONG outOsIsr;
                    };




typedef struct _LU_EXTENSION{   // Logical Unit Extension per Device Storage
    UCHAR       flags;
    UCHAR       deviceType;
    USHORT      OutstandingIOs;
    USHORT      MaxOutstandingIOs;
    USHORT      MaxAllowedIOs;
    LUN Lun;
    agFCDev_t * phandle;
    #ifndef YAM2_1
    #ifdef _DEBUG_EVENTLOG_
    UCHAR           InquiryData[40];
    agFCDevInfo_t   devinfo;
    UCHAR           WWN[8];
    #endif
    #else
    USHORT      PaDeviceIndex;  
        #define PA_DEVICE_ALREADY_LOGGED    0x0001
    USHORT      LogFlags;
    ULONG       Mode;
//  ULONG       CurrentMode;
//  LUN         PaLun;
//  LUN         VsLun;
//  LUN         LuLun;
    #endif  
      }LU_EXTENSION, *PLU_EXTENSION;

// Defines for LU_EXTENSION flags

#define LU_EXT_INITIALIZED      1

typedef struct _CARD_EXTENSION    CARD_EXTENSION;
typedef struct _CARD_EXTENSION * PCARD_EXTENSION;
typedef struct _SRB_EXTENSION      SRB_EXTENSION;
typedef struct _SRB_EXTENSION    *PSRB_EXTENSION;

struct _SRB_EXTENSION{   // SRB Extension per Request Storage
    PSRB_EXTENSION pNextSrbExt;
    agRoot_t * phpRoot;
    pPERFORMANCE Perf_ptr;
    PCARD_EXTENSION pCard;
    void * AbortSrb;   // PSCSI_REQUEST_BLOCK
                       // Save srb for abort when interrupt handler is called
    void * pSrb;       // Original srb
    void *  pNextSrb;   // Next srb
    PUCHAR SglVirtAddr;
    ULONG SglDataLen;
    ULONG SglElements;
    ULONG SRB_State;
    ULONG SRB_StartTime;
    ULONG SRB_TimeOutTime;
    ULONG SRB_IO_COUNT;
    PLU_EXTENSION pLunExt;
#ifdef DOUBLE_BUFFER_CRASHDUMP
    void * orgDataBuffer; // used to store the original Srb->DataBuffer, during dump
#endif
    agIORequest_t hpIORequest;
    agIORequestBody_t hpRequestBody;
    };

// Device type definitions */

#define DEV_NONE                0
#define DEV_MUX                 1
//
// The artiste Formerly known as DEV_EMC
//
#define DEV_VOLUMESET                 2
#define DEV_COMPAQ              3

#define MAX_SPECIAL_DEVICES     2

typedef struct _SPECIAL_DEV {
    USHORT  devType;            /* type of device DEV_MUX / DEV_VOLUMESET / DEV_COMPAQ / DEV_NONE */
    USHORT  addrMode;           /* Addressing mode used with the device */
    ULONG   devHandleIndex;     /* index into device handle array */
} SPECIAL_DEV;

#define LOGGED_IO_MAX 100
#define HP_FC_RESPONSE_BUFFER_LEN 128

typedef struct _NODE_INFO {
    ULONG       DeviceType;
} NODE_INFO;

#define PCI_CONFIG_DATA_SIZE            256
#define NUM_PCI_CONFIG_DATA_ELEMENTS    (PCI_CONFIG_DATA_SIZE/sizeof(ULONG))

#if defined(HP_PCI_HOT_PLUG)

    #define MAX_CONTROLLERS             12
    #define HPP_VERSION                 SUPPORT_VERSION_10
    #define HBA_DESCRIPTION             "Agilent Technologies Fibre Channel HBA"    //Max length 255 characters
    //Controller States for Hot Plug Operation
    #define IOS_HPP_HBA_EXPANDING       0x00001070
    #define IOS_HPP_HBA_CACHE_IN_USE    0x00001075
    #define IOS_HPP_BAD_REQUEST         0x000010ff

    // The following 2 macros are used to temporarily block and then release
    // our startio routine by setting/clearing the state hot plug flags.

    #define HOLD_IO(pCard) (pCard->stateFlags |= PCS_HBA_OFFLINE)
    #define FREE_IO(pCard) (pCard->stateFlags &= ~PCS_HBA_OFFLINE)

    // Callback prototype for hot plug service async messaging.

    typedef ULONG (*PCALLBACK) ( void *pEvent );

    typedef struct _RCMC_DATA {
        ULONG   driverId;
        PCALLBACK   healthCallback;
        ULONG   controllerChassis;
        UCHAR   slot;                           
        UCHAR   numAccessRanges;
        ULONG   accessRangeLength[NUMBER_ACCESS_RANGES];
    }RCMC_DATA, *PRCMC_DATA;

    typedef struct _PSUEDO_DEVICE_EXTENSION {
        ULONG   extensions[MAX_CONTROLLERS];
        ULONG   driverId;
        ULONG   hotplugVersion;
    } PSUEDO_DEVICE_EXTENSION, *PPSUEDO_DEVICE_EXTENSION;

#endif


/* 
 * Events used for SNIA.
 */
#ifdef _SAN_IOCTL_

#define SAN_EVENT_LIP_OCCURRED          1
#define SAN_EVENT_LINK_UP               2
#define SAN_EVENT_LINK_DOWN             3
#define SAN_EVENT_LIP_RESET_OCCURRED    4
#define SAN_EVENT_RSCN                  5
#define SAN_EVENT_PROPRIETARY           0xFFFF

typedef struct SAN_Link_EventInfo {
    ULONG       PortFcId;               /* Port which this event occurred */
    ULONG       Reserved[3];
} SAN_LINK_EVENTINFO, *PSAN_LINK_EVENTINFO;

typedef struct SAN_RSCN_EventInfo {
    ULONG       PortFcId;               /* Port which this event occurred */
    ULONG       NPortPage;              /* Reference FC-FS for  RSCN ELS "Affected N-Port Pages"*/
    ULONG       Reserved[2];
} SAN_RSCN_EVENTINFO, *PSAN_RSCN_EVENTINFO;

typedef struct SAN_Pty_EventInfo {
    ULONG       PtyData[4];  /* Proprietary data */
} SAN_PTY_EVENTINFO, *PSAN_PTY_EVENTINFO;

typedef struct SAN_EventInfo {
    ULONG       EventCode;
    union {
        SAN_LINK_EVENTINFO Link_EventInfo;
        SAN_RSCN_EVENTINFO RSCN_EventInfo;
        SAN_PTY_EVENTINFO Pty_EventInfo;
        } Event;
} SAN_EVENTINFO, *PSAN_EVENTINFO;

#endif

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)
typedef struct _S_STALL_DATA
{
    ULONG   MicroSec;
    ULONG   Address;
}   S_STALL_DATA;

#endif

struct _CARD_EXTENSION{  // Card Pointer per Adapter Storage
    ULONG signature;                    // unique signature for debugging purposes
    PSRB_EXTENSION RootSrbExt;
    
    #ifdef _DEBUG_PERF_DATA_
    PERFORMANCE perf_data[ LOGGED_IO_MAX ];
    ULONG PerfStartTimed;
    ULONG TimedOutIO;
    #endif
    
#ifdef _DEBUG_LOSE_IOS_
    ULONG Srb_IO_Count;
    ULONG Last_Srb_IO_Count;
#endif
    agRoot_t hpRoot;
    void * IoLBase;              // Io Address Lower Reg 0
    void * IoUpBase;             // Io Address Upper Reg 0
    void * MemIoBase;            // Memory mapped Io Address Reg 0
    void * RamBase;              // On card Ram Address 0
    void * RomBase;              // On card Flash Address 0
    void * AltRomBase;           // Alternate Rom at config space 0x30
    ULONG RamLength;             // Ram Length
    ULONG RomLength;             // Rom Length
    ULONG AltRomLength;          // Alternate Rom Length
    USHORT State;                 // Current Adapter State
    USHORT flags;
    USHORT LinkState;             // Current link state.
    USHORT LostDevTickCount;      // # of ticks to wait after link up to see lost devices
    ULONG SystemIoBusNumber;     // Needed by PCI config
    ULONG SlotNumber;            // Needed by PCI config

    PULONG cachedMemoryPtr;
    ULONG cachedMemoryNeeded;
    ULONG cachedMemoryAlign;
    ULONG dmaMemoryUpper32;
    ULONG dmaMemoryLower32;
    PULONG dmaMemoryPtr;
    ULONG dmaMemoryNeeded;
    ULONG nvMemoryNeeded;
    ULONG cardRamUpper;
    ULONG cardRamLower;
    ULONG cardRomUpper;
    ULONG cardRomLower;
    ULONG usecsPerTick;

    OSL_QUEUE   AdapterQ;
    OSL_QUEUE   RetryQ;
    ULONG IsFirstTime;                      //
    ULONG SingleThreadCount;                //
    ULONG ResetType;                        //
    ULONG External_ResetCount;              //
    ULONG Internal_ResetCount;              //
    ULONG LIPCount;
    ULONG Num_Devices;                      //
    ULONG OldNumDevices;
    ULONG ResetPathId;
    ULONG ForceTag;
	
//--LP101000    agFCDev_t hpFCDev[MAX_FC_DEVICES];
//--LP101000	NODE_INFO nodeInfo[MAX_FC_DEVICES];
    agFCDev_t	*hpFCDev;
	NODE_INFO	*nodeInfo;
    ULONG  cardHandleIndex;      // index into the devHandle array for card itself
    ULONG Number_interrupts;
    ULONG TicksSinceLinkDown;
#ifndef YAM2_1
    SPECIAL_DEV specialDev[MAX_SPECIAL_DEVICES];
#endif  

    // Move these to the bottom to avoid alignment issue in IA-64, BOOLEAN is defined as BYTE.
    //    volatile BOOLEAN inDriver;
    //    volatile BOOLEAN inTimer;

    //
    // For IA-64 , the Response_Buffer has to be 32 bit alligned.
    //
    UCHAR Response_Buffer[HP_FC_RESPONSE_BUFFER_LEN];
    ULONG pciConfigData[NUM_PCI_CONFIG_DATA_ELEMENTS];
    //
    // KC
    //
    char * ArgumentString;
#if DBG_TRACE
    ULONG traceBufferLen;
    char  *curTraceBufferPtr;
    char  traceBuffer[HP_FC_TRACE_BUFFER_LEN];
#endif

#if defined(HP_PCI_HOT_PLUG)
    ULONG   stateFlags;
    ULONG   controlFlags;
    ULONG   IoHeldRetMaxIter;   // Max countdown before returning SRB_STATUS_ERROR in StartIo
    ULONG   IoHeldRetTimer;     // Countdown for returning SRB_STATUS_BUSY in StartIo
    RCMC_DATA   rcmcData;       // PCI Hot Plug related structure
    PPSUEDO_DEVICE_EXTENSION    pPsuedoExt;
#endif

    ULONG   PrevLinkState;

#ifdef _DEBUG_EVENTLOG_
    ULONG   LogActive;

//  struct  _EVENTLOG_STRUCT    EventLog;
    struct  _EVENTLOG_BUFFER        *Events;
    ULONG   EventLogBufferIndex;

    #ifndef YAM2_1
    agFCDev_t Old_hpFCDev[MAX_FC_DEVICES];
    #endif
#endif
    ULONG   CDResetCount;
#ifdef __REGISTERFORSHUTDOWN__
    ULONG   AlreadyShutdown;
#endif
    ULONG SrbStatusFlag;
#ifdef DOUBLE_BUFFER_CRASHDUMP
    void *localDataBuffer;  // pointer to the local DMA area, used during dump
#endif
// Move these from the top to the bottom to avoid alignment issue in IA-64, BOOLEAN is defined as BYTE.
    volatile BOOLEAN inDriver;
    volatile BOOLEAN inTimer;

#ifdef _SAN_IOCTL_
    #define             MAX_FC_EVENTS   64
    ULONG               SanEvent_GetIndex;
    ULONG               SanEvent_PutIndex;
    LONG                SanEvent_UngetCount;
    ULONG               SanEvent_Reserved;
    SAN_EVENTINFO       SanEvents[MAX_FC_EVENTS];
#endif

#ifdef YAM2_1
    PULONG	UncachedMemoryPtr;
	UCHAR   Reserved1;
    UCHAR   Reserved2;
    struct _DEVICE_ARRAY    *Dev;
#endif  

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)
    #define             STALL_COUNT_MAX     20
    ULONG               StallCount;
    S_STALL_DATA        StallData[STALL_COUNT_MAX];
#endif
    };

#define MAX_OS_ADJUST_BIT32_PARAMS           64
#define MAX_OS_ADJUST_BUFFER_PARAMS          16
#define MAX_OS_ADJUST_PARAM_NAME_LEN         64
#define MAX_OS_ADJUST_PARAM_BUFFER_VALUE_LEN 64

struct _OS_ADJUST_PARAM_CACHE {
    int     numBit32Elements;
    int     numBufferElements;
    BOOLEAN safeToAccessRegistry;
    struct {
        char  paramName[MAX_OS_ADJUST_PARAM_NAME_LEN];
        ULONG value;
    } bit32Element[MAX_OS_ADJUST_BIT32_PARAMS];
    struct {
        char  paramName[MAX_OS_ADJUST_PARAM_NAME_LEN];
        char  value[MAX_OS_ADJUST_PARAM_BUFFER_VALUE_LEN];
    } bufferElement[MAX_OS_ADJUST_BUFFER_PARAMS];
};

typedef struct _OS_ADJUST_PARAM_CACHE OS_ADJUST_PARAM_CACHE;

//
// Remove the use of static global, NT50 PnP support
//

/*
extern PCARD_EXTENSION  hpTLCards [MAX_ADAPTERS];
extern int hpTLNumCards;
*/

// LinkState defintions.

#define LS_LINK_UP      0
#define LS_LINK_DOWN    1
#define LS_LINK_DEAD    2


// Flags

#define OS_DO_SOFT_RESET        1
#define OS_IGNORE_NEXT_RESET    2

#define TICKS_FOR_LINK_DEAD     60
#define INITIATOR_BUS_ID        254

#define LOST_DEV_TICK_COUNT     15

#endif //  __OSSTRUCT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\pktstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/PktState.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 8/14/00 6:50p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/PktState.C

--*/

#ifndef __PktState_H__
#define __PktState_H__

#define PktStateConfused                 0
#define PktStateFree                     1
#define PktStateAllocSFThread            2
#define PktStateDoFarp                   3
#define PktStateLogin                    4
#define PktStateReady                    5
#define PktStateDoIPData                 6

#define PktStateMAXState                 PktStateDoIPData

#define PktEventConfused                 0
#define PktEventGotSFThread              1
#define PktEventFarpSuccess              2
#define PktEventLoginSuccess             3
#define PktEventDoIPData                 4

#define PktEventMAXEvent                 PktEventDoIPData

STATE_PROTO(PktActionConfused);
STATE_PROTO(PktActionFree);
STATE_PROTO(PktActionAllocSFThread);
STATE_PROTO(PktActionDoFarp);
STATE_PROTO(PktActionLogin);
STATE_PROTO(PktActionReady);
STATE_PROTO(PktActionDoIPData);

stateTransitionMatrix_t PktStateTransitionMatrix;
stateActionScalar_t PktStateActionScalar;
#ifdef _DvrArch_1_30_
void PktFuncIRB_OffCardInit(PktThread_t  * PktThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit);
#endif /* _DvrArch_1_30_ was defined */

#endif /*  __PktState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\pktstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/PktState.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 9/19/00 12:05p  $

Purpose:

  This file implements the FC Layer State Machine for each IP Packet Thread.
  Each thread is responsible for managing a single IP Packet Send.

--*/
#ifdef _DvrArch_1_30_

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/fcstruct.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"

#include "../h/ipstate.h"
#include "../h/pktstate.h"
#include "../h/sfstate.h"
#include "../h/queue.h"
#include "../h/timersvc.h"
#include "../h/ip.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "fcstruct.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"

#include "cstate.h"
#include "cfunc.h"

#include "ipstate.h"
#include "pktstate.h"
#include "sfstate.h"
#include "queue.h"
#include "timersvc.h"
#include "ip.h"
#endif  /* _New_Header_file_Layout_ */

stateTransitionMatrix_t PktStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...              */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 PktEventGotSFThread                                  */
    0,0,PktStateDoFarp,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 PktEventFarpSuccess                                  */
    0,0,0,PktStateLogin,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 3 PktEventLoginSuccess                                 */
    0,0,0,0,PktStateReady, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 4 PktEventDoIPData                                    */
    0,PktStateAllocSFThread,0,0,0, PktStateDoIPData,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 5                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 10                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 20                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 30                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    };

stateTransitionMatrix_t copiedPktStateTransitionMatrix;

stateActionScalar_t PktStateActionScalar = {
    &PktActionConfused,
    &PktActionFree,
    &PktActionAllocSFThread,
    &PktActionDoFarp,
    &PktActionLogin,
    &PktActionReady,
    &PktActionDoIPData,
    &PktActionConfused
    };

stateActionScalar_t copiedPktStateActionScalar;

#ifdef USESTATEMACROS

PktSTATE_FUNCTION_TERMINATE(PktActionConfused);

#endif /* USESTATEMACROS */

#define testPktCompareBase 0x00000110


/* PktStateConfused 0  */
extern void PktActionConfused( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "PktActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    PktStateLogErrorLevel,
                    "In %s - State = %d",
                    "PktActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

extern void PktActionFree( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiLogDebugString(thread->hpRoot,
                    PktStateLogErrorLevel,
                    "In %s - State = %d",
                    "PktActionFree",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

extern void PktActionAllocSFThread( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    PktThread_t     * pPktThread = ( PktThread_t  * )thread;
    SFThread_t      * pSFThread  = pPktThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    pPktThread->SFThread_Request.eventRecord_to_send.event = PktEventGotSFThread;
    pPktThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiLogDebugString(thread->hpRoot,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d SF Request State %x",
                    "PktActionAllocSFThread",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pPktThread->SFThread_Request.State,
                    0,0,0,0,0,0);

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList( &(pSFThread->SFLink),
                                  &(CThread_ptr(thread->hpRoot)->Free_SFLink) ) )
	{
            SFThreadFree( thread->hpRoot, &pPktThread->SFThread_Request );
        }
    }

    if( pPktThread->SFThread_Request.State )
    {
            fiLogDebugString(thread->hpRoot,
                        PktStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X  FDCnt %x SFThread req state  %08X Wrong !",
                        "PktActionAllocSFThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pPktThread->Device->DevInfo.CurrentAddress.AL_PA,
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        pPktThread->SFThread_Request.State,
                        0,0,0,0);
    }
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pPktThread->SFThread_Request );
}

/* PktStateDoFarp                       3    */
extern void PktActionDoFarp( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    PktThread_t  * pPktThread = ( PktThread_t  * )thread;
    SFThread_t   * pSFThread  = pPktThread->SFThread_Request.SFThread;

    pSFThread->parent.IPPkt = pPktThread;

    fiLogDebugString(thread->hpRoot,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "PktActionDoFarp",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pPktThread->Device->DevInfo.CurrentAddress.AL_PA,
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    /* Send event to SFthread */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFarpRequest);
}

/* PktStateLogin                       3    */
extern void PktActionLogin( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    /* currently not implemented */
    fiLogDebugString(thread->hpRoot,
                    PktStateLogErrorLevel,
                    "In %s - State = %d",
                    "PktActionLogin",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

extern void PktActionReady( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiSetEventRecord(eventRecord,thread,PktEventDoIPData);
}

extern void PktActionDoIPData( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    PktThread_t *   pPktThread  = (PktThread_t * )thread;
    DevThread_t *   pDevThread  = pPktThread->Device;
    os_bit32 SFS_Len            = 0;

    fiLogDebugString(hpRoot ,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d DCnt %x",
                    "PktActionDoIPData",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pDevThread->pollingCount,0,0,0,0,0,0);

    /* pCThread->PktpollingCount++; */
    pDevThread->pollingCount++;

    pPktThread->status = FC_CMND_STATUS_TIMEDOUT;

    if( CFuncAll_clear( hpRoot ) )
    {
        WaitForERQ( hpRoot );

        SFS_Len = fiFillInIPData( pPktThread );

        pCThread->FuncPtrs.Pkt_IRB_Init(pPktThread, SFS_Len, fiComputeDevThread_D_ID(pDevThread), 0);

        pPktThread->Timer_Request.eventRecord_to_send.thread = (fi_thread__t *) pCThread->IP;
        pPktThread->Timer_Request.eventRecord_to_send.event = IPEventOutgoingComplete;

        fiTimerSetDeadlineFromNow( hpRoot, &pPktThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot, &pPktThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncIPCmnd);

        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiLogDebugString(hpRoot,
                   PktStateLogErrorLevel,
                   "IPData CFunc_Queues_Frozen  Wrong LD %x IR %x",
                   (char *)agNULL,(char *)agNULL,
                   (void *)agNULL,(void *)agNULL,
                   pCThread->LOOP_DOWN,
                   pCThread->IDLE_RECEIVED,
                   0,0, 0,0,0,0);

        fiSetEventRecord(eventRecord,(fi_thread__t *)pCThread->IP,IPEventOutgoingComplete);
    }
}

void PktFuncIRB_OffCardInit(PktThread_t  * PktThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit)
{
#ifndef __MemMap_Force_On_Card__

    CThread_t                  *CThread = CThread_ptr(PktThread->thread_hdr.hpRoot);
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    IRB_t                      *pIrb;

    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    pIrb += CThread->HostCopy_ERQProdIndex;

    pIrb->Req_A.Bits__SFS_Len   = SFS_Len | IRB_SFA | DCM_Bit |
            ((D_ID & 0xff) == 0xff ? IRB_BRD : 0);
    pIrb->Req_A.SFS_Addr        = PktThread->Pkt_CMND_Lower32;
    pIrb->Req_A.D_ID            = D_ID << IRB_D_ID_SHIFT;
    pIrb->Req_A.MBZ__SEST_Index__Trans_ID = PktThread->Device->IP_X_ID;
    pIrb->Req_B.Bits__SFS_Len = 0;

#endif /* __MemMap_Force_On_Card__ was not defined */
}

#endif /* _DvrArch_1_30_ was defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\protos.h ===
/*
Copyright (c) 2000 Agilent Technologies

    Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/H/PROTOS.H $

Revision History:

    $Revision: 9 $
    $Date: 12/07/00 1:38p $
    $Modtime:: 12/05/00 5:32p    $

*/

#ifndef __PROTOS_H__
#define __PROTOS_H__

#ifndef  GetDriverParameter
ULONG 
GetDriverParameter(
    IN PCHAR Parameter,
    IN ULONG Default,
    IN ULONG Min,
    IN ULONG Max,
    IN PCHAR ArgumentString
    );
#endif



ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    );

ULONG
HPFibreEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    );

ULONG
HPFibreFindAdapter(
    IN PCARD_EXTENSION pCard,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

BOOLEAN
HPFibreInitialize(
    IN PCARD_EXTENSION pCard
    );

BOOLEAN
HPFibreStartIo(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
HPFibreInterrupt(
    IN PCARD_EXTENSION pCard
    );

BOOLEAN
HPFibreResetBus(
    IN PCARD_EXTENSION HwDeviceExtension,
    ULONG  notused
    );

#if defined(HP_NT50)
SCSI_ADAPTER_CONTROL_STATUS
HPAdapterControl(
    IN PCARD_EXTENSION pCard,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );
#endif

void
ResetTimer (PCARD_EXTENSION pCard);
void
doLinkDownProcessing (PCARD_EXTENSION pCard);
void
ClearDevHandleArray (PCARD_EXTENSION pCard);
void
doPostResetProcessing (PCARD_EXTENSION pCard);

void
completeRequests (
    IN PCARD_EXTENSION pCard,
    UCHAR PId,
    UCHAR TId,
    UCHAR compStatus);

void
CompleteQueuedRequests (PCARD_EXTENSION pCard, agFCDev_t devHandle, UCHAR compStatus);
void
FixDevHandlesForLinkDown (PCARD_EXTENSION pCard);
void
FixDevHandlesForLinkUp (PCARD_EXTENSION pCard);
void
CompleteQueue (PCARD_EXTENSION pCard, 
               OSL_QUEUE *queue, 
               int param, 
               agFCDev_t devHandle, 
               UCHAR compStatus);

void
RegisterIfSpecialDev (PCARD_EXTENSION pCard, ULONG pathId, ULONG targetId, char *inquiryData);

BOOLEAN Map_FC_ScsiError( agRoot_t      *hpRoot,
                 agIORequest_t *phpIORequest,
                 agFcpRspHdr_t  * pResponseHeader,
                 ULONG hpIOInfoLen,
                 PSCSI_REQUEST_BLOCK Srb
                 );
int
RetrySrbOK (PSCSI_REQUEST_BLOCK pSrb);


void osFill(void * destin, os_bit32 length, os_bit8 fill );
BOOLEAN osStringCompare (char *str1, char *str2);
BOOLEAN osMemCompare (char *str1, char *str2, int count);
void osStringCopy ( char *destStr, char *sourceStr, int  destStrLen);

void osChipConfigWriteBit( agRoot_t *hpRoot, os_bit32 cardConfigOffset,os_bit32 chipIOLValue, os_bit32 valuesize);


void osCopyAndSwap(void * destin, void * source, UCHAR length );


VOID KeQuerySystemTime(
        OUT PLARGE_INTEGER  CurrentTime
        );

unsigned long get_time_stamp(void);

void ERROR_CONTEXT(char * file,  int line);

void SrbEnqueueTail (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb);
void SrbEnqueueHead (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb);
PSCSI_REQUEST_BLOCK SrbDequeueHead (OSL_QUEUE *queue);
void Startio (PCARD_EXTENSION pCard);


#if DBG

void dump_pCard( IN PCARD_EXTENSION pCard);

void  dump_PCI_regs( PCI_COMMON_CONFIG * pciCommonConfig );

#endif

int remove_Srbext(PCARD_EXTENSION     pCard,    PSRB_EXTENSION      pSrbExt);
void insert_Srbext(PCARD_EXTENSION     pCard,    PSRB_EXTENSION      pSrbExt);
PSRB_EXTENSION  Get_next_Srbext( PSRB_EXTENSION pNextSrbExt);
PSRB_EXTENSION  Del_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pOldSrbExt);
PSRB_EXTENSION  Add_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pNewSrbExt);


void display_sest_data(agIORequest_t *hpIORequest );
void display_srbext(agIORequest_t *hpIORequest );
void show_outstanding_IOs(PCARD_EXTENSION pCard);
os_bit32 fcGet_QA_Trace(agRoot_t  *hpRoot, void * data_out);
void fcDumpRegisters(agRoot_t  *hpRoot, void * data_out);

unsigned long get_hi_time_stamp(void);

#ifdef _DEBUG_PERF_DATA_
void dump_perf_data( PCARD_EXTENSION pCard  );
#endif

BOOLEAN
ReadFromRegistry (char *paramName, int type, void *data, int len);
void
osBugCheck (ULONG code,
    ULONG param1,
    ULONG param2,
    ULONG param3,
    ULONG param4);

void HPFibreTimerTick (IN PCARD_EXTENSION pCard);

BOOLEAN
RetrieveOsAdjustBufferEntry (
    char  *paramName,
    char  *value,
    int   len);

BOOLEAN
RetrieveOsAdjustBit32Entry (
    char  *paramName,
    os_bit32 *value);

agFCDev_t
MapToHandle (PCARD_EXTENSION pCard,
    ULONG           pathId,
    ULONG           targetId,
    ULONG           lun,
    PLU_EXTENSION   pLunExt);

/* The following are List of functions called in IOCTLs */

void
HPFillDriverInfo(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDriverInformation_t *hpFcDriverInfo,
    UCHAR *status
    );

void
HPFillCardConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcCardConfiguration_t *hpFcCardConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPFillDeviceConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceConfiguration_t *hpFcDeviceConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPFillLinkStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcLinkStatistics_t *hpFcLinkStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPFillDevStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceStatistics_t *hpFcDevStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPDoLinkReset(
    PSRB_IO_CONTROL srbIoCtl,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPDoDevReset(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceReset_t *hpFcDevReset,
    PCARD_EXTENSION pCard,
    UCHAR *PathId,
    UCHAR *TargetId,
    UCHAR *status
    );

void
HPDoRegRead(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegRead_t *hpFcRegRead,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPDoRegWrite(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegWrite_t *hpFcRegWrite,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

#ifdef _FCCI_SUPPORT
void
FcciFillDriverInfo(
    PSRB_IO_CONTROL srbIoCtl,
    AFCCI_DRIVER_INFO *FcciDriverInfo,
    UCHAR *status
    );

void
FcciFillAdapterInfo(
    PSRB_IO_CONTROL srbIoCtl,
    AFCCI_ADAPTER_INFO *FcciAdapterInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciFillAdapterPortInfo(
    PSRB_IO_CONTROL srbIoCtl,
    FCCI_ADAPTER_PORT_INFO *FcciAdapterPortInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciFillLogUnitInfo(
    PSRB_IO_CONTROL srbIoCtl,
    FCCI_LOGUNIT_INFO *FcciLogUnitInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciFillDeviceInfo(
    PSRB_IO_CONTROL srbIoCtl,
    AFCCI_DEVICE_INFO *FcciGetDeviceInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciDoDeviceReset(
    PSRB_IO_CONTROL srbIoCtl,
    FCCI_RESET_TARGET *FcciResetTarget,
    PCARD_EXTENSION pCard,
    UCHAR *PathId,
    UCHAR *TargetId,
    UCHAR *status
    );
#endif

void
InitLunExtension (PLU_EXTENSION pLunExt);

void
GetNodeInfo (PCARD_EXTENSION pCard);
void
RetryQToAdapterQ (PCARD_EXTENSION pCard);
int 
TestOnCardRam (agRoot_t *hpRoot);

void
GetSystemTime (CSHORT *Year, 
               CSHORT *Month,
               CSHORT *Day, 
               CSHORT *Hour,
               CSHORT *Minute,
               CSHORT *Second,
               CSHORT *Milliseconds);

/* Till here */
#ifdef _DEBUG_EVENTLOG_
VOID 
LogEvent(    
            PVOID                   pCard,
            PVOID                   pDeviceObject,
            ULONG                   errorType,
            ULONG                   Parm[],
            ULONG                   ParmCount,
            char                    *formatString,
            ... 
            );
BOOLEAN LogScsiError( agRoot_t            *hpRoot,
                      PSCSI_REQUEST_BLOCK pSrb ,
                  agFcpRspHdr_t  * pResponseHeader,
                  ULONG           hpIOInfoLen);

void FlushCardErrors(PCARD_EXTENSION    pcard);

extern ULONG LogLevel;

extern ULONG DecodeSrbError(UCHAR err);
extern void LogHBAInformation(PCARD_EXTENSION pCard);
extern VOID LogAnyMessage(IN PVOID DriverObject,
            LONG    msgCode,
            UCHAR   *formatString,
            ...
            );

extern ULONG AllocEventLogBuffer(IN PVOID DriverObject, IN PVOID pc);

extern VOID ReleaseEventLogBuffer(IN PVOID DriverObject, IN PVOID pc);

#endif


void ReadGlobalRegistry(PVOID DriverObject);

#ifdef __REGISTERFORSHUTDOWN__
extern ULONG gRegisterForShutdown;
#endif

#ifdef   _ENABLE_LARGELUN_
extern ULONG gEnableLargeLun;
extern ULONG gMaximumLuns;
#endif
#ifdef YAM2_1
extern REG_SETTING  gRegSetting;
extern WWN_TABLE    *gWWNTable;
extern ULONG            gMaxPaDevices;
extern int          gDeviceExtensionSize;
extern int          gMaximumTargetIDs;
extern ULONG    FindInPaDeviceTable(PCARD_EXTENSION pCard, ULONG fcDeviceIndex);
extern void     FillPaDeviceTable(PCARD_EXTENSION pCard);
extern ULONG    FindInWWNTable (PCARD_EXTENSION pCard, UCHAR *nodeWWN);
ULONG   GetPaDeviceHandle(PCARD_EXTENSION pCard,
            ULONG           pathId,
            ULONG           targetId,
            ULONG           lun,
            PLU_EXTENSION   pLunExt,
            USHORT          *paIndex);
void SetPaDeviceTable(PCARD_EXTENSION pCard, ULONG devIndex, ULONG flag);

void SetFcpLunBeforeStartIO (
            PLU_EXTENSION           pLunExt,
            agIORequestBody_t       *pHpio_CDBrequest,
            PSCSI_REQUEST_BLOCK     pSrb);

int  TryOtherAddressingMode(
            PCARD_EXTENSION     pCard, 
            agIORequest_t       *phpIORequest,
            PSRB_EXTENSION  pSrbExt, 
            ULONG               flag);

void InitializeDeviceTable(PCARD_EXTENSION pCard);
DEVICE_MAP  *GetDeviceMapping(PCARD_EXTENSION pCard,
    ULONG               pathId,
    ULONG               targetId,
    ULONG               lun, 
    CHAR                    *addrmode,
    USHORT              *paIndex);

void SetLunCount(PCARD_EXTENSION pCard,
    ULONG               pathId,
    ULONG               targetId,
    ULONG               lun);

#endif


#ifdef _DEBUG_SCSIPORT_NOTIFICATION_
VOID
Local_ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );
#define ScsiPortNotification                Local_ScsiPortNotification

VOID 
Local_ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    );
#define ScsiPortCompleteRequest             Local_ScsiPortCompleteRequest

#endif

#ifdef DBGPRINT_IO

#define DBGPRINT_START                      0x1
#define DBGPRINT_SEND                       0x2
#define DBGPRINT_DONE                       0x4
#define DBGPRINT_QHEAD                      0x8
#define DBGPRINT_QTAIL                      0x10
#define DBGPRINT_DEQHEAD                    0x20
#define DBGPRINT_HPFibreStartIo             0x40
#define DBGPRINT_SCSIPORT_RequestComplete   0x100
#define DBGPRINT_SCSIPORT_NextRequest       0x200
#define DBGPRINT_SCSIPORT_NextLuRequest     0x400
#define DBGPRINT_SCSIPORT_ResetDetected     0x800
#define DBGPRINT_SCSIPORT_ScsiportCompleteRequest       0x1000

extern ULONG    gDbgPrintIo;
#endif

#ifdef _DEBUG_PERR_             /* enable BugCheck */
extern ULONG    gDebugPerr;
#endif
#ifdef _DEBUG_REPORT_LUNS_
void PrintReportLunData(PSCSI_REQUEST_BLOCK pSrb);
#endif

#ifdef _ENABLE_PSEUDO_DEVICE_
extern ULONG    gEnablePseudoDevice;
ULONG   PseudoDeviceIO(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    );
#endif

ULONG DoIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    );


#ifdef _SAN_IOCTL_
ULONG AgSANIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN     *LinkResetPerformed,
    BOOLEAN     *DeviceResetPerformed,
    UCHAR           *srb_status,
    UCHAR       *PathId, 
    UCHAR           *TargetId);

void SANPutNextBuffer(
    IN PCARD_EXTENSION pCard,
    SAN_EVENTINFO      *this);
#endif


extern ULONG gCrashDumping;
extern ULONG gIrqlLevel;
#endif // __PROTOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\ostypes.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/OSTypes.H $

   $Revision: 3 $
   $Date: 9/07/00 11:19a $ (Last Check-In)
   $Modtime:: 8/31/00 3:25p   $ (Last Modified)

Purpose:

  This is the NT-specific OS Layer Types Include File.

  This file should be included by every module to ensure a uniform definition
  of all basic data types.  The NT-specific Layer must provide definitions for:

    os_bit8    - unsigned 8-bit value
    os_bit16   - unsigned 16-bit value
    os_bit32   - unsigned 32-bit value
    osGLOBAL   - used to declare a 'C' function external to a module
    osLOCAL    - used to declare a 'C' function local to a module

--*/

#ifndef __NT_OSTypes_H__

#define __NT_OSTypes_H__

//#ifndef _DvrArch_1_20_
//#define _DvrArch_1_20_
//#endif /* _DvrArch_1_20_ was not defined */


typedef unsigned char  os_bit8;
typedef unsigned short os_bit16;
typedef unsigned int   os_bit32;

#define osGLOBAL         extern
#define osLOCAL


#ifndef _DvrArch_1_20_

#define agBOOLEAN BOOLEAN
#define agTRUE         TRUE
#define agFALSE        FALSE
#define agNULL         NULL

#define bit8 os_bit8
#define bit16     os_bit16
#define bit32     os_bit32

#define GLOBAL    osGLOBAL
#define LOCAL     osLOCAL

#define agFCChanInfo_s      hpFCChanInfo_s
#define agFCChanInfo_t      hpFCChanInfo_t

#define agFCDev_t           hpFCDev_t

#define agDevUnknown        hpDevUnknown
#define agDevSelf           hpDevSelf
#define agDevSCSIInitiator  hpDevSCSIInitiator
#define agDevSCSITarget          hpDevSCSITarget

#define agFCDevInfo_s       hpFCDevInfo_s
#define agFCDevInfo_t       hpFCDevInfo_t

#define agFcpCntlReadData   hpFcpCntlReadData
#define agFcpCntlWriteData  hpFcpCntlWriteData

#define agFcpCmnd_s              hpFcpCmnd_s
#define agFcpCmnd_t              hpFcpCmnd_t

#define agCDBRequest_s      hpCDBRequest_s
#define agCDBRequest_t      hpCDBRequest_t

#define agFcpRspHdr_s       hpFcpRspHdr_s
#define agFcpRspHdr_t       hpFcpRspHdr_t

#define agIORequest_s       hpIORequest_s
#define agIORequest_t       hpIORequest_t

#define agIORequestBody_u   hpIORequestBody_u
#define agIORequestBody_t   hpIORequestBody_t

#define agRoot_s            hpRoot_s
#define agRoot_t            hpRoot_t



#endif  // #ifndef _DvrArch_1_20_


#include     <miniport.h>

#if defined(HP_NT50)
#define os_bitptr UINT_PTR
#else
#define os_bitptr ULONG
#endif


#endif  /* ~__NT_OSTypes_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\queue.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/Queue.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/12/00 8:44p  $ (Last Modified)

Purpose:

  This file implements queue management for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/timersvc.h"
#include "../h/queue.h"
#include "../h/cstate.h"
#include "../h/sfstate.h"
#include "../h/cfunc.h" 
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "timersvc.h"
#include "queue.h"
#include "cstate.h"
#include "sfstate.h"
#include "cfunc.h" 
#endif  /* _New_Header_file_Layout_ */

/*+
Static Table to convert AL_PA to Loop Index
-*/

os_bit8 AL_PA_to_Loop_Index[256] =
     {
       0x7E, 0x7D, 0x7C, 0xFF, 0x7B, 0xFF, 0xFF, 0xFF,
       0x7A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x79,
       0x78, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x77,
       0x76, 0xFF, 0xFF, 0x75, 0xFF, 0x74, 0x73, 0x72,
       0xFF, 0xFF, 0xFF, 0x71, 0xFF, 0x70, 0x6F, 0x6E,
       0xFF, 0x6D, 0x6C, 0x6B, 0x6A, 0x69, 0x68, 0xFF,
       0xFF, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0xFF,
       0xFF, 0x61, 0x60, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0x5E, 0xFF, 0x5D, 0x5C, 0x5B,
       0xFF, 0x5A, 0x59, 0x58, 0x57, 0x56, 0x55, 0xFF,
       0xFF, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4F, 0xFF,
       0xFF, 0x4E, 0x4D, 0xFF, 0x4C, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0x4B, 0xFF, 0x4A, 0x49, 0x48,
       0xFF, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0xFF,
       0xFF, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0xFF,
       0xFF, 0x3B, 0x3A, 0xFF, 0x39, 0xFF, 0xFF, 0xFF,
       0x38, 0x37, 0x36, 0xFF, 0x35, 0xFF, 0xFF, 0xFF,
       0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x33,
       0x32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x31,
       0x30, 0xFF, 0xFF, 0x2F, 0xFF, 0x2E, 0x2D, 0x2C,
       0xFF, 0xFF, 0xFF, 0x2B, 0xFF, 0x2A, 0x29, 0x28,
       0xFF, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0xFF,
       0xFF, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0xFF,
       0xFF, 0x1B, 0x1A, 0xFF, 0x19, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0x18, 0xFF, 0x17, 0x16, 0x15,
       0xFF, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0F, 0xFF,
       0xFF, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0xFF,
       0xFF, 0x08, 0x07, 0xFF, 0x06, 0xFF, 0xFF, 0xFF,
       0x05, 0x04, 0x03, 0xFF, 0x02, 0xFF, 0xFF, 0xFF,
       0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
     };

/*+
Queue Functions
-*/

agBOOLEAN fiListElementOnList(
                             fiList_t *toFindHdr,
                             fiList_t *listHdr
                           )
{
    fiList_t *elementHdr = listHdr;

    while ((elementHdr = elementHdr->flink) != listHdr)
    {
        if (elementHdr == toFindHdr)
        {
            return agTRUE;
        }
    }

    return agFALSE;
}

os_bit32 fiNumElementsOnList(
                           fiList_t *listHdr
                         )
{
    fiList_t *elementHdr  = listHdr;
    os_bit32     numElements = 0;
    if( elementHdr->flink == agNULL)
    {
        fiLogDebugString(agNULL,
                        0,
                        "In %s elementHdr->flink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        return numElements;
    }
    if( elementHdr->blink == agNULL)
    {
        fiLogDebugString(agNULL,
                        0,
                        "In %s   elementHdr->blink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        return numElements;
    }

    while ((elementHdr = elementHdr->flink) != listHdr)
    {
        if( elementHdr->flink == agNULL)
        {
            fiLogDebugString(agNULL,
                        0,
                        "In %s   elementHdr->flink->flink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            return numElements;
        }

        if( elementHdr->blink == agNULL)
        {
            fiLogDebugString(agNULL,
                        0,
                        "In %s   elementHdr->flink->blink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            return numElements;
        }

        numElements++;
        if( listHdr->flink == listHdr->blink)
        {
            break;
        }

        if(numElements > 0x1000)
        {
            fiLogDebugString(agNULL,
                        CStateLogConsoleERROR,
                        "In %s                   List exceeds 0x1000",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            break;
        } 
    }

    return numElements;
}

/*+
ERQ Management
-*/

void WaitForERQ(
                 agRoot_t *hpRoot
               )
{
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  NextProdIndex    = CThread->HostCopy_ERQProdIndex + 1;
    os_bit32           ConsIndex_Offset;
    ERQConsIndex_t *ConsIndex_Ptr;
    os_bit32 ERQ_Polling_Count = 0;
    if (NextProdIndex == CThread->Calculation.MemoryLayout.ERQ.elements)
    {
        NextProdIndex = 0;
    }

    if (CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inCardRam)
    {
        ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

        while (NextProdIndex == osCardRamReadBit32(
                                                    hpRoot,
                                                    ConsIndex_Offset
                                                  ))
        {
            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    }
    else /* CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inDmaMemory */
    {
        ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

        while (NextProdIndex == *ConsIndex_Ptr)
        {
            ERQ_Polling_Count++;
            if(ERQ_Polling_Count > 30000)
            {
                fiLogDebugString(
                                  hpRoot,
                                  QueueLogConsoleERRORLevel,
                                  "ERQ_Polling_Count over 30000",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );
                ERQ_Polling_Count=0;
            break;
            
            }

            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    ERQ_Polling_Count=0;
    }
}

void WaitForERQ_ConsIndexOnCard(
                                 agRoot_t *hpRoot
                               )
{
#ifndef __MemMap_Force_Off_Card__
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  NextProdIndex    = CThread->HostCopy_ERQProdIndex + 1;
    os_bit32           ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

    if (NextProdIndex == CThread->Calculation.MemoryLayout.ERQ.elements)
    {
        NextProdIndex = 0;
    }

    while (NextProdIndex == osCardRamReadBit32(
                                                hpRoot,
                                                ConsIndex_Offset
                                              ))
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void WaitForERQ_ConsIndexOffCard(
                                  agRoot_t *hpRoot
                                )
{
#ifndef __MemMap_Force_On_Card__
    CThread_t      *CThread       = CThread_ptr(hpRoot);
    ERQProdIndex_t  NextProdIndex = CThread->HostCopy_ERQProdIndex + 1;
    ERQConsIndex_t *ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

    if (NextProdIndex == CThread->Calculation.MemoryLayout.ERQ.elements)
    {
        NextProdIndex = 0;
    }

    while (NextProdIndex == *ConsIndex_Ptr)
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void WaitForERQEmpty(
                      agRoot_t *hpRoot
                    )
{
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  ProdIndex        = CThread->HostCopy_ERQProdIndex;
    os_bit32           ConsIndex_Offset;
    ERQConsIndex_t *ConsIndex_Ptr;

    if (CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inCardRam)
    {
        ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

        while (ProdIndex != osCardRamReadBit32(
                                                hpRoot,
                                                ConsIndex_Offset
                                              ))
        {
            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    }
    else /* CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inDmaMemory */
    {
        ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

        while (ProdIndex != *ConsIndex_Ptr)
        {
            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    }
}

void WaitForERQEmpty_ConsIndexOnCard(
                                      agRoot_t *hpRoot
                                    )
{
#ifndef __MemMap_Force_Off_Card__
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  ProdIndex        = CThread->HostCopy_ERQProdIndex;
    os_bit32           ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

    while (ProdIndex != osCardRamReadBit32(
                                            hpRoot,
                                            ConsIndex_Offset
                                          ))
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void WaitForERQEmpty_ConsIndexOffCard(
                                       agRoot_t *hpRoot
                                     )
{
#ifndef __MemMap_Force_On_Card__
    CThread_t      *CThread       = CThread_ptr(hpRoot);
    ERQProdIndex_t  ProdIndex     = CThread->HostCopy_ERQProdIndex;
    ERQConsIndex_t *ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

    while (ProdIndex != *ConsIndex_Ptr)
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
/*+
PktThread Management
-*/
void PktThreadsInitializeFreeList(
                                   agRoot_t *agRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(agRoot);
    fiMemMapMemoryDescriptor_t *PktThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.PktThread);
    fiMemMapMemoryDescriptor_t *Pkt_CMND_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.Pkt_CMND);
    PktThread_t                *PktThread                  = PktThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    FCHS_t                     *Pkt_CMND_Ptr;
    os_bit32                    Pkt_CMND_Offset;
    os_bit32                    Pkt_CMND_Lower32;
    os_bit32                    PktThread_size             = PktThread_MemoryDescriptor->elementSize;
    os_bit32                    Pkt_CMND_size              = Pkt_CMND_MemoryDescriptor->elementSize;
    fiMemMapMemoryLocation_t    Pkt_CMND_memLoc            = Pkt_CMND_MemoryDescriptor->memLoc;
    os_bit32                    total_PktThreads           = PktThread_MemoryDescriptor->elements;
    os_bit32                    PktThread_index;

    if (Pkt_CMND_memLoc == inCardRam)
    {
        Pkt_CMND_Ptr     = (FCHS_t *) agNULL;
        Pkt_CMND_Offset  = Pkt_CMND_MemoryDescriptor->addr.CardRam.cardRamOffset;
        Pkt_CMND_Lower32 = Pkt_CMND_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* Pkt_CMND_memLoc == inDmaMemory */
    {
        Pkt_CMND_Ptr     = (FCHS_t *)(Pkt_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        Pkt_CMND_Offset  = 0;
        Pkt_CMND_Lower32 = Pkt_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    fiListInitHdr(
                   &(CThread->Free_PktLink)
                 );

    for (PktThread_index = 0;
         PktThread_index < total_PktThreads;
         PktThread_index++)
    {
        PktThread->Pkt_CMND_Ptr     = Pkt_CMND_Ptr;
        PktThread->Pkt_CMND_Offset  = Pkt_CMND_Offset;
        PktThread->Pkt_CMND_Lower32 = Pkt_CMND_Lower32;

        fiListInitElement(&(PktThread->PktLink));

        fiListEnqueueAtTail( &(PktThread->PktLink),
                             &(CThread->Free_PktLink));

        PktThread = (PktThread_t *)((os_bit8 *)PktThread + PktThread_size);

        if (Pkt_CMND_memLoc == inCardRam)
        {
            Pkt_CMND_Offset += Pkt_CMND_size;
        }
        else /* Pkt_CMND_memLoc == inDmaMemory */
        {
            Pkt_CMND_Ptr     = (FCHS_t *)((os_bit8 *)Pkt_CMND_Ptr + Pkt_CMND_size);
        }

        Pkt_CMND_Lower32    += Pkt_CMND_size;
    }
}

PktThread_t *PktThreadAlloc(
                             agRoot_t *agRoot,
                             DevThread_t *pDevThread
                           )
{
    CThread_t   *CThread             = CThread_ptr(agRoot);
    fiList_t    *fiList_to_return;
    PktThread_t *PktThread_to_return;

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_PktLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        PktThread_to_return = (PktThread_t *)agNULL;
    }
    else /* fiList_to_return != (fiList_t *)agNULL */
    {
        PktThread_to_return = hpObjectBase(
                                            PktThread_t,
                                            PktLink,
                                            fiList_to_return
                                          );
        PktThread_to_return->Device = pDevThread;
    }

    return PktThread_to_return;
}

void PktThreadFree(
                    agRoot_t    *agRoot,
                    PktThread_t *PktThread
                  )
{
    CThread_t *CThread        = CThread_ptr(agRoot);
    fiList_t  *fiList_to_free = &(PktThread->PktLink);

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_PktLink)
                       );
}

#endif /* _DvrArch_1_30_ was defined */

/*+
TgtThread Management
-*/

void TgtThreadsInitializeFreeList(
                                   agRoot_t *hpRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *TgtThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.TgtThread);
    TgtThread_t                *TgtThread                  = TgtThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                       TgtThread_size             = TgtThread_MemoryDescriptor->elementSize;
    os_bit32                       total_TgtThreads           = TgtThread_MemoryDescriptor->elements;
    os_bit32                       TgtThread_index;

    fiListInitHdr(
                   &(CThread->Free_TgtLink)
                 );

    for (TgtThread_index = 0;
         TgtThread_index < total_TgtThreads;
         TgtThread_index++)
    {
        TgtThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

        SFThreadInitializeRequest(
                                   &(TgtThread->SFThread_Request)
                                 );

        fiListInitElement(&(TgtThread->TgtLink));

        fiListEnqueueAtTail( &(TgtThread->TgtLink),
                             &(CThread->Free_TgtLink));

        TgtThread = (TgtThread_t *)((os_bit8 *)TgtThread + TgtThread_size);
    }
}

TgtThread_t *TgtThreadAlloc(
                             agRoot_t *hpRoot
                           )
{
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    fiList_t    *fiList_to_return;
    TgtThread_t *TgtThread_to_return;

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_TgtLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        TgtThread_to_return = (TgtThread_t *)agNULL;
    }
    else /* fiList_to_return != (fiList_t *)agNULL */
    {
        TgtThread_to_return = hpObjectBase(
                                            TgtThread_t,
                                            TgtLink,
                                            fiList_to_return
                                          );
    }

    return TgtThread_to_return;
}

void TgtThreadFree(
                    agRoot_t    *hpRoot,
                    TgtThread_t *TgtThread
                  )
{
    CThread_t *CThread        = CThread_ptr(hpRoot);
    fiList_t  *fiList_to_free = &(TgtThread->TgtLink);

    if (TgtThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (TgtThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 hpRoot,
                                 &(TgtThread->SFThread_Request)
                               );
        }
        else /* TgtThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            SFThreadFree(
                          hpRoot,
                          &(TgtThread->SFThread_Request)
                        );
        }
    }

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_TgtLink)
                       );
}

/*+
DevThread Management
-*/

void DevThreadsInitializeFreeList(
                                   agRoot_t *hpRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *DevThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.DevThread);
    DevThread_t                *DevThread                  = DevThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                    DevThread_size             = DevThread_MemoryDescriptor->elementSize;
    os_bit32                    total_DevThreads           = DevThread_MemoryDescriptor->elements;
    os_bit32                    DevThread_index;
#ifdef _DvrArch_1_30_
    os_bit32                    IP_X_ID_Offset             = CThread->Calculation.MemoryLayout.CDBThread.elements +
                                                             CThread->Calculation.MemoryLayout.SFThread.elements;
#endif /* _DvrArch_1_30_ was defined */

    fiListInitHdr(
                   &(CThread->Free_DevLink)
                 );

    for (DevThread_index = 0;
         DevThread_index < total_DevThreads;
         DevThread_index++)
    {
#ifdef _DvrArch_1_30_
        DevThread->IP_X_ID                         =(X_ID_t) (DevThread_index + IP_X_ID_Offset);
        DevThread->NewIPExchange                   = agTRUE;
#endif /* _DvrArch_1_30_ was defined */
        DevThread->DevSlot                         = DevSlot_Invalid;

        DevThread->DevInfo.CurrentAddress.reserved = 0;
        DevThread->DevInfo.CurrentAddress.Domain   = 0;
        DevThread->DevInfo.CurrentAddress.Area     = 0;
        DevThread->DevInfo.CurrentAddress.AL_PA    = 0;

        DevThread->DevInfo.HardAddress.reserved    = 0;
        DevThread->DevInfo.HardAddress.Domain      = 0;
        DevThread->DevInfo.HardAddress.Area        = 0;
        DevThread->DevInfo.HardAddress.AL_PA       = 0;

        DevThread->SFThread_Request.SFThread       = (SFThread_t *)agNULL;

        SFThreadInitializeRequest(
                                   &(DevThread->SFThread_Request)
                                 );

        fiTimerInitializeRequest(
                                  &(DevThread->Timer_Request)
                                );

        fiListInitHdr( &(DevThread->Active_CDBLink_0));
        fiListInitHdr( &(DevThread->Active_CDBLink_1));
        fiListInitHdr( &(DevThread->Active_CDBLink_2));
        fiListInitHdr( &(DevThread->Active_CDBLink_3));
        fiListInitHdr( &(DevThread->TimedOut_CDBLink));

        fiListInitHdr( &(DevThread->Send_IO_CDBLink));

        fiListInitHdr( &(DevThread->Awaiting_Login_CDBLink));

        fiListInitElement( &(DevThread->DevLink) );

        fiListEnqueueAtTail( &(DevThread->DevLink),
                             &(CThread->Free_DevLink)
                           );

        DevThread = (DevThread_t *)((os_bit8 *)DevThread + DevThread_size);
    }
}

DevThread_t *DevThreadAlloc(
                             agRoot_t     *hpRoot,
                             FC_Port_ID_t  Port_ID
                           )
{
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    fiList_t    *fiList_to_return;
    DevThread_t *DevThread_to_return;

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_DevLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        DevThread_to_return = (DevThread_t *)agNULL;
    }
    else /* fiList_to_return != (fiList_t *)agNULL */
    {
        DevThread_to_return = hpObjectBase(
                                            DevThread_t,
                                            DevLink,
                                            fiList_to_return
                                          );

        DevThread_to_return->DevInfo.CurrentAddress.reserved = 0;
        DevThread_to_return->DevInfo.CurrentAddress.Domain = Port_ID.Struct_Form.Domain;
        DevThread_to_return->DevInfo.CurrentAddress.Area   = Port_ID.Struct_Form.Area;
        DevThread_to_return->DevInfo.CurrentAddress.AL_PA  = Port_ID.Struct_Form.AL_PA;
        CFuncInit_DevThread( hpRoot, DevThread_to_return );
        DevThread_to_return->DevSlot                       = DevSlot_Invalid;
        DevThread_to_return->PRLI_rejected                 = agFALSE;
        DevThread_to_return->FC_TapeDevice                 = agFALSE;
        DevThread_to_return->OtherAgilentHBA               = agFALSE;

    }

    return DevThread_to_return;
}

void DevThreadFree(
                    agRoot_t    *hpRoot,
                    DevThread_t *DevThread
                  )
{
    CThread_t   *CThread        = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread;
    fiList_t    *fiList_to_free;

    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_0)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_0",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_0),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_0)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_1)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_1",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_1),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_1)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_2)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_2",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_2),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_2)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_3)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_3",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_3),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_3)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->TimedOut_CDBLink)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","TimedOut_CDBLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->TimedOut_CDBLink),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->TimedOut_CDBLink)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }

    while (fiListNotEmpty(
                           &(DevThread->Send_IO_CDBLink)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Send_IO_CDBLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Send_IO_CDBLink),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Send_IO_CDBLink)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }

    while (fiListNotEmpty(
                           &(DevThread->Awaiting_Login_CDBLink)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Awaiting_Login_CDBLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Awaiting_Login_CDBLink)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }

    if (DevThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (DevThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 hpRoot,
                                 &(DevThread->SFThread_Request)
                               );
        }
        else /* DevThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            SFThreadFree(
                          hpRoot,
                          &(DevThread->SFThread_Request)
                        );
        }
    }

    if (DevThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(DevThread->Timer_Request)
                   );
    }

    DevThread->DevSlot                       = DevSlot_Invalid;

    DevThread->DevInfo.CurrentAddress.Domain = 0;
    DevThread->DevInfo.CurrentAddress.Area   = 0;
    DevThread->DevInfo.CurrentAddress.AL_PA  = 0;

    fiListDequeueThis( &(DevThread->DevLink));    
    fiList_to_free = &(DevThread->DevLink);

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_DevLink)
                       );
}

void DevThreadInitializeSlots(
                               agRoot_t *hpRoot
                             )
{
    os_bit32 total_SlotWWNs = CThread_ptr(hpRoot)->Calculation.MemoryLayout.SlotWWN.elements;
    os_bit32 SlotWWN_index;

    for (SlotWWN_index = 0;
         SlotWWN_index < total_SlotWWNs;
         SlotWWN_index++)
    {
        DevThreadFreeSlot(
                           hpRoot,
                           SlotWWN_index
                         );
    }
}

agBOOLEAN DevThreadMatchWWN(FC_Port_Name_t *WWN_1,FC_Port_Name_t *WWN_2 )
{
    if ((*WWN_1)[0] != (*WWN_2)[0]) return agFALSE;
    if ((*WWN_1)[1] != (*WWN_2)[1]) return agFALSE;
    if ((*WWN_1)[2] != (*WWN_2)[2]) return agFALSE;
    if ((*WWN_1)[3] != (*WWN_2)[3]) return agFALSE;
    if ((*WWN_1)[4] != (*WWN_2)[4]) return agFALSE;
    if ((*WWN_1)[5] != (*WWN_2)[5]) return agFALSE;
    if ((*WWN_1)[6] != (*WWN_2)[6]) return agFALSE;
    if ((*WWN_1)[7] != (*WWN_2)[7]) return agFALSE;

    return agTRUE;
}

#define MAX_DevSlot_Ranges  4

#define DevSlot_Bounds      2
#define DevSlot_Range_Start 0
#define DevSlot_Range_End   1

DevSlot_t DevThreadFindSlot(
                             agRoot_t       *hpRoot,
                             os_bit8            Domain_Address,
                             os_bit8            Area_Address,
                             os_bit8            Loop_Address,
                             FC_Port_Name_t *FindWWN
                           )
{
    CThread_t                  *CThread                                           = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SlotWWN_MemoryDescriptor                          = &(CThread->Calculation.MemoryLayout.SlotWWN);
    SlotWWN_t                  *SlotWWN_First                                     = (SlotWWN_t *)(SlotWWN_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr);
    os_bit32                       SlotWWN_size                                      = SlotWWN_MemoryDescriptor->elementSize;
    SlotWWN_t                  *SlotWWN;
    os_bit32                       NumDevSlotsPerArea                                = CThread->Calculation.Parameters.NumDevSlotsPerArea;
    os_bit32                       NumAreasPerDomain                                 = CThread->Calculation.Parameters.NumAreasPerDomain;
    os_bit32                       NumDomains                                        = CThread->Calculation.Parameters.NumDomains;
    os_bit32                       Loop_Index                                        = AL_PA_to_Loop_Index[Loop_Address];
    DevSlot_t                   DevSlot_Bucket_Min;
    DevSlot_t                   DevSlot_Bucket_Max;
    DevSlot_t                   DevSlot_Ideal;
    DevSlot_t                   DevSlot_Last                                      = SlotWWN_MemoryDescriptor->elements - 1;
    os_bit32                       DevSlot_Range_Index;
    os_bit32                       DevSlot_Ranges;
    DevSlot_t                   DevSlot_Range[MAX_DevSlot_Ranges][DevSlot_Bounds];
    DevSlot_t                   DevSlot_ToReturn;
    fiList_t                   *DevThread_DevLink;
    DevThread_t                *DevThread;

    /* Compute DevSlot_Bucket and DevSlot_Ideal */

    if (Loop_Index == 0xFF)
    {
        /* Invalid AL_PA: Use first DevSlot of Last DevSlot_Bucket */

        DevSlot_Ideal =   (  (  (NumDomains - 1)
                              * NumAreasPerDomain)
                           + (NumAreasPerDomain - 1) )
                        * NumDevSlotsPerArea;

        if (DevSlot_Ideal == 0)
        {
            /* Only a single DevSlot_Bucket, so only a single, simple DevSlot_Range */

            DevSlot_Ranges                        = 1;

            DevSlot_Range[0][DevSlot_Range_Start] = 0;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Last;
        }
        else /* DevSlot_Ideal != 0 */
        {
            /* More than one DevSlot_Bucket, so use two DevSlot_Ranges */

            DevSlot_Ranges                        = 2;

            DevSlot_Range[0][DevSlot_Range_Start] = DevSlot_Ideal;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Last;

            DevSlot_Range[1][DevSlot_Range_Start] = 0;
            DevSlot_Range[1][DevSlot_Range_End  ] = DevSlot_Ideal - 1;
        }
    }
    else /* Loop_Index != 0xFF */
    {
        /* Valid AL_PA: Use Loop_Index-based DevSlot in Domain/Area-based DevSlot_Bucket */

        DevSlot_Bucket_Min =   (  (  (Domain_Address % NumDomains)
                                   * NumAreasPerDomain            )
                                + (Area_Address % NumAreasPerDomain) )
                             * NumDevSlotsPerArea;

        DevSlot_Bucket_Max = DevSlot_Bucket_Min + NumDevSlotsPerArea - 1;

        DevSlot_Ideal      =   DevSlot_Bucket_Min
                             + (Loop_Index % NumDevSlotsPerArea);

        if (DevSlot_Ideal == DevSlot_Bucket_Min)
        {
            /* Only a simple DevSlot_Range needed for this DevSlot_Bucket */

            DevSlot_Ranges                        = 1;

            DevSlot_Range[0][DevSlot_Range_Start] = DevSlot_Bucket_Min;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Bucket_Max;
        }
        else /* DevSlot_Ideal == DevSlot_Bucket_Min */
        {
            /* Two DevSlot_Ranges needed for this DevSlot_Bucket */

            DevSlot_Ranges                        = 2;

            DevSlot_Range[0][DevSlot_Range_Start] = DevSlot_Ideal;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Bucket_Max;

            DevSlot_Range[1][DevSlot_Range_Start] = DevSlot_Bucket_Min;
            DevSlot_Range[1][DevSlot_Range_End  ] = DevSlot_Ideal - 1;
        }

        if (DevSlot_Bucket_Max < DevSlot_Last)
        {
            /* Additional DevSlot_Range for DevSlot_Buckets after DevSlot_Ideal Bucket */

            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_Start]  = DevSlot_Bucket_Max + 1;
            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_End  ]  = DevSlot_Last;

            DevSlot_Ranges                                     += 1;
        }

        if (DevSlot_Bucket_Min > 0)
        {
            /* Additional DevSlot_Range for DevSlot_Buckets before DevSlot_Ideal Bucket */

            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_Start]  = 0;
            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_End  ]  = DevSlot_Bucket_Min - 1;

            DevSlot_Ranges                                     += 1;
        }
    }

    /* First, see if this Port is already in a DevSlot */

    for (DevSlot_Range_Index = 0;
         DevSlot_Range_Index < DevSlot_Ranges;
         DevSlot_Range_Index++)
    {
        for (DevSlot_ToReturn  = DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_Start];
             DevSlot_ToReturn <= DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_End  ];
             DevSlot_ToReturn++)
        {
            SlotWWN = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevSlot_ToReturn * SlotWWN_size));

            if (    (SlotWWN->Slot_Status == SlotWWN_Slot_Status_InUse)
                 && (DevThreadMatchWWN( FindWWN,
                                        &(SlotWWN->Slot_PortWWN)
                                      )                         == agTRUE) )
            {
                SlotWWN->Slot_Domain_Address = Domain_Address;
                SlotWWN->Slot_Area_Address   = Area_Address;
                SlotWWN->Slot_Loop_Address   = Loop_Address;

                return DevSlot_ToReturn;
            }
        }
    }

    /* Since not found, see if there is room to insert this Port */

    for (DevSlot_Range_Index = 0;
         DevSlot_Range_Index < DevSlot_Ranges;
         DevSlot_Range_Index++)
    {
        for (DevSlot_ToReturn  = DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_Start];
             DevSlot_ToReturn <= DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_End  ];
             DevSlot_ToReturn++)
        {
            SlotWWN = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevSlot_ToReturn * SlotWWN_size));

            if (SlotWWN->Slot_Status == SlotWWN_Slot_Status_Empty)
            {
                SlotWWN->Slot_Status         = SlotWWN_Slot_Status_InUse;

                SlotWWN->Slot_Domain_Address = Domain_Address;
                SlotWWN->Slot_Area_Address   = Area_Address;
                SlotWWN->Slot_Loop_Address   = Loop_Address;

                SlotWWN->Slot_PortWWN[0]     = (*FindWWN)[0];
                SlotWWN->Slot_PortWWN[1]     = (*FindWWN)[1];
                SlotWWN->Slot_PortWWN[2]     = (*FindWWN)[2];
                SlotWWN->Slot_PortWWN[3]     = (*FindWWN)[3];
                SlotWWN->Slot_PortWWN[4]     = (*FindWWN)[4];
                SlotWWN->Slot_PortWWN[5]     = (*FindWWN)[5];
                SlotWWN->Slot_PortWWN[6]     = (*FindWWN)[6];
                SlotWWN->Slot_PortWWN[7]     = (*FindWWN)[7];

                return DevSlot_ToReturn;
            }
        }
    }

    /* No room, so see if some DevSlots can be reclaimed */

    /* First, mark all DevSlots (potentially) Stale (since they are all InUse currently) */

    SlotWWN = SlotWWN_First;

    for (DevSlot_ToReturn  = 0;
         DevSlot_ToReturn <= DevSlot_Last;
         DevSlot_ToReturn++)
    {
        SlotWWN->Slot_Status = SlotWWN_Slot_Status_Stale;

        SlotWWN++;
    }

    if (   (CThread->DeviceSelf != (DevThread_t *)agNULL)
        && (CThread->DeviceSelf->DevSlot != DevSlot_Invalid))
    {
        /* DeviceSelf is not on any list, so if it exists (it should) & DevSlot allocated, mark DevSlot as InUse */

        SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (CThread->DeviceSelf->DevSlot * SlotWWN_size));

        SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
    }

    /* Walk CThread->Active_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Active_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Active_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Unknown_Slot_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Unknown_Slot_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Unknown_Slot_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Slot_Searching_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Slot_Searching_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Slot_Searching_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Prev_Active_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Prev_Active_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Prev_Active_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Prev_Unknown_Slot_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Prev_Unknown_Slot_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Prev_Unknown_Slot_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Finally, free up (i.e. mark as Empty) Stale DevSlots */

    SlotWWN = SlotWWN_First;

    for (DevSlot_ToReturn  = 0;
         DevSlot_ToReturn <= DevSlot_Last;
         DevSlot_ToReturn++)
    {
        if (SlotWWN->Slot_Status == SlotWWN_Slot_Status_Stale)
        {
            SlotWWN->Slot_Status = SlotWWN_Slot_Status_Empty;
        }

        SlotWWN++;
    }

    /* Now repeat the search for an empty DevSlot */

    for (DevSlot_Range_Index = 0;
         DevSlot_Range_Index < DevSlot_Ranges;
         DevSlot_Range_Index++)
    {
        for (DevSlot_ToReturn  = DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_Start];
             DevSlot_ToReturn <= DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_End  ];
             DevSlot_ToReturn++)
        {
            SlotWWN = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevSlot_ToReturn * SlotWWN_size));

            if (SlotWWN->Slot_Status == SlotWWN_Slot_Status_Empty)
            {
                SlotWWN->Slot_Status         = SlotWWN_Slot_Status_InUse;

                SlotWWN->Slot_Domain_Address = Domain_Address;
                SlotWWN->Slot_Area_Address   = Area_Address;
                SlotWWN->Slot_Loop_Address   = Loop_Address;

                SlotWWN->Slot_PortWWN[0]     = (*FindWWN)[0];
                SlotWWN->Slot_PortWWN[1]     = (*FindWWN)[1];
                SlotWWN->Slot_PortWWN[2]     = (*FindWWN)[2];
                SlotWWN->Slot_PortWWN[3]     = (*FindWWN)[3];
                SlotWWN->Slot_PortWWN[4]     = (*FindWWN)[4];
                SlotWWN->Slot_PortWWN[5]     = (*FindWWN)[5];
                SlotWWN->Slot_PortWWN[6]     = (*FindWWN)[6];
                SlotWWN->Slot_PortWWN[7]     = (*FindWWN)[7];

                return DevSlot_ToReturn;
            }
        }
    }

    return DevSlot_Invalid;
}

void DevThreadFreeSlot(
                        agRoot_t  *hpRoot,
                        DevSlot_t  DevSlot
                      )
{
    CThread_t                  *CThread                  = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SlotWWN_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SlotWWN);
    os_bit32                       SlotWWN_size             = SlotWWN_MemoryDescriptor->elementSize;
    SlotWWN_t                  *SlotWWN;

    SlotWWN = (SlotWWN_t *)((os_bit8 *)(SlotWWN_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr) + (DevSlot * SlotWWN_size));

    SlotWWN->Slot_Status         = SlotWWN_Slot_Status_Empty;

    SlotWWN->Slot_Domain_Address = 0;
    SlotWWN->Slot_Area_Address   = 0;
    SlotWWN->Slot_Loop_Address   = 0;

    SlotWWN->Slot_PortWWN[0]     = 0;
    SlotWWN->Slot_PortWWN[1]     = 0;
    SlotWWN->Slot_PortWWN[2]     = 0;
    SlotWWN->Slot_PortWWN[3]     = 0;
    SlotWWN->Slot_PortWWN[4]     = 0;
    SlotWWN->Slot_PortWWN[5]     = 0;
    SlotWWN->Slot_PortWWN[6]     = 0;
    SlotWWN->Slot_PortWWN[7]     = 0;
}

/*+
CDBThread Management
-*/

void CDBThreadsInitializeFreeList(
                                   agRoot_t *hpRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    fiMemMapMemoryDescriptor_t *SEST_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SEST);
    fiMemMapMemoryDescriptor_t *FCP_CMND_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.FCP_CMND);
    fiMemMapMemoryDescriptor_t *FCP_RESP_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.FCP_RESP);
    CDBThread_t                *CDBThread                  = CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    SEST_t                     *SEST_Ptr;
    os_bit32                       SEST_Offset;
    FCHS_t                     *FCP_CMND_Ptr;
    os_bit32                       FCP_CMND_Offset;
    os_bit32                       FCP_CMND_Lower32;
    FCHS_t                     *FCP_RESP_Ptr;
    os_bit32                       FCP_RESP_Offset;
    os_bit32                       FCP_RESP_Lower32;
    os_bit32                       CDBThread_size             = CDBThread_MemoryDescriptor->elementSize;
    os_bit32                       SEST_size                  = SEST_MemoryDescriptor->elementSize;
    os_bit32                       FCP_CMND_size              = FCP_CMND_MemoryDescriptor->elementSize;
    os_bit32                       FCP_RESP_size              = FCP_RESP_MemoryDescriptor->elementSize;
    fiMemMapMemoryLocation_t    SEST_memLoc                = SEST_MemoryDescriptor->memLoc;
    fiMemMapMemoryLocation_t    FCP_CMND_memLoc            = FCP_CMND_MemoryDescriptor->memLoc;
    fiMemMapMemoryLocation_t    FCP_RESP_memLoc            = FCP_RESP_MemoryDescriptor->memLoc;
    os_bit32                       total_CDBThreads           = CDBThread_MemoryDescriptor->elements;
    os_bit32                       CDBThread_index;

    if (SEST_memLoc == inCardRam)
    {
        SEST_Ptr         = (SEST_t *)agNULL;
        SEST_Offset      = SEST_MemoryDescriptor->addr.CardRam.cardRamOffset;
    }
    else /* SEST_memLoc == inDmaMemory */
    {
        SEST_Ptr         = (SEST_t *)(SEST_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        SEST_Offset      = 0;
    }

    if (FCP_CMND_memLoc == inCardRam)
    {
        FCP_CMND_Ptr     = (FCHS_t *)agNULL;
        FCP_CMND_Offset  = FCP_CMND_MemoryDescriptor->addr.CardRam.cardRamOffset;
        FCP_CMND_Lower32 = FCP_CMND_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* FCP_CMND_memLoc == inDmaMemory */
    {
        FCP_CMND_Ptr     = (FCHS_t *)(FCP_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        FCP_CMND_Offset  = 0;
        FCP_CMND_Lower32 = FCP_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    if (FCP_RESP_memLoc == inCardRam)
    {
        FCP_RESP_Ptr     = (FCHS_t *)agNULL;
        FCP_RESP_Offset  = FCP_RESP_MemoryDescriptor->addr.CardRam.cardRamOffset;
        FCP_RESP_Lower32 = FCP_RESP_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* FCP_RESP_memLoc == inDmaMemory */
    {
        FCP_RESP_Ptr     = (FCHS_t *)(FCP_RESP_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        FCP_RESP_Offset  = 0;
        FCP_RESP_Lower32 = FCP_RESP_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    CThread->IOsStartedThisTimerTick      = 0;
    CThread->IOsCompletedThisTimerTick    = 0;
    CThread->IOsIntCompletedThisTimerTick = 0;
    CThread->IOsActive                    = 0;
    CThread->IOsStartedSinceISR           = 0;

#ifdef _Enforce_MaxCommittedMemory_
    CThread->CommittedMemory              = 0;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiListInitHdr(
                   &(CThread->Free_CDBLink)
                 );

    for (CDBThread_index = 0;
         CDBThread_index < total_CDBThreads;
         CDBThread_index++)
    {
        CDBThread->Active                    = agFALSE;
        CDBThread->ExchActive                = agFALSE;

        CDBThread->hpIORequest               = (agIORequest_t *)agNULL;
        CDBThread->X_ID                      = (os_bit16)CDBThread_index;
        CDBThread->SEST_Ptr                  = SEST_Ptr;
        CDBThread->SEST_Offset               = SEST_Offset;
        CDBThread->FCP_CMND_Ptr              = FCP_CMND_Ptr;
        CDBThread->FCP_CMND_Offset           = FCP_CMND_Offset;
        CDBThread->FCP_CMND_Lower32          = FCP_CMND_Lower32;
        CDBThread->FCP_RESP_Ptr              = FCP_RESP_Ptr;
        CDBThread->FCP_RESP_Offset           = FCP_RESP_Offset;
        CDBThread->FCP_RESP_Lower32          = FCP_RESP_Lower32;

        CDBThread->CDB_CMND_Class            = SFThread_SF_CMND_Class_CDB_FCP;
        CDBThread->CDB_CMND_Type             = SFThread_SF_CMND_Type_NULL;
        CDBThread->CDB_CMND_State            = SFThread_SF_CMND_State_NULL;
        CDBThread->CDB_CMND_Status           = SFThread_SF_CMND_Status_NULL;

        CDBThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

        SFThreadInitializeRequest(
                                   &(CDBThread->SFThread_Request)
                                 );

        fiTimerInitializeRequest(
                                  &(CDBThread->Timer_Request)
                                );

        ESGLInitializeRequest(
                               &(CDBThread->ESGL_Request)
                             );

        fiListInitElement(
                           &(CDBThread->CDBLink)
                         );

        fiListEnqueueAtTail(
                             &(CDBThread->CDBLink),
                             &(CThread->Free_CDBLink)
                           );

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread + CDBThread_size);

        if (SEST_memLoc == inCardRam)
        {
            SEST_Offset     += SEST_size;
        }
        else /* SEST_memLoc == inDmaMemory */
        {
            SEST_Ptr        += 1;
        }

        if (FCP_CMND_memLoc == inCardRam)
        {
            FCP_CMND_Offset += FCP_CMND_size;
        }
        else /* FCP_CMND_memLoc == inDmaMemory */
        {
            FCP_CMND_Ptr     = (FCHS_t *)((os_bit8 *)FCP_CMND_Ptr + FCP_CMND_size);
        }

        if (FCP_RESP_memLoc == inCardRam)
        {
            FCP_RESP_Offset += FCP_RESP_size;
        }
        else /* FCP_RESP_memLoc == inDmaMemory */
        {
            FCP_RESP_Ptr     = (FCHS_t *)((os_bit8 *)FCP_RESP_Ptr + FCP_RESP_size);
        }

        FCP_CMND_Lower32    += FCP_CMND_size;
        FCP_RESP_Lower32    += FCP_RESP_size;
    }
}

CDBThread_t *CDBThreadAlloc(
                             agRoot_t          *hpRoot,
                             agIORequest_t     *hpIORequest,
                             agFCDev_t          hpFCDev,
                             agIORequestBody_t *hpRequestBody
                           )
{
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    DevThread_t *DevThread           = DevThread_ptr(hpFCDev);
    fiList_t    *fiList_to_return;
    CDBThread_t *CDBThread_to_return;
    agFcpCmnd_t *FcpCmnd             = &(hpRequestBody->CDBRequest.FcpCmnd);
    os_bit32        Add_CommittedMemory;
#ifdef _Enforce_MaxCommittedMemory_
    os_bit32        New_CommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    Add_CommittedMemory =   (FcpCmnd->FcpDL[0] << 24)
                          + (FcpCmnd->FcpDL[1] << 16)
                          + (FcpCmnd->FcpDL[2] <<  8)
                          + (FcpCmnd->FcpDL[3] <<  0);

#ifdef _Enforce_MaxCommittedMemory_
    New_CommittedMemory = CThread->CommittedMemory + Add_CommittedMemory;

    if (New_CommittedMemory > CThread->Calculation.Parameters.MaxCommittedMemory)
    {

        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "CDBThreadAlloc Fail - New_CommittedMemory(%X) > %X",
                    (char *)agNULL,(char *)agNULL,
                    New_CommittedMemory,
                    CThread->Calculation.Parameters.MaxCommittedMemory,
                    0,0,0,0,0,0);

        hpIORequest->fcData = (void *)agNULL;
        return (CDBThread_t *)agNULL;
    }
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_CDBLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "CDBThreadAlloc Fail - No CDBThreads Left ! IOsActive %X CCnt %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->IOsActive,
                    CThread->CDBpollingCount,
                    0,0,0,0,0,0);

        hpIORequest->fcData = (void *)agNULL;
        return (CDBThread_t *)agNULL;
    }

    CDBThread_to_return = hpObjectBase(
                                        CDBThread_t,
                                        CDBLink,
                                        fiList_to_return
                                      );
    /* If you want to drop a X_ID zero  do this
    if(CDBThread_to_return->X_ID == 0x0)
    {
        fiListEnqueueAtTail(
                             &(CDBThread_to_return->CDBLink),
                             &(CThread->Free_CDBLink)
                           );

        fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_CDBLink)
                         );

        CDBThread_to_return = hpObjectBase(
                                            CDBThread_t,
                                            CDBLink,
                                            fiList_to_return
                                          );
    }
    */

    CDBThread_to_return->Active      = agTRUE;
    CDBThread_to_return->ExchActive  = agTRUE;

    CDBThread_to_return->ReSentIO    = agFALSE;
    CDBThread_to_return->TimeStamp   =  0;
    CDBThread_to_return->ActiveDuringLinkEvent = agFALSE;
    CDBThread_to_return->CompletionStatus = osIOInvalid;


    CDBThread_to_return->Device      = DevThread;
    CDBThread_to_return->hpIORequest = hpIORequest;
    CDBThread_to_return->CDBRequest  = &(hpRequestBody->CDBRequest);
    CDBThread_to_return->DataLength  = Add_CommittedMemory;

    CDBThread_to_return->SFThread_Request.SFThread = (SFThread_t * )agNULL;
    CThread->IOsStartedThisTimerTick += 1;
    CThread->IOsActive               += 1;

#ifdef FULL_FC_TAPE_DBG
    if( DevThread->FC_TapeDevice)
    {
        CDBThread_to_return->FC_Tape_Active = agTRUE;
        CDBThread_to_return->CDB_CMND_Class = SFThread_SF_CMND_Class_FC_Tape;
        CDBThread_to_return->CDB_CMND_Type  = SFThread_SF_CMND_Type_CDB_FC_Tape;
    }
    else
    {
#endif /* FULL_FC_TAPE_DBG */
        CDBThread_to_return->FC_Tape_Active = agFALSE;
        CDBThread_to_return->CDB_CMND_Class = SFThread_SF_CMND_Class_CDB_FCP;
        CDBThread_to_return->CDB_CMND_Type  = SFThread_SF_CMND_Type_CDB;
#ifdef FULL_FC_TAPE_DBG
    }
#endif /* FULL_FC_TAPE_DBG */

    CDBThread_to_return->CDB_CMND_State            = SFThread_SF_CMND_State_NULL;
    CDBThread_to_return->CDB_CMND_Status           = SFThread_SF_CMND_Status_NULL;


#ifdef _Enforce_MaxCommittedMemory_
    CThread->CommittedMemory = New_CommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    hpIORequest->fcData = (void *)CDBThread_to_return;

    fiListEnqueueAtTail(
                         fiList_to_return,
                         &(DevThread->Send_IO_CDBLink)
                       );

    return CDBThread_to_return;
}

void CDBThreadFree(
                    agRoot_t    *hpRoot,
                    CDBThread_t *CDBThread
                  )
{
    CThread_t *CThread        = CThread_ptr(hpRoot);
    fiList_t  *fiList_to_free = &(CDBThread->CDBLink);

    if (!(CDBThread->Active))
        fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "CDBThreadFree: Freeing already freed Cdb %p",
                (char *)agNULL,(char *)agNULL,
                CDBThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    osDebugBreakpoint(
                       hpRoot,
                       ((CDBThread->Active == agTRUE) ? agFALSE : agTRUE),
                       "CDBThreadFree(): CDBThread->Active != agTRUE"
                     );

    if (CDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (CDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread->FuncPtrs.ESGLAllocCancel(
                                               hpRoot,
                                               &(CDBThread->ESGL_Request)
                                             );
        }
        else /* CDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread->FuncPtrs.ESGLFree(
                                        hpRoot,
                                        &(CDBThread->ESGL_Request)
                                      );
        }
    }

    if (CDBThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (CDBThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 hpRoot,
                                 &(CDBThread->SFThread_Request)
                               );
        }
        else /* CDBThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            fiLogDebugString(hpRoot,
                            CDBStateAbortPathLevel,
                            "In %s - SF %p SFState = %d CCnt %x",
                            "CDBThreadFree",(char *)agNULL,
                            CDBThread->SFThread_Request.SFThread,(void *)agNULL,
                            (os_bit32)CDBThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            CThread->CDBpollingCount,
                            0,0,0,0,0,0);

           /*  CThread->pollingCount--; */
            SFThreadFree(
                          hpRoot,
                          &(CDBThread->SFThread_Request)
                        );
        }
    }

    if (CDBThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(CDBThread->Timer_Request)
                   );
    }

    CDBThread->hpIORequest = (agIORequest_t *)agNULL;

    fiListDequeueThis(
                       fiList_to_free
                     );

    CDBThread->Active = agFALSE;

    CThread->IOsCompletedThisTimerTick += 1;
    CThread->IOsActive                 -= 1;

#ifdef _Enforce_MaxCommittedMemory_
    CThread->CommittedMemory           -= CDBThread->DataLength;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_CDBLink)
                       );
}

/*+
SFThread Management
-*/

void SFThreadsInitializeFreeList(
                                  agRoot_t *hpRoot
                                )
{
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    fiMemMapMemoryDescriptor_t *SF_CMND_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SF_CMND);
    SFThread_t                 *SFThread                  = SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    FCHS_t                     *SF_CMND_Ptr;
    os_bit32                       SF_CMND_Offset;
    os_bit32                       SF_CMND_Lower32;
    os_bit32                       SFThread_size             = SFThread_MemoryDescriptor->elementSize;
    os_bit32                       SF_CMND_size              = SF_CMND_MemoryDescriptor->elementSize;
    fiMemMapMemoryLocation_t    SF_CMND_memLoc            = SF_CMND_MemoryDescriptor->memLoc;
    os_bit32                       total_SFThreads           = SFThread_MemoryDescriptor->elements;
    os_bit32                       SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_index;

    if (SF_CMND_memLoc == inCardRam)
    {
        SF_CMND_Ptr     = (FCHS_t *)agNULL;
        SF_CMND_Offset  = SF_CMND_MemoryDescriptor->addr.CardRam.cardRamOffset;
        SF_CMND_Lower32 = SF_CMND_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* SF_CMND_memLoc == inDmaMemory */
    {
        SF_CMND_Ptr     = (FCHS_t *)(SF_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        SF_CMND_Offset  = 0;
        SF_CMND_Lower32 = SF_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    fiListInitHdr(
                   &(CThread->SFThread_Wait_Link)
                 );
    fiListInitHdr(
                   &(CThread->Free_SFLink)
                 );

    for (SFThread_index = 0;
         SFThread_index < total_SFThreads;
         SFThread_index++)
    {
        SFThread->X_ID            = (X_ID_t)(SFThread_index + SFThread_X_ID_Offset);
        SFThread->SF_CMND_Ptr     = SF_CMND_Ptr;
        SFThread->SF_CMND_Offset  = SF_CMND_Offset;
        SFThread->SF_CMND_Lower32 = SF_CMND_Lower32;
        SFThread->SF_CMND_Class   = SFThread_SF_CMND_Class_NULL;
        SFThread->SF_CMND_Type    = SFThread_SF_CMND_Type_NULL;
        SFThread->SF_CMND_State   = SFThread_SF_CMND_State_NULL;
        SFThread->SF_CMND_Status  = SFThread_SF_CMND_Status_NULL;

        fiTimerInitializeRequest(
                                  &(SFThread->Timer_Request)
                                );

        fiListInitElement(
                           &(SFThread->SFLink)
                         );

        fiListEnqueueAtTail(
                             &(SFThread->SFLink),
                             &(CThread->Free_SFLink)
                           );

        SFThread = (SFThread_t *)((os_bit8 *)SFThread + SFThread_size);

        if (SF_CMND_memLoc == inCardRam)
        {
            SF_CMND_Offset += SF_CMND_size;
        }
        else /* SF_CMND_memLoc == inDmaMemory */
        {
            SF_CMND_Ptr     = (FCHS_t *)((os_bit8 *)SF_CMND_Ptr + SF_CMND_size);
        }

        SF_CMND_Lower32    += SF_CMND_size;
    }
}

void SFThreadInitializeRequest(
                                SFThread_Request_t *SFThread_Request
                              )
{
    fiListInitElement(
                       &(SFThread_Request->SFThread_Wait_Link)
                     );

    SFThread_Request->SFThread = (SFThread_t *)agNULL;
    SFThread_Request->State    = SFThread_Request_InActive;
}

void SFThreadAlloc(
                    agRoot_t           *hpRoot,
                    SFThread_Request_t *SFThread_Request
                  )
{
    CThread_t *CThread = CThread_ptr(hpRoot);
    fiList_t  *fiList;

    if(SFThread_Request->State != SFThread_Request_InActive)
    {
        fiLogString(hpRoot,
                "In %s  %x != SFThread_Request_InActive",
                "SFThreadAlloc",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->State,
                0,0,0,0,0,0,0);
    }

    osDebugBreakpoint(
                       hpRoot,
                       ((SFThread_Request->State == SFThread_Request_InActive) ? agFALSE : agTRUE),
                       "SFThreadAlloc(): SFThread_Request->State != SFThread_Request_InActive"
                     );

    fiListDequeueFromHead(
                           &fiList,
                           &(CThread->Free_SFLink)
                         );

    if (fiList == (fiList_t *)agNULL)
    {
        SFThread_Request->State = SFThread_Request_Pending;
        /*
        fiLogString(hpRoot,
                "In %s %s     event %d",
                "SFThreadAlloc","SFThread_Request_Pending",
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->eventRecord_to_send.event,
                0,0,0,0,0,0,0);
        */
        fiListEnqueueAtTail(
                             SFThread_Request,
                             &(CThread->SFThread_Wait_Link)
                           );
    }
    else /* fiList != (fiList_t *)agNULL */
    {
        SFThread_Request->SFThread = hpObjectBase(
                                                   SFThread_t,
                                                   SFLink,
                                                   fiList
                                                 );

        SFThread_Request->State = SFThread_Request_Granted;
        /*
        fiLogString(hpRoot,
                "In %s %s = %p event %d",
                "SFThreadAlloc","SFThread_Request_Granted",
                SFThread_Request->SFThread,(void *)agNULL,
                SFThread_Request->eventRecord_to_send.event,
                0,0,0,0,0,0,0);
        */
        fiListInitHdr(&(SFThread_Request->SFThread->SFLink));

        fiSendEvent(
                     SFThread_Request->eventRecord_to_send.thread,
                     SFThread_Request->eventRecord_to_send.event
                   );
    }
}

void SFThreadAllocCancel(
                          agRoot_t           *hpRoot,
                          SFThread_Request_t *SFThread_Request
                        )
{

    if(SFThread_Request->State != SFThread_Request_Pending)
    {
        fiLogString(hpRoot,
                "In %s  %x != SFThread_Request_Pending",
                "SFThreadAllocCancel",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->State,
                0,0,0,0,0,0,0);
    }

    osDebugBreakpoint(
                       hpRoot,
                       ((SFThread_Request->State == SFThread_Request_Pending) ? agFALSE : agTRUE),
                       "SFThreadAllocCancel(): SFThread_Request->State != SFThread_Request_Pending"
                     );

    fiListDequeueThis(
                       SFThread_Request
                     );

    SFThread_Request->State = SFThread_Request_InActive;
}

void SFThreadFree(
                   agRoot_t           *hpRoot,
                   SFThread_Request_t *SFThread_Request
                 )
{
    CThread_t          *CThread                  = CThread_ptr(hpRoot);
    SFThread_t         *SFThread                 = SFThread_Request->SFThread;
    fiList_t           *fiList;
    SFThread_Request_t *Pending_SFThread_Request;

    if(SFThread_Request->State != SFThread_Request_Granted)
    {
        fiLogString(hpRoot,
                "In %s  %x != SFThread_Request_Granted",
                "SFThreadFree",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->State,
                0,0,0,0,0,0,0);
    }
    osDebugBreakpoint(
                       hpRoot,
                       ((SFThread_Request->State == SFThread_Request_Granted) ? agFALSE : agTRUE),
                       "SFThreadFree(): SFThread_Request->State != SFThread_Request_Granted"
                     );


    fiSendEvent(&SFThread->thread_hdr,SFEventReset);

    if (SFThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(SFThread->Timer_Request)
                   );
    }

    SFThread_Request->SFThread = (SFThread_t *)agNULL;
    SFThread_Request->State    = SFThread_Request_InActive;

    SFThread->SF_CMND_Class    = SFThread_SF_CMND_Class_NULL;
    SFThread->SF_CMND_Type     = SFThread_SF_CMND_Type_NULL;
    SFThread->SF_CMND_State    = SFThread_SF_CMND_State_NULL;
    SFThread->SF_CMND_Status   = SFThread_SF_CMND_Status_NULL;
    
    fiListDequeueFromHead(
                           &fiList,
                           &(CThread->SFThread_Wait_Link)
                         );

    if (fiList == (fiList_t *)agNULL)
    {
        fiListEnqueueAtTail(
                             &(SFThread->SFLink),
                             &(CThread->Free_SFLink)
                           );
    }
    else /* fiList != (fiList_t *)agNULL */
    {
        Pending_SFThread_Request = hpObjectBase(
                                                 SFThread_Request_t,
                                                 SFThread_Wait_Link,
                                                 fiList
                                               );

        Pending_SFThread_Request->SFThread = SFThread;
        Pending_SFThread_Request->State    = SFThread_Request_Granted;

        fiSendEvent(
                     Pending_SFThread_Request->eventRecord_to_send.thread,
                     Pending_SFThread_Request->eventRecord_to_send.event
                   );
    }
}

/*+
ESGL Management
-*/

void ESGLInitializeFreeList(
                             agRoot_t *hpRoot
                           )
{
    CThread_t                  *CThread               = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *ESGL_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.ESGL);
    fiMemMapMemoryLocation_t    ESGL_memLoc           = ESGL_MemoryDescriptor->memLoc;
    os_bit32                    ESGL_Upper32;
    os_bit32                    ESGL_Lower32;
    os_bit32                    ESGL_Offset;
    SG_Element_t               *ESGL;
    os_bit32                    ESGL_size             = ESGL_MemoryDescriptor->elementSize;
    os_bit32                    ESGL_Next_Lower32;
    os_bit32                    ESGL_Next_Offset;
    SG_Element_t               *ESGL_Next;
    os_bit32                    ESGL_Chain_Offset;
    SG_Element_t               *ESGL_Chain;
    os_bit32                    total_ESGLs           = ESGL_MemoryDescriptor->elements;
    os_bit32                    ESGL_index;
    SG_Element_t                ESGL_Chain_To_Write;
    ESGL = ESGL_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr;

    if (ESGL_memLoc == inCardRam)
    {
        ESGL_Offset  = ESGL_MemoryDescriptor->addr.CardRam.cardRamOffset;
        ESGL_Lower32 = ESGL_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* ESGL_memLoc == inDmaMemory */
    {
        ESGL_Lower32 = ESGL_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
        ESGL_Offset  = ESGL_Lower32 - CThread->Calculation.Input.dmaMemoryLower32;
        ESGL         = ESGL_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr;
    }

    ESGL_Upper32 = CThread->Calculation.Input.cardRamUpper32;

    fiListInitHdr(
                   &(CThread->ESGL_Wait_Link)
                 );

    CThread->Free_ESGL_count        = total_ESGLs;
    CThread->offsetToFirstFree_ESGL = ESGL_Offset;

    for (ESGL_index = 0;
         ESGL_index < total_ESGLs;
         ESGL_index++)
    {
        ESGL_Next_Lower32 = ESGL_Lower32 + ESGL_size;

        if (ESGL_index == (total_ESGLs - 1))
        {
            ESGL_Chain_To_Write.U32_Len = 0;
            ESGL_Chain_To_Write.L32     = 0;
        }
        else /* ESGL_index != (total_ESGLs - 1) */
        {
            ESGL_Chain_To_Write.U32_Len = (~SG_Element_Chain_Res_MASK)
                                          & ((ESGL_Upper32 << SG_Element_U32_SHIFT)
                                             | SG_Element_Len_MASK);
            ESGL_Chain_To_Write.L32     = ESGL_Next_Lower32;
        }

        if (ESGL_memLoc == inCardRam)
        {
            ESGL_Next_Offset  = ESGL_Offset  + ESGL_size;
            ESGL_Chain_Offset = ESGL_Next_Offset - sizeof(SG_Element_t);

            osCardRamWriteBlock(
                                 hpRoot,
                                 ESGL_Chain_Offset,
                                 (os_bit8 *)&ESGL_Chain_To_Write,
                                 sizeof(SG_Element_t)
                               );

            ESGL_Offset = ESGL_Next_Offset;
        }
        else /* ESGL_memLoc == inDmaMemory */
        {
            ESGL_Next   = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_size);
            ESGL_Chain  = ESGL_Next - 1;

            *ESGL_Chain = ESGL_Chain_To_Write;

            ESGL        = ESGL_Next;
        }

        ESGL_Lower32 = ESGL_Next_Lower32;
    }
}

void ESGLInitializeRequest(
                            ESGL_Request_t *ESGL_Request
                          )
{
    fiListInitElement(
                       &(ESGL_Request->ESGL_Wait_Link)
                     );

    ESGL_Request->num_ESGL      = 0;
    ESGL_Request->offsetToFirst = 0;
    ESGL_Request->State         = ESGL_Request_InActive;
}

void ESGLAlloc(
                agRoot_t       *hpRoot,
                ESGL_Request_t *ESGL_Request
              )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        ESGLAlloc_OnCard(
                          hpRoot,
                          ESGL_Request
                        );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        ESGLAlloc_OffCard(
                           hpRoot,
                           ESGL_Request
                         );
    }
}

void ESGLAlloc_OnCard(
                       agRoot_t       *hpRoot,
                       ESGL_Request_t *ESGL_Request
                     )
{
    CThread_t    *CThread             = CThread_ptr(hpRoot);
    os_bit32         ESGL_deltaToChain   = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32         ESGL_deltaToU32_Len = hpFieldOffset(
                                                       SG_Element_t,
                                                       U32_Len
                                                     );
    os_bit32         ESGL_deltaToL32     = hpFieldOffset(
                                                       SG_Element_t,
                                                       L32
                                                     );
    os_bit32         ESGLs_Needed        = ESGL_Request->num_ESGL;
    os_bit32         ESGL_offset;
    os_bit32         ESGL_Chain = 0;
    os_bit32         cardRamLower32      = CThread->Calculation.Input.cardRamLower32;


    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_InActive) ? agFALSE : agTRUE),
                       "ESGLAlloc_OnCard(): ESGL_Request->State != ESGL_Request_InActive"
                     );

    if ((ESGLs_Needed > CThread->Free_ESGL_count) ||
        (fiListNotEmpty(
                         &(CThread->ESGL_Wait_Link)
                       )))
    {
        ESGL_Request->State = ESGL_Request_Pending;

        fiListEnqueueAtTail(
                             ESGL_Request,
                             &(CThread->ESGL_Wait_Link)
                           );
    }
    else /* (ESGLs_Needed <= CThread->Free_ESGL_count) &&
            (fiListEmpty(
                          &(CThread->ESGL_Wait_Link)
                        )) */
    {
        ESGL_offset = CThread->offsetToFirstFree_ESGL;

        ESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count    -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = ESGL_offset + ESGL_deltaToChain;

            ESGL_offset   = osCardRamReadBit32(
                                                hpRoot,
                                                ESGL_Chain + ESGL_deltaToL32
                                              )
                            - cardRamLower32;

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToU32_Len,
                             0
                           );
        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToL32,
                             0
                           );

        ESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     ESGL_Request->eventRecord_to_send.thread,
                     ESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLAlloc_OffCard(
                        agRoot_t       *hpRoot,
                        ESGL_Request_t *ESGL_Request
                      )
{
    CThread_t    *CThread           = CThread_ptr(hpRoot);
    os_bit32         ESGL_deltaToChain = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32         ESGLs_Needed      = ESGL_Request->num_ESGL;
    os_bit32         ESGL_offset;
    SG_Element_t *ESGL;
    SG_Element_t *ESGL_Chain = (SG_Element_t *)agNULL;
    os_bit32         dmaMemoryLower32  = CThread->Calculation.Input.dmaMemoryLower32;
    void         *dmaMemoryPtr      = CThread->Calculation.Input.dmaMemoryPtr;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_InActive) ? agFALSE : agTRUE),
                       "ESGLAlloc_OffCard(): ESGL_Request->State != ESGL_Request_InActive"
                     );

    if ((ESGLs_Needed > CThread->Free_ESGL_count) ||
        (fiListNotEmpty(
                         &(CThread->ESGL_Wait_Link)
                       )))
    {
        ESGL_Request->State = ESGL_Request_Pending;

        fiListEnqueueAtTail(
                             ESGL_Request,
                             &(CThread->ESGL_Wait_Link)
                           );
    }
    else /* (ESGLs_Needed <= CThread->Free_ESGL_count) &&
            (fiListEmpty(
                          &(CThread->ESGL_Wait_Link)
                        )) */
    {
        ESGL_offset = CThread->offsetToFirstFree_ESGL;
        ESGL        = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        ESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count    -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

            ESGL_offset   = ESGL_Chain->L32 - dmaMemoryLower32;

            ESGL          = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        ESGL_Chain->U32_Len = 0;
        ESGL_Chain->L32     = 0;

        ESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     ESGL_Request->eventRecord_to_send.thread,
                     ESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLAllocCancel(
                      agRoot_t       *hpRoot,
                      ESGL_Request_t *ESGL_Request
                    )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        ESGLAllocCancel_OnCard(
                                hpRoot,
                                ESGL_Request
                              );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        ESGLAllocCancel_OffCard(
                                 hpRoot,
                                 ESGL_Request
                               );
    }
}

void ESGLAllocCancel_OnCard(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           )
{
    CThread_t      *CThread             = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain   = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGL_deltaToU32_Len = hpFieldOffset(
                                                         SG_Element_t,
                                                         U32_Len
                                                       );
    os_bit32           ESGL_deltaToL32     = hpFieldOffset(
                                                         SG_Element_t,
                                                         L32
                                                       );
    os_bit32           ESGL_offset         = ESGL_Request->offsetToFirst;
    os_bit32           ESGL_Chain = 0;
    os_bit32           cardRamLower32      = CThread->Calculation.Input.cardRamLower32;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Pending) ? agFALSE : agTRUE),
                       "ESGLAllocCancel_OnCard(): ESGL_Request->State != ESGL_Request_Pending"
                     );

    fiListDequeueThis(
                       ESGL_Request
                     );

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset = CThread->offsetToFirstFree_ESGL;

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = ESGL_offset + ESGL_deltaToChain;

            ESGL_offset   = osCardRamReadBit32(
                                                hpRoot,
                                                ESGL_Chain + ESGL_deltaToL32
                                              )
                            - cardRamLower32;

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToU32_Len,
                             0
                           );
        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToL32,
                             0
                           );

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLAllocCancel_OffCard(
                              agRoot_t       *hpRoot,
                              ESGL_Request_t *ESGL_Request
                            )
{
    CThread_t      *CThread           = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGL_offset       = ESGL_Request->offsetToFirst;
    SG_Element_t   *ESGL;
    SG_Element_t   *ESGL_Chain = (SG_Element_t   *)agNULL;
    os_bit32           dmaMemoryLower32  = CThread->Calculation.Input.dmaMemoryLower32;
    void           *dmaMemoryPtr      = CThread->Calculation.Input.dmaMemoryPtr;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Pending) ? agFALSE : agTRUE),
                       "ESGLAllocCancel_OffCard(): ESGL_Request->State != ESGL_Request_Pending"
                     );

    fiListDequeueThis(
                       ESGL_Request
                     );

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset  = CThread->offsetToFirstFree_ESGL;
        ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

            ESGL_offset   = ESGL_Chain->L32 - dmaMemoryLower32;

            ESGL          = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        ESGL_Chain->U32_Len = 0;
        ESGL_Chain->L32     = 0;

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLFree(
               agRoot_t       *hpRoot,
               ESGL_Request_t *ESGL_Request
             )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        ESGLFree_OnCard(
                         hpRoot,
                         ESGL_Request
                       );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        ESGLFree_OffCard(
                          hpRoot,
                          ESGL_Request
                        );
    }
}

void ESGLFree_OnCard(
                      agRoot_t       *hpRoot,
                      ESGL_Request_t *ESGL_Request
                    )
{
    CThread_t      *CThread             = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain   = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGL_deltaToU32_Len = hpFieldOffset(
                                                         SG_Element_t,
                                                         U32_Len
                                                       );
    os_bit32           ESGL_deltaToL32     = hpFieldOffset(
                                                         SG_Element_t,
                                                         L32
                                                       );
    os_bit32           ESGLs_Freed         = ESGL_Request->num_ESGL;
    os_bit32           ESGL_offset         = ESGL_Request->offsetToFirst;
    os_bit32           ESGL_Chain = 0;
    os_bit32           cardRamUpper32      = CThread->Calculation.Input.cardRamUpper32;
    os_bit32           cardRamLower32      = CThread->Calculation.Input.cardRamLower32;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Granted) ? agFALSE : agTRUE),
                       "ESGLFree_OnCard(): ESGL_Request->State != ESGL_Request_Granted"
                     );

    CThread->Free_ESGL_count += ESGLs_Freed;

    while (ESGLs_Freed > 0)
    {
        ESGL_Chain   = ESGL_offset + ESGL_deltaToChain;

        ESGL_offset  = osCardRamReadBit32(
                                           hpRoot,
                                           ESGL_Chain + ESGL_deltaToL32
                                         )
                       - cardRamLower32;

        ESGLs_Freed -= 1;
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ESGL_Chain + ESGL_deltaToU32_Len,
                         (~SG_Element_Chain_Res_MASK)
                         & ((cardRamUpper32 << SG_Element_U32_SHIFT)
                            | SG_Element_Len_MASK)
                       );
    osCardRamWriteBit32(
                         hpRoot,
                         ESGL_Chain + ESGL_deltaToL32,
                         CThread->offsetToFirstFree_ESGL + cardRamLower32
                       );

    CThread->offsetToFirstFree_ESGL = ESGL_Request->offsetToFirst;

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset = CThread->offsetToFirstFree_ESGL;

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = ESGL_offset + ESGL_deltaToChain;

            ESGL_offset   = osCardRamReadBit32(
                                                hpRoot,
                                                ESGL_Chain + ESGL_deltaToL32
                                              )
                            - cardRamLower32;

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToU32_Len,
                             0
                           );
        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToL32,
                             0
                           );

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLFree_OffCard(
                       agRoot_t       *hpRoot,
                       ESGL_Request_t *ESGL_Request
                     )
{
    CThread_t      *CThread           = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGLs_Freed       = ESGL_Request->num_ESGL;
    os_bit32           ESGL_offset       = ESGL_Request->offsetToFirst;
    SG_Element_t   *ESGL;
    SG_Element_t   *ESGL_Chain = (SG_Element_t   *)agNULL;
    os_bit32           dmaMemoryUpper32  = CThread->Calculation.Input.dmaMemoryUpper32;
    os_bit32           dmaMemoryLower32  = CThread->Calculation.Input.dmaMemoryLower32;
    void           *dmaMemoryPtr      = CThread->Calculation.Input.dmaMemoryPtr;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Granted) ? agFALSE : agTRUE),
                       "ESGLFree_OffCard(): ESGL_Request->State != ESGL_Request_Granted"
                     );

    CThread->Free_ESGL_count += ESGLs_Freed;

    ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

    while (ESGLs_Freed > 0)
    {
        ESGL_Chain   = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

        ESGL_offset  = ESGL_Chain->L32 - dmaMemoryLower32;

        ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        ESGLs_Freed -= 1;
    }

    ESGL_Chain->U32_Len = (~SG_Element_Chain_Res_MASK)
                          & ((dmaMemoryUpper32 << SG_Element_U32_SHIFT)
                             | SG_Element_Len_MASK);
    ESGL_Chain->L32     = CThread->offsetToFirstFree_ESGL + dmaMemoryLower32;

    CThread->offsetToFirstFree_ESGL = ESGL_Request->offsetToFirst;

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset  = CThread->offsetToFirstFree_ESGL;
        ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

            ESGL_offset   = ESGL_Chain->L32 - dmaMemoryLower32;

            ESGL          = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        ESGL_Chain->U32_Len = 0;
        ESGL_Chain->L32     = 0;

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\readreg.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   readreg.h

Abstract:

Authors:

Environment:

    kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/readreg.h $

Revision History:
   $Revision: 3 $
   $Date: 9/07/00 11:19a $
   $Modtime: 8/31/00 3:26p $

Notes:

--*/

#include "buildop.h"             //LP021100 build switches

#include <stdarg.h>
#include <stdio.h>

#ifndef _READREG_H_
#define _READREG_H_

#ifdef HP_NT50
#define REG_ParametersDevice          "AFCW2K\\Parameters\\Device"
#define REG_Parameters                "AFCW2K\\Parameters"
#else
#ifdef _USE_OLD_NAME_
#define REG_ParametersDevice          "HHBA5100\\Parameters\\Device"
#define REG_Parameters                "HHBA5100\\Parameters"
#else
#define REG_ParametersDevice          "AFCNT4\\Parameters\\Device"
#define REG_Parameters                "AFCNT4\\Parameters"
#endif
#endif

#define REG_PaPathIdWidth        "PaPathIdWidth"
#define REG_VoPathIdWidth        "VoPathIdWidth"
#define REG_LuPathIdWidth        "LuPathIdWidth"
#define REG_LuTargetWidth        "LuTargetWidth"
#define REG_MaximumTids          "MaximumTids"

#ifdef HP_NT50
#define REG_LARGE_LUNS_RELPATH   RTL_REGISTRY_SERVICES
#define REG_LARGE_LUNS_PATH "\\ScsiPort\\SpecialTargetList\\GenDisk"
#else
#define REG_LARGE_LUNS_RELPATH   RTL_REGISTRY_CONTROL
#define REG_LARGE_LUNS_PATH REG_ParametersDevice
#endif


BOOLEAN ReadRegistry(
   ULONG          dataType,
   ULONG          relativeTo,
   char           *name, 
   char      *path,
   ULONG     *dwordOrLen,
   void      *stringData);


void RegGetDword(ULONG cardinstance, IN char *path, IN char *name, ULONG *retData, ULONG min_val, ULONG max_val);


#ifndef osDEBUGPRINT
#if DBG >= 1
#define osDEBUGPRINT(x) osDebugPrintString x
#else
#define osDEBUGPRINT(x)
#endif
#endif

#ifndef ALWAYS_PRINT
#define  ALWAYS_PRINT               0x01000000  // If statement executes always
#endif

#ifndef osDebugPrintString
extern void osDebugPrintString(
                            unsigned int Print_LEVEL,
                            char     *formatString,
                            ...
                            );

#endif  /* ~osDebugPrintString */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\queue.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/Queue.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/18/00 11:32a  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/Queue.C

--*/

#ifndef __Queue_H__
#define __Queue_H__

/*+
Paranoia Setting
-*/

#ifndef __Queue_Paranoia__
#define __Queue_Paranoia__
#endif
#undef  __Queue_Paranoia__

/*+
Queue Macros
-*/

#define fiListInitHdr(hdr)                                  \
          {                                                 \
            ((fiList_t *)(hdr))->flink = (fiList_t *)(hdr); \
            ((fiList_t *)(hdr))->blink = (fiList_t *)(hdr); \
          }

#ifdef __Queue_Paranoia__
#define fiListInitElementFlinkBlinkSentinel (fiList_t *)0x0BAD0BAD

#define fiListInitElement(hdr)                                                \
          {                                                                   \
            ((fiList_t *)(hdr))->flink = fiListInitElementFlinkBlinkSentinel; \
            ((fiList_t *)(hdr))->blink = fiListInitElementFlinkBlinkSentinel; \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListInitElement(hdr)                             \
          {                                                \
            ((fiList_t *)(hdr))->flink = (fiList_t *)agNULL; \
            ((fiList_t *)(hdr))->blink = (fiList_t *)agNULL; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#ifdef __Queue_Paranoia__
#define fiListEnqueueAtHead(toAddHdr,listHdr)                                                                                  \
          {                                                                                                                    \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtHead(): ((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtHead(): ((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            ((fiList_t *)(toAddHdr))->flink       = ((fiList_t *)(listHdr))->flink;                                            \
            ((fiList_t *)(toAddHdr))->blink       =  (fiList_t *)(listHdr);                                                    \
            ((fiList_t *)(listHdr))->flink->blink =  (fiList_t *)(toAddHdr);                                                   \
            ((fiList_t *)(listHdr))->flink        =  (fiList_t *)(toAddHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListEnqueueAtHead(toAddHdr,listHdr)                                       \
          {                                                                         \
            ((fiList_t *)(toAddHdr))->flink       = ((fiList_t *)(listHdr))->flink; \
            ((fiList_t *)(toAddHdr))->blink       =  (fiList_t *)(listHdr);         \
            ((fiList_t *)(listHdr))->flink->blink =  (fiList_t *)(toAddHdr);        \
            ((fiList_t *)(listHdr))->flink        =  (fiList_t *)(toAddHdr);        \
          }
#endif /* __Queue_Paranoia__ was not defined */

#ifdef __Queue_Paranoia__
#define fiListEnqueueAtTail(toAddHdr,listHdr)                                                                                  \
          {                                                                                                                    \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtTail(): ((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtTail(): ((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            ((fiList_t *)(toAddHdr))->flink       =  (fiList_t *)(listHdr);                                                    \
            ((fiList_t *)(toAddHdr))->blink       = ((fiList_t *)(listHdr))->blink;                                            \
            ((fiList_t *)(listHdr))->blink->flink =  (fiList_t *)(toAddHdr);                                                   \
            ((fiList_t *)(listHdr))->blink        =  (fiList_t *)(toAddHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListEnqueueAtTail(toAddHdr,listHdr)                                       \
          {                                                                         \
            ((fiList_t *)(toAddHdr))->flink       =  (fiList_t *)(listHdr);         \
            ((fiList_t *)(toAddHdr))->blink       = ((fiList_t *)(listHdr))->blink; \
            ((fiList_t *)(listHdr))->blink->flink =  (fiList_t *)(toAddHdr);        \
            ((fiList_t *)(listHdr))->blink        =  (fiList_t *)(toAddHdr);        \
          }
#endif /* __Queue_Paranoia__ was not defined */

#define fiListEmpty(hdr) \
          (((fiList_t *)(hdr))->flink == ((fiList_t *)(hdr)))

#define fiListNotEmpty(hdr) \
          (((fiList_t *)(hdr))->flink != ((fiList_t *)(hdr)))

#define fiListEnqueueListAtHeadFast(toAddListHdr,listHdr)                                     \
          {                                                                                   \
            ((fiList_t *)(toAddListHdr))->blink->flink = ((fiList_t *)(listHdr))->flink;      \
            ((fiList_t *)(toAddListHdr))->flink->blink =  (fiList_t *)(listHdr);              \
            ((fiList_t *)(listHdr))->flink->blink      = ((fiList_t *)(toAddListHdr))->blink; \
            ((fiList_t *)(listHdr))->flink             = ((fiList_t *)(toAddListHdr))->flink; \
            fiListInitHdr(toAddListHdr);                                                      \
          }

#define fiListEnqueueListAtHead(toAddListHdr,listHdr)              \
          {                                                        \
            if (fiListNotEmpty(toAddListHdr))                      \
              {                                                    \
                fiListEnqueueListAtHeadFast(toAddListHdr,listHdr); \
              }                                                    \
          }

#define fiListEnqueueListAtTailFast(toAddListHdr,listHdr)                                     \
          {                                                                                   \
            ((fiList_t *)(toAddListHdr))->blink->flink =  (fiList_t *)(listHdr);              \
            ((fiList_t *)(toAddListHdr))->flink->blink = ((fiList_t *)(listHdr))->blink;      \
            ((fiList_t *)(listHdr))->blink->flink      = ((fiList_t *)(toAddListHdr))->flink; \
            ((fiList_t *)(listHdr))->blink             = ((fiList_t *)(toAddListHdr))->blink; \
            fiListInitHdr(toAddListHdr);                                                      \
          }

#define fiListEnqueueListAtTail(toAddListHdr,listHdr)              \
          {                                                        \
            if (fiListNotEmpty(toAddListHdr))                      \
              {                                                    \
                fiListEnqueueListAtTailFast(toAddListHdr,listHdr); \
              }                                                    \
          }

#ifdef __Queue_Paranoia__
#define fiListDequeueThis(hdr) \
          {                                                                 \
            ((fiList_t *)(hdr))->blink->flink = ((fiList_t *)(hdr))->flink; \
            ((fiList_t *)(hdr))->flink->blink = ((fiList_t *)(hdr))->blink; \
            fiListInitElement(hdr);                                         \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListDequeueThis(hdr) \
          {                                                                 \
            ((fiList_t *)(hdr))->blink->flink = ((fiList_t *)(hdr))->flink; \
            ((fiList_t *)(hdr))->flink->blink = ((fiList_t *)(hdr))->blink; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#ifdef __Queue_Paranoia__
#define fiListDequeueFromHeadFast(atHeadHdr,listHdr)                                         \
          {                                                                                  \
              *((fiList_t **)atHeadHdr)                =   ((fiList_t *)listHdr)->flink;     \
             (*((fiList_t **)atHeadHdr))->flink->blink =    (fiList_t *)listHdr;             \
               ((fiList_t  *)listHdr)->flink           = (*((fiList_t **)atHeadHdr))->flink; \
            fiListInitElement(*atHeadHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListDequeueFromHeadFast(atHeadHdr,listHdr)                                         \
          {                                                                                  \
              *((fiList_t **)atHeadHdr)                =   ((fiList_t *)listHdr)->flink;     \
             (*((fiList_t **)atHeadHdr))->flink->blink =    (fiList_t *)listHdr;             \
               ((fiList_t  *)listHdr)->flink           = (*((fiList_t **)atHeadHdr))->flink; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#define fiListDequeueFromHead(atHeadHdr,listHdr)              \
          {                                                   \
            if (fiListNotEmpty(listHdr))                      \
              {                                               \
                fiListDequeueFromHeadFast(atHeadHdr,listHdr); \
              }                                               \
            else                                              \
              {                                               \
                *((fiList_t **)atHeadHdr) = (fiList_t *)agNULL; \
              }                                               \
          }

#ifdef __Queue_Paranoia__
#define fiListDequeueFromTailFast(atTailHdr,listHdr)                                        \
          {                                                                                 \
             *((fiList_t **)atTailHdr)                =   ((fiList_t *)listHdr)->blink;     \
            (*((fiList_t **)atTailHdr))->blink->flink =    (fiList_t *)listHdr;             \
              ((fiList_t  *)listHdr)->blink           = (*((fiList_t **)atTailHdr))->blink; \
            fiListInitElement(*atTailHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListDequeueFromTailFast(atTailHdr,listHdr)                                        \
          {                                                                                 \
             *((fiList_t **)atTailHdr)                =   ((fiList_t *)listHdr)->blink;     \
            (*((fiList_t **)atTailHdr))->blink->flink =    (fiList_t *)listHdr;             \
              ((fiList_t  *)listHdr)->blink           = (*((fiList_t **)atTailHdr))->blink; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#define fiListDequeueFromTail(atTailHdr,listHdr)              \
          {                                                   \
            if (fiListNotEmpty(listHdr))                      \
              {                                               \
                fiListDequeueFromTailFast(atTailHdr,listHdr); \
              }                                               \
            else                                              \
              {                                               \
                *((fiList_t **)atTailHdr) = (fiList_t *)agNULL; \
              }                                               \
          }

/*+
Queue Functions
-*/

osGLOBAL agBOOLEAN fiListElementOnList(
                                    fiList_t *toFindHdr,
                                    fiList_t *listHdr
                                  );

osGLOBAL os_bit32 fiNumElementsOnList(
                                  fiList_t *listHdr
                                );

/*+
ERQ Management
-*/

#define ERQ_Polling_osStallThread_Parameter 20

osGLOBAL void WaitForERQ(
                        agRoot_t *hpRoot
                      );

osGLOBAL void WaitForERQ_ConsIndexOnCard(
                                        agRoot_t *hpRoot
                                      );

osGLOBAL void WaitForERQ_ConsIndexOffCard(
                                         agRoot_t *hpRoot
                                       );

osGLOBAL void WaitForERQEmpty(
                             agRoot_t *hpRoot
                           );

osGLOBAL void WaitForERQEmpty_ConsIndexOnCard(
                                             agRoot_t *hpRoot
                                           );

osGLOBAL void WaitForERQEmpty_ConsIndexOffCard(
                                              agRoot_t *hpRoot
                                            );

#ifdef _DvrArch_1_30_
/*+
PktThread Management
-*/

osGLOBAL void PktThreadsInitializeFreeList(
                                            agRoot_t *agRoot
                                          );

osGLOBAL PktThread_t *PktThreadAlloc(
                                      agRoot_t *agRoot,
                                      DevThread_t *pDevThread
                                    );

osGLOBAL void PktThreadFree(
                             agRoot_t    *agRoot,
                             PktThread_t *PktThread
                           );
#endif /* _DvrArch_1_30_ was defined */

/*+
TgtThread Management
-*/

osGLOBAL void TgtThreadsInitializeFreeList(
                                          agRoot_t *hpRoot
                                        );

osGLOBAL TgtThread_t *TgtThreadAlloc(
                                    agRoot_t *hpRoot
                                  );

osGLOBAL void TgtThreadFree(
                           agRoot_t    *hpRoot,
                           TgtThread_t *TgtThread
                         );

/*+
DevThread Management
-*/

osGLOBAL void DevThreadsInitializeFreeList(
                                          agRoot_t *hpRoot
                                        );

osGLOBAL DevThread_t *DevThreadAlloc(
                                    agRoot_t     *hpRoot,
                                    FC_Port_ID_t  Port_ID
                                  );

osGLOBAL void DevThreadFree(
                           agRoot_t    *hpRoot,
                           DevThread_t *DevThread
                         );

osGLOBAL agBOOLEAN DevThreadMatchWWN( FC_Port_Name_t *WWN_1, FC_Port_Name_t *WWN_2 );

osGLOBAL DevSlot_t DevThreadFindSlot(
                                    agRoot_t       *hpRoot,
                                    os_bit8            Domain_Address,
                                    os_bit8            Area_Address,
                                    os_bit8            Loop_Address,
                                    FC_Port_Name_t *FindWWN
                                  );

osGLOBAL void DevThreadFreeSlot(
                               agRoot_t  *hpRoot,
                               DevSlot_t  DevSlot
                             );

osGLOBAL void DevThreadInitializeSlots(
                                      agRoot_t *hpRoot
                                    );

/*+
CDBThread Management
-*/

osGLOBAL void CDBThreadsInitializeFreeList(
                                          agRoot_t *hpRoot
                                        );

osGLOBAL CDBThread_t *CDBThreadAlloc(
                                    agRoot_t          *hpRoot,
                                    agIORequest_t     *hpIORequest,
                                    agFCDev_t          hpFCDev,
                                    agIORequestBody_t *hpRequestBody
                                  );

osGLOBAL void CDBThreadFree(
                           agRoot_t    *hpRoot,
                           CDBThread_t *CDBThread
                         );

/*+
SFThread Management
-*/

osGLOBAL void SFThreadsInitializeFreeList(
                                         agRoot_t *hpRoot
                                       );

osGLOBAL void SFThreadInitializeRequest(
                                       SFThread_Request_t *SFThread_Request
                                     );

osGLOBAL void SFThreadAlloc(
                           agRoot_t           *hpRoot,
                           SFThread_Request_t *SFThread_Request
                         );

osGLOBAL void SFThreadAllocCancel(
                                 agRoot_t           *hpRoot,
                                 SFThread_Request_t *SFThread_Request
                               );

osGLOBAL void SFThreadFree(
                          agRoot_t           *hpRoot,
                          SFThread_Request_t *SFThread_Request
                        );

/*+
ESGL Management
-*/

osGLOBAL void ESGLInitializeFreeList(
                                    agRoot_t *hpRoot
                                  );

osGLOBAL void ESGLInitializeRequest(
                                   ESGL_Request_t *ESGL_Request
                                 );

osGLOBAL void ESGLAlloc(
                       agRoot_t       *hpRoot,
                       ESGL_Request_t *ESGL_Request
                     );

osGLOBAL void ESGLAlloc_OnCard(
                              agRoot_t       *hpRoot,
                              ESGL_Request_t *ESGL_Request
                            );

osGLOBAL void ESGLAlloc_OffCard(
                               agRoot_t       *hpRoot,
                               ESGL_Request_t *ESGL_Request
                             );

osGLOBAL void ESGLAllocCancel(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           );

osGLOBAL void ESGLAllocCancel_OnCard(
                                    agRoot_t       *hpRoot,
                                    ESGL_Request_t *ESGL_Request
                                  );

osGLOBAL void ESGLAllocCancel_OffCard(
                                     agRoot_t       *hpRoot,
                                     ESGL_Request_t *ESGL_Request
                                   );

osGLOBAL void ESGLFree(
                      agRoot_t       *hpRoot,
                      ESGL_Request_t *ESGL_Request
                    );

osGLOBAL void ESGLFree_OnCard(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           );

osGLOBAL void ESGLFree_OffCard(
                              agRoot_t       *hpRoot,
                              ESGL_Request_t *ESGL_Request
                            );

#endif /* __Queue_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\resetbus.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    ResetBus.c

Abstract:

    This is the reset bus enty point for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/RESETBUS.C $
    
Revision History:

    $Revision: 9 $
    $Date: 10/25/00 10:17a $
    $Modtime:: 10/25/00 10:17a       $

Notes:



--*/

#include "buildop.h"        //LP021100 build switches
#include "osflags.h"
// #include "HPFibre.h"    // includes scsi.h
#ifdef _DEBUG_EVENTLOG_
#include "eventlog.h"
#endif

BOOLEAN
HPFibreResetBus(
    IN PCARD_EXTENSION pCard,
    ULONG PathId)

/*++

Routine Description:

    Reset adapter.

Arguments:

    pCard - HBA miniport driver's adapter data storage
    PathId          - Identifies the bus to be reset.
                      Only > 0 for multi-bus HBA's.

Return Value:

    TRUE  if reset successful
    FALSE if reset unsuccessful

--*/

{
    PLU_EXTENSION plunExtension = NULL;
    ULONG Reset_Status;
    agRoot_t * hpRoot=&pCard->hpRoot;
    
    pCard->inDriver = TRUE;

    while (pCard->inTimer == TRUE)
       // HPFibreTimerTick routine is running. Busy wait until
       // HPFibreTimerTick returns.
       ;

    if ((pCard->flags & OS_IGNORE_NEXT_RESET) && 
       (PathId == (pCard->ResetPathId + 1))) 
    {
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreResetBus: Ignoring... pCard = 0x%x PathId = %d ResetCount = %d @ %d\n", 
           pCard, PathId, pCard->External_ResetCount ,  osTimeStamp(0) ));

        if(PathId == (NUMBER_OF_BUSES - 1)) 
        {
            pCard->flags &= ~OS_IGNORE_NEXT_RESET;
            ScsiPortNotification (RequestTimerCall, pCard,
                         (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
        } 
        else 
        {
            pCard->ResetPathId = PathId;
            ScsiPortNotification (RequestTimerCall, pCard, (PHW_TIMER) ResetTimer, 30000); // 30 ms
        }

    } 
    else 
    {
        pCard->State |= CS_DURING_RESET_ADAPTER;
        pCard->flags &= ~OS_IGNORE_NEXT_RESET;
        pCard->External_ResetCount++;

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreResetBus: pCard = 0x%x PathId = %d ResetCount = %d @ %d\n", 
           pCard, PathId, pCard->External_ResetCount ,  osTimeStamp(0) ));

        pCard->LinkState = LS_LINK_DOWN;
        if (pCard->OldNumDevices == 0)
            pCard->OldNumDevices = pCard->Num_Devices;

        Reset_Status = fcResetDevice (hpRoot, fcResetAllDevs, fcHardReset);

        doPostResetProcessing (pCard);

        if (PathId == 0) 
        {
            pCard->flags |= OS_IGNORE_NEXT_RESET;
            pCard->ResetPathId = PathId;
            ScsiPortNotification (RequestTimerCall, pCard, (PHW_TIMER) ResetTimer, 30000); // 30 ms
        }

        // osZero(&pCard->OutStandingSrbExt[0],sizeof(pCard->OutStandingSrbExt));
        // ScsiPortNotification(NextRequest,pCard,NULL);

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreResetBus: Exiting... pCard = 0x%x Reset_Status = %d @ %d\n", pCard, Reset_Status, osTimeStamp(0) ));

        pCard->State &= ~CS_DURING_RESET_ADAPTER;
    }

    #ifdef _DEBUG_EVENTLOG_
    LogEvent(pCard, NULL, HPFC_MSG_DEV_RESET, NULL, 0, "%d", Reset_Status);
    #endif
   
    pCard->inDriver = FALSE;
    return (Reset_Status == fcResetSuccess);
} // end HPFibreResetBus()

void
ResetTimer (PCARD_EXTENSION pCard)
{
    pCard->flags &= ~OS_IGNORE_NEXT_RESET;

    ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
}

#ifdef DBG
void show_outstanding_IOs(PCARD_EXTENSION pCard)
{
    int Num_outstanding=0;
    PSRB_EXTENSION      pSrbExt=pCard->RootSrbExt;

    while( pSrbExt )
    {
        if(pSrbExt )
        {
            osDEBUGPRINT((ALWAYS_PRINT,"IO %lx lost because of reset SRB %lx DEV %lx Delta T %x %s\n",
                &pSrbExt->hpIORequest,pSrbExt->pSrb,pSrbExt->pLunExt->phandle,osTimeStamp(0)-pSrbExt->SRB_StartTime,
                pSrbExt->SRB_State & RS_TIMEOUT ? "TIMEDOUT" : "Not marked" ));
                Num_outstanding++;
                // display_sest_data(&pSrbExt->hpIORequest );
            display_srbext(&pSrbExt->hpIORequest );
            pSrbExt->SRB_State |= RS_RESET;
        }
        pSrbExt=Get_next_Srbext(pSrbExt);
    }

    osDEBUGPRINT((ALWAYS_PRINT,"Out %x\n",Num_outstanding));
}
#endif

osGLOBAL void osResetChannelCallback(
    agRoot_t *hpRoot,
    os_bit32  hpResetStatus
    )
{
    PCARD_EXTENSION pCard;
    PLU_EXTENSION plunExtension = NULL;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;

    osDEBUGPRINT((ALWAYS_PRINT,"IN osResetChannelCallback Notify scsiport of reset @ %x\n",osTimeStamp(0)));

    osDEBUGPRINT((ALWAYS_PRINT,"OUT osResetChannelCallback OK\n"));

}

void
osFCLayerAsyncEvent (agRoot_t *hpRoot, os_bit32 fcLayerEvent)
{
    PCARD_EXTENSION  pCard = (PCARD_EXTENSION)hpRoot->osData;
    PLU_EXTENSION lunEx;
    UCHAR   path, target, lun;


    #ifdef _DEBUG_EVENTLOG_Testing
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4, NULL, 0, "%s", 
      "123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789-1234567890");

    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L1 ,NULL,0, "Dynamic L1");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L2 ,NULL,0, "Dynamic L2");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L3 ,NULL,0, "Dynamic L3");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4 ,NULL,0, "Dynamic L4");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L5 ,NULL,0, "Dynamic L5");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L6 ,NULL,0, "Dynamic L6");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L7 ,NULL,0, "Dynamic L7");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L8 ,NULL,0, "Dynamic L8");
    #endif

   
    switch (fcLayerEvent) 
    {
        case osFCLinkUp:
            #ifdef _DEBUG_EVENTLOG_
            if (pCard->PrevLinkState != fcLayerEvent)
                LogEvent(pCard, NULL,HPFC_MSG_LOOP_UP,NULL,0, NULL);
            #endif
      
            #ifdef _SAN_IOCTL_
            {
                SAN_EVENTINFO      this;
      
                osZero(&this, sizeof(this) );
                this.EventCode = SAN_EVENT_LINK_UP;
                if (pCard->PrevLinkState != fcLayerEvent)
                SANPutNextBuffer(pCard, &this);
            }
            #endif
            osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: fcLayerEvent = osFCLinkUp\n"));
            pCard->LIPCount++;
            // Reset the flag, since link is up
            pCard->SrbStatusFlag = FALSE;
            // Do link down processing just in case. If every thing is going well
            // doLinkDownProcessing should not do any harm.
            doLinkDownProcessing (pCard);

            GetNodeInfo (pCard);

            if ( (pCard->OldNumDevices == 0) || (pCard->OldNumDevices <= pCard->Num_Devices) ) 
            {
                FixDevHandlesForLinkUp (pCard);
                pCard->LinkState = LS_LINK_UP;
                pCard->flags &= ~OS_DO_SOFT_RESET;

                #if defined(HP_NT50)
                // 
                // Tell SCSIPort to rescan the target device for this HBA.
                //

                if (pCard->OldNumDevices < pCard->Num_Devices)
                {
                    osDEBUGPRINT((ALWAYS_PRINT, "BusChangeDetected notification to SCSIPort.\n"));
                    ScsiPortNotification(BusChangeDetected, pCard, 0);
                }
                #endif         
                pCard->OldNumDevices = 0;
                ScsiPortNotification (NextRequest, pCard, NULL, NULL, NULL);

            } 
            else 
            {
                ClearDevHandleArray (pCard);
                pCard->LinkState = LS_LINK_DOWN;
                if (!(pCard->flags & OS_DO_SOFT_RESET)) 
                {
                    pCard->flags |= OS_DO_SOFT_RESET;
                pCard->LostDevTickCount = LOST_DEV_TICK_COUNT;
                }
                osDEBUGPRINT((ALWAYS_PRINT, ".............................................\n"));
                osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: Channel Reset will be done. OldNumDevices = %d, Num_Devices = %d\n",
                    pCard->OldNumDevices, pCard->Num_Devices));
            }

            break;

        case osFCLinkDown:
        case osFCLinkFalling:
        case osFCLinkRising:
        case osFCLinkDead:
            #ifdef _DEBUG_EVENTLOG_
            if (pCard->PrevLinkState != fcLayerEvent)
            {
                if (fcLayerEvent == osFCLinkDown) 
                    LogEvent(pCard, NULL,HPFC_MSG_LOOP_DOWN,NULL,0, "");
                else
                    if (fcLayerEvent == osFCLinkDead) 
                        LogEvent(pCard, NULL,HPFC_MSG_LOOP_DEAD, NULL,0, "");
            }
            #endif   

            #ifdef _SAN_IOCTL_
            {
                SAN_EVENTINFO      this;
      
                osZero(&this, sizeof(this) );
                this.EventCode = SAN_EVENT_LINK_DOWN;
                if (pCard->PrevLinkState != fcLayerEvent)
                    SANPutNextBuffer(pCard, &this);
            }
            #endif
      
            pCard->LinkState = LS_LINK_DOWN;
            osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: fcLayerEvent = osFCLinkDown\n"));
            doLinkDownProcessing (pCard);
            break;

        default:
            osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: fcLayerEvent = %d - default\n", fcLayerEvent));
            break;
    }
    #ifdef _DEBUG_EVENTLOG_ 
    pCard->PrevLinkState = fcLayerEvent;
    #endif
}

void
doLinkDownProcessing (PCARD_EXTENSION pCard)
{
    PLU_EXTENSION   pLunExt;

    FixDevHandlesForLinkDown (pCard);

    if (pCard->OldNumDevices == 0)
        pCard->OldNumDevices = pCard->Num_Devices;

    ClearDevHandleArray (pCard);
    #ifdef YAM2_1
    SetPaDeviceTable(pCard, ALL_DEVICE, PA_DEVICE_GONEAWAY);
    #endif
}

void
ClearDevHandleArray (PCARD_EXTENSION pCard)
{
    ULONG     x;

    pCard->Num_Devices = 0;
    pCard->cardHandleIndex = -1;

    #ifndef YAM2_1
    for(x=0; x < MAX_FC_DEVICES; x++)
    {
    #else
    for(x=0; x < gMaxPaDevices; x++)
    {
    #endif
        pCard->hpFCDev[x] = NULL;
        pCard->nodeInfo[x].DeviceType = agDevUnknown;
    }
}

void
doPostResetProcessing (PCARD_EXTENSION pCard)
{
    completeRequests (pCard, SP_UNTAGGED, SP_UNTAGGED, SRB_STATUS_BUS_RESET);

//--LP101000   pCard->TimedOutIO=0;
    pCard->State &= ~CS_FCLAYER_LOST_IO;
    pCard->RootSrbExt = NULL;
    pCard->AdapterQ.Head = NULL;
    pCard->AdapterQ.Tail = NULL;

    GetNodeInfo (pCard);

    if (pCard->OldNumDevices == 0 || pCard->OldNumDevices <= pCard->Num_Devices) 
    {
        if (pCard->LinkState != LS_LINK_UP) 
        {
            ScsiPortNotification (NextRequest, pCard, NULL, NULL, NULL);
            pCard->LinkState = LS_LINK_UP;
            pCard->flags &= ~OS_DO_SOFT_RESET;
            pCard->OldNumDevices = 0;
        }
    } 
    else 
    {
        ClearDevHandleArray (pCard);
        pCard->LinkState = LS_LINK_DOWN;
        if (!(pCard->flags & OS_DO_SOFT_RESET)) 
        {
            pCard->flags |= OS_DO_SOFT_RESET;
            pCard->LostDevTickCount = LOST_DEV_TICK_COUNT;
        }
        osDEBUGPRINT((ALWAYS_PRINT, ".............................................\n"));
        osDEBUGPRINT((ALWAYS_PRINT, "doPostResetProcessing: Channel Reset will be done. OldNumDevices = %d, Num_Devices = %d\n",
                pCard->OldNumDevices, pCard->Num_Devices));
    }
}

void
completeRequests (
    IN PCARD_EXTENSION pCard,
    UCHAR PId,
    UCHAR TId,
    UCHAR compStatus)
{
    UCHAR PathId;
    UCHAR TargId;
    UCHAR Cur_Lun;
    PLU_EXTENSION plunExtension = NULL;
    agFCDev_t devPidTid, devPathidTargid;
    agRoot_t *hpRoot = &pCard->hpRoot;
    PSCSI_REQUEST_BLOCK pSrb;
    int completeAll;
    #ifdef YAM2_1
    DEVICE_MAP  *devmap;
    CHAR        addrmode;
    USHORT      paIndex;
    #endif

    devPidTid = devPathidTargid = NULL;
    if (PId == SP_UNTAGGED && TId == SP_UNTAGGED)
        completeAll = TRUE;
    else 
    {
        completeAll = FALSE;
        devPidTid = MapToHandle(pCard, PId, TId, 0, NULL);
        if (devPidTid == NULL)
        {
            osDEBUGPRINT ((ALWAYS_PRINT," [CompleteRequests] devPidTid ==NULL\n"));
            return;
        }
    }

    if (completeAll) 
    {
        CompleteQueuedRequests (pCard, NULL, compStatus);
#ifdef NONONO
        ScsiPortCompleteRequest(pCard,
                            PId,
                            TId,
                            SP_UNTAGGED,
                            compStatus);
#endif
    } 
    else
        CompleteQueuedRequests (pCard, devPidTid, compStatus);
    

    osDEBUGPRINT((DMOD,"Reinit plunExtensions\n"));

    for( PathId = 0; PathId < NUMBER_OF_BUSES; PathId++ )
    {
        #ifndef YAM2_1
        for( TargId = 0; TargId < MAXIMUM_TID; TargId++)
        { 
        #else
        for( TargId = 0; TargId < gMaximumTargetIDs; TargId++)
        {
        #endif
            #ifndef YAM2_1
            for( Cur_Lun = 0; Cur_Lun < gMaximumLuns; Cur_Lun++)
            {
            #else
            devmap = GetDeviceMapping(pCard, PathId, TargId, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
            for( Cur_Lun = 0; Cur_Lun < devmap->Com.MaxLuns+1; Cur_Lun++)
            {
            #endif
                devPathidTargid = MapToHandle(pCard, PathId, TargId, Cur_Lun, NULL);
                if (completeAll || (devPidTid == devPathidTargid)) 
                {
                    if (completeAll == FALSE) 
                    {
                    osDEBUGPRINT ((ALWAYS_PRINT," [CompleteRequests] completeAll False Doing ScsiportCompletion\n"));

#ifdef NONONO
                    ScsiPortCompleteRequest(pCard,
                            PathId,
                            TargId,
                            SP_UNTAGGED,
                            compStatus);
#endif
                    }

                    plunExtension = ScsiPortGetLogicalUnit(pCard,
                                                           PathId,
                                                           TargId,
                                                           Cur_Lun
                                                           );
                    if( plunExtension != NULL)
                    {
                        osDEBUGPRINT((DMOD,"plunExtension %lx OK\n",plunExtension));
                        plunExtension->OutstandingIOs = 0;
                        plunExtension->phandle = NULL;
                    }
                }
            }
        }
    }
}

//
// Complete the queued SRB requests on pCard->RootSrb queue with the given compStatus.
// If devHandle is null then complete all the queued SRB requests.
// If devHandle is non-null then complete only those queued SRB requests that 
// belong to the devHandle.
//
void
CompleteQueuedRequests (PCARD_EXTENSION pCard, agFCDev_t devHandle, UCHAR compStatus)
{
    if(!pCard)
    {
        osDEBUGPRINT ((ALWAYS_PRINT, "[CompleteQueuedRequests] pCard = 0x%x devHandle = 0x%x compStatus = 0x%x\n", pCard, devHandle, compStatus));
    }

    if (devHandle == NULL) 
    {
        CompleteQueue (pCard, &pCard->RetryQ, 0, NULL, compStatus);
        CompleteQueue (pCard, &pCard->AdapterQ, 0, NULL, compStatus);
    } 
    else 
    {
        CompleteQueue (pCard, &pCard->RetryQ, 1, devHandle, compStatus);
        CompleteQueue (pCard, &pCard->AdapterQ, 1, devHandle, compStatus);
    }
}

void
FixDevHandlesForLinkDown (PCARD_EXTENSION pCard)
{
    UCHAR   p, t, l;
    PLU_EXTENSION pLunExt;
    #ifdef YAM2_1
    DEVICE_MAP  *devmap;
    CHAR        addrmode;
    USHORT      paIndex;
    #endif


    for (p = 0; p < NUMBER_OF_BUSES; p++ ) 
    {
        #ifndef YAM2_1
        for (t = 0; t < MAXIMUM_TID; t++) 
        {
        #else
        for (t = 0; t < gMaximumTargetIDs; t++) 
        {
        #endif
   
            #ifndef YAM2_1 
            for (l = 0; l < gMaximumLuns; l++) 
            {
            #else
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; l < devmap->Com.MaxLuns+1; l++) 
            {
            #endif
                pLunExt = ScsiPortGetLogicalUnit (pCard, p, t, l);

                if (pLunExt != NULL) 
                {
                    pLunExt->phandle = NULL;
                }
            }
        }
    }
}

void
FixDevHandlesForLinkUp (PCARD_EXTENSION pCard)
{
    UCHAR   p, t, l;
    PLU_EXTENSION pLunExt;
    #ifdef YAM2_1
    DEVICE_MAP  *devmap;
    CHAR        addrmode;
    USHORT      paIndex;
    #endif



    for (p = 0; p < NUMBER_OF_BUSES; p++ ) 
    {
        #ifndef YAM2_1
        for (t = 0; t < MAXIMUM_TID; t++) 
        {
        #else
        for (t = 0; t < gMaximumTargetIDs; t++) 
        {
        #endif

            #ifndef YAM2_1 
            for (l = 0; l < gMaximumLuns ; l++) 
            {
            #else
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; l < devmap->Com.MaxLuns+1; l++) 
            {
            #endif
                pLunExt = ScsiPortGetLogicalUnit (pCard, p, t, l);

                if (pLunExt != NULL)
//--LP101900 bug with missing EMC                    pLunExt->phandle = MapToHandle (pCard, p, t, l, pLunExt);
                    pLunExt->phandle = MapToHandle (pCard, p, t, l, NULL);
            }
        }
    }

    // Device may have disappeared after link up. Complete the SRBs
    // of missing devices.

    CompleteQueue (pCard, &pCard->RetryQ, 1, NULL, SRB_STATUS_SELECTION_TIMEOUT);
    CompleteQueue (pCard, &pCard->AdapterQ, 1, NULL, SRB_STATUS_SELECTION_TIMEOUT);
}

//
// Complete SRBs on the given queue with the given compStatus.
// If param == 0 then complete all the SRBs on the queue
// If param == non-zero then complete only the SRBs with the given devHandle
//
void
CompleteQueue (
    PCARD_EXTENSION pCard, 
    OSL_QUEUE *queue, 
    int param, 
    agFCDev_t devHandle, 
    UCHAR compStatus)
{
    PSCSI_REQUEST_BLOCK pSrb = queue->Head;
    PSRB_EXTENSION      pSrbExt;
    PLU_EXTENSION       pLunExt;
    PSCSI_REQUEST_BLOCK prevSrb = NULL;
    PSCSI_REQUEST_BLOCK temp_Srb;
    ULONG                paDeviceIndex = 0;
   
   
    osDEBUGPRINT ((ALWAYS_PRINT," [CompleteQueue] pCard=%x Q=%x Param=%d devHandle=%x sta=%x Srb=%x\n",
         pCard, 
         queue, 
         param, 
         devHandle, 
         compStatus,
         pSrb));


    while (pSrb != NULL) 
    {
        pSrbExt = (PSRB_EXTENSION)(pSrb->SrbExtension);
        pLunExt = pSrbExt->pLunExt;

        // ADPTFIX
        //
        // With Compaq style hot plug PCI, if heavy I/O activity a device
        // behind an adapter that is powered off then powered on pLunExt
        // occasionally is NULL.
        //
        // if (param == 0 || pLunExt->phandle == devHandle) 
        // {
        //
        if (param == 0 || ((pLunExt) && (pLunExt->phandle == devHandle))) 
        {
            pSrb->SrbStatus = compStatus;
            pSrb->ScsiStatus = 0;
            pLunExt->OutstandingIOs--;

            if (queue->Head == pSrb)
                queue->Head = pSrbExt->pNextSrb;
            else
                ((PSRB_EXTENSION)(prevSrb->SrbExtension))->pNextSrb = pSrbExt->pNextSrb;

            if (queue->Tail == pSrb)
                queue->Tail = prevSrb;

            #ifdef YAM2_1
            paDeviceIndex =  pLunExt->PaDeviceIndex;
            #endif

            // EBUGPRINT ((ALWAYS_PRINT, "[CompleteQueue] Completing Srb = 0x%x SrbStatus = 0x%x\n", pSrb, compStatus));
            osDEBUGPRINT((ALWAYS_PRINT, " [CompleteQueue] %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x FCP0 %02x%02x PAIx=%d FCHndl=%08x\n",
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                        pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9],          
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[0],
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[1],
                        paDeviceIndex, 
                        pSrbExt->pLunExt->phandle 
                        ));

            temp_Srb = pSrb;
            
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_DONE )
            {
                static   count;
                UCHAR    *uptr;
                osDEBUGPRINT((ALWAYS_PRINT, " CplQ(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
                  count++,
                  pSrb->PathId,
                  pSrb->TargetId,
                  pSrb->Lun,
                  pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                  pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
                  pSrb,
                  ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
                  queue->Head,
                  queue->Tail
                  ));
            }
            #endif   
            if (prevSrb == NULL)
                pSrb = queue->Head;
            else
                pSrb = ((PSRB_EXTENSION)(prevSrb->SrbExtension))->pNextSrb;
            ASSERT(pSrb == temp_Srb);

            ScsiPortNotification (RequestComplete, pCard, temp_Srb);

        } 
        else 
        {
            prevSrb = pSrb;
            pSrb = pSrbExt->pNextSrb;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sanioctl.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    sanioctl.c

Abstract:

    Contains routines for SAN IOTCL handler


Author:

    Leopold Purwadihardja

Revision History:

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/sanioctl.c $
    
Revision History:

    $Revision: 13 $
    $Date: 11/10/00 5:51p $
    $Modtime:: $

--*/

#include "buildop.h"        //LP021100 build switches

#include "osflags.h"
#include "sanioctl.h"
#include "hhba5100.ver"
#include "tlstruct.h"
//#include <stdio.h>

#ifdef _SAN_IOCTL_

/* 
 * SANGetNextBuffer()
 *   return the unread SAN event buffer.  
 */
SAN_EVENTINFO *SANGetNextBuffer(
    IN PCARD_EXTENSION pCard)
{
    SAN_EVENTINFO  *this=NULL;
   
    if (pCard->SanEvent_UngetCount > 0)                      /* check the counter */
    {
        pCard->SanEvent_UngetCount --;                        /* get one off */
        this = &pCard->SanEvents[pCard->SanEvent_GetIndex];   /* get the event buffer */
        pCard->SanEvent_GetIndex++;                           /* increment index */
        if (pCard->SanEvent_GetIndex > (MAX_FC_EVENTS-1) )    /* make sure it doesn't wrap around */
            pCard->SanEvent_GetIndex = 0;
    }
    return this;
}


/*
 * SANPutNextBuffer()
 *  - add a new entry into the circular buffer. 
 */
void SANPutNextBuffer(
    IN PCARD_EXTENSION pCard,
    SAN_EVENTINFO      *this)
{
    /* get the next buffer and return it to the caller */
    osCopy (&pCard->SanEvents[pCard->SanEvent_PutIndex], this, sizeof(*this) );   
   
    pCard->SanEvent_PutIndex ++;                          /* increment the index */
    if (pCard->SanEvent_PutIndex > (MAX_FC_EVENTS-1) )    /* make sure it doesn't wrap around*/
        pCard->SanEvent_PutIndex = 0;
   
    /* handle case where put operation coms faster than get operation */
    if (pCard->SanEvent_UngetCount < MAX_FC_EVENTS)       
    {
        pCard->SanEvent_UngetCount ++;                     /* if within limit, increment the # of items */
    }
    else
    {
        pCard->SanEvent_GetIndex = pCard->SanEvent_PutIndex;     /* buffer wrapped around, move the get pointer too */
    }
    return;   
}


ULONG SANGetPortAttributes(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL         srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_DISCOVERED_PORTATTRIBUTES   *data = (AG_DISCOVERED_PORTATTRIBUTES *)Srb->DataBuffer;
    ULONG                   paDevIndex, fcDevIndex;
    agFCDevInfo_t           devinfo;
    agRoot_t                *hpRoot = &pCard->hpRoot;
    PA_DEVICE               *dev;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortAttributes : port index %d\n", data->Com.DiscoveredPortIndex));
   
    paDevIndex = data->Com.DiscoveredPortIndex;
   
    if ( paDevIndex < gMaxPaDevices)
    {
        dev = pCard->Dev->PaDevice + paDevIndex;   
        fcDevIndex = dev->Index.Pa.FcDeviceIndex;
        if ( fcDevIndex != PA_DEVICE_NO_ENTRY) 
        {
            if  (pCard->hpFCDev[fcDevIndex]) 
            {
            fcGetDeviceInfo (hpRoot, pCard->hpFCDev[fcDevIndex], &devinfo );
      
            osCopy(data->Com.PortAttributes.NodeWWN.wwn, devinfo.NodeWWN, 8); 
            osCopy(data->Com.PortAttributes.PortWWN.wwn, devinfo.PortWWN, 8);
   
            data->Com.PortAttributes.PortFcId  =   ((ULONG)devinfo.CurrentAddress.reserved << 24 )|
                              ((ULONG)devinfo.CurrentAddress.Domain   << 16 )|
                              ((ULONG)devinfo.CurrentAddress.Area     << 8  )|
                              (ULONG)devinfo.CurrentAddress.AL_PA ;
            data->Com.PortAttributes.PortType = devinfo.PortType;      /*PTP, Fabric, etc. */
            data->Com.PortAttributes.PortState = devinfo.PortState;
            data->Com.PortAttributes.PortSupportedClassofService = devinfo.PortSupportedClassofService;
         
            osCopy(&data->Com.PortAttributes.PortSupportedFc4Types, devinfo.PortSupportedFc4Types, sizeof(HBA_FC4TYPES) );
            osCopy(&data->Com.PortAttributes.PortActiveFc4Types, devinfo.PortActiveFc4Types, sizeof(HBA_FC4TYPES) );
            C_strcpy(data->Com.PortAttributes.PortSymbolicName, "");      /* I don't know what it is */
            C_strcpy(data->Com.PortAttributes.OSDeviceName, "");          /* I don't know what it is */
            data->Com.PortAttributes.PortSupportedSpeed = devinfo.PortSupportedSpeed;
            data->Com.PortAttributes.PortSpeed = devinfo.PortSpeed; 
            data->Com.PortAttributes.PortMaxFrameSize = devinfo.MaxFrameSize;
            osCopy(data->Com.PortAttributes.FabricName.wwn, devinfo.FabricName, sizeof(data->Com.PortAttributes.FabricName) );
    //raghu should change here...
            //data->Com.PortAttributes.NumberofDiscoveredPorts = paDevIndex;
            data->Com.PortAttributes.NumberofDiscoveredPorts = 0;
            }
             
        }
        else
        {
            osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortAttributes : No FC handle \n"));
            srbIoCtl->ReturnCode = HP_FC_RTN_INVALID_DEVICE;
        }
    }
    else
    {
        osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortAttributes : PA Index > MAX \n"));
        srbIoCtl->ReturnCode = HP_FC_RTN_INVALID_DEVICE;
    }
      
    return 0;
   
}

ULONG SANGetHBAPortAttributes(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL         srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_PORTATTRIBUTES   *data = (AG_HBA_PORTATTRIBUTES *)Srb->DataBuffer;
    agFCChanInfo_t          chanInfo;
    ULONG                   x;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetHBAPortAttributes \n"));
   
    fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
    
    osCopy(data->Com.NodeWWN.wwn, chanInfo.NodeWWN, 8); 
    osCopy(data->Com.PortWWN.wwn, chanInfo.PortWWN, 8);
    
    data->Com.PortFcId  = ((ULONG)chanInfo.CurrentAddress.reserved << 24 )|
                         ((ULONG)chanInfo.CurrentAddress.Domain   << 16 )|
                         ((ULONG)chanInfo.CurrentAddress.Area     << 8  )|
                         (ULONG)chanInfo.CurrentAddress.AL_PA ;
    data->Com.PortType = chanInfo.PortType;      /*PTP, Fabric, etc. */
    data->Com.PortState = chanInfo.PortState;
    data->Com.PortSupportedClassofService = chanInfo.PortSupportedClassofService;
   
    osCopy(&data->Com.PortSupportedFc4Types, chanInfo.PortSupportedFc4Types, sizeof(HBA_FC4TYPES) );
    osCopy(&data->Com.PortActiveFc4Types, chanInfo.PortActiveFc4Types, sizeof(HBA_FC4TYPES) );
    C_strcpy(data->Com.PortSymbolicName, "");      /* I don't know what it is */
    C_strcpy(data->Com.OSDeviceName, "");          /* I don't know what it is */
    data->Com.PortSupportedSpeed = chanInfo.PortSupportedSpeed;
    data->Com.PortSpeed = chanInfo.PortSpeed; 
    data->Com.PortMaxFrameSize = chanInfo.MaxFrameSize;
    osCopy(data->Com.FabricName.wwn, chanInfo.FabricName, sizeof(data->Com.FabricName) );
    data->Com.NumberofDiscoveredPorts = 0;
   
    for (x = 0; x < gMaxPaDevices;x++)
    {
        if ( pCard->Dev->PaDevice[x].Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY) 
        {
         if (pCard->hpFCDev[pCard->Dev->PaDevice[x].Index.Pa.FcDeviceIndex]) 
            data->Com.NumberofDiscoveredPorts++;
        }
    }
   
    return 0;
   
}


ULONG SANGetPortStatistics(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL         srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_PORTSTATISTICS  *data = (AG_HBA_PORTSTATISTICS*) Srb->DataBuffer;
    agFCChanInfo_t          chanInfo;
    
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortStatistics\n"));
   
    fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
   
    data->Com.SecondsSinceLastReset = 0;
    data->Com.TxFrames         = (((_int64)chanInfo.TxFramesUpper)<<32)  | chanInfo.TxFramesLower;
    data->Com.TxWords          = (((_int64)chanInfo.TxWordsUpper)<<32)   | chanInfo.TxWordsLower;
    data->Com.RxFrames         = (((_int64)chanInfo.RxFramesUpper)<<32)  | chanInfo.RxFramesLower;
    data->Com.RxWords          = (((_int64)chanInfo.RxWordsUpper)<<32)   | chanInfo.RxWordsLower;
    data->Com.LIPCount         = (((_int64)chanInfo.LIPCountUpper)<<32)  | chanInfo.LIPCountLower;
    data->Com.NOSCount         = (((_int64)chanInfo.NOSCountUpper)<<32)  | chanInfo.NOSCountLower;
    data->Com.ErrorFrames      = (((_int64)chanInfo.ErrorFramesUpper)<<32)  | chanInfo.ErrorFramesLower;
    data->Com.DumpedFrames     = (((_int64)chanInfo.DumpedFramesUpper)<<32)  | chanInfo.DumpedFramesLower;
    data->Com.LinkFailureCount = (((_int64)chanInfo.LinkFailureCountUpper)<<32)  | chanInfo.LinkFailureCountLower;
    data->Com.LossOfSyncCount  = (((_int64)chanInfo.LossOfSyncCountUpper)<<32)  | chanInfo.LossOfSyncCountLower;
    data->Com.LossOfSignalCount= (((_int64)chanInfo.LossOfSignalCountUpper)<<32)  | chanInfo.LossOfSignalCountLower;
    data->Com.PrimitiveSeqProtocolErrCount= (((_int64)chanInfo.PrimitiveSeqProtocolErrCountUpper)<<32)  | chanInfo.PrimitiveSeqProtocolErrCountLower;
    data->Com.InvalidTxWordCount= (((_int64)chanInfo.InvalidRxWordCountUpper)<<32)  | chanInfo.InvalidRxWordCountLower;
    data->Com.InvalidCRCCount  = (((_int64)chanInfo.InvalidCRCCountUpper)<<32)  | chanInfo.InvalidCRCCountLower;
    
    return 0;
   
}

typedef struct _ADAPTER_MODEL
{
    WCHAR    DID;
    WCHAR    VID;
    WCHAR    SSID;
    WCHAR    SVID;
    UCHAR    Model[64];
    UCHAR    ModelDescription[64];
}  ADAPTER_MODEL;


ADAPTER_MODEL  agModels[] = 
    {
    {0x1028,0,0,0,"HHBA-510x","Agilent HHBA-510x (Tachyon TL)"},
    {0x102a,0,0,0,"HHBA-512x","Agilent HHBA-512x (Tachyon TS)"},
    {0x1029,0,0,0,"HHBA-522x","Agilent HHBA-522x (Tachyon XL2)"},
    {0,0,0,0,"",""}
    };

ADAPTER_MODEL *GetAdapterModel(ULONG devid)
{
    ADAPTER_MODEL *this = agModels;
   
    while(this->DID)
    {
        if (this->DID == (WCHAR)devid)
            return this;
        this++;
    }
   
    return NULL;
}


ULONG SANGetHBAAttributes(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{   
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_ADAPTERATTRIBUTES   *data = (AG_HBA_ADAPTERATTRIBUTES*) Srb->DataBuffer;
    agFCChanInfo_t             chanInfo;
    ChipConfig_t               *pciConfig;
    ADAPTER_MODEL              *model;
    ULONG DEVID_VENDID;
    ULONG VENDID;
    ULONG DEVID;
    ULONG REVID;
    ULONG SVID;
    ULONG MAJOR_REVID;
    ULONG MINOR_REVID;

    osDEBUGPRINT((ALWAYS_PRINT,"SANGetHBAAttributes \n"));
   
    pciConfig = (ChipConfig_t*)pCard->pciConfigData;
   
    fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
 
    C_strcpy(data->Com.Manufacturer, VER_COMPANYNAME_STR);
    C_sprintf(data->Com.SerialNumber, "%02x%02x%02x%02x%02x%02x%02x%02x", 
       chanInfo.NodeWWN[0], chanInfo.NodeWWN[1],
       chanInfo.NodeWWN[2], chanInfo.NodeWWN[3],
       chanInfo.NodeWWN[4], chanInfo.NodeWWN[5],
       chanInfo.NodeWWN[6], chanInfo.NodeWWN[7]);
   
    DEVID_VENDID = pciConfig->DEVID_VENDID;
    VENDID       = DEVID_VENDID & ChipConfig_VENDID_MASK;
    DEVID        = DEVID_VENDID & ChipConfig_DEVID_MASK;
    REVID        = pciConfig->CLSCODE_REVID & ChipConfig_REVID_Major_Minor_MASK;
    MAJOR_REVID  = (REVID & ChipConfig_REVID_Major_MASK) >> ChipConfig_REVID_Major_MASK_Shift;
    MINOR_REVID  = REVID & ChipConfig_REVID_Minor_MASK;
    SVID         = pciConfig->SVID;
    DEVID        = DEVID >> 16;
      
   
    model = GetAdapterModel(DEVID);
    if (model)
    {
        C_strcpy(data->Com.Model, model->Model);
        C_strcpy(data->Com.ModelDescription, model->ModelDescription);
    }
    else
    {
        C_strcpy(data->Com.Model, "Unknown");
        C_strcpy(data->Com.ModelDescription, "unknown");
    }     
      
    osCopy(data->Com.NodeWWN.wwn, chanInfo.NodeWWN, 8); 
    C_strcpy(data->Com.NodeSymbolicName, "");
    C_sprintf(data->Com.HardwareVersion, "%d.%d", MAJOR_REVID, MINOR_REVID);
    C_strcpy(data->Com.DriverVersion,  DRIVER_VERSION_STR);
    C_strcpy(data->Com.OptionROMVersion, "");
    C_strcpy(data->Com.FirmwareVersion, "");
    data->Com.VendorSpecificID = SVID;
    data->Com.NumberOfPorts = 1;
    C_strcpy(data->Com.DriverName, DRIVER_NAME);
   
//   *status = 0;
   
    return 0;
}


ULONG SANGetFCPLunMappingSize(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_FCPTARGETMAPPING_SIZE   *data = (AG_FCPTARGETMAPPING_SIZE*) Srb->DataBuffer;
    UCHAR                      p, t, l;
    PLU_EXTENSION              pLunExt;
    DEVICE_MAP                 *devmap;
    CHAR                       addrmode;
    USHORT                     paIndex;
    ULONG                      count = 0;
    
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetLunMappingSize\n"));
   
    for (p = 0; p < NUMBER_OF_BUSES; p++ ) 
    {
        for (t = 0; t < gMaximumTargetIDs; t++) 
        {
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; l < devmap->Com.MaxLuns+1; l++) 
            {
                pLunExt = ScsiPortGetLogicalUnit (pCard, p, t, l);

                if (pLunExt != NULL) 
                {
                    count++;
                }
            }
        }
    }

   
    data->Com.TotalLunMappings = count;
    data->Com.SizeInBytes = sizeof (AG_HBA_FCPTARGETMAPPING) + count*sizeof(HBA_FCPBINDINGENTRY);
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetLunMappingSize: TotalLunMappings=%d  SizeInBytes=%d\n", 
       data->Com.TotalLunMappings, data->Com.SizeInBytes));
   
    return 0;
}

ULONG GetOSToFcpMapping(
    IN PCARD_EXTENSION pCard,
    HBA_FCPSCSIENTRY *fcpEntry, 
    UCHAR PathId, 
    UCHAR TargetId, 
    UCHAR Lun)
{
    PLU_EXTENSION           pLunExt;
    agFCDevInfo_t           devinfo;
    ULONG                   paDevIndex, fcDevIndex;
    LUN                     tempLun;                        /* added for FCP Lun data */
    PLUN                    ptempLun = &tempLun;
    ULONG                   status = -1;
    PA_DEVICE               *dev;
    
   
    pLunExt = ScsiPortGetLogicalUnit (pCard, PathId, TargetId, Lun);

    if (pLunExt != NULL) 
    {
        osZero( (void *)&tempLun, sizeof(tempLun));

        paDevIndex = pLunExt->PaDeviceIndex;
       
        if ( paDevIndex < gMaxPaDevices) 
        {
            dev = pCard->Dev->PaDevice + paDevIndex;   
            fcDevIndex = dev->Index.Pa.FcDeviceIndex;
            if ( fcDevIndex != PA_DEVICE_NO_ENTRY) 
            {
                fcGetDeviceInfo (&pCard->hpRoot, pCard->hpFCDev[fcDevIndex], &devinfo );
         
                if (devinfo.PortState == HBA_PORTSTATE_ONLINE)
                {
                    /* Fill HBA_FCPID data */
                    fcpEntry->FcpId.FcId  = 
                        ((ULONG)devinfo.CurrentAddress.reserved << 24 )|
                        ((ULONG)devinfo.CurrentAddress.Domain   << 16 )|
                        ((ULONG)devinfo.CurrentAddress.Area     << 8  )|
                        (ULONG)devinfo.CurrentAddress.AL_PA ;
                         
                osCopy (fcpEntry->FcpId.NodeWWN.wwn, devinfo.NodeWWN, sizeof(fcpEntry->FcpId.NodeWWN.wwn));
                osCopy (fcpEntry->FcpId.PortWWN.wwn, devinfo.PortWWN, sizeof(fcpEntry->FcpId.PortWWN.wwn));
         
                switch(pLunExt->Mode)
                {
                    case PA_DEVICE_TRY_MODE_VS:
                        SET_VS_LUN(ptempLun, PathId, TargetId, Lun)
                        break;
            
                    case PA_DEVICE_TRY_MODE_LU:
                        SET_LU_LUN(ptempLun, PathId, TargetId, Lun)
                        break;
            
                    case PA_DEVICE_TRY_MODE_PA:
                        SET_PA_LUN(ptempLun, PathId, TargetId, Lun)
                        break;
                } // end switch
         
                osCopy(&fcpEntry->FcpId.FcpLun, ptempLun, sizeof(fcpEntry->FcpId.FcpLun) );
         
                /* Fill HBA_SCSIID data */
         
                C_strcpy (fcpEntry->ScsiId.OSDeviceName, "");
                fcpEntry->ScsiId.ScsiBusNumber      = (ULONG) PathId;
                fcpEntry->ScsiId.ScsiTargetNumber   = (ULONG) TargetId;
                fcpEntry->ScsiId.ScsiOSLun          = (ULONG) Lun;
         
                status = 0;
                }
            }
            else
            {
                osDEBUGPRINT((ALWAYS_PRINT,"GetOsToFcpMapping: No FC handle \n"));
            }
        }
        else
        {  
            osDEBUGPRINT((ALWAYS_PRINT,"GetOsToFcpMapping : PA Index > MAX \n"));
        }
    }
    return status;
}

ULONG SANGetFCPLunMapping(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_FCPTARGETMAPPING   *data = (AG_HBA_FCPTARGETMAPPING*) Srb->DataBuffer;
    UCHAR                      p, t, l;
    DEVICE_MAP                 *devmap;
    CHAR                       addrmode;
    USHORT                     paIndex;
    LONG                       count=0, reqCount;
    ULONG                      done = FALSE;
    HBA_FCPSCSIENTRY           *fcpEntry = data->Com.entry;

   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetFCPLunMapping: req:%d entries\n", data->Com.NumberOfEntries));
    
    reqCount = (LONG) data->Com.NumberOfEntries;       /* get requested number of entries */
    
    data->Com.NumberOfEntries = 0;                     /* reset number of entries */
   
    osZero(( void *)data, sizeof(data));
    for (p = 0; (p < NUMBER_OF_BUSES) && (done==FALSE); p++ ) 
    {
        for (t = 0; (t < gMaximumTargetIDs) && (done==FALSE); t++) 
        {
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; (l < devmap->Com.MaxLuns+1) && (done==FALSE); l++) 
            {
                if (!GetOSToFcpMapping(pCard, fcpEntry, p,t,l))
                {
                    data->Com.NumberOfEntries++;     /* incerement number of entries */
                    fcpEntry++;                      /* move the storage pointer */                  
                    reqCount--;                      /* decrement # of requested entries */
                    if (reqCount <=0 )               /* is it done yet ? */
                        done = TRUE;
                }
            }
        }
    }

    return 0;
}


ULONG SANGetOsScsiFcpAttribute(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_SCSI_FCP_ATTRIBUTE      *data = (AG_SCSI_FCP_ATTRIBUTE*) Srb->DataBuffer;
    HBA_FCPSCSIENTRY           fcpEntry;
    UCHAR                      pathId, targetId, lun;
    
    pathId   = (UCHAR) data->Com.OsScsi.OsScsiBusNumber;
    targetId = (UCHAR) data->Com.OsScsi.OsScsiTargetNumber;
    lun      = (UCHAR) data->Com.OsScsi.OsScsiLun;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetOsScsiFcpAttribute: Bus=%d Tid=%d Lun=%d\n",pathId, targetId, lun));
    if (!GetOSToFcpMapping(pCard, &fcpEntry, pathId, targetId, lun))
    {
        osCopy(&data->Com.FcpId, &fcpEntry.FcpId, sizeof(data->Com.FcpId) );
    }
    else
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED; 
        return 1; /* SNIA : This is needed as on some older versions of win2, setting
                  Srb return code is not working */
    }

    return 0;
}


ULONG SANGetEventBuffer(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_EVENTINFO           *data = (AG_HBA_EVENTINFO*) Srb->DataBuffer;
    ULONG                      portid;
    agFCChanInfo_t             chanInfo;
    SAN_EVENTINFO              *this=NULL;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetEventBuffer\n"));
   
    this = SANGetNextBuffer(pCard);
    if (this)
    {
        fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
      
        portid = ((ULONG)chanInfo.CurrentAddress.reserved << 24 )|
               ((ULONG)chanInfo.CurrentAddress.Domain   << 16 )|
               ((ULONG)chanInfo.CurrentAddress.Area     << 8  )|
               (ULONG)chanInfo.CurrentAddress.AL_PA ;
             
        data->Com.EventCode = this->EventCode;
        data->Com.Event.Link_EventInfo.PortFcId = portid;
        data->Com.Event.Link_EventInfo.Reserved[0] = this->Event.Link_EventInfo.Reserved[0];
        data->Com.Event.Link_EventInfo.Reserved[1] = this->Event.Link_EventInfo.Reserved[1];
        data->Com.Event.Link_EventInfo.Reserved[2] = this->Event.Link_EventInfo.Reserved[2];
    }
    else
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED; 
    }   
   
    return 0;
}


ULONG SANGetPersistentBindingSize(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_FCPBINDING_SIZE         *data = (AG_FCPBINDING_SIZE*) Srb->DataBuffer;
    SCSI_REQUEST_BLOCK         tempSrb;
    AG_FCPTARGETMAPPING_SIZE   tempBuffer;
    UCHAR                      tempStatus;
    PSRB_IO_CONTROL            tempSrbIoCtl;

    tempSrb.DataBuffer = &tempBuffer;
    tempSrb.DataTransferLength = sizeof(tempBuffer);
    tempSrbIoCtl = (PSRB_IO_CONTROL) &tempBuffer;
   
    SANGetFCPLunMappingSize(&tempSrb, pCard, &tempStatus);
   
    if( (tempStatus == SRB_STATUS_SUCCESS) && (tempSrbIoCtl->ReturnCode == HP_FC_RTN_OK) )
    {
        data->Com.TotalLunBindings = tempBuffer.Com.TotalLunMappings;
        data->Com.SizeInBytes = tempBuffer.Com.SizeInBytes;
    }
    else
    {
        *status = tempStatus;
        srbIoCtl->ReturnCode = tempSrbIoCtl->ReturnCode;      
    }
   
    return 0;
      
}

ULONG SANGetPersistentBinding(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_FCPBINDING          *data = (AG_HBA_FCPBINDING*) Srb->DataBuffer;
    
    return 0;
}


#define PROCESS_IOCTL(size, func)   \
   { \
      if (Srb->DataTransferLength >= size ) \
      { \
         func (Srb, pCard, &status); \
      } \
      else \
      { \
         osDEBUGPRINT((ALWAYS_PRINT,"PROCESS_IOCTL Func %d : GivenSize=%d required=%d\n", \
            srbIoCtl->ControlCode, Srb->DataTransferLength, size));  \
         srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER; \
      } \
   }

ULONG AgSANIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN     *LinkResetPerformed,
    BOOLEAN     *DeviceResetPerformed,
    UCHAR       *srb_status,
    UCHAR       *PathId, 
    UCHAR       *TargetId
    )
{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    PSRB_IO_CONTROL srbIoCtl;
    UCHAR status;
//  PSRB_IO_CONTROL srbIoCtl;
//  ULONG    done = FALSE;
//    UCHAR    srbPathId = Srb->PathId;
//    UCHAR    srbTargetId = Srb->TargetId;
//    UCHAR    srbLun = Srb->Lun;

    status = *srb_status;
    srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    
    switch (srbIoCtl->ControlCode) 
    {
        case AG_IOCTL_GET_HBA_ATTRIBUTES : 
            PROCESS_IOCTL(sizeof(AG_HBA_ADAPTERATTRIBUTES), SANGetHBAAttributes)
            break;
         
        case AG_IOCTL_GET_HBA_PORT_ATTRIBUTES: 
            PROCESS_IOCTL(sizeof(AG_HBA_PORTATTRIBUTES), SANGetHBAPortAttributes)
            break;

        case AG_IOCTL_GET_HBA_PORT_STATISTICS : 
            PROCESS_IOCTL(sizeof(AG_HBA_PORTSTATISTICS), SANGetPortStatistics)
            break;

        case AG_IOCTL_GET_PORT_ATTRIBUTES : 
            PROCESS_IOCTL(sizeof(AG_DISCOVERED_PORTATTRIBUTES), SANGetPortAttributes)
            break;

        case AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE:
            PROCESS_IOCTL(sizeof(AG_FCPTARGETMAPPING_SIZE), SANGetFCPLunMappingSize)
            break;
     
        case AG_IOCTL_GET_FCP_LUN_MAPPING:
            PROCESS_IOCTL(sizeof(AG_HBA_FCPTARGETMAPPING), SANGetFCPLunMapping)
            break;
     
        case AG_IOCTL_GET_EVENT_BUFFER:
            PROCESS_IOCTL(sizeof(AG_HBA_EVENTINFO), SANGetEventBuffer)
            break;
     
        case AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE:
            PROCESS_IOCTL(sizeof(AG_SCSI_FCP_ATTRIBUTE), SANGetOsScsiFcpAttribute)
            break;
     
        case AG_IOCTL_GET_PERSISTENT_BINDING_SIZE:
            PROCESS_IOCTL(sizeof(AG_FCPBINDING_SIZE), SANGetPersistentBindingSize)
            break;
     
        case AG_IOCTL_GET_PERSISTENT_BINDING:
            PROCESS_IOCTL(sizeof(AG_HBA_FCPBINDING), SANGetPersistentBinding)
            break;
         
        default :
            osDEBUGPRINT((ALWAYS_PRINT,"AgSANIoctl: MiniportIOCtl not supported\n"));
            srbIoCtl->ReturnCode = HP_FC_RTN_BAD_CTL_CODE;
    } // end IOCTL switch

    if( (status != SRB_STATUS_SUCCESS) || (srbIoCtl->ReturnCode) )
        osDEBUGPRINT((ALWAYS_PRINT,"AgSANIoctl: Func %d failed. NT Status %xx  Ioctl Status %xx\n",
            srbIoCtl->ControlCode, status, srbIoCtl->ReturnCode));
    *srb_status = status;
   
    return 0;
           
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sanapi.h ===
#ifndef SANAPI_H
#define SANAPI_H

#include "hbaapi.h"

/* FOR REFERENCE - from NTDDSCSI.h
typedef struct _SRB_IO_CONTROL 
{
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;
*/

#define AG_SAN_IOCTL_SIGNATURE 	"SANIOCTL"

/*
	Agilent SAN IOCTLs
	------------------
 	AG_IOCTL_GET_HBA_ATTRIBUTES			Retrieve the attributes of the HBA.
	AG_IOCTL_GET_HBA_PORT_ATTRIBUTES	Retrieve the attributes for  the specific FC port on the HBA.
	AG_IOCTL_GET_HBA_PORT_STATISTICS	Retrieve the statistics for the specific FC port on the HBA.
	AG_IOCTL_GET_PORT_ATTRIBUTES		Retrieve the attributes of the specific FC port discovered by the HBA.
	AG_IOCTL_GET_FCP_LUN_MAPPING		Retrieve ALL mapping between the FCP Lun and OS SCSI address.
	AG_IOCTL_GET_PERSISTENT_BINDING		Retrieve the persistent binding between the FCP Lun and the OS SCSI address.
	AG_IOCTL_GET_EVENT_BUFFER			Retrieve the HBA event queue.
	AG_IOCTL_SEND_CT_PASSTHRU			Send a CT passthrough frame.
	AG_IOCTL_SET_RNID_MGMT_INFO			Set the RNID management info for the HBA.
	AG_IOCTL_GET_RNID_MGMT_INFO			Retrieve the RNID management info from the HBA.
	AG_IOCTL_SEND_RNID					Send an ELS  RNID to another node.
	AG_IOCTL_SEND_SCSI_INQUIRY			Send a SCSI Inquiry to an FCL Lun of a port.
	AG_IOCTL_SEND_SCSI_REPORT_LUN		Send a SCSI Report Lun to an FCP Lun of a port.
	AG_IOCTL_SEND_SCSI_READ_CAPACITY	Send a SCSI Capacity  to an FCP Lun of a port.
	AG_IOCTL_GET_DEV_FCP_LUN_MAPPING	Retrieve the mapping between a FCP Lun and OS SCSI address of a device
	AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE	Retrieve an FCP Port attribute for an OS known SCSI device.
	AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE	Retrieve the size in bytes required for all the mappings between the FCP Lun and OS SCSI address.
	AG_IOCTL_GET_PERSISTENT_BINDING_SIZE	Retrieve the size in bytes required for all the persistent bindings between the FCP Lun and the OS SCSI address
 */

typedef enum IOCTL_CODES{
	AG_IOCTL_GET_HBA_PORT_ATTRIBUTES	=	0x20,
	AG_IOCTL_GET_HBA_PORT_STATISTICS,
	AG_IOCTL_GET_HBA_ATTRIBUTES,
	AG_IOCTL_GET_PORT_ATTRIBUTES,
	AG_IOCTL_GET_FCP_LUN_MAPPING,
	AG_IOCTL_GET_PERSISTENT_BINDING,
	AG_IOCTL_GET_EVENT_BUFFER,
	AG_IOCTL_SEND_CT_PASSTHRU,
	AG_IOCTL_SET_RNID_MGMT_INFO,
	AG_IOCTL_GET_RNID_MGMT_INFO,
	AG_IOCTL_SEND_RNID,
	AG_IOCTL_SEND_SCSI_INQUIRY,
	AG_IOCTL_SEND_SCSI_REPORT_LUN,
	AG_IOCTL_SEND_SCSI_READ_CAPACITY,
	AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE,
	AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE,
	AG_IOCTL_GET_PERSISTENT_BINDING_SIZE
}; // end of codes


/* Return Codes */
/*	
	HP_FC_RTN_OK					The requested operation completed successfully.
	HP_FC_RTN_FAILED				The requested operation failed.
	HP_FC_RTN_BAD_CTL_CODE			The Control Code of the requested operation is invalid.
	HP_FC_RTN_INSUFFICIENT_BUFFER	The requested operation could not be satisfied due to the Data Area being smaller than the expected.
	HP_FC_RTN_INVALID_DEVICE		The target device specified in the input SCSI_ADDRESS data structure is not valid.
	HP_FC_RTN_INVALID_INDEX			The index (such as DiscoveredPortIndex in AG_IOCTL_GET_PORT_ATTRIBUTES).
*/
#define HP_FC_RTN_OK					0
#define HP_FC_RTN_FAILED				1
#define HP_FC_RTN_BAD_CTL_CODE			2
#define HP_FC_RTN_INSUFFICIENT_BUFFER	3
#define HP_FC_RTN_INVALID_DEVICE		4
#define HP_FC_RTN_BAD_SIGNATURE			5
#define HP_FC_RTN_INVALID_INDEX			6

/* Structures used for different IOCTLs */

/* Get Port attributes - AG_IOCTL_GET_HBA_PORT_ATTRIBUTES */
typedef struct _AG_HBA_PORTATTRIBUTES {
	SRB_IO_CONTROL		srbIoCtl;
	HBA_PORTATTRIBUTES	Com;
} AG_HBA_PORTATTRIBUTES, *PAG_HBA_PORTATTRIBUTES;

/* Get Port statistics - AG_IOCTL_GET_PORT_STATISTICS */
typedef struct _AG_HBA_PORTSTATISTICS {
	SRB_IO_CONTROL		srbIoCtl;
	HBA_PORTSTATISTICS	Com;
} AG_HBA_PORTSTATISTICS, *PAG_HBA_PORTSTATISTICS;

/* Get Adapter/HBA attributes - AG_IOCTL_GET_HBA_ATTRIBUTES */
typedef struct _AG_HBA_ADAPTERATTRIBUTES {
	SRB_IO_CONTROL			srbIoCtl;
	HBA_ADAPTERATTRIBUTES	Com;
} AG_HBA_ADAPTERATTRIBUTES, *PAG_HBA_ADAPTERATTRIBUTES;

// Wrapper structure, which stores the discovered port
// properties and also the port index
typedef struct _DISCOVERED_PORTATTRIBUTES {
	HBA_UINT32			DiscoveredPortIndex;
	HBA_PORTATTRIBUTES	PortAttributes;
} DISCOVERED_PORTATTRIBUTES, *PDISCOVERED_PORTATTRIBUTES;

/* Get Port attributes - AG_IOCTL_GET_PORT_ATTRIBUTES */
typedef struct _AG_DISCOVERED_PORTATTRIBUTES {
	SRB_IO_CONTROL				srbIoCtl;
	DISCOVERED_PORTATTRIBUTES	Com;
} AG_DISCOVERED_PORTATTRIBUTES, *PAG_DISCOVERED_PORTATTRIBUTES;

/* Get FCP LUN mapping - AG_IOCTL_GET_FCP_LUN_MAPPING */
typedef struct _AG_HBA_FCPTARGETMAPPING {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_FCPTARGETMAPPING	Com;
} AG_HBA_FCPTARGETMAPPING, *PAG_HBA_FCPTARGETMAPPING;

typedef struct _AG_HBA_FCPBINDING {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_FCPBINDING	Com;
} AG_HBA_FCPBINDING, *PAG_HBA_FCPBINDING;

typedef struct _AG_HBA_MGMTINFO {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_MGMTINFO	Com;
} AG_HBA_MGMTINFO, *PAG_HBA_MGMTINFO;

typedef struct _AG_HBA_EVENTINFO {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_EVENTINFO	Com;
} AG_HBA_EVENTINFO, *PAG_HBA_EVENTINFO;

/* Data structures needed for AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE */
typedef struct OS_ScsiAddress {
	HBA_UINT32		OsScsiBusNumber;
	HBA_UINT32		OsScsiTargetNumber;
	HBA_UINT32		OsScsiLun;
} OS_SCSI_ADDRESS, *POS_SCSI_ADDRESS;

typedef struct Scsi_Fcp_Attribute {
	OS_SCSI_ADDRESS	OsScsi;
	HBA_FCPID		FcpId;
} SCSI_FCP_ATTRIBUTE, *PSCSI_FCP_ATTRIBUTE;

typedef struct _AG_SCSI_FCP_ATTRIBUTE {
	SRB_IO_CONTROL 	srbIoCtl;
	SCSI_FCP_ATTRIBUTE	Com;
} AG_SCSI_FCP_ATTRIBUTE, *PAG_SCSI_FCP_ATTRIBUTE;

/* Data structures needed for AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE */

typedef struct FCPTargetMapping_Size {
	HBA_UINT32		TotalLunMappings;
	HBA_UINT32		SizeInBytes;
} FCPTARGETMAPPING_SIZE, *PFCPTARGETMAPPING_SIZE;

typedef struct _AG_FCPTARGETMAPPING_SIZE {
	SRB_IO_CONTROL 	srbIoCtl;
	FCPTARGETMAPPING_SIZE	Com;
} AG_FCPTARGETMAPPING_SIZE, *PAG_FCPTARGETMAPPING_SIZE;

/* Data structures needed for AG_IOCTL_GET_PERSISTENT_BINDING_SIZE */
typedef struct FCPBinding_Size {
	HBA_UINT32		TotalLunBindings;
	HBA_UINT32		SizeInBytes;
} FCPBINDING_SIZE, *PFCPBINDING_SIZE;

typedef struct _AG_FCPBINDING_SIZE {
	SRB_IO_CONTROL 	srbIoCtl;
	FCPBINDING_SIZE	Com;
} AG_FCPBINDING_SIZE, *PAG_FCPBINDING_SIZE;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sa110.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/SA110.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  specific to the Intel StrongARM SA-110 Microprocessor

Reference Documents:

  SA-110 Microprocessor Technical Reference Manual
                   September 1998

  Advanced RISC Machines Architectural Reference Manual
    Edited by Dave Jaggar          ISBN 0-13-736299-4

  ARM System Architecture
    By Steve Furber                ISBN 0-201-40352-8

--*/

#ifndef __SA110_H__
#define __SA110_H__

/*+
System Control Coprocessor
-*/

#define SA110_Coprocessor                                                      p15

#define SA110_Coprocessor_ID                                                   c0
#define SA110_Coprocessor_Control                                              c1
#define SA110_Coprocessor_TranslationTableBase                                 c2
#define SA110_Coprocessor_DomainAccessControl                                  c3
#define SA110_Coprocessor_FaultStatus                                          c5
#define SA110_Coprocessor_FaultAddress                                         c6
#define SA110_Coprocessor_CacheControlOperations                               c7
#define SA110_Coprocessor_TLBOperations                                        c8
#define SA110_Coprocessor_TestClockIdleControl                                 c15

#define SA110_Coprocessor_Ignored_OPC_1                                        0
#define SA110_Coprocessor_Ignored_OPC_2                                        0
#define SA110_Coprocessor_Ignored_CRm                                          c0

#define SA110_Coprocessor_ID_MASK                                              (os_bit32)0xFFFFFFF0
#define SA110_Coprocessor_ID_VALUE                                             (os_bit32)0x4401A100

#define SA110_Coprocessor_ID_Revision_MASK                                     (os_bit32)0x0000000F

#define SA110_Coprocessor_Control_MASK                                         (os_bit32)0x0000138F
#define SA110_Coprocessor_Control_TEMPLATE                                     (os_bit32)0x00000070

#define SA110_Coprocessor_Control_ICache_Enabled                               (os_bit32)0x00001000
#define SA110_Coprocessor_Control_ROM_Protect                                  (os_bit32)0x00000200
#define SA110_Coprocessor_Control_System_Protect                               (os_bit32)0x00000100
#define SA110_Coprocessor_Control_Big_Endian                                   (os_bit32)0x00000080
#define SA110_Coprocessor_Control_WrtBuf_Enabled                               (os_bit32)0x00000008
#define SA110_Coprocessor_Control_DCache_Enabled                               (os_bit32)0x00000004
#define SA110_Coprocessor_Control_AddrFault_Enabled                            (os_bit32)0x00000002
#define SA110_Coprocessor_Control_MMU_Enabled                                  (os_bit32)0x00000001

#define SA110_Coprocessor_TranslationTableBase_MASK                            (os_bit32)0xFFFFC000

#define SA110_Coprocessor_DomainAccessControl_SIZE                             (os_bit32)0x02
#define SA110_Coprocessor_DomainAccessControl_MASK                             (os_bit32)0x00000003

#define SA110_Coprocessor_DomainAccessControl_NoAccess                         (os_bit32)0x00000000
#define SA110_Coprocessor_DomainAccessControl_Client                           (os_bit32)0x00000001
#define SA110_Coprocessor_DomainAccessControl_Reserved                         (os_bit32)0x00000002
#define SA110_Coprocessor_DomainAccessControl_Manager                          (os_bit32)0x00000003

#define SA110_Coprocessor_FaultStatus_ZeroBit_MASK                             (os_bit32)0x00000100

#define SA110_Coprocessor_FaultStatus_Domain_MASK                              (os_bit32)0x000000F0
#define SA110_Coprocessor_FaultStatus_Domain_SHIFT                             (os_bit32)0x04

#define SA110_Coprocessor_FaultStatus_Status_MASK                              (os_bit32)0x0000000F
#define SA110_Coprocessor_FaultStatus_Status_TerminalException                 (os_bit32)0x00000002
#define SA110_Coprocessor_FaultStatus_Status_VectorException                   (os_bit32)0x00000000
#define SA110_Coprocessor_FaultStatus_Status_Alignment_1                       (os_bit32)0x00000001
#define SA110_Coprocessor_FaultStatus_Status_Alignment_3                       (os_bit32)0x00000003
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnTransL1                 (os_bit32)0x0000000C
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnTransL2                 (os_bit32)0x0000000E
#define SA110_Coprocessor_FaultStatus_Status_TranslationSection                (os_bit32)0x00000005
#define SA110_Coprocessor_FaultStatus_Status_TranslationPage                   (os_bit32)0x00000007
#define SA110_Coprocessor_FaultStatus_Status_DomainSection                     (os_bit32)0x00000009
#define SA110_Coprocessor_FaultStatus_Status_DomainPage                        (os_bit32)0x0000000B
#define SA110_Coprocessor_FaultStatus_Status_PermissionSection                 (os_bit32)0x0000000D
#define SA110_Coprocessor_FaultStatus_Status_PermissionPage                    (os_bit32)0x0000000F
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnLineFetchSection        (os_bit32)0x00000004
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnLineFetchPage           (os_bit32)0x00000006
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnNonLineFetchSection     (os_bit32)0x00000008
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnNonLineFetchPage        (os_bit32)0x0000000A

#define SA110_Coprocessor_CacheControlOperations_FlushID_OPC_2                 0
#define SA110_Coprocessor_CacheControlOperations_FlushID_CRm                   c7

#define SA110_Coprocessor_CacheControlOperations_FlushI_OPC_2                  0
#define SA110_Coprocessor_CacheControlOperations_FlushI_CRm                    c5

#define SA110_Coprocessor_CacheControlOperations_FlushD_OPC_2                  0
#define SA110_Coprocessor_CacheControlOperations_FlushD_CRm                    c6

#define SA110_Coprocessor_CacheControlOperations_FlushDEntry_OPC_2             1
#define SA110_Coprocessor_CacheControlOperations_FlushDEntry_CRm               c6

#define SA110_Coprocessor_CacheControlOperations_CleanDEntry_OPC_2             1
#define SA110_Coprocessor_CacheControlOperations_CleanDEntry_CRm               c10

#define SA110_Coprocessor_CacheControlOperations_DrainWriteBuffer_OPC_2        4
#define SA110_Coprocessor_CacheControlOperations_DrainWriteBuffer_CRm          c10

#define SA110_Coprocessor_TLBOperations_FlushID_OPC_2                          0
#define SA110_Coprocessor_TLBOperations_FlushID_CRm                            c7

#define SA110_Coprocessor_TLBOperations_FlushI_OPC_2                           0
#define SA110_Coprocessor_TLBOperations_FlushI_CRm                             c5

#define SA110_Coprocessor_TLBOperations_FlushD_OPC_2                           0
#define SA110_Coprocessor_TLBOperations_FlushD_CRm                             c6

#define SA110_Coprocessor_TLBOperations_FlushDEntry_OPC_2                      1
#define SA110_Coprocessor_TLBOperations_FlushDEntry_CRm                        c6

#define SA110_Coprocessor_TestClockIdleControl_EnableOddWordLFSR_OPC_2         1
#define SA110_Coprocessor_TestClockIdleControl_EnableOddWordLFSR_CRm           c1

#define SA110_Coprocessor_TestClockIdleControl_EnableEvenWordLFSR_OPC_2        1
#define SA110_Coprocessor_TestClockIdleControl_EnableEvenWordLFSR_CRm          c2

#define SA110_Coprocessor_TestClockIdleControl_ClearICacheLFSR_OPC_2           1
#define SA110_Coprocessor_TestClockIdleControl_ClearICacheLFSR_CRm             c4

#define SA110_Coprocessor_TestClockIdleControl_MoveLFSRtoR14_OPC_2             1
#define SA110_Coprocessor_TestClockIdleControl_MoveLFSRtoR14_CRm               c8

#define SA110_Coprocessor_TestClockIdleControl_EnableClockSwitching_OPC_2      2
#define SA110_Coprocessor_TestClockIdleControl_EnableClockSwitching_CRm        c1

#define SA110_Coprocessor_TestClockIdleControl_DisableClockSwitching_OPC_2     2
#define SA110_Coprocessor_TestClockIdleControl_DisableClockSwitching_CRm       c2

#define SA110_Coprocessor_TestClockIdleControl_DisablenMCLKOutput_OPC_2        2
#define SA110_Coprocessor_TestClockIdleControl_DisablenMCLKOutput_CRm          c4

#define SA110_Coprocessor_TestClockIdleControl_WaitForInterrupt_OPC_2          2
#define SA110_Coprocessor_TestClockIdleControl_WaitForInterrupt_CRm            c8

/*+
MMU Declarations
-*/

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_MASK                   (os_bit32)0x00000003
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_Fault                  (os_bit32)0x00000000
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_PageTable              (os_bit32)0x00000001
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_Section                (os_bit32)0x00000002
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_Reserved               (os_bit32)0x00000003

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_PageTable_BaseAddress_MASK  (os_bit32)0xFFFFFC00

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_PageTable_Domain_MASK       (os_bit32)0x000001E0
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_PageTable_Domain_SHIFT      (os_bit32)0x05

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_BaseAddress_MASK    (os_bit32)0xFFF00000

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_AP_MASK             (os_bit32)0x00000C00
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_AP_SHIFT            (os_bit32)0x0A

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Domain_MASK         (os_bit32)0x000001E0
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Domain_SHIFT        (os_bit32)0x05

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Cacheable           (os_bit32)0x00000008

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Bufferable          (os_bit32)0x00000004

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_MASK                  (os_bit32)0x00000003
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_Fault                 (os_bit32)0x00000000
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_LargePage             (os_bit32)0x00000001
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_SmallPage             (os_bit32)0x00000002
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_Reserved              (os_bit32)0x00000003

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_BaseAddress_MASK (os_bit32)0xFFFF0000

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP3_MASK         (os_bit32)0x00000C00
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP3_SHIFT        (os_bit32)0x0A

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP2_MASK         (os_bit32)0x00000300
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP2_SHIFT        (os_bit32)0x08

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP1_MASK         (os_bit32)0x000000C0
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP1_SHIFT        (os_bit32)0x06

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP0_MASK         (os_bit32)0x00000030
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP0_SHIFT        (os_bit32)0x04

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_Cacheable        (os_bit32)0x00000008

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_Bufferable       (os_bit32)0x00000004

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_BaseAddress_MASK (os_bit32)0xFFFFF000

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP3_MASK         (os_bit32)0x00000C00
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP3_SHIFT        (os_bit32)0x0A

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP2_MASK         (os_bit32)0x00000300
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP2_SHIFT        (os_bit32)0x08

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP1_MASK         (os_bit32)0x000000C0
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP1_SHIFT        (os_bit32)0x06

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP0_MASK         (os_bit32)0x00000030
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP0_SHIFT        (os_bit32)0x04

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_Cacheable        (os_bit32)0x00000008

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_Bufferable       (os_bit32)0x00000004

#endif /* __SA110_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sanioctl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   sanioctl.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/sanioctl.h $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:19a $
   $Modtime:: 8/31/00 3:27p            $

Notes:


--*/

#ifndef SANIOCTL_H
#define SANIOCTL_H

#include "buildop.h"             //LP021100 build switches
#include "osflags.h"
#include "hbaapi.h"
#include "sanapi.h"

/* FOR REFERENCE - from NTDDSCSI.h
typedef struct _SRB_IO_CONTROL 
{
   ULONG HeaderLength;
   UCHAR Signature[8];
   ULONG Timeout;
   ULONG ControlCode;
   ULONG ReturnCode;
   ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;
*/

#endif  // SANIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sfstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/SFSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/30/00 3:19p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/fcstruct.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"

#include "../h/devstate.h"
#ifdef _DvrArch_1_30_
#include "../h/ip.h"
#include "../h/pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"
#include "../h/queue.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/sf_fcp.h"
#include "../h/timersvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "fcstruct.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"

#include "cstate.h"
#include "cfunc.h"

#include "devstate.h"
#ifdef _DvrArch_1_30_
#include "ip.h"
#include "pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "cdbstate.h"
#include "sfstate.h"
#include "tgtstate.h"
#include "queue.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "sf_fcp.h"
#include "timersvc.h"
#endif  /* _New_Header_file_Layout_ */


/*
[maxEvents][maxStates];

*/
stateTransitionMatrix_t SFStateTransitionMatrix = {
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 SFEventReset */
    SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
      SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
        SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
          SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
            SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
              SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                  SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                    SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                      SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                        SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                          SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                            SFStateFree, SFStateFree, SFStateFree, SFStateFree,
    SFStateFree,
      SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
        SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
          SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
            SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
              SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                SFStateFree, SFStateFree, SFStateFree,SFStateFree, SFStateFree,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 SFEventDoPlogi */
     SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
      SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
        SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
          SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
            SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
              SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
                SFStateDoPlogi, SFStateDoPlogi,   SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                  SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                    SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                      SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                        SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                          SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                            SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi,
    SFStateDoPlogi,
      SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,
        SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
          SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
            SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi,SFStateDoPlogi,
              SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,
                SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 3 SFEventPlogiAccept  */
    0,0,SFStatePlogiAccept,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 4 SFEventPlogiRej */
    0,0,SFStatePlogiRej,     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 5 SFEventPlogiBadALPA */
    0,SFStateFree,SFStatePlogiBadALPA,0,0,
      SFStatePlogiBadALPA,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6 SFEventPlogiTimedOut */
    0,0,SFStatePlogiTimedOut,0,0,SFStatePlogiTimedOut,SFStatePlogiTimedOut,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7 SFEventDoPrli */
    SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
      SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
        SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
          SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
            SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
              SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                  SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                    SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                      SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                        SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
                          SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
                            SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
    SFStateDoPrli,
      SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,
        SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
          SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
            SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,SFStateDoPrli,
              SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,
                SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8 SFEventPrliAccept */
    0,0,0,0,0,0,0,SFStatePrliAccept,   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9 SFEventPrliRej */
    0,0,0,0,0,0,0,SFStatePrliRej,      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10  SFEventPrliBadALPA0 */
    0,0,0,0,0,0,0,SFStatePrliBadAlpa,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11 B SFEventPrliTimedOut */
    0,0,0,0,0,0,0,SFStatePrliTimedOut, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12 C SFEventDoFlogi */
    SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
      SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
        SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
          SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
            SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
              SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                  SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                    SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                      SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                        SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
                          SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
                            SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
    SFStateDoFlogi,
      SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,
        SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
          SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
            SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,SFStateDoFlogi,
              SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,
                SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,SFStateDoFlogi,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13 D SFEventFlogiAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiAccept,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14 E SFEventFlogiRej */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiRej,     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15 F SFEventFlogiBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiBadALPA, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16 10 SFEventFlogiTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiTimedOut,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17 11 SFEventDoLogo */
    SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
      SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
        SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
          SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
            SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
              SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                  SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                    SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                      SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                        SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
                          SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
                            SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
    SFStateDoLogo,
      SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,
        SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
          SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
            SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,SFStateDoLogo,
              SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,
                SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18 12 SFEventLogoAccept*/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoAccept,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19 13 SFEventLogoRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoRej,     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20 14 SFEventLogoBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoBadALPA, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21 15 SFEventLogoTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoTimedOut,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22 16 SFEventDoPrlo */
    SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
     SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
      SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
       SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
        SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
         SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
          SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
           SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
            SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
             SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
              SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
               SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
                SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
    SFStateDoPrlo,
      SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
        SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
          SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
            SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
              SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
                SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23 17 SFEventPrloAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloAccept,   0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24 18 SFEventPrloRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloRej,      0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25 19 SFEventPrloBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloBadALPA,  0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26 1a SFEventPrloTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloTimedOut ,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27 1b SFEventDoAdisc */
    SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
     SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
      SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
       SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
        SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
         SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
          SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
           SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
            SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
             SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
              SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
               SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
                SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
    SFStateDoAdisc,
      SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,SFStateDoAdisc,
        SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
          SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
            SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
              SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,SFStateDoAdisc,
                SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,SFStateDoAdisc,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28 1c SFEventAdiscAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscAccept,  0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29 1d SFEventAdiscRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscRej,     0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 30 1e SFEventAdiscBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscBadALPA, 0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31 1f SFEventAdiscTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscTimedOut,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32 20 SFEventDoPdisc */
    SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
     SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
      SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
       SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
        SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
         SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
          SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
           SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
            SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
             SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
              SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
               SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
                SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
    SFStateDoPdisc,
      SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,
        SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
          SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
            SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,SFStateDoPdisc,
              SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,
                SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33 21 SFEventPdiscAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscAccept,  0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34 22 SFEventPdiscRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscRej,     0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35 23 SFEventPdiscBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscBadALPA, 0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36 24 SFEventPdiscTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscTimedOut,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37 25 SFEventDoAbort */
    SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
     SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
      SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
       SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
        SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
         SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
          SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
           SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
            SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
             SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
              SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
               SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
                SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
    SFStateDoAbort,
      SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,
        SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
          SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
            SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,SFStateDoAbort,
              SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,
                SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38 26 SFEventAbortAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortAccept,  0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39 27 SFEventAbortRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortRej,     0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 40 28 SFEventAbortBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortBadALPA, 0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41 29 SFEventAbortTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortTimedOut,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42 2a SFEventDoResetDevice */
    SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
     SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
      SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
       SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
        SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
         SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
          SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
           SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
            SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
             SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
              SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
               SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
                SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
    SFStateDoResetDevice,
      SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,
        SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
          SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
            SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
              SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,
                SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43 2b SFEventResetDeviceAccept */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceAccept,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44 2c SFEventResetDeviceRej */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceRej,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45 2d SFEventResetDeviceBadALPA */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceBadALPA,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46 2e SFEventResetDeviceTimedOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceTimedOut,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47 2f SFEventDoLS_RJT */
    SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
     SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
      SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
       SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
        SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
         SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
          SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
           SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
            SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
             SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
              SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
               SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
                SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
    SFStateDoLS_RJT,
      SFStateDoLS_RJT, SFStateDoLS_RJT,  SFStateDoLS_RJT, SFStateDoLS_RJT,SFStateDoLS_RJT,
        SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
          SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
            SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
              SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,SFStateDoLS_RJT,
                SFStateDoLS_RJT, SFStateDoLS_RJT,  SFStateDoLS_RJT, SFStateDoLS_RJT,SFStateDoLS_RJT,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 48 30 SFEventLS_RJT_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateLS_RJT_Done,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49 31 SFEventDoPlogiAccept */
    SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
     SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
      SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
       SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
        SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
         SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
          SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
           SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
            SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
             SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
              SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
               SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
                SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
    SFStateDoPlogiAccept,
      SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
        SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
          SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
            SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
              SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
                SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 50 32 SFEventPlogiAccept_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,SFStatePlogiAccept_Done, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51 33 SFEventDoPrliAccept */
    SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
     SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
      SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
       SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
        SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
         SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
          SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
           SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
            SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
             SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
              SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
               SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
                SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
    SFStateDoPrliAccept,
      SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept, SFStateDoPrliAccept,
        SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
          SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
            SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
              SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept, SFStateDoPrliAccept,
                SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept, SFStateDoPrliAccept,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52 34 SFEventPrliAccept_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,SFStatePrliAccept_Done,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53 35 SFEventDoELSAccept    */
    SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
     SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
      SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
       SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
        SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
         SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
          SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
           SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
            SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
             SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
              SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
               SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
                SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
    SFStateDoELSAccept,
      SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept, SFStateDoELSAccept,
        SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
          SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
            SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
              SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,SFStateDoELSAccept,
                SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept, SFStateDoELSAccept,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54 SFEventELSAccept_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,SFStateELSAccept_Done,0,  0,0,0,0,0, 0,0,0,0,
    0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55 SFEventDoFCP_DR_ACC_Reply */
    SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                          0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
     SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
      SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
       SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
        SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
         SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
          SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
           SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
            SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
             SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
              SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
               SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
                SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
    SFStateDoFCP_DR_ACC_Reply,
      SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
        SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
          SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
            SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
              SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
                SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56 SFEventFCP_DR_ACC_Reply_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  SFStateFCP_DR_ACC_Reply_Done,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  57 SFEventLS_RJT_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFEventLS_RJT_TimeOut,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  58 SFEventPlogiAccept_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,SFEventPlogiAccept_TimeOut, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  59 SFEventPrliAccept_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,SFEventPrliAccept_TimeOut,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  60 SFEventELSAccept_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,SFEventELSAccept_TimeOut,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  61 SFEventFCP_DR_ACC_Reply_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  SFEventFCP_DR_ACC_Reply_TimeOut,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62   SFEventDoRFT_ID */
    SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
      SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
        SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
          SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
            SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
              SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                  SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                    SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                      SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                        SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                          SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                            SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                              SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,SFStateDoRFT_ID,
                                SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                                  SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                                    SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                                      SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,SFStateDoRFT_ID,
                                        SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,SFStateDoRFT_ID,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63   SFEventRFT_IDAccept */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0, 0,
                          0,0,0,0,0,
                            0,0,SFStateRFT_IDAccept,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64   SFEventRFT_IDRej */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,SFStateRFT_IDRej,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65   SFEventRFT_IDBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
         0,0,0,0,0,
           0,0,0,0,0,
             0,0,0,0,0,
               0,0,0,0,0,
                 0,0,0,0,0,
                   0,0,0,0,0,
                     0,0,0,0,0,
                       0,0,0,0,0,
                         0,0,0,0,0,
                           0,0,0,0,0,
                             0,0,SFStateRFT_IDBadALPA,0,0,
                               0,0,0,0,0,
                                 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66   SFEventRFT_IDTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0, 0 ,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,SFStateRFT_IDTimedOut,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67   SFEventDoGID_FT */
    SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
      SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
        SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
          SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
            SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
              SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                  SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                    SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                      SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                        SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                          SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                            SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                              SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,SFStateDoGID_FT,
                                SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                                  SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                                    SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                                      SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,SFStateDoGID_FT,
                                        SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,SFStateDoGID_FT,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68   SFEventGID_FTAccept */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTAccept,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69   SFEventGID_FTRej */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTRej,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 70   SFEventGID_FTBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTBadALPA,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71   SFEventGID_FTTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTTimedOut,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
   /* Event 72   SFEventDoSCR */
    SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
      SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
        SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
          SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
            SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
              SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                  SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                    SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                      SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                        SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                          SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                            SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                              SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,SFStateDoSCR,
                                SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                                  SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                                    SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                                      SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,SFStateDoSCR,
                                        SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,SFStateDoSCR,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73   SFEventSCRAccept */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRAccept,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74   SFEventSCRRej */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRRej,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75   SFEventSCRBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRBadALPA,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76   SFEventSCRTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRTimedOut,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77 11 SFEventDoSRR */
    SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
      SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
        SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
          SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
            SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
              SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                  SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                    SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                      SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                        SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                          SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                            SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                              SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                  SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                    SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                      SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                        SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78 12 SFEventSRRAccept*/
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,SFStateSRRAccept,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79 13 SFEventSRRRej */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,SFStateSRRRej,SFStateSRRRej,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 80 14 SFEventSRRBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,SFStateSRRBadALPA,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81 15 SFEventSRRTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,SFStateSRRTimedOut,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82 11 SFEventDoREC */
    SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
      SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
        SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
          SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
            SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
              SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                  SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                    SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                      SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                        SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
                          SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
                            SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
    SFStateDoREC,
      SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,
        SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
          SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
            SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,SFStateDoREC,
              SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,
                SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83 12 SFEventRECAccept*/
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECAccept,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84 13 SFEventRECRej */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECRej,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85 14 SFEventRECBadALPA */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECBadALPA,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86 15 SFEventRECTimedOut */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECTimedOut,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87 SFEventDoADISCAccept                                                     */
    SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept,
      SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 5 */
        SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 10 */
          SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 15 */
            SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 20 */
              SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 25 */
                SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 30 */
                  SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 35 */
                    SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 40 */
                      SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,    0    , /* 45 */
                        SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept, /* 50 */
                          SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 55 */
                                0    ,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 60 */
                              SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 65 */
                                SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 70 */
                                  SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 75 */
                                    SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 80 */
                                      SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88 SFEventADISCAccept_Done                                                     */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,SFStateADISCAccept_Done,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89 SFEventADISCAccept_TimeOut                */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,SFStateADISCAccept_TimeOut,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
#ifdef _DvrArch_1_30_
    /* Event 90 SFEventDoFarpRequest                      */
    SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
     SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
      SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
       SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
        SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
         SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
          SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
           SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
            SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
             SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
              SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
               SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                 SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,SFStateDoFarpRequest,
                  SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                   SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                    SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                     SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,SFStateDoFarpRequest,
                      SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,SFStateDoFarpRequest,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91 SFEventFarpReplied                        */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        SFStateFarpRequestDone,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92 SFEventFarpRequestTimedOut                */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        SFStateFarpRequestTimedOut,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93 SFEventDoFarpReply                        */
    SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
     SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
      SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
       SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
        SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
         SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
          SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
           SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
            SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
             SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
              SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
               SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                 SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,SFStateDoFarpReply,
                  SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                   SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                    SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                     SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,SFStateDoFarpReply,
                      SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,SFStateDoFarpReply,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94 SFEventFarpReplyDone                      */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,SFStateFarpReplyDone,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
#else /* _DvrArch_1_30_ was not defined */
    /* Event 90                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
#endif /* _DvrArch_1_30_ was not defined */
    /* Event 95                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 110                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 120                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 125                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

/*
stateTransitionMatrix_t copiedSFStateTransitionMatrix;
*/

stateActionScalar_t SFStateActionScalar = {
    &SFActionConfused,
    &SFActionReset,
    &SFActionDoPlogi,
    &SFActionPlogiAccept,
    &SFActionPlogiRej,
    &SFActionPlogiBadALPA,
    &SFActionPlogiTimedOut,
    &SFActionDoPrli,
    &SFActionPrliAccept,
    &SFActionPrliRej,
    &SFActionPrliBadALPA,
    &SFActionPrliTimedOut,
    &SFActionDoFlogi,
    &SFActionFlogiAccept,
    &SFActionFlogiRej,
    &SFActionFlogiBadALPA,
    &SFActionFlogiTimedOut,
    &SFActionDoLogo,
    &SFActionLogoAccept,
    &SFActionLogoRej,
    &SFActionLogoBadALPA,
    &SFActionLogoTimedOut,
    &SFActionDoPrlo,
    &SFActionPrloAccept,
    &SFActionPrloRej,
    &SFActionPrloBadALPA,
    &SFActionPrloTimedOut,
    &SFActionDoAdisc,
    &SFActionAdiscAccept,
    &SFActionAdiscRej,
    &SFActionAdiscBadALPA,
    &SFActionAdiscTimedOut,
    &SFActionDoPdisc,
    &SFActionPdiscAccept,
    &SFActionPdiscRej,
    &SFActionPdiscBadALPA,
    &SFActionPdiscTimedOut,
    &SFActionDoAbort,
    &SFActionAbortAccept,
    &SFActionAbortRej,
    &SFActionAbortBadALPA,
    &SFActionAbortTimedOut,
    &SFActionDoResetDevice,
    &SFActionResetDeviceAccept,
    &SFActionResetDeviceRej,
    &SFActionResetDeviceBadALPA,
    &SFActionResetDeviceTimedOut,
    &SFActionDoLS_RJT,
    &SFActionLS_RJT_Done,
    &SFActionDoPlogiAccept,
    &SFActionPlogiAccept_Done,
    &SFActionDoPrliAccept,
    &SFActionPrliAccept_Done,
    &SFActionDoELSAccept,
    &SFActionELSAccept_Done,
    &SFActionDoFCP_DR_ACC_Reply,
    &SFActionFCP_DR_ACC_Reply_Done,
    &SFActionLS_RJT_TimeOut,
    &SFActionPlogiAccept_TimeOut,
    &SFActionPrliAccept_TimeOut,
    &SFActionELSAccept_TimeOut,
    &SFActionFCP_DR_ACC_Reply_TimeOut,
    &SFActionDoRFT_ID,
    &SFActionRFT_IDAccept,
    &SFActionRFT_IDRej,
    &SFActionRFT_IDBadALPA,
    &SFActionRFT_IDTimedOut,
    &SFActionDoGID_FT,
    &SFActionGID_FTAccept,
    &SFActionGID_FTRej,
    &SFActionGID_FTBadALPA,
    &SFActionGID_FTTimedOut,
    &SFActionDoSCR,
    &SFActionSCRAccept,
    &SFActionSCRRej,
    &SFActionSCRBadALPA,
    &SFActionSCRTimedOut,
    &SFActionDoSRR,
    &SFActionSRRAccept,
    &SFActionSRRRej,
    &SFActionSRRBadALPA,
    &SFActionSRRTimedOut,
    &SFActionDoREC,
    &SFActionRECAccept,
    &SFActionRECRej,
    &SFActionRECBadALPA,
    &SFActionRECTimedOut,
    &SFActionDoADISCAccept,
    &SFActionADISCAccept_Done,
    &SFActionADISCAccept_TimeOut,
#ifdef _DvrArch_1_30_
    &SFActionDoFarpRequest,
    &SFActionFarpRequestDone,
    &SFActionFarpRequestTimedOut,
    &SFActionDoFarpReply,
    &SFActionFarpReplyDone,
#else /* _DvrArch_1_30_ was not defined */
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
#endif /* _DvrArch_1_30_ was not defined */
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused

    };

stateActionScalar_t copiedSFStateActionScalar;


#define SFtestCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t SFtestActionUpdate[] = {
                         0,          0,      agNULL,                 agNULL
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */


#ifndef USESTATEMACROS

/*+
  Function: SFActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: None
-*/
/* SFStateConfused                 0 */
extern void SFActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord ){

    fiLogString(thread->hpRoot,
                    "SFActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In Thread(%p) %s - State = %d",
                    "SFActionConfused",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionReset
   Purpose: Indicates sfstate is available. Terminating State.
 Called By: Any sfthread that completes.
     Calls: None
-*/
/* SFStateFree                     1 */
extern void SFActionReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    if(pDevThread)
    {
        fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevel,
                        "In %s - State = %d ALPA %X",
                        "SFActionReset",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        0,0,0,0,0,0);
    }

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionDoPlogi
   Purpose: Does PLOGI. Terminating State.
 Called By: SFEventDoPlogi.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInPLOGI
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPlogiTimedOut
            Proccess_IMQ
-*/
/* SFStateDoPlogi                  2 */
extern void SFActionDoPlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t   *    hpRoot = thread->hpRoot;
    CThread_t  *   pCThread= CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len = 0;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x",
                    "SFActionDoPlogi",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogConsoleLevel,
                    "ERQ Producer %X ERQ_Consumer_Index %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                    0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {
        pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Do Plogi ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    if( pDevThread->Plogi_Reason_Code == PLOGI_REASON_DIR_LOGIN) pCThread->Fabric_pollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        SFS_Len = fiFillInPLOGI( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPlogiTimedOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

#ifndef OSLayer_Stub

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventPlogiAccept);
#endif  /* OSLayer_Stub */

    }
    else
    {

         fiLogDebugString(hpRoot ,
                        SFStateLogErrorLevel,
                        "%s Queues_Frozen - AL_PA %X FM Status %08X TL Status %08X CState %d",
                        "SFActionDoPlogi",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0);

        fiLogDebugString(hpRoot,
                        SFStateLogErrorLevel,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);
        /* Enable rescan for this device */
        pDevThread->Prev_Active_Device_FLAG = agDevSCSITarget;
        fiSetEventRecord(eventRecord,thread,SFEventPlogiTimedOut);
    }
}

/*+
  Function: SFActionPlogiAccept
   Purpose: PLOGI success state. Depending on Plogi_Reason_Code send appropriate
            event.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_OK
            DevEventPlogiSuccess
            DevEventDeviceResetDone
            DevEventAL_PA_Self_OK
-*/
/* SFStatePlogiAccept              3 */
extern void SFActionPlogiAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "(%p)In %s - State = %d CState %d ALPA %X CCnt %x DCnt %x",
                    "SFActionPlogiAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->thread_hdr.currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0);

    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_OK);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiSuccess);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
                break;
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_OK);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                /* Don't do anything - Cthread will take over based on the SF State */
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);
    }

}

/*+
  Function: SFActionPlogiRej
   Purpose: PLOGI rejected state. Depending on Plogi_Reason_Code send appropriate
            event.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_BAD
            DevEventPlogiFailed
            DevEventDeviceResetDone
            
-*/
/* SFStatePlogiRej                 4 */
extern void SFActionPlogiRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    pSFThread->SF_REJ_RETRY_COUNT +=1;

    fiLogString(thread->hpRoot,
                    "%s AL_PA %X AC %X",
                    "SFActionPlogiRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( thread->hpRoot ),
                    0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X  CCnt %x DCnt %x",
                    "SFActionPlogiRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_BAD);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                /* Call this device a target so plogi gets retried */
                pDevThread->Prev_Active_Device_FLAG = agDevSCSITarget;
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiFailed);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);

    }

}

/*+
  Function: SFActionPlogiBadALPA
   Purpose: PLOGI Bad ALPA state. This indcates missing device. Depending on 
            Plogi_Reason_Code send appropriate event.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_BAD
            DevEventPlogiFailed
            DevEventDeviceResetDone
            
-*/
/* SFStatePlogiBadALPA             5 */
extern void SFActionPlogiBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X  CCnt %x DCnt %x",
                    "SFActionPlogiBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_BAD);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiFailed);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevStateDeviceResetDone);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);
    }
}

/*+
  Function: SFActionPlogiTimedOut
   Purpose: This indicates problem with device. Depending on Plogi_Reason_Code 
            send appropriate event. This completion state is used if the PLOGI
            was not sent or if SF_EDTOV has expired.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_BAD
            DevEventPlogiFailed
            DevEventDeviceResetDone
            
-*/
/* SFStatePlogiTimedOut            6 */
extern void SFActionPlogiTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot        = thread->hpRoot;
    SFThread_t  * pSFThread     = (SFThread_t * )thread;
    DevThread_t * pDevThread    = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogString(thread->hpRoot,
                    "%s  %X AC %X OtherAgilentHBA %X TO's %d",
                    "SFAPTO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( hpRoot ),
                    pDevThread->OtherAgilentHBA,
                    CThread_ptr(thread->hpRoot)->NumberOfPlogiTimeouts,
                    0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "(%p)In %s - State = %d CState %d ALPA %X CCnt %x DCnt %x CcurSta %d",
                    "SFActionPlogiTimedOut",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->thread_hdr.currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    CThread_ptr(thread->hpRoot)->thread_hdr.currentState,
                    0,0);

    fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "FM Status %08X TL Status %08X Interrupts %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "pCThread->HostCopy_IMQConsIndex %X  IMQProdIndex %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->HostCopy_IMQConsIndex,
                    CThread_ptr(thread->hpRoot)->FuncPtrs.GetIMQProdIndex(hpRoot),
                    0,0,0,0,0,0);


    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_BAD);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                if( pDevThread->DevInfo.CurrentAddress.AL_PA  > 0x10)
                {
                    if( CThread_ptr(thread->hpRoot)->NumberOfPlogiTimeouts < MAX_PLOGI_TIMEOUTS )
                    {
                        CThread_ptr(thread->hpRoot)->NumberOfPlogiTimeouts +=1;
                        CThread_ptr(thread->hpRoot)->ReScanForDevices = agTRUE;
                    }
                }
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiFailed);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);
    }

}

/*+
  Function: SFActionDoPrli
   Purpose: Does PRLI. Terminating State.
 Called By: SFEventDoPrli.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInPRLI
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPrliTimedOut
-*/
/* SFStateDoPrli                   7 */
extern void SFActionDoPrli( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    os_bit32 SFS_Len = 0;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevelOne,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x Cthread State %x",
                    "SFActionDoPrli",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->SFpollingCount,pDevThread->pollingCount,
                    pCThread->thread_hdr.currentState,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogConsoleLevelOne,
                    "ERQ Producer %X ERQ_Consumer_Index %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                    0,0,0,0,0);

    if( pSFThread->SF_REJ_RETRY_COUNT )
    {
        fiLogString(thread->hpRoot,
                        "%s  %X Retry %d Dev %x AC %d",
                        "SFActionDoPrli",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pSFThread->SF_REJ_RETRY_COUNT,
                        pDevThread->PRLI_rejected,
                        CFuncAll_clear( hpRoot ),0,0,0,0);
    }

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {
        pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Do Prli ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {
        fiSetEventRecordNull(eventRecord);

        WaitForERQ(hpRoot );
        SFS_Len = fiFillInPRLI( pSFThread );
        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );
        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPrliTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );
#ifndef OSLayer_Stub
        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventPrliAccept);
#endif  /* OSLayer_Stub */

    }
    else
    {

         fiLogDebugString(hpRoot ,
                        SFStateLogErrorLevel,
                        "%s Queues_Frozen - AL_PA %X FM Status %08X TL Status %08X CState %d",
                        "SFActionDoPrli",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0);

        fiLogDebugString(hpRoot,
                        SFStateLogErrorLevel,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);

        fiSetEventRecord(eventRecord,thread,SFEventPrliTimedOut);
    }

}

/*+
  Function: SFActionPrliAccept
   Purpose: PRLI success state. Device will be added to active list.
 Called By: SFEventPrliAccept.
     Calls: fiTimerStop
            DevEventPrliSuccess
-*/
/* SFStatePrliAccept               8 */
extern void SFActionPrliAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x",
                    "SFActionPrliAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);


    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliSuccess);

}

/*+
  Function: SFActionPrliRej
   Purpose: PRLI rejected state. If we get rejected retry upto FC_MAX_PRLI_REJECT_RETRY
            times.
 Called By: SFEventPrliRej.
     Calls: fiTimerStop
            SFEventDoPrli
            DevEventPrliFailed
-*/
/* SFStatePrliRej                  9 */
extern void SFActionPrliRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );
    /*+ Check This DRL Make sure reason code is updated in all ELS cases -*/

    fiLogString(thread->hpRoot,
                    "%s AL_PA %X AC %X",
                    "SFActionPrliRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( thread->hpRoot ),
                    0,0,0,0,0,0);


    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x RtryCnt %d",
                    "SFActionPrliRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    pSFThread->SF_REJ_RETRY_COUNT,
                    0,0,0);

    pSFThread->SF_REJ_RETRY_COUNT +=1;

    if(! pDevThread->PRLI_rejected || ! CFuncAll_clear( thread->hpRoot ) )
    {
        fiLogString(thread->hpRoot,
                        "%s  %X Retry %d Dev %x AC %d",
                        "SFActionPrliRej",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pSFThread->SF_REJ_RETRY_COUNT,
                        pDevThread->PRLI_rejected,
                        CFuncAll_clear( thread->hpRoot ),
                        0,0,0,0);
        if( pSFThread->SF_REJ_RETRY_COUNT > FC_MAX_PRLI_REJECT_RETRY )
        {
            pDevThread->PRLI_rejected = agTRUE;
        }
        fiSetEventRecord(eventRecord,thread,SFEventDoPrli);
    }
    else
    {
        fiLogString(thread->hpRoot,
                        "A %s  %X Retry %d Dev %x",
                        "SFActionPrliRej",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pSFThread->SF_REJ_RETRY_COUNT,
                        pDevThread->PRLI_rejected,
                        CFuncAll_clear( thread->hpRoot ),
                        0,0,0,0);
        if( pSFThread->SF_REJ_RETRY_COUNT < FC_MAX_PRLI_REJECT_RETRY )
        {
            fiSetEventRecord(eventRecord,thread,SFEventDoPrli);
        }
        else
        {
            fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliFailed);
        }
    }
}

/*+
  Function: SFActionPrliBadALPA
   Purpose: If we get a bad ALPA here its a qute trick since it takes microseconds
            from PLOGI to now. Device has failed.
 Called By: SFEventPrliBadALPA.
     Calls: fiTimerStop
            DevEventPrliFailed
-*/
/* SFStatePrliBadAlpa              10 */
extern void SFActionPrliBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogString(thread->hpRoot,
                    "%s  %X",
                    "SFActionPrliBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x",
                    "SFActionPrliBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliFailed);

}

/*+
  Function: SFActionPrliTimedOut
   Purpose: PRLI timeout state. If we get timed out retry upto FC_MAX_PRLI_REJECT_RETRY
            times.
 Called By: SFEventPrliTimedOut.
     Calls: fiTimerStop
            SFEventDoPrli
            DevEventPrliFailed
-*/
/* SFStatePrliTimedOut             11 */
extern void SFActionPrliTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot        = thread->hpRoot;
    SFThread_t * pSFThread   = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogString(thread->hpRoot,
                    "%s  %X AC %X",
                    "SFActionPrliTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( hpRoot ),0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x CcurSta %d RtryCnt %d",
                    "SFActionPrliTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    CThread_ptr(hpRoot)->thread_hdr.currentState,
                    pSFThread->SF_REJ_RETRY_COUNT,
                    0,0);

    fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "FM Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    pSFThread->SF_REJ_RETRY_COUNT +=1;
    if(pSFThread->SF_REJ_RETRY_COUNT > FC_MAX_PRLI_REJECT_RETRY || ! CFuncAll_clear( thread->hpRoot ) )
    {
        fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliFailed);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventDoPrli);
    }

}

/*+
  Function: SFActionDoFlogi
   Purpose: Does FLOGI. Terminating State. Set MYID register to enable area and domain use
            by channel.
 Called By: SFEventDoFlogi.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInFLOGI
            SF_IRB_Init
            osChipIOUpWriteBit32
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventFlogiTimedOut
-*/
/* SFStateDoFlogi                  12 */
extern void SFActionDoFlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot    = thread->hpRoot;
    CThread_t   * CThread  = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    os_bit32      SFS_Len   =0;

    WaitForERQ(hpRoot );

    SFS_Len = fiFillInFLOGI( pSFThread );

    CThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Fabric_F_Port,IRB_DCM);

    fiSetEventRecordNull(eventRecord);

    if (! CThread->InitAsNport)
    {
        CThread->ChanInfo.CurrentAddress.Domain = 0;
        CThread->ChanInfo.CurrentAddress.Area   = 1;
        /* Chip Bug:  Must have non-zero Domain||Area to force FLOGI to AL_PA '00' */
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, (fiComputeCThread_S_ID(CThread) ));
    }

#ifndef OSLayer_Stub
    CThread->SFpollingCount++;
    CThread->FLOGI_pollingCount++;
    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_FLOGI_TOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFlogiTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(CThread->HostCopy_ERQProdIndex,
            CThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,CThread,thread,DoFuncSfCmnd);

#endif  /* OSLayer_Stub */

    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "Out %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoFlogi",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeCThread_S_ID(CThread),
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionFlogiAccept
   Purpose: FLOGI  success state. Use Name server behavior. CActionDoFlogi detects 
            this state. fiLinkSvcProcess_FLOGI_Response_xxxCard processes this condition.
 Called By: SFEventFlogiAccept.
     Calls: fiTimerStop
-*/
/* SFStateFlogiAccept              13 */
extern void SFActionFlogiAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionFlogiAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);
}

/*+
  Function: SFActionFlogiRej
   Purpose: FLOGI  Rejected state.If we get rejected  switch did not "like" 
            some of our FLOGI parameters.CActionDoFlogi detects and adjusts 
            parameters acordingly
 Called By: SFEventFlogiRej
     Calls: fiTimerStop
-*/
/* SFStateFlogiRej                 14 */
extern void SFActionFlogiRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionFlogiRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionFlogiBadALPA
   Purpose: FLOGI  failed state. If we get Bad ALPA channel uses LOOP behavior.
 Called By: SFEventFlogiBadALPA.
     Calls: fiTimerStop
-*/
/* SFStateFlogiBadALPA             15 */
extern void SFActionFlogiBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionFlogiBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionFlogiTimedOut
   Purpose: FLOGI in unknown state. If we get here retry is our only option.
 Called By: SFEventFlogiTimedOut.
     Calls: fiTimerStop
-*/
/* SFStateFlogiTimedOut            16 */
extern void SFActionFlogiTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionFlogiTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

}

/*+
  Function: SFActionDoLogo
   Purpose: Does LOGO. Terminating State.
 Called By: SFEventDoLogo.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInLOGO
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventLogoTimedOut
-*/
/* SFStateDoLogo                  17 */
extern void SFActionDoLogo( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    DevThread_t *   pDevThread  = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoLogo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);

        WaitForERQ(hpRoot );

        SFS_Len = fiFillInLOGO( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventLogoTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {

         fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Logo CFunc_Queues_Frozen  Wrong LD %x IR %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    0,0, 0,0,0,0);

        fiSetEventRecord(eventRecord,thread,SFEventLogoTimedOut);
    }
}

/*+
  Function: SFActionLogoAccept
   Purpose: LOGO succeded. 
 Called By: SFEventLogoAccept.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoAccept              18 */
extern void SFActionLogoAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionLogoAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionLogoRej
   Purpose: LOGO failed but we were not logged in OK. 
 Called By: SFEventLogoRej.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoRej                 19 */
extern void SFActionLogoRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionLogoRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionLogoBadALPA
   Purpose: LOGO failed but device is gone OK. 
 Called By: SFEventLogoBadALPA.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoBadALPA             20 */
extern void SFActionLogoBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionLogoBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionLogoTimedOut
   Purpose: LOGO failed but assume device is gone. 
 Called By: SFEventLogoBadALPA.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoTimedOut            21 */
extern void SFActionLogoTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    /*+ Check This DRL possible problem in this case -*/
    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionLogoTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->LOOP_DOWN,
                    CThread_ptr(thread->hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(thread->hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(thread->hpRoot)->ERQ_FROZEN,
                    CThread_ptr(thread->hpRoot)->FCP_FROZEN,
                    CThread_ptr(thread->hpRoot)->ProcessingIMQ,
                    0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionDoPrlo
   Purpose: Does PRLO. Terminating State.
 Called By: None.
     Calls: WaitForERQ
            fiFillInPRLI
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoPrlo                   22 */
extern void SFActionDoPrlo( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;
    /*+ Check This DRL incomplete  -*/
    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);
    /* fiFillInPRLO( pSFThread ); */

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoPrlo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPrloTimedOut;


    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionPrloAccept
   Purpose: PRLO success. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloAccept               23 */
extern void SFActionPrloAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPrloAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPrloRej
   Purpose: PRLO failed. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloRej                  24 */
extern void SFActionPrloRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPrloRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPrloBadALPA
   Purpose: PRLO failed. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloBadALPA              25 */
extern void SFActionPrloBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPrloBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPrloTimedOut
   Purpose: PRLO failed. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloTimedOut             26 */
extern void SFActionPrloTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPrloTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionDoAdisc
   Purpose: Does ADISC. Terminating State.
 Called By: SFEventDoAdisc.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInAdisc
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventAdiscTimedOut
-*/
/* SFStateDoAdisc                  27 */
extern void SFActionDoAdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoAdisc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);



    if( CFuncAll_clear( hpRoot ) )
    {
        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        SFS_Len =fiFillInADISC( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventAdiscTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );
#ifndef OSLayer_Stub

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventAdiscAccept);
#endif /* OSLayer_Stub */

    }

    else
    {
         fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Adisc CFunc_Queues_Frozen  Wrong LD %x IR %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    0,0, 0,0,0,0);

        fiSetEventRecord(eventRecord,thread,SFEventAdiscTimedOut);
    }

}

/*+
  Function: SFActionAdiscAccept
   Purpose: ADISC succeseful. Device address verified
 Called By: SFEventAdiscAccept.
     Calls: fiTimerStop
            DevEventAdiscDone_OK
-*/
/* SFStateAdiscAccept              28 */
extern void SFActionAdiscAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionAdiscAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_OK);
}

/*+
  Function: SFActionAdiscRej
   Purpose: ADISC failed. Device address is valid but login required.
            This will occur if to much time has elasped from link event 
            to ADISC attempt.
 Called By: SFEventAdiscRej.
     Calls: fiTimerStop
            DevEventAdiscDone_FAIL_ReLogin
-*/
/* SFStateAdiscRej                 29 */
extern void SFActionAdiscRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x X_ID %X",
                    "SFActionAdiscRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    pSFThread->X_ID,
                    0,0,0,0);



    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_FAIL_ReLogin);
}

/*+
  Function: SFActionAdiscBadALPA
   Purpose: ADISC failed. Device address is no longer valid.
 Called By: SFEventAdiscBadALPA.
     Calls: fiTimerStop
            DevEventAdiscDone_FAIL_No_Device
-*/
/* SFStateAdiscBadALPA             30 */
extern void SFActionAdiscBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionAdiscBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_FAIL_No_Device);

}

/*+
  Function: SFActionAdiscTimedOut
   Purpose: ADISC failed. Device address is treated as if it is no longer valid.
 Called By: SFEventAdiscTimedOut.
     Calls: fiTimerStop
            DevEventAdiscDone_FAIL_No_Device
-*/
/* SFStateAdiscTimedOut            31 */
extern void SFActionAdiscTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d SFcnt %x DCnt %x ACnt X_ID %X",
                    "SFActionAdiscTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    CThread_ptr(thread->hpRoot)->ADISC_pollingCount,
                    pSFThread->X_ID,
                    0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_FAIL_No_Device);
}

/*+
  Function: SFActionDoPdisc
   Purpose: Should do pdisc. Terminating State.
 Called By: None.
     Calls: WaitForERQ
            fiFillInLOGO
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventLogoTimedOut
-*/
/* SFStateDoPdisc                  32 */
extern void SFActionDoPdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;


    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);
    /* fiFillInPDISC( pSFThread ); */

    pCThread = CThread_ptr(hpRoot );

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    fiLogDebugString( hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoPdisc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPdiscTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionPdiscAccept
   Purpose: Pdisc successfull. 
 Called By: SFEventPdiscAccept
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePdiscAccept              33 */
extern void SFActionPdiscAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPdiscAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPdiscRej
   Purpose: Pdisc failed. 
 Called By: SFEventPdiscRej
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePdiscRej                 34 */
extern void SFActionPdiscRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );


    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPdiscRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPdiscBadALPA
   Purpose: Pdisc failed. 
 Called By: SFEventPdiscBadALPA
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePdiscBadALPA             35 */
extern void SFActionPdiscBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPdiscBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPdiscTimedOut
   Purpose: Pdisc failed. 
 Called By: SFEventPdiscBadTimedOut
     Calls: SFEventReset
-*/
/* SFStatePdiscTimedOut            36 */
extern void SFActionPdiscTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPdiscTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionDoAbort
   Purpose: Does ABTS. Terminating State. Aborts the Parent threads X_ID. Abort
            is used to discontue X_ID proccessing.
 Called By: SFEventDoAbort.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInABTS
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventAbortTimedOut
-*/
/* SFStateDoAbort                  37 */
extern void SFActionDoAbort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot    = thread->hpRoot;
    CThread_t       * pCThread  = CThread_ptr(hpRoot);
    SFThread_t      * pSFThread = (SFThread_t * )thread;
    os_bit32 SFS_Len               = 0;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogConsoleLevelOne,
                      "In %s - State = %d (%p)",
                      "SFActionDoAbort",(char *)agNULL,
                      pSFThread,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    WaitForERQ(hpRoot );

    SFS_Len = fiFillInABTS( pSFThread );

    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.CDB->Device),IRB_DCM);

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventAbortTimedOut;

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );
#ifndef OSLayer_Stub

    ROLL(pCThread->HostCopy_ERQProdIndex,
        pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
    fiSetEventRecord(eventRecord,thread,SFEventAbortAccept);
#endif /* OSLayer_Stub */

    fiLogDebugString(thread->hpRoot,
                  SFStateLogConsoleLevelOne,
                  "Started  %s - State = %d (%p) Class %x Type %x State %x",
                  "SFActionDoAbort",(char *)agNULL,
                  pSFThread,(void *)agNULL,
                  (os_bit32)thread->currentState,
                  (os_bit32)pSFThread->SF_CMND_Class,
                  (os_bit32)pSFThread->SF_CMND_Type,
                  (os_bit32)pSFThread->SF_CMND_State,
                  0,0,0,0);
}

/*+
  Function: SFActionAbortAccept
   Purpose: ABTS successful. The device has aknowledged the X_ID as
            1) Known to the device.
            2) All further proccessing of X_ID is stopped
 Called By: SFEventAbortAccept.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortAccept              38 */
extern void SFActionAbortAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t      * pSFThread     = (SFThread_t * )thread;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )pSFThread->parent.CDB;

    fiTimerStop(&pSFThread->Timer_Request );
    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAborted;
    }

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d (%p) X_ID %X CDBState %d",
                      "SFActionAbortAccept",(char *)agNULL,
                      thread,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      pCDBThread->X_ID,
                      pCDBThread->thread_hdr.currentState,
                      0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);
}

/*+
  Function: SFActionAbortRej
   Purpose: ABTS failed. The device has denies knowledged of the X_ID.
 Called By: SFEventAbortRej.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortRej                 39 */
extern void SFActionAbortRej( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t      * pSFThread     = (SFThread_t * )thread;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )pSFThread->parent.CDB;

    fiTimerStop(&pSFThread->Timer_Request );
    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAbortFailed;
    }

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionAbortRej",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);
    /*
    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEvent_Abort_Rejected);
    */
    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);
}

/*+
  Function: SFActionAbortBadALPA
   Purpose: ABTS failed. The device is gone.
 Called By: SFEventAbortBadALPA.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortBadALPA             40 */
extern void SFActionAbortBadALPA( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t      * pSFThread     = (SFThread_t * )thread;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )pSFThread->parent.CDB;

    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAbortFailed;
    }
    fiTimerStop(&pSFThread->Timer_Request );
    /*+ Check This DRL If we get bad alpa device is gone -*/
    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionAbortBadALPA",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);

}

/*+
  Function: SFActionAbortTimedOut
   Purpose: ABTS failed. The exchange has problems.
 Called By: SFEventAbortTimedOut.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortTimedOut            41 */
extern void SFActionAbortTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t * )pSFThread->parent.CDB;

    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAbortFailed;
    }
    /*+ Check This DRL is this the right thing to do ? -*/
    fiLogDebugString(thread->hpRoot,
                        SFStateLogErrorLevel,
                        "In %s - State = %d X_ID %X",
                        "SFActionAbortTimedOut",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                       (os_bit32)thread->currentState,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);

}

/*+
  Function: SFActionDoResetDevice
   Purpose: Does Task Management Reset for device. Terminating State.
 Called By: SFEventDoResetDevice.
     Calls: WaitForERQ
            fiFillInTargetReset
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventResetDeviceTimedOut
-*/
/* SFStateDoResetDevice                  42 */
extern void SFActionDoResetDevice( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    DevThread_t *   pDevThread  = pSFThread->parent.Device;
    os_bit32           RD_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d CCnt %x DCnt %x DCur %d",
                        "SFActionDoResetDevice",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->SFpollingCount,
                        pDevThread->pollingCount,
                        pDevThread->thread_hdr.currentState,
                        0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        RD_Len = fiFillInTargetReset(pSFThread);
        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, RD_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventResetDeviceTimedOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV / 2 );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

#ifndef OSLayer_Stub

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventResetDeviceAccept);
#endif /* OSLayer_Stub */

    }
    else
    {

         fiLogDebugString(hpRoot ,
                        SFStateLogErrorLevel,
                        "%s Queues_Frozen - AL_PA %X FM Status %08X TL Status %08X CState %d",
                        "SFActionDoResetDevice",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0);

        fiLogDebugString(hpRoot,
                        SFStateLogErrorLevel,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);

        fiSetEventRecord(eventRecord,thread,SFEventResetDeviceTimedOut);
    }
}

/*+
  Function: SFActionResetDeviceAccept
   Purpose: Task Management Reset successfull. 
 Called By: SFEventResetDeviceAccept.
     Calls: fiTimerStop
            DevEventDeviceResetDone
-*/
/* SFActionResetDeviceAccept              43 */
extern void SFActionResetDeviceAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogConsoleLevelOne,
                      "In %s - State = %d",
                      "SFActionResetDeviceAccept",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
}

/*+
  Function: SFActionResetDeviceRej
   Purpose: Task Management Reset failed. 
 Called By: SFEventResetDeviceRej.
     Calls: fiTimerStop
            DevEventDeviceResetDoneFail
-*/
/* SFStateResetDeviceRej                 44 */
extern void SFActionResetDeviceRej( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionResetDeviceRej",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDoneFail);
}

/*+
  Function: SFActionResetDeviceBadALPA
   Purpose: Task Management Reset failed. Device is gone. 
 Called By: SFEventResetDeviceRej.
     Calls: fiTimerStop
            DevEventDeviceResetDoneFail
-*/
/* SFStateResetDeviceBadALPA             45 */
extern void SFActionResetDeviceBadALPA( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionResetDeviceBadALPA",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDoneFail);
}

/*+
  Function: SFActionResetDeviceTimedOut
   Purpose: Task Management Reset failed. Exchange had problems. 
 Called By: SFEventResetDeviceTimedOut.
     Calls: fiTimerStop
            DevEventDeviceResetDoneFail
-*/
/* SFStateResetDeviceTimedOut            46 */
extern void SFActionResetDeviceTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    /*+ Check This DRL if we get here did reset happen or not ? -*/
    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionResetDeviceTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDoneFail);

}

/*+
  Function: SFActionDoLS_RJT
   Purpose: Does Link services reject. Terminating State.
 Called By: SFEventDoResetDevice.
     Calls: WaitForERQ
            fiFillInLS_RJT
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventLS_RJT_Done
-*/
/* SFStateActionDoLS_RJT                  47 */
extern void SFActionDoLS_RJT( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoLS_RJT",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    pCThread->SFpollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInLS_RJT(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT),
                             FC_ELS_LS_RJT_Command_Not_Supported | FC_ELS_LS_RJT_Request_Not_Supported
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventLS_RJT_Done);
    }
}

/*+
  Function: SFActionLS_RJT_Done
   Purpose: Link services reject done. Target mode command
 Called By: SFEventLS_RJT_Done.
     Calls: TgtEventPLOGI_RJT_ReplyDone
-*/
/* SFStateLS_RJT_Done              48 */
extern void SFActionLS_RJT_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionLS_RJT_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_RJT_ReplyDone);
}

/*+
  Function: SFActionDoPlogiAccept
   Purpose: Does PLOGI accept. If another device does PLOGI accept it. 
            Terminating State.
 Called By: TgtEventPLOGI_ACC_Reply.
     Calls: WaitForERQ
            fiFillInPLOGI_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPlogiAccept_TimeOut
-*/
/* SFStateDoPlogiAccept   49 */
extern void SFActionDoPlogiAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogErrorLevel,
                        "In %s (%p) - State = %d ",
                        "SFActionDoPlogiAccept",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInPLOGI_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPlogiAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );


        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {

       fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "%s AC %X",
                    "SFEventPlogiAccept_TimeOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CFuncAll_clear( hpRoot ),
                    0,0,0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,SFEventPlogiAccept_TimeOut);

    }
}

/*+
  Function: SFActionPlogiAccept_Done
   Purpose: PLOGI accept done. Target mode command
 Called By: SFEventLS_RJT_Done.
     Calls: fiTimerStop
            TgtEventPLOGI_ACC_ReplyDone
-*/
/* SFStatePlogiAccept_Done              50 */
extern void SFActionPlogiAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPlogiAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_ACC_ReplyDone);
}

/*+
  Function: SFActionDoPrliAccept
   Purpose: Does PRLI accept. If another device does PRLI to us accept it. 
            Terminating State.
 Called By: TgtEventPRLI_ACC_Reply.
     Calls: WaitForERQ
            fiFillInPRLI_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPrliAccept_TimeOut
-*/
/* SFStateDoPrliAccept   51 */
extern void SFActionDoPrliAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoPrliAccept",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }



    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {
        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInPRLI_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPrliAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventPrliAccept_TimeOut);
    }
}

/*+
  Function: SFActionPrliAccept_Done
   Purpose: PRLI accept done. Target mode command
 Called By: SFEventPrliAccept_Done.
     Calls: fiTimerStop
            TgtEventPRLI_ACC_ReplyDone
-*/
/* SFStatePrliAccept_Done              52 */
extern void SFActionPrliAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPrliAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPRLI_ACC_ReplyDone);
}

/*+
  Function: SFActionDoELSAccept
   Purpose: Does generic accept. If another device does ELS to us accept it. 
            Terminating State.
 Called By: TgtActionLOGO_ACC_Reply.
     Calls: WaitForERQ
            fiFillInELS_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventELSAccept_TimeOut
-*/
/* SFStateDoELSAccept   53 */
extern void SFActionDoELSAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogErrorLevel,
                        "In %s (%p) - State = %d ",
                        "SFActionDoELSAccept",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }



    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInELS_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventELSAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventELSAccept_TimeOut);
    }
}

/*+
  Function: SFActionELSAccept_Done
   Purpose: Extended link services accept done. Target mode command
 Called By: SFEventELSAccept_Done.
     Calls: fiTimerStop
            TgtEventELS_ACC_ReplyDone
-*/
/* SFStateELSAccept_Done              54 */
extern void SFActionELSAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionELSAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventELS_ACC_ReplyDone);
}

/*+
  Function: SFActionDoFCP_DR_ACC_Reply
   Purpose: Does device reset accept. If another device does device reset accept it. 
            Terminating State.
 Called By: None.
     Calls: WaitForERQ
            fiFillInADISC_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventFCP_DR_ACC_Reply_TimeOut
-*/
/* SFStateDoFCP_DR_ACC_Reply   55 */
extern void SFActionDoFCP_DR_ACC_Reply( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;
    FC_FCP_RSP_Payload_t  Payload;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoFCP_DR_ACC_Reply",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    Payload.Reserved_Bit32_0 = 0;
    Payload.Reserved_Bit32_1 = 0;
    Payload.FCP_RESID        = 0;
    Payload.FCP_SNS_LEN      = 0;
    Payload.FCP_RSP_LEN      = 0;

    Payload.FCP_STATUS.Reserved_Bit8_0 = 0;
    Payload.FCP_STATUS.Reserved_Bit8_1 = 0;
    Payload.FCP_STATUS.ValidityStatusIndicators = 0;
    Payload.FCP_STATUS.SCSI_status_byte = 0;

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInFCP_RSP_IU(pSFThread,
                                pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                                ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT),
                                FC_FCP_RSP_Payload_t_SIZE,
                                &Payload
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFCP_DR_ACC_Reply_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventFCP_DR_ACC_Reply_TimeOut);

    }
}

/*+
  Function: SFActionFCP_DR_ACC_Reply_Done
   Purpose: Task management reset accept reply done. Target mode command
 Called By: SFEventFCP_DR_ACC_Reply_Done.
     Calls: fiTimerStop
            TgtEventFCP_DR_ACC_ReplyDone
-*/
/* SFStateFCP_DR_ACC_Reply_Done         56             */
extern void SFActionFCP_DR_ACC_Reply_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogConsoleLevelOne,
                      "In %s - State = %d",
                      "SFActionFCP_DR_ACC_Reply_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventFCP_DR_ACC_ReplyDone);
}

/*+
  Function: SFActionLS_RJT_TimeOut
   Purpose: Link services reject timedout. Target mode command
 Called By: SFEventPlogiAccept_TimeOut.
     Calls: TgtEventPLOGI_RJT_ReplyDone
-*/
/*  SFStateLS_RJT_TimeOut       57       */
extern void SFActionLS_RJT_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionLS_RJT_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);
    /*+ Check This DRL is this right ? -*/
    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_RJT_ReplyDone);
}

/*+
  Function: SFActionPlogiAccept_TimeOut
   Purpose: PLOGI accept timedout. Target mode command
 Called By: SFEventPlogiAccept_TimeOut.
     Calls: TgtEventPLOGI_ACC_ReplyDone
-*/
/*  SFStatePlogiAccept_TimeOut           58               */
extern void SFActionPlogiAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPlogiAccept_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_ACC_ReplyDone);
}

/*+
  Function: SFActionPrliAccept_TimeOut
   Purpose: PRLI accept timedout. Target mode command
 Called By: SFEventPrliAccept_TimeOut.
     Calls: TgtEventPRLI_ACC_ReplyDone
-*/
/* SFStatePrliAccept_TimeOut            59              */
extern void SFActionPrliAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPrliAccept_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPRLI_ACC_ReplyDone);
}

/*+
  Function: SFActionELSAccept_TimeOut
   Purpose: Extended link services accept timedout. Target mode command
 Called By: SFEventPlogiAccept_TimeOut.
     Calls: TgtEventPRLI_ACC_ReplyDone
-*/
/*  SFStateELSAccept_TimeOut            60             */
extern void SFActionELSAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionELSAccept_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventELS_ACC_ReplyDone);
}

/*+
  Function: SFActionFCP_DR_ACC_Reply_TimeOut
   Purpose: Task manangment reset timedout. Target mode command
 Called By: SFEventFCP_DR_ACC_Accept_TimeOut.
     Calls: TgtEventFCP_DR_ACC_ReplyDone
-*/
/*  SFStateFCP_DR_ACC_Reply_TimeOut      61              */
extern void SFActionFCP_DR_ACC_Reply_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    TgtThread_t * pTgtThread =  pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionFCP_DR_ACC_Reply_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventFCP_DR_ACC_ReplyDone);
}

#ifdef NAME_SERVICES
/*+
  Function: SFActionDoRFT_ID
   Purpose: Does Name server Register FC-4 types (RFT_ID). Terminating State.
 Called By: SFEventDoRFT_ID.
     Calls: WaitForERQ
            fiFillInRFT_ID
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventRFT_IDTimedOut
-*/
/* SFStateDoRFT_ID                  62 */
extern void SFActionDoRFT_ID( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot    = thread->hpRoot;
    CThread_t   * pCThread  = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    os_bit32         SFS_Len   =0;

    WaitForERQ(hpRoot );

    SFS_Len = fiFillInRFT_ID( pSFThread );

#ifdef BROCADE_BUG
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, 0xfffc41,IRB_DCM);
#else /* BROCADE_BUG */
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Directory_Server,IRB_DCM);
#endif /* BROCADE_BUG */
    fiSetEventRecordNull(eventRecord);

#ifndef OSLayer_Stub
    pCThread->SFpollingCount++;

    pCThread->Fabric_pollingCount++;

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventRFT_IDTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#endif  /* OSLayer_Stub */
    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "In %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoRFT_ID",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    (fiComputeCThread_S_ID(pCThread) | 0x100),0,0,0,0,0,0);
}

/*+
  Function: SFActionRFT_IDAccept
   Purpose: Name server Register FC-4 types (RFT_ID) successfull
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDAccept
     Calls: fiTimerStop
-*/
/* SFStateRFT_IDAccept              63 */
extern void SFActionRFT_IDAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionRFT_IDAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionRFT_IDRej
   Purpose: Name server Register FC-4 types (RFT_ID) rejected.
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDRej
     Calls: fiTimerStop
-*/
/* SFStateRFT_IDRej                 64 */
extern void SFActionRFT_IDRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionRFT_IDRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionRFT_IDBadALPA
   Purpose: Name server Register FC-4 types (RFT_ID) failed because switch disapeared.
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDBadALPA
     Calls: fiTimerStop
-*/
/* SFStateRFT_IDBadALPA             65 */
extern void SFActionRFT_IDBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionRFT_IDBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionRFT_IDTimedOut
   Purpose: Name server Register FC-4 types (RFT_ID) failed.
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDBadALPA
     Calls: 
-*/
/* SFStateRFT_IDTimedOut            66 */
extern void SFActionRFT_IDTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionRFT_IDTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

}

/*+
  Function: SFActionDoGID_FT
   Purpose: Does Get Port Identifiers (GID_FT). Terminating State. 
 Called By: SFEventDoGID_FT in CActionDoGID_FT
     Calls: WaitForERQ
            fiFillInGID_FT
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoGID_ID                  67 */
extern void SFActionDoGID_FT( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot    = thread->hpRoot;
    CThread_t   * pCThread  = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    os_bit32         SFS_Len   =0;


    WaitForERQ(hpRoot );

    SFS_Len = fiFillInGID_FT( pSFThread );

#ifdef BROCADE_BUG
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, 0xfffc41,IRB_DCM);
#else /* BROCADE_BUG */
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Directory_Server,IRB_DCM);
#endif /* BROCADE_BUG */

    fiSetEventRecordNull(eventRecord);
#ifndef OSLayer_Stub
    pCThread->SFpollingCount++;
    pCThread->Fabric_pollingCount++;

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventGID_FTTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#endif /* OSLayer_Stub */
    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "In %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoGID_FT",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    (fiComputeCThread_S_ID(pCThread) | 0x100),0,0,0,0,0,0);
}

/*+
  Function: SFActionGID_FTAccept
   Purpose: Get Port Identifiers (GID_FT) successful. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTAccept.
     Calls: fiTimerStop
-*/
/* SFStateGID_FTAccept              68 */
extern void SFActionGID_FTAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionGID_FTAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionGID_FTRej
   Purpose: Get Port Identifiers (GID_FT) failed. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTRej.
     Calls: fiTimerStop
-*/
/* SFStateGID_FTRej                 69 */
extern void SFActionGID_FTRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionGID_FTRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionGID_FTBadALPA
   Purpose: Get Port Identifiers (GID_FT) failed. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTBadALPA.
     Calls: fiTimerStop
-*/
/* SFStateGID_FTBadALPA             70 */
extern void SFActionGID_FTBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionGID_FTBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionGID_FTTimedOut
   Purpose: Get Port Identifiers (GID_FT) failed. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTTimedOut
     Calls: fiTimerStop
-*/
/* SFStateGID_FTTimedOut            71 */
extern void SFActionGID_FTTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionGID_FTTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

}

/*+
  Function: SFActionDoSCR
   Purpose: Does Name server State Change Register (SCR). Terminating State.
            CActionDoSCR starts this proccess.
 Called By: SFEventDoSCR.
     Calls: WaitForERQ
            fiFillInSCR
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventRFT_IDTimedOut
-*/
/* SFStateDoSCR              72 */
extern void SFActionDoSCR( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t     * hpRoot    = thread->hpRoot;
    CThread_t    * pCThread  = CThread_ptr(hpRoot);
    SFThread_t   * pSFThread = (SFThread_t * )thread;
    os_bit32      SFS_Len    = 0;


    WaitForERQ(hpRoot );

    SFS_Len = fiFillInSCR( pSFThread );

    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Fabric_Controller,IRB_DCM);

    fiSetEventRecordNull(eventRecord);
#ifndef OSLayer_Stub
    pCThread->SFpollingCount++;
    pCThread->Fabric_pollingCount++;
    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventSCRTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#endif /* OSLayer_Stub */


    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "In %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoSCR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    (fiComputeCThread_S_ID(pCThread) | 0x100),0,0,0,0,0,0);



}

/*+
  Function: SFActionSCRAccept
   Purpose: Name server State Change Register (SCR) was successful. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRAccept
     Calls: fiTimerStop
-*/
/* SFStateSCRAccept              73 */
extern void SFActionSCRAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionSCRAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionSCRRej
   Purpose: Name server State Change Register (SCR) failed. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRRej
     Calls: fiTimerStop
-*/
/* SFStateSCRRej                 74 */
extern void SFActionSCRRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionSCRRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionSCRBadALPA
   Purpose: Name server State Change Register (SCR) failed. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRBadALPA
     Calls: fiTimerStop
-*/
/* SFStateSCRBadALPA             75 */
extern void SFActionSCRBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionSCRBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionSCRTimedOut
   Purpose: Name server State Change Register (SCR) failed. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRTimedOut
     Calls: 
-*/
/* SFStateSCRTimedOut            76 */
extern void SFActionSCRTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionSCRTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

}

#endif /* NAME_SERVICES */

/****************** FC Tape ******************************************/

/*+
  Function: SFActionDoSRR
   Purpose: Does Sequence Retransmission Request (SRR). FC Tape. Terminating State.
 Called By: SFEventDoSRR.
     Calls: WaitForERQ
            fiFillInSRR
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoSRR                  77 */
extern void SFActionDoSRR( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;
/*    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;
*/
    os_bit32 SFS_Len = 0;
    os_bit32 RO=0;
/* Gets rejected    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Solicited_Data >> FCHS_R_CTL_SHIFT;
*/
/*
    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Solicited_Data >> FCHS_R_CTL_SHIFT;  Freaks out !

    os_bit32 R_CTL=  FC_Frame_Header_R_CTL_Lo_Unsolicited_Data >> FCHS_R_CTL_SHIFT; Rejected !

    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Unsolicited_Command >> FCHS_R_CTL_SHIFT; Rejected !

    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Solicited_Data >> FCHS_R_CTL_SHIFT;  Send data back !

 FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame                   0x00000000
 FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame                 0x20000000
 FC_Frame_Header_R_CTL_Hi_FC_4_Link_Data_Frame                     0x30000000
 FC_Frame_Header_R_CTL_Hi_Video_Data_Frame                         0x40000000
 FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame                    0x80000000 fc4link data reply - rej !
 FC_Frame_Header_R_CTL_Hi_Link_Control_Frame                       0xC0000000



 FC_Frame_Header_R_CTL_Lo_Uncategorized_Information                0x00000000
 FC_Frame_Header_R_CTL_Lo_Solicited_Data                           0x01000000 Send data back ! DATA
 FC_Frame_Header_R_CTL_Lo_Unsolicited_Control                      0x02000000 Rejected !
 FC_Frame_Header_R_CTL_Lo_Solicited_Control                        0x03000000
 FC_Frame_Header_R_CTL_Lo_Unsolicited_Data                         0x04000000 Send data back !
 FC_Frame_Header_R_CTL_Lo_Data_Descriptor                          0x05000000 XFER RDY
 FC_Frame_Header_R_CTL_Lo_Unsolicited_Command                      0x06000000 Rejected !
 FC_Frame_Header_R_CTL_Lo_Command_Status                           0x07000000 RSP


*/

    os_bit32 OXID;
    os_bit32 RXID;
    os_bit32 R_CTL;

    R_CTL = FC_Frame_Header_R_CTL_Lo_Data_Descriptor | FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame;

    R_CTL >>= FCHS_R_CTL_SHIFT;


    OXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);


    SFS_Len = fiFillInSRR( pSFThread, OXID, RXID, RO, R_CTL);

    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pDevThread),IRB_DCM);

    /* OXID, RXID, Relative offset and R_CTL all need to be passed through the SF Thread or associated CDBThread
      For now, this is going to be all zeros */


    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    fiSetEventRecordNull(eventRecord);

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X SF XID %08X",
                    "SFActionDoSRR",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    pSFThread->X_ID,
                    0,0,0);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventSRRTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );
    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

}

/*+
  Function: SFActionSRRAccept
   Purpose: Sequence Retransmission Request (SRR) successful. FC Tape.
 Called By: SFEventSRRAccept.
     Calls: fiTimerStop
            CDBEventSendSRR_Success
-*/
/* SFStateSRRAccept              78 */
extern void SFActionSRRAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X",
                    "SFActionSRRAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Success);

}

/*+
  Function: SFActionSRRRej
   Purpose: Sequence Retransmission Request (SRR) failed. FC Tape.
 Called By: SFEventSRRRej.
     Calls: fiTimerStop
            CDBEventSendSRR_Fail
-*/
/* SFStateSRRRej                 79 */
extern void SFActionSRRRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X",
                    "SFActionSRRRej",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Fail);
}

/*+
  Function: SFActionSRRBadALPA
   Purpose: Sequence Retransmission Request (SRR) failed. FC Tape.
 Called By: SFEventSRRBadALPA.
     Calls: fiTimerStop
            CDBEventSendSRR_Fail
-*/
/* SFStateSRRBadALPA             80 */
extern void SFActionSRRBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X",
                    "SFActionSRRBadALPA",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Fail);
}

/*+
  Function: SFActionSRRTimedOut
   Purpose: Sequence Retransmission Request (SRR) failed. FC Tape.
 Called By: SFEventSRRRej.
     Calls: fiTimerStop
            CDBEventSendSRR_Fail
-*/
/* SFStateSRRTimedOut            81 */
extern void SFActionSRRTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionSRRTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Fail);
}

/*+
  Function: SFActionDoREC
   Purpose: Does Read Exchange Concise. Terminating State. FC Tape
            REC is done for IOs on FC Tape device that have timed out. 
 Called By: SFEventDoREC.
     Calls: WaitForERQ
            fiFillInREC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoREC                  82 */
extern void SFActionDoREC( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;
    os_bit32 SFS_Len = 0;
    os_bit32 OXID;
    os_bit32 RXID;

    OXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    /* OXID and RXID Should be gotten from the CDBThread */
    SFS_Len = fiFillInREC( pSFThread, OXID, RXID );

    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pDevThread),IRB_DCM);


    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X SF XID %08X",
                    "SFActionDoREC",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    pSFThread->X_ID,
                    0,0,0);

    fiSetEventRecordNull(eventRecord);

    ROLL(pCThread->HostCopy_ERQProdIndex,
        pCThread->Calculation.MemoryLayout.ERQ.elements);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_RECTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventRECTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );
    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

}

/*+
  Function: SFStateRECAccept
   Purpose: Read Exchange Concise successful. FC Tape
            If the REC is accepted the device has aknowledged the X_ID is
            currently active.
 Called By: SFEventRECAccept.
     Calls: fiTimerStop
            CDBEventSendREC_Success
-*/
/* SFStateRECAccept              83 */
extern void SFActionRECAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Success);
}

/*+
  Function: SFActionRECRej
   Purpose: Read Exchange Concise failed. FC Tape
            If the REC is rejected the device does not aknowledged the X_ID is
            currently active.
 Called By: SFEventRECRej.
     Calls: fiTimerStop
            CDBEventSendREC_Fail
-*/
/* SFStateRECRej                 84 */
extern void SFActionRECRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );


    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECRej",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Fail);
}

/*+
  Function: SFActionRECBadALPA
   Purpose: Read Exchange Concise failed. FC Tape
            The device is missing.
 Called By: SFEventRECBadALPA.
     Calls: fiTimerStop
            CDBEventSendREC_Fail
-*/
/* SFStateRECBadALPA             85 */
extern void SFActionRECBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;
    /*+ Check This DRL if the device is gone is this the right thing to do ? -*/
    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECBadALPA",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Fail);
}

/*+
  Function: SFActionRECTimedOut
   Purpose: Read Exchange Concise failed. FC Tape
            This exchange has a problem.
 Called By: SFEventRECTimedOut.
     Calls: fiTimerStop
            CDBEventSendREC_Fail
-*/
/* SFStateRECTimedOut            86 */
extern void SFActionRECTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECTimedOut",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Fail);
}

/******************End FC Tape ******************************************/

/*+
  Function: SFActionDoADISCAccept
   Purpose: Does ADISC accept. If another device does ADISC accept it. Terminating State.
 Called By: SFEventDoADISCAccept.
     Calls: WaitForERQ
            fiFillInADISC_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoADISCAccept   87 */
extern void SFActionDoADISCAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot      = thread->hpRoot;
    SFThread_t  * pSFThread   = (SFThread_t * )thread;
    TgtThread_t * pTgtThread  = pSFThread->parent.Target;
    os_bit32      Cmd_Len     = 0;


    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "In %s (%p) - State = %d ",
                    "SFActionDoADISCAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    if(ERQ_FULL(CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
                CThread_ptr(hpRoot)->FuncPtrs.GetERQConsIndex(hpRoot ),
                CThread_ptr(hpRoot)->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
                    CThread_ptr(hpRoot)->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    CThread_ptr(hpRoot)->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInADISC_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );

        CThread_ptr(hpRoot)->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFStateADISCAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
            CThread_ptr(hpRoot)->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,CThread_ptr(hpRoot),thread,DoFuncSfCmnd);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventADISCAccept_TimeOut);
    }
}

/*+
  Function: SFActionADISCAccept_Done
   Purpose: ADISC accept was successfull.
 Called By: SFEventADISCAccept_Done.
     Calls: fiTimerStop
            TgtEventADISC_ReplyDone
-*/
/* SFStateADISCAccept_Done              88 */
extern void SFActionADISCAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionELSAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventADISC_ReplyDone);
}

/*+
  Function: SFActionADISCAccept_TimeOut
   Purpose: ADISC accept failed.
 Called By: SFEventADISCAccept_Done.
     Calls: TgtEventADISC_ReplyDone
-*/
/*  SFStateADISCAccept_TimeOut            89 */
extern void SFActionADISCAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionELSAccept_TimeOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventADISC_ReplyDone);
}

#ifdef _DvrArch_1_30_

/*+
  Function: SFActionDoFarpRequest
   Purpose: Does Fibre Channel Address Resolution Protocol. Terminating State. IP interface
 Called By: fiFillInFARP_REQ_OffCard.
     Calls: WaitForERQ
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventFarpRequestTimedOut
-*/
/* SFStateDoFarp                  90 */
extern void SFActionDoFarpRequest( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t *)thread;
    os_bit32        SFS_Len     = 0;

    fiLogDebugString(hpRoot,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d X_ID %X CCnt %x",
                    "SFActionDoFarpRequest",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pSFThread->X_ID,pCThread->SFpollingCount,0,0,0,0,0);

    pCThread->SFpollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);

        WaitForERQ(hpRoot );
        /*+ Check This DRL Need function pointer and oncard version -*/
        SFS_Len = fiFillInFARP_REQ_OffCard( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeBroadcast_D_ID(pCThread), IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFarpRequestTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);
    }
    else
    {

         fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "Farp CFunc_Queues_Frozen  Wrong LD %x IR %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    0,0, 0,0,0,0);

         fiSetEventRecord(eventRecord,thread,SFEventFarpRequestTimedOut);
    }
}

/*+
  Function: SFActionFarpRequestDone
   Purpose: Fibre Channel Address Resolution Protocol successful. IP interface
 Called By: fiFillInFARP_REQ_OffCard.
     Calls: fiTimerStop
            PktEventFarpSuccess
-*/
/* SFStateFarpRequestDone                91 */
extern void SFActionFarpRequestDone( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    PktThread_t *   pPktThread  = pSFThread->parent.IPPkt;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionFarpRequestDone",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    fiSendEvent(&pPktThread->thread_hdr,PktEventFarpSuccess);
}

/*+
  Function: SFActionFarpRequestTimedOut
   Purpose: Fibre Channel Address Resolution Protocol. IP interface
 Called By: fiFillInFARP_REQ_OffCard.
     Calls: none
-*/
/*  SFStateFarpRequestTimedOut           92 */
extern void SFActionFarpRequestTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionFarpRequestTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionDoFarpReply
   Purpose: Reply to external Fibre Channel Address Resolution Protocol. IP interface
 Called By: ?.
     Calls: none
-*/
/*  SFStateDoFarpReply                   93 */
extern void SFActionDoFarpReply( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32        Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoFarpReply",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInFARP_REPLY_OffCard( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFarpReplyTimedOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventFarpReplyTimedOut);
    }
}

/*+
  Function: SFActionFarpReplyDone
   Purpose: Reply to external Fibre Channel Address Resolution Protocol reply sent. IP interface
 Called By: ?.
     Calls: TgtEventFARP_ReplyDone
-*/
/*  SFStateFarpReplyDone                 94 */
extern void SFActionFarpReplyDone( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionFarpReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventFARP_ReplyDone);
}

#endif /* _DvrArch_1_30_ was defined */

/*+
  Function: SFFuncIRB_OffCardInit
   Purpose: Initialize off card (system memory) Io request block
 Called By: All sfaction do routines. When system memory is used.
     Calls: none
-*/
void SFFuncIRB_OffCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit)
{
#ifndef __MemMap_Force_On_Card__
    CThread_t                  *CThread = CThread_ptr(SFThread->thread_hdr.hpRoot);
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    IRB_t                      *pIrb;

    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    pIrb += CThread->HostCopy_ERQProdIndex;

#ifdef _DvrArch_1_30_
    pIrb->Req_A.Bits__SFS_Len   = SFS_Len | IRB_SFA | DCM_Bit |
            ((D_ID & 0xff) == 0xff ? IRB_BRD : 0);
#else /* _DvrArch_1_30_ was not defined */
    pIrb->Req_A.Bits__SFS_Len   = SFS_Len | IRB_SFA | DCM_Bit;
#endif /* _DvrArch_1_30_ was not defined */
    pIrb->Req_A.SFS_Addr        = SFThread->SF_CMND_Lower32;
    pIrb->Req_A.D_ID             = D_ID << IRB_D_ID_SHIFT;
    pIrb->Req_A.MBZ__SEST_Index__Trans_ID = SFThread->X_ID;
    pIrb->Req_B.Bits__SFS_Len = 0;

/*
    fiLogDebugString(hpRoot,
                      SFStateLogErrorLevel,
                      "\t\t\tIRB %08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pIrb->Req_A.Bits__SFS_Len,
                      0,0,0,0,0,0,0);
*/
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
  Function: SFFuncIRB_OnCardInit
   Purpose: Initialize on card  Io request block
 Called By: All sfaction do routines when card ram is used.
     Calls: none
-*/
void SFFuncIRB_OnCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t     * hpRoot = SFThread->thread_hdr.hpRoot;

    CThread_t                  *CThread = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    os_bit32                       Irb_offset;

    Irb_offset =   ERQ->addr.CardRam.cardRamOffset;
    Irb_offset += (CThread->HostCopy_ERQProdIndex * sizeof(IRB_t));


    osCardRamWriteBit32(hpRoot,
                        Irb_offset + hpFieldOffset(IRB_t,Req_A.Bits__SFS_Len),
                        SFS_Len | IRB_SFA | DCM_Bit );

    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_A.SFS_Addr),
                        SFThread->SF_CMND_Lower32);

    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_A.D_ID),
                        D_ID << IRB_D_ID_SHIFT);
    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_A.MBZ__SEST_Index__Trans_ID),
                        SFThread->X_ID);
    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_B.Bits__SFS_Len),
                        0);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/* void ttttttt(void){} */


#endif /* USESTATEMACROS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sf_fcp.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/SF_FCP.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:32a  $ (Last Modified)

Purpose:

  This file implements Single Frame FCP services for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tgtstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/sf_fcp.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tgtstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "sf_fcp.h"
#endif  /* _New_Header_file_Layout_ */

void fiFillInSF_FCP_FrameHeader_OnCard(
                                        SFThread_t *SFThread,
                                        os_bit32       D_ID,
                                        os_bit32       X_ID,
                                        os_bit32       F_CTL_Exchange_Context
                                      )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t  *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread           = CThread_ptr(hpRoot);
    os_bit32      FCP_Header_Offset = SFThread->SF_CMND_Offset;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID=0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Command
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Command_Status
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         R_CTL__D_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         TYPE__F_CTL
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiFillInSF_FCP_FrameHeader_OffCard(
                                         SFThread_t *SFThread,
                                         os_bit32       D_ID,
                                         os_bit32       X_ID,
                                         os_bit32       F_CTL_Exchange_Context
                                       )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot       = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread      = CThread_ptr(hpRoot);
    FCHS_t    *FCP_Header   = SFThread->SF_CMND_Ptr;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID=0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Command
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Command_Status
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    FCP_Header->MBZ1                                        = 0;
    FCP_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    FCP_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    FCP_Header->CS_CTL__S_ID                                = S_ID;
    FCP_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    FCP_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    FCP_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    FCP_Header->RO                                          = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInTargetReset(
                           SFThread_t *SFThread
                         )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInTargetReset_OnCard(
                                           SFThread
                                         );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInTargetReset_OffCard(
                                            SFThread
                                          );
    }
}

os_bit32 fiFillInTargetReset_OnCard(
                                  SFThread_t *SFThread
                                )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot             = SFThread->thread_hdr.hpRoot;
    DevThread_t *DevThread          = SFThread->parent.Device;
    os_bit32        FCP_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        FCP_Payload_Offset = FCP_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_TargetReset;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Started;

/*+
Fill in TargetReset Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OnCard(
                                       SFThread,
                                       fiComputeDevThread_D_ID(
                                                                DevThread
                                                              ),
                                       0xFFFF,
                                       FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                     );

/*+
Fill in TargetReset Frame Payload
-*/

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.Reserved_Bit8
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.TaskCodes
                                                          ),
                        FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.TaskManagementFlags
                                                          ),
                        FC_FCP_CMND_FcpCntl_TaskManagementFlags_TARGET_RESET
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.ExecutionManagementCodes
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 0]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 1]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 2]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 3]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 4]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 5]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 6]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 7]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 8]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 9]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[10]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[11]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[12]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[13]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[14]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[15]
                                                          ),
                        0
                      );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Payload_Offset + hpFieldOffset(
                                                             FC_FCP_CMND_Payload_t,
                                                             FcpDL
                                                           ),
                         hpSwapBit32( 0 )
                       );

/*+
Return length of TargetReset Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_FCP_CMND_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInTargetReset_OffCard(
                                   SFThread_t *SFThread
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    DevThread_t           *DevThread   = SFThread->parent.Device;
    FCHS_t                *FCP_Header  = SFThread->SF_CMND_Ptr;
    FC_FCP_CMND_Payload_t *FCP_Payload = (FC_FCP_CMND_Payload_t *)((os_bit8 *)FCP_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_TargetReset;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Started;

/*+
Fill in TargetReset Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OffCard(
                                        SFThread,
                                        fiComputeDevThread_D_ID(
                                                                 DevThread
                                                               ),
                                        0xFFFF,
                                        FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                      );

/*+
Fill in TargetReset Frame Payload
-*/

    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_1 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_1 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_1 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_1 = 0;

    FCP_Payload->FcpCntl.Reserved_Bit8                     = 0;
    FCP_Payload->FcpCntl.TaskCodes                         = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q;
    FCP_Payload->FcpCntl.TaskManagementFlags               = FC_FCP_CMND_FcpCntl_TaskManagementFlags_TARGET_RESET;
    FCP_Payload->FcpCntl.ExecutionManagementCodes          = 0;

    FCP_Payload->FcpCdb[ 0]                                = 0;
    FCP_Payload->FcpCdb[ 1]                                = 0;
    FCP_Payload->FcpCdb[ 2]                                = 0;
    FCP_Payload->FcpCdb[ 3]                                = 0;
    FCP_Payload->FcpCdb[ 4]                                = 0;
    FCP_Payload->FcpCdb[ 5]                                = 0;
    FCP_Payload->FcpCdb[ 6]                                = 0;
    FCP_Payload->FcpCdb[ 7]                                = 0;
    FCP_Payload->FcpCdb[ 8]                                = 0;
    FCP_Payload->FcpCdb[ 9]                                = 0;
    FCP_Payload->FcpCdb[10]                                = 0;
    FCP_Payload->FcpCdb[11]                                = 0;
    FCP_Payload->FcpCdb[12]                                = 0;
    FCP_Payload->FcpCdb[13]                                = 0;
    FCP_Payload->FcpCdb[14]                                = 0;
    FCP_Payload->FcpCdb[15]                                = 0;

    FCP_Payload->FcpDL                                     = hpSwapBit32( 0 );

/*+
Return length of TargetReset Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_FCP_CMND_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiSF_FCP_Process_TargetReset_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 )
{
#ifndef __MemMap_Force_Off_Card__
#if 0
    agRoot_t *hpRoot = SFThread->thread_hdr.hpRoot;

    agFCDevInfo_t *DevInfo = &(SFThread->parent.Device->DevInfo);
    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
#endif /* if 0 */
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiSF_FCP_Process_TargetReset_Response_OffCard(
                                                    SFThread_t                 *SFThread,
                                                    os_bit32                       Frame_Length,
                                                    FCHS_t                     *FCHS,
                                                    FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                                    os_bit32                       Payload_Wrap_Offset,
                                                    FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                                  )
{
#ifndef __MemMap_Force_On_Card__
#if 0
    agFCDevInfo_t *DevInfo = &(SFThread->parent.Device->DevInfo);
    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
#endif /* if 0 */
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInFCP_RSP_IU(
                          SFThread_t           *SFThread,
                          os_bit32                 D_ID,
                          os_bit32                 OX_ID,
                          os_bit32                 Payload_LEN,
                          FC_FCP_RSP_Payload_t *Payload
                        )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInFCP_RSP_IU_OnCard(
                                          SFThread,
                                          D_ID,
                                          OX_ID,
                                          Payload_LEN,
                                          Payload
                                        );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInFCP_RSP_IU_OffCard(
                                           SFThread,
                                           D_ID,
                                           OX_ID,
                                           Payload_LEN,
                                           Payload
                                         );
    }
}

os_bit32 fiFillInFCP_RSP_IU_OnCard(
                                 SFThread_t           *SFThread,
                                 os_bit32                 D_ID,
                                 os_bit32                 OX_ID,
                                 os_bit32                 Payload_LEN,
                                 FC_FCP_RSP_Payload_t *Payload
                               )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t  *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread             = CThread_ptr(hpRoot);
    os_bit32      FCP_Header_Offset   = SFThread->SF_CMND_Offset;
    os_bit32      FCP_Payload_Offset  = FCP_Header_Offset + sizeof(FCHS_t);
    os_bit32      FCP_Payload_MAX_LEN = CThread->Calculation.MemoryLayout.SF_CMND.elementSize - sizeof(FCHS_t);
    os_bit32      FCP_Payload_to_copy;
    os_bit32      Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

/*+
Fill in FCP_RSP_IU Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OnCard(
                                       SFThread,
                                       D_ID,
                                       OX_ID,
                                       FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                     );

/*+
Fill in FCP_RSP_IU Frame Payload
-*/

    FCP_Payload_to_copy = ((Payload_LEN < FCP_Payload_MAX_LEN) ? Payload_LEN : FCP_Payload_MAX_LEN);

    for (Bit8_Index = 0;
         Bit8_Index < FCP_Payload_to_copy;
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FCP_Payload_Offset + Bit8_Index,
                            *((os_bit8 *)Payload + Bit8_Index)
                          );
    }

/*+
Return length of FCP_RSP_IU Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + FCP_Payload_to_copy;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInFCP_RSP_IU_OffCard(
                                  SFThread_t           *SFThread,
                                  os_bit32                 D_ID,
                                  os_bit32                 OX_ID,
                                  os_bit32                 Payload_LEN,
                                  FC_FCP_RSP_Payload_t *Payload
                                )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t  *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread             = CThread_ptr(hpRoot);
    FCHS_t    *FCP_Header          = SFThread->SF_CMND_Ptr;
    os_bit8      *FCP_Payload         = (os_bit8 *)FCP_Header + sizeof(FCHS_t);
    os_bit32      FCP_Payload_MAX_LEN = CThread->Calculation.MemoryLayout.SF_CMND.elementSize - sizeof(FCHS_t);
    os_bit32      FCP_Payload_to_copy;
    os_bit32      Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

/*+
Fill in FCP_RSP_IU Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OffCard(
                                        SFThread,
                                        D_ID,
                                        OX_ID,
                                        FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                      );

/*+
Fill in FCP_RSP_IU Frame Payload
-*/

    FCP_Payload_to_copy = ((Payload_LEN < FCP_Payload_MAX_LEN) ? Payload_LEN : FCP_Payload_MAX_LEN);

    for (Bit8_Index = 0;
         Bit8_Index < FCP_Payload_to_copy;
         Bit8_Index++)
    {
        *FCP_Payload++ = *((os_bit8 *)Payload + Bit8_Index);
    }

/*+
Return length of FCP_RSP_IU Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + FCP_Payload_to_copy;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiSF_FCP_Process_TargetRequest_OnCard(
                                            agRoot_t *hpRoot,
                                            os_bit32     Frame_Length,
                                            os_bit32     Offset_to_FCHS,
                                            os_bit32     Offset_to_Payload,
                                            os_bit32     Payload_Wrap_Offset,
                                            os_bit32     Offset_to_Payload_Wrapped
                                          )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32        TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32        TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32        TgtCmnd_Payload_To_Copy;
    os_bit32        Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OnCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        osCardRamReadBlock(
                            hpRoot,
                            Offset_to_FCHS,
                            (void *)TgtCmnd_FCHS,
                            sizeof(FCHS_t)
                          );

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload + Bit8_Index
                                       );
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload_Wrapped + Bit8_Index
                                       );
            }
        }

        fiSendEvent(
                     &(TgtThread->thread_hdr),
                     TgtEventIncoming
                   );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OnCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

void fiSF_FCP_Process_TargetRequest_OffCard(
                                             agRoot_t *hpRoot,
                                             os_bit32     Frame_Length,
                                             FCHS_t   *FCHS,
                                             void     *Payload,
                                             os_bit32     Payload_Wrap_Offset,
                                             void     *Payload_Wrapped
                                           )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32     TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32     TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32     TgtCmnd_Payload_To_Copy;
    os_bit32     Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OffCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        *TgtCmnd_FCHS = *FCHS;

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload + Bit8_Index);
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload_Wrapped + Bit8_Index);
            }
        }

        fiSendEvent(
                     &(TgtThread->thread_hdr),
                     TgtEventIncoming
                   );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OffCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

os_bit32 fiSF_FCP_ProcessSFQ(
                           agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           fi_thread__t       **Thread_to_return
                         )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiSF_FCP_ProcessSFQ_OnCard(
                                           hpRoot,
                                           SFQConsIndex,
                                           Frame_Length,
                                           Thread_to_return
                                         );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiSF_FCP_ProcessSFQ_OffCard(
                                            hpRoot,
                                            SFQConsIndex,
                                            Frame_Length,
                                            Thread_to_return
                                          );
    }
}

os_bit32 fiSF_FCP_ProcessSFQ_OnCard(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    os_bit32                       Offset_to_FCHS             = SFQ_MemoryDescriptor->addr.CardRam.cardRamOffset
                                                             + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize);
    os_bit32                       Offset_to_Payload          = Offset_to_FCHS + sizeof(FCHS_t);
    os_bit32                       Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit32                       Offset_to_Payload_Wrapped  = Offset_to_Payload
                                                             - SFQ_MemoryDescriptor->objectSize;
    os_bit32                       TYPE__F_CTL;
    X_ID_t                      X_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset       = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;
    fiMemMapMemoryDescriptor_t *SEST_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SEST);
    os_bit32                       SEST_Offset;
    SEST_t                     *SEST;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    TYPE__F_CTL = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                    );

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP)
    {
        /* This function only understands SCSI FCP Frames */

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        fiSF_FCP_Process_TargetRequest_OnCard(
                                               hpRoot,
                                               Frame_Length,
                                               Offset_to_FCHS,
                                               Offset_to_Payload,
                                               Payload_Wrap_Offset,
                                               Offset_to_Payload_Wrapped
                                             );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_TargetRequest;
    }

    X_ID = (X_ID_t)(((osCardRamReadBit32(
                                          hpRoot,
                                          Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                        ) & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    if (X_ID <= CDBThread_X_ID_Max)
    {
        /* Got an unexpected Inbound CDB Frame on SFQ */

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)CDBThread;
        
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID <= CDBThread_X_ID_Max",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID==0x%08X  CThread==0x%p",
                          (char *)agNULL,(char *)agNULL,
                          CThread,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,MBZ1)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,CS_CTL__S_ID)
                                            ),
                          0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SEQ_ID__DF_CTL__SEQ_CNT)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,RO)
                                            ),
                          0,0,0,0
                        );

        if (SEST_MemoryDescriptor->memLoc == inCardRam)
        {
            SEST_Offset =   SEST_MemoryDescriptor->addr.CardRam.cardRamOffset
                          + (X_ID * SEST_MemoryDescriptor->elementSize);

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Bits)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_1)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_2)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_3)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.LOC)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_5)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_6)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_7)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_8)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_9)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.L32)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.L32)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.L32)
                                                ),
                              0,0,0,0
                            );
        }
        else /* SEST_MemoryDescriptor->memLoc == inDmaMemory */
        {
            SEST = (SEST_t *)(  (os_bit8 *)SEST_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                              + (X_ID * SEST_MemoryDescriptor->elementSize)               );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Bits,
                              SEST->USE.Unused_DWord_1,
                              SEST->USE.Unused_DWord_2,
                              SEST->USE.Unused_DWord_3,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.LOC,
                              SEST->USE.Unused_DWord_5,
                              SEST->USE.Unused_DWord_6,
                              SEST->USE.Unused_DWord_7,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Unused_DWord_8,
                              SEST->USE.Unused_DWord_9,
                              SEST->USE.First_SG.U32_Len,
                              SEST->USE.First_SG.L32,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Second_SG.U32_Len,
                              SEST->USE.Second_SG.L32,
                              SEST->USE.Third_SG.U32_Len,
                              SEST->USE.Third_SG.L32,
                              0,0,0,0
                            );
        }

        return fiSF_FCP_Cmd_Status_Bad_CDB_Frame;
    }

    if (X_ID > SFThread_X_ID_Max)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID > SFThread_X_ID_Max",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,MBZ1)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,CS_CTL__S_ID)
                                            ),
                          0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SEQ_ID__DF_CTL__SEQ_CNT)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,RO)
                                            ),
                          0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((X_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;
        
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

    /* For now, assume TargetReset */

    fiLogDebugString(
                      hpRoot,
                      SF_FCP_LogConsoleLevel,
                      "fiSF_FCP_ProcessSFQ_OnCard(): hard-coded call to fiSF_FCP_Process_TargetReset_Response_OnCard()",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiSF_FCP_Process_TargetReset_Response_OnCard(
                                                  SFThread,
                                                  Frame_Length,
                                                  Offset_to_FCHS,
                                                  Offset_to_Payload,
                                                  Payload_Wrap_Offset,
                                                  Offset_to_Payload_Wrapped
                                                );

    return fiSF_FCP_Cmd_Status_Success;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiSF_FCP_ProcessSFQ_OffCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32            Frame_Length,
                                   fi_thread__t       **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                       = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    FC_ELS_Unknown_Payload_t   *Payload                    = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    FC_ELS_Unknown_Payload_t   *Payload_Wrapped            = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)Payload
                                                                                          - SFQ_MemoryDescriptor->objectSize);
    os_bit32                    TYPE__F_CTL                = FCHS->TYPE__F_CTL;
    X_ID_t                      X_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                    CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                    SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;
    fiMemMapMemoryDescriptor_t *SEST_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SEST);
    os_bit32                    SEST_Offset;
    SEST_t                     *SEST;
    os_bit32                  * FCHS_Payload = (os_bit32 *) Payload;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP)
    {
        /* This function only understands SCSI FCP Frames */

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );
        fiLogDebugString(
                        hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(FCHS_Payload+0),
                        *(FCHS_Payload+1),
                        *(FCHS_Payload+2),
                        *(FCHS_Payload+3),
                        *(FCHS_Payload+4),
                        *(FCHS_Payload+5),
                        *(FCHS_Payload+6),
                        *(FCHS_Payload+7));


        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        fiSF_FCP_Process_TargetRequest_OffCard(
                                                hpRoot,
                                                Frame_Length,
                                                FCHS,
                                                (void *)Payload,
                                                Payload_Wrap_Offset,
                                                (void *)Payload_Wrapped
                                              );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_TargetRequest;
    }

    X_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    if (X_ID <= CDBThread_X_ID_Max)
    {
        /* Got an unexpected Inbound CDB Frame on SFQ */

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)CDBThread;
        
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID <= CDBThread_X_ID_Max   X_ID==0x%08X ",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );
        fiLogDebugString(
                        hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(FCHS_Payload+0),
                        *(FCHS_Payload+1),
                        *(FCHS_Payload+2),
                        *(FCHS_Payload+3),
                        *(FCHS_Payload+4),
                        *(FCHS_Payload+5),
                        *(FCHS_Payload+6),
                        *(FCHS_Payload+7));

        if (SEST_MemoryDescriptor->memLoc == inCardRam)
        {
            SEST_Offset =   SEST_MemoryDescriptor->addr.CardRam.cardRamOffset
                          + (X_ID * SEST_MemoryDescriptor->elementSize);

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Bits)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_1)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_2)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_3)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.LOC)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_5)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_6)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_7)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_8)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_9)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.L32)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.L32)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.L32)
                                                ),
                              0,0,0,0
                            );
        }
        else /* SEST_MemoryDescriptor->memLoc == inDmaMemory */
        {
            SEST = (SEST_t *)(  (os_bit8 *)SEST_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                              + (X_ID * SEST_MemoryDescriptor->elementSize)               );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Bits,
                              SEST->USE.Unused_DWord_1,
                              SEST->USE.Unused_DWord_2,
                              SEST->USE.Unused_DWord_3,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.LOC,
                              SEST->USE.Unused_DWord_5,
                              SEST->USE.Unused_DWord_6,
                              SEST->USE.Unused_DWord_7,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Unused_DWord_8,
                              SEST->USE.Unused_DWord_9,
                              SEST->USE.First_SG.U32_Len,
                              SEST->USE.First_SG.L32,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Second_SG.U32_Len,
                              SEST->USE.Second_SG.L32,
                              SEST->USE.Third_SG.U32_Len,
                              SEST->USE.Third_SG.L32,
                              0,0,0,0
                            );
        }

        return fiSF_FCP_Cmd_Status_Bad_CDB_Frame;
    }

    if (X_ID > SFThread_X_ID_Max)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID > SFThread_X_ID_Max   X_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );

        fiLogDebugString( hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(FCHS_Payload+0),
                        *(FCHS_Payload+1),
                        *(FCHS_Payload+2),
                        *(FCHS_Payload+3),
                        *(FCHS_Payload+4),
                        *(FCHS_Payload+5),
                        *(FCHS_Payload+6),
                        *(FCHS_Payload+7));

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((X_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;
        
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

    /* For now, assume TargetReset */

    fiLogDebugString(
                      hpRoot,
                      SF_FCP_LogConsoleLevel,
                      "fiSF_FCP_ProcessSFQ_OffCard(): hard-coded call to fiSF_FCP_Process_TargetReset_Response_OffCard()",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0 );

    fiLogDebugString(hpRoot,
                    SF_FCP_LogConsoleLevel,
                    "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    FCHS->MBZ1,
                    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                    FCHS->R_CTL__D_ID,
                    FCHS->CS_CTL__S_ID,
                    FCHS->TYPE__F_CTL,
                    FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                    FCHS->OX_ID__RX_ID,
                    FCHS->RO );

    fiLogDebugString(hpRoot,
                    SF_FCP_LogConsoleLevel,
                    "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *(FCHS_Payload+0),
                    *(FCHS_Payload+1),
                    *(FCHS_Payload+2),
                    *(FCHS_Payload+3),
                    *(FCHS_Payload+4),
                    *(FCHS_Payload+5),
                    *(FCHS_Payload+6),
                    *(FCHS_Payload+7));


    fiSF_FCP_Process_TargetReset_Response_OffCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   FCHS,
                                                   (FC_ELS_ACC_PLOGI_Payload_t *)Payload,
                                                   Payload_Wrap_Offset,
                                                   (FC_ELS_ACC_PLOGI_Payload_t *)Payload_Wrapped
                                                 );

    return fiSF_FCP_Cmd_Status_Success;
#endif /* __MemMap_Force_On_Card__ was not defined */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\sfstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/SFSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 9/12/00 5:01p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/SFState.C

--*/

#ifndef __SFState_H__
#define __SFState_H__

#define SFTHREAD_FINISHED               0xBAD10BAD

#define SF_EDTOV                         900000  /* Micro seconds  was 2 000 000*/
#define SF_FLOGI_TOV                     900000  /* Micro seconds  was   700 000*/
#define SF_RECTOV                        500000  /* */

#define SFCompletion                    42

#define SFStateConfused                 0
#define SFStateFree                     1

#define SFStateDoPlogi                  2
#define SFStatePlogiAccept              3
#define SFStatePlogiRej                 4
#define SFStatePlogiBadALPA             5
#define SFStatePlogiTimedOut            6

#define SFStateDoPrli                   7
#define SFStatePrliAccept               8
#define SFStatePrliRej                  9
#define SFStatePrliBadAlpa              10
#define SFStatePrliTimedOut             11

#define SFStateDoFlogi                  12
#define SFStateFlogiAccept              13
#define SFStateFlogiRej                 14
#define SFStateFlogiBadALPA             15
#define SFStateFlogiTimedOut            16

#define SFStateDoLogo                  17
#define SFStateLogoAccept              18
#define SFStateLogoRej                 19
#define SFStateLogoBadALPA             20
#define SFStateLogoTimedOut            21

#define SFStateDoPrlo                   22
#define SFStatePrloAccept               23
#define SFStatePrloRej                  24
#define SFStatePrloBadALPA              25
#define SFStatePrloTimedOut             26

#define SFStateDoAdisc                  27
#define SFStateAdiscAccept              28
#define SFStateAdiscRej                 29
#define SFStateAdiscBadALPA             30
#define SFStateAdiscTimedOut            31

#define SFStateDoPdisc                  32
#define SFStatePdiscAccept              33
#define SFStatePdiscRej                 34
#define SFStatePdiscBadALPA             35
#define SFStatePdiscTimedOut            36

#define SFStateDoAbort                  37
#define SFStateAbortAccept              38
#define SFStateAbortRej                 39
#define SFStateAbortBadALPA             40
#define SFStateAbortTimedOut            41

#define SFStateDoResetDevice                 42
#define SFStateResetDeviceAccept             43
#define SFStateResetDeviceRej                44
#define SFStateResetDeviceBadALPA            45
#define SFStateResetDeviceTimedOut           46

#define SFStateDoLS_RJT                      47
#define SFStateLS_RJT_Done                   48

#define SFStateDoPlogiAccept                 49
#define SFStatePlogiAccept_Done              50

#define SFStateDoPrliAccept                  51
#define SFStatePrliAccept_Done               52

#define SFStateDoELSAccept                   53
#define SFStateELSAccept_Done                54

#define SFStateDoFCP_DR_ACC_Reply            55
#define SFStateFCP_DR_ACC_Reply_Done         56

#define SFStateLS_RJT_TimeOut                57
#define SFStatePlogiAccept_TimeOut           58
#define SFStatePrliAccept_TimeOut            59
#define SFStateELSAccept_TimeOut             60
#define SFStateFCP_DR_ACC_Reply_TimeOut      61

#ifdef NAME_SERVICES
#define SFStateDoRFT_ID                      62
#define SFStateRFT_IDAccept                  63
#define SFStateRFT_IDRej                     64
#define SFStateRFT_IDBadALPA                 65
#define SFStateRFT_IDTimedOut                66

#define SFStateDoGID_FT                      67
#define SFStateGID_FTAccept                  68
#define SFStateGID_FTRej                     69
#define SFStateGID_FTBadALPA                 70
#define SFStateGID_FTTimedOut                71

#define SFStateDoSCR                         72
#define SFStateSCRAccept                     73
#define SFStateSCRBadALPA                    74
#define SFStateSCRTimedOut                   75
#define SFStateSCRRej                        76

#endif

#define SFStateDoSRR                  77
#define SFStateSRRAccept              78
#define SFStateSRRRej                 79
#define SFStateSRRBadALPA             80
#define SFStateSRRTimedOut            81

#define SFStateDoREC                  82
#define SFStateRECAccept              83
#define SFStateRECRej                 84
#define SFStateRECBadALPA             85
#define SFStateRECTimedOut            86

#define SFStateDoADISCAccept          87
#define SFStateADISCAccept_Done       88
#define SFStateADISCAccept_TimeOut    89

#ifdef _DvrArch_1_30_
#define SFStateDoFarpRequest                 90
#define SFStateFarpRequestDone               91
#define SFStateFarpRequestTimedOut           92
#define SFStateDoFarpReply                   93
#define SFStateFarpReplyDone                 94
#define SFStateFarpReplyTimedOut             95 /* not handled, exceeded the maximum state number */
#define SFStateMAXState         SFStateFarpReplayTimedOut
#else /* _DvrArch_1_30_ was not defined */
#define SFStateMAXState         SFStateADISCAccept_TimeOut
#endif /* _DvrArch_1_30_ was not defined */

#define SFEventReset                         1

#define SFEventDoPlogi                       2
#define SFEventPlogiAccept                   3
#define SFEventPlogiRej                      4
#define SFEventPlogiBadALPA                  5
#define SFEventPlogiTimedOut                 6

#define SFEventDoPrli                        7
#define SFEventPrliAccept                    8
#define SFEventPrliRej                       9
#define SFEventPrliBadALPA                   10
#define SFEventPrliTimedOut                  11

#define SFEventDoFlogi                       12
#define SFEventFlogiAccept                   13
#define SFEventFlogiRej                      14
#define SFEventFlogiBadALPA                  15
#define SFEventFlogiTimedOut                 16

#define SFEventDoLogo                       17
#define SFEventLogoAccept                   18
#define SFEventLogoRej                      19
#define SFEventLogoBadALPA                  20
#define SFEventLogoTimedOut                 21

#define SFEventDoPrlo                        22
#define SFEventPrloAccept                    23
#define SFEventPrloRej                       24
#define SFEventPrloBadALPA                   25
#define SFEventPrloTimedOut                  26

#define SFEventDoAdisc                       27
#define SFEventAdiscAccept                   28
#define SFEventAdiscRej                      29
#define SFEventAdiscBadALPA                  30
#define SFEventAdiscTimedOut                 31

#define SFEventDoPdisc                       32
#define SFEventPdiscAccept                   33
#define SFEventPdiscRej                      34
#define SFEventPdiscBadALPA                  35
#define SFEventPdiscTimedOut                 36

#define SFEventDoAbort                       37
#define SFEventAbortAccept                   38
#define SFEventAbortRej                      39
#define SFEventAbortBadALPA                  40
#define SFEventAbortTimedOut                 41

#define SFEventDoResetDevice                 42
#define SFEventResetDeviceAccept             43
#define SFEventResetDeviceRej                44
#define SFEventResetDeviceBadALPA            45
#define SFEventResetDeviceTimedOut           46

#define SFEventDoLS_RJT                      47
#define SFEventLS_RJT_Done                   48

#define SFEventDoPlogiAccept                 49
#define SFEventPlogiAccept_Done              50

#define SFEventDoPrliAccept                  51
#define SFEventPrliAccept_Done               52

#define SFEventDoELSAccept                   53
#define SFEventELSAccept_Done                54

#define SFEventDoFCP_DR_ACC_Reply            55
#define SFEventFCP_DR_ACC_Reply_Done         56

#define SFEventLS_RJT_TimeOut                57
#define SFEventPlogiAccept_TimeOut           58
#define SFEventPrliAccept_TimeOut            59
#define SFEventELSAccept_TimeOut             60
#define SFEventFCP_DR_ACC_Reply_TimeOut      61
#ifdef NAME_SERVICES
#define SFEventDoRFT_ID                      62
#define SFEventRFT_IDAccept                  63
#define SFEventRFT_IDRej                     64
#define SFEventRFT_IDBadALPA                 65
#define SFEventRFT_IDTimedOut                66

#define SFEventDoGID_FT                      67
#define SFEventGID_FTAccept                  68
#define SFEventGID_FTRej                     69
#define SFEventGID_FTBadALPA                 70
#define SFEventGID_FTTimedOut                71

#define SFEventDoSCR                         72
#define SFEventSCRAccept                     73
#define SFEventSCRRej                        74
#define SFEventSCRBadALPA                    75
#define SFEventSCRTimedOut                   76
#endif

#define SFEventDoSRR                         77
#define SFEventSRRAccept                     78
#define SFEventSRRRej                        79
#define SFEventSRRBadALPA                    80
#define SFEventSRRTimedOut                   81

#define SFEventDoREC                         82
#define SFEventRECAccept                     83
#define SFEventRECRej                        84
#define SFEventRECBadALPA                    85
#define SFEventRECTimedOut                   86

#define SFEventDoADISCAccept                 87
#define SFEventADISCAccept_Done              88
#define SFEventADISCAccept_TimeOut           89


#ifdef _DvrArch_1_30_
#define SFEventDoFarpRequest                 90
#define SFEventFarpReplied                   91
#define SFEventFarpRequestTimedOut           92
#define SFEventDoFarpReply                   93
#define SFEventFarpReplyDone                 94
#define SFEventFarpReplyTimedOut             95 /* not handled, exceeded the maximum event number */
#define SFEventMAXState   SFEventReplyTimedOut
#else /* _DvrArch_1_30_ was not defined */
#define SFEventMAXEvent   SFEventADISCAccept_TimeOut      
#endif /* _DvrArch_1_30_ was not defined */


STATE_PROTO(SFActionConfused);
STATE_PROTO(SFActionReset);

STATE_PROTO(SFActionDoPlogi);
STATE_PROTO(SFActionPlogiAccept);
STATE_PROTO(SFActionPlogiRej);
STATE_PROTO(SFActionPlogiBadALPA);
STATE_PROTO(SFActionPlogiTimedOut);

STATE_PROTO(SFActionDoPrli);
STATE_PROTO(SFActionPrliAccept);
STATE_PROTO(SFActionPrliRej);
STATE_PROTO(SFActionPrliBadALPA);
STATE_PROTO(SFActionPrliTimedOut);

STATE_PROTO(SFActionDoFlogi);
STATE_PROTO(SFActionFlogiAccept);
STATE_PROTO(SFActionFlogiRej);
STATE_PROTO(SFActionFlogiBadALPA);
STATE_PROTO(SFActionFlogiTimedOut);

STATE_PROTO(SFActionDoLogo);
STATE_PROTO(SFActionLogoAccept);
STATE_PROTO(SFActionLogoRej);
STATE_PROTO(SFActionLogoBadALPA);
STATE_PROTO(SFActionLogoTimedOut);

STATE_PROTO(SFActionDoPrlo);
STATE_PROTO(SFActionPrloAccept);
STATE_PROTO(SFActionPrloRej);
STATE_PROTO(SFActionPrloBadALPA);
STATE_PROTO(SFActionPrloTimedOut);

STATE_PROTO(SFActionDoAdisc);
STATE_PROTO(SFActionAdiscAccept);
STATE_PROTO(SFActionAdiscRej);
STATE_PROTO(SFActionAdiscBadALPA);
STATE_PROTO(SFActionAdiscTimedOut);

STATE_PROTO(SFActionDoPdisc);
STATE_PROTO(SFActionPdiscAccept);
STATE_PROTO(SFActionPdiscRej);
STATE_PROTO(SFActionPdiscBadALPA);
STATE_PROTO(SFActionPdiscTimedOut);

STATE_PROTO(SFActionDoAbort);
STATE_PROTO(SFActionAbortAccept);
STATE_PROTO(SFActionAbortRej);
STATE_PROTO(SFActionAbortBadALPA);
STATE_PROTO(SFActionAbortTimedOut);

STATE_PROTO(SFActionDoResetDevice);
STATE_PROTO(SFActionResetDeviceAccept);
STATE_PROTO(SFActionResetDeviceRej);
STATE_PROTO(SFActionResetDeviceBadALPA);
STATE_PROTO(SFActionResetDeviceTimedOut);


STATE_PROTO(SFActionDoLS_RJT);
STATE_PROTO(SFActionLS_RJT_Done );

STATE_PROTO(SFActionDoPlogiAccept);
STATE_PROTO(SFActionPlogiAccept_Done);

STATE_PROTO(SFActionDoPrliAccept);
STATE_PROTO(SFActionPrliAccept_Done);

STATE_PROTO(SFActionDoELSAccept);
STATE_PROTO(SFActionELSAccept_Done);

STATE_PROTO(SFActionDoFCP_DR_ACC_Reply);
STATE_PROTO(SFActionFCP_DR_ACC_Reply_Done);


STATE_PROTO(SFActionLS_RJT_TimeOut );
STATE_PROTO(SFActionPlogiAccept_TimeOut);
STATE_PROTO(SFActionPrliAccept_TimeOut);
STATE_PROTO(SFActionELSAccept_TimeOut);
STATE_PROTO(SFActionFCP_DR_ACC_Reply_TimeOut);
STATE_PROTO(SFActionDoRFT_ID);
STATE_PROTO(SFActionRFT_IDAccept);
STATE_PROTO(SFActionRFT_IDRej);
STATE_PROTO(SFActionRFT_IDBadALPA);
STATE_PROTO(SFActionRFT_IDTimedOut);
STATE_PROTO(SFActionDoGID_FT);
STATE_PROTO(SFActionGID_FTAccept);
STATE_PROTO(SFActionGID_FTRej);
STATE_PROTO(SFActionGID_FTBadALPA);
STATE_PROTO(SFActionGID_FTTimedOut);

STATE_PROTO(SFActionDoSCR);
STATE_PROTO(SFActionSCRAccept);
STATE_PROTO(SFActionSCRRej);
STATE_PROTO(SFActionSCRBadALPA);
STATE_PROTO(SFActionSCRTimedOut);

STATE_PROTO(SFActionDoSRR);
STATE_PROTO(SFActionSRRAccept);
STATE_PROTO(SFActionSRRRej);
STATE_PROTO(SFActionSRRBadALPA);
STATE_PROTO(SFActionSRRTimedOut);

STATE_PROTO(SFActionDoREC);
STATE_PROTO(SFActionRECAccept);
STATE_PROTO(SFActionRECRej);
STATE_PROTO(SFActionRECBadALPA);
STATE_PROTO(SFActionRECTimedOut);

STATE_PROTO(SFActionDoADISCAccept);
STATE_PROTO(SFActionADISCAccept_Done);
STATE_PROTO(SFActionADISCAccept_TimeOut);

#ifdef _DvrArch_1_30_
STATE_PROTO(SFActionDoFarpRequest);
STATE_PROTO(SFActionFarpRequestDone);
STATE_PROTO(SFActionFarpRequestTimedOut);
STATE_PROTO(SFActionDoFarpReply);
STATE_PROTO(SFActionFarpReplyDone);
STATE_PROTO(SFActionFarpReplyTimedOut);
#endif /* _DvrArch_1_30_ was not defined */

extern stateTransitionMatrix_t SFStateTransitionMatrix;
extern stateActionScalar_t     SFStateActionScalar;


void SFFuncIRB_OnCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit);
void SFFuncIRB_OffCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit);

#ifdef USESTATEMACROS

void testSFthread( agRoot_t * hpRoot );

#define SFSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",          \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define SFSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                            \
    CThread_t  * pCThread=CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;             \
    DevThread_t * pDevThread=pCDBThread->Device;                 \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#define SFSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;                            \
    CThread_t  * pCThread = CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;             \
    DevThread_t * pDevThread = pCDBThread->Device;                 \
    os_bit8 WhichAction[4];                                            \
    static  os_bit32 ActionCount=0;                                    \
    WhichAction[0] = Action0;                                       \
    WhichAction[1] = Action1;                                       \
    WhichAction[2] = Action2;                                       \
    WhichAction[3] = Action3;                                       \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d ALPA %X",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                    \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...returns event %s %d",       \
                      #Action0,#Action1,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],  \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "or %s  or %s",                  \
                      (void * )agNULL,(void * )agNULL,  \
                      #Action2,#Action3,                \
                      0,0,0,0,0,0,0,0);                 \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                              \
    else ActionCount =0;                                            \
    }                                                               \

#ifdef TestSFStateMachine

char * SFStateString[]=
{

    "SFStateConfused            ",
    "SFStateFree                ",
    "SFStateDoPlogi             ",
    "SFStatePlogiAccept         ",
    "SFStatePlogiRej            ",
    "SFStatePlogiBadALPA        ",
    "SFStatePlogiTimedOut       ",
    "SFStateDoPrli              ",
    "SFStatePrliAccept          ",
    "SFStatePrliRej             ",
    "SFStatePrliBadAlpa         ",
    "SFStatePrliTimedOut        ",
    "SFStateDoFlogi             ",
    "SFStateFlogiAccept         ",
    "SFStateFlogiRej            ",
    "SFStateFlogiBadALPA        ",
    "SFStateFlogiTimedOut       ",
    "SFStateDoLogo              ",
    "SFStateLogoAccept          ",
    "SFStateLogoRej             ",
    "SFStateLogoBadALPA         ",
    "SFStateLogoTimedOut        ",
    "SFStateDoPrlo              ",
    "SFStatePrloAccept          ",
    "SFStatePrloRej             ",
    "SFStatePrloBadALPA         ",
    "SFStatePrloTimedOut        ",
    "SFStateDoAdisc             ",
    "SFStateAdiscAccept         ",
    "SFStateAdiscRej            ",
    "SFStateAdiscBadALPA        ",
    "SFStateAdiscTimedOut       ",
    "SFStateDoPdisc             ",
    "SFStatePdiscAccept         ",
    "SFStatePdiscRej            ",
    "SFStatePdiscBadALPA        ",
    "SFSta