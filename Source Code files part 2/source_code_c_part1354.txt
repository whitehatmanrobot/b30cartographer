***********************/

VOID CTopWindow::UpdateHelpMenu(HMENU hMenuHelp)
{
	if (NULL != hMenuHelp)
	{
		// Enable/disable web items
		UINT uEnable = ::CanShellExecHttp() ? MF_ENABLED : MF_GRAYED;
		::EnableMenuItem(hMenuHelp, IDM_FILE_LAUNCH_WEB_PAGE, uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_FREE,     uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_NEWS,     uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_FAQ,      uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_FEEDBACK, uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_MSHOME,   uEnable);
		::EnableMenuItem(hMenuHelp, ID_HELP_WEB_SUPPORT,  uEnable);
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateViewMenu(HMENU hMenuView)
*
*        PURPOSE:  Updates the view menu by placing a bullet next to the
*                          current view and a check mark next to the toolbar and
*                          status bar items
*
****************************************************************************/

VOID CTopWindow::UpdateViewMenu(HMENU hMenuView)
{
	if (NULL == hMenuView)
		return;

	CheckMenu_ViewStatusBar(hMenuView);

	CMainUI *pMainUI = GetMainUI();
	BOOL bChecked;
	BOOL bEnable;

	bChecked = (NULL != pMainUI && pMainUI->IsCompact());
	CheckMenuItem(hMenuView, IDM_VIEW_COMPACT,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = FIsAVCapable();
	EnableMenuItem(hMenuView, IDM_VIEW_COMPACT,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));


	bChecked = (NULL != pMainUI && pMainUI->IsDataOnly());
	CheckMenuItem(hMenuView, IDM_VIEW_DATAONLY,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = FIsAVCapable();
	EnableMenuItem(hMenuView, IDM_VIEW_DATAONLY,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

	bChecked = (NULL != pMainUI && pMainUI->IsDialing());
	CheckMenuItem(hMenuView, IDM_VIEW_DIALPAD,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = (NULL != pMainUI && pMainUI->IsDialingAllowed());
	bEnable = bEnable && FIsAVCapable();
	EnableMenuItem(hMenuView, IDM_VIEW_DIALPAD,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

	bChecked = (NULL != pMainUI && pMainUI->IsPicInPic());
	CheckMenuItem(hMenuView, ID_TB_PICINPIC,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
	bEnable = (NULL != pMainUI && pMainUI->IsPicInPicAllowed());
	EnableMenuItem(hMenuView, ID_TB_PICINPIC,
		MF_BYCOMMAND|(bEnable ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

	bChecked = IsOnTop();
	CheckMenuItem(hMenuView, IDM_VIEW_ONTOP,
		MF_BYCOMMAND|(bChecked ? MF_CHECKED : MF_UNCHECKED));
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateToolsMenu(HMENU hMenuTools)
*
*        PURPOSE:  Updates the tools menu
*
****************************************************************************/

VOID CTopWindow::UpdateToolsMenu(HMENU hMenuTools)
{
    if (NULL != hMenuTools)
    {
        bool    fRDSDisabled = ConfPolicies::IsRDSDisabled();

		EnableMenuItem(hMenuTools, ID_TOOLS_AUDIO_WIZARD,
			FEnableAudioWizard() ? MF_ENABLED : MF_GRAYED);

		EnableMenuItem(hMenuTools, ID_TB_SHARING,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsSharingAllowed()));
        //
        // No app sharing, no RDS.
        //
        if (!m_pConfRoom->FIsSharingAvailable())
        {
            fRDSDisabled = TRUE;
        }

        // If this is NT, we need to handle adding or removing the menu item
        // to enable the display driver for application sharing.  We add the
        // menu item (immediately above the "Options" item) if the display
        // driver is not enabled and the item hasn't been added already.  We
        // remove the menu item if it's there and the display driver is
        // enabled, which should only happen if the user enabled it and then
        // choose to ignore the reboot prompt.
        if (::IsWindowsNT())
        {
            if (!g_fNTDisplayDriverEnabled && !m_fEnableAppSharingMenuItem)
            {
                // Add the menu item

                TCHAR szEnableAppSharingMenuItem[MAX_PATH];
                MENUITEMINFO mmi;

                int cchEnableAppSharingMenuItem =
                    ::LoadString(
                        GetInstanceHandle(),
                        ID_TOOLS_ENABLEAPPSHARING,
                        szEnableAppSharingMenuItem,
                        CCHMAX(szEnableAppSharingMenuItem));

                if (0 == cchEnableAppSharingMenuItem)
                {
                    ERROR_OUT(("LoadString(%d) failed", (int) ID_TOOLS_ENABLEAPPSHARING));
                }
                else
                {
                    //ZeroMemory((PVOID) &mmi, sizeof(mmi));
                    mmi.cbSize = sizeof(mmi);
                    mmi.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
                    mmi.fState = MFS_ENABLED;
                    mmi.wID = ID_TOOLS_ENABLEAPPSHARING;
                    mmi.fType = MFT_STRING;
                    mmi.dwTypeData = szEnableAppSharingMenuItem;
                    mmi.cch = cchEnableAppSharingMenuItem;

                    if (InsertMenuItem(
                        hMenuTools,
                        ID_TOOLS_OPTIONS,
                        FALSE,
                        &mmi))
                    {
                        m_fEnableAppSharingMenuItem = TRUE;
                    }
                    else
                    {
                        ERROR_OUT(("InsertMenuItem() failed, rc=%lu", (ULONG) GetLastError()));
                    }
                }
            }
            else if (m_fEnableAppSharingMenuItem && g_fNTDisplayDriverEnabled)
            {
                // Remove the menu item
                if (DeleteMenu(
                    hMenuTools,
                    ID_TOOLS_ENABLEAPPSHARING,
                    MF_BYCOMMAND))
                {
                    m_fEnableAppSharingMenuItem = FALSE;
                }
                else
                {
                    ERROR_OUT(("DeleteMenu() failed, rc=%lu", (ULONG) GetLastError()));
                }
            }
            if (m_fEnableAppSharingMenuItem)
                fRDSDisabled = TRUE;
        }
        else
        {
            // Windows 9.x;
            if (ConfPolicies::IsRDSDisabledOnWin9x())
            {
                fRDSDisabled = TRUE;
            }
        }

        EnableMenuItem(hMenuTools, ID_TOOLS_RDSWIZARD, MF_BYCOMMAND |
                       (fRDSDisabled ? MF_GRAYED : MF_ENABLED));

        //
        // LAURABU BOGUS:
        // Make installable tools a popup from Tools submenu, don't put these
        // flat!
        //
        CleanTools(hMenuTools, m_ExtToolsList);
        if (m_pConfRoom->GetMeetingPermissions() & NM_PERMIT_STARTOTHERTOOLS)
        {
            FillInTools(hMenuTools, 0, TOOLS_MENU_KEY, m_ExtToolsList);
        }

        BOOL fEnableSend = FALSE;
        BOOL fSending = FALSE;
        CVideoWindow *pLocal  = GetLocalVideo();
        if (NULL != pLocal)
        {
            fEnableSend = pLocal->IsXferAllowed() &&
                ((m_pConfRoom->GetMeetingPermissions() & NM_PERMIT_SENDVIDEO) != 0);
            fSending = fEnableSend &&
                !pLocal->IsPaused();
        }

        BOOL fEnableReceive = FALSE;
        BOOL fReceiving = FALSE;
        CVideoWindow *pRemote = GetRemoteVideo();
        if (NULL != pRemote)
        {
            fEnableReceive = pRemote->IsConnected();
            fReceiving = fEnableReceive &&
                !pRemote->IsPaused();
        }

        EnableMenuItem( hMenuTools,
                        MENUPOS_TOOLS_VIDEO,
                        (MF_BYPOSITION |
                         ((fEnableSend || fEnableReceive) ? MF_ENABLED : MF_GRAYED)));

        EnableMenuItem( hMenuTools,
                        ID_TOOLS_SENDVIDEO,
                        fEnableSend ? MF_ENABLED : MF_GRAYED);

        CheckMenuItem(  hMenuTools,
                        ID_TOOLS_SENDVIDEO,
                        fSending ? MF_CHECKED : MF_UNCHECKED);

        EnableMenuItem( hMenuTools,
                        ID_TOOLS_RECEIVEVIDEO,
                        fEnableReceive ? MF_ENABLED : MF_GRAYED);

        CheckMenuItem(  hMenuTools,
                        ID_TOOLS_RECEIVEVIDEO,
                        fReceiving ? MF_CHECKED : MF_UNCHECKED);

		EnableMenuItem(hMenuTools, ID_TOOLS_OPTIONS,
			MF_BYCOMMAND|MenuState(CanLaunchConfCpl()));

        //
        // OTHER TOOLS
        //
		EnableMenuItem(hMenuTools, ID_TB_NEWWHITEBOARD,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsNewWhiteboardAllowed()));
		EnableMenuItem(hMenuTools, ID_TB_WHITEBOARD,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsOldWhiteboardAllowed()));
		EnableMenuItem(hMenuTools, ID_TB_CHAT,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsChatAllowed()));
		EnableMenuItem(hMenuTools, ID_TB_FILETRANSFER,
			MF_BYCOMMAND|MenuState(m_pConfRoom->IsFileTransferAllowed()));
    }
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   SelAndRealizePalette()
*
*        PURPOSE:  Selects and realizes the NetMeeting palette
*
****************************************************************************/

BOOL CTopWindow::SelAndRealizePalette()
{
	BOOL bRet = FALSE;

	HPALETTE hPal = m_pConfRoom->GetPalette();
	if (NULL == hPal)
	{
		return(bRet);
	}

	HWND hwnd = GetWindow();

	HDC hdc = ::GetDC(hwnd);
	if (NULL != hdc)
	{
		::SelectPalette(hdc, hPal, FALSE);
		bRet = (GDI_ERROR != ::RealizePalette(hdc));

		::ReleaseDC(hwnd, hdc);
	}

	return bRet;
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   InitMenuFont()
*
*        PURPOSE:  Initializes/Updates the menu font member
*
****************************************************************************/

VOID CTopWindow::InitMenuFont()
{
	DebugEntry(CConfRoom::InitMenuFont);
	if (NULL != m_hFontMenu)
	{
		::DeleteObject(m_hFontMenu);
	}
	NONCLIENTMETRICS ncm;
	ncm.cbSize = sizeof(ncm);
	if (::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
	{
		m_hFontMenu = ::CreateFontIndirect(&(ncm.lfMenuFont));
		ASSERT(m_hFontMenu);
	}
	DebugExitVOID(CConfRoom::InitMenuFont);
}

CVideoWindow* CTopWindow::GetLocalVideo()
{
	CMainUI *pMainUI = GetMainUI();
	return (pMainUI ? pMainUI->GetLocalVideo() : NULL);
}

CVideoWindow* CTopWindow::GetRemoteVideo()
{
	CMainUI *pMainUI = GetMainUI();
	return (pMainUI ? pMainUI->GetRemoteVideo() : NULL);
}

BOOL CTopWindow::IsOnTop()
{
	return((GetWindowLong(GetWindow(), GWL_EXSTYLE)&WS_EX_TOPMOST) == WS_EX_TOPMOST);
}

void CTopWindow::SetOnTop(BOOL bOnTop)
{
	bOnTop = (bOnTop != FALSE);

	if (IsOnTop() == bOnTop)
	{
		// Nothing to do
		return;
	}

	SetWindowPos(GetWindow(), bOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
		0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
}

HPALETTE CTopWindow::GetPalette()
{
	return(m_pConfRoom->GetPalette());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\upropdlg.h ===
/****************************************************************************
*
*    FILE:     UPropDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 6-18-96
*
****************************************************************************/

#ifndef _UPROPDLG_H_
#define _UPROPDLG_H_


// 2 pages
#define PSP_MAX     2

struct UPROPDLGENTRY
{
	UINT	uProperty;
	LPTSTR	pszValue;
};
typedef UPROPDLGENTRY* PUPROPDLGENTRY;

class CUserPropertiesDlg
{
protected:
	HWND			m_hwndParent;
	HWND			m_hwnd;
	PUPROPDLGENTRY	m_pUPDE;
	int				m_nProperties;
	LPTSTR			m_pszName;
	UINT			m_uIcon;
	HICON			m_hIcon;
	PCCERT_CONTEXT	m_pCert;

	BOOL			OnPropertiesMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL			OnCredentialsMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL			OnInitPropertiesDialog();
	BOOL			OnInitCredentialsDialog();

	// Handlers:
	BOOL			OnOk();

public:
	
	// Methods:
					CUserPropertiesDlg(	HWND hwndParent,
										UINT uIcon);
					~CUserPropertiesDlg()	{ ::DestroyIcon(m_hIcon);	};
	INT_PTR	DoModal(PUPROPDLGENTRY pUPDE,
		            int nProperties,
		            LPTSTR pszName,
		            PCCERT_CONTEXT pCert);

	static INT_PTR CALLBACK UserPropertiesDlgProc(	HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam);
	static INT_PTR CALLBACK UserCredentialsDlgProc(	HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam);
};

#endif // _UPROPDLG_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\videocpl.cpp ===
// File: videocpl.cpp

#include "precomp.h"

#include "confcpl.h"
#include "help_ids.h"
#include "vidview.h"
#include "confroom.h"


static const DWORD aContextHelpIds[] = {

	IDC_SENDRECEIVE_GROUP,			IDH_VIDEO_SEND_RECEIVE,
	IDC_VIDEO_AUTOSEND, 			IDH_VIDEO_AUTO_SEND,
	IDC_VIDEO_AUTORECEIVE,			IDH_VIDEO_AUTO_RECEIVE,

	IDC_VIDEO_SQCIF,				IDH_VIDEO_SQCIF,
	IDC_VIDEO_QCIF, 				IDH_VIDEO_QCIF,
	IDC_VIDEO_CIF,					IDH_VIDEO_CIF,

	IDC_VIDEO_QUALITY_DESC, 		IDH_VIDEO_QUALITY,
	IDC_VIDEO_QUALITY,				IDH_VIDEO_QUALITY,
	IDC_VIDEO_QUALITY_LOW,			IDH_VIDEO_QUALITY,
	IDC_VIDEO_QUALITY_HIGH, 		IDH_VIDEO_QUALITY,

	IDC_CAMERA_GROUP,				IDH_VIDEO_CAMERA,
	IDC_COMBOCAP,					IDH_VIDEO_CAPTURE,
	IDC_VIDEO_SOURCE,				IDH_VIDEO_SOURCE,
	IDC_VIDEO_FORMAT,				IDH_VIDEO_FORMAT,
	IDC_VIDEO_MIRROR,               IDH_VIDEO_MIRROR,
	
	0, 0   // terminator
};

INT_PTR APIENTRY VideoDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	//BAD KARMA: this stuff should be in a struct and stored in "GWL_USERDATA"
	static PROPSHEETPAGE * ps;
	static BOOL fAllowSend = FALSE;
	static BOOL fAllowReceive = FALSE;
	static BOOL fOldAutoSend = FALSE;
	static BOOL fOldAutoReceive = FALSE;
	static BOOL fOldOpenLocalWindow = FALSE;
	static BOOL fOldCloseLocalWindow = FALSE;
	static DWORD dwOldQuality = FALSE;
	static DWORD dwNewQuality = 0;
	static DWORD dwOldFrameSize = 0;
	static DWORD dwNewFrameSize = 0;
	static BOOL fHasSourceDialog = FALSE;
	static BOOL fHasFormatDialog = FALSE;
	static BOOL dwFrameSizes = 0;
	static int nNumCapDev = 0;
	static DWORD dwOldCapDevID = 0;
	static DWORD dwNewCapDevID = 0;
	static int nMaxCapDevNameLen;
	static TCHAR *pszCapDevNames = (TCHAR *)NULL;
	static DWORD *pdwCapDevIDs = (DWORD *)NULL;
	static LPSTR szOldCapDevName = (LPSTR)NULL;
	static BOOL fOldMirror = FALSE;

	static CVideoWindow *m_pLocal  = NULL;
	static CVideoWindow *m_pRemote = NULL;


	RegEntry rePolicies( POLICIES_KEY, HKEY_CURRENT_USER );

	switch (message) {
		case WM_INITDIALOG:
		{
			RegEntry reVideo(VIDEO_KEY, HKEY_CURRENT_USER);
			LPSTR szTemp = (LPSTR)NULL;

			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;

			CConfRoom* pcr = ::GetConfRoom();
			ASSERT(NULL != pcr);
			m_pLocal  = pcr->GetLocalVideo();
			m_pRemote = pcr->GetRemoteVideo();
			ASSERT(NULL != m_pLocal && NULL != m_pRemote);

			fAllowSend = m_pLocal->IsXferAllowed();
			fAllowReceive = m_pRemote->IsXferAllowed();
			fOldAutoSend = m_pLocal->IsAutoXferEnabled();
			fOldAutoReceive = m_pRemote->IsAutoXferEnabled();
			fOldMirror = m_pLocal->GetMirror();
			dwFrameSizes = m_pLocal->GetFrameSizes();
			dwNewFrameSize = dwOldFrameSize = m_pLocal->GetFrameSize();
			dwNewQuality = dwOldQuality = m_pRemote->GetImageQuality();

			// If we have one or more capture devices installed, display its or their
			// names in a combo box. The user will be asked to select the device he/she
			// wants to use.

			if (nNumCapDev = m_pLocal->GetNumCapDev())
			{
				// Get the ID of the device currently selected
				nMaxCapDevNameLen = m_pLocal->GetMaxCapDevNameLen();
				dwOldCapDevID = reVideo.GetNumber(REGVAL_CAPTUREDEVICEID, ((UINT)-1));
				szTemp = reVideo.GetString(REGVAL_CAPTUREDEVICENAME);
				if (szTemp && (szOldCapDevName = (LPSTR)LocalAlloc(LPTR, sizeof(TCHAR) * nMaxCapDevNameLen)))
					lstrcpy(szOldCapDevName, szTemp);
				dwNewCapDevID = m_pLocal->GetCurrCapDevID();
				if ((!((dwOldCapDevID == ((UINT)-1)) || (dwNewCapDevID != dwOldCapDevID))) || (dwNewCapDevID == ((UINT)-1)))
					dwNewCapDevID = dwOldCapDevID;


				if (nMaxCapDevNameLen && (pdwCapDevIDs = (DWORD *)LocalAlloc(LPTR, nNumCapDev * (sizeof(TCHAR) * nMaxCapDevNameLen + sizeof(DWORD)))))
				{
					int i;

					pszCapDevNames = (TCHAR *)(pdwCapDevIDs + nNumCapDev);
					// Fill up the arrey of device IDs and names.
					// Only enabled capture devices are returned
					m_pLocal->EnumCapDev(pdwCapDevIDs, pszCapDevNames, nNumCapDev);

					// Are we still Ok?
					nNumCapDev = m_pLocal->GetNumCapDev();

					// Fill up the combo box with the capture devices names
					for (i=0; i<nNumCapDev; i++)
						SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_INSERTSTRING, i, (LPARAM)(pszCapDevNames + i * nMaxCapDevNameLen));

					// Set the default capture device in the combo box
					for (i=0; i<nNumCapDev; i++)
					{
						if (!i)
						{
							SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, 0, (LPARAM)NULL);
							// If for some reason, no device is registered yet, register one
							if (dwOldCapDevID == ((UINT)-1))
							{
								dwNewCapDevID = pdwCapDevIDs[i];
								reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID);
								reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames + i * nMaxCapDevNameLen));
							}
						}
						else
						{
							if (dwNewCapDevID == pdwCapDevIDs[i])
							{
								// The following will allow us to keep the right device
								// even if its ID has changed (if a lower ID device was
								// removed or added for instance)
								if (lstrcmp(szOldCapDevName, (LPSTR)(pszCapDevNames + i * nMaxCapDevNameLen)) != 0)
								{
									int j;

									// Look for the string in the array of device names
									for (j=0; j<nNumCapDev; j++)
										if (lstrcmp(szOldCapDevName, (LPSTR)(pszCapDevNames + j * nMaxCapDevNameLen)) == 0)
											break;
									if (j<nNumCapDev)
									{
										SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, j, (LPARAM)NULL);
										if (dwNewCapDevID != (DWORD)j)
										{
											// The device ID has changed but the device name was found
											// Set the current device ID to the new onew
											reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID = (DWORD)j);
											m_pLocal->SetCurrCapDevID(dwNewCapDevID);
										}
									}
									else
									{
										// This is either a totally new device or an updated version of the
										// driver. We should store the new string for that device
										reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames + i * nMaxCapDevNameLen));
										SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, i, (LPARAM)NULL);
									}
								}
								else
									SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_SETCURSEL, i, (LPARAM)NULL);
							}
							else
							{
								if ((dwNewCapDevID >= (DWORD)nNumCapDev) || (dwNewCapDevID != pdwCapDevIDs[dwNewCapDevID]))
								{
									// Device is missing! Use the first one as the new default
									dwNewCapDevID = pdwCapDevIDs[0];
									reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID);
									reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames));
									m_pLocal->SetCurrCapDevID(dwNewCapDevID);
								}
							}
						}
					}
				}
			}
			else
				EnableWindow(GetDlgItem(hDlg, IDC_COMBOCAP), FALSE);

			// The dialog caps need to be evaluated
			fHasSourceDialog = m_pLocal->IsXferEnabled() &&
					m_pLocal->HasDialog(NM_VIDEO_SOURCE_DIALOG);
			fHasFormatDialog = m_pLocal->IsXferEnabled() &&
					m_pLocal->HasDialog(NM_VIDEO_FORMAT_DIALOG);

			///////////////////////////////////////////////////////////
			//
			// Sending and Receiving Video
			//

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_AUTOSEND),
				fAllowSend && (0 != dwFrameSizes));
			CheckDlgButton(hDlg, IDC_VIDEO_AUTOSEND,
				fAllowSend && fOldAutoSend);

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_AUTORECEIVE), fAllowReceive);
			CheckDlgButton(hDlg, IDC_VIDEO_AUTORECEIVE,
					fAllowReceive && fOldAutoReceive);



			///////////////////////////////////////////////////////////
			//
			// Video Image
			//


			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SQCIF),
					fAllowSend && (dwFrameSizes & FRAME_SQCIF));
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QCIF),
					fAllowSend && (dwFrameSizes & FRAME_QCIF));
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CIF),
					fAllowSend && (dwFrameSizes & FRAME_CIF));

			switch (dwOldFrameSize & dwFrameSizes)
			{
				case FRAME_SQCIF:
					CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
					break;

				case FRAME_CIF:
					CheckDlgButton(hDlg, IDC_VIDEO_CIF, TRUE);
					break;

				case FRAME_QCIF:
				default:
					CheckDlgButton(hDlg, IDC_VIDEO_QCIF, TRUE);
					break;
			}

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY),
					fAllowReceive);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY_DESC),
					fAllowReceive);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY_LOW),
					fAllowReceive);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QUALITY_HIGH),
					fAllowReceive);
			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETRANGE, FALSE,
				MAKELONG (NM_VIDEO_MIN_QUALITY, NM_VIDEO_MAX_QUALITY ));

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETTICFREQ,
				( NM_VIDEO_MAX_QUALITY - NM_VIDEO_MIN_QUALITY )
														/ 8, 0 );

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETPAGESIZE,
				0, ( NM_VIDEO_MAX_QUALITY - NM_VIDEO_MIN_QUALITY ) / 8 );

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETLINESIZE,
				0, 1 );

			SendDlgItemMessage (hDlg, IDC_VIDEO_QUALITY, TBM_SETPOS, TRUE,
								dwOldQuality );


			///////////////////////////////////////////////////////////
			//
			// Video Card and Camera
			//

			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SOURCE), fAllowSend && fHasSourceDialog);
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_FORMAT), fAllowSend && fHasFormatDialog);

			// mirror video button
			EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_MIRROR), fAllowSend);
			Button_SetCheck(GetDlgItem(hDlg, IDC_VIDEO_MIRROR), fOldMirror);

			return (TRUE);
		}

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_APPLY:
				{
					BOOL fChecked;
					
					///////////////////////////////////////////////////////////
					//
					// Sending and Receiving Video
					//

					if (fAllowSend)
					{
						fChecked = IsDlgButtonChecked(hDlg, IDC_VIDEO_AUTOSEND);

						if ( fChecked != fOldAutoSend )
						{
							m_pLocal->EnableAutoXfer(fChecked);
							g_dwChangedSettings |= CSETTING_L_VIDEO;
						}
					}


					if (fAllowReceive)
					{
						fChecked = IsDlgButtonChecked(hDlg, IDC_VIDEO_AUTORECEIVE);

						if ( fChecked != fOldAutoReceive ) {
							m_pRemote->EnableAutoXfer(fChecked);
							g_dwChangedSettings |= CSETTING_L_VIDEO;
						}
					}

					///////////////////////////////////////////////////////////
					//
					// Video Image
					//

					if (dwNewFrameSize != dwOldFrameSize )
					{
						g_dwChangedSettings |= CSETTING_L_VIDEOSIZE;
					}

					if ( dwNewQuality != dwOldQuality )
					{
						g_dwChangedSettings |= CSETTING_L_VIDEO;
					}

					///////////////////////////////////////////////////////////
					//
					// Capture Device
					//

					if (dwNewCapDevID != dwOldCapDevID)
					{
						g_dwChangedSettings |= CSETTING_L_CAPTUREDEVICE;
					}

					break;
				}

				case PSN_RESET:
				{
					// restore settings
					if ( dwNewQuality != dwOldQuality )
					{
						m_pRemote->SetImageQuality(dwOldQuality);
					}

					if ( dwNewFrameSize != dwOldFrameSize )
					{
						m_pLocal->SetFrameSize(dwOldFrameSize);
					}

					if (dwNewCapDevID != dwOldCapDevID)
					{
						// Set the capture device ID back to its old value
						RegEntry reVideo(VIDEO_KEY, HKEY_CURRENT_USER);
						reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwOldCapDevID);
						reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, szOldCapDevName);

						m_pLocal->SetCurrCapDevID(dwOldCapDevID);
					}

					m_pLocal->SetMirror(fOldMirror);
				}
			}
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_VIDEO_SOURCE:
					if ( HIWORD(wParam) == BN_CLICKED ) {
						m_pLocal->ShowDialog(NM_VIDEO_SOURCE_DIALOG);
					}
					break;

				case IDC_VIDEO_FORMAT:
					if ( HIWORD(wParam) == BN_CLICKED ) {
						m_pLocal->ShowDialog(NM_VIDEO_FORMAT_DIALOG);
					}
					break;
				case IDC_VIDEO_SQCIF:
					if (( HIWORD(wParam) == BN_CLICKED )
						&& (dwNewFrameSize != FRAME_SQCIF))
					{
						dwNewFrameSize = FRAME_SQCIF;
						m_pLocal->SetFrameSize(dwNewFrameSize);
					}
					break;
				case IDC_VIDEO_CIF:
					if (( HIWORD(wParam) == BN_CLICKED )
						&& (dwNewFrameSize != FRAME_CIF))
					{
						dwNewFrameSize = FRAME_CIF;
						m_pLocal->SetFrameSize(dwNewFrameSize);
					}
					break;
				case IDC_VIDEO_QCIF:
					if (( HIWORD(wParam) == BN_CLICKED )
						&& (dwNewFrameSize != FRAME_QCIF))
					{
						dwNewFrameSize = FRAME_QCIF;
						m_pLocal->SetFrameSize(dwNewFrameSize);
					}
					break;

				case IDC_VIDEO_MIRROR:
					if ((HIWORD(wParam) == BN_CLICKED))
					{
						BOOL bRet;
						bRet = Button_GetCheck((HWND)lParam);
						if (m_pLocal)
						{
							m_pLocal->SetMirror(bRet);
						}
					}

				case IDC_COMBOCAP:
					if (LBN_SELCHANGE == HIWORD(wParam))
					{
						int index;
						RegEntry reVideo(VIDEO_KEY, HKEY_CURRENT_USER);

						index = (int)SendMessage(GetDlgItem(hDlg, IDC_COMBOCAP), CB_GETCURSEL, 0, 0);
						dwNewCapDevID = pdwCapDevIDs[index];
						reVideo.SetValue(REGVAL_CAPTUREDEVICEID, dwNewCapDevID);
						reVideo.SetValue(REGVAL_CAPTUREDEVICENAME, (LPSTR)(pszCapDevNames + index * nMaxCapDevNameLen));

						if (dwNewCapDevID != (DWORD)m_pLocal->GetCurrCapDevID())
						{
							m_pLocal->SetCurrCapDevID(dwNewCapDevID);

							// The dialog caps need to be reevaluated
							fHasSourceDialog = m_pLocal->IsXferEnabled() &&
									m_pLocal->HasDialog(NM_VIDEO_SOURCE_DIALOG);
							fHasFormatDialog = m_pLocal->IsXferEnabled() &&
									m_pLocal->HasDialog(NM_VIDEO_FORMAT_DIALOG);
							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SOURCE), fAllowSend && fHasSourceDialog);
							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_FORMAT), fAllowSend && fHasFormatDialog);

							// Update the size buttons
							dwFrameSizes = m_pLocal->GetFrameSizes();

							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_SQCIF), fAllowSend && (dwFrameSizes & FRAME_SQCIF));
							if (dwNewFrameSize & FRAME_SQCIF)
							{
								if (dwFrameSizes & FRAME_SQCIF)
									CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
								else
								{
									if (dwFrameSizes & FRAME_QCIF)
										dwNewFrameSize = FRAME_QCIF;
									else if (dwFrameSizes & FRAME_CIF)
										dwNewFrameSize = FRAME_CIF;
									CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, FALSE);
								}
							}
							else
							{
								CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, FALSE);
							}

							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_QCIF), fAllowSend && (dwFrameSizes & FRAME_QCIF));
							if (dwNewFrameSize & FRAME_QCIF)
							{
								if (dwFrameSizes & FRAME_QCIF)
									CheckDlgButton(hDlg, IDC_VIDEO_QCIF, TRUE);
								else
								{
									if (dwFrameSizes & FRAME_SQCIF)
									{
										dwNewFrameSize = FRAME_SQCIF;
										CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
									}
									else if (dwFrameSizes & FRAME_CIF)
										dwNewFrameSize = FRAME_CIF;
									CheckDlgButton(hDlg, IDC_VIDEO_QCIF, FALSE);
								}
							}
							else
							{
								CheckDlgButton(hDlg, IDC_VIDEO_QCIF, FALSE);
							}

							EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CIF), fAllowSend && (dwFrameSizes & FRAME_CIF));
							if (dwNewFrameSize & FRAME_CIF)
							{
								if (dwFrameSizes & FRAME_CIF)
									CheckDlgButton(hDlg, IDC_VIDEO_CIF, TRUE);
								else
								{
									if (dwFrameSizes & FRAME_QCIF)
									{
										dwNewFrameSize = FRAME_QCIF;
										CheckDlgButton(hDlg, IDC_VIDEO_QCIF, TRUE);
									}
									else if (dwFrameSizes & FRAME_SQCIF)
									{
										dwNewFrameSize = FRAME_SQCIF;
										CheckDlgButton(hDlg, IDC_VIDEO_SQCIF, TRUE);
									}
									CheckDlgButton(hDlg, IDC_VIDEO_CIF, FALSE);
								}
							}
							else
							{
								CheckDlgButton(hDlg, IDC_VIDEO_CIF, FALSE);
							}

							m_pLocal->SetFrameSize(dwNewFrameSize);
						}
					}
					break;
			}
			break;

		case WM_HSCROLL:
			if (TB_ENDTRACK == LOWORD(wParam))
			{
				DWORD dwValue = (DWORD)SendDlgItemMessage( hDlg, IDC_VIDEO_QUALITY,
							TBM_GETPOS, 0, 0 );

				if ( dwValue != dwNewQuality ) {
					dwNewQuality = dwValue;
					m_pRemote->SetImageQuality(dwNewQuality);
				}
			}
			break;

		case WM_DESTROY:
			if (pdwCapDevIDs)
			{
				LocalFree(pdwCapDevIDs);
				pdwCapDevIDs = (DWORD *)NULL;
			}
			if (szOldCapDevName)
			{
				LocalFree(szOldCapDevName);
				szOldCapDevName = (LPSTR)NULL;
			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, aContextHelpIds);
			break;

		case WM_HELP:
			DoHelp(lParam, aContextHelpIds);
			break;
	}
	return (FALSE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\videowindow.cpp ===
// VideoWindow.cpp : Implementation of CVideoWindowObj
#include "Precomp.h"
#include "VidView.h"
#include "VideoWindow.h"

/////////////////////////////////////////////////////////////////////////////
// CVideoWindowObj


CVideoWindowObj::CVideoWindowObj()
: m_pVideoView( NULL ),
  m_hWndEdit( NULL )
{
	DBGENTRY(CVideoWindowObj::CVideoWindowObj);

	m_bWindowOnly = TRUE;

	DBGEXIT(CVideoWindowObj::CVideoWindowObj);
}

CVideoWindowObj::~CVideoWindowObj()
{
	DBGENTRY(CVideoWindowObj::~CVideoWindowObj);
	if( m_pVideoView )
	{
		delete m_pVideoView;
	}

	DBGEXIT(CVideoWindowObj::~CVideoWindowObj);
}


/*virtual*/ 
HWND CVideoWindowObj::CreateControlWindow(HWND hWndParent, RECT& rcPos)
{

	Create(hWndParent, rcPos);
	if( m_hWnd )
	{
		m_pVideoView = new CVideoView;
		if (NULL != m_pVideoView)
		{
			if (NULL == m_pVideoView->Create(m_hWnd))
			{
				delete m_pVideoView;
				m_pVideoView = NULL;
			}
			else
			{
				m_pVideoView->DeferredInit();
				m_pVideoView->Resize( m_rcPos.left, m_rcPos.top, RectWidth( m_rcPos ), RectHeight( m_rcPos ) );
				m_pVideoView->Show(TRUE);
			}
		}
    }
	else
	{
		ASSERT( 0 );
	}

	return m_hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\videowindow.h ===
// VideoWindow.h : Declaration of the CVideoWindowObj

#ifndef __VIDEOWINDOW_H_
#define __VIDEOWINDOW_H_

#include "resource.h"       // main symbols
#include "NetMeeting.h"

/////////////////////////////////////////////////////////////////////////////
// CVideoWindowObj
class ATL_NO_VTABLE CVideoWindowObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IVideoWindow, &IID_IVideoWindow, &LIBID_NetMeetingLib>,
	public CComControl<CVideoWindowObj>,
	public IPersistStreamInitImpl<CVideoWindowObj>,
	public IOleControlImpl<CVideoWindowObj>,
	public IOleObjectImpl<CVideoWindowObj>,
	public IOleInPlaceActiveObjectImpl<CVideoWindowObj>,
	public IViewObjectExImpl<CVideoWindowObj>,
	public IOleInPlaceObjectWindowlessImpl<CVideoWindowObj>,
	public CComCoClass<CVideoWindowObj, &CLSID_VideoWindow>,
	public ISupportErrorInfoImpl<&IID_IVideoWindow>,
	public IObjectSafetyImpl<CVideoWindowObj, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{

private:
	CVideoView*	m_pVideoView;
	HWND		m_hWndEdit;

public:
	CVideoWindowObj();
	~CVideoWindowObj();

DECLARE_REGISTRY_RESOURCEID(IDR_VIDEOWINDOW)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVideoWindowObj)
	COM_INTERFACE_ENTRY(IVideoWindow)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CVideoWindowObj)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CVideoWindowObj)
//	CHAIN_MSG_MAP(CComControl<CVideoWindowObj>)
	MESSAGE_HANDLER(WM_PAINT, MyOnPaint)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()

  virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

  LRESULT MyOnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
  {
	PAINTSTRUCT ps;
	::BeginPaint(m_hWnd, &ps );

	if( ::IsWindow( m_hWndEdit ) )
	{
		::InvalidateRect(m_hWndEdit, NULL, TRUE);
		::UpdateWindow( m_hWndEdit );
			TRACE_OUT(("MyOnPaint"));
	}
	
	::EndPaint( m_hWnd, &ps );

	return 1;
  }

// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

public:
};

#endif //__VIDEOWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\vidview.cpp ===
// File: videview.cpp

#include "precomp.h"

#include "vidview.h"
#include "resource.h"
#include "confman.h"
#include "rtoolbar.h"
#include "pfndrawd.h"
#include "NmManager.h"
#include "cmd.h"

#define DibHdrSize(lpbi)		((lpbi)->biSize + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibDataSize(lpbi)		((lpbi)->biSizeImage)
#define DibSize(lpbi)			(DibHdrSize(lpbi) + DibDataSize(lpbi))

typedef struct
{
	DWORD *pdwCapDevIDs;
	LPTSTR pszCapDevNames;
	DWORD dwNumCapDev;
} ENUM_CAP_DEV;

CSimpleArray<CVideoWindow *> *CVideoWindow::g_pVideos;
BOOL CVideoWindow::g_fMirror = FALSE;
BOOL CVideoWindow::g_bLocalOneTimeInited = FALSE;

static const TCHAR REGVAL_VIDEO_QUALITY[] = TEXT("ImageQuality");

static const UINT VIDEO_ZOOM_MIN = 50;
static const UINT VIDEO_ZOOM_MAX = 400;

static const UINT QCIF_WIDTH  = 176;
static const UINT QCIF_HEIGHT = 144;

CVideoWindow::CVideoWindow(VideoType eType, BOOL bEmbedded) :
	m_dwFrameSize(NM_VIDEO_MEDIUM),
	m_hdd(NULL),
#ifdef DISPLAYFPS
	m_cFrame (0),
	m_dwTick (GetTickCount()),
#endif // DISPLAYFPS
	m_pActiveChannel(NULL),
	m_dwCookie(0),
	m_dwImageQuality(NM_VIDEO_MIN_QUALITY),
	m_pNotify(NULL),
	m_fLocal(REMOTE!=eType),
	m_hBitmapMirror(NULL),
	m_hDCMirror(NULL),
	m_fZoomable(TRUE),
	m_bEmbedded(bEmbedded),
	m_hGDIObj(NULL)
{
	if (NULL == g_pVideos)
	{
		g_pVideos = new CSimpleArray<CVideoWindow*>;
	}
	if (NULL != g_pVideos)
	{
		CVideoWindow* p = static_cast<CVideoWindow*>(this);
		g_pVideos->Add(p);
	}

	m_sizeVideo.cx = 0;
	m_sizeVideo.cy = 0;

	RegEntry reAudio(AUDIO_KEY); // HKCU
	RegEntry reVideo( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
			HKEY_CURRENT_USER );

	DWORD dwFrameSizeDefault = FRAME_QCIF;
	DWORD dwImageQualityDefault = NM_VIDEO_DEFAULT_QUALITY;
	int nVideoWidthDefault = VIDEO_WIDTH_QCIF;
	int nVideoHeightDefault = VIDEO_HEIGHT_QCIF;

	UINT uBandWidth = reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH, BW_DEFAULT);
	if (uBandWidth == BW_144KBS)
	{
		dwImageQualityDefault = NM_VIDEO_MIN_QUALITY;
	}

	m_dwFrameSize = reVideo.GetNumber(
			REGVAL_VIDEO_FRAME_SIZE, dwFrameSizeDefault );

	if (!IsLocal())
	{
		m_dwImageQuality = reVideo.GetNumber(
				REGVAL_VIDEO_QUALITY, dwImageQualityDefault );
	}

	m_nXferOnConnect =
		IsLocal() ? VIDEO_SEND_CONNECT_DEFAULT :
		VIDEO_RECEIVE_CONNECT_DEFAULT;


	m_nXferOnConnect = reVideo.GetNumber(
		REGVAL_VIDEO_XFER_CONNECT,
		m_nXferOnConnect);

	m_zoom = 100;
}

VOID CVideoWindow::OnNCDestroy()
{
	// remote channel will get released upon the NM_CHANNEL_REMOVED
	// notification.  The preview channel needs to be released here,
	// and not in the destructor because of a circular ref count
	if (NULL != m_pActiveChannel)
	{
		NmUnadvise(m_pActiveChannel, IID_INmChannelVideoNotify, m_dwCookie);
		m_dwCookie = 0;
		m_pActiveChannel->Release();
		m_pActiveChannel = NULL;
	}

	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}
}

CVideoWindow::~CVideoWindow()
{
	CVideoWindow* p = static_cast<CVideoWindow*>(this);
	g_pVideos->Remove(p);
	if (0 == g_pVideos->GetSize())
	{
		delete g_pVideos;
		g_pVideos = NULL;
	}

	if (NULL != m_hdd)
	{
		DRAWDIB::DrawDibClose(m_hdd);
	}
	// BUGBUG PhilF: Does DrawDibClose() nuke the selected palette?


	// release resources related to mirror preview
	UnInitMirroring();
}

BOOL CVideoWindow::Create(HWND hwndParent, HPALETTE hpal, IVideoChange *pNotify)
{
	if (FAILED(DRAWDIB::Init()))
	{
		return(FALSE);
	}

	if (!CGenWindow::Create(
		hwndParent,
		0,
		IsLocal() ? TEXT("NMLocalVideo") : TEXT("NMRemoteVideo"),
		WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
		WS_EX_CLIENTEDGE))
	{
		return(FALSE);
	}

	SetWindowPos(GetWindow(), NULL, 0, 0, m_sizeVideo.cx, m_sizeVideo.cy,
		SWP_NOZORDER|SWP_NOACTIVATE);

	// We do NOT own this palette
	m_hPal = hpal;

	m_hdd = DRAWDIB::DrawDibOpen();
	if (NULL != m_hdd)
	{
		// Use the Indeo palette in 8 bit mode only if the decompressed
		// video data is H.261 or H.263. We will create this palette as
		// an identity palette.

		// PhilF: If the user is utilizing an installable codec, do we still want to do this?

		// Update the palette in the DrawDib surface
		if (NULL != hpal)
		{
			DRAWDIB::DrawDibSetPalette(m_hdd, hpal);
		}
	}

	if (NULL != pNotify)
	{
		m_pNotify = pNotify;
		m_pNotify->AddRef();
	}
	
	if (IsLocal())
	{
		// need to get PreviewChannel;
		INmManager2 *pManager = CConfMan::GetNmManager();
		ASSERT (NULL != pManager);
		pManager->GetPreviewChannel(&m_pActiveChannel);
		pManager->Release();

		if (m_pActiveChannel)
		{
			NmAdvise(m_pActiveChannel, static_cast<INmChannelVideoNotify*>(this),
				IID_INmChannelVideoNotify, &m_dwCookie);

			DWORD_PTR dwFrameSize = GetFrameSize();
			if (g_bLocalOneTimeInited)
			{
				m_pActiveChannel->GetProperty(NM_VIDPROP_IMAGE_PREFERRED_SIZE, &dwFrameSize);
			}
			else
			{
				DWORD dwSizes = GetFrameSizes();

				// if frame size is not valid
				if (!(m_dwFrameSize & dwSizes))
				{
					// find an alternate size
					if (FRAME_QCIF & dwSizes)
					{
						dwFrameSize = FRAME_QCIF;
					}
					else if (FRAME_SQCIF & dwSizes)
					{
						dwFrameSize = FRAME_SQCIF;
					}
					else if (FRAME_CIF & dwSizes)
					{
						dwFrameSize = FRAME_CIF;
					}
				}

				RegEntry reVideo( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
						HKEY_CURRENT_USER );
				SetMirror(reVideo.GetNumber(REGVAL_VIDEO_MIRROR, TRUE));

				g_bLocalOneTimeInited = TRUE;
			}

			SetFrameSize((DWORD)dwFrameSize);
		}
	}

	ResizeWindowsToFrameSize();

	return TRUE;
}

DWORD CVideoWindow::GetFrameSizes()
{
	DWORD_PTR dwSizes = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_IMAGE_SIZES, &dwSizes);
	}

	return (DWORD)dwSizes;
}

VOID CVideoWindow::SetFrameSize(DWORD dwSize)
{
	DWORD dwPrevSize = m_dwFrameSize;

	m_dwFrameSize = dwSize;
	if (IsLocal())
	{
		if (NULL != m_pActiveChannel)
		{
			m_pActiveChannel->SetProperty(NM_VIDPROP_IMAGE_PREFERRED_SIZE, dwSize);
		}
	}

	if (dwPrevSize != dwSize)
	{
		if ((NULL == m_pActiveChannel) ||
			(!IsLocal() && (S_OK != m_pActiveChannel->IsActive())) ||
			(IsLocal() && IsPaused()))
		{
			ResizeWindowsToFrameSize();
		}
	}
}

VOID CVideoWindow::ResizeWindowsToFrameSize()
{
	SIZE size; 

	switch(m_dwFrameSize)
	{
	case FRAME_SQCIF:
		size.cx = VIDEO_WIDTH_SQCIF;
		size.cy = VIDEO_HEIGHT_SQCIF;
		break;
	case FRAME_CIF:
		if (IsLocal())
		{
			size.cx = VIDEO_WIDTH_CIF;
			size.cy = VIDEO_HEIGHT_CIF;
			break;
		}
		// else fall through to QCIF
	case FRAME_QCIF:
	default:
		size.cx = VIDEO_WIDTH_QCIF;
		size.cy = VIDEO_HEIGHT_QCIF;
		break;
	}

	SetVideoSize(&size);
}

STDMETHODIMP CVideoWindow::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmChannelVideoNotify) || (riid == IID_IUnknown))
	{
		*ppv = static_cast<INmChannelVideoNotify *>(this);
		DbgMsgApi("CVideoWindow::QueryInterface()");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CVideoWindow::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CVideoWindow::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CVideoWindow::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	return S_OK;
}

STDMETHODIMP CVideoWindow::StateChanged(NM_VIDEO_STATE uState)
{
	InvalidateRect(GetWindow(), NULL, TRUE);

	if (NULL != m_pNotify)
	{
		m_pNotify->StateChange(this, uState);
	}

	CNmManagerObj::VideoChannelStateChanged(uState, !m_fLocal);

	return S_OK;
}

STDMETHODIMP CVideoWindow::PropertyChanged(DWORD dwReserved)
{
	if (NM_VIDPROP_FRAME == dwReserved)
	{
		OnFrameAvailable();
	}
	return S_OK;
}

HRESULT	CVideoWindow::OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	INmChannelVideo* pChannelVideo;
	if (SUCCEEDED(pChannel->QueryInterface(IID_INmChannelVideo, (void**)&pChannelVideo)))
	{
		BOOL bIncoming = (S_OK == pChannelVideo->IsIncoming());
		if ((bIncoming && !IsLocal()) || (!bIncoming && IsLocal()))
		{
			switch (uNotify)
			{
			case NM_CHANNEL_ADDED:
				if (NULL == m_pActiveChannel)
				{
					pChannelVideo->AddRef();
					m_pActiveChannel = pChannelVideo;
					NmAdvise(m_pActiveChannel,static_cast<INmChannelVideoNotify*>(this),
						IID_INmChannelVideoNotify, &m_dwCookie);

					SetImageQuality(m_dwImageQuality);
				}

				if (!_Module.InitControlMode())
				{
					switch(m_nXferOnConnect)
					{
					case VIDEO_XFER_START:
						if (IsPaused())
						{
							Pause(FALSE);
						}
						break;

					case VIDEO_XFER_STOP:
						Pause(TRUE);
						break;

					default:
						if (!IsLocal())
						{
							Pause(TRUE);
						}
						break;
					}
				}
				break;

			case NM_CHANNEL_REMOVED:
				if (!IsLocal() && (pChannel == m_pActiveChannel))
				{
					NmUnadvise(m_pActiveChannel, IID_INmChannelVideoNotify, m_dwCookie);
					m_pActiveChannel->Release();
					m_pActiveChannel = NULL;
					m_dwCookie = 0;

					ResizeWindowsToFrameSize();
				}
			}

			// just in case we missed a notification
			// (in final version this should not be the case)
			// m_VideoWindow.OnStateChange();
		}

		pChannelVideo->Release();
	}

	return S_OK;
}

HRESULT CVideoWindow::SetImageQuality(DWORD dwQuality)
{
	HRESULT hr = E_FAIL;
	m_dwImageQuality = dwQuality;
	if (NULL != m_pActiveChannel)
	{
		hr = m_pActiveChannel->SetProperty(NM_VIDPROP_IMAGE_QUALITY, dwQuality);

		CNmManagerObj::VideoPropChanged(NM_VIDPROP_IMAGE_QUALITY, !IsLocal());
	}

	return hr;
}


HRESULT CVideoWindow::SetCameraDialog(ULONG ul)
{
	if(IsLocal())
	{
		return m_pActiveChannel->SetProperty(NM_VIDPROP_CAMERA_DIALOG, ul);
		CNmManagerObj::VideoPropChanged(NM_VIDPROP_CAMERA_DIALOG, IsLocal());
	}

	return E_FAIL;
}

HRESULT CVideoWindow::GetCameraDialog(ULONG* pul)
{
    HRESULT hr;
    DWORD_PTR dwPropVal;

	if(IsLocal())
	{
		hr = m_pActiveChannel->GetProperty(NM_VIDPROP_CAMERA_DIALOG, &dwPropVal);
        *pul = (ULONG)dwPropVal;
        return hr;
	}

	return E_FAIL;
}


BOOL CVideoWindow::IsXferAllowed()
{
	if (IsLocal())
	{
		return FIsSendVideoAllowed() && (NULL != m_pActiveChannel);
	}
	else
	{
		return FIsReceiveVideoAllowed();
	}
}

BOOL CVideoWindow::IsAutoXferEnabled()
{
	return(VIDEO_XFER_START == m_nXferOnConnect);
}

BOOL CVideoWindow::IsXferEnabled()
{
	if (NULL != m_pActiveChannel)
	{
		NM_VIDEO_STATE state;
		if (SUCCEEDED(m_pActiveChannel->GetState(&state)))
		{
			switch (state)
			{
			case NM_VIDEO_PREVIEWING:
			case NM_VIDEO_TRANSFERRING:
			case NM_VIDEO_REMOTE_PAUSED:
				return TRUE;
			case NM_VIDEO_IDLE:
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_BOTH_PAUSED:
			default:
				return FALSE;
			}
		}
	}
	return FALSE;
}

HRESULT CVideoWindow::GetVideoState(NM_VIDEO_STATE* puState)
{
	if(m_pActiveChannel)
	{
		return m_pActiveChannel->GetState(puState);
	}

	return E_FAIL;
}

VOID CVideoWindow::Pause(BOOL fPause)
{
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->SetProperty(NM_VIDPROP_PAUSE, (ULONG)fPause);

		CNmManagerObj::VideoPropChanged(NM_VIDPROP_PAUSE, !IsLocal());
	}
}

BOOL CVideoWindow::IsPaused()
{
	if (NULL != m_pActiveChannel)
	{
		ULONG_PTR uPause;
		if (SUCCEEDED(m_pActiveChannel->GetProperty(NM_VIDPROP_PAUSE, &uPause)))
		{
			return (BOOL)uPause;
		}
	}
	return TRUE;
}

BOOL CVideoWindow::IsConnected()
{
	if (NULL != m_pActiveChannel)
	{
		NM_VIDEO_STATE state;
		if (SUCCEEDED(m_pActiveChannel->GetState(&state)))
		{
			switch (state)
			{
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_TRANSFERRING:
			case NM_VIDEO_BOTH_PAUSED:
			case NM_VIDEO_REMOTE_PAUSED:
				return TRUE;
			case NM_VIDEO_IDLE:
			case NM_VIDEO_PREVIEWING:
			default:
				return FALSE;
			}
		}
	}
	return FALSE;
}

DWORD CVideoWindow::GetNumCapDev()
{
	DWORD_PTR dwNumDevs = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_NUM_CAPTURE_DEVS, &dwNumDevs);
	}
	return (DWORD)dwNumDevs;
}

DWORD CVideoWindow::GetMaxCapDevNameLen()
{
	DWORD_PTR dwLen = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_MAX_CAPTURE_NAME, &dwLen);
	}
	return (DWORD)dwLen;
}

DWORD CVideoWindow::GetCurrCapDevID()
{
	DWORD_PTR dwID = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_CAPTURE_DEV_ID, &dwID);
	}
	return (DWORD)dwID;
}

VOID CVideoWindow::SetCurrCapDevID(DWORD dwID)
{	
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->SetProperty(NM_VIDPROP_CAPTURE_DEV_ID, dwID);
        InvalidateRect(GetWindow(), NULL, TRUE);
	}
}

VOID CVideoWindow::EnableAutoXfer(BOOL fEnable)
{
	m_nXferOnConnect = fEnable ? VIDEO_XFER_START : VIDEO_XFER_NOP;

	RegEntry reXfer( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
		HKEY_CURRENT_USER );
	
	reXfer.SetValue ( REGVAL_VIDEO_XFER_CONNECT, m_nXferOnConnect);
}

VOID CVideoWindow::EnumCapDev(DWORD *pdwCapDevIDs, LPTSTR pszCapDevNames, DWORD dwNumCapDev)
{
	ENUM_CAP_DEV enumCapDev;
	enumCapDev.pdwCapDevIDs = pdwCapDevIDs;
	enumCapDev.pszCapDevNames = pszCapDevNames;
	enumCapDev.dwNumCapDev = dwNumCapDev;

	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_CAPTURE_LIST, (DWORD_PTR *)&enumCapDev);
	}
}

VOID CVideoWindow::GetDesiredSize(SIZE *ppt)
{
	ppt->cx = m_sizeVideo.cx*m_zoom/100;
	ppt->cy = m_sizeVideo.cy*m_zoom/100;

	if (m_bEmbedded)
	{
		ppt->cx = min(ppt->cx, QCIF_WIDTH);
		ppt->cy = min(ppt->cy, QCIF_HEIGHT);
	}

	SIZE sGen;
	CGenWindow::GetDesiredSize(&sGen);

	ppt->cx += sGen.cx;
	ppt->cy += sGen.cy;
}

VOID CVideoWindow::SetVideoSize(LPSIZE lpsize)
{
	m_sizeVideo = *lpsize;

	OnDesiredSizeChanged();
}

#ifdef DEBUG
DWORD g_fDisplayFPS = FALSE;

#ifdef DISPLAYFPS
VOID CVideoWindow::UpdateFps(void)
{
	DWORD dwTick = GetTickCount();
	m_cFrame++;
	// Update display every 4 seconds
	if ((dwTick - m_dwTick) < 4000)
		return;

	TCHAR sz[32];
	wsprintf(sz, "%d FPS", m_cFrame / 4);
	SetWindowText(m_hwndParent, sz);

	m_cFrame = 0;
	m_dwTick = dwTick;
}
#endif /* DISPLAYFPS */
#endif // DEBUG

VOID CVideoWindow::OnFrameAvailable(void)
{
	::InvalidateRect(GetWindow(), NULL, FALSE);

#ifdef DISPLAYFPS
	if (g_fDisplayFPS)
	{
		UpdateFps();
	}
#endif // DISPLAYFPS
}


VOID CVideoWindow::PaintDib(HDC hdc, FRAMECONTEXT *pFrame)
{
	RECT rcVideo;
	GetClientRect(GetWindow(), &rcVideo);

	HPALETTE hpOld = NULL;

	if (NULL != m_hPal)
	{
		hpOld = SelectPalette(hdc, m_hPal, FALSE);
		RealizePalette(hdc);
	}

	// create the bitmap object, only if it doesn't exist
	// and if the mirror bitmap object isn't the right size
	if (!ShouldMirror() || !InitMirroring(rcVideo))
	{
		// ISSUE: (ChrisPi 2-19-97) should we use DDF_SAME_HDC?
		DRAWDIB::DrawDibDraw(m_hdd,hdc,
				rcVideo.left,
				rcVideo.top,
				RectWidth(rcVideo),
				RectHeight(rcVideo),
				&pFrame->lpbmi->bmiHeader,
				pFrame->lpData,
				pFrame->lpClipRect->left,
				pFrame->lpClipRect->top,
				RectWidth(pFrame->lpClipRect),
				RectHeight(pFrame->lpClipRect),
				0);
	}
	else
	{
		if (NULL != m_hPal)
		{
			SelectPalette(m_hDCMirror, m_hPal, FALSE);
			RealizePalette(m_hDCMirror);
		}

		DRAWDIB::DrawDibDraw(m_hdd,
				m_hDCMirror,
				0,
				0,
				RectWidth(rcVideo),
				RectHeight(rcVideo),
				&pFrame->lpbmi->bmiHeader,
				pFrame->lpData,
				pFrame->lpClipRect->left,
				pFrame->lpClipRect->top,
				RectWidth(pFrame->lpClipRect),
				RectHeight(pFrame->lpClipRect),
				0);

		::StretchBlt(hdc,
				rcVideo.right,
				rcVideo.top,
				-RectWidth(rcVideo),
				RectHeight(rcVideo),
				m_hDCMirror,
				0,
				0,
				RectWidth(rcVideo),
				RectHeight(rcVideo),
				SRCCOPY);

		// HACKHACK georgep; don't worry about deselecting the palette in
		// the temp DC
	}

	if (NULL != hpOld)
	{
		SelectPalette(hdc, hpOld, FALSE);
	}
}

/*  P A I N T  L O G O  */
/*-------------------------------------------------------------------------
    %%Function: PaintLogo

    Display the 256 color NetMeeting logo in the video window.
-------------------------------------------------------------------------*/
VOID CVideoWindow::PaintLogo(HDC hdc, UINT idbLargeLogo, UINT idbSmallLogo)
{
	RECT rcVideo;
	GetClientRect(GetWindow(), &rcVideo);

	::FillRect(hdc, &rcVideo, (HBRUSH)::GetStockObject(WHITE_BRUSH));

	// Create the memory DC
	HDC hdcMem = ::CreateCompatibleDC(hdc);
	if (NULL == hdcMem)
	{
		ERROR_OUT(("PaintLogo: Unable to CreateCompatibleDC"));
		return;
	}

	// Load the bitmap  (LoadBitmap doesn't work for 256 color images)
	HANDLE hBitmap = LoadImage(::GetInstanceHandle(),
			MAKEINTRESOURCE(idbLargeLogo), IMAGE_BITMAP, 0, 0,
			LR_CREATEDIBSECTION);

	if (NULL != hBitmap)
	{
		BITMAP bitmap;
		::GetObject(hBitmap, sizeof(bitmap), &bitmap);
		int cx = bitmap.bmWidth;
		int cy = bitmap.bmHeight;

		if (RectWidth(rcVideo) < cx || RectHeight(rcVideo) < cy)
		{
			HANDLE hNew = LoadImage(::GetInstanceHandle(),
				MAKEINTRESOURCE(idbSmallLogo), IMAGE_BITMAP, 0, 0,
				LR_CREATEDIBSECTION);
			if (NULL != hNew)
			{
				DeleteObject(hBitmap);
				hBitmap = hNew;

				::GetObject(hBitmap, sizeof(bitmap), &bitmap);
				cx = bitmap.bmWidth;
				cy = bitmap.bmHeight;
			}
		}

		HBITMAP hBmpTmp = (HBITMAP)::SelectObject(hdcMem, hBitmap);

		// Select and realize the palette
		HPALETTE hPalette = m_hPal;
		if (NULL != hPalette)
		{
			SelectPalette(hdcMem, hPalette, FALSE);
			RealizePalette(hdcMem);
			SelectPalette(hdc, hPalette, FALSE);
			RealizePalette(hdc);
		}

		int x = rcVideo.left + (RectWidth(rcVideo) - cx) / 2;
		int y = rcVideo.top + (RectHeight(rcVideo) - cy) / 2;
		::BitBlt(hdc, x, y, cx, cy, hdcMem, 0, 0, SRCCOPY);

		::SelectObject(hdcMem, hBmpTmp);
		::DeleteObject(hBitmap);
	}
	::DeleteDC(hdcMem);
}


VOID CVideoWindow::OnPaint()
{
	PAINTSTRUCT ps;
	HDC hdc;

	hdc = ::BeginPaint(GetWindow(), &ps);

	if( hdc )
	{
		if( RectWidth(ps.rcPaint) && RectHeight(ps.rcPaint) )
		{
			// This means that we have a non-zero surface area ( there may be something to paint )

			DBGENTRY(CVideoWindow::ProcessPaint);

			// paint the video rect
			FRAMECONTEXT fc;
			if ((S_OK == GetFrame(&fc)))
			{
				if (!IsPaused())
				{
					SIZE vidSize =
					{
						RectWidth(fc.lpClipRect),
						RectHeight(fc.lpClipRect)
					} ;

					if ((vidSize.cx != m_sizeVideo.cx) || (vidSize.cy != m_sizeVideo.cy))
					{
						// save the new image size
						SetVideoSize(&vidSize);
					}
				}

				PaintDib(hdc, &fc);

				ReleaseFrame(&fc);
			}
			else
			{
				PaintLogo(hdc, IDB_VIDEO_LOGO, IDB_VIDEO_LOGO_SMALL);
			}

			// check to see if needs painting outside the video rect
#if FALSE
			// Currently just stretching the video to the window size
			if (ps.rcPaint.left < m_rcVideo.left ||
				ps.rcPaint.top < m_rcVideo.top ||
				ps.rcPaint.right > m_rcVideo.right ||
				ps.rcPaint.bottom > m_rcVideo.bottom)
			{
				HFONT   hfOld;
				int nBkModeOld;
				RECT rc, rcClient;

				::GetClientRect(GetWindow(), &rcClient);

				// erase the background if requested
				if (ps.fErase)
				{
					::ExcludeClipRect(hdc,
						m_rcVideo.left,
						m_rcVideo.top,
						m_rcVideo.right,
						m_rcVideo.bottom);
					::FillRect(hdc, &rcClient, ::GetSysColorBrush(COLOR_BTNFACE));
				}

				nBkModeOld = ::SetBkMode(hdc, TRANSPARENT);
				hfOld = (HFONT)::SelectObject(hdc, g_hfontDlg);

				// paint the status text
				// first erase the old text if not already done
				if (!ps.fErase)
				{
					::FillRect(hdc, &m_rcStatusText, ::GetSysColorBrush(COLOR_BTNFACE));
				}
				TCHAR szState[MAX_PATH];
				if (GetState(szState, CCHMAX(szState)))
				{
					COLORREF crOld;

					crOld = ::SetTextColor(hdc, ::GetSysColor(COLOR_BTNTEXT));

					rc = m_rcStatusText;
					rc.left += STATUS_MARGIN;
					::DrawText(hdc,
							szState,
							-1,
							&rc,
							DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX);
					::SetTextColor(hdc, crOld);
				}

				// paint border around video
				rc = m_rcVideo;
				::InflateRect(&rc,
						::GetSystemMetrics(SM_CXEDGE),
						::GetSystemMetrics(SM_CYEDGE));
				::DrawEdge(hdc, &rc, EDGE_SUNKEN , BF_RECT);

				// restore DC stuff
				::SelectObject(hdc, hfOld);
				::SetBkMode(hdc, nBkModeOld);
			}
#endif // FALSE

			DBGEXIT(CVideoWindow::ProcessPaint);
		}

		::EndPaint(GetWindow(), &ps);
	}

}

VOID CVideoWindow::SetZoom(UINT zoom)
{
	if (m_zoom == zoom)
	{
		return;
	}

	m_zoom = zoom;
	OnDesiredSizeChanged();
}

void CVideoWindow::OnCommand(int idCmd)
{

	switch (idCmd)
	{
	case IDM_VIDEO_GETACAMERA:
		CmdLaunchWebPage(idCmd);
		break;

	case IDM_VIDEO_COPY:
		CopyToClipboard();
		break;

	case IDM_VIDEO_FREEZE:
		Pause(!IsPaused());
		break;

	case IDM_VIDEO_UNDOCK:
		CMainUI::NewVideoWindow(GetConfRoom());
		break;

	case IDM_VIDEO_ZOOM1:
		SetZoom(100);
		break;

	case IDM_VIDEO_ZOOM2:
		SetZoom(200);
		break;

	case IDM_VIDEO_ZOOM3:
		SetZoom(300);
		break;

	case IDM_VIDEO_ZOOM4:
		SetZoom(400);
		break;

	case IDM_VIDEO_PROPERTIES:
		LaunchConfCpl(GetWindow(), OPTIONS_VIDEO_PAGE);
		break;
	}
}

void CVideoWindow::UpdateVideoMenu(HMENU hMenu)
{
	EnableMenuItem(hMenu, IDM_VIDEO_COPY, MF_BYCOMMAND|(CanCopy() ? MF_ENABLED : MF_GRAYED|MF_DISABLED));
	EnableMenuItem(hMenu, IDM_VIDEO_UNDOCK, MF_BYCOMMAND|(IsLocal() ? MF_ENABLED : MF_GRAYED|MF_DISABLED));

    if (!FIsSendVideoAllowed() && !FIsReceiveVideoAllowed())
    {
        EnableMenuItem(hMenu, IDM_VIDEO_FREEZE, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
        EnableMenuItem(hMenu, IDM_VIDEO_PROPERTIES, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
        EnableMenuItem(hMenu, IDM_VIDEO_GETACAMERA, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
    }
    else
    {
    	CheckMenuItem(hMenu, IDM_VIDEO_FREEZE, MF_BYCOMMAND|(IsPaused() ? MF_CHECKED : MF_UNCHECKED));

    	UINT uEnable = ::CanShellExecHttp() ? MF_ENABLED : MF_GRAYED;
	    ::EnableMenuItem(hMenu, IDM_VIDEO_GETACAMERA, uEnable);
    }

	int nZoom = GetZoom();
    int idZoom;
	if (350 < nZoom) idZoom = IDM_VIDEO_ZOOM4;
    else if (250 < nZoom) idZoom = IDM_VIDEO_ZOOM3;
	else if (150 < nZoom) idZoom = IDM_VIDEO_ZOOM2;
    else idZoom = IDM_VIDEO_ZOOM1;

	UINT uFlags = IsZoomable() && !m_bEmbedded
	    ? MF_ENABLED : MF_GRAYED|MF_DISABLED;
    for (int id=IDM_VIDEO_ZOOM1; id<=IDM_VIDEO_ZOOM4; ++id)
	{
	    EnableMenuItem(hMenu, id, MF_BYCOMMAND|uFlags);
    	CheckMenuItem(hMenu, id, MF_BYCOMMAND|MF_UNCHECKED);
	}
    CheckMenuItem(hMenu, idZoom, MF_BYCOMMAND|MF_CHECKED);

	uFlags = CanLaunchConfCpl()
	    ? MF_ENABLED : MF_GRAYED|MF_DISABLED;
	EnableMenuItem(hMenu, IDM_VIDEO_PROPERTIES, MF_BYCOMMAND|uFlags);



}

void CVideoWindow::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
	HMENU hmLoad = LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_VIDEO_POPUP));
	if (NULL != hmLoad)
	{
		HMENU hmPopup = GetSubMenu(hmLoad, 0);
		ASSERT(NULL != hmPopup);

		UpdateVideoMenu(hmPopup);

		int idCmd = TrackPopupMenu(hmPopup, TPM_RETURNCMD|TPM_RIGHTBUTTON,
			xPos, yPos, 0, hwnd, NULL);

		if (0 != idCmd)
		{
			OnCommand(idCmd);
		}

		DestroyMenu(hmLoad);
	}
}

LRESULT CVideoWindow::ProcessMessage(HWND hwnd, UINT message,
								 WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);

	case WM_ERASEBKGND:
		return 0;

	case WM_PAINT:
		OnPaint();
		return 0;

	case WM_NCDESTROY:
		OnNCDestroy();
		return 0;

	case WM_SIZE:
		// Need to redraw the whole window
		InvalidateRect(GetWindow(), NULL, FALSE);
		break;

	default:
		break;
	}
	return CGenWindow::ProcessMessage(hwnd, message, wParam, lParam) ;
}

#if FALSE
int CVideoWindow::GetState(LPTSTR lpszState, int nStateMax)
{
	int uStringID;

	NM_VIDEO_STATE state = NM_VIDEO_IDLE;

	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetState(&state);
	}

	if (IsLocal())
	{
		switch (state)
		{
			case NM_VIDEO_PREVIEWING:
				uStringID = IDS_VIDEO_STATE_PREVIEWING;
				break;
			case NM_VIDEO_TRANSFERRING:
				uStringID = IDS_VIDEO_STATE_SENDING;
				break;
			case NM_VIDEO_REMOTE_PAUSED:
				uStringID = IDS_VIDEO_STATE_REMOTEPAUSED;
				break;
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_BOTH_PAUSED:
				uStringID = IDS_VIDEO_STATE_PAUSED;
				break;
			case NM_VIDEO_IDLE:
			default:
				uStringID = IDS_VIDEO_STATE_NOTSENDING;
				break;
		}
	}
	else
	{
		switch (state)
		{
			case NM_VIDEO_TRANSFERRING:
				uStringID = IDS_VIDEO_STATE_RECEIVING;
				break;
			case NM_VIDEO_REMOTE_PAUSED:
				uStringID = IDS_VIDEO_STATE_REMOTEPAUSED;
				break;
			case NM_VIDEO_LOCAL_PAUSED:
			case NM_VIDEO_BOTH_PAUSED:
				uStringID = IDS_VIDEO_STATE_PAUSED;
				break;
			case NM_VIDEO_IDLE:
			case NM_VIDEO_PREVIEWING:
			default:
				uStringID = IDS_VIDEO_STATE_NOTRECEIVING;
				break;
		}
	}

	return ::LoadString(
				::GetInstanceHandle(),
				uStringID,
				lpszState,
				nStateMax);
}
#endif // FALSE

// Return value will be TRUE if Windows can handle the format
static BOOL IsKnownDIBFormat(BITMAPINFOHEADER *pbmih)
{
	if (sizeof(BITMAPINFOHEADER) != pbmih->biSize)
	{
		return(FALSE);
	}

	if (1 != pbmih->biPlanes)
	{
		return(FALSE);
	}

	int bits = pbmih->biBitCount;
	int comp = pbmih->biCompression;

	switch (bits)
	{
	case 1:
		if (BI_RGB == comp)
		{
			return(TRUE);
		}
		break;

	case 4:
		if (BI_RGB == comp || BI_RLE4 == comp)
		{
			return(TRUE);
		}
		break;

	case 8:
		if (BI_RGB == comp || BI_RLE8 == comp)
		{
			return(TRUE);
		}
		break;

	case 16:
		if (BI_RGB == comp || BI_BITFIELDS == comp)
		{
			return(TRUE);
		}
		break;

	case 24:
	case 32:
		if (BI_RGB == comp)
		{
			return(TRUE);
		}
		break;

	default:
		break;
	}

	return(FALSE);
}

#ifdef TryPaintDIB
BOOL CVideoWindow::CopyToClipboard()
{
	FRAMECONTEXT fc;
	BOOL fSuccess = FALSE; 

	// Get the current frame and open the clipboard
	if (S_OK == GetFrame(&fc))
	{
		HWND hwnd = GetWindow();

		if (OpenClipboard(hwnd))
		{
			// Allocate memory that we will be giving to the clipboard
			BITMAPINFOHEADER *pbmih = &fc.lpbmi->bmiHeader;

			BOOL bCopy = IsKnownDIBFormat(pbmih);

			// BUGBUG georgep; I think this doesn't work for 15 or 16 bit DIBs
			int nColors = pbmih->biClrUsed;
			if (0 == nColors && pbmih->biBitCount <= 8)
			{
				nColors = 1 << pbmih->biBitCount;
			}
			// Special case for 16-bit bitfield bitmaps
			if (16 == pbmih->biBitCount && BI_BITFIELDS == pbmih->biCompression)
			{
				nColors = 3;
			}
			int nHdrSize = pbmih->biSize + nColors * sizeof(RGBQUAD);

			int bitsPer = pbmih->biBitCount;
			if (!bCopy)
			{
				bitsPer *= pbmih->biPlanes;
				if (bitsPer > 24)
				{
					bitsPer = 32;
				}
				// LAZYLAZY georgep: Skipping 16-bit format
				else if (bitsPer > 8)
				{
					bitsPer = 24;
				}
				else if (bitsPer > 4)
				{
					bitsPer = 8;
				}
				else if (bitsPer > 1)
				{
					bitsPer = 4;
				}
				else
				{
					bitsPer = 1;
				}
			}

			int nDataSize = bCopy ? pbmih->biSizeImage : 0;
			if (0 == nDataSize)
			{
				// Make an uncompressed DIB
				int nByteWidth = (pbmih->biWidth*bitsPer+7) / 8;
				nDataSize = ((nByteWidth + 3)&~3) * pbmih->biHeight;
			}

			// Allocate the total memory for the DIB
			HGLOBAL hCopy = GlobalAlloc(GHND, nHdrSize + nDataSize);
			if (NULL != hCopy)
			{
				BITMAPINFO *lpvCopy = reinterpret_cast<BITMAPINFO*>(GlobalLock(hCopy));

				CopyMemory(lpvCopy, pbmih, nHdrSize);

				// Create a temporary DC for drawing into
				HDC hdc = GetDC(hwnd);
				if (NULL != hdc)
				{
					HDC hdcTemp = CreateCompatibleDC(hdc);
					ReleaseDC(hwnd, hdc);
					hdc = hdcTemp;
				}

				if (NULL != hdc)
				{
					if (bCopy)
					{
						if (ShouldMirror())
						{
							// Create a DIB section for drawing into
							LPVOID pData;
							HBITMAP hDIB = CreateDIBSection(hdc, lpvCopy, DIB_RGB_COLORS, &pData, NULL, 0);
							if (NULL != hDIB)
							{
								// Draw into the DIB, and then copy the bits
								HGDIOBJ hOld = SelectObject(hdc, hDIB);

								RECT rc = { 0, 0, pbmih->biWidth, pbmih->biHeight };
								StretchDIBits(hdc, 0, 0, pbmih->biWidth, pbmih->biHeight,
									pbmih->biWidth, 0, -pbmih->biWidth, pbmih->biHeight,
									fc.lpData, lpvCopy, DIB_RGB_COLORS, SRCCOPY);

								CopyMemory(&lpvCopy->bmiColors[nColors], pData, nDataSize);

								// Start cleaning up
								SelectObject(hdc, hOld);
								DeleteObject(hDIB);
							}
						}
						else
						{
							CopyMemory(&lpvCopy->bmiColors[nColors], fc.lpData, nDataSize);
						}

						fSuccess = TRUE;
					}
					else
					{
						lpvCopy->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
						lpvCopy->bmiHeader.biPlanes = 1;
						lpvCopy->bmiHeader.biBitCount = bitsPer;
						lpvCopy->bmiHeader.biCompression = BI_RGB;
						lpvCopy->bmiHeader.biSizeImage = nDataSize;

						// Create a DIB section for drawing into
						LPVOID pData;
						HBITMAP hDIB = CreateDIBSection(hdc, lpvCopy, DIB_RGB_COLORS, &pData, NULL, 0);
						if (NULL != hDIB)
						{
							// Draw into the DIB, and then copy the bits
							HGDIOBJ hOld = SelectObject(hdc, hDIB);

							RECT rc = { 0, 0, pbmih->biWidth, pbmih->biHeight };
							PaintDib(hdc, &fc, &rc);

							CopyMemory(&lpvCopy->bmiColors[nColors], pData, nDataSize);

							// Start cleaning up
							SelectObject(hdc, hOld);
							DeleteObject(hDIB);

							fSuccess = TRUE;
						}
					}

					DeleteDC(hdc);
				}

				GlobalUnlock(hCopy);

				if (fSuccess)
				{
					// Set the DIB into the clipboard
					EmptyClipboard();
					fSuccess = (NULL != SetClipboardData(CF_DIB, (HANDLE)hCopy));
				}

				if (!fSuccess)
				{
					GlobalFree(hCopy);
				}
			}

			CloseClipboard();
		}

		ReleaseFrame(&fc);
	}
	
	return fSuccess;
}
#else // TryPaintDIB
BOOL CVideoWindow::CopyToClipboard()
{
	FRAMECONTEXT fc;
	BOOL fSuccess = FALSE; 
	
	if (S_OK == GetFrame(&fc))
	{
		if (OpenClipboard(GetWindow()))
		{
			EmptyClipboard();
			{
				HGLOBAL hCopy;
				BITMAPINFOHEADER *pbmih;
				
				pbmih = &fc.lpbmi->bmiHeader;
				hCopy = GlobalAlloc(GHND, DibSize(pbmih));
				if (NULL != hCopy)
				{
					LPVOID lpvCopy = GlobalLock(hCopy);
					int nHdrSize = DibHdrSize(pbmih);
					CopyMemory(lpvCopy, pbmih, nHdrSize);
					CopyMemory((LPBYTE)lpvCopy + nHdrSize, fc.lpData, DibDataSize(pbmih));
					GlobalUnlock(hCopy);
					fSuccess = (NULL != SetClipboardData(CF_DIB, (HANDLE)hCopy));
					if (!fSuccess)
					{
						GlobalFree(hCopy);
					}
				}
			}
			CloseClipboard();
		}
		ReleaseFrame(&fc);
	}
	
	return fSuccess;
}
#endif // TryPaintDIB

HRESULT CVideoWindow::GetFrame(FRAMECONTEXT *pFrameContext)
{
	HRESULT hr = E_FAIL;

	if (NULL != m_pActiveChannel)
	{
		hr = m_pActiveChannel->GetProperty(NM_VIDPROP_FRAME, (DWORD_PTR *)pFrameContext);
	}
	return hr;
}

HRESULT CVideoWindow::ReleaseFrame(FRAMECONTEXT *pFrameContext)
{
	HRESULT hr = E_FAIL;

	if (NULL != m_pActiveChannel)
	{
		hr = m_pActiveChannel->SetProperty(NM_VIDPROP_FRAME, (DWORD_PTR)pFrameContext);
	}
	return hr;
}

void CVideoWindow::SaveSettings()
{
	RegEntry re( IsLocal() ? VIDEO_LOCAL_KEY : VIDEO_REMOTE_KEY,
			HKEY_CURRENT_USER );

	re.SetValue(REGVAL_VIDEO_FRAME_SIZE, m_dwFrameSize);

	if (!IsLocal())
	{
		re.SetValue(REGVAL_VIDEO_QUALITY, m_dwImageQuality);
	}
	else
	{
		re.SetValue(REGVAL_VIDEO_MIRROR, GetMirror());
	}
}

VOID CVideoWindow::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_PALETTECHANGED:
		OnPaletteChanged();
		break;
	}
}

VOID CVideoWindow::OnPaletteChanged(void)
{
	::RedrawWindow(GetWindow(), NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
}

BOOL CVideoWindow::HasDialog(DWORD dwDialog)
{
	DWORD_PTR dwDialogs = 0;
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->GetProperty(NM_VIDPROP_CAMERA_DIALOG, &dwDialogs);
	}
	return (BOOL)(dwDialogs & dwDialog);
}

VOID CVideoWindow::ShowDialog(DWORD dwDialog)
{
	if (NULL != m_pActiveChannel)
	{
		m_pActiveChannel->SetProperty(NM_VIDPROP_CAMERA_DIALOG, dwDialog);
	}
}


BOOL CVideoWindow::InitMirroring(RECT &rcVideo)
{
	HDC hdcWindow;

	if ((m_hBitmapMirror != NULL) && 
		(RectWidth(rcVideo) == m_sizeBitmapMirror.cx) &&
		(RectHeight(rcVideo) == m_sizeBitmapMirror.cy))
	{
		return TRUE;
	}

	hdcWindow = ::GetDC(NULL);

	UnInitMirroring();

	m_hBitmapMirror = ::CreateCompatibleBitmap(hdcWindow, RectWidth(rcVideo), RectHeight(rcVideo));

	if (m_hBitmapMirror == NULL)
	{
		ReleaseDC(NULL, hdcWindow);
		return FALSE;
	}

	m_hDCMirror = ::CreateCompatibleDC(hdcWindow);

	if (m_hDCMirror == NULL)
	{
		UnInitMirroring();
		ReleaseDC(NULL, hdcWindow);
		return FALSE;
	}
		
	// preserve the handle of the object being replaced
	m_hGDIObj = ::SelectObject(m_hDCMirror, m_hBitmapMirror);
	::SetMapMode(m_hDCMirror, GetMapMode(hdcWindow));

	m_sizeBitmapMirror.cx = RectWidth(rcVideo);
	m_sizeBitmapMirror.cy = RectHeight(rcVideo);
	ReleaseDC(NULL, hdcWindow);
	return TRUE;
}

VOID CVideoWindow::UnInitMirroring()
{
	if (m_hBitmapMirror)
	{
		if (m_hDCMirror)
		{
			::SelectObject(m_hDCMirror, m_hGDIObj);
		}
		::DeleteObject(m_hBitmapMirror);
		m_hBitmapMirror = NULL;
	}

	if (m_hDCMirror)
	{
		::DeleteObject(m_hDCMirror);
		m_hDCMirror = NULL;
	}
}

VOID CVideoWindow::InvalidateAll()
{
	for(int i = g_pVideos->GetSize()-1; i >= 0 ; --i)
	{
		CVideoWindow *pVideo = (*g_pVideos)[i];
		HWND hwnd = pVideo->GetWindow();
		if (NULL != hwnd)
		{
			InvalidateRect(hwnd, NULL, FALSE);
		}
	}
}

VOID CVideoWindow::SetMirror(BOOL bMirror)
{
	bMirror = bMirror != FALSE;

	if (g_fMirror != bMirror)
	{
		g_fMirror = bMirror;
		InvalidateAll();
	}
}

BOOL CVideoWindow::CanCopy()
{
	BOOL bCopy = (IsXferEnabled() && IsLocal()) || IsConnected();
	if (bCopy)
	{
		bCopy = FALSE;

		FRAMECONTEXT fc;
		if (S_OK == GetFrame(&fc))
		{
			BITMAPINFOHEADER *pbmih = &fc.lpbmi->bmiHeader;

			bCopy = IsKnownDIBFormat(pbmih);

			ReleaseFrame(&fc);
		}
	}

	return(bCopy);
}

BOOL CVideoWindow::FDidNotDisplayIntelLogo()
{
	return FALSE;
}

VOID CVideoWindow::DisplayIntelLogo( BOOL bDisplay )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\vidwiz.h ===
#ifndef _VIDWIZ_H
#define _VIDWIZ_H

#include "dcap.h"

// header file for Setup wizard's video capture device selection page



void UpdateVidConfigRegistry();
BOOL NeedVideoPropPage(BOOL fForce);
INT_PTR APIENTRY VidWizDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

BOOL InitVidWiz();
BOOL UnInitVidWiz();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wab.h ===
// File: wab.h

#ifndef _WAB_H_
#define _WAB_H_

#include "wabutil.h"
#include <lst.h>
#include "calv.h"

class CWAB : public CWABUTIL, public CALV
{
protected:
	static CWAB * m_spThis;
public:
	static CWAB * GetInstance() {return m_spThis;}

public:
	CWAB();
	~CWAB();

	HRESULT ShowNmEntires(HWND hwnd);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID CmdProperties(void);
	RAI * GetAddrInfo(void);

private:
	HRESULT _GetLPSTRProps( lst<LPSTR>& rLst, ULONG* paPropTags, LPMAPIPROP pMapiProp, int nProps );
};

// Utility routines
HRESULT CreateWabEntry(LPTSTR pszDisplay, LPTSTR pszFirst, LPTSTR pszLast,
	LPTSTR pcszEmail, LPTSTR pszLocation, LPTSTR pszPhoneNumber, LPTSTR pcszComments,
	LPTSTR pcszServer);

#endif /* _WAB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\vidview.h ===
/****************************************************************************
*
*	 FILE:	   VidView.h
*
*	 CREATED:  Chris Pirich (ChrisPi) 12-16-96
*
****************************************************************************/

#ifndef _VIDVIEW_H_
#define _VIDVIEW_H_

#include <ih323cc.h>

#include "GenWindow.h"
#include "SDKInternal.h"

typedef HANDLE HDRAWDIB; /* hdd */

class CVideoWindow;

interface IVideoChange : public IUnknown
{
	virtual void StateChange(CVideoWindow *pVideo, NM_VIDEO_STATE uState) = 0;
} ;

class CVideoWindow : public CGenWindow, public INmChannelVideoNotify
{
public:
	static VOID    SetMirror(BOOL bMirror);
	static BOOL    GetMirror() {return g_fMirror != FALSE;}

	enum VideoType
	{
		REMOTE,
		LOCAL
	} ;

	CVideoWindow(VideoType eType, BOOL bEmbedded);
	~CVideoWindow();

	BOOL	Create(HWND hwndOwner, HPALETTE hPal, IVideoChange *pNotify=NULL);

	BOOL	IsXferAllowed();
	BOOL	IsAutoXferEnabled();
	BOOL	IsXferEnabled();
	BOOL    IsPaused();
	BOOL    IsConnected();
	HRESULT GetVideoState(NM_VIDEO_STATE* puState);

	BOOL	CanCopy();

	BOOL	HasDialog(DWORD dwDialog);

	DWORD	GetFrameSize() { return(m_dwFrameSize); }
	DWORD	GetFrameSizes();
	DWORD	GetImageQuality() { return(m_dwImageQuality); }
	DWORD	GetNumCapDev();
	DWORD	GetMaxCapDevNameLen();
	DWORD	GetCurrCapDevID();

	VOID	SetCurrCapDevID(DWORD dwID);
	HRESULT	SetImageQuality(DWORD dwQuality);
	HRESULT SetCameraDialog(ULONG ul);
	HRESULT GetCameraDialog(ULONG* pul);
	VOID	SetFrameSize(DWORD dwSize);
	VOID    SetZoom(UINT nZoom);

	VOID	EnableAutoXfer(BOOL fEnable);

	VOID	ShowDialog(DWORD dwDialog);
	VOID	SaveSettings();
	VOID    Pause(BOOL fPause);
	VOID    RefreshWindow() { OnFrameAvailable(); }
	VOID	ResizeWindowsToFrameSize();

	VOID	EnumCapDev(DWORD *pdwCapDevIDs, LPTSTR pszCapDevNames, DWORD dwNumCapDev);

	VOID    OnPaletteChanged(void);
	VOID	OnMinimize(BOOL fMinimize) { /* Should this pause the video? */ }
	HRESULT OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);
	VOID	ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

	void	UpdateVideoMenu(HMENU hMenu);
	void	OnCommand(int idCmd);

	void SetZoomable(BOOL bZoomable) { m_fZoomable = (bZoomable!=FALSE); }
	BOOL IsZoomable() { return(m_fZoomable != FALSE); }

	// IUnknown
	STDMETHODIMP_(ULONG) AddRef(void) { return(CGenWindow::AddRef()); }
	STDMETHODIMP_(ULONG) Release(void) { return(CGenWindow::Release()); }
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// INmChannelVideoNotify
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	STDMETHODIMP StateChanged(NM_VIDEO_STATE uState);
	STDMETHODIMP PropertyChanged(DWORD dwReserved);

	// IGenWindow
	virtual VOID GetDesiredSize(SIZE *ppt);

	static BOOL FDidNotDisplayIntelLogo();
	static VOID DisplayIntelLogo( BOOL bDisplay );

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	// Array keeping track of all video windows, so they can be invalidated
	// when the state changes (like mirroring)
	static CSimpleArray<CVideoWindow *> *g_pVideos;
	// Specifies whether we are mirroring the local video.
	static BOOL g_fMirror;
	// Specifies whether we have done one-time local video init stuff
	static BOOL g_bLocalOneTimeInited;

	static VOID InvalidateAll();

	INmChannelVideo* m_pActiveChannel;
	DWORD			m_dwCookie;
	DWORD			m_dwImageQuality;
	UINT			m_nXferOnConnect;

	DWORD			m_dwFrameSize;
	SIZE			m_sizeVideo;

	HDRAWDIB		m_hdd;
	HPALETTE		m_hPal;

	UINT			m_zoom;

	IVideoChange *m_pNotify;

	BOOL			m_fLocal : 1;
	// CMainUI uses this to disallow zoom on the PiP window
	BOOL			m_fZoomable : 1;
	// Use this to make sure the embedded window does not display CIF
	BOOL			m_bEmbedded : 1;

	VOID		SetVideoSize(LPSIZE lpsize);

	UINT		GetZoom() { return(m_zoom); }
	BOOL		ShouldMirror() { return(IsLocal() && GetMirror()); }

	VOID		OnFrameAvailable(void);
	VOID		PaintDib(HDC hdc, FRAMECONTEXT *pFrame);
	VOID		PaintLogo(HDC hdc, UINT idbLargeLogo, UINT idbSmallLogo);
	VOID		OnPaint();
	VOID		OnNCDestroy();
	void		OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);

	BOOL		CopyToClipboard();

	HRESULT 	GetFrame(FRAMECONTEXT *pFrameContext);
	HRESULT 	ReleaseFrame(FRAMECONTEXT *pFrameContext);

	BOOL        InitMirroring(RECT &rcVideo);
	VOID        UnInitMirroring();

	HBITMAP     m_hBitmapMirror;
	SIZE        m_sizeBitmapMirror;
	HDC         m_hDCMirror;
	HGDIOBJ     m_hGDIObj;

	

	BOOL		IsLocal() { return m_fLocal; }
};

#endif // _VIDVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wab.cpp ===
// File: wab.cpp

#include "precomp.h"
#include "resource.h"

#include "dirutil.h"

#include "wab.h"
#include "wabtags.h"
#include "wabiab.h"
#include "lst.h"
#include "fnobjs.h"

static const int _rgIdMenu[] = {
	IDM_DLGCALL_SPEEDDIAL,
	0
};


// As of VC 6.0 on the Alpha, FreePsz couldn't be passed to a 
// template taking an F&. There is an internal compiler error
// One day, this will be fixed. For now, this call should be
// identical
class FreePszFunctor
{public:
	void operator()( LPTSTR sz ) { FreePsz( sz ); }
};
		



// There is only one instance of this object  (for CreateWabEntry)
CWAB * CWAB::m_spThis = NULL;

/*  C  W  A  B  */
/*-------------------------------------------------------------------------
    %%Function: CWAB
    
-------------------------------------------------------------------------*/
CWAB::CWAB() :
	CALV(IDS_DLGCALL_WAB, II_WAB, _rgIdMenu)
{
	DbgMsg(iZONE_OBJECTS, "CWAB - Constructed(%08X)", this);

	ASSERT(NULL == m_spThis);
	m_spThis = this;

	SetAvailable(NULL != m_pAdrBook);
}

CWAB::~CWAB()
{
	m_spThis = NULL;

	DbgMsg(iZONE_OBJECTS, "CWAB - Destroyed(%08X)", this);
}


///////////////////////////////////////////////////////////////////////////
// CALV methods

	

/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems
    
-------------------------------------------------------------------------*/
VOID CWAB::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);
	
	ShowNmEntires(hwnd);
}

HRESULT CWAB::ShowNmEntires(HWND hwnd)
{
	HRESULT hr;
	if (!FAvailable())
		return S_FALSE; // nothing to show

	hr = GetContainer();
	if (FAILED(hr))
		return hr;

	hr = EnsurePropTags();
	if (FAILED(hr))
		return hr;

	LPMAPITABLE pAB = NULL;
	hr = m_pContainer->GetContentsTable(0, &pAB);
	if (FAILED(hr) || (NULL == pAB))
		return hr;

	// reset the system to use the correct properties
	ASSERT(NULL != m_pPropTags);
	hr = pAB->SetColumns(GetTags(), 0);
	if (SUCCEEDED(hr))
	{
		// Read all the rows of the table one by one
		hr = pAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
	}

	while (S_OK == hr)
	{
		LPSRowSet pRowAB = NULL;
		hr = pAB->QueryRows(1, 0, &pRowAB);
		if (FAILED(hr) || (NULL == pRowAB))
			break;

		int cNumRows = pRowAB->cRows;
		hr = (0 != cNumRows) ? S_OK : S_FALSE;
		if (S_OK == hr)
		{
			LPSPropValue lpProp = &(pRowAB->aRow[0].lpProps[ieidPR_NM_ADDRESS]);
			if (Get_PR_NM_ADDRESS() == lpProp->ulPropTag)
			{
				LPSTR pszName = pRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
				SLPSTRArray * pMVszA = &(lpProp->Value.MVszA);
				if (0 != pMVszA->cValues)
				{
					// Find the default entry
					LPSPropValue lpPropDefault = &(pRowAB->aRow[0].lpProps[ieidPR_NM_DEFAULT]);
					ULONG iDefault = (Get_PR_NM_DEFAULT() == lpPropDefault->ulPropTag)
						? lpPropDefault->Value.ul : 0;
					ASSERT(iDefault <= pMVszA->cValues);
					LPCTSTR pszAddr = pMVszA->lppszA[iDefault];
					pszAddr = PszSkipCallTo(pszAddr);

					// This trick will only work if the sizeof(LPARAM) == sizeof(LPENTRYID)
					LPARAM lParam;
					if (sizeof(LPARAM) == pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb)
					{
						lParam = * (LPARAM *) pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
					}
					else
					{
						lParam = 0;
					}

					DlgCallAddItem(hwnd, pszName, pszAddr, II_WAB_CARD, lParam);
				}
			}
		}
		FreeProws(pRowAB);
    }

	pAB->Release();

	return hr;
}


/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties
    
-------------------------------------------------------------------------*/
VOID CWAB::CmdProperties(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	LV_ITEM lvi;
	ClearStruct(&lvi);
	lvi.iItem = iItem;
	lvi.mask = LVIF_PARAM;
	if (!ListView_GetItem(GetHwnd(), &lvi))
		return;

	HWND hwnd = GetParent(GetHwnd());
	m_pAdrBook->Details((LPULONG) &hwnd, NULL, NULL,
		    sizeof(LPARAM), (LPENTRYID) &lvi.lParam,
		    NULL, NULL, NULL, 0);

		// this is because we may have changed something in the Details dlg.
	CmdRefresh();

	ListView_SetItemState(GetHwnd(), iItem,
			LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

}

/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo
    
-------------------------------------------------------------------------*/
RAI * CWAB::GetAddrInfo(void)
{
	RAI* pRai = NULL;
	lst<LPTSTR> PhoneNums;
	lst<LPTSTR> EmailNames;
	lst<LPTSTR> ILSServers;

	int iItem = GetSelection();
	if (-1 != iItem)
	{

		LV_ITEM lvi;
		ClearStruct(&lvi);
		lvi.iItem = iItem;
		lvi.mask = LVIF_PARAM;
		if (ListView_GetItem(GetHwnd(), &lvi))
		{

			LPMAPIPROP pMapiProp = NULL;
			ULONG ulObjType = 0;
			HRESULT hr = m_pContainer->OpenEntry( sizeof(LPARAM), 
												  reinterpret_cast<LPENTRYID>(&lvi.lParam), 
												  NULL, 
												  0,
												  &ulObjType, 
												  reinterpret_cast<LPUNKNOWN*>(&pMapiProp)
												);

			if (SUCCEEDED(hr))
			{
				// Email Name
				if (FEnabledNmAddr(NM_ADDR_ALIAS_ID))
				{
					ULONG PropTags[] = { PR_EMAIL_ADDRESS };

					_GetLPSTRProps( EmailNames, PropTags, pMapiProp, ARRAY_ELEMENTS( PropTags ) );
				}


				// Phone number
				if (FEnabledNmAddr(NM_ADDR_ALIAS_E164) || FEnabledNmAddr(NM_ADDR_H323_GATEWAY))
				{

					ULONG PhoneNumPropTags[] = {
						PR_BUSINESS_TELEPHONE_NUMBER,
						PR_HOME_TELEPHONE_NUMBER,
						PR_PRIMARY_TELEPHONE_NUMBER,
						PR_BUSINESS2_TELEPHONE_NUMBER,
						PR_CELLULAR_TELEPHONE_NUMBER,
						PR_RADIO_TELEPHONE_NUMBER,
						PR_CAR_TELEPHONE_NUMBER,
						PR_OTHER_TELEPHONE_NUMBER,
						PR_PAGER_TELEPHONE_NUMBER
					};

					_GetLPSTRProps( PhoneNums, PhoneNumPropTags, pMapiProp, ARRAY_ELEMENTS( PhoneNumPropTags ) );
				}

				if (FEnabledNmAddr(NM_ADDR_ULS))
				{
					enum { iPrNmAddress = 0, iDefaultServer = 1 };
					ULONG PropTags[2];
					PropTags[iPrNmAddress] = Get_PR_NM_ADDRESS();
					PropTags[iDefaultServer] = Get_PR_NM_DEFAULT();

					if( m_pWabObject )
					{
						BYTE* pb = new BYTE[ sizeof( SPropTagArray ) + sizeof( ULONG ) * ARRAY_ELEMENTS( PropTags ) ];
						if( pb )
						{
								// Fill in the prop tags that we are interested in...
							SPropTagArray* pProps = reinterpret_cast<SPropTagArray*>(pb);
							pProps->cValues = ARRAY_ELEMENTS(PropTags);
							for( UINT iCur = 0; iCur < pProps->cValues; iCur++ )
							{
								pProps->aulPropTag[iCur] = PropTags[iCur];
							}

							LPSPropValue pData = NULL;
							ULONG cValues = ARRAY_ELEMENTS(PropTags);

							if( SUCCEEDED( hr = pMapiProp->GetProps( pProps, 0, &cValues, &pData ) ) && pData )
							{
									// Get teh ILS Servers
								if( LOWORD( pData[iPrNmAddress].ulPropTag ) != PT_ERROR )
								{
									for( ULONG iCurVal = 0; iCurVal < pData[iPrNmAddress].Value.MVszA.cValues; ++iCurVal )
									{	
										LPSTR pStr = pData[iPrNmAddress].Value.MVszA.lppszA[iCurVal];

											// Skip the callto://
										pStr = const_cast<LPSTR>(PszSkipCallTo(pStr));

											// Skip duplicate server names...
										if( !FEmptySz(pStr) && ( ILSServers.end() == find( ILSServers, IsEqLPTSTR( pStr ) ) ) )
										{
											ILSServers.push_back( PszAlloc( pStr ) );
										}
									}
								}

									// Get the default Server
								if( LOWORD( pData[iDefaultServer].ulPropTag ) != PT_ERROR )
								{
										// If the default server is not already in the front, put it there...
									if( pData[iDefaultServer].Value.l != 0 )
									{
											// Find the default server in the list
										lst<LPTSTR>::iterator I = ILSServers.begin();
										for( long lCur = 0; ( I != ILSServers.end() ) && ( lCur != pData[iDefaultServer].Value.l ); ++I, ++lCur )
										{ ; }

										ASSERT( I != ILSServers.end() );

										LPTSTR pszDefault = *I;
										ILSServers.erase(I);
										ILSServers.push_front( pszDefault );
									}
								}
									
								m_pWabObject->FreeBuffer(pData);
							}

							delete [] pb;
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}
					else
					{
						hr = E_FAIL;
					}


				}

				if( PhoneNums.size() || EmailNames.size() || ILSServers.size() )
				{
						// Initialize the RAI struct
					int nItems = PhoneNums.size() + EmailNames.size() + ILSServers.size();
					DWORD cbLen = sizeof(RAI) + sizeof(DWSTR)* nItems;
					pRai = reinterpret_cast<RAI*>(new BYTE[ cbLen ]);
					ZeroMemory(pRai, cbLen);
					pRai->cItems = nItems;
						
						// This is the display name...
					GetSzName(pRai->szName, CCHMAX(pRai->szName), iItem);

					int iCur = 0;

						// First copy the e-mail names
					for( lst<LPTSTR>::iterator I = EmailNames.begin(); I != EmailNames.end(); ++I, ++iCur )
					{
						pRai->rgDwStr[iCur].dw = NM_ADDR_ALIAS_ID;
						pRai->rgDwStr[iCur].psz = PszAlloc(*I);
					}
					for_each( EmailNames, FreePszFunctor() );
					
						// Copy the phone numbirs
					for( I = PhoneNums.begin(); I != PhoneNums.end(); ++I, ++iCur )
					{
						pRai->rgDwStr[iCur].dw = g_fGkEnabled ? NM_ADDR_ALIAS_E164 : NM_ADDR_H323_GATEWAY;
						pRai->rgDwStr[iCur].psz = PszAlloc(*I);
					}
					for_each( PhoneNums, FreePszFunctor() );

						// Copy the ils servers
					for( I = ILSServers.begin(); I != ILSServers.end(); ++I, ++iCur )
					{
						pRai->rgDwStr[iCur].dw = NM_ADDR_ULS;
						pRai->rgDwStr[iCur].psz = PszAlloc(*I);
					}
					for_each( ILSServers, FreePszFunctor() );

				}

				pMapiProp->Release();
			}
		}
	}

	return pRai;
}

HRESULT CWAB::_GetLPSTRProps( lst<LPSTR>& rLst, ULONG* paPropTags, LPMAPIPROP pMapiProp, int nProps )
{
	HRESULT hr = S_OK;

	if( m_pWabObject )
	{
		BYTE* pb = new BYTE[ sizeof( SPropTagArray ) + sizeof( ULONG ) * nProps ];
		if( pb )
		{
				// Fill in the prop tags that we are interested in...
			SPropTagArray* pProps = reinterpret_cast<SPropTagArray*>(pb);
			pProps->cValues = nProps;
			for( UINT iCur = 0; iCur < pProps->cValues; iCur++ )
			{
				pProps->aulPropTag[iCur] = paPropTags[iCur];
			}

			LPSPropValue pData = NULL;
			ULONG cValues = nProps;

			// Get the props
			if( SUCCEEDED( hr = pMapiProp->GetProps( pProps, 0, &cValues, &pData ) ) && pData )
			{
					// Extract thet props
				for( ULONG iCurVal = 0; iCurVal < cValues; ++iCurVal )
				{	
					if( LOWORD( pData[iCurVal].ulPropTag ) != PT_ERROR )
					{
						if( !FEmptySz(pData[iCurVal].Value.lpszA) && ( rLst.end() == find( rLst, IsEqLPTSTR( 
#ifdef UNICODE
																	pData[iCurVal].Value.lpszW 
#else
																	pData[iCurVal].Value.lpszA
#endif
) ) ) )
						{
							rLst.push_back( PszAlloc( pData[iCurVal].Value.lpszA ) );
						}
					}
				}
						
				m_pWabObject->FreeBuffer(pData);
			}

			delete [] pb;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;

}


/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CreateWabEntry(LPTSTR pszDisplay, LPTSTR pszFirst, LPTSTR pszLast,
	LPTSTR pszEmail, LPTSTR pszLocation, LPTSTR pszPhoneNumber, LPTSTR pszComments,
	LPTSTR pszServer)
{
	CWAB * pWab = CWAB::GetInstance();
	if (NULL == pWab)
		return E_FAIL;

	HWND hwnd = GetParent(pWab->GetHwnd());
	return pWab->CreateWabEntry(hwnd, pszDisplay, pszFirst, pszLast, pszEmail,
		pszLocation, pszPhoneNumber, pszComments, pszServer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\vidwiz.cpp ===
// File: vidwiz.cpp

#include "precomp.h"

#include "dcap.h"
#include "vidinout.h"
#include "vidwiz.h"
#include "confcpl.h"


static HINSTANCE g_hDcapLib;

typedef int (WINAPI *GNCD)();
typedef BOOL (WINAPI *FFCD)(FINDCAPTUREDEVICE*, char *);
typedef BOOL (WINAPI *FFCDBI)(FINDCAPTUREDEVICE*, int);

// implementations in DCAP32.DLL
static FFCD DLL_FindFirstCaptureDevice = NULL;
static FFCDBI DLL_FindFirstCaptureDeviceByIndex = NULL;
static GNCD DLL_GetNumCaptureDevices = NULL;

	// Defined in wizard.cpp
extern UINT_PTR GetPageBeforeVideoWiz();
extern UINT_PTR GetPageAfterVideo();

// index number of the user's selection on the combo box
static int g_nCurrentSelection = 0;

// set to true only if the user hit's back or next
static BOOL g_bCurrentValid = FALSE;

// was the user prompted to select a video device
static BOOL g_bPrompted = FALSE;


static char *BuildCaptureDeviceInfoString(FINDCAPTUREDEVICE *pCaptureDeviceInfo, char *szOut);


BOOL InitVidWiz()
{

	// initialize locals
	g_hDcapLib = NULL;
	DLL_FindFirstCaptureDevice = NULL;
	DLL_FindFirstCaptureDeviceByIndex = NULL;
	DLL_GetNumCaptureDevices = NULL;
	g_nCurrentSelection = 0;
   	g_bCurrentValid = FALSE;
	g_bPrompted = FALSE;

	g_hDcapLib = NmLoadLibrary("dcap32.dll");
	if (g_hDcapLib == NULL)
		return FALSE;
	
	DLL_FindFirstCaptureDevice = (FFCD)GetProcAddress(g_hDcapLib, "FindFirstCaptureDevice");
	DLL_FindFirstCaptureDeviceByIndex = (FFCDBI)GetProcAddress(g_hDcapLib, "FindFirstCaptureDeviceByIndex");
	DLL_GetNumCaptureDevices = (GNCD)GetProcAddress(g_hDcapLib, "GetNumCaptureDevices");

	return TRUE;
}


// returns TRUE if the capture device id in the registry corresponds with
// the driver description string.
static BOOL IsVideoRegistryValid()
{
	RegEntry re(VIDEO_KEY);
	char szDriverDesc[200];
	char *szDriverDescReg;
	int numVideoDevices, nID;
	FINDCAPTUREDEVICE CaptureDeviceInfo;
	BOOL fRet;

	// just in case InitVidWiz wasn't called
	if (NULL == g_hDcapLib)
		return FALSE;

	numVideoDevices = DLL_GetNumCaptureDevices();	

	nID = re.GetNumber(REGVAL_CAPTUREDEVICEID, -1);
	szDriverDescReg = re.GetString(REGVAL_CAPTUREDEVICENAME);

	// no video devices and no registry entry is valid
	if ((numVideoDevices == 0) && (nID == -1))
	{
		return TRUE;
	}

	if ((numVideoDevices == 0) && (nID != -1))
	{
		return FALSE;
	}

	// TRUE == (numVideoDevice >= 1)

	// installed video devices but no registry entry is invalid
	if (nID == -1)
	{
		return FALSE;
	}

	CaptureDeviceInfo.dwSize = sizeof(FINDCAPTUREDEVICE);
	fRet = DLL_FindFirstCaptureDeviceByIndex(&CaptureDeviceInfo, nID);

	if (fRet == FALSE)
	{
		return FALSE;
	}

	BuildCaptureDeviceInfoString(&CaptureDeviceInfo, szDriverDesc);

	if (0 == lstrcmp(szDriverDescReg, szDriverDesc))
	{
		return TRUE;
	}
	return FALSE;
}


BOOL UnInitVidWiz()
{
	if (g_hDcapLib)
		FreeLibrary(g_hDcapLib);

	g_hDcapLib = NULL;

	return TRUE;
}


static char *BuildCaptureDeviceInfoString(FINDCAPTUREDEVICE *pCaptureDeviceInfo, char *szOut)
{
	if (pCaptureDeviceInfo->szDeviceDescription[0] != '\0')
	{
		lstrcpy(szOut, pCaptureDeviceInfo->szDeviceDescription);
	}
	else
	{
		lstrcpy(szOut, pCaptureDeviceInfo->szDeviceName);
	}

	if (pCaptureDeviceInfo->szDeviceVersion[0] != '\0')
	{
		lstrcat(szOut, _T(", "));
		lstrcat(szOut, pCaptureDeviceInfo->szDeviceVersion);
	}
	return szOut;
}


void UpdateVidConfigRegistry()
{
	FINDCAPTUREDEVICE CaptureDeviceInfo, *CaptureDevTable;
	RegEntry re(VIDEO_KEY);
	BOOL bRet;
	char strNameDesc[MAX_CAPDEV_NAME+MAX_CAPDEV_VERSION];
	int numVideoDevices, index, enum_index;

	// just in case InitVidWiz wasn't called
	if (NULL == g_hDcapLib)
		return;

	numVideoDevices = DLL_GetNumCaptureDevices();	

	// no devices - delete the registry entries
	if (numVideoDevices == 0)
	{
		re.DeleteValue(REGVAL_CAPTUREDEVICEID);
		re.DeleteValue(REGVAL_CAPTUREDEVICENAME);
		return;
	}


	// build a table of all the devices

	CaptureDevTable = (FINDCAPTUREDEVICE *)LocalAlloc(LPTR, numVideoDevices*sizeof(FINDCAPTUREDEVICE));

	if (NULL == CaptureDevTable)
	{
		ERROR_OUT(("UpdateVidConfigRegistry: Out of memory"));
		return;
	}

	index = 0;
	for (enum_index=0; enum_index < MAXVIDEODRIVERS; enum_index++)
	{
		CaptureDevTable[index].dwSize = sizeof(FINDCAPTUREDEVICE);
		bRet = DLL_FindFirstCaptureDeviceByIndex(&CaptureDevTable[index], enum_index);
		if (bRet == TRUE)
			index++;
		if (index == numVideoDevices)
			break;
	}

	if (index != numVideoDevices)
	{
		ERROR_OUT(("UpdateVidConfigReg: Device Enumeration Failure"));
		LocalFree(CaptureDevTable);
		return;
	}

	// if only one capture device:
	// don't bother to see if the previous entry was valid
	// just update the registry with the current default
	if (numVideoDevices == 1)
	{
		BuildCaptureDeviceInfoString(&CaptureDevTable[0], strNameDesc);
		re.SetValue(REGVAL_CAPTUREDEVICEID, CaptureDevTable[0].nDeviceIndex);
		re.SetValue(REGVAL_CAPTUREDEVICENAME, strNameDesc);
		LocalFree(CaptureDevTable);
		return;
	}

	// TRUE == (numVideoDevices >= 2)

	// user wasn't prompted - he must of had a valid registry to start with
	if (g_bPrompted == FALSE)
	{
		LocalFree(CaptureDevTable);
		return;
	}

	// the user pressed CANCEL during setup
	if (g_bCurrentValid == FALSE)
	{
		if (IsVideoRegistryValid() == TRUE)
		{
			LocalFree(CaptureDevTable);
			return;
		}
		else
			g_nCurrentSelection = 0;
	}
		

	CaptureDeviceInfo = CaptureDevTable[g_nCurrentSelection];

	BuildCaptureDeviceInfoString(&CaptureDeviceInfo, strNameDesc);
	re.SetValue(REGVAL_CAPTUREDEVICEID, CaptureDeviceInfo.nDeviceIndex);
	re.SetValue(REGVAL_CAPTUREDEVICENAME, strNameDesc);

	LocalFree(CaptureDevTable);

	return;
}


// if <= 1 video capture device, return false
// if 2 or more video devices and the Wizard is in force mode, return true
// if 2 or more video devices and a MATCHING registry entry, return false
// otherwise something is fishy - return true
BOOL NeedVideoPropPage(BOOL fForce)
{
	// just in case InitVidWiz wasn't called
	if (NULL == g_hDcapLib)
		return FALSE;

	// check the system policies for sending video
	if (_Module.IsSDKCallerRTC() || SysPol::NoVideoSend())
	{
		WARNING_OUT(("Video is disabled by system policies key\r\n"));
		return FALSE;
	}

	// count how many devices we have
	int numCaptureDevices = DLL_GetNumCaptureDevices();
	if (numCaptureDevices <= 1)
	{
		return FALSE;
	}

	// TRUE == (numCaptureDevice >= 2)

	if (fForce)
	{
		g_bPrompted = TRUE;
		return TRUE;
	}

	if (IsVideoRegistryValid() == TRUE)
	{
		return FALSE;
	}

	g_bPrompted = TRUE;
	return TRUE;
}



// Message handler for property page
INT_PTR APIENTRY VidWizDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND  hwndCB;  // handle to the dialog box
	int index;
	char szDriverNameDesc[MAX_CAPDEV_NAME+MAX_CAPDEV_VERSION];
	static LONG_PTR button_mask;
	FINDCAPTUREDEVICE CaptureDeviceInfo;
	
	hwndCB = GetDlgItem(hDlg, IDC_VWCOMBO);

	switch(message)
	{
		case(WM_INITDIALOG) :
			button_mask = ((PROPSHEETPAGE *)lParam)->lParam;
			if (g_hDcapLib == NULL) break;
			for (index = 0; index < MAXVIDEODRIVERS; index++)
			{
				CaptureDeviceInfo.dwSize = sizeof(FINDCAPTUREDEVICE);
				if (DLL_FindFirstCaptureDeviceByIndex(&CaptureDeviceInfo, index))
				{
					BuildCaptureDeviceInfoString(&CaptureDeviceInfo, szDriverNameDesc);
					ComboBox_AddString(hwndCB, szDriverNameDesc);
				}
			}
			ComboBox_SetCurSel(hwndCB, g_nCurrentSelection);
			break;

		case(WM_NOTIFY) :
			switch (((NMHDR *)lParam)->code)
			{
				case PSN_WIZBACK:
				{
					UINT_PTR iPrev = GetPageBeforeVideoWiz();
					ASSERT( iPrev );
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iPrev);
					g_bCurrentValid = TRUE;
					return TRUE;
				}

				case PSN_WIZNEXT:
				{
					UINT_PTR iNext = GetPageAfterVideo();
					ASSERT( iNext );
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iNext);
					g_bCurrentValid = TRUE;
					return TRUE;
				}

				case PSN_WIZFINISH:
				case PSN_KILLACTIVE:
					SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					g_bCurrentValid = TRUE;
					break;

				case PSN_SETACTIVE:
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), (button_mask & PSWIZB_NEXT) ? PSBTN_NEXT : PSBTN_FINISH);
					}
					else
					{
						PropSheet_SetWizButtons(GetParent(hDlg), button_mask);
					}
					break;

				case PSN_RESET:
					// psn_reset get's received even if user presses
					// cancel on another dialog.
					g_bCurrentValid = FALSE;
					break;

				default:
					return FALSE;
			}
			break;


		// combox box messages get sent here.
		// only one we need is when the user selects something
		case(WM_COMMAND) :
			if (HIWORD(wParam) == CBN_SELCHANGE)
			{
				g_nCurrentSelection = ComboBox_GetCurSel(hwndCB);
				break;
			}
			else
			{
				return FALSE;
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wabme.cpp ===
// File: wabme.cpp

#include "precomp.h"

#include "wabme.h"
#include "wabtags.h"
#include "wabiab.h"

BOOL GetKeyDataForProp(long nmProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, BOOL *pfString)
{
        // Default to ULS registry key
        *phkey = HKEY_CURRENT_USER;
        *ppszSubKey = ISAPI_KEY "\\" REGKEY_USERDETAILS;
        *pfString = TRUE;

        switch (nmProp)
                {
        default:
                WARNING_OUT(("GetKeyDataForProp - invalid argument %d", nmProp));
                return FALSE;

        case NM_SYSPROP_EMAIL_NAME:    *ppszValue = REGVAL_ULS_EMAIL_NAME;    break;
        case NM_SYSPROP_SERVER_NAME:   *ppszValue = REGVAL_SERVERNAME;        break;
        case NM_SYSPROP_RESOLVE_NAME:  *ppszValue = REGVAL_ULS_RES_NAME;      break;
        case NM_SYSPROP_FIRST_NAME:    *ppszValue = REGVAL_ULS_FIRST_NAME;    break;
        case NM_SYSPROP_LAST_NAME:     *ppszValue = REGVAL_ULS_LAST_NAME;     break;
        case NM_SYSPROP_USER_NAME:     *ppszValue = REGVAL_ULS_NAME;          break;
        case NM_SYSPROP_USER_LOCATION: *ppszValue = REGVAL_ULS_LOCATION_NAME; break;
        case NM_SYSPROP_USER_COMMENTS: *ppszValue = REGVAL_ULS_COMMENTS_NAME; break;

                } /* switch (nmProp) */

        return TRUE;
}


/*  W A B  R E A D  M E  */
/*-------------------------------------------------------------------------
    %%Function: WabReadMe

    Prep the NetMeeting registry settings with the data from the WAB "Me" entry.
    This function is also used by the main UI wizard.
-------------------------------------------------------------------------*/
int WabReadMe(void)
{
        CWABME * pWab = new CWABME;
        if (NULL == pWab)
                return FALSE;

        HRESULT hr = pWab->ReadMe();

        delete pWab;

        return SUCCEEDED(hr);
}


/*  R E A D  M E  */
/*-------------------------------------------------------------------------
    %%Function: ReadMe

    Read the WAB data, if it exists (but don't create a default "ME")
-------------------------------------------------------------------------*/
HRESULT CWABME::ReadMe(void)
{
        if (NULL == m_pWabObject)
        {
                return E_FAIL; // no wab installed?
        }

        SBinary eid;
        HRESULT hr = m_pWabObject->GetMe(m_pAdrBook, AB_NO_DIALOG | WABOBJECT_ME_NOCREATE, NULL, &eid, 0);
        if (SUCCEEDED(hr))
        {
                ULONG ulObjType = 0;
                LPMAPIPROP pMapiProp = NULL;
                hr = m_pAdrBook->OpenEntry(eid.cb, (LPENTRYID) eid.lpb, NULL, 0,
                                                &ulObjType, (LPUNKNOWN *)&pMapiProp);
                if (SUCCEEDED(hr))
                {
                        if (NULL != pMapiProp)
                        {
                                EnsurePropTags(pMapiProp);

                                UpdateRegEntry(pMapiProp, NM_SYSPROP_EMAIL_NAME,    PR_EMAIL_ADDRESS);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_FIRST_NAME,    PR_GIVEN_NAME);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_LAST_NAME,     PR_SURNAME);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_USER_NAME,     PR_DISPLAY_NAME);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_USER_LOCATION, PR_LOCALITY);
                                UpdateRegEntry(pMapiProp, NM_SYSPROP_USER_COMMENTS, PR_COMMENT);

                                UpdateRegEntryCategory(pMapiProp);
                                UpdateRegEntryServer(pMapiProp);

                                pMapiProp->Release();
                        }
                }
        }
        return hr;
}



/*  U P D A T E  R E G  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRegEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABME::UpdateRegEntry(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;
        ULONG  cValues;
        LPSPropValue pData;

        SPropTagArray prop;
        prop.cValues = 1;
        prop.aulPropTag[0] = uProp;

        HRESULT hr = pMapiProp->GetProps(&prop, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                if ((1 == cValues) && !FEmptySz(pData->Value.lpszA))
                {
                        if (GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString))
                        {
                                ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                                RegEntry re(pszSubKey, hkey);
                                re.SetValue(pszValue, pData->Value.lpszA);
                                WARNING_OUT(("Updated - %s to [%s]", pszValue, pData->Value.lpszA));
                        }
                }
                m_pWabObject->FreeBuffer(pData);
        }

        return hr;
}


// Update the user's server and resolved names in the registry
// based on the "ME" data
HRESULT CWABME::UpdateRegEntryServer(LPMAPIPROP pMapiProp)
{
        HRESULT hr;
        HKEY    hkey;
        LPTSTR  pszSubKey;
        LPTSTR  pszValue;
        BOOL    fString;
        ULONG   cValues;
        LPSPropValue pData;

        SPropTagArray propTag;
        propTag.cValues = 1;
        propTag.aulPropTag[0] = Get_PR_NM_DEFAULT();

        ULONG iDefault = 0; // the default server
        hr = pMapiProp->GetProps(&propTag, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                iDefault = pData->Value.ul;
                m_pWabObject->FreeBuffer(pData);
        }

        // ILS server data is in an array of strings like "callto://server/email@address"
        propTag.aulPropTag[0] = Get_PR_NM_ADDRESS();
        hr = pMapiProp->GetProps(&propTag, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                SLPSTRArray * pMVszA = &(pData->Value.MVszA);
                if ((0 != cValues) && (0 != pMVszA->cValues))
                {
                        ASSERT(iDefault < pMVszA->cValues);
                        LPCTSTR pszAddr = pMVszA->lppszA[iDefault];
                        pszAddr = PszSkipCallTo(pszAddr);

                        // Resolve Name is "server/email@address"
                        if (GetKeyDataForProp(NM_SYSPROP_RESOLVE_NAME, &hkey, &pszSubKey, &pszValue, &fString))
                        {
                                ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                                RegEntry re(pszSubKey, hkey);
                                re.SetValue(pszValue, pszAddr);
                                WARNING_OUT(("Updated - %s to [%s]", pszValue, pszAddr));
                        }

                        LPCTSTR pszSlash = _StrChr(pszAddr, _T('/'));
                        if (NULL != pszSlash)
                        {
                                pszSlash++;
                                TCHAR szServer[CCHMAXSZ_SERVER];
                                lstrcpyn(szServer, pszAddr, (int)min(CCHMAX(szServer), pszSlash - pszAddr));
                                if (GetKeyDataForProp(NM_SYSPROP_SERVER_NAME, &hkey, &pszSubKey, &pszValue, &fString))
                                {
                                        ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                                        RegEntry re(pszSubKey, hkey);
                                        re.SetValue(pszValue, szServer);
                                        WARNING_OUT(("Updated - %s to [%s]", pszValue, szServer));
                                }
                        }
                }
                m_pWabObject->FreeBuffer(pData);
        }

        return hr;
}


// Update the user's category in the registry
// based on the WAB value for the "ME" NetMeeting user category
HRESULT CWABME::UpdateRegEntryCategory(LPMAPIPROP pMapiProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;
        ULONG  cValues;
        LPSPropValue pData;

        SPropTagArray prop;
        prop.cValues = 1;
        prop.aulPropTag[0] = Get_PR_NM_CATEGORY();

        HRESULT hr = pMapiProp->GetProps(&prop, 0, &cValues, &pData);
        if (S_OK == hr)
        {
                if (1 == cValues)
                {
                        if (GetKeyDataForProp(NM_SYSPROP_USER_CATEGORY, &hkey, &pszSubKey, &pszValue, &fString))
                        {
                                ASSERT((HKEY_CURRENT_USER == hkey) && !fString);
                                RegEntry re(pszSubKey, hkey);
                                re.SetValue(pszValue, pData->Value.l);
                                WARNING_OUT(("Updated - category to %d", pData->Value.l));
                        }
                }
                m_pWabObject->FreeBuffer(pData);
        }

        return hr;
}




/*  W A B  W R I T E  M E  */
/*-------------------------------------------------------------------------
    %%Function: WabWriteMe

    Write the current NM settings to the WAB "Me" entry.
    This function is also used by the main UI wizard.
-------------------------------------------------------------------------*/
int WabWriteMe(void)
{
        CWABME * pWab = new CWABME;
        if (NULL == pWab)
                return FALSE;

        HRESULT hr = pWab->WriteMe();

        delete pWab;

        return SUCCEEDED(hr);
}


/*  W R I T E  M E  */
/*-------------------------------------------------------------------------
    %%Function: WriteMe

    Write the "ME" data only if no entry already exists.
-------------------------------------------------------------------------*/
HRESULT CWABME::WriteMe(void)
{
        return( S_OK );

        if (NULL == m_pWabObject)
        {
                return E_FAIL; // no wab installed?
        }

        SBinary eid;
        HRESULT hr = m_pWabObject->GetMe(m_pAdrBook, AB_NO_DIALOG, NULL, &eid, 0);
        if (SUCCEEDED(hr))
        {
                ULONG ulObjType = 0;
                LPMAPIPROP pMapiProp = NULL;
                hr = m_pAdrBook->OpenEntry(eid.cb, (LPENTRYID) eid.lpb, NULL, MAPI_MODIFY,
                                                &ulObjType, (LPUNKNOWN *)&pMapiProp);
                if (SUCCEEDED(hr))
                {
                        if (NULL != pMapiProp)
                        {
                                EnsurePropTags(pMapiProp);

                                UpdateProp(pMapiProp, NM_SYSPROP_FIRST_NAME,    PR_GIVEN_NAME);
                                UpdateProp(pMapiProp, NM_SYSPROP_LAST_NAME,     PR_SURNAME);
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_NAME,     PR_DISPLAY_NAME);
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_CITY,     PR_LOCALITY);           // Business
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_CITY,     PR_HOME_ADDRESS_CITY);  // Personal
                                UpdateProp(pMapiProp, NM_SYSPROP_USER_COMMENTS, PR_COMMENT);

                                UpdatePropServer(pMapiProp);
                                
                                hr = pMapiProp->SaveChanges(FORCE_SAVE);
                                pMapiProp->Release();
                        }
                }
        }
        return hr;

}


/*  U P D A T E  P R O P  */
/*-------------------------------------------------------------------------
    %%Function: UpdateProp

    Update a WAB properly based on the corresponding registry string.
-------------------------------------------------------------------------*/
HRESULT CWABME::UpdateProp(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;

        HRESULT hr = GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
                ASSERT((HKEY_CURRENT_USER == hkey) && fString);
                RegEntry re(pszSubKey, hkey);

                LPTSTR psz = re.GetString(pszValue);
                if (!FEmptySz(psz))
                {
                        hr = UpdatePropSz(pMapiProp, uProp, psz, FALSE);
                }
        }

        return hr;
}


// Update a WAB property to the given string.
// Replace existing data only if fReplace is TRUE
HRESULT CWABME::UpdatePropSz(LPMAPIPROP pMapiProp, ULONG uProp, LPTSTR psz, BOOL fReplace)
{
        HRESULT hr;

        if (!fReplace)
        {       // Don't replace existing data
                ULONG  cValues;
                LPSPropValue pData;

                SPropTagArray propTag;
                propTag.cValues = 1;
                propTag.aulPropTag[0] = uProp;

                hr = pMapiProp->GetProps(&propTag, 0, &cValues, &pData);
                if (S_OK == hr)
                {
                        if ((1 == cValues) && !FEmptySz(pData->Value.lpszA))
                        {
                                hr = S_FALSE;
                        }
                        m_pWabObject->FreeBuffer(pData);

                        if (S_OK != hr)
                                return hr;
                }
        }

        SPropValue propVal;
        propVal.ulPropTag = uProp;
        propVal.Value.lpszA = psz;
        
        hr = pMapiProp->SetProps(1, &propVal, NULL);
        WARNING_OUT(("Updated - property %08X to [%s]", uProp, propVal.Value.lpszA));

        return hr;
}


static const TCHAR g_pcszSMTP[] = TEXT("SMTP"); // value for PR_ADDRTYPE

// Update the default WAB "callto" information
HRESULT CWABME::UpdatePropServer(LPMAPIPROP pMapiProp)
{
        HKEY   hkey;
        LPTSTR pszSubKey;
        LPTSTR pszValue;
        BOOL   fString;

        TCHAR szServer[CCHMAXSZ_SERVER];
        GetKeyDataForProp(NM_SYSPROP_SERVER_NAME, &hkey, &pszSubKey, &pszValue, &fString);
        RegEntry re(pszSubKey, hkey);
        lstrcpyn(szServer, re.GetString(pszValue), CCHMAXSZ_SERVER);

        // Save the email address
        LPTSTR pszEmail = re.GetString(REGVAL_ULS_EMAIL_NAME);
        if (S_OK == UpdatePropSz(pMapiProp, PR_EMAIL_ADDRESS, pszEmail, FALSE))
        {
                UpdatePropSz(pMapiProp, PR_ADDRTYPE, (LPTSTR) g_pcszSMTP, FALSE);
        }

        // Create the full "callto://server/foo@bar.com"
        TCHAR sz[MAX_PATH*2];
        if (!FCreateCallToSz(szServer, pszEmail, sz, CCHMAX(sz)))
                return E_OUTOFMEMORY;

        LPTSTR psz = sz;
        SPropValue propVal;
        propVal.ulPropTag = Get_PR_NM_ADDRESS();
        propVal.Value.MVszA.cValues = 1;
        propVal.Value.MVszA.lppszA = &psz;
        
        HRESULT hr = pMapiProp->SetProps(1, &propVal, NULL);
        WARNING_OUT(("Updated - NM server [%s]", sz));
        if (SUCCEEDED(hr))
        {
                // Set this as the default
                propVal.ulPropTag = Get_PR_NM_DEFAULT();
                propVal.Value.ul = 0;
                hr = pMapiProp->SetProps(1, &propVal, NULL);
        }
        
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wabme.h ===
// File: wabme.h

#ifndef _WABME_H_
#define _WABME_H_

#include "wabutil.h"
#include "SDKInternal.h"

class CWABME : public CWABUTIL
{
public:
	CWABME() {};
	~CWABME() {};

	HRESULT ReadMe(void);
	HRESULT UpdateRegEntry(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp);
	HRESULT UpdateRegEntryLocation(LPMAPIPROP pMapiProp);
	HRESULT UpdateRegEntryServer(LPMAPIPROP pMapiProp);
	HRESULT UpdateRegEntryCategory(LPMAPIPROP pMapiProp);

	HRESULT WriteMe(void);
	HRESULT UpdateProp(LPMAPIPROP pMapiProp, NM_SYSPROP nmProp, ULONG uProp);
	HRESULT UpdatePropSz(LPMAPIPROP pMapiProp, ULONG uProp, LPTSTR psz, BOOL fReplace);
	HRESULT UpdatePropServer(LPMAPIPROP pMapiProp);
};

int WabReadMe();
int WabWriteMe();

#endif /* _WABME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wabutil.h ===
// File: wabutil.h

#ifndef _WABUTIL_H_
#define _WABUTIL_H_

#include "wabdefs.h"
#include "wabapi.h"

///////////////////////////////////////
// NetMeeting named prop IDs in the WAB

// DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);
#define PR_SERVERS          0x8056
#define CONF_DEFAULT_INDEX  0x8057
#define CONF_BACKUP_INDEX   0x8058
#define CONF_EMAIL_INDEX    0x8059

#define PR_NM_ADDRESS       PROP_TAG(PT_MV_STRING8, PR_SERVERS)
#define PR_NM_DEFAULT       PROP_TAG(PT_LONG, CONF_DEFAULT_INDEX)
#define PR_NM_BACKUP        PROP_TAG(PT_LONG, CONF_BACKUP_INDEX)

// CLSID_ConferenceManager (see confguid.h)
#define NM_TAG_MASK         0x0800
#define CONF_CATEGORY       0x8800
#define CONF_CTRYCODE       0x8801
#define PR_NM_CATEGORY      PROP_TAG(PT_LONG,    CONF_CATEGORY)

class CWABUTIL
{
private:
	BOOL   m_fTranslatedTags; // TRUE after GetNamedPropsTags succeeds

public:
	CWABUTIL();
	~CWABUTIL();

	// It's just easier if everything is public
	LPADRBOOK   m_pAdrBook;
	LPWABOBJECT m_pWabObject;
	LPABCONT    m_pContainer;

	LPSPropTagArray m_pPropTags;  // Translated tags
	LPSPropTagArray GetTags()    {return m_pPropTags;}

	ULONG   Get_PR_NM_ADDRESS();
	ULONG   Get_PR_NM_DEFAULT();
	ULONG   Get_PR_NM_CATEGORY();

	LPCTSTR PszSkipCallTo(LPCTSTR psz);
	BOOL    FCreateCallToSz(LPCTSTR pszServer, LPCTSTR pszEmail, LPTSTR pszCallTo, UINT cchMax);
	VOID    FreeProws(LPSRowSet prows);
	HRESULT GetContainer(void);

	HRESULT EnsurePropTags(void);
	HRESULT EnsurePropTags(LPMAPIPROP pMapiProp);
	HRESULT GetNamedPropsTag(LPMAPIPROP pMapiProp, LPSPropTagArray pProps);

	HRESULT HrGetWABTemplateID(ULONG * lpcbEID, LPENTRYID * lppEID);
	HRESULT CreateNewEntry(HWND hwndParent, ULONG cProps, SPropValue * pProps);
	HRESULT _CreateWabEntry(HWND hwndParent,
			LPCTSTR pszDisplay, LPCTSTR pszFirst, LPCTSTR pszLast, LPCTSTR pcszEmail,
			LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pcszComments, LPCTSTR pcszCallTo);
	HRESULT CreateWabEntry(HWND hwndParent,
			LPCTSTR pszDisplay, LPCTSTR pszFirst, LPCTSTR pszLast, LPCTSTR pcszEmail,
			LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pcszComments, LPCTSTR pcszServer);
	HRESULT CreateWabEntry(HWND hwndParent,
			LPCTSTR pszDisplay, LPCTSTR pszEmail,
			LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pszULSAddress);
};


// This is used for the ptaEid and m_pPropTags data
enum {
    ieidPR_ENTRYID = 0,    // Unique Entry ID
    ieidPR_DISPLAY_NAME,   // Display Name
	ieidPR_NM_ADDRESS,     // MVsz (array of "callto://server/email")
	ieidPR_NM_DEFAULT,     // Default Index into MVsz
	ieidPR_NM_CATEGORY,    // User Category/Rating (Personal=1, Business=2, Adult=4)
    ieidMax
};


#endif /* _WABUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wavedev.cpp ===
#include "precomp.h"
#include "WaveDev.h"
#include "WaveIo.h"



// utility function for both waveIndev and waveOutdev
// builds a PCM WaveFormatEx structure for a given sampling rate and size
static MMRESULT MakeWaveFormat(WAVEFORMATEX *pWF, int hertz, int bps)
{
	WAVEFORMATEX waveFormat;

	if ((bps != 8) && (bps != 16))
	{
		return WAVERR_BADFORMAT;
	}

	waveFormat.wFormatTag = WAVE_FORMAT_PCM;
	waveFormat.nChannels = 1;
	waveFormat.nSamplesPerSec = hertz;
	waveFormat.nAvgBytesPerSec = hertz * bps/8;
	waveFormat.nBlockAlign = bps/8;
	waveFormat.wBitsPerSample = (WORD)bps;
	waveFormat.cbSize = 0;

	*pWF = waveFormat;

	return MMSYSERR_NOERROR;
}




waveInDev::waveInDev(UINT uDevId, HANDLE hEvent) :
  m_devID(uDevId), m_hwi(NULL), m_bOpen(FALSE), m_fAllowMapper(TRUE),
  m_hEvent(hEvent)
{
	ZeroMemory(&m_waveFormat, sizeof(m_waveFormat));
	return;
}


waveInDev::~waveInDev()
{
	Close();
}

MMRESULT waveInDev::Open(int hertz, int bps)
{
	MMRESULT mmr;
	WAVEFORMATEX waveFormat;
	DWORD dwCallbackType = (m_hEvent ? CALLBACK_EVENT : CALLBACK_NULL );

	if (m_bOpen == TRUE)
		return MMSYSERR_NOERROR;

	mmr = MakeWaveFormat(&waveFormat, hertz, bps);
	if (mmr != MMSYSERR_NOERROR)
	{
		return mmr;
	}

	mmr = waveInOpen(&m_hwi, m_devID, &waveFormat, (DWORD_PTR)m_hEvent, 0, dwCallbackType);

	// begin hack, try to open wave_mapper
	// this may end up opening a different device!

	if ((mmr == WAVERR_BADFORMAT) && (m_fAllowMapper))
	{
		mmr = waveInOpen(&m_hwi, WAVE_MAPPER, &waveFormat, (DWORD_PTR)m_hEvent,
		                 0, dwCallbackType);
	}

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = TRUE;

	waveInStart(m_hwi);

	m_waveFormat = waveFormat;

	return mmr;
}


MMRESULT waveInDev::PrepareHeader(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = waveInPrepareHeader(m_hwi, pWaveHdr, sizeof(WAVEHDR));

	return mmr;

}



MMRESULT waveInDev::UnPrepareHeader(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = waveInUnprepareHeader(m_hwi, pWaveHdr, sizeof(WAVEHDR));

	return mmr;

}



MMRESULT waveInDev::Reset()
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_NOERROR;

	mmr = waveInReset(m_hwi);

	return mmr;
}


MMRESULT waveInDev::Close()
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_NOERROR;

	waveInReset(m_hwi);
	mmr = waveInClose(m_hwi);

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = FALSE;

	return mmr;
}


MMRESULT waveInDev::Record(WAVEHDR *pHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = waveInAddBuffer(m_hwi, pHdr, sizeof(WAVEHDR));

	return mmr;

}


void waveInDev::AllowMapper(BOOL fAllowMapper)
{
	m_fAllowMapper = fAllowMapper;
}




waveOutDev::waveOutDev(UINT uDevID, HWND hwnd)
 : m_devID(uDevID), m_hwo(NULL), m_bOpen(FALSE), m_hWnd(hwnd),
   m_pfBuffer(NULL), m_nBufferSize(0), m_fFileBufferValid(FALSE),
	m_fAllowMapper(TRUE)
{
	ZeroMemory(&m_waveFormat, sizeof(m_waveFormat));
	ZeroMemory(m_szPlayFile, sizeof(m_szPlayFile));
	ZeroMemory(&m_waveHdr, sizeof(m_waveHdr));

	if (hwnd == NULL)
	{
		m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

		if (m_hEvent == NULL)
		{
			ERROR_OUT(("waveOutDev::waveOutDev - Unable to create event"));
		}
	}
	else
		m_hEvent = NULL;

}

waveOutDev::~waveOutDev()
{
	Close();
	if (m_hEvent)
		CloseHandle(m_hEvent);

	if (m_pfBuffer)
		LocalFree(m_pfBuffer);
}



MMRESULT waveOutDev::Open(int hertz, int bps)
{
	MMRESULT mmr;
	WAVEFORMATEX waveFormat;

	mmr = MakeWaveFormat(&waveFormat, hertz, bps);
	if (mmr != MMSYSERR_NOERROR)
	{
		return mmr;
	}

	return Open(&waveFormat);

}


MMRESULT waveOutDev::Open(WAVEFORMATEX *pWaveFormat)
{
	MMRESULT mmr;

	m_waveFormat = *pWaveFormat;

	if (m_bOpen == TRUE)
		return MMSYSERR_NOERROR;

	if (m_hWnd == NULL)
	{
		mmr = waveOutOpen(&m_hwo, m_devID, &m_waveFormat, (DWORD_PTR)m_hEvent,
		                  0, CALLBACK_EVENT);
	}
	else
	{
		mmr = waveOutOpen(&m_hwo, m_devID, &m_waveFormat, (DWORD_PTR)m_hWnd,
		                  0, CALLBACK_WINDOW);
	}


	// begin hack, try to open wave_mapper
	// this may end up opening a different device!

	if ((mmr == WAVERR_BADFORMAT) && (m_fAllowMapper))
	{
		if (m_hWnd == NULL)
		{
			mmr = waveOutOpen(&m_hwo, WAVE_MAPPER, &m_waveFormat,
			(DWORD_PTR)m_hEvent, 0, CALLBACK_EVENT);
		}
		else
		{
			mmr = waveOutOpen(&m_hwo, WAVE_MAPPER, &m_waveFormat,
			(DWORD_PTR)m_hWnd, 0, CALLBACK_WINDOW);
		}
	}

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = TRUE;


	return mmr;

}





MMRESULT waveOutDev::Close()
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_NOERROR;

	waveOutReset(m_hwo);

	if (m_waveHdr.dwFlags & WHDR_PREPARED)
	{
		waveOutUnprepareHeader(m_hwo, &m_waveHdr, sizeof(m_waveHdr));
		m_waveHdr.dwFlags = 0;
	}

	mmr = waveOutClose(m_hwo);

	if (mmr == MMSYSERR_NOERROR)
		m_bOpen = FALSE;
	else
		ERROR_OUT(("ATW:Close failed"));

	return mmr;
}

MMRESULT waveOutDev::PrepareHeader(WAVEHDR *pWhdr, SHORT *shBuffer, int numSamples)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	// if shBuffer is not NULL, we assume the caller wants us to fill in the
	// WAVEHDR struct
	if (shBuffer)
	{
		ZeroMemory(pWhdr, sizeof(WAVEHDR));
		pWhdr->lpData = (LPSTR)shBuffer;
		pWhdr->dwBufferLength = numSamples * m_waveFormat.nBlockAlign;
	}

	mmr = waveOutPrepareHeader(m_hwo, pWhdr, sizeof(WAVEHDR));

	return mmr;

}

MMRESULT waveOutDev::UnprepareHeader(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = waveOutUnprepareHeader(m_hwo, pWaveHdr, sizeof(WAVEHDR));

	return mmr;

}

MMRESULT waveOutDev::Play(WAVEHDR *pWaveHdr)
{
	MMRESULT mmr;
	DWORD dwTimeOut;
	DWORD dwRet;
	int numSamples;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	if (m_hEvent)
		ResetEvent(m_hEvent);

	mmr = waveOutWrite(m_hwo, pWaveHdr, sizeof(WAVEHDR));

	if (mmr != MMSYSERR_NOERROR)
		return mmr;

	if (m_hEvent)
	{
		numSamples = pWaveHdr->dwBufferLength / m_waveFormat.nBlockAlign;

		dwTimeOut = 5 * ((1000 * numSamples) / m_waveFormat.nSamplesPerSec);
	
		dwRet = WaitForSingleObject(m_hEvent, dwTimeOut);

		if ((dwRet != WAIT_ABANDONED) && (dwRet != WAIT_OBJECT_0))
		{
			ERROR_OUT(("waveOutDev::Play() - WaitForSingleObject Failed"));
			return WAVERR_LASTERROR + 1;
		}
	}

	return MMSYSERR_NOERROR;
}



// File io errors or anything unexpected results in -1 being returned
// Otherwise, returns the MMRESULT of the last waveOut call made
MMRESULT waveOutDev::PlayFile(LPCTSTR szFileName)
{
	MMRESULT    mmr;
	WAVEIOCB    waveiocb;
	WIOERR      werr;
	DWORD       dwSize;
	PCHAR       pBuffer;


	// quick optimization
	// if the same file is being played twice in a row
	// the just replay the buffer

	if ((m_fFileBufferValid) && (0 == lstrcmp(szFileName, m_szPlayFile)))
	{
		Close();
		mmr = Open(&m_PlayFileWf);

		if (mmr == MMSYSERR_NOERROR)
		{
			mmr = PrepareHeader(&m_waveHdr, (SHORT*)m_pfBuffer, m_nBufferSize / m_PlayFileWf.nBlockAlign);
			if (mmr == MMSYSERR_NOERROR)
			{
				mmr = Play(&m_waveHdr);
			}
		}

		m_fFileBufferValid = (mmr == MMSYSERR_NOERROR);
		return mmr;
	}


	ZeroMemory(&waveiocb, sizeof(waveiocb));
	werr = wioFileOpen(&waveiocb, szFileName, 0);

	if (werr == WIOERR_NOERROR)
	{
		// prepare to read the samples!

		// quick hack, if the file to play was the same as the last,
		// then use the same buffer

		m_fFileBufferValid = FALSE;

		if (m_pfBuffer == NULL)
		{
			m_pfBuffer = (char *)LocalAlloc(LPTR, waveiocb.dwDataBytes);
		}
		else
		{
		    pBuffer = (char*)LocalReAlloc(m_pfBuffer, waveiocb.dwDataBytes, LMEM_MOVEABLE |LMEM_ZEROINIT);
		    if(NULL != pBuffer)
		    {
			    m_pfBuffer = pBuffer;
		    }
		    else
		    {
				// Failed to reallocate buffer, make sure to clean up
		        LocalFree(m_pfBuffer);
		        m_pfBuffer = NULL;
		    }
		}

		if (m_pfBuffer == NULL)
		{
			wioFileClose(&waveiocb, 0);
			return -1;
		}

		// read
		mmioSeek(waveiocb.hmmio, waveiocb.dwDataOffset, SEEK_SET);
		dwSize = mmioRead(waveiocb.hmmio, m_pfBuffer, waveiocb.dwDataBytes);

		if (dwSize == 0)
			return -1;

		Close();
		mmr = Open(waveiocb.pwfx);
		if (mmr != MMSYSERR_NOERROR)
		{
			wioFileClose(&waveiocb, 0);
			return mmr;
		}

//		mmr = Play((short *)m_pfBuffer, dwSize / (waveiocb.pwfx)->nBlockAlign);

		mmr = PrepareHeader(&m_waveHdr, (SHORT*)m_pfBuffer,
		                           dwSize / (waveiocb.pwfx)->nBlockAlign);
		if (mmr == MMSYSERR_NOERROR)
		{
			mmr = Play(&m_waveHdr);
		}

		m_fFileBufferValid = (mmr == MMSYSERR_NOERROR);
		if (m_fFileBufferValid)
		{
			m_PlayFileWf = *(waveiocb.pwfx);
			lstrcpy(m_szPlayFile, szFileName);
			m_nBufferSize = dwSize;
		}

		wioFileClose(&waveiocb, 0);

		return mmr;
	}

	return -1;

}

void waveOutDev::AllowMapper(BOOL fAllowMapper)
{
	m_fAllowMapper = fAllowMapper;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wabutil.cpp ===
// File: wabutil.cpp
//
// Generic Windows Address Book utility functions

#include "precomp.h"

#include "wabutil.h"
#include "wabtags.h"
#include "wabiab.h"

#include <confguid.h> // for CLSID_ConferenceManager


static const TCHAR _szCallToWab[] = TEXT("callto://"); // the prefix for NM WAB entries

static const TCHAR g_pcszSMTP[] = TEXT("SMTP"); // value for PR_ADDRTYPE

// see rgData in CreateWabEntry
static const int IENTRYPROP_NM_DEFAULT = 5;
static const int IENTRYPROP_NM_ADDRESS = 6;


// REVIEW: There should be an external header file for these.
// They are documented in http://fbi/wabapi.htm

// DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);
static const GUID PS_Conferencing = {0x00062004, 0, 0, {0xC0,0,0,0,0,0,0,0x46} };


/////////////////////////////////////////////////////////////////////

static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_NM_ADDRESS,
        PR_NM_DEFAULT,
        PR_NM_CATEGORY
    }
};
static const SizedSPropTagArray(1, ptaEidOnly)=
{
        1, {PR_ENTRYID}
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrMax
};

static const SizedSPropTagArray(icrMax, ptaCreate) =
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
    }
};



/////////////////////////////////////////////////////////////////////
//
// Dynamic WAB interface

const static TCHAR _szWABRegPathKey[] = TEXT("Software\\Microsoft\\WAB\\DLLPath");
const static TCHAR _szWABDll[]        = TEXT("WAB32DLL.dll");
const static char  _szWABOpen[]       = "WABOpen";

class WABDLL
{
private:
        static HINSTANCE m_hInstLib;
        static LPWABOPEN m_pfnWABOpen;

protected:
        WABDLL();
        ~WABDLL() {};
        
public:
        static HRESULT WABOpen(LPADRBOOK FAR *, LPWABOBJECT FAR *, LPWAB_PARAM, DWORD);
};

LPWABOPEN WABDLL::m_pfnWABOpen = NULL;
HINSTANCE WABDLL::m_hInstLib = NULL;

HRESULT WABDLL::WABOpen(LPADRBOOK FAR * lppAdrBook, LPWABOBJECT FAR * lppWABObject,
                        LPWAB_PARAM lpWP, DWORD dwReserved)
{
        if (NULL == m_pfnWABOpen)
        {
            HKEY hKey;
            TCHAR szPath[MAX_PATH];

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                _szWABRegPathKey, 0, KEY_READ, &hKey))
                {
                        // Probably don't have IE4 installed
                        lstrcpy(szPath, _szWABDll);
                }
                else
                {
                    DWORD dwType = 0;
                    DWORD cbData = sizeof(szPath); // the size in BYTES
                        RegQueryValueEx(hKey, g_cszEmpty, NULL, &dwType, (LPBYTE) szPath, &cbData);
                        RegCloseKey(hKey);
                        if (FEmptySz(szPath))
                return E_NOINTERFACE;
                }

                m_hInstLib = LoadLibrary(szPath);
                if (NULL == m_hInstLib)
            return E_NOINTERFACE;

                m_pfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstLib, _szWABOpen);
                if (NULL == m_pfnWABOpen)
                {
                        FreeLibrary(m_hInstLib);
            return E_NOINTERFACE;
                }
        }

        return m_pfnWABOpen(lppAdrBook, lppWABObject, lpWP, dwReserved);
}

///////////////////////////////////////////////////////////////////////////



/*  C  W  A  B  U  T  I  L  */
/*-------------------------------------------------------------------------
    %%Function: CWABUTIL
    
-------------------------------------------------------------------------*/
CWABUTIL::CWABUTIL() :
        m_pAdrBook(NULL),
        m_pWabObject(NULL),
        m_pContainer(NULL),
        m_pPropTags(NULL),
        m_fTranslatedTags(FALSE)
{
        // Make a copy of the property data
        m_pPropTags = (LPSPropTagArray) new BYTE[sizeof(ptaEid)];
        if (NULL != m_pPropTags)
        {
                CopyMemory(m_pPropTags, &ptaEid, sizeof(ptaEid));

                WABDLL::WABOpen(&m_pAdrBook, &m_pWabObject, NULL, 0);
        }
}

CWABUTIL::~CWABUTIL()
{
        delete m_pPropTags;

        if (NULL != m_pContainer)
        {
                m_pContainer->Release();
        }
        if (NULL != m_pWabObject)
        {
                m_pWabObject->Release();
        }
        if (NULL != m_pAdrBook)
        {
                m_pAdrBook->Release();
        }
}


/*  P S Z  S K I P  C A L L  T O  */
/*-------------------------------------------------------------------------
    %%Function: PszSkipCallTo

    Return a pointer after the "callto://" string.
-------------------------------------------------------------------------*/
LPCTSTR CWABUTIL::PszSkipCallTo(LPCTSTR psz)
{
        ASSERT(!FEmptySz(psz));

        TCHAR szTemp[CCHMAX(_szCallToWab)];
        lstrcpyn(szTemp, psz, CCHMAX(szTemp)); // FUTURE: Use StrCmpNI
        if (0 == lstrcmpi(szTemp, _szCallToWab))
        {
                psz += CCHMAX(_szCallToWab)-1;
        }

        return psz;
}

BOOL CWABUTIL::FCreateCallToSz(LPCTSTR pszServer, LPCTSTR pszEmail, LPTSTR pszDest, UINT cchMax)
{
        if ((lstrlen(pszServer) + lstrlen(pszEmail) + CCHMAX(_szCallToWab)) >= cchMax)
                return FALSE; // it won't fix
        
        // This has the format:  "callto://server/foo@bar.com"
        wsprintf(pszDest, TEXT("%s%s/%s"), _szCallToWab, pszServer, pszEmail);
        ASSERT(lstrlen(pszDest) < (int) cchMax);
        return TRUE;
}


ULONG CWABUTIL::Get_PR_NM_ADDRESS(void)
{
        ASSERT(m_fTranslatedTags);
        return m_pPropTags->aulPropTag[ieidPR_NM_ADDRESS];
}

ULONG CWABUTIL::Get_PR_NM_DEFAULT(void)
{
        ASSERT(m_fTranslatedTags);
        return m_pPropTags->aulPropTag[ieidPR_NM_DEFAULT];
}

ULONG CWABUTIL::Get_PR_NM_CATEGORY(void)
{
        ASSERT(m_fTranslatedTags);
        return m_pPropTags->aulPropTag[ieidPR_NM_CATEGORY];
}

/*  F R E E  P R O W S  */
/*-------------------------------------------------------------------------
    %%Function: FreeProws
    
-------------------------------------------------------------------------*/
VOID CWABUTIL::FreeProws(LPSRowSet prows)
{
        if (NULL == prows)
                return;

        for (ULONG irow = 0; irow < prows->cRows; irow++)
        {
                m_pWabObject->FreeBuffer(prows->aRow[irow].lpProps);
        }

        m_pWabObject->FreeBuffer(prows);
}


/*  G E T  C O N T A I N E R  */
/*-------------------------------------------------------------------------
    %%Function: GetContainer
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::GetContainer(void)
{
        if (NULL != m_pContainer)
                return S_OK;

        ASSERT(NULL != m_pWabObject);
        ASSERT(NULL != m_pAdrBook);

        // get the entryid for the WAB
        ULONG cbEID;
        LPENTRYID lpEID;
        HRESULT hr = m_pAdrBook->GetPAB(&cbEID, &lpEID);
        if (SUCCEEDED(hr))
        {
                // use the entryid to get the container
                ULONG ulObjType = 0;
            hr = m_pAdrBook->OpenEntry(cbEID, lpEID, NULL, 0,
                                                        &ulObjType, (LPUNKNOWN *)&m_pContainer);
                m_pWabObject->FreeBuffer(lpEID);
        }

        return hr;
}


/*  E N S U R E  P R O P  T A G S  */
/*-------------------------------------------------------------------------
    %%Function: EnsurePropTags

    Ensure the special property tags are available.
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::EnsurePropTags(void)
{
        if (m_fTranslatedTags)
                return S_OK;

        ASSERT(NULL != m_pContainer);

        LPSRowSet pRowSet = NULL;
        LPMAPITABLE pAB = NULL;
        // get the WAB contents
        HRESULT hr = m_pContainer->GetContentsTable(0, &pAB);
        if (FAILED(hr))
        {
                return hr; // probably empty
        }

        if ((SUCCEEDED(hr = pAB->SetColumns((LPSPropTagArray)&ptaEidOnly, 0))) &&
                (SUCCEEDED(hr = pAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL))) &&
                (SUCCEEDED(hr = pAB->QueryRows(1, 0, &pRowSet))) &&
                (NULL != pRowSet) )
        {
                if (0 != pRowSet->cRows)
                {
                        LPMAPIPROP pMapiProp = NULL;
                        ULONG ulObjType = 0;
                        hr = m_pContainer->OpenEntry(pRowSet->aRow[0].lpProps[0].Value.bin.cb,
                                                                                (LPENTRYID) pRowSet->aRow[0].lpProps[0].Value.bin.lpb,
                                                                                NULL,   // the object's standard i/f
                                                                                0,              // flags
                                                                                &ulObjType,
                                                                                (LPUNKNOWN *)&pMapiProp);
                        if (SUCCEEDED(hr))
                        {
                                hr = GetNamedPropsTag(pMapiProp, m_pPropTags);
                        }

                        if (NULL != pMapiProp)
                        {
                                pMapiProp->Release();
                        }
                }
                FreeProws(pRowSet);
        }

        if (NULL != pAB)
        {
                pAB->Release();
        }

        return hr;
}


// Use this version when no m_pContainer is available
HRESULT CWABUTIL::EnsurePropTags(LPMAPIPROP pMapiProp)
{
        if (m_fTranslatedTags)
                return S_OK;

        return GetNamedPropsTag(pMapiProp, m_pPropTags);
}

/*  G E T  N A M E D  P R O P S  T A G  */
/*-------------------------------------------------------------------------
    %%Function: GetNamedPropsTag

    Translate the named properties into their proper values
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::GetNamedPropsTag(LPMAPIPROP pMapiProp, LPSPropTagArray pProps)
{
        ASSERT(!m_fTranslatedTags);
        ASSERT(NULL != pMapiProp);
        ASSERT(NULL != pProps);

        int iProp;
        int cProps = pProps->cValues;  // total number of property tags
        ASSERT(0 != cProps);

        int iName;
        int cNames = 0;  // The number of named tags to translate
        for (iProp = 0; iProp < cProps; iProp++)
        {
                if (0 != (PROP_ID(pProps->aulPropTag[iProp]) & 0x8000))
                {
                        cNames++;
                }
        }
        ASSERT(0 != cNames);
        
        // allocate memory for the named props pointers array
        int cb = sizeof(LPMAPINAMEID) * cNames;
        LPMAPINAMEID * pNameIds = (LPMAPINAMEID *) new BYTE[cb];
        if (NULL == pNameIds)
                return E_OUTOFMEMORY;
        ZeroMemory(pNameIds, cb);

        // run through the prop tag array and build a MAPINAMEID for each prop tag
        HRESULT hr = S_OK;
        iName = 0;
        for (iProp = 0; iProp < cProps; iProp++)
        {
                ULONG ulTag = pProps->aulPropTag[iProp];
                if (0 != (PROP_ID(ulTag) & 0x8000))
                {
                pNameIds[iName] = new MAPINAMEID;
                if (NULL == pNameIds[iName])
                {
                                hr = E_OUTOFMEMORY;
                                break;
                }

                        // Either Outlook public or NetMeeting private tag
                        BOOL fPrivate = 0 != (PROP_ID(ulTag) & NM_TAG_MASK);
                        GUID * pGuid = (GUID *) (fPrivate ? &CLSID_ConferenceManager : &PS_Conferencing);
                        
                        pNameIds[iName]->lpguid = pGuid;
                        pNameIds[iName]->ulKind = MNID_ID;
                        pNameIds[iName]->Kind.lID = PROP_ID(ulTag);
                        iName++;
                }
        }

        if (SUCCEEDED(hr))
        {
                LPSPropTagArray pta = NULL;

                // get the named props "real" tags
                hr = pMapiProp->GetIDsFromNames(cNames, pNameIds, MAPI_CREATE, &pta);
                if (SUCCEEDED(hr))
                {
                        if (NULL == pta)
                        {
                                hr = E_FAIL;
                        }
                        else
                        {
                                // replace the named tags with the real tags in the passed in prop tag array,
                                // maintaining the types.
                                ULONG * pul = &pta->aulPropTag[0];
                                for (iProp = 0; iProp < cProps; iProp++)
                                {
                                        ULONG ulTag = pProps->aulPropTag[iProp];
                                        if (0 != (PROP_ID(ulTag) & 0x8000))
                                        {
                                                // set the property types on the returned props
                                                pProps->aulPropTag[iProp] = CHANGE_PROP_TYPE(*pul++, PROP_TYPE(ulTag));
                                        }
                                }

                                m_pWabObject->FreeBuffer(pta);
                        }
                }
        }

        // Cleanup
    if (NULL != pNameIds)
    {
            for (iName = 0; iName < cNames; iName++)
            {
                        delete pNameIds[iName];
                }

                delete pNameIds;
        }

        m_fTranslatedTags = SUCCEEDED(hr);
        return hr;
}


/*  H R  G E T  W  A  B  T E M P L A T E  I  D  */
/*-------------------------------------------------------------------------
    %%Function: HrGetWABTemplateID

        Gets the WABs default Template ID for MailUsers or DistLists.
        These Template IDs are needed for creating new mailusers and distlists.
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::HrGetWABTemplateID(ULONG * lpcbEID, LPENTRYID * lppEID)
{
    *lpcbEID = 0;
    *lppEID = NULL;

    if (NULL == m_pAdrBook)
    {
        return E_INVALIDARG;
    }
    ASSERT(NULL != m_pWabObject);

        ULONG cbWABEID;
        LPENTRYID lpWABEID;
        HRESULT hr = m_pAdrBook->GetPAB(&cbWABEID, &lpWABEID);
        if (FAILED(hr))
                return hr;

        LPABCONT lpContainer = NULL;
        ULONG ulObjectType = MAPI_MAILUSER;
        hr = m_pAdrBook->OpenEntry(cbWABEID, lpWABEID, NULL, 0,
              &ulObjectType, (LPUNKNOWN *)&lpContainer);
        if (SUCCEEDED(hr))
        {
                ULONG cNewProps;
            LPSPropValue lpCreateEIDs = NULL;

            // Get the default creation entryids
                hr = lpContainer->GetProps((LPSPropTagArray)&ptaCreate, 0, &cNewProps, &lpCreateEIDs);
            if (S_OK == hr)
                {
                    // Validate the properites
                    if (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag == PR_DEF_CREATE_MAILUSER)
                    {
                        ULONG nIndex = icrPR_DEF_CREATE_MAILUSER;
                            *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;
                            if (S_OK == m_pWabObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID))
                            {
                                        CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);
                                }
                        }
                }

                if (NULL != lpCreateEIDs)
                {
                        m_pWabObject->FreeBuffer(lpCreateEIDs);
                }
        }

        if (NULL != lpContainer)
        {
                lpContainer->Release();
        }

        if (NULL != lpWABEID)
        {
                m_pWabObject->FreeBuffer(lpWABEID);
        }

        return hr;
}


/*  C R E A T E  N E W  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateNewEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::CreateNewEntry(HWND hwndParent, ULONG cProps, SPropValue * pProps)
{
        ULONG cbEID;
        LPENTRYID lpEID;
        ULONG cbTplEID;
        LPENTRYID lpTplEID;

        // Get the template id which is needed to create the new object
        HRESULT hr = HrGetWABTemplateID(&cbTplEID, &lpTplEID);
        if (FAILED(hr))
                return hr;

        // get the entryid for the WAB
        hr = m_pAdrBook->GetPAB(&cbEID, &lpEID);
        if (FAILED(hr))
                return hr;

        // use the entryid to get the container
        ULONG ulObjType = 0;
        LPABCONT pContainer = NULL;
        hr = m_pAdrBook->OpenEntry(cbEID, lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&pContainer);
        m_pWabObject->FreeBuffer(lpEID);
        if (SUCCEEDED(hr))
        {
                LPMAPIPROP pMapiProp = NULL;
                hr = pContainer->CreateEntry(cbTplEID, lpTplEID, CREATE_CHECK_DUP_LOOSE, &pMapiProp);
                if (SUCCEEDED(hr))
                {
                        if (PR_NM_ADDRESS == m_pPropTags->aulPropTag[ieidPR_NM_ADDRESS])
                        {
                                GetNamedPropsTag(pMapiProp, m_pPropTags);
                        }
                        (pProps+IENTRYPROP_NM_DEFAULT)->ulPropTag = m_pPropTags->aulPropTag[ieidPR_NM_DEFAULT];
                        (pProps+IENTRYPROP_NM_ADDRESS)->ulPropTag = m_pPropTags->aulPropTag[ieidPR_NM_ADDRESS];

                        LPSPropProblemArray pErr = NULL;
                        hr = pMapiProp->SetProps(cProps, pProps, &pErr);
                        if (SUCCEEDED(hr))
                        {
                                hr = pMapiProp->SaveChanges(FORCE_SAVE);

                                // Show the new entry
                                if (SUCCEEDED(hr))
                                {
                                        ULONG cProp1;
                                        LPSPropValue pPropEid;
                                        hr = pMapiProp->GetProps((LPSPropTagArray)&ptaEidOnly, 0, &cProp1, &pPropEid);
                                        if (S_OK == hr)
                                        {
                                        hr = m_pAdrBook->Details((LPULONG) &hwndParent, NULL, NULL,
                                                                    pPropEid->Value.bin.cb,
                                                                    (LPENTRYID) pPropEid->Value.bin.lpb,
                                                                    NULL, NULL, NULL, DIALOG_MODAL);
                                        }

                                        if (S_OK != hr)
                                        {
                                                // There was a problem, delete the entry
                                                ENTRYLIST eList;
                                                eList.cValues = 1;
                                                eList.lpbin = (LPSBinary) &pPropEid->Value.bin;

                                                pContainer->DeleteEntries(&eList, 0);
                                        }

                                        m_pWabObject->FreeBuffer(pPropEid);
                                }
                        }
                        else
                        {
                                // How could this ever fail?
                                m_pWabObject->FreeBuffer(pErr);
                        }

                        pMapiProp->Release();
                }
        }

        if (NULL != pContainer)
        {
                pContainer->Release();
        }

        return hr;
}


/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::_CreateWabEntry(HWND hwndParent, LPCTSTR pszDisplay, LPCTSTR pszFirst, LPCTSTR pszLast,
        LPCTSTR pszEmail, LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pszComments,
        LPCTSTR pszCallTo)
{
        // These must be non-null
        ASSERT(!FEmptySz(pszDisplay));
        ASSERT(!FEmptySz(pszEmail));

        SPropValue rgData[13]; // maximum number of properties
        ZeroMemory(rgData, sizeof(rgData));

        rgData[0].ulPropTag = PR_DISPLAY_NAME;
        rgData[0].Value.lpszA = const_cast<LPTSTR>(pszDisplay);
        rgData[1].ulPropTag = PR_GIVEN_NAME;
        rgData[1].Value.lpszA = const_cast<LPTSTR>(pszFirst);
        rgData[2].ulPropTag = PR_SURNAME;
        rgData[2].Value.lpszA = const_cast<LPTSTR>(pszLast);
        rgData[3].ulPropTag = PR_EMAIL_ADDRESS;
        rgData[3].Value.lpszA = const_cast<LPTSTR>(pszEmail);
        rgData[4].ulPropTag = PR_ADDRTYPE;
        rgData[4].Value.lpszA = (LPSTR) g_pcszSMTP;

        // There is only one default server

        ASSERT(5 == IENTRYPROP_NM_DEFAULT);
        // LPSPropTagArray pPropTags = pWab->GetTags();  // Translated tags
        //rgData[IENTRYPROP_NM_DEFAULT].ulPropTag = pPropTags->aulPropTag[ieidPR_NM_DEFAULT];
        rgData[IENTRYPROP_NM_DEFAULT].Value.ul = 0;

        ASSERT(6 == IENTRYPROP_NM_ADDRESS);
        //rgData[IENTRYPROP_NM_ADDRESS].ulPropTag = pPropTags->aulPropTag[ieidPR_NM_ADDRESS];
        rgData[IENTRYPROP_NM_ADDRESS].Value.MVszA.cValues = 1;
        rgData[IENTRYPROP_NM_ADDRESS].Value.MVszA.lppszA =  const_cast<LPTSTR*>(&pszCallTo);


        // Add any other non-null properties
        SPropValue * pProp = &rgData[7];

        if (!FEmptySz(pszLocation))
        {
                pProp->ulPropTag = PR_LOCALITY;
                pProp->Value.lpszA = const_cast<LPTSTR>(pszLocation);
                pProp++;
        }

        if (!FEmptySz(pszPhoneNum))
        {
                pProp->ulPropTag = PR_BUSINESS_TELEPHONE_NUMBER;
                pProp->Value.lpszA = const_cast<LPTSTR>(pszPhoneNum);
                pProp++;
        }

        if (!FEmptySz(pszComments))
        {
                pProp->ulPropTag = PR_COMMENT;
                pProp->Value.lpszA = const_cast<LPTSTR>(pszComments);
                pProp++;
        }
        ULONG cProp = (ULONG)(pProp - rgData);
        ASSERT(cProp <= ARRAY_ELEMENTS(rgData));

        return CreateNewEntry(hwndParent, cProp, rgData);
}

/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::CreateWabEntry(HWND hwndParent, LPCTSTR pszDisplay,
        LPCTSTR pszFirst, LPCTSTR pszLast, LPCTSTR pszEmail, LPCTSTR pszLocation,
        LPCTSTR pszPhoneNum, LPCTSTR pszComments,       LPCTSTR pszServer)
{
        // This has the format:  "callto://server/foo@bar.com"
        TCHAR szCallTo[MAX_PATH*2];
        LPTSTR pszCallTo = szCallTo;
        if (!FCreateCallToSz(pszServer, pszEmail, szCallTo, CCHMAX(szCallTo)))
                return E_OUTOFMEMORY;

        return _CreateWabEntry(hwndParent, pszDisplay, pszFirst, pszLast,
                pszEmail, pszLocation, pszPhoneNum, pszComments, pszCallTo);
}

/*  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CreateWabEntry
    
-------------------------------------------------------------------------*/
HRESULT CWABUTIL::CreateWabEntry(HWND hwndParent,
        LPCTSTR pszDisplay, LPCTSTR pszEmail,
        LPCTSTR pszLocation, LPCTSTR pszPhoneNum, LPCTSTR pszULSAddress)
{

        // This has the format:  "callto://server/foo@bar.com"
        TCHAR szCallTo[MAX_PATH*2];
        LPTSTR pszCallTo = szCallTo;
        if ((lstrlen(pszULSAddress) + CCHMAX(_szCallToWab)) >= CCHMAX(szCallTo))
                return E_FAIL; // it won't fit
        wsprintf(szCallTo, TEXT("%s%s"), _szCallToWab, pszULSAddress);

        return _CreateWabEntry(hwndParent, pszDisplay, g_szEmpty, g_szEmpty,
                pszEmail, pszLocation, pszPhoneNum, g_szEmpty, pszCallTo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wavedev.h ===
#ifndef _WAVEDEV_H
#define _WAVEDEV_H

#include "WaveIo.h"

class waveInDev
{
private:
	UINT m_devID;
	HWAVEIN m_hwi;
	BOOL m_bOpen;  // is the device open ?
	WAVEFORMATEX m_waveFormat;
	BOOL m_fAllowMapper;
	HANDLE m_hEvent;

public:
	waveInDev(UINT uDevId, HANDLE hEvent=NULL);
	~waveInDev();

	MMRESULT Open(int hertz=8000, int bps=16);
	MMRESULT Reset();
	MMRESULT Close();

	MMRESULT PrepareHeader(WAVEHDR *pHdr);
	MMRESULT UnPrepareHeader(WAVEHDR *pHdr);

	MMRESULT Record(WAVEHDR *pHdr);

	void AllowMapper(BOOL fAllow);
};


// waveOutDev works in blocking/synchronous mode and
// non-blocking async mode.  If a window handle is passed
// as the second argument to the contructor, then the window
// will receive message from the waveOut device and the calls
// are non-blocking.  Otherwise, Play() and PlayFile are blocking.
class waveOutDev
{
private:
	UINT m_devID;
	HWAVEOUT m_hwo;
	BOOL m_bOpen;  // is the device open
	HANDLE m_hWnd;
	HANDLE m_hEvent;
	WAVEFORMATEX m_waveFormat;
	BOOL m_fAllowMapper;


	// playfile needs a temporary buffer
	char *m_pfBuffer;
	WAVEHDR m_waveHdr;
	int m_nBufferSize;
	TCHAR m_szPlayFile[150];
	WAVEFORMATEX m_PlayFileWf;
	BOOL m_fFileBufferValid;

public:
	waveOutDev(UINT uDevID, HWND hwnd=NULL);
	~waveOutDev();

	MMRESULT Open(int hertz=8000, int bps=16);
	MMRESULT Open(WAVEFORMATEX *pWaveFormat);
	MMRESULT Close();

	MMRESULT PrepareHeader(WAVEHDR *pWhdr, SHORT *shBuffer=NULL, int numSamples=0);
	MMRESULT Play(WAVEHDR *pWhdr);
	MMRESULT UnprepareHeader(WAVEHDR *pWhdr);

	MMRESULT PlayFile(LPCTSTR szFileName);

	void AllowMapper(BOOL fAllow);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\wizard.cpp ===
// File: wizard.cpp

#include "precomp.h"

#include <vfw.h>
#include <ulsreg.h>
#include "call.h"
#include "ulswizrd.h"
#include "ConfWnd.h"
#include "ConfCpl.h"
#include "mrulist.h"
#include "conf.h"
#include "setupdd.h"
#include "vidwiz.h"
#include "dstest.h"
#include "splash.h"
#include "nmmkcert.h"

#include "confroom.h" // for GetConfRoom
#include "FnObjs.h"

#include "ConfPolicies.h"
#include "SysPol.h"
#include "confUtil.h"
#include "shlWAPI.h"

#include "help_ids.h"

extern VOID SaveDefaultCodecSettings(UINT uBandWidth);
INT_PTR CALLBACK ShortcutWizDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// from ulscpl.cpp
VOID FixServerDropList(HWND hdlg, int id, LPTSTR pszServer, UINT cchMax);

static const TCHAR g_szRegOwner[]    = WIN_REGKEY_REGOWNER;	// concatenated string of first name + last name
static const TCHAR g_szClientFld[]   = ULS_REGISTRY TEXT ("\\") ULS_REGFLD_CLIENT;

static const TCHAR g_szFirstName[]   = ULS_REGKEY_FIRST_NAME;
static const TCHAR g_szLastName[]    = ULS_REGKEY_LAST_NAME;
static const TCHAR g_szEmailName[]   = ULS_REGKEY_EMAIL_NAME;
static const TCHAR g_szLocation[]    = ULS_REGKEY_LOCATION;
static const TCHAR g_szComments[]    = ULS_REGKEY_COMMENTS;
static const TCHAR g_szServerName[]  = ULS_REGKEY_SERVER_NAME;
static const TCHAR g_szDontPublish[] = ULS_REGKEY_DONT_PUBLISH;
static const TCHAR g_szResolveName[] = ULS_REGKEY_RESOLVE_NAME; // concatenated string of uls://servername/emailname
static const TCHAR g_szUserName[]    = ULS_REGKEY_USER_NAME;	// concatenated string of first name + last name


// These functions are implemented below:
static INT_PTR APIENTRY IntroWiz(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
static INT_PTR APIENTRY AppSharingWiz(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
static INT_PTR APIENTRY BandwidthWiz(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
static BOOL NeedAudioWizard(LPLONG plSoundCaps, BOOL fForce);
static BOOL CheckForNames(ULS_CONF *pConf);

static void FillWizardPages ( PROPSHEETPAGE *pPage, LPARAM lParam );


struct INTRO_PAGE_CONFIG
{
	BOOL *	fContinue;
	BOOL	fAllowBack;
};

BOOL g_fSilentWizard = FALSE;

// This holdn the user info page HWND...
static HWND s_hDlgUserInfo = NULL;
static HWND s_hDlgGKSettings = NULL;

class IntroWiz
{
public:
	// The order of the pages
	// Make sure to change the order the pages are created at the same time
	// you change this
	enum
	{
		Intro,
		AppSharing,
		ULSFirst,
		ULSLast,
		Bandwidth,
		Video,
		Shortcuts,
		AudioFirst,
		Count
	} ;

	static void InitPages()
	{
		// Init to NULL before adding any pages
		for (int i=0; i<Count; ++i)
		{
			g_idWizOrder[i] = 0;
		}
	}

	static void SetPage(UINT nPage, UINT_PTR id)
	{
		g_idWizOrder[nPage] = id;
	}

	static UINT_PTR GetPrevPage(UINT nPageCur)
	{
		if (0 == nPageCur)
		{
			return(0);
		}

		for (int i=nPageCur-1; i>=1; --i)
		{
			if (0 != g_idWizOrder[i])
			{
				break;
			}
		}

		return(g_idWizOrder[i]);
	}

	static UINT_PTR GetNextPage(UINT nPageCur)
	{
		if (Count-1 <= nPageCur)
		{
			return(0);
		}

		for (int i=nPageCur+1; i<Count-1; ++i)
		{
			if (0 != g_idWizOrder[i])
			{
				break;
			}
		}

		return(g_idWizOrder[i]);
	}

	static BOOL HandleWizNotify(HWND hPage, NMHDR *pHdr, UINT nPageCur)
	{
		switch(pHdr->code)
		{
		case PSN_SETACTIVE:
			InitBackNext(hPage, nPageCur);

			if (g_fSilentWizard)
			{
				PropSheet_PressButton(GetParent(hPage), PSBTN_NEXT);
			}
			break;

        case PSN_WIZBACK:
		{
			UINT_PTR iPrev = GetPrevPage(nPageCur);
			SetWindowLongPtr(hPage, DWLP_MSGRESULT, iPrev);
			break;
		}

		case PSN_WIZNEXT:
		{
			UINT_PTR iPrev = GetNextPage(nPageCur);
			SetWindowLongPtr(hPage, DWLP_MSGRESULT, iPrev);
			break;
		}

		default:
			return(FALSE);
		}

		return(TRUE);
	}

private:
	static UINT_PTR g_idWizOrder[Count];

	static void InitBackNext(HWND hPage, UINT nPageCur)
	{
		DWORD dwFlags = 0;

		if (0 != nPageCur && 0 != GetPrevPage(nPageCur))
		{
			dwFlags |= PSWIZB_BACK;
		}

		if (Count-1 != nPageCur && 0 != GetNextPage(nPageCur))
		{
			dwFlags |= PSWIZB_NEXT;
		}
		else
		{
			dwFlags |= PSWIZB_FINISH;
		}

		PropSheet_SetWizButtons(::GetParent(hPage), dwFlags);
	}
} ;

UINT_PTR IntroWiz::g_idWizOrder[Count];

UINT_PTR GetPageBeforeULS()
{
	return(IntroWiz::GetPrevPage(IntroWiz::ULSFirst));
}

UINT_PTR GetPageBeforeVideoWiz()
{
	return(IntroWiz::GetPrevPage(IntroWiz::Video));
}

UINT_PTR GetPageBeforeAudioWiz()
{
	return(IntroWiz::GetPrevPage(IntroWiz::AudioFirst));
}

UINT_PTR GetPageAfterVideo()
{
	return(IntroWiz::GetNextPage(IntroWiz::Video));
}

UINT_PTR GetPageAfterULS()
{
	return(IntroWiz::GetNextPage(IntroWiz::ULSLast));
}

void HideWizard(HWND hwnd)
{
	SetWindowPos(hwnd, NULL, -1000, -1000, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
}

void ShowWizard(HWND hwnd)
{
	CenterWindow(hwnd, HWND_DESKTOP);
	g_fSilentWizard = FALSE;
	PostMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
}


/*  F I L L  I N  P R O P E R T Y  P A G E  */
/*-------------------------------------------------------------------------
    %%Function: FillInPropertyPage

    Fill in the given PROPSHEETPAGE structure.
-------------------------------------------------------------------------*/
VOID FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg,
    DLGPROC pfnDlgProc, LPARAM lParam, LPCTSTR pszProc)
{
	// Clear and set the size of the PROPSHEETPAGE
	InitStruct(psp);

	ASSERT(0 == psp->dwFlags);       // No special flags.
	ASSERT(NULL == psp->pszIcon);    // Don't use a special icon in the caption bar.

	psp->hInstance = ::GetInstanceHandle();
	psp->pszTemplate = MAKEINTRESOURCE(idDlg); // The dialog box template to use.
	psp->pfnDlgProc = pfnDlgProc;    // The dialog procedure that handles this page.
	psp->pszTitle = pszProc;         // The title for this page.
	psp->lParam = lParam;            // Special application-specific data.
}


static const UINT NOVALSpecified = 666;

UINT GetBandwidth()
{
	RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
	return(reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH, NOVALSpecified ));
}

void SetBandwidth(UINT uBandwidth)
{
	RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
	reAudio.SetValue(REGVAL_TYPICALBANDWIDTH, uBandwidth);
}

HRESULT StartRunOnceWizard(LPLONG plSoundCaps, BOOL fForce, BOOL fVisible)
{
	LPPROPSHEETPAGE	pAudioPages = NULL;
	UINT			nNumAudioPages = 0;
	PWIZCONFIG		pAudioConfig;

	CULSWizard*		pIWizard = NULL;
	LPPROPSHEETPAGE	pULSPages = NULL;
	DWORD			dwNumULSPages = 0;
	ULS_CONF*		pulsConf = NULL;
	UINT			uOldBandwidth = 0;
	UINT			uBandwidth = 0;

	int				idAppSharingIntroWiz = 0;
	
	BOOL  fULSWiz     = FALSE;
	BOOL  fAudioWiz   = FALSE;
	BOOL  fVideoWiz   = FALSE;
	BOOL  fVidWizInit = FALSE;
	
    HRESULT         hrRet = E_FAIL;

	g_fSilentWizard = !fVisible;

    ASSERT(plSoundCaps);

	BOOL fNeedUlsWizard = FALSE;
	BOOL fNeedVideoWizard = FALSE;
	BOOL fNeedAudioWizard = NeedAudioWizard(plSoundCaps, fForce);

	if (fNeedAudioWizard)
	{
        if (GetAudioWizardPages(RUNDUE_NEVERBEFORE,
								WAVE_MAPPER,
								&pAudioPages,
								&pAudioConfig,
								&nNumAudioPages))
        {
            fAudioWiz = TRUE;
        }
        else
        {
			ERROR_OUT(("could not get AudioWiz pages"));
        }
	}

	fVidWizInit = InitVidWiz();
	if (fVidWizInit == FALSE)
	{
		fVideoWiz = FALSE;
		WARNING_OUT(("InitVidWiz failed"));
	}
		
	else
	{
		fNeedVideoWizard = NeedVideoPropPage(fForce);
		fVideoWiz = fNeedVideoWizard;
	}


    if (NULL != (pIWizard = new CULSWizard))
	{
		ASSERT (pIWizard);
		// BUGBUG: not checking return value:
		HRESULT hr = pIWizard->GetWizardPages (&pULSPages, &dwNumULSPages, &pulsConf);
		if (SUCCEEDED(hr))
		{
			ASSERT(pulsConf);
			
			TRACE_OUT(("ULS_CONF from UlsGetConfiguration:"));
			TRACE_OUT(("\tdwFlags:       0x%08x", pulsConf->dwFlags));
			TRACE_OUT(("\tszServerName:  >%s<", pulsConf->szServerName));
			TRACE_OUT(("\tszUserName:    >%s<", pulsConf->szUserName));
			TRACE_OUT(("\tszEmailName:   >%s<", pulsConf->szEmailName));

			fNeedUlsWizard = ((pulsConf->dwFlags &
			    (ULSCONF_F_EMAIL_NAME | ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME)) !=
			    (ULSCONF_F_EMAIL_NAME | ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME));

			// Don't bother with the ULS wizard if we have all the information
		    if ((!fForce) && !fNeedUlsWizard)
		    {
			    // We have all of the necessary names
                hrRet = S_OK;
                // release the pages we won't be needing them
        		pIWizard->ReleaseWizardPages (pULSPages);
        		delete pIWizard;
        		pIWizard = NULL;
                dwNumULSPages = 0;
            }
            else
			{
				// some information is not available - we need to run the
				// wizard...
				//SS: if for some reason the user name is not set
				//even though the others are set??
				fULSWiz = TRUE;
				if (::GetDefaultName(pulsConf->szUserName, CCHMAX(pulsConf->szUserName)))
				{
					// We have added a default name, so mark that structure
					// member as valid:
					pulsConf->dwFlags |= ULSCONF_F_USER_NAME;
				}
			}
        }
    }
    else
    {
		ERROR_OUT(("CreateUlsWizardInterface() failed!"));
    }

	// Determine if we need to display the app sharing info page, and if
	// so which one.
	if (::IsWindowsNT() && !g_fNTDisplayDriverEnabled)
	{
		idAppSharingIntroWiz = ::CanInstallNTDisplayDriver()
									? IDD_APPSHARINGWIZ_HAVESP
									: IDD_APPSHARINGWIZ_NEEDSP;
	}

    if ((fULSWiz || fAudioWiz || fVideoWiz))
    {
	    UINT nNumPages = 0;

        // Now fill in remaining PROPSHEETHEADER structures:
	    PROPSHEETHEADER	psh;
	    InitStruct(&psh);
	    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
	    psh.hInstance = ::GetInstanceHandle();
	    ASSERT(0 == psh.nStartPage);

        // alocate enough space for all pages
        DWORD nPages = dwNumULSPages + nNumAudioPages
									 + ( (0 != idAppSharingIntroWiz) ? 1 : 0 )
									 + (fVideoWiz ? 1 : 0)
									 + 2 // intro page & bandwidth page
									 + 1 // shortcuts page
									 ;

        LPPROPSHEETPAGE ppsp = new PROPSHEETPAGE[ nPages ];

	    if (NULL != ppsp)
	    {
			IntroWiz::InitPages();

			BOOL fContinue = TRUE;
		    INTRO_PAGE_CONFIG ipcIntro = { &fContinue, FALSE };
		    INTRO_PAGE_CONFIG ipcAppSharing = { &fContinue, TRUE };

            if (fULSWiz)
		    {
			    // Insert the intro page:

			    FillInPropertyPage(&ppsp[nNumPages++], IDD_INTROWIZ,
                        IntroWiz, (LPARAM) &ipcIntro);

				IntroWiz::SetPage(IntroWiz::Intro, IDD_INTROWIZ);

				// Insert an NT application page, if necessary.  It uses the
				// same dialog proc as the intro page.
				if (0 != idAppSharingIntroWiz)
				{
					FillInPropertyPage(&ppsp[nNumPages++], idAppSharingIntroWiz,
							AppSharingWiz, (LPARAM) &ipcAppSharing);

					IntroWiz::SetPage(IntroWiz::AppSharing, idAppSharingIntroWiz);
				}

			    ASSERT(pulsConf);
			    pulsConf->dwFlags |= (ULSWIZ_F_SHOW_BACK |
						((fAudioWiz || fVideoWiz) ? ULSWIZ_F_NO_FINISH : 0));
			    ::CopyMemory(	&(ppsp[nNumPages]),
							    pULSPages,
							    dwNumULSPages * sizeof(PROPSHEETPAGE));

				IntroWiz::SetPage(IntroWiz::ULSFirst,
					reinterpret_cast<UINT_PTR>(pULSPages[0].pszTemplate));
				IntroWiz::SetPage(IntroWiz::ULSLast,
					reinterpret_cast<UINT_PTR>(pULSPages[dwNumULSPages-1].pszTemplate));
			    nNumPages += dwNumULSPages;

				uBandwidth = uOldBandwidth = GetBandwidth();
				if( NOVALSpecified == uBandwidth )
				{
					FillInPropertyPage(&ppsp[nNumPages++], IDD_BANDWIDTHWIZ,
							BandwidthWiz, (LPARAM) &uBandwidth);
					IntroWiz::SetPage(IntroWiz::Bandwidth, IDD_BANDWIDTHWIZ);
				}
            }

			BOOL fShortcuts = fForce && !g_fSilentWizard;

			if (fVideoWiz)
			{
				LONG button_mask = 0;
				if (fULSWiz == TRUE)
					button_mask |= PSWIZB_BACK;
				if (fShortcuts || fAudioWiz)
					button_mask |= PSWIZB_NEXT;
				else
					button_mask |= PSWIZB_FINISH;
				
				FillInPropertyPage(&ppsp[nNumPages], IDD_VIDWIZ,
	                   VidWizDlg, button_mask, "NetMeeting");
				nNumPages++;
			
				IntroWiz::SetPage(IntroWiz::Video, IDD_VIDWIZ);
			}

			if (fShortcuts)
			{
				FillInPropertyPage(&ppsp[nNumPages], IDD_SHRTCUTWIZ,
					   ShortcutWizDialogProc, 0);
				nNumPages++;

				IntroWiz::SetPage(IntroWiz::Shortcuts, IDD_SHRTCUTWIZ);
			}

		    if (fAudioWiz)
		    {
			     if (fULSWiz || fVideoWiz)
			     {
				     pAudioConfig->uFlags |= STARTWITH_BACK;
			     }
			     ::CopyMemory(	&(ppsp[nNumPages]),
							    pAudioPages,
							    nNumAudioPages * sizeof(PROPSHEETPAGE));
			    nNumPages += nNumAudioPages;
				
				IntroWiz::SetPage(IntroWiz::AudioFirst,
					reinterpret_cast<UINT_PTR>(pAudioPages[0].pszTemplate));
		    }

		    psh.ppsp = ppsp;
            psh.nPages = nNumPages;

			if( !PropertySheet(&psh) )
			{		// User hit CANCEL
        		pIWizard->ReleaseWizardPages (pULSPages);
        		delete pIWizard;
				delete ppsp;
				return S_FALSE;
			}
		
		    delete ppsp;

            if ((FALSE == fContinue) && fULSWiz)
		    {
			    // Clear out the flags, because we don't want to store
			    // any info in the registry (and therefore, we don't want
			    // to run)
			    pulsConf->dwFlags = 0;
		    }
	    }
    }

    if (fULSWiz)
    {
	    if (!(ULSCONF_F_USER_NAME & pulsConf->dwFlags))
	    {
    	    if (::GetDefaultName(pulsConf->szUserName, CCHMAX(pulsConf->szUserName)))
		    {
			    pulsConf->dwFlags |= ULSCONF_F_USER_NAME;
		    }
	    }
	
	    if ((S_OK == pIWizard->SetConfig (pulsConf)) &&
		    (ULSCONF_F_USER_NAME & pulsConf->dwFlags) &&
		    (ULSCONF_F_EMAIL_NAME & pulsConf->dwFlags) &&
		    (ULSCONF_F_FIRST_NAME & pulsConf->dwFlags) &&
		    (ULSCONF_F_LAST_NAME & pulsConf->dwFlags))
	    {
		    // We have all of the necessary names
            hrRet = S_OK;
	    }
        else
        {
		    WARNING_OUT(("Unable to obtain a name!"));
	    }

        TRACE_OUT(("ULS_CONF after running wizard:"));
	    TRACE_OUT(("\tdwFlags:       0x%08x", pulsConf->dwFlags));
	    TRACE_OUT(("\tszServerName:  >%s<", pulsConf->szServerName));
	    TRACE_OUT(("\tszUserName:    >%s<", pulsConf->szUserName));
	    TRACE_OUT(("\tszEmailName:   >%s<", pulsConf->szEmailName));
	
	    pIWizard->ReleaseWizardPages (pULSPages);
	    delete pIWizard;
	    pIWizard = NULL;
    }

	// Display the Splash screen as soon as possible
    if( SUCCEEDED(hrRet) && fForce && fVisible && (NULL == GetConfRoom()))
    {
    	::StartSplashScreen(NULL);
    }


	if (uOldBandwidth != uBandwidth)
	{
		SetBandwidth(uBandwidth);
		SaveDefaultCodecSettings(uBandwidth);
	}

    if (fAudioWiz)
    {
	    AUDIOWIZOUTPUT awo;
	    ReleaseAudioWizardPages(pAudioPages, pAudioConfig, &awo);
	    if (awo.uValid & SOUNDCARDCAPS_CHANGED)
	    {
		    *plSoundCaps = awo.uSoundCardCaps;
	    }
	    else
	    {
		    // The wizard was cancelled, so we should only take the
		    // information that tells us whether or not a sound card
		    // is present.
		    *plSoundCaps = (awo.uSoundCardCaps & SOUNDCARD_PRESENT);
		
		    // Write this value to the registry so that the wizard will not
		    // auto-launch the next time we run:
            RegEntry reSoundCaps(AUDIO_KEY, HKEY_CURRENT_USER);
		    reSoundCaps.SetValue(REGVAL_SOUNDCARDCAPS, *plSoundCaps);
	    }
    }


	// Even if the VidWiz page wasn't shown, we still need to call this
	// function (UpdateVidConfigRegistry) to fix the registry if the video
   // capture device configurations have changed since the last time.
	if (fVidWizInit)
	{
		UpdateVidConfigRegistry();
		UnInitVidWiz();
	}
	g_fSilentWizard = FALSE;

	return hrRet;
}



INT_PTR APIENTRY AppSharingWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
		{
			// Save the lParam information. in DWL_USER
			::SetWindowLongPtr(hDlg, DWLP_USER, ((PROPSHEETPAGE*)lParam)->lParam);
			if (g_fSilentWizard)
			{
				HideWizard(GetParent(hDlg));
			}
			else
			{
				ShowWizard(GetParent(hDlg));
			}

			return TRUE;
		}

		case WM_NOTIFY:
		{
			switch (((NMHDR FAR *) lParam)->code)
			{
				case PSN_SETACTIVE:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);

					DWORD dwFlags = pipc->fAllowBack ? PSWIZB_BACK : 0;
					if( IntroWiz::GetNextPage(IntroWiz::AppSharing) == 0 )
					{
						dwFlags |= PSWIZB_FINISH;						
					}
					else
					{
						dwFlags |= PSWIZB_NEXT;						
					}

					// Initialize the controls.
					PropSheet_SetWizButtons( ::GetParent(hDlg), dwFlags );

					if (g_fSilentWizard)
					{
						PropSheet_PressButton(
							GetParent(hDlg), PSBTN_NEXT);
					}
					break;
				}

				case PSN_KILLACTIVE:
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
					return TRUE;
				}

				case PSN_WIZNEXT:
				{
					UINT_PTR iNext = IntroWiz::GetNextPage(IntroWiz::AppSharing);

					ASSERT( iNext );
					SetWindowLongPtr( hDlg, DWLP_MSGRESULT, iNext );
					return TRUE;
				}

				case PSN_RESET:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);
					*pipc->fContinue = FALSE;
					break;
				}
			}
			break;
		}

	default:
		break;
	}
	return FALSE;
}

INT_PTR APIENTRY IntroWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
		{
			// Save the lParam information. in DWL_USER
			::SetWindowLongPtr(hDlg, DWLP_USER, ((PROPSHEETPAGE*)lParam)->lParam);
			if (g_fSilentWizard)
			{
				HideWizard(GetParent(hDlg));
			}
			else
			{
				ShowWizard(GetParent(hDlg));
			}
			return TRUE;
		}

		case WM_NOTIFY:
		{
			switch (((NMHDR FAR *) lParam)->code)
			{
				case PSN_SETACTIVE:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);

					// Initialize the controls.
					PropSheet_SetWizButtons(
						::GetParent(hDlg),
						PSWIZB_NEXT | (pipc->fAllowBack ? PSWIZB_BACK : 0));

					if (g_fSilentWizard)
					{
						PropSheet_PressButton(
							GetParent(hDlg), PSBTN_NEXT);
					}
					break;
				}

				case PSN_KILLACTIVE:
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
					return TRUE;
				}

				case PSN_WIZNEXT:
				{
					break;
				}

				case PSN_RESET:
				{
					ASSERT(lParam);
					INTRO_PAGE_CONFIG* pipc = (INTRO_PAGE_CONFIG*)
												::GetWindowLongPtr(hDlg, DWLP_USER);
					ASSERT(pipc);
					*pipc->fContinue = FALSE;
					break;
				}
			}
			break;
		}

	default:
		break;
	}
	return FALSE;
}

static void BandwidthWiz_InitDialog(HWND hDlg, UINT uOldBandwidth)
{
	INT idChecked;
	
	//set the initial value
	switch (uOldBandwidth)
	{
		case BW_144KBS:
			idChecked = IDC_RADIO144KBS;
			break;
		case BW_ISDN:
			idChecked = IDC_RADIOISDN;
			break;
		case BW_MOREKBS:
			idChecked = IDC_RADIOMOREKBS;
			break;
		case BW_288KBS:
		default:
			idChecked = IDC_RADIO288KBS;
			break;
	}

	CheckRadioButton(hDlg, IDC_RADIO144KBS, IDC_RADIOISDN, idChecked);
}

static void BandwidthWiz_OK(HWND hDlg, UINT *puBandwidth)
{
	//check the radio button
	if (IsDlgButtonChecked(hDlg,IDC_RADIO144KBS))
	{
		*puBandwidth = BW_144KBS; 						
	}							
	else if (IsDlgButtonChecked(hDlg,IDC_RADIO288KBS))
	{
		*puBandwidth = BW_288KBS; 						
	}							
	else if (IsDlgButtonChecked(hDlg,IDC_RADIOISDN))
	{
		*puBandwidth = BW_ISDN;							
	}							
	else
	{
		*puBandwidth = BW_MOREKBS;							
	}							

//	if (BW_MOREKBS != *puBandwidth)
//	{
//		// disable refresh of speed dials if not on a LAN
//		RegEntry re(UI_KEY, HKEY_CURRENT_USER);
//		re.SetValue(REGVAL_ENABLE_FRIENDS_AUTOREFRESH, (ULONG) 0L);
//	}
}

INT_PTR APIENTRY BandwidthWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE *ps;
	static UINT *puBandwidth;
	static UINT uOldBandwidth;

	switch (message) {
		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			puBandwidth = (UINT*)ps->lParam;
			uOldBandwidth = *puBandwidth;

			BandwidthWiz_InitDialog(hDlg, uOldBandwidth);

			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					// Initialize the controls.
					IntroWiz::HandleWizNotify(hDlg,
						reinterpret_cast<NMHDR*>(lParam), IntroWiz::Bandwidth);
					break;
				}

				case PSN_WIZBACK:
					return(IntroWiz::HandleWizNotify(hDlg,
						reinterpret_cast<NMHDR*>(lParam), IntroWiz::Bandwidth));

				case PSN_WIZFINISH:
				case PSN_WIZNEXT:
				{
					BandwidthWiz_OK(hDlg, puBandwidth);

					return(IntroWiz::HandleWizNotify(hDlg,
						reinterpret_cast<NMHDR*>(lParam), IntroWiz::Bandwidth));
				}

				case PSN_RESET:
					*puBandwidth = uOldBandwidth;
					break;

				default:
					break;													
			}
			break;

		default:
			break;
	}
	return FALSE;
}

static void BandwidthDlg_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
	switch(id)
	{
	case IDOK:
	{
		UINT uBandwidth;
		BandwidthWiz_OK(hDlg, &uBandwidth);
		EndDialog(hDlg, uBandwidth);
		break;
	}

		// Fall through
	case IDCANCEL:
		EndDialog(hDlg, 0);
		break;

	default:
		break;
	}
}

INT_PTR CALLBACK BandwidthDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static const DWORD aContextHelpIds[] = {
		IDC_RADIO144KBS,	IDH_AUDIO_CONNECTION_SPEED,
		IDC_RADIO288KBS,	IDH_AUDIO_CONNECTION_SPEED,
		IDC_RADIOISDN,		IDH_AUDIO_CONNECTION_SPEED,
		IDC_RADIOMOREKBS,	IDH_AUDIO_CONNECTION_SPEED,

		0, 0   // terminator
	};

	switch (message) {
		HANDLE_MSG(hDlg, WM_COMMAND, BandwidthDlg_OnCommand);

	case WM_INITDIALOG:
		BandwidthWiz_InitDialog(hDlg, (UINT)lParam);
		break;

	case WM_CONTEXTMENU:
		DoHelpWhatsThis(wParam, aContextHelpIds);
		break;

	case WM_HELP:
		DoHelp(lParam, aContextHelpIds);
		break;
	
	default:
		return(FALSE);
	}

	return(TRUE);
}


BOOL NeedAudioWizard(LPLONG plSoundCaps, BOOL fForce)
{
	if (_Module.IsSDKCallerRTC() || SysPol::NoAudio())
	{
		WARNING_OUT(("Audio disabled through system policy switch"));
		return FALSE;
	}

	if (fForce)
	{
		return TRUE;
	}


    BOOL fAudioWiz = FALSE;

	RegEntry reSoundCaps(AUDIO_KEY, HKEY_CURRENT_USER);

	// a default that doesn't overlap with real values
	long lCapsNotPresent = 0x7FFFFFFF;

	*plSoundCaps = reSoundCaps.GetNumber(	REGVAL_SOUNDCARDCAPS,
											lCapsNotPresent);

	if (lCapsNotPresent == *plSoundCaps)
	{
		TRACE_OUT(("Missing sound caps - starting calib wizard"));
		fAudioWiz = TRUE;
	}
	else
	{
		if (!ISSOUNDCARDPRESENT(*plSoundCaps))
		{
			if (waveInGetNumDevs() && waveOutGetNumDevs())
				fAudioWiz = TRUE;
		}
		else
		{
			WAVEINCAPS	waveinCaps;
			WAVEOUTCAPS	waveoutCaps;
			
			//if the wavein has changed since last
			if (waveInGetDevCaps(reSoundCaps.GetNumber(REGVAL_WAVEINDEVICEID,WAVE_MAPPER),
				&waveinCaps, sizeof(WAVEINCAPS)) == MMSYSERR_NOERROR)
			{
				//check the name, if changed, run the wizard
				if (lstrcmp(reSoundCaps.GetString(REGVAL_WAVEINDEVICENAME),waveinCaps.szPname))
					fAudioWiz = TRUE;

			}
			else
				fAudioWiz = TRUE;


			//if the waveout has changed since last
			if (waveOutGetDevCaps(reSoundCaps.GetNumber(REGVAL_WAVEOUTDEVICEID,WAVE_MAPPER),
				&waveoutCaps, sizeof(WAVEOUTCAPS)) == MMSYSERR_NOERROR)
			{
				//check the name, if changed, run the wizard
				if (lstrcmp(reSoundCaps.GetString(REGVAL_WAVEOUTDEVICENAME),waveoutCaps.szPname))
					fAudioWiz = TRUE;

			}
			else
				fAudioWiz = TRUE;

		}

	}

    return fAudioWiz;
}


///////////////////////////////////////////////////////
//
// Wizard pages
//

DWORD SetUserPageWizButtons(HWND hDlg, DWORD dwConfFlags)
{
    DWORD dwButtonFlags = PSWIZB_BACK;

    // disable the 'Next' button if not all of first name, last name and email
    // are filled in
    if (!FEmptyDlgItem(hDlg, IDEC_FIRSTNAME) &&
    	!FEmptyDlgItem(hDlg, IDEC_LASTNAME) &&
		!FEmptyDlgItem(hDlg, IDC_USER_EMAIL))
    {
        dwButtonFlags |= (dwConfFlags & ULSWIZ_F_NO_FINISH) ? PSWIZB_NEXT : PSWIZB_FINISH;
    }
    PropSheet_SetWizButtons (GetParent (hDlg), dwButtonFlags);

    return dwButtonFlags;
}

void GetUserPageState(HWND hDlg, ULS_CONF *pConf)
{
    //strip the first name/email name and last name
    TrimDlgItemText(hDlg, IDEC_FIRSTNAME);
    TrimDlgItemText(hDlg, IDEC_LASTNAME);
    TrimDlgItemText(hDlg, IDC_USER_EMAIL);
    TrimDlgItemText(hDlg, IDC_USER_LOCATION);
	TrimDlgItemText(hDlg, IDC_USER_INTERESTS);

    Edit_GetText(GetDlgItem(hDlg, IDEC_FIRSTNAME),
            pConf->szFirstName, MAX_FIRST_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDEC_LASTNAME),
            pConf->szLastName, MAX_LAST_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDC_USER_EMAIL),
            pConf->szEmailName, MAX_EMAIL_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDC_USER_LOCATION),
            pConf->szLocation, MAX_LOCATION_NAME_LENGTH);
    Edit_GetText(GetDlgItem(hDlg, IDC_USER_INTERESTS),
            pConf->szComments, MAX_COMMENTS_LENGTH);

    if (pConf->szFirstName[0]) pConf->dwFlags |= ULSCONF_F_FIRST_NAME;
    if (pConf->szLastName[0]) pConf->dwFlags |= ULSCONF_F_LAST_NAME;
    if (pConf->szEmailName[0]) pConf->dwFlags |= ULSCONF_F_EMAIL_NAME;
    if (pConf->szLocation[0]) pConf->dwFlags |= ULSCONF_F_LOCATION;
    if (pConf->szComments[0]) pConf->dwFlags |= ULSCONF_F_COMMENTS;
}

UINT_PTR GetPageAfterUser()
{
	UINT_PTR iNext = 0;

	if( SysPol::AllowDirectoryServices() )
	{
		iNext = IDD_PAGE_SERVER;
	}
	else
	{	
		iNext = GetPageAfterULS();
	}
	
	return iNext;
}

INT_PTR APIENTRY PageUserDlgProc ( HWND hDlg, UINT uMsg, WPARAM uParam, LPARAM lParam )
{
    ULS_CONF *pConf;
    PROPSHEETPAGE *pPage;
    static DWORD dwWizButtons;

    switch (uMsg)
    {
	
	case WM_DESTROY:
		s_hDlgUserInfo = NULL;
		break;

    case WM_INITDIALOG:
		s_hDlgUserInfo = hDlg;
        pPage = (PROPSHEETPAGE *) lParam;
        pConf = (ULS_CONF *) pPage->lParam;
        SetWindowLongPtr (hDlg, GWLP_USERDATA, lParam);

		// Set the font
		::SendDlgItemMessage(hDlg, IDEC_FIRSTNAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
		::SendDlgItemMessage(hDlg, IDEC_LASTNAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
		::SendDlgItemMessage(hDlg, IDC_USER_LOCATION, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
		::SendDlgItemMessage(hDlg, IDC_USER_INTERESTS, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

		// Limit the text
        Edit_LimitText(GetDlgItem(hDlg, IDEC_FIRSTNAME), MAX_FIRST_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDEC_LASTNAME), MAX_LAST_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_USER_EMAIL), MAX_EMAIL_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_USER_LOCATION), MAX_LOCATION_NAME_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_USER_INTERESTS), UI_COMMENTS_LENGTH - 1);

        if (pConf->dwFlags & ULSCONF_F_FIRST_NAME)
        {
            Edit_SetText(GetDlgItem(hDlg, IDEC_FIRSTNAME), pConf->szFirstName);
        }
        if (pConf->dwFlags & ULSCONF_F_LAST_NAME)
        {
            Edit_SetText(GetDlgItem(hDlg, IDEC_LASTNAME), pConf->szLastName);
        }

        if (pConf->dwFlags & ULSCONF_F_EMAIL_NAME)
        {
            Edit_SetText(GetDlgItem(hDlg, IDC_USER_EMAIL), pConf->szEmailName);
        }
        if (pConf->dwFlags & ULSCONF_F_LOCATION)
        {
            Edit_SetText(GetDlgItem(hDlg, IDC_USER_LOCATION), pConf->szLocation);
        }

#ifdef DEBUG
        if ((0 == (pConf->dwFlags & ULSCONF_F_COMMENTS)) &&
        	(0 == (pConf->dwFlags & ULSCONF_F_EMAIL_NAME)) )
		{
			extern VOID DbgGetComments(LPTSTR);
			DbgGetComments(pConf->szComments);
			pConf->dwFlags |= ULSCONF_F_COMMENTS;
		}
#endif

        if (pConf->dwFlags & ULSCONF_F_COMMENTS)
        {
            Edit_SetText(GetDlgItem (hDlg, IDC_USER_INTERESTS), pConf->szComments);
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID (uParam, lParam))
        {
        case IDEC_FIRSTNAME:
        case IDEC_LASTNAME:
        case IDC_USER_EMAIL:
            if (GET_WM_COMMAND_CMD(uParam,lParam) == EN_CHANGE)
            {
                pPage = (PROPSHEETPAGE *) GetWindowLongPtr (hDlg, GWLP_USERDATA);
                pConf = (ULS_CONF *) pPage->lParam;

                dwWizButtons = SetUserPageWizButtons(hDlg, pConf->dwFlags);
            }
            break;
        }
        break;

    case WM_NOTIFY:
        pPage = (PROPSHEETPAGE *) GetWindowLongPtr (hDlg, GWLP_USERDATA);
        pConf = (ULS_CONF *) pPage->lParam;
        switch (((NMHDR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, FALSE);
            break;
        case PSN_RESET:
            ZeroMemory (pConf, sizeof (ULS_CONF));
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, FALSE);
            break;
        case PSN_SETACTIVE:
            dwWizButtons = SetUserPageWizButtons(hDlg, pConf->dwFlags);
			if (g_fSilentWizard)
			{
				PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
			}
            break;
        case PSN_WIZBACK:
			return(IntroWiz::HandleWizNotify(hDlg,
				reinterpret_cast<NMHDR*>(lParam), IntroWiz::ULSFirst));

		case PSN_WIZNEXT:
		case PSN_WIZFINISH:

			if (!(dwWizButtons & ((PSN_WIZNEXT == ((NMHDR *) lParam)->code) ?
									PSWIZB_NEXT : PSWIZB_FINISH)))
            {
            	// Reject the next/finish button
				ShowWizard(GetParent(hDlg));
				::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
				return TRUE;
			}

            if (!FLegalEmailName(hDlg, IDC_USER_EMAIL))
            {
				ShowWizard(GetParent(hDlg));
				ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGALEMAILNAME);
				SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
				return TRUE;
            }
            GetUserPageState(hDlg, pConf);

			if( PSN_WIZNEXT == (((NMHDR *) lParam)->code) )
			{
				UINT_PTR iNext = GetPageAfterUser();
				ASSERT( iNext );
				SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iNext);
					
				return TRUE;
			}
            break;

        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}


HRESULT CULSWizard::GetWizardPages ( PROPSHEETPAGE **ppPage, ULONG *pcPages, ULS_CONF **ppUlsConf )
{
	const int cULS_Pages = 5;

    PROPSHEETPAGE *pPage = NULL;
	ULONG cPages = 0;
    UINT cbSize = cULS_Pages * sizeof (PROPSHEETPAGE) + sizeof (ULS_CONF);
    ULS_CONF *pConf = NULL;
    HRESULT hr;

    if (ppPage == NULL || pcPages == NULL || ppUlsConf == NULL)
    {
        return E_POINTER;
    }

    pPage = (PROPSHEETPAGE*) LocalAlloc(LPTR, cbSize);
    if (pPage == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pConf = (ULS_CONF *) (((LPBYTE) pPage) +
                               cULS_Pages * sizeof (PROPSHEETPAGE));
    hr = GetConfig (pConf);
    if (hr != S_OK)
    {
    	// REVIEW: GetConfig will never fail, but if it did, pPage would not be released.
        return hr;
    }

#if USE_GAL
	if( !ConfPolicies::IsGetMyInfoFromGALEnabled() ||
	    !ConfPolicies::GetMyInfoFromGALSucceeded() ||
		ConfPolicies::InvalidMyInfo()
	  )
#endif // USE_GAL
	{
	    FillInPropertyPage(&pPage[cPages], IDD_PAGE_USER, PageUserDlgProc, (LPARAM) pConf);
	    cPages++;
	}


	m_WizDirectCallingSettings.SetULS_CONF( pConf );

	FillInPropertyPage( &pPage[cPages++],
						IDD_PAGE_SERVER,
						CWizDirectCallingSettings::StaticDlgProc,
						reinterpret_cast<LPARAM>(&m_WizDirectCallingSettings)
					  );

    *ppPage = pPage;
	*pcPages = cPages;
	*ppUlsConf = pConf;

    return S_OK;
}


HRESULT CULSWizard::ReleaseWizardPages ( PROPSHEETPAGE *pPage)
{
    LocalFree(pPage);

    return S_OK;
}



HRESULT CULSWizard::GetConfig ( ULS_CONF *pConf )
{
    HRESULT hr = E_POINTER;

	if (NULL != pConf)
	{
		::ZeroMemory (pConf, sizeof (ULS_CONF));
		// always return these as valid
	    pConf->dwFlags = ULSCONF_F_SERVER_NAME | ULSCONF_F_PUBLISH;
	    RegEntry reULS(g_szClientFld, HKEY_CURRENT_USER);
		// BUGBUG: ChrisPi - this was a bad idea - lstrcpyn() returns NULL on failure!
		if (_T('\0') != *(lstrcpyn(	pConf->szEmailName,
									reULS.GetString(g_szEmailName),
									CCHMAX(pConf->szEmailName))))
		{
			pConf->dwFlags |= ULSCONF_F_EMAIL_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szFirstName,
						reULS.GetString(g_szFirstName),
						CCHMAX(pConf->szFirstName))))
		{
			pConf->dwFlags |= ULSCONF_F_FIRST_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szLastName,
						reULS.GetString(g_szLastName),
						CCHMAX(pConf->szLastName))))
		{
			pConf->dwFlags |= ULSCONF_F_LAST_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szLocation,
						reULS.GetString(g_szLocation),
						CCHMAX(pConf->szLocation))))
		{
			pConf->dwFlags |= ULSCONF_F_LOCATION;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szUserName,
						reULS.GetString(g_szUserName),
						CCHMAX(pConf->szUserName))))
		{
			pConf->dwFlags |= ULSCONF_F_USER_NAME;
		}
		if (_T('\0') != *(lstrcpyn(	pConf->szComments,
						reULS.GetString(g_szComments),
						CCHMAX(pConf->szComments))))
		{
			pConf->dwFlags |= ULSCONF_F_COMMENTS;
		}
		
		if (!_Module.IsSDKCallerRTC())
		{
			lstrcpyn( pConf->szServerName, CDirectoryManager::get_defaultServer(), CCHMAX( pConf->szServerName ) );
		}
		else
		{
			lstrcpyn( pConf->szServerName, _T(" "), CCHMAX( pConf->szServerName ) );
		}

		pConf->fDontPublish = reULS.GetNumber(g_szDontPublish,
										REGVAL_ULS_DONT_PUBLISH_DEFAULT);
		pConf->dwFlags |= ULSCONF_F_PUBLISH;
		hr = S_OK;
	}
	
	return hr;
}


// FUTURE: Use CombineNames
static BOOL CheckForNames(ULS_CONF *pConf)
{
	// only care if one of first name, last name, email address is missing
	if ((pConf->dwFlags & ULSCONF_F_FIRST_NAME) &&
		(pConf->dwFlags & ULSCONF_F_LAST_NAME) &&
		(pConf->dwFlags & ULSCONF_F_EMAIL_NAME))
	{
		return TRUE;
	}

	if ((pConf->dwFlags & ULSCONF_F_FIRST_NAME) || (pConf->dwFlags & ULSCONF_F_LAST_NAME))
	//set the user name too
	{
		TCHAR	szSource[128];
		TCHAR	*argw[2];

		argw[0] = pConf->szFirstName;
		argw[1] = pConf->szLastName;
		
        LoadString (GetInstanceHandle(), IDS_NAME_ORDER, szSource, sizeof(szSource)/sizeof(TCHAR));
		FormatMessage(FORMAT_MESSAGE_ARGUMENT_ARRAY|FORMAT_MESSAGE_FROM_STRING,szSource,
			0,0,pConf->szUserName, sizeof(pConf->szUserName),(va_list *)argw );

		//truncate at 47 character
		pConf->szUserName[47] = TEXT('\0');
		pConf->dwFlags |= ULSCONF_F_USER_NAME;
	}

	return TRUE;
}


/*  S E T  C O N F I G  */
/*-------------------------------------------------------------------------
    %%Function: SetConfig

-------------------------------------------------------------------------*/
HRESULT CULSWizard::SetConfig ( ULS_CONF *pConf )
{
	if (pConf->dwFlags == 0)
	{
		// nothing to set value
		return S_OK;
	}

	if ((pConf->dwFlags & ULSCONF_F_EMAIL_NAME) &&
		(!FLegalEmailSz(pConf->szEmailName)) )
	{
		// email name must be legal
		return E_INVALIDARG;
	}

	RegEntry re(g_szClientFld);

	if (pConf->dwFlags & ULSCONF_F_PUBLISH)
	{
		re.SetValue(g_szDontPublish, (LONG) pConf->fDontPublish);
	}

	if (pConf->dwFlags & ULSCONF_F_EMAIL_NAME)
	{
		re.SetValue(g_szEmailName, pConf->szEmailName);
	}

	if (pConf->dwFlags & ULSCONF_F_FIRST_NAME)
	{
		re.SetValue(g_szFirstName, pConf->szFirstName);
	}

    if (pConf->dwFlags & ULSCONF_F_LAST_NAME)
    {
		re.SetValue(g_szLastName, pConf->szLastName);
	}
	
	if (pConf->dwFlags & ULSCONF_F_LOCATION)
	{
		re.SetValue(g_szLocation, pConf->szLocation);
	}
	
	if (pConf->dwFlags & ULSCONF_F_COMMENTS)
	{
		re.SetValue(g_szComments, pConf->szComments);
	}

	if (pConf->dwFlags & ULSCONF_F_SERVER_NAME)
	{
		CDirectoryManager::set_defaultServer( pConf->szServerName );
	}

	//SS:may be oprah should do this and store it as their own key
    if ((pConf->dwFlags & ULSCONF_F_FIRST_NAME) || (pConf->dwFlags & ULSCONF_F_LAST_NAME))
    {
		ULS_CONF ulcExisting;
		if ((ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME) !=
			(pConf->dwFlags & (ULSCONF_F_FIRST_NAME | ULSCONF_F_LAST_NAME)) )
		{
			// If only one of these fields is being set, load the previous config:
			GetConfig(&ulcExisting);
		}

		CombineNames(pConf->szUserName, MAX_DCL_NAME_LEN,
			 (pConf->dwFlags & ULSCONF_F_FIRST_NAME) ?
					pConf->szFirstName : ulcExisting.szFirstName,
			(pConf->dwFlags & ULSCONF_F_LAST_NAME) ?
					pConf->szLastName : ulcExisting.szLastName);

		pConf->dwFlags |= ULSCONF_F_USER_NAME;
		re.SetValue(g_szUserName, pConf->szUserName);
    }

    if ((pConf->dwFlags & ULSCONF_F_SERVER_NAME) || (pConf->dwFlags & ULSCONF_F_EMAIL_NAME))
    {
		TCHAR szTemp[MAX_SERVER_NAME_LENGTH + MAX_EMAIL_NAME_LENGTH + 6];

		ULS_CONF ulcExisting;
		if ((ULSCONF_F_SERVER_NAME | ULSCONF_F_EMAIL_NAME) !=
			(pConf->dwFlags & (ULSCONF_F_SERVER_NAME | ULSCONF_F_EMAIL_NAME)))
		{
			// If only one of these fields is being set, load the previous config:
			GetConfig(&ulcExisting);
		}

		FCreateIlsName(szTemp,
			(pConf->dwFlags & ULSCONF_F_SERVER_NAME) ?
						pConf->szServerName : ulcExisting.szServerName,
			(pConf->dwFlags & ULSCONF_F_EMAIL_NAME) ?
						pConf->szEmailName : ulcExisting.szEmailName,
					CCHMAX(szTemp));

    	re.SetValue(g_szResolveName, szTemp);
    }


	// Generate a cert based on the entered information for secure calls
	// ...make sure all fields we care about are valid first
	#define ULSCONF_F_IDFIELDS (ULSCONF_F_FIRST_NAME|ULSCONF_F_LAST_NAME|\
					ULSCONF_F_EMAIL_NAME)

	if ((pConf->dwFlags & ULSCONF_F_IDFIELDS ) == ULSCONF_F_IDFIELDS)
	{
        //
        // LAURABU BUGBUG:
        // If we can't make a cert (France?) or have wrong SCHANNEL or
        // buggy crypto or unrecognized provider, can we propagate that info
        // and act like security is diabled (not available)?
        //
        // How/can we make a common "security not possible" setting we
        // can use.
        //
        MakeCertWrap(pConf->szFirstName, pConf->szLastName,
		    pConf->szEmailName,	0);

        //
        // LAURABU BOGUS!
        // Only do this when RDS is installed.  And just ONCE.
        //

		// Now make a local machine cert for RDS
		CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
		DWORD cbComputerName = sizeof(szComputerName);
		if (GetComputerName(szComputerName, &cbComputerName))
		{
			MakeCertWrap(szComputerName, NULL, NULL, NMMKCERT_F_LOCAL_MACHINE);
		}
		else
		{
			ERROR_OUT(("GetComputerName failed: %x", GetLastError()));
		}
	}

	return S_OK;
}



bool IsLegalGatewaySz(LPCTSTR szServer)
{
	bool bRet = false;
	
	if( szServer && szServer[0] )
	{
		bRet = true;
	}
	
	return bRet;		
}

bool IsLegalGateKeeperServerSz(LPCTSTR szServer)
{
	
	bool bRet = false;
	
	if( szServer && szServer[0] )
	{
		bRet = true;
	}
	
	return bRet;		
}

bool IsLegalE164Number(LPCTSTR szPhone)
{
	
	if( (NULL == szPhone) || (0 == szPhone[0]) )
	{
		return false;
	}

	// assume a legal phone number is anything with at least 1
	// digit, *,or #.  Anything else will be considered the user's
	// own pretty print formatting (e.g. "876-5309")

	// the bad chars will get filtered out later

	while (*szPhone)
	{
		if ( ((*szPhone >= '0') && (*szPhone <= '9')) ||
		     ((*szPhone == '#') || (*szPhone == '*')) )
		{
			return true;
		}
		szPhone++;
	}
	
	return false;
}


/*  F  L E G A L  E M A I L  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailSz

    A legal email name contains only ANSI characters.
	"a-z, A-Z, numbers 0-9 and some common symbols"
	It cannot include extended characters or < > ( ) /
-------------------------------------------------------------------------*/
BOOL FLegalEmailSz(PTSTR pszName)
{
    if (IS_EMPTY_STRING(pszName))
    	return FALSE;

    for ( ; ; )
    {
		UINT ch = (UINT) ((*pszName++) & 0x00FF);
		if (0 == ch)
			break;

		switch (ch)
			{
		default:
			if ((ch > (UINT) _T(' ')) && (ch <= (UINT) _T('~')) )
				break;
		// else fall thru to error code
		case '(': case ')':
		case '<': case '>':
		case '[': case ']':
		case '/': case '\\':
		case ':': case ';':
		case '+':
		case '=':
		case ',':
		case '\"':
			WARNING_OUT(("FLegalEmailSz: Invalid character '%s' (0x%02X)", &ch, ch));
			return FALSE;
			}
	}

	return TRUE;
}


/*  F  L E G A L  E M A I L  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailName

-------------------------------------------------------------------------*/
BOOL FLegalEmailName(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	
	GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz));
	return FLegalEmailSz(sz);
}


/*  F I L L  S E R V E R  C O M B O  B O X  */
/*-------------------------------------------------------------------------
    %%Function: FillServerComboBox

-------------------------------------------------------------------------*/
VOID FillServerComboBox(HWND hwndCombo)
{
	CMRUList	MRUList;

	MRUList.Load( DIR_MRU_KEY );

	const TCHAR * const	pszDomainDirectory	= CDirectoryManager::get_DomainDirectory();

	if( pszDomainDirectory != NULL )
	{
		//	Make sure the configured domain server name is in the list...
		MRUList.AppendEntry( pszDomainDirectory );
	}

	if( CDirectoryManager::isWebDirectoryEnabled() )
	{
		//	Make sure the web directory is in the list...
		MRUList.AppendEntry( CDirectoryManager::get_webDirectoryIls() );
	}

	const TCHAR * const	defaultServer	= CDirectoryManager::get_defaultServer();

	if( lstrlen( defaultServer ) > 0 )
	{
		//	Make sure the default server name is in the list and at the top...
		MRUList.AddNewEntry( defaultServer );
	}

	::SendMessage( hwndCombo, WM_SETREDRAW, FALSE, 0 );
	::SendMessage( hwndCombo, CB_RESETCONTENT, 0, 0 );

	int nCount = MRUList.GetNumEntries();

	for( int nn = MRUList.GetNumEntries() - 1; nn >= 0; nn-- )
	{
		::SendMessage( hwndCombo, CB_ADDSTRING, 0, (LPARAM) CDirectoryManager::get_displayName( MRUList.GetNameEntry( nn ) ) );
	}

	::SendMessage( hwndCombo, WM_SETREDRAW, TRUE, 0 );

}	//	End of FillServerComboBox.


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// CWizDirectCallingSettings wizard page
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/* static */ HWND CWizDirectCallingSettings::s_hDlg;

INT_PTR CWizDirectCallingSettings::StaticDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	INT_PTR bRet = FALSE;

	if ( message == WM_INITDIALOG )
	{
		PROPSHEETPAGE* pPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
		SetWindowLongPtr( hDlg, GWLP_USERDATA, pPage->lParam );

		s_hDlg = hDlg;
		CWizDirectCallingSettings* pThis = reinterpret_cast<CWizDirectCallingSettings*>(pPage->lParam);
		if( pThis )
		{
			bRet = pThis->_OnInitDialog();
		}

	}
	else
	{
		CWizDirectCallingSettings* pThis = reinterpret_cast<CWizDirectCallingSettings*>( GetWindowLongPtr( hDlg, GWLP_USERDATA ) );
		if( pThis )
		{
			bRet = pThis->_DlgProc(hDlg, message, wParam, lParam );
		}
	}

	return bRet;
}

/* static */ void CWizDirectCallingSettings::OnWizFinish()
{
	if( s_hDlg && IsWindow( s_hDlg ) )
	{
		CWizDirectCallingSettings* pThis = reinterpret_cast<CWizDirectCallingSettings*>( GetWindowLongPtr( s_hDlg, GWLP_USERDATA ) );
		if( pThis )
		{
			pThis->_OnWizFinish();
		}
	}
}


INT_PTR APIENTRY CWizDirectCallingSettings::_DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;

	switch( message )
	{
		case WM_DESTROY:
			s_hDlg = NULL;
			break;

		case WM_NOTIFY:
		{
			NMHDR* pNmHdr = reinterpret_cast<NMHDR*>(lParam);
			switch(pNmHdr->code)
			{
				case PSN_SETACTIVE:		return _OnSetActive();
				case PSN_KILLACTIVE:	return _OnKillActive();
				case PSN_WIZBACK:		return _OnWizBack();
				case PSN_WIZNEXT:		bRet = _OnWizNext();

							// We fall through from the WIZ_NEXT becaus
							// we have to save the informaition when we change
							// pages
				case PSN_APPLY:
				case PSN_WIZFINISH:		_OnWizFinish();

			}
			break;
		}

		case WM_COMMAND:
			return _OnCommand(wParam, lParam);

		default:
			break;

	}
	return bRet;
}


/* static */ bool CWizDirectCallingSettings::IsGatewayNameInvalid()
{
	TCHAR szServer[MAX_SERVER_NAME_LENGTH];
	szServer[0] = NULL;

	if( s_hDlg )
	{
		GetDlgItemTextTrimmed(s_hDlg, IDE_CALLOPT_GW_SERVER, szServer, CCHMAX(szServer) );
	}
	else
	{
		GetDefaultGateway( szServer, CCHMAX( szServer ) );
	}

	return !IsLegalGatewaySz(szServer);
}

void CWizDirectCallingSettings::_SetWizButtons()
{
	DWORD dwFlags = NULL;
	
	if( ( BST_CHECKED == IsDlgButtonChecked( s_hDlg, IDC_CHECK_USE_GATEWAY ) ) && IsGatewayNameInvalid() )
	{
		dwFlags = PSWIZB_BACK;
	}
	else
	{
		dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
	}

	if( 0 == GetPageAfterULS() )
	{
		dwFlags |= PSWIZB_FINISH;
	}
	else
	{
		dwFlags |= PSWIZB_NEXT;
	}

	PropSheet_SetWizButtons( GetParent( s_hDlg ), dwFlags );
}

BOOL CWizDirectCallingSettings::_OnCommand( WPARAM wParam, LPARAM lParam )
{
	BOOL bRet = TRUE;

	switch( LOWORD( wParam ) )
	{
		case IDC_CHECK_USE_GATEWAY:
		{
			bool bEnable = ( BST_CHECKED == IsDlgButtonChecked( s_hDlg, IDC_CHECK_USE_GATEWAY ) );
			EnableWindow( GetDlgItem( s_hDlg, IDC_STATIC_GATEWAY_NAME ), bEnable );
			EnableWindow( GetDlgItem( s_hDlg, IDE_CALLOPT_GW_SERVER ), bEnable );
			_SetWizButtons();
		}
		break;

		case IDE_CALLOPT_GW_SERVER:
			if( HIWORD( wParam ) == EN_CHANGE )
			{		
				_SetWizButtons();
			}
			break;

		default:			
			break;
	}

	return bRet;
}


BOOL CWizDirectCallingSettings::_OnInitDialog()
{
	BOOL bRet = TRUE;

	_SetWizButtons();

	InitDirectoryServicesDlgInfo( s_hDlg, m_pWiz, m_bInitialEnableGateway, m_szInitialServerName, CCHMAX(m_szInitialServerName) );

	return bRet;
}


BOOL CWizDirectCallingSettings::_OnSetActive()
{
	_SetWizButtons();

	if (g_fSilentWizard)
	{
		PropSheet_PressButton(GetParent(s_hDlg), PSBTN_NEXT);
	}

	return FALSE;
}

BOOL CWizDirectCallingSettings::_OnKillActive()
{
	return FALSE;
}

BOOL CWizDirectCallingSettings::_OnWizBack()
{
	UINT iPrev = IDD_PAGE_USER;

#if USE_GAL
	if( !ConfPolicies::IsGetMyInfoFromGALEnabled() )
	{
		iPrev = IDD_PAGE_USER;
	}
	else
	{
		iPrev = GetPageBeforeULS();
	}
#endif
		
	ASSERT( iPrev );
	SetWindowLongPtr( s_hDlg, DWLP_MSGRESULT, iPrev );
	return TRUE;
}

BOOL CWizDirectCallingSettings::_OnWizFinish()
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	m_pConf->dwFlags |= ULSCONF_F_PUBLISH | ULSCONF_F_SERVER_NAME;

	// Get the server name
	SendDlgItemMessage( s_hDlg, IDC_NAMESERVER, WM_GETTEXT, CCHMAX( m_pConf->szServerName ), (LPARAM) m_pConf->szServerName );
	TrimSz( m_pConf->szServerName );

	lstrcpyn( m_pConf->szServerName, CDirectoryManager::get_dnsName( m_pConf->szServerName ), CCHMAX( m_pConf->szServerName ) );

		// Get the don't publish flags			
	m_pConf->fDontPublish = ( BST_CHECKED == IsDlgButtonChecked( s_hDlg, IDC_USER_PUBLISH ) );

	reConf.SetValue(REGVAL_DONT_LOGON_ULS, BST_CHECKED != IsDlgButtonChecked( s_hDlg, IDC_USEULS ));

	return FALSE;
}

BOOL CWizDirectCallingSettings::_OnWizNext()
{

	UINT_PTR iNext = GetPageAfterULS();
	ASSERT( iNext );
	SetWindowLongPtr( s_hDlg, DWLP_MSGRESULT, iNext );
	return TRUE;
}

// Taken from MSDN:
static HRESULT CreateLink(LPCSTR lpszPathObj,
    LPCTSTR lpszPathLink, LPCSTR lpszDesc)
{
    HRESULT hres;
    IShellLink* psl;

    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, IID_IShellLink, reinterpret_cast<LPVOID *>(&psl));
    if (SUCCEEDED(hres)) {
        IPersistFile* ppf;

        // Set the path to the shortcut target and add the
        // description.
        psl->SetPath(lpszPathObj);
        if (NULL != lpszDesc)
        {
        	psl->SetDescription(lpszDesc);
        }

       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
        hres = psl->QueryInterface(IID_IPersistFile,
            reinterpret_cast<LPVOID *>(&ppf));

        if (SUCCEEDED(hres)) {
#ifndef UNICODE
            WCHAR wsz[MAX_PATH];

            // Ensure that the string is ANSI.
            MultiByteToWideChar(CP_ACP, 0, lpszPathLink, -1,
                wsz, MAX_PATH);
#else // UNICODE
			LPCWSTR wsz = lpszPathLink;
#endif // UNICODE

            // Save the link by calling IPersistFile::Save.
            hres = ppf->Save(wsz, TRUE);
            ppf->Release();
        }
        psl->Release();
    }
    return hres;
}

void DeleteShortcut(int csidl, LPCTSTR pszSubDir)
{
	TCHAR szSpecial[MAX_PATH];
	if (!NMGetSpecialFolderPath(NULL, szSpecial, csidl, TRUE))
	{
		return;
	}

	LPCTSTR pszNetMtg = RES2T(IDS_MEDIAPHONE_TITLE);

	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, TEXT("%s%s\\%s.lnk"), szSpecial, pszSubDir, pszNetMtg);
	DeleteFile(szPath);
}

static void CreateShortcut(HWND hDlg, int csidl, LPCTSTR pszSubDir)
{
	TCHAR szSpecial[MAX_PATH];
	if (!NMGetSpecialFolderPath(hDlg, szSpecial, csidl, TRUE))
	{
		return;
	}

	LPCTSTR pszNetMtg = RES2T(IDS_MEDIAPHONE_TITLE);

	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, TEXT("%s%s\\%s.lnk"), szSpecial, pszSubDir, pszNetMtg);

	char szThis[MAX_PATH];
	GetModuleFileNameA(NULL, szThis, ARRAY_ELEMENTS(szThis));

	CreateLink(szThis, szPath, NULL);
}

INT_PTR CALLBACK ShortcutWizDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_INITDIALOG:
		CheckDlgButton(hDlg, IDC_ONDESKTOP, BST_CHECKED);
		CheckDlgButton(hDlg, IDC_ONQUICKLAUNCH, BST_CHECKED);
		break;

	case WM_DESTROY:
		if (IsDlgButtonChecked(hDlg, IDC_ONDESKTOP))
		{
			CreateShortcut(hDlg, CSIDL_DESKTOP, g_szEmpty);
		}
		if (IsDlgButtonChecked(hDlg, IDC_ONQUICKLAUNCH))
		{
			CreateShortcut(hDlg, CSIDL_APPDATA, QUICK_LAUNCH_SUBDIR);
		}
		break;

	case WM_NOTIFY:
	{
		NMHDR* pNmHdr = reinterpret_cast<NMHDR*>(lParam);
		switch(pNmHdr->code)
		{
		case PSN_RESET:
			// HACKHACK georgep: Uncheck the buttons so we will not try to
			// create the shortcuts
			CheckDlgButton(hDlg, IDC_ONDESKTOP, BST_UNCHECKED);
			CheckDlgButton(hDlg, IDC_ONQUICKLAUNCH, BST_UNCHECKED);

			// Fall through
		default:
			return(IntroWiz::HandleWizNotify(hDlg, pNmHdr, IntroWiz::Shortcuts));
		}
		break;
	}

	default:
		return(FALSE);
	}

	return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\waveio.cpp ===
// File: waveio.cpp

#include "precomp.h"
#include "waveio.h"



//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  waveio.c
//
//  Description:
//      Contains routines for opening and closing RIFF WAVE files.
//
//
//==========================================================================;




//--------------------------------------------------------------------------;
//  
//  WIOERR wioFileClose
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEIOCB pwio:
//  
//      DWORD fdwClose:
//  
//  Return (WIOERR):
//  
//--------------------------------------------------------------------------;

WIOERR WIOAPI wioFileClose
(
    LPWAVEIOCB      pwio,
    DWORD           fdwClose
)
{
    //
    //  validate a couple of things...
    //
    if (NULL == pwio)
        return (WIOERR_BADPARAM);


    //
    //  get rid of stuff...
    //
//  wioStopWave(pwio);
    
    if (NULL != pwio->hmmio)
    {
        mmioClose(pwio->hmmio, 0);
    }
    
//  FreeWaveHeaders(lpwio);

#if 0
    if (pwio->pInfo)
        riffFreeINFO(&(lpwio->pInfo));
    
    if (pwio->pDisp)
        riffFreeDISP(&(lpwio->pDisp));
#endif

    if (NULL != pwio->pwfx)
        GlobalFreePtr(pwio->pwfx);

    _fmemset(pwio, 0, sizeof(*pwio));

    return (WIOERR_NOERROR);
} // wioFileClose()


//--------------------------------------------------------------------------;
//  
//  WIOERR wioFileOpen
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEIOCB pwio:
//  
//      LPCTSTR pszFilePath:
//  
//      DWORD fdwOpen:
//  
//  Return (WIOERR):
//  
//  
//--------------------------------------------------------------------------;

WIOERR WIOAPI wioFileOpen
(
    LPWAVEIOCB      pwio,
    LPCTSTR         pszFilePath,
    DWORD           fdwOpen
)
{
    WIOERR      werr;
    HMMIO       hmmio;
    MMCKINFO    ckRIFF;
    MMCKINFO    ck;
    DWORD       dw;

    //
    //  validate a couple of things...
    //
    if (NULL == pwio)
        return (WIOERR_BADPARAM);

    //
    //  default our error return (assume the worst)
    //
    _fmemset(pwio, 0, sizeof(*pwio));
    werr = WIOERR_FILEERROR;

    pwio->dwFlags   = fdwOpen;

    //
    //  first try to open the file, etc.. open the given file for reading
    //  using buffered I/O
    //
    hmmio = mmioOpen((LPTSTR)pszFilePath, NULL, MMIO_READ | MMIO_ALLOCBUF);
    if (NULL == hmmio)
        goto wio_Open_Error;

    pwio->hmmio     = hmmio;


    //
    //  locate a 'WAVE' form type...
    //
    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    if (mmioDescend(hmmio, &ckRIFF, NULL, MMIO_FINDRIFF))
        goto wio_Open_Error;

    //
    //  we found a WAVE chunk--now go through and get all subchunks that
    //  we know how to deal with...
    //
    pwio->dwDataSamples = (DWORD)-1L;

#if 0
    if (lrt=riffInitINFO(&wio.pInfo))
    {
        lr=lrt;
        goto wio_Open_Error;
    }
#endif

    //
    //
    //
    while (MMSYSERR_NOERROR == mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        //
        //  quickly check for corrupt RIFF file--don't ascend past end!
        //
        if ((ck.dwDataOffset + ck.cksize) > (ckRIFF.dwDataOffset + ckRIFF.cksize))
        {
//				TCHAR       ach[255];
//            wsprintf(ach, TEXT("This wave file might be corrupt. The RIFF chunk.ckid '%.08lX' (data offset at %lu) specifies a cksize of %lu that extends beyond what the RIFF header cksize of %lu allows. Attempt to load?"),
//                     ck.ckid, ck.dwDataOffset, ck.cksize, ckRIFF.cksize);
//            u = MessageBox(NULL, ach, TEXT("wioFileOpen"),
//                           MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL);
//            if (IDNO == u)
//            {
                werr = WIOERR_BADFILE;
                goto wio_Open_Error;
//            }
        }

        switch (ck.ckid)
        {
            case mmioFOURCC('L', 'I', 'S', 'T'):
                if (ck.fccType == mmioFOURCC('I', 'N', 'F', 'O'))
                {
#if 0
                    if(lrt=riffReadINFO(hmmio, &ck, wio.pInfo))
                    {
                        lr=lrt;
                        goto wio_Open_Error;
                    }
#endif
                }
                break;
                
            case mmioFOURCC('D', 'I', 'S', 'P'):
#if 0
                riffReadDISP(hmmio, &ck, &(wio.pDisp));
#endif
                break;
                
            case mmioFOURCC('f', 'm', 't', ' '):
                //
                //  !?! another format chunk !?!
                //
                if (NULL != pwio->pwfx)
                    break;

                //
                //  get size of the format chunk, allocate and lock memory
                //  for it. we always alloc a complete extended format header
                //  (even for PCM headers that do not have the cbSize field
                //  defined--we just set it to zero).
                //
                dw = ck.cksize;
                if (dw < sizeof(WAVEFORMATEX))
                    dw = sizeof(WAVEFORMATEX);

                pwio->pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, dw);
                if (NULL == pwio->pwfx)
                {
                    werr = WIOERR_NOMEM;
                    goto wio_Open_Error;
                }

                //
                //  read the format chunk
                //
                werr = WIOERR_FILEERROR;
                dw = ck.cksize;
                if (mmioRead(hmmio, (HPSTR)pwio->pwfx, dw) != (LONG)dw)
                    goto wio_Open_Error;
                break;


            case mmioFOURCC('d', 'a', 't', 'a'):
                //
                //  !?! multiple data chunks !?!
                //
                if (0L != pwio->dwDataBytes)
                    break;

                //
                //  just hang on to the total length in bytes of this data
                //  chunk.. and the offset to the start of the data
                //
                pwio->dwDataBytes  = ck.cksize;
                pwio->dwDataOffset = ck.dwDataOffset;
                break;


            case mmioFOURCC('f', 'a', 'c', 't'):
                //
                //  !?! multiple fact chunks !?!
                //
                if (-1L != pwio->dwDataSamples)
                    break;

                //
                //  read the first dword in the fact chunk--it's the only
                //  info we need (and is currently the only info defined for
                //  the fact chunk...)
                //
                //  if this fails, dwDataSamples will remain -1 so we will
                //  deal with it later...
                //
                mmioRead(hmmio, (HPSTR)&pwio->dwDataSamples, sizeof(DWORD));
                break;
        }

        //
        //  step up to prepare for next chunk..
        //
        mmioAscend(hmmio, &ck, 0);
    }

    //
    //  if no fmt chunk was found, then die!
    //
    if (NULL == pwio->pwfx)
    {
        werr = WIOERR_ERROR;
        goto wio_Open_Error;
    }

    //
    //  all wave files other than PCM are _REQUIRED_ to have a fact chunk
    //  telling the number of samples that are contained in the file. it
    //  is optional for PCM (and if not present, we compute it here).
    //
    //  if the file is not PCM and the fact chunk is not found, then fail!
    //
    if (-1L == pwio->dwDataSamples)
    {
        if (WAVE_FORMAT_PCM == pwio->pwfx->wFormatTag)
        {
            pwio->dwDataSamples = pwio->dwDataBytes / pwio->pwfx->nBlockAlign;
        }
        else
        {
            //
            //  !!! HACK HACK HACK !!!
            //
            //  although this should be considered an invalid wave file, we
            //  will bring up a message box describing the error--hopefully
            //  people will start realizing that something is missing???
            //
//            u = MessageBox(NULL, TEXT("This wave file does not have a 'fact' chunk and requires one! This is completely invalid and MUST be fixed! Attempt to load it anyway?"),
//                           TEXT("wioFileOpen"), MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL);
//            if (IDNO == u)
//            {
                werr = WIOERR_BADFILE;
                goto wio_Open_Error;
//            }

            //
            //  !!! need to hack stuff in here !!!
            //
            pwio->dwDataSamples = 0L;
        }
    }

    //
    //  cool! no problems.. 
    //
    return (WIOERR_NOERROR);


    //
    //  return error (after minor cleanup)
    //
wio_Open_Error:

    wioFileClose(pwio, 0L);
    return (werr);
} // wioFileOpen()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\waveio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  waveio.h
//
//  Description:
//      Contains structure definitions and prototypes for the functions in
//      waveio.c.  Also contains Win16/Win32 portability definitions.
//
//
//==========================================================================;

#ifndef _INC_WAVEIO
#define _INC_WAVEIO                 // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifdef WIN32
    //
    //  for compiling Unicode
    //
    #ifndef SIZEOF
    #ifdef UNICODE
        #define SIZEOF(x)       (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)       sizeof(x)
    #endif
    #endif
#else
    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef TEXT
    #define TEXT(a)             a
    #endif

    #ifndef SIZEOF
    #define SIZEOF(x)           sizeof(x)
    #endif

    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif
#endif


//
//
//
//
//
#ifdef WIN32
    #define WIOAPI      _stdcall
#else
#ifdef _WINDLL
    #define WIOAPI      FAR PASCAL _loadds
#else
    #define WIOAPI      FAR PASCAL
#endif
#endif


//
//
//
typedef UINT        WIOERR;


//
//
//
//
typedef struct tWAVEIOCB
{
    DWORD           dwFlags;
    HMMIO           hmmio;

    DWORD           dwDataOffset;
    DWORD           dwDataBytes;
    DWORD           dwDataSamples;

    LPWAVEFORMATEX  pwfx;

#if 0
    HWAVEOUT        hwo;
    DWORD           dwBytesLeft;
    DWORD           dwBytesPerBuffer;
    
    DISP FAR *      pDisp;
    INFOCHUNK FAR * pInfo;
#endif

} WAVEIOCB, *PWAVEIOCB, FAR *LPWAVEIOCB;



//
//  error returns from waveio functions
//
#define WIOERR_BASE             (0)
#define WIOERR_NOERROR          (0)
#define WIOERR_ERROR            (WIOERR_BASE+1)
#define WIOERR_BADHANDLE        (WIOERR_BASE+2)
#define WIOERR_BADFLAGS         (WIOERR_BASE+3)
#define WIOERR_BADPARAM         (WIOERR_BASE+4)
#define WIOERR_BADSIZE          (WIOERR_BASE+5)
#define WIOERR_FILEERROR        (WIOERR_BASE+6)
#define WIOERR_NOMEM            (WIOERR_BASE+7)
#define WIOERR_BADFILE          (WIOERR_BASE+8)
#define WIOERR_NODEVICE         (WIOERR_BASE+9)
#define WIOERR_BADFORMAT        (WIOERR_BASE+10)
#define WIOERR_ALLOCATED        (WIOERR_BASE+11)
#define WIOERR_NOTSUPPORTED     (WIOERR_BASE+12)



//
//  function prototypes and flag definitions
//
WIOERR WIOAPI wioFileClose
(
    LPWAVEIOCB              pwio,
    DWORD                   fdwClose
);

WIOERR WIOAPI wioFileOpen
(
    LPWAVEIOCB              pwio,
    LPCTSTR                 pszFilePath,
    DWORD                   fdwOpen
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_WAVEIO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\confmrsl\ps.cpp ===
#include "SDKInternal.h"
#include <atlbase.h>

#if(_WIN32_WINNT < 0x0500)
extern "C"
WINUSERAPI
BOOL
WINAPI
AllowSetForegroundWindow(
    DWORD dwProcessId);

#define ASFW_ANY    ((DWORD)-1)
#endif 


/* [local] */ HRESULT STDMETHODCALLTYPE INmObject_CallDialog_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ int options)
{
	AllowSetForegroundWindow(ASFW_ANY);
	return INmObject_RemoteCallDialog_Proxy(This, hwnd, options);
}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_CallDialog_Stub( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ int options)
{
	return This->CallDialog(hwnd, options);
}


/* [local] */ HRESULT STDMETHODCALLTYPE INmObject_ShowLocal_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ NM_APPID appId)
{
	AllowSetForegroundWindow(ASFW_ANY);
	return INmObject_RemoteShowLocal_Proxy(This, appId);
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_ShowLocal_Stub( 
    INmObject __RPC_FAR * This,
    /* [in] */ NM_APPID appId)
{
	return This->ShowLocal(appId);
}



/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_Initialize_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puOptions,
    /* [out][in] */ ULONG __RPC_FAR *puchCaps)
	{

		ULONG uOptions = puOptions ? *puOptions : NM_INIT_NORMAL;
		ULONG uchCaps = puchCaps ? *puchCaps : NMCH_ALL;

		HRESULT hr = INmManager_RemoteInitialize_Proxy(This, &uOptions, &uchCaps);

		if(puOptions)
		{
			*puOptions = uOptions;
		}

		if(puchCaps)
		{
			*puchCaps = uchCaps;					
		}

		return hr;
	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_Initialize_Stub( 
    INmManager __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puOptions,
    /* [out][in] */ ULONG __RPC_FAR *puchCaps)
	{

		return This->Initialize(puOptions, puchCaps);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CreateConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ ULONG uchCaps)
	{
		INmConference* pConf = ppConference ? *ppConference : NULL;

			// These may be OLECHARs and not BSTR
		CComBSTR _bstrName = bstrName;
		CComBSTR _bstrPassword = bstrPassword;
		
		HRESULT hr = INmManager_RemoteCreateConference_Proxy(This, &pConf, _bstrName, _bstrPassword, uchCaps);

		if(ppConference)
		{
			*ppConference = pConf;
		}
		else if(SUCCEEDED(hr))
		{
				// Since the client does not want this pointer, we discard it
			pConf->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CreateConference_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ ULONG uchCaps)
	{
		return This->CreateConference(ppConference, bstrName, bstrPassword, uchCaps);
	}

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CreateCall_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ INmConference __RPC_FAR *pConference)
	{
		INmCall* pCall = NULL;

			// These may be OLECHARs and not BSTR
		CComBSTR _bstrAddr = bstrAddr;


		HRESULT hr = INmManager_RemoteCreateCall_Proxy(This, &pCall, callType, addrType, _bstrAddr, pConference);

		if(ppCall)
		{
			*ppCall = pCall;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pCall->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CreateCall_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ INmConference __RPC_FAR *pConference)
	{
		return This->CreateCall(ppCall, callType, addrType, bstrAddr, pConference);
	}

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CallConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword)
	{
		INmCall* pCall = ppCall ? *ppCall : NULL;

		CComBSTR _bstrAddr = bstrAddr;
		CComBSTR _bstrName = bstrName;
		CComBSTR _bstrPassword = bstrPassword;

		HRESULT hr = INmManager_RemoteCallConference_Proxy(This, &pCall, callType, addrType, _bstrAddr, _bstrName, _bstrPassword);

		if(ppCall)
		{
			*ppCall = pCall;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pCall->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CallConference_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword)
	{
		return This->CallConference(ppCall, callType, addrType, bstrAddr, bstrName, bstrPassword);
	}

/* [local] */ HRESULT STDMETHODCALLTYPE INmConference_CreateDataChannel_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
    /* [in] */ REFGUID rguid)
	{
		INmChannelData* pChan = ppChannel ? *ppChannel : NULL;
		HRESULT hr = INmConference_RemoteCreateDataChannel_Proxy(This, &pChan, rguid);
		if(ppChannel)
		{
			*ppChannel = pChan;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pChan->Release();
		}

		return hr;
	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE INmConference_CreateDataChannel_Stub( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
    /* [in] */ REFGUID rguid)
	{
		return This->CreateDataChannel(ppChannel, rguid);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SendFile_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ BSTR bstrFile,
    /* [in] */ ULONG uOptions)
	{
		INmFt* pFt = ppFt ? *ppFt : NULL;
		CComBSTR _bstrFile = bstrFile;

		HRESULT hr = INmChannelFt_RemoteSendFile_Proxy(This, &pFt, pMember, _bstrFile, uOptions);
		if(ppFt)
		{
			*ppFt = pFt;
		}
		else if(SUCCEEDED(hr))
		{
			// Since the client does not want this pointer, we discard it
			pFt->Release();
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SendFile_Stub( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ BSTR bstrFile,
    /* [in] */ ULONG uOptions)
	{
		return This->SendFile(ppFt, pMember, bstrFile, uOptions);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SetReceiveFileDir_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [in] */ BSTR bstrDir)
	{
		CComBSTR _bstrDir = bstrDir;
		return INmChannelFt_RemoteSetReceiveFileDir_Proxy(This, _bstrDir);
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SetReceiveFileDir_Stub( 
    INmChannelFt __RPC_FAR * This,
    /* [in] */ BSTR bstrDir)
	{
		return This->SetReceiveFileDir(bstrDir);		
	}


/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmConference_Next_Proxy( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{	
		
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgConference and set cConference to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cConference) && (NULL == rgpConference) && (NULL != pcFetched))
		{
			INmConference *pConference = NULL;
			cConference = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmConference_RemoteNext_Proxy(This, cConference, &pConference, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpConference) || ((NULL == pcFetched) && (cConference != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmConference_RemoteNext_Proxy(This, cConference, rgpConference, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;
	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmConference_Next_Stub( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference,
    /* [length_is][size_is][out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpConference has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cConference, rgpConference, pcFetched);

	}


/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmMember_Next_Proxy( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember,
    /* [out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgMember and set cMember to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cMember) && (NULL == rgpMember) && (NULL != pcFetched))
		{
			INmMember *pMember = NULL;
			cMember = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmMember_RemoteNext_Proxy(This, cMember, &pMember, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpMember) || ((NULL == pcFetched) && (cMember != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmMember_RemoteNext_Proxy(This, cMember, rgpMember, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;

	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmMember_Next_Stub( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember,
    /* [length_is][size_is][out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpMember has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cMember, rgpMember, pcFetched);
	}



/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmChannel_Next_Proxy( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel,
    /* [out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgChannel and set cChannel to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cChannel) && (NULL == rgpChannel) && (NULL != pcFetched))
		{
			INmChannel *pChannel = NULL;
			cChannel = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmChannel_RemoteNext_Proxy(This, cChannel, &pChannel, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpChannel) || ((NULL == pcFetched) && (cChannel != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmChannel_RemoteNext_Proxy(This, cChannel, rgpChannel, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmChannel_Next_Stub( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel,
    /* [length_is][size_is][out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpChannel has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cChannel, rgpChannel, pcFetched);
	}


/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmCall_Next_Proxy( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgCall and set cCall to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cCall) && (NULL == rgpCall) && (NULL != pcFetched))
		{
			INmCall *pCall = NULL;
			cCall = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmCall_RemoteNext_Proxy(This, cCall, &pCall, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpCall) || ((NULL == pcFetched) && (cCall != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmCall_RemoteNext_Proxy(This, cCall, rgpCall, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;

	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmCall_Next_Stub( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall,
    /* [length_is][size_is][out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpCall has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cCall, rgpCall, pcFetched);

	}

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Next_Proxy( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp,
    /* [out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
	{
		HRESULT hr = S_OK;

			// The user can pass NULL for rpgSharableApp and set cSharableApp to 0 
			// to get the number of items, but they have to BOTH be set!
		if ((0 == cApp) && (NULL == rgpApp) && (NULL != pcFetched))
		{
			INmSharableApp *pSharableApp = NULL;
			cApp = 1;

			// Return the number of remaining elements
			ULONG ulItems = *pcFetched = 0;

			hr = IEnumNmSharableApp_RemoteNext_Proxy(This, cApp, &pSharableApp, pcFetched, &ulItems, TRUE);

			*pcFetched = ulItems;

			return hr;
		}
		
		if ((NULL == rgpApp) || ((NULL == pcFetched) && (cApp != 1)))
			return E_POINTER;

		ULONG cFetched = pcFetched ? *pcFetched : 0;
		
			// This parameter is only used when we have to determine the number of elements
		ULONG ulUnused;

		hr = IEnumNmSharableApp_RemoteNext_Proxy(This, cApp, rgpApp, &cFetched, &ulUnused, FALSE);

		if(pcFetched)
		{
			*pcFetched = cFetched;
		}

		return hr;

	}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Next_Stub( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp,
    /* [length_is][size_is][out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining)
	{
		if(bGetNumberRemaining)
		{
			HRESULT hr = This->Next(0, NULL, pcFetched);

				// Store the numebr of items
			*pcItems = *pcFetched;

				// This is so the marshaller does not think that *rgpApp has valid info
			*pcFetched = 0;
			return hr;
		}

		return This->Next(cApp, rgpApp, pcFetched);
	}



typedef HRESULT (WINAPI *VERIFYUSERINFO)(HWND hwnd, NM_VUI options);

/* [local] */ HRESULT STDMETHODCALLTYPE INmObject_VerifyUserInfo_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ UINT_PTR hwnd,
    /* [in] */ NM_VUI options)
	{
		HRESULT hr = E_FAIL;
		HMODULE hMod = LoadLibrary("msconf.dll");
		if (NULL != hMod)
		{
			VERIFYUSERINFO pfnVUI = (VERIFYUSERINFO)GetProcAddress(hMod, "VerifyUserInfo");
			if (NULL != pfnVUI)
			{
				hr = pfnVUI((HWND)hwnd, options);
			}
			FreeLibrary(hMod);
		}

		return hr;
	}


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_VerifyUserInfo_Stub( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ NM_VUI options)
	{
		return This->VerifyUserInfo(hwnd, options);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clclsfct.h ===
/*
 * clsfact.h - IClassFactory implementation.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _CLSFACT_H_
#define _CLSFACT_H_

typedef PIUnknown (*NEWOBJECTPROC)(OBJECTDESTROYEDPROC);
DECLARE_STANDARD_TYPES(NEWOBJECTPROC);

typedef struct classconstructor
{
   PCCLSID pcclsid;

   NEWOBJECTPROC NewObject;
}
CLASSCONSTRUCTOR;
DECLARE_STANDARD_TYPES(CLASSCONSTRUCTOR);

/* Classes
 **********/

// object class factory

class CCLClassFactory : public RefCount,
                        public IClassFactory
{
private:
   NEWOBJECTPROC m_NewObject;

public:
   CCLClassFactory(NEWOBJECTPROC NewObject, OBJECTDESTROYEDPROC ObjectDestroyed);
   ~CCLClassFactory(void);

   // IClassFactory methods

   HRESULT STDMETHODCALLTYPE CreateInstance(PIUnknown piunkOuter, REFIID riid, PVOID *ppvObject);
   HRESULT STDMETHODCALLTYPE LockServer(BOOL bLock);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCCCLClassFactory(const CCLClassFactory *pcurlcf);

#endif

};
DECLARE_STANDARD_TYPES(CCLClassFactory);

/* Module Prototypes
 ********************/

PIUnknown NewConfLink(OBJECTDESTROYEDPROC ObjectDestroyed);
HRESULT GetClassConstructor(REFCLSID rclsid,
                            PNEWOBJECTPROC pNewObject);


#endif /* _CLSFACT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clcnflnk.cpp ===
// File: conflnk.cpp

#include "precomp.h"

#include <shellapi.h>
#include <shlstock.h>
#include <ConfDir.h>
#include <ConfCli.h>

#include "clCnfLnk.hpp"
#include "resource.h"

#include	"atlbase.h"
#include	"confevt.h"
#include	"sdkInternal.h"
#include	"nameres.h"

/////////////////////////////////////////////////////////////////////
// Initialize GUIDs
//
#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include "CLinkId.h"

// from shlguid.h - must keep in sync
DEFINE_SHLGUID(CLSID_ShellLink,         0x00021401L, 0, 0);
#ifndef _UNICODE
DEFINE_SHLGUID(IID_IShellLink,          0x000214EEL, 0, 0);
DEFINE_SHLGUID(IID_IShellExtInit,       0x000214E8L, 0, 0);
DEFINE_SHLGUID(IID_IShellPropSheetExt,  0x000214E9L, 0, 0);
#endif // _UNICODE
#undef INITGUID
#pragma data_seg()
/////////////////////////////////////////////////////////////////////



#ifdef DEBUG

BOOL IsValidPCConfLink(PCCConfLink pcConfLink)
{
	return(	
		IS_VALID_READ_PTR(pcConfLink, CConfLink) &&
		FLAGS_ARE_VALID(pcConfLink->m_dwFlags, ALL_CONFLNK_FLAGS) &&
		(! pcConfLink->m_pszFile ||
			IS_VALID_STRING_PTR(pcConfLink->m_pszFile, STR)) &&
		(! pcConfLink->m_pszName ||
			IS_VALID_STRING_PTR(pcConfLink->m_pszName, STR)) &&
		IS_VALID_STRUCT_PTR((PCRefCount)pcConfLink, CRefCount) &&
		IS_VALID_INTERFACE_PTR((PCIDataObject)pcConfLink, IDataObject) &&
		IS_VALID_INTERFACE_PTR((PCIPersistFile)pcConfLink, IPersistFile) &&
		IS_VALID_INTERFACE_PTR((PCIPersistStream)pcConfLink, IPersistStream) &&
		IS_VALID_INTERFACE_PTR((PCIShellExtInit)pcConfLink, IShellExtInit) &&
		IS_VALID_INTERFACE_PTR((PCIShellPropSheetExt)pcConfLink, IShellPropSheetExt) &&
		IS_VALID_INTERFACE_PTR((PCIConferenceLink)pcConfLink, IConferenceLink));
}
#endif /* DEBUG */


CConfLink::CConfLink(OBJECTDESTROYEDPROC ObjectDestroyed) : 
	RefCount			(ObjectDestroyed),
	m_dwFlags			(0),
	m_dwCallFlags		(0),
	m_dwTransport		(0),
	m_pszFile			(NULL),
	m_pszName			(NULL),
	m_pszRemoteConfName	(NULL),
	m_pszAddress		(NULL)
{
	DebugEntry(CConfLink::CConfLink);

	// Don't validate this until after construction.

	ASSERT(	!ObjectDestroyed ||
			IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitVOID(CConfLink::CConfLink);

	return;
}

CConfLink::~CConfLink(void)
{
	DebugEntry(CConfLink::~CConfLink);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	delete m_pszFile;
	m_pszFile = NULL;

	delete m_pszName;
	m_pszName = NULL;

	delete m_pszAddress;
	m_pszAddress = NULL;

	delete m_pszRemoteConfName;
	m_pszRemoteConfName = NULL;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitVOID(CConfLink::~CConfLink);

	return;
}

HRESULT STDMETHODCALLTYPE CConfLink::SetAddress(PCSTR pcszAddress)
{
	HRESULT hr;
	PSTR pszNewAddress = NULL;

	DebugEntry(CConfLink::SetAddress);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcszAddress ||
			IS_VALID_STRING_PTR(pcszAddress, CSTR));

	pszNewAddress = new char[lstrlen(pcszAddress) + 1];

	if (NULL != pszNewAddress)
	{
		lstrcpy(pszNewAddress, pcszAddress);
		hr = S_OK;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if (S_OK == hr)
	{
		if (NULL != m_pszAddress)
		{
			delete m_pszAddress;
		}
		
		m_pszAddress = pszNewAddress;

		Dirty(TRUE);

		TRACE_OUT(("CConfLink::SetAddress(): Set Address to %s.",
					CHECK_STRING(m_pszAddress)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	hr == S_OK ||
			hr == E_OUTOFMEMORY);

	DebugExitHRESULT(CConfLink::SetAddress, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetAddress(PSTR *ppszAddress)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetAddress);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppszAddress, PSTR));

	*ppszAddress = NULL;

	if (NULL != m_pszAddress)
	{
		*ppszAddress = NULL;
		LPMALLOC pMalloc;
		
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			// (+ 1) for null terminator.
			*ppszAddress = (PSTR) pMalloc->Alloc(lstrlen(m_pszAddress) + 1);
			pMalloc->Release();
			pMalloc = NULL;
		}

		if (NULL != *ppszAddress)
		{
			lstrcpy(*ppszAddress, m_pszAddress);

			hr = S_OK;

			TRACE_OUT(("CConfLink::GetAddress(): Got Address %s.", *ppszAddress));
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// No Name.
		hr = S_FALSE;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	(hr == S_OK &&
				IS_VALID_STRING_PTR(*ppszAddress, STR)) ||
			((	hr == S_FALSE ||
				hr == E_OUTOFMEMORY) &&
				! *ppszAddress));

	DebugExitHRESULT(CConfLink::GetAddress, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetRemoteConfName(PCSTR pcszRemoteConfName)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetRemoteConfName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcszRemoteConfName ||
			IS_VALID_STRING_PTR(pcszRemoteConfName, CSTR));

	PSTR pszNewRemoteConfName = new char[lstrlen(pcszRemoteConfName) + 1];

	if (NULL != pszNewRemoteConfName)
	{
		lstrcpy(pszNewRemoteConfName, pcszRemoteConfName);
		hr = S_OK;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if (S_OK == hr)
	{
		if (NULL != m_pszRemoteConfName)
		{
			delete m_pszRemoteConfName;
		}
		
		m_pszRemoteConfName = pszNewRemoteConfName;

		Dirty(TRUE);

		TRACE_OUT(("CConfLink::SetRemoteConfName(): Set RemoteConfName to %s.",
					CHECK_STRING(m_pszRemoteConfName)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	hr == S_OK ||
			hr == E_OUTOFMEMORY);

	DebugExitHRESULT(CConfLink::SetRemoteConfName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetRemoteConfName(PSTR *ppszRemoteConfName)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetRemoteConfName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppszRemoteConfName, PSTR));

	*ppszRemoteConfName = NULL;

	if (NULL != m_pszRemoteConfName)
	{
		*ppszRemoteConfName = NULL;
		LPMALLOC pMalloc;
		
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			// (+ 1) for null terminator.
			*ppszRemoteConfName = (PSTR) pMalloc->Alloc(lstrlen(m_pszRemoteConfName) + 1);
			pMalloc->Release();
			pMalloc = NULL;
		}

		if (NULL != *ppszRemoteConfName)
		{
			lstrcpy(*ppszRemoteConfName, m_pszRemoteConfName);

			hr = S_OK;

			TRACE_OUT(("CConfLink::GetRemoteConfName(): Got RemoteConfName %s.",
						*ppszRemoteConfName));
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// No Name.
		hr = S_FALSE;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	(hr == S_OK &&
				IS_VALID_STRING_PTR(*ppszRemoteConfName, STR)) ||
			((	hr == S_FALSE ||
				hr == E_OUTOFMEMORY) &&
				! *ppszRemoteConfName));

	DebugExitHRESULT(CConfLink::GetRemoteConfName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetName(PCSTR pcszName)
{
	HRESULT hr;
	BOOL bChanged;
	PSTR pszNewName = NULL;

	DebugEntry(CConfLink::SetName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcszName ||
			IS_VALID_STRING_PTR(pcszName, CSTR));

	bChanged = ! ((! pcszName && ! m_pszName) ||
					(pcszName && m_pszName &&
					! lstrcmp(pcszName, m_pszName)));

	if (bChanged && pcszName)
	{
		pszNewName = new(char[lstrlen(pcszName) + 1]);

		if (pszNewName)
		{
			lstrcpy(pszNewName, pcszName);
			hr = S_OK;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = S_OK;
	}

	if (hr == S_OK)
	{
		if (bChanged)
		{
			if (m_pszName)
			{
				delete m_pszName;
			}

			m_pszName = pszNewName;

			Dirty(TRUE);

			TRACE_OUT(("CConfLink::SetName(): Set Name to %s.",
						CHECK_STRING(m_pszName)));
		}
		else
		{
			TRACE_OUT(("CConfLink::SetName(): Name already %s.",
						CHECK_STRING(m_pszName)));
		}
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	hr == S_OK ||
			hr == E_OUTOFMEMORY);

	DebugExitHRESULT(CConfLink::SetName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetName(PSTR *ppszName)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetName);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppszName, PSTR));

	*ppszName = NULL;

	if (m_pszName)
	{
		*ppszName = NULL;
		LPMALLOC pMalloc;
		
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			// (+ 1) for null terminator.
			*ppszName = (PSTR) pMalloc->Alloc(lstrlen(m_pszName) + 1);
			pMalloc->Release();
			pMalloc = NULL;
		}
		
		// ChrisPi: I changed this to use the above implementation because
		// SHAlloc is not available in the sdk shell32.lib
		
		// *ppszName = (PSTR)SHAlloc(lstrlen(m_pszURL) + 1);

		if (*ppszName)
		{
			lstrcpy(*ppszName, m_pszName);

			hr = S_OK;

			TRACE_OUT(("CConfLink::GetName(): Got Name %s.", *ppszName));
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// No Name.
		hr = S_FALSE;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	(hr == S_OK &&
				IS_VALID_STRING_PTR(*ppszName, STR)) ||
			((	hr == S_FALSE ||
				hr == E_OUTOFMEMORY) &&
				! *ppszName));

	DebugExitHRESULT(CConfLink::GetName, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetTransport(DWORD dwTransport)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetTransport);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	m_dwTransport = dwTransport;

	Dirty(TRUE);

	TRACE_OUT(("CConfLink::SetTransport(): Set Transport to %#8x.",
				m_dwTransport));

	hr = S_OK;
	
	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::SetTransport, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetTransport(DWORD *pdwTransport)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetTransport);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(pdwTransport, PDWORD));

	*pdwTransport = m_dwTransport;

	hr = S_OK;

	TRACE_OUT(("CConfLink::GetTransport(): Got Transport %#8x.",
				*pdwTransport));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::GetTransport, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::SetCallFlags(DWORD dwCallFlags)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetCallFlags);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	m_dwCallFlags = dwCallFlags;

	Dirty(TRUE);

	TRACE_OUT(("CConfLink::SetCallFlags(): Set CallFlags to %#8x.",
				m_dwCallFlags));

	hr = S_OK;
	
	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::SetCallFlags, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetCallFlags(DWORD *pdwCallFlags)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetCallFlags);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(pdwCallFlags, PDWORD));

	*pdwCallFlags = m_dwCallFlags;

	hr = S_OK;

	TRACE_OUT(("CConfLink::GetCallFlags(): Got CallFlags %#8x.",
				*pdwCallFlags));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::GetCallFlags, hr);

	return(hr);
}


#define STR_CALLTO			_T("callto:")
#define STR_CONFERENCE		_T("+conference=")
#define STR_GATEWAY			_T("+gateway=")
#define STR_SECURE			_T("+secure=true")
#define STR_PHONE			_T("+type=phone")
#define STR_NO_AV			_T("+av=false")
#define STR_NO_DATA			_T("+data=false")


//--------------------------------------------------------------------------//
//	CConfLink::InvokeCommand.												//
//--------------------------------------------------------------------------//
HRESULT
STDMETHODCALLTYPE
CConfLink::InvokeCommand
(
	PCLINVOKECOMMANDINFO	pclici
){
	DebugEntry( CConfLink::InvokeCommand );
	ASSERT( IS_VALID_STRUCT_PTR( this, CConfLink ) );
	ASSERT( IS_VALID_STRUCT_PTR( pclici, CCLINVOKECOMMANDINFO ) );

	HRESULT	result = E_INVALIDARG;

	if(m_pszAddress)
	{
		if( m_dwTransport == NAMETYPE_CALLTO )
		{
			result = shellCallto( m_pszAddress, IS_FLAG_SET( pclici->dwFlags, ICL_INVOKECOMMAND_FL_ALLOW_UI ) );
		}
		else
		{
			long lMax =	lstrlen(STR_CALLTO) + 
						lstrlen(STR_CONFERENCE) + 
						lstrlen(STR_GATEWAY) + 
						lstrlen(STR_PHONE) + 
						lstrlen(STR_SECURE) + 
						lstrlen(STR_NO_AV) +
						lstrlen(STR_NO_DATA) +
						lstrlen(m_pszAddress) +
						(m_pszRemoteConfName ? lstrlen(m_pszRemoteConfName) : 0) +
						1; 

			LPTSTR url = (TCHAR*) _alloca(lMax);

			lstrcpy( url, STR_CALLTO );

			if( m_dwTransport != NAMETYPE_H323GTWY )
			{
				lstrcat( url, m_pszAddress );
			}
			else
			{
				TCHAR *	const pSlash	= (TCHAR * const) _StrChr( m_pszAddress, '/' );

				if( pSlash != NULL )
				{
					*pSlash = '\0';
					lstrcat( url, pSlash + 1 );
					lstrcat( url, STR_GATEWAY );
				}

				lstrcat( url, m_pszAddress );
				lstrcat( url, STR_PHONE );
			}

			if( m_pszRemoteConfName != NULL )
			{
				lstrcat( url, STR_CONFERENCE );
				lstrcat( url, m_pszRemoteConfName );
			}

			if( IS_FLAG_SET( m_dwCallFlags, CRPCF_SECURE ) )
			{
				lstrcat( url, STR_SECURE );
			}

			if( IS_FLAG_CLEAR( m_dwCallFlags, (CRPCF_AUDIO | CRPCF_VIDEO) ) )
			{
				lstrcat( url, STR_NO_AV );
			}

			if( IS_FLAG_CLEAR( m_dwCallFlags, CRPCF_DATA) )
			{
				lstrcat( url, STR_NO_DATA );
			}

			result = shellCallto( url, IS_FLAG_SET( pclici->dwFlags, ICL_INVOKECOMMAND_FL_ALLOW_UI ) );
		}

		ASSERT( IS_VALID_STRUCT_PTR( this, CConfLink ) );
		DebugExitHRESULT( CConfLink::InvokeCommand, result );
	}

	return( result );

}	//	End of CConfLink::InvokeCommand.


//--------------------------------------------------------------------------//
//	shellCallto.															//
//--------------------------------------------------------------------------//
HRESULT
shellCallto
(
	const TCHAR * const	url,
	const bool			notifyOnError
){
	ASSERT( url != NULL );
	ASSERT( url[ 0 ] != '\0' );
	TRACE_OUT( ("shellCallto:   url:\"%s\"", url) );

	HRESULT	result;

	if( url == NULL )
	{
		result = E_POINTER;
	}
	else if( url[ 0 ] == '\0' )
	{
		result = E_INVALIDARG;
	}
	else
	{
		result = ::CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

		if( SUCCEEDED( result ) )
		{
			IInternalConfExe *	internalConf;
			HRESULT				result;
			
			result = CoCreateInstance( CLSID_NmManager, NULL, CLSCTX_ALL, IID_IInternalConfExe, (LPVOID *) &internalConf );

			if( SUCCEEDED( result ) && (internalConf != NULL) )
			{
				result = internalConf->ShellCalltoProtocolHandler( CComBSTR( url ), FALSE );

				internalConf->Release();
			}

			::CoUninitialize();
		}

		if( FAILED( result ) && notifyOnError )
		{
			TCHAR	message[ MAX_PATH ];
			TCHAR	title[ MAX_PATH ];

			::LoadString(	g_hInst,						//	handle to module containing string resource
							IDS_COULD_NOT_CALL,				//	resource identifier
							message,						//	pointer to buffer for resource
							ARRAY_ELEMENTS( message ) );	//	size of buffer

			::LoadString(	g_hInst,						//	handle to module containing string resource
							IDS_LAUNCH_ERROR,				//	resource identifier
							title,							//	pointer to buffer for resource
							ARRAY_ELEMENTS( title ) );		//	size of buffer

			::MessageBox( NULL, message, title, MB_ICONERROR | MB_OK );
		}
	}

	return( result );

}	//	End of shellCallto.


ULONG STDMETHODCALLTYPE CConfLink::AddRef(void)
{
	ULONG ulcRef;

	DebugEntry(CConfLink::AddRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	ulcRef = RefCount::AddRef();

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitULONG(CConfLink::AddRef, ulcRef);

	return(ulcRef);
}


ULONG STDMETHODCALLTYPE CConfLink::Release(void)
{
	ULONG ulcRef;

	DebugEntry(CConfLink::Release);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	ulcRef = RefCount::Release();

	DebugExitULONG(CConfLink::Release, ulcRef);

	return(ulcRef);
}


HRESULT STDMETHODCALLTYPE CConfLink::QueryInterface(REFIID riid,
													PVOID *ppvObject)
{
	HRESULT hr = S_OK;

	DebugEntry(CConfLink::QueryInterface);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	if (riid == IID_IDataObject)
	{
		*ppvObject = (PIDataObject)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IDataObject."));
	}

#if 0 // These are currently unsupported interfaces:

	else if (riid == IID_IExtractIcon)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PIExtractIcon)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning IExtractIcon!"));
	}
	else if (riid == IID_INewShortcutHook)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PINewShortcutHook)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning INewShortcutHook!"));
	}
	else if (riid == IID_IShellExecuteHook)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PIShellExecuteHook)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning IShellExecuteHook!"));
	}
	else if (riid == IID_IShellLink)
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;

		// *ppvObject = (PIShellLink)this;
		TRACE_OUT(("CConfLink::QueryInterface(): NOT Returning IShellLink!"));
	}
#endif /* DEBUG */


	// Supported interfaces:
	
	else if (riid == IID_IShellExtInit)
	{
		*ppvObject = (PIShellExtInit)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IShellExtInit."));
	}
	else if (riid == IID_IShellPropSheetExt)
	{
		*ppvObject = (PIShellPropSheetExt)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IShellPropSheetExt."));
	}
	else if (riid == IID_IPersist)
	{
		*ppvObject = (PIPersist)(PIPersistStream)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IPersist."));
	}
	else if (riid == IID_IPersistFile)
	{
		*ppvObject = (PIPersistFile)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IPersistFile."));
	}
	else if (riid == IID_IPersistStream)
	{
		*ppvObject = (PIPersistStream)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IPersistStream."));
	}
	else if (riid == IID_IConferenceLink)
	{
		*ppvObject = (PIConferenceLink)this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IConferenceLink."));
	}
	else if (riid == IID_IUnknown)
	{
		*ppvObject = (PIUnknown) (PIConferenceLink) this;
		TRACE_OUT(("CConfLink::QueryInterface(): Returning IUnknown."));
	}
	else
	{
		TRACE_OUT(("CConfLink::QueryInterface(): Called on unknown interface."));
		*ppvObject = NULL;
		hr = E_NOINTERFACE;
	}

	if (hr == S_OK)
	{
		AddRef();
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::QueryInterface, hr);

	return(hr);
}




/*  O P E N  C O N F  L I N K  */
/*-------------------------------------------------------------------------
    %%Function: OpenConfLink
    
-------------------------------------------------------------------------*/
void WINAPI OpenConfLink(HWND hwndParent, HINSTANCE hinst,
									PSTR pszCmdLine, int nShowCmd)
{
	HRESULT hr;
	CConfLink conflink(NULL);
	// int nResult;

	DebugEntry(OpenConfLink);

	ASSERT(IS_VALID_HANDLE(hwndParent, WND));
	ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
	ASSERT(IS_VALID_STRING_PTR(pszCmdLine, STR));
	ASSERT(IsValidShowCmd(nShowCmd));

	// Assume the entire command line is a Conference Link file path.

	// TrimWhiteSpace(pszCmdLine);

	TRACE_OUT(("OpenConfLink(): Trying to open Conference Link %s.",
				pszCmdLine));

#if 0
	TCHAR szBuf[256];
	
	wsprintf(szBuf, "Launching conference link %s", pszCmdLine);
	
	::MessageBox(	NULL,
					szBuf,
					"Conference Link Extension",
					MB_ICONINFORMATION);
#endif

	hr = conflink.LoadFromFile(pszCmdLine, TRUE);

	if (hr == S_OK)
	{
		CLINVOKECOMMANDINFO clici;

		clici.dwcbSize = sizeof(clici);
		clici.hwndParent = hwndParent;
		clici.pcszVerb = NULL;
		clici.dwFlags = (	ICL_INVOKECOMMAND_FL_ALLOW_UI |
							ICL_INVOKECOMMAND_FL_USE_DEFAULT_VERB);

		hr = conflink.InvokeCommand(&clici);
	}
	else
	{
		// BUGBUG: need resource here INTL

		::MessageBox(	hwndParent,
						_TEXT("There was an error while identifying the conference"),
						_TEXT("Conference Shortcut Error"),
						MB_ICONINFORMATION);
		
		// if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
		//			MAKEINTRESOURCE(IDS_LOADFROMFILE_FAILED),
		//			(MB_OK | MB_ICONEXCLAMATION), &nResult, pszCmdLine))
		//
		// ASSERT(nResult == IDOK);
	}

	DebugExitVOID(OpenConfLink);

	return;
}


/*  A N Y  M E A T  */
/*-------------------------------------------------------------------------
    %%Function: AnyMeat

    Return TRUE if the string has any non-whitespace characters
-------------------------------------------------------------------------*/
BOOL AnyMeat(PCSTR pcsz)
{
	TCHAR ch;

	ASSERT((!pcsz) || IS_VALID_STRING_PTR(pcsz, CSTR));

	if (NULL == pcsz)
		return FALSE;

	while (0 != (ch = *pcsz++))
	{
		switch (ch)
			{
		case _T(' '):   // Space
		case _T('\t'):  // Tab
		case 0x00A0:    // Non-breaking space
			break;
		default:
			return TRUE; // found a non-whitespace character
			}
	}

	return FALSE;
}



HRESULT MyReleaseStgMedium(PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

   if (pstgmed->pUnkForRelease)
       hr = pstgmed->pUnkForRelease->Release();
   else
   {
      switch(pstgmed->tymed)
      {
         case TYMED_HGLOBAL:
            hr = (! GlobalFree(pstgmed->hGlobal)) ? S_OK : E_HANDLE;
            break;

#if 0  /* Only TYMED_HGLOBAL is ever used */
         case TYMED_ISTREAM:
            hr = pstgmed->pstm->Release();
            break;

         case TYMED_ISTORAGE:
            hr = pstgmed->pstm->Release();
            break;

         case TYMED_FILE:
         {
            PIMalloc pMalloc = NULL;
            
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
            	pMalloc->Free(pstgmed->lpszFileName);
				pMalloc->Release();
				pMalloc = NULL;
				pstgmed->lpszFileName = NULL;
			}
            hr = S_OK;
            break;
		 }

         case TYMED_GDI:
            hr = (DeleteObject(pstgmed->hBitmap)) ? S_OK : E_HANDLE;
            break;

         case TYMED_MFPICT:
            hr = (DeleteMetaFile((HMETAFILE)(pstgmed->hMetaFilePict)) &&
                  ! GlobalFree(pstgmed->hMetaFilePict)) ? S_OK : E_HANDLE;
            break;

         case TYMED_ENHMF:
            hr = (DeleteEnhMetaFile(pstgmed->hEnhMetaFile)) ? S_OK : E_HANDLE;
            break;
#endif // 0

         default:
            ASSERT(pstgmed->tymed == TYMED_NULL);
            hr = S_OK;
            break;
      }
   }

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clclsfct.cpp ===
/*
 * clsfact.cpp - IClassFactory implementation.
 *
 * Taken from URL code - essentially identical to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "CLinkID.h"
#include "clrefcnt.hpp"
#include "clenumft.hpp"
#include "clCnfLnk.hpp"

#include "clclsfct.h"

#define INITGUID
#include <initguid.h>
#include <olectlid.h>
#include <confguid.h>


// from niMgr.cpp
PIUnknown NewNmManager(OBJECTDESTROYEDPROC ObjectDestroyed);

// from imconfmg.cpp
PIUnknown NewConfMgr(OBJECTDESTROYEDPROC ObjectDestroyed);

/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

CCLASSCONSTRUCTOR s_cclscnstr[] =
{
//	{ &CLSID_ConferenceManager, &NewNmManager },
	{ &CLSID_ConfLink,			&NewConfLink },
//	{ &CLSID_NmManager,         &NewNmManager },
//   { &CLSID_MIMEFileTypesPropSheetHook,   &NewMIMEHook },
//   { &CLSID_Internet,                     &NewInternet },
};


#pragma data_seg()

/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

// DLL reference count == number of class factories +
//                        number of URLs +
//                        LockServer() count

ULONG s_ulcDLLRef   = 0;

#pragma data_seg()

/***************************** Private Functions *****************************/


HRESULT GetClassConstructor(REFCLSID rclsid,
                                         PNEWOBJECTPROC pNewObject)
{
   HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
   UINT u;

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IS_VALID_WRITE_PTR(pNewObject, NEWOBJECTPROC));

   *pNewObject = NULL;

   for (u = 0; u < ARRAY_ELEMENTS(s_cclscnstr); u++)
   {
      if (rclsid == *(s_cclscnstr[u].pcclsid))
      {
         *pNewObject = s_cclscnstr[u].NewObject;
         hr = S_OK;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_CODE_PTR(*pNewObject, NEWOBJECTPROC)) ||
          (hr == CLASS_E_CLASSNOTAVAILABLE &&
           ! *pNewObject));

   return(hr);
}


VOID STDMETHODCALLTYPE DLLObjectDestroyed(void)
{
   TRACE_OUT(("DLLObjectDestroyed(): Object destroyed."));

   DllRelease();
}


PIUnknown NewConfLink(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewConfLink(): Creating a new ConfLink."));

   return((PIUnknown) (PIConferenceLink) new CConfLink(ObjectDestroyed));
}

#if 0
PIUnknown NewMIMEHook(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewMIMEHook(): Creating a new MIMEHook."));

   return((PIUnknown)(PIShellPropSheetExt)new(MIMEHook(ObjectDestroyed)));
}


PIUnknown NewInternet(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewInternet(): Creating a new Internet."));

   return((PIUnknown)(PIShellPropSheetExt)new(Internet(ObjectDestroyed)));
}

#endif // 0

#ifdef DEBUG

BOOL IsValidPCCCLClassFactory(PCCCLClassFactory pccf)
{
   return(IS_VALID_READ_PTR(pccf, CCCLClassFactory) &&
          IS_VALID_CODE_PTR(pccf->m_NewObject, NEWOBJECTPROC) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pccf, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIClassFactory)pccf, IClassFactory));
}

#endif


/****************************** Public Functions *****************************/

ULONG DLLAddRef(void)
{
   ULONG ulcRef;

   ASSERT(s_ulcDLLRef < ULONG_MAX);

   ulcRef = ++s_ulcDLLRef;

   TRACE_OUT(("DLLAddRef(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


ULONG DLLRelease(void)
{
   ULONG ulcRef;

   if (EVAL(s_ulcDLLRef > 0))
      s_ulcDLLRef--;

   ulcRef = s_ulcDLLRef;

   TRACE_OUT(("DLLRelease(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


PULONG GetDLLRefCountPtr(void)
{
   return(&s_ulcDLLRef);
}


/********************************** Methods **********************************/


CCLClassFactory::CCLClassFactory(NEWOBJECTPROC NewObject,
                           OBJECTDESTROYEDPROC ObjectDestroyed) :
   RefCount(ObjectDestroyed)
{
   DebugEntry(CCLClassFactory::CCLClassFactory);

   // Don't validate this until after construction.

   ASSERT(IS_VALID_CODE_PTR(NewObject, NEWOBJECTPROC));

   m_NewObject = NewObject;

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   DebugExitVOID(CCLClassFactory::CCLClassFactory);

   return;
}


CCLClassFactory::~CCLClassFactory(void)
{
   DebugEntry(CCLClassFactory::~CCLClassFactory);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   m_NewObject = NULL;

   // Don't validate this after destruction.

   DebugExitVOID(CCLClassFactory::~CCLClassFactory);

   return;
}


ULONG STDMETHODCALLTYPE CCLClassFactory::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(CCLClassFactory::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   DebugExitULONG(CCLClassFactory::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE CCLClassFactory::Release(void)
{
   ULONG ulcRef;

   DebugEntry(CCLClassFactory::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   ulcRef = RefCount::Release();

   DebugExitULONG(CCLClassFactory::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::QueryInterface(REFIID riid,
                                                       PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(CCLClassFactory::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IClassFactory)
   {
      *ppvObject = (PIClassFactory)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
      TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IClassFactory."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
      TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
      TRACE_OUT(("CCLClassFactory::QueryInterface(): Called on unknown interface."));
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   
   // removed by ChrisPi CINTERFACE undeclared identifier
   // ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(CCLClassFactory::QueryInterface, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::CreateInstance(PIUnknown piunkOuter,
                                                       REFIID riid,
                                                       PVOID *ppvObject)
{
   HRESULT hr;

   DebugEntry(CCLClassFactory::CreateInstance);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   ASSERT(! piunkOuter ||
          IS_VALID_INTERFACE_PTR(piunkOuter, IUnknown));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   *ppvObject = NULL;

   if (! piunkOuter)
   {
      PIUnknown piunk;

      piunk = (*m_NewObject)(  (void(__stdcall *)(void))   &DLLObjectDestroyed);

      if (piunk)
      {
         DllLock();

         hr = piunk->QueryInterface(riid, ppvObject);

         // N.b., the Release() method will destroy the object if the
         // QueryInterface() method failed.

         piunk->Release();
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = CLASS_E_NOAGGREGATION;
      WARNING_OUT(("CCLClassFactory::CreateInstance(): Aggregation not supported."));
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
   
   // removed by ChrisPi - see above
   // ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(CCLClassFactory::CreateInstance, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::LockServer(BOOL bLock)
{
   HRESULT hr;

   DebugEntry(CCLClassFactory::LockServer);

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   // bLock may be any value.

   if (bLock)
      DllLock();
   else
      DllRelease();

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

   DebugExitHRESULT(CCLClassFactory::LockServer, hr);

   return(hr);
}


/***************************** Exported Functions ****************************/


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PVOID *ppvObject)
{
   HRESULT hr = S_OK;
   NEWOBJECTPROC NewObject;

   DebugEntry(DllGetClassObject);

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   *ppvObject = NULL;

   hr = GetClassConstructor(rclsid, &NewObject);

   if (hr == S_OK)
   {
      if (riid == IID_IUnknown ||
          riid == IID_IClassFactory)
      {
         PCCLClassFactory pcf;

         pcf = new CCLClassFactory(NewObject, (void(__stdcall *)(void)) &DLLObjectDestroyed);

         if (pcf)
         {
            if (riid == IID_IClassFactory)
            {
               *ppvObject = (PIClassFactory)pcf;
               ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
               TRACE_OUT(("DllGetClassObject(): Returning IClassFactory."));
            }
            else
            {
               ASSERT(riid == IID_IUnknown);
               *ppvObject = (PIUnknown)pcf;
               ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
               TRACE_OUT(("DllGetClassObject(): Returning IUnknown."));
            }

            DllLock();
            hr = S_OK;

            TRACE_OUT(("DllGetClassObject(): Created a new class factory."));
         }
         else
            hr = E_OUTOFMEMORY;
      }
      else
      {
         WARNING_OUT(("DllGetClassObject(): Called on unknown interface."));
         hr = E_NOINTERFACE;
      }
   }
   else
      WARNING_OUT(("DllGetClassObject(): Called on unknown class."));

   // removed by ChrisPi - see above
   // ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(DllGetClassObject, hr);

   return(hr);
}


STDAPI DllCanUnloadNow(void)
{
   HRESULT hr;

   DebugEntry(DllCanUnloadNow);

   hr = (s_ulcDLLRef > 0) ? S_FALSE : S_OK;

   TRACE_OUT(("DllCanUnloadNow(): DLL reference count is %lu.", s_ulcDLLRef));

   DebugExitHRESULT(DllCanUnloadNow, hr);

   return(hr);
}

void DllLock(void)
{
    InterlockedIncrement((LPLONG) &s_ulcDLLRef);

    DBGAPI_TRACE("Ref: DllLock count=%d", s_ulcDLLRef);
}

void DllRelease(void)
{
	LONG cRef = InterlockedDecrement((LPLONG) &s_ulcDLLRef);

#ifdef DEBUG
    DBGAPI_TRACE("Ref: DllLock count=%d", s_ulcDLLRef);
    if (0 == cRef)
		WARNING_OUT(("MSCONF.DLL Can now be unloaded"));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clcnflnk.hpp ===
#ifndef _CONFLNK_HPP_
#define _CONFLNK_HPP_

// ConfLink flags

typedef enum _conflnkflags
{
   CONFLNK_FL_DIRTY    = 0x0001,

   ALL_CONFLNK_FLAGS   = CONFLNK_FL_DIRTY
}
CONFLNKFLAGS;

class CConfLink :
		public RefCount,
		public IDataObject,
		public IPersistFile,
		public IPersistStream,
		public IShellExtInit,
		// public IShellPropSheetExt,
		public IConferenceLink
{
private:
	DWORD	m_dwFlags;
	DWORD	m_dwTransport;
	DWORD	m_dwCallFlags;
	PSTR	m_pszFile;
	PSTR	m_pszName;
	PSTR	m_pszAddress;
	PSTR	m_pszRemoteConfName;

	// Data transfer
	
	DWORD   STDMETHODCALLTYPE GetFileContentsSize(void);
	HRESULT STDMETHODCALLTYPE TransferFileContents(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);

#if 0
	HRESULT STDMETHODCALLTYPE TransferText(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
	HRESULT STDMETHODCALLTYPE TransferFileGroupDescriptor(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
	HRESULT STDMETHODCALLTYPE TransferConfLink(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
#endif // 0

public:
	CConfLink(OBJECTDESTROYEDPROC);
	~CConfLink(void);

	// IDataObject methods

	HRESULT STDMETHODCALLTYPE GetData(PFORMATETC pfmtetcIn, PSTGMEDIUM pstgmed);
	HRESULT STDMETHODCALLTYPE GetDataHere(PFORMATETC pfmtetc, PSTGMEDIUM pstgpmed);
	HRESULT STDMETHODCALLTYPE QueryGetData(PFORMATETC pfmtetc);
	HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(PFORMATETC pfmtetcIn, PFORMATETC pfmtetcOut);
	HRESULT STDMETHODCALLTYPE SetData(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed, BOOL bRelease);
	HRESULT STDMETHODCALLTYPE EnumFormatEtc(DWORD dwDirection, PIEnumFORMATETC *ppienumFormatEtc);
	HRESULT STDMETHODCALLTYPE DAdvise(PFORMATETC pfmtetc, DWORD dwAdviseFlags, PIAdviseSink piadvsink, PDWORD pdwConnection);
	HRESULT STDMETHODCALLTYPE DUnadvise(DWORD dwConnection);
	HRESULT STDMETHODCALLTYPE EnumDAdvise(PIEnumSTATDATA *ppienumStatData);

	// IPersist methods

	HRESULT STDMETHODCALLTYPE GetClassID(PCLSID pclsid);

	// IPersistFile methods

	HRESULT STDMETHODCALLTYPE IsDirty(void);
	HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pcwszFileName, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pcwszFileName);
	HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pcwszFileName, DWORD dwMode);
	HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR *ppwszFileName);

	// IPersistStream methods

	HRESULT STDMETHODCALLTYPE Save(PIStream pistr, BOOL bClearDirty);
	HRESULT STDMETHODCALLTYPE Load(PIStream pistr);
	HRESULT STDMETHODCALLTYPE GetSizeMax(PULARGE_INTEGER pcbSize);

	// IShellExtInit methods

	HRESULT STDMETHODCALLTYPE Initialize(LPCITEMIDLIST pcidlFolder, LPDATAOBJECT pidobj, HKEY hkeyProgID);

	// IShellPropSheetExt methods

	// HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
	// HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

	// IConferenceLink methods

	HRESULT STDMETHODCALLTYPE SetName(PCSTR pcszName);
	HRESULT STDMETHODCALLTYPE GetName(PSTR *ppszName);
	HRESULT STDMETHODCALLTYPE SetAddress(PCSTR pcszAddress);
	HRESULT STDMETHODCALLTYPE GetAddress(PSTR *ppszAddress);
	HRESULT STDMETHODCALLTYPE SetRemoteConfName(PCSTR pcszRemoteConfName);
	HRESULT STDMETHODCALLTYPE GetRemoteConfName(PSTR *ppszRemoteConfName);
	HRESULT STDMETHODCALLTYPE SetCallFlags(DWORD dwCallFlags);
	HRESULT STDMETHODCALLTYPE GetCallFlags(DWORD *pdwCallFlags);
	HRESULT STDMETHODCALLTYPE SetTransport(DWORD dwTransport);
	HRESULT STDMETHODCALLTYPE GetTransport(DWORD *pdwTransport);
	HRESULT STDMETHODCALLTYPE InvokeCommand(PCLINVOKECOMMANDINFO pclici);

	// IUnknown methods

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	// other methods

	HRESULT STDMETHODCALLTYPE SaveToFile(PCSTR pcszFile, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE LoadFromFile(PCSTR pcszFile, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE GetCurFile(PSTR pszFile, UINT ucbLen);
	HRESULT STDMETHODCALLTYPE Dirty(BOOL bDirty);

#ifdef DEBUG

	void STDMETHODCALLTYPE Dump(void);

#endif

	// friends

#ifdef DEBUG

	friend BOOL IsValidPCConfLink(const CConfLink *pcConfLink);

#endif
};

HRESULT
shellCallto
(
	const TCHAR * const	url,
	const bool			notifyOnError
);

DECLARE_STANDARD_TYPES(CConfLink);

// in dataobj.cpp:
PUBLIC_CODE BOOL InitDataObjectModule(void);

// in conflnk.cpp:

PUBLIC_CODE BOOL AnyMeat(PCSTR pcsz);
PUBLIC_CODE BOOL DataCopy(PCBYTE pcbyteSrc, ULONG ulcbLen, PBYTE *ppbyteDest);
PUBLIC_CODE BOOL StringCopy(PCSTR pcszSrc, PSTR *ppszCopy);
PUBLIC_CODE void MyLStrCpyN(PSTR pszDest, PCSTR pcszSrc, int ncb);
PUBLIC_CODE BOOL GetConfLinkDefaultVerb(PSTR pszDefaultVerbBuf,
										UINT ucDefaultVerbBufLen);
PUBLIC_CODE LRESULT GetRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey,
									PCSTR pcszValue, PDWORD pdwValueType,
									PBYTE pbyteBuf, PDWORD pdwcbBufLen);
PUBLIC_CODE LRESULT GetRegKeyStringValue(	HKEY hkeyParent, PCSTR pcszSubKey,
											PCSTR pcszValue, PSTR pszBuf,
											PDWORD pdwcbBufLen);
PUBLIC_CODE LRESULT GetDefaultRegKeyValue(	HKEY hkeyParent, PCSTR pcszSubKey,
											PSTR pszBuf, PDWORD pdwcbBufLen);
PUBLIC_CODE BOOL GetClassDefaultVerb(	PCSTR pcszClass, PSTR pszDefaultVerbBuf,
										UINT ucDefaultVerbBufLen);
PUBLIC_CODE HRESULT MyReleaseStgMedium(PSTGMEDIUM pstgmed);


extern "C"
{
void WINAPI OpenConfLink(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);
}

#endif // _CONFLNK_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\cldataob.cpp ===
/*
 * DataObj.cpp - IDataObject implementation.
 *
 * Taken from URL code - very similar to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */

#include "precomp.h"

#include "clrefcnt.hpp"
#include "clenumft.hpp"
#include "clCnfLnk.hpp"

/* Global Variables
 *******************/

/* registered clipboard formats */

UINT g_cfConfLink = 0;
UINT g_cfFileGroupDescriptor = 0;
UINT g_cfFileContents = 0;

/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

char s_szConfLinkCF[] = "ConferenceLink";
char s_szFileGroupDescriptorCF[]   = CFSTR_FILEDESCRIPTOR;
char s_szFileContentsCF[]          = CFSTR_FILECONTENTS;

#pragma data_seg()


/***************************** Private Functions *****************************/

BOOL InitDataObjectModule(void)
{
	g_cfConfLink = RegisterClipboardFormat(s_szConfLinkCF);
	g_cfFileGroupDescriptor = RegisterClipboardFormat(s_szFileGroupDescriptorCF);
	g_cfFileContents        = RegisterClipboardFormat(s_szFileContentsCF);

	return(	g_cfConfLink &&
			g_cfFileGroupDescriptor &&
			g_cfFileContents);
}

/********************************** Methods **********************************/

HRESULT STDMETHODCALLTYPE CConfLink::GetData(	PFORMATETC pfmtetc,
												PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetData);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	// Ignore pfmtetc.ptd.  All supported data formats are device-independent.

	ZeroMemory(pstgmed, sizeof(*pstgmed));

	if (pfmtetc->dwAspect == DVASPECT_CONTENT)
	{
#ifdef DEBUG
		if ((pfmtetc->lindex == -1) &&
			  ( (pfmtetc->cfFormat == g_cfConfLink) ||
				(pfmtetc->cfFormat == CF_TEXT) ||
				(pfmtetc->cfFormat == g_cfFileGroupDescriptor)) )
		{
			ERROR_OUT(("CConfLink::GetData - unsupported cfFormat"));
		}
#endif /* DEBUG */
#if 0
		if (pfmtetc->cfFormat == g_cfConfLink)
		{
			hr = (pfmtetc->lindex == -1) ? 
				TransferConfLink(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else if (pfmtetc->cfFormat == CF_TEXT)
		{
			hr = (pfmtetc->lindex == -1) ? 
				TransferText(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else if (pfmtetc->cfFormat == g_cfFileGroupDescriptor)
		{
			hr = (pfmtetc->lindex == -1) ? 
				TransferFileGroupDescriptor(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else
#endif // 0

		     if (pfmtetc->cfFormat == g_cfFileContents)
		{
			hr = (! pfmtetc->lindex) ? 
				TransferFileContents(pfmtetc, pstgmed) : DV_E_LINDEX;
		}
		else
		{
			hr = DV_E_FORMATETC;
		}
	}
	else
	{
		hr = DV_E_DVASPECT;
	}

	if (hr == S_OK)
	{
		TRACE_OUT(("CConfLink::GetData(): Returning clipboard format %s.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}
	else
	{
		TRACE_OUT(("CConfLink::GetData(): Failed to return clipboard format %s.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(FAILED(hr) || IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

	DebugExitHRESULT(CConfLink::GetData, hr);

	return(hr);
}

// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::GetDataHere(	PFORMATETC pfmtetc,
													PSTGMEDIUM pstgpmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetDataHere);
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_STRUCT_PTR(pstgpmed, CSTGMEDIUM));

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	TRACE_OUT(("CConfLink::GetDataHere(): Failed to return clipboard format %s.",
				GetClipboardFormatNameString(pfmtetc->cfFormat)));

	hr = DV_E_FORMATETC;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pstgpmed, CSTGMEDIUM));

	DebugExitHRESULT(CConfLink::GetDataHere, hr);

	return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::QueryGetData(PFORMATETC pfmtetc)
{
	HRESULT hr;

	DebugEntry(CConfLink::QueryGetData);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));

	TRACE_OUT(("CConfLink::QueryGetData(): Asked for clipboard format %s.",
				GetClipboardFormatNameString(pfmtetc->cfFormat)));

	// Ignore pfmtetc.ptd.  All supported data formats are device-independent.

	if (pfmtetc->dwAspect == DVASPECT_CONTENT)
	{
		if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
		{
			if (pfmtetc->cfFormat == g_cfConfLink)
				hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
			else if (pfmtetc->cfFormat == CF_TEXT)
				hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
			else if (pfmtetc->cfFormat == g_cfFileGroupDescriptor)
				hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
			else if (pfmtetc->cfFormat == g_cfFileContents)
				hr = (! pfmtetc->lindex) ? S_OK : DV_E_LINDEX;
			else
				hr = DV_E_FORMATETC;
		}
		else
			hr = DV_E_TYMED;
	}
	else
	{
		hr = DV_E_DVASPECT;
	}

	if (hr == S_OK)
	{
		TRACE_OUT(("CConfLink::QueryGetData(): Clipboard format %s supported.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}
	else
	{
		TRACE_OUT(("CConfLink::QueryGetData(): Clipboard format %s not supported.",
					GetClipboardFormatNameString(pfmtetc->cfFormat)));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::QueryGetData, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::GetCanonicalFormatEtc(	PFORMATETC pfmtetcIn,
															PFORMATETC pfmtetcOut)
{
	HRESULT hr;

	DebugEntry(CConfLink::GetCanonicalFormatEtc);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetcIn, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pfmtetcOut, FORMATETC));

	hr = QueryGetData(pfmtetcIn);

	if (hr == S_OK)
	{
		*pfmtetcOut = *pfmtetcIn;

		if (pfmtetcIn->ptd == NULL)
		{
			hr = DATA_S_SAMEFORMATETC;
		}
		else
		{
			pfmtetcIn->ptd = NULL;
			ASSERT(hr == S_OK);
		}
	}
	else
	{
		ZeroMemory(pfmtetcOut, sizeof(*pfmtetcOut));
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(FAILED(hr) ||
	IS_VALID_STRUCT_PTR(pfmtetcOut, CFORMATETC));

	DebugExitHRESULT(CConfLink::GetCanonicalFormatEtc, hr);

	return(hr);
}

// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::SetData(	PFORMATETC pfmtetc,
												PSTGMEDIUM pstgmed,
												BOOL bRelease)
{
	HRESULT hr;

	DebugEntry(CConfLink::SetData);

	// bRelease may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

	hr = DV_E_FORMATETC;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::SetData, hr);

	return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::EnumFormatEtc(	DWORD dwDirFlags,
													PIEnumFORMATETC *ppiefe)
{
	HRESULT hr;

	DebugEntry(CConfLink::EnumFormatEtc);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(FLAGS_ARE_VALID(dwDirFlags, ALL_DATADIR_FLAGS));
	ASSERT(IS_VALID_WRITE_PTR(ppiefe, PIEnumFORMATETC));

	*ppiefe = NULL;

	if (dwDirFlags == DATADIR_GET)
	{
		FORMATETC rgfmtetc[] =
		{
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
			{ 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
		};
		PEnumFormatEtc pefe;

		rgfmtetc[0].cfFormat = (CLIPFORMAT)g_cfConfLink;
		rgfmtetc[1].cfFormat = CF_TEXT;
		rgfmtetc[2].cfFormat = (CLIPFORMAT)g_cfFileGroupDescriptor;
		rgfmtetc[3].cfFormat = (CLIPFORMAT)g_cfFileContents;

		pefe = new ::EnumFormatEtc(rgfmtetc, ARRAY_ELEMENTS(rgfmtetc));

		if (pefe)
		{
			hr = pefe->Status();

			if (hr == S_OK)
			{
				*ppiefe = pefe;
			}
			else
			{
				delete pefe;
				pefe = NULL;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// BUGBUG: Implement IDataObject::SetData() and add support for
		// DATADIR_SET here.
		hr = E_NOTIMPL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
	IS_VALID_INTERFACE_PTR(*ppiefe, IEnumFORMATETC)) || (FAILED(hr) && ! *ppiefe));

	DebugExitHRESULT(CConfLink::EnumFormatEtc, hr);

	return(hr);
}

// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::DAdvise(	PFORMATETC pfmtetc,
												DWORD dwAdviseFlags,
												PIAdviseSink piadvsink,
												PDWORD pdwConnection)
{
	HRESULT hr;

	DebugEntry(CConfLink::DAdvise);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(FLAGS_ARE_VALID(dwAdviseFlags, ALL_ADVISE_FLAGS));
	ASSERT(IS_VALID_INTERFACE_PTR(piadvsink, IAdviseSink));
	ASSERT(IS_VALID_WRITE_PTR(pdwConnection, DWORD));

	*pdwConnection = 0;
	hr = OLE_E_ADVISENOTSUPPORTED;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK && *pdwConnection) ||
			(FAILED(hr) && ! *pdwConnection));

	DebugExitHRESULT(CConfLink::DAdvise, hr);

	return(hr);
}

HRESULT STDMETHODCALLTYPE CConfLink::DUnadvise(DWORD dwConnection)
{
	HRESULT hr;

	DebugEntry(CConfLink::DUnadvise);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(dwConnection);

	hr = OLE_E_ADVISENOTSUPPORTED;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::DUnadvise, hr);

	return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::EnumDAdvise(PIEnumSTATDATA *ppiesd)
{
	HRESULT hr;

	DebugEntry(CConfLink::EnumDAdvise);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_WRITE_PTR(ppiesd, PIEnumSTATDATA));

	*ppiesd = NULL;
	hr = OLE_E_ADVISENOTSUPPORTED;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK && IS_VALID_INTERFACE_PTR(*ppiesd, IEnumSTATDATA)) ||
			(FAILED(hr) && ! *ppiesd));

	DebugExitHRESULT(CConfLink::EnumDAdvise, hr);

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clenumft.hpp ===
/*
 * enumfmte.hpp - EnumFormatEtc class description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _ENUMFMTE_HPP_
#define _ENUMFMTE_HPP_

/* Classes
 **********/

class EnumFormatEtc : public RefCount,
                      public IEnumFORMATETC
{
private:
   PFORMATETC m_pfmtetc;
   ULONG m_ulcFormats;   
   ULONG m_uliCurrent;

public:
   EnumFormatEtc(CFORMATETC rgcfmtetc[], ULONG ulcFormats);
   ~EnumFormatEtc(void);

   // IEnumFormatEtc methods

   HRESULT STDMETHODCALLTYPE Next(ULONG ulcToFetch, PFORMATETC pfmtetc, PULONG pulcFetched);
   HRESULT STDMETHODCALLTYPE Skip(ULONG ulcToSkip);
   HRESULT STDMETHODCALLTYPE Reset(void);
   HRESULT STDMETHODCALLTYPE Clone(PIEnumFORMATETC *ppiefe);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

   // other methods

   HRESULT STDMETHODCALLTYPE Status(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCEnumFormatEtc(const EnumFormatEtc *pcefe);

#endif

};
DECLARE_STANDARD_TYPES(EnumFormatEtc);

#endif // _ENUMFMTE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clenumft.cpp ===
/*
 * enumfmte.cpp - EnumFormatEtc class implementation.
 *
 * Taken from URL code - essentially identical to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "clrefcnt.hpp"
#include "clenumft.hpp"


/***************************** Private Functions *****************************/


#ifdef DEBUG

BOOL IsValidArrayOfFORMATETCs(CFORMATETC rgcfmtetc[],
                                           ULONG ulcFormats)
{
   BOOL bResult = TRUE;
   ULONG ul;

   for (ul = 0; ul < ulcFormats; ul++)
      bResult = (EVAL(IS_VALID_STRUCT_PTR(&(rgcfmtetc[ul]), CFORMATETC)) &&
                 bResult);

   return(bResult);
}


BOOL IsValidPCEnumFormatEtc(PCEnumFormatEtc pcefe)
{
   return(IS_VALID_READ_PTR(pcefe, CEnumFormatEtc) &&
          EVAL(IsValidArrayOfFORMATETCs(pcefe->m_pfmtetc, pcefe->m_ulcFormats)) &&
          EVAL(pcefe->m_uliCurrent <= pcefe->m_ulcFormats) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pcefe, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIEnumFORMATETC)pcefe, IEnumFORMATETC));
}

#endif


/********************************** Methods **********************************/


EnumFormatEtc::EnumFormatEtc(CFORMATETC rgcfmtetc[], ULONG ulcFormats) :
   RefCount(NULL)
{
   DebugEntry(EnumFormatEtc::EnumFormatEtc);

   // Don't validate this until after construction.

   ASSERT(IsValidArrayOfFORMATETCs(rgcfmtetc, ulcFormats));

   m_pfmtetc = new(FORMATETC[ulcFormats]);

   if (m_pfmtetc)
   {
      CopyMemory(m_pfmtetc, rgcfmtetc, ulcFormats * sizeof(rgcfmtetc[0]));
      m_ulcFormats = ulcFormats;
   }
   else
      m_ulcFormats = 0;

   m_uliCurrent = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitVOID(EnumFormatEtc::EnumFormatEtc);

   return;
}


EnumFormatEtc::~EnumFormatEtc(void)
{
   DebugEntry(EnumFormatEtc::~EnumFormatEtc);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (m_pfmtetc)
   {
      delete m_pfmtetc;
      m_pfmtetc = NULL;
   }

   m_ulcFormats = 0;
   m_uliCurrent = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitVOID(EnumFormatEtc::~EnumFormatEtc);

   return;
}


ULONG STDMETHODCALLTYPE EnumFormatEtc::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(EnumFormatEtc::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitULONG(EnumFormatEtc::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE EnumFormatEtc::Release(void)
{
   ULONG ulcRef;

   DebugEntry(EnumFormatEtc::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   ulcRef = RefCount::Release();

   DebugExitULONG(EnumFormatEtc::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::QueryInterface(REFIID riid,
														PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(EnumFormatEtc::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IEnumFORMATETC)
   {
      *ppvObject = (PIEnumFORMATETC)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIEnumFORMATETC)*ppvObject, IEnumFORMATETC));
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Returning IEnumFORMATETC."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Called on unknown interface."));
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   
   // removed by ChrisPi - CINTERFACE undeclared identifier
   //ASSERT(FAILED(hr) ||
   //       IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(EnumFormatEtc::QueryInterface, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Next(ULONG ulcToFetch,
                                              PFORMATETC pfmtetc,
                                              PULONG pulcFetched)
{
   HRESULT hr = S_FALSE;
   ULONG ulcFetched;

   DebugEntry(EnumFormatEtc::Next);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (m_uliCurrent < m_ulcFormats)
   {
      ULONG ulcCanFetch = m_ulcFormats - m_uliCurrent;

      ulcFetched = min(ulcCanFetch, ulcToFetch);

      CopyMemory(pfmtetc, &(m_pfmtetc[m_uliCurrent]),
                 ulcFetched * sizeof(*pfmtetc));

      m_uliCurrent += ulcFetched;
   }
   else
      // End of the list.
      ulcFetched = 0;

   if (pulcFetched)
      *pulcFetched = ulcFetched;
   else
      ASSERT(ulcToFetch == 1);

   if (ulcFetched < ulcToFetch)
      hr = S_FALSE;
   else
   {
      ASSERT(ulcFetched == ulcToFetch);
      hr = S_OK;
   }

   TRACE_OUT(("EnumFormatEtc::Next(): Fetched %lu FORMATETCs.",
              ulcFetched));

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((((hr == S_OK &&
             EVAL((! pulcFetched &&
                   ulcToFetch == 1) ||
                  *pulcFetched == ulcToFetch)) ||
            (hr == S_FALSE &&
             EVAL((! pulcFetched &&
                   ulcToFetch == 1) ||
                  *pulcFetched < ulcToFetch))) &&
            EVAL((! pulcFetched &&
                  IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC)) ||
                 IsValidArrayOfFORMATETCs(pfmtetc, *pulcFetched))) ||
          (FAILED(hr) &&
           EVAL((! pulcFetched &&
                 ulcToFetch == 1) ||
                ! *pulcFetched)));

   DebugExitHRESULT(EnumFormatEtc::Next, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Skip(ULONG ulcToSkip)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Skip);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (ulcToSkip <= m_ulcFormats - m_uliCurrent)
   {
      m_uliCurrent += ulcToSkip;
      hr = S_OK;

      TRACE_OUT(("EnumFormatEtc::Skip(): Skipped %lu FORMATETCs, as requested.",
                 ulcToSkip));
   }
   else
   {
      TRACE_OUT(("EnumFormatEtc::Skip(): Skipped %lu of %lu FORMATETCs.",
                 m_ulcFormats - m_uliCurrent,
                 ulcToSkip));

      m_uliCurrent = m_ulcFormats;
      hr = S_FALSE;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((hr == S_OK &&
           m_uliCurrent <= m_ulcFormats) ||
          (hr == S_FALSE &&
           m_uliCurrent == m_ulcFormats));

   DebugExitHRESULT(EnumFormatEtc::Skip, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Reset(void)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Reset);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   m_uliCurrent = 0;
   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT(hr == S_OK &&
          ! m_uliCurrent);

   DebugExitHRESULT(EnumFormatEtc::Reset, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Clone(PIEnumFORMATETC *ppiefe)
{
   HRESULT hr;
   PEnumFormatEtc pefe;

   DebugEntry(EnumFormatEtc::Clone);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   pefe = new ::EnumFormatEtc(m_pfmtetc, m_ulcFormats);

   if (pefe)
   {
      hr = pefe->Status();

      if (hr == S_OK)
      {
         hr = pefe->Skip(m_uliCurrent);

         if (hr == S_OK)
            *ppiefe = pefe;
         else
            hr = E_UNEXPECTED;
      }

      if (hr != S_OK)
      {
         delete pefe;
         pefe = NULL;
      }
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((hr == S_OK &&
           IS_VALID_INTERFACE_PTR(*ppiefe, IEnumFORMATETC)) ||
          (FAILED(hr) &&
           ! *ppiefe));

   DebugExitHRESULT(EnumFormatEtc::Clone, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Status(void)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Status);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   hr = (m_pfmtetc ? S_OK : E_OUTOFMEMORY);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitHRESULT(EnumFormatEtc::Status, hr);

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clrefcnt.hpp ===
/*
 * refcount.hpp - RefCount class description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _REFCOUNT_HPP_
#define _REFCOUNT_HPP_

/* Types
 ********/

// RefCount destructor callback function

typedef void (*OBJECTDESTROYEDPROC)(void);


/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;
   OBJECTDESTROYEDPROC m_ObjectDestroyed;

public:
   RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCRefCount(const RefCount *pcrefcnt);

#endif

};
DECLARE_STANDARD_TYPES(RefCount);

VOID DllLock(void);
VOID DllRelease(void);
VOID STDMETHODCALLTYPE DLLObjectDestroyed(void);


#endif // _REFCOUNT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clpersis.hpp ===
/*
 * persist.hpp - IPersist, IPersistFile, and IPersistStream implementation
 *               description.
 *
 * Taken from URL code by ChrisPi 9-12-95
 *
 */


/* Global Constants
 *******************/

// persist.cpp

extern const UINT g_ucMaxURLLen;
extern const char g_cszURLLeftDelimiter[];
extern const char g_cszURLRightDelimiter[];
extern const char g_cszURLPrefix[];
extern const UINT g_ucbURLPrefixLen;
extern const char g_cszURLExt[];
extern const char g_cszURLDefaultFileNamePrompt[];
extern const char g_cszCRLF[];


/* Prototypes
 *************/

// persist.cpp

extern HRESULT UnicodeToANSI(LPCOLESTR pcwszUnicode, PSTR *ppszANSI);
extern HRESULT ANSIToUnicode(PCSTR pcszANSI, LPOLESTR *ppwszUnicode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clprpsht.cpp ===
#include "precomp.h"
#include <shellapi.h>
#include "clCnfLnk.hpp"
#include "resource.h"

#if 0

typedef struct _clps
{
   PROPSHEETPAGE psp;
   PCConfLink pconflink;
   char rgchIconFile[MAX_PATH_LEN];
}
CLPS;
DECLARE_STANDARD_TYPES(CLPS);

UINT CALLBACK CLPSCallback(HWND hwnd, UINT uMsg,
										LPPROPSHEETPAGE ppsp)
{
	UINT uResult = TRUE;
	PCLPS pclps = (PCLPS)ppsp;

	// uMsg may be any value.

	ASSERT(! hwnd ||
	      IS_VALID_HANDLE(hwnd, WND));
	ASSERT(IS_VALID_STRUCT_PTR((PCCLPS)ppsp, CCLPS));

	switch (uMsg)
	{
		case PSPCB_CREATE:
			TRACE_OUT(("CLPSCallback(): Received PSPCB_CREATE."));
			break;

		case PSPCB_RELEASE:
			TRACE_OUT(("CLPSCallback(): Received PSPCB_RELEASE."));
						pclps->pconflink->Release();
			break;

		default:
			TRACE_OUT(("CLPSCallback(): Unhandled message %u.",
						uMsg));
			break;
	}

	return(uResult);
}

void SetCLPSFileNameAndIcon(HWND hdlg)
{
	HRESULT hr;
	PCConfLink pconflink;
	char rgchFile[MAX_PATH_LEN];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	hr = pconflink->GetCurFile(rgchFile, sizeof(rgchFile));

	if (hr == S_OK)
	{
		SHFILEINFO shfi;
		DWORD dwResult;

		dwResult = SHGetFileInfo(	rgchFile, 0, &shfi, sizeof(shfi),
									(SHGFI_DISPLAYNAME | SHGFI_ICON));

		if (dwResult)
		{
			PSTR pszFileName;

			pszFileName = (PSTR)ExtractFileName(shfi.szDisplayName);

			EVAL(SetDlgItemText(hdlg, IDC_NAME, pszFileName));

			TRACE_OUT(("SetCLPSFileNameAndIcon(): Set property sheet file name to \"%s\".",
			        pszFileName));

			ASSERT(IS_VALID_HANDLE(shfi.hIcon, ICON));

			HICON hIconOld = (HICON) SendDlgItemMessage(hdlg, 
														IDC_FILEICON,
														STM_SETICON,
														(WPARAM) shfi.hIcon,
														0);
			if (NULL != hIconOld)
			{
				DestroyIcon(hIconOld);
			}
		}
		else
		{
			hr = E_FAIL;

			TRACE_OUT(	("SetCLPSFileNameAndIcon(): SHGetFileInfo() failed, returning %lu.",
						dwResult));
		}
	}
	else
	{
		TRACE_OUT(("SetCLPSFileNameAndIcon(): GetCurFile() failed, returning %s.",
					GetHRESULTString(hr)));
	}

	if (hr != S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDC_NAME, EMPTY_STRING));
	}

	return;
}


void SetCLPSName(HWND hdlg)
{
	PCConfLink pconflink;
	HRESULT hr;
	PSTR pszName;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	hr = pconflink->GetName(&pszName);

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFNAME, pszName));

		TRACE_OUT(("SetCLPSURL(): Set property sheet Name to \"%s\".",
					pszName));

		PIMalloc pMalloc = NULL;
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			pMalloc->Free(pszName);
			pMalloc->Release();
			pMalloc = NULL;
			
			pszName = NULL;
		}
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFNAME, EMPTY_STRING));
	}

	return;
}

void SetCLPSAddress(HWND hdlg)
{
	PCConfLink pconflink;
	HRESULT hr;
	PSTR pszAddress;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	hr = pconflink->GetAddress(&pszAddress);

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFADDR, pszAddress));

		TRACE_OUT(("SetCLPSURL(): Set property sheet Address to \"%s\".",
					pszAddress));

		PIMalloc pMalloc = NULL;
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			pMalloc->Free(pszAddress);
			pMalloc->Release();
			pMalloc = NULL;
			
			pszAddress = NULL;
		}
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDC_CONFADDR, EMPTY_STRING));
	}

	return;
}

BOOL CLPS_InitDialog(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	PCConfLink pconflink;

	// wparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));
	ASSERT(IS_VALID_STRUCT_PTR((PCCLPS)lparam, CCLPS));

	SetWindowLong(hdlg, DWL_USER, lparam);

	pconflink = ((PCLPS)lparam)->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CCConfLink));

	// Initialize control contents.

	SetCLPSFileNameAndIcon(hdlg);
	SetCLPSName(hdlg);
	SetCLPSAddress(hdlg);

	return(TRUE);
}


BOOL CLPS_Destroy(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	PCConfLink pconflink;

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pconflink = ((PCLPS)GetWindowLong(hdlg, DWL_USER))->pconflink;
	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CConfLink));

	SetWindowLong(hdlg, DWL_USER, NULL);

	return(TRUE);
}

BOOL CALLBACK CLPS_DlgProc(HWND hdlg, UINT uMsg, WPARAM wparam,
										LPARAM lparam)
{
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
			bMsgHandled = CLPS_InitDialog(hdlg, wparam, lparam);
			break;

		case WM_DESTROY:
			bMsgHandled = CLPS_Destroy(hdlg, wparam, lparam);
			break;

#if 0
		case WM_COMMAND:
			bMsgHandled = CLPS_Command(hdlg, wparam, lparam);
			break;

		case WM_NOTIFY:
			bMsgHandled = CLPS_Notify(hdlg, wparam, lparam);
			break;
#endif // 0

#ifdef CLPSHELP
		case WM_HELP:
			WinHelp((HWND)(((LPHELPINFO)lparam)->hItemHandle),
					ISPS_GetHelpFileFromControl((HWND)(((LPHELPINFO)lparam)->hItemHandle)),
					HELP_WM_HELP, (DWORD)(PVOID)s_rgdwHelpIDs);
			bMsgHandled = TRUE;
			break;

		case WM_CONTEXTMENU:
		{
			POINT pt;

			LPARAM_TO_POINT(lparam, pt);
			EVAL(ScreenToClient(hdlg, &pt));

			WinHelp((HWND)wparam,
					ISPS_GetHelpFileFromControl(ChildWindowFromPoint(hdlg, pt)),
					HELP_CONTEXTMENU, (DWORD)(PVOID)s_rgdwHelpIDs);
			bMsgHandled = TRUE;
			break;
		}
#endif // CLSPSHELP

		default:
			break;
	}

	return(bMsgHandled);
}

HRESULT AddCLPS(	PCConfLink pconflink,
								LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam)
{
	HRESULT hr;
	CLPS clps;
	HPROPSHEETPAGE hpsp;

	// lparam may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(pconflink, CConfLink));
	ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

	ZeroMemory(&clps, sizeof(clps));

	clps.psp.dwSize = sizeof(clps);
	clps.psp.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
	clps.psp.hInstance = g_hInst;
	clps.psp.pszTemplate = MAKEINTRESOURCE(IDD_CONFLINKPROP);
	clps.psp.pfnDlgProc = (DLGPROC) &CLPS_DlgProc;
	clps.psp.pfnCallback = &CLPSCallback;

	clps.pconflink = pconflink;

	ASSERT(IS_VALID_STRUCT_PTR(&clps, CCLPS));

	hpsp = CreatePropertySheetPage(&(clps.psp));

	if (hpsp)
	{
		if ((*pfnAddPage)(hpsp, lparam))
		{
			pconflink->AddRef();
			hr = S_OK;
			TRACE_OUT(("AddCLPS(): Added Conference Link property sheet."));
		}
		else
		{
			DestroyPropertySheetPage(hpsp);

			hr = E_FAIL;
			WARNING_OUT(("AddCLPS(): Callback to add property sheet failed."));
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	return(hr);
}
#endif // 0

HRESULT STDMETHODCALLTYPE CConfLink::Initialize(LPCITEMIDLIST pcidlFolder,
												LPDATAOBJECT pido,
												HKEY hkeyProgID)
{
	HRESULT hr;
	FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM stgmed;

	DebugEntry(CConfLink::Initialize);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(	!pcidlFolder ||
			IS_VALID_STRUCT_PTR(pcidlFolder, const ITEMIDLIST));
	ASSERT(IS_VALID_INTERFACE_PTR(pido, IDataObject));
	ASSERT(IS_VALID_HANDLE(hkeyProgID, KEY));

	hr = pido->GetData(&fmtetc, &stgmed);

	if (hr == S_OK)
	{
		UINT ucbPathLen;
		PSTR pszFile;

		// (+ 1) for null terminator.

		ucbPathLen = DragQueryFile((HDROP)(stgmed.hGlobal), 0, NULL, 0) + 1;
		ASSERT(ucbPathLen > 0);

		pszFile = new(char[ucbPathLen]);

		if (pszFile)
		{
			EVAL(DragQueryFile((HDROP)(stgmed.hGlobal), 0, pszFile, ucbPathLen) == ucbPathLen - 1);
			ASSERT(IS_VALID_STRING_PTR(pszFile, STR));
			ASSERT((UINT)lstrlen(pszFile) == ucbPathLen - 1);

			hr = LoadFromFile(pszFile, TRUE);

			delete pszFile;
			pszFile = NULL;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		EVAL(MyReleaseStgMedium(&stgmed) == S_OK);
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::Initialize, hr);

	return(hr);
}

#if 0

HRESULT STDMETHODCALLTYPE CConfLink::AddPages(	LPFNADDPROPSHEETPAGE pfnAddPage,
												LPARAM lparam)
{
	HRESULT hr;

	DebugEntry(CConfLink::AddPages);

	// lparam may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

	hr = AddCLPS(this, pfnAddPage, lparam);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::AddPages, hr);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::ReplacePage(	UINT uPageID,
													LPFNADDPROPSHEETPAGE pfnReplaceWith,
													LPARAM lparam)
{
	HRESULT hr;

	DebugEntry(CConfLink::ReplacePage);

	// lparam may be any value.
	// uPageID may be any value.

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_CODE_PTR(pfnReplaceWith, LPFNADDPROPSHEETPAGE));

	hr = E_NOTIMPL;

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitHRESULT(CConfLink::ReplacePage, hr);

	return(hr);
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\dlginfo.h ===
// File: dlgInfo.h

#ifndef _CDLGINFO_H_
#define _CDLGINFO_H_

#include "imsconf3.h"

class CDlgInfo
{
private:
	HWND   m_hwnd;
	HWND   m_hwndCombo;

	VOID InitCtrl(NM_SYSPROP nmProp, HWND hwnd, int cchMax);
	VOID InitCategory(void);
	VOID ValidateData(void);
	BOOL FSetProperty(NM_SYSPROP nmProp, int id);
	BOOL FSaveData(void);
	BOOL FSetCategory(void);

public:
	CDlgInfo();
	~CDlgInfo();

	INT_PTR DoModal(HWND hwndParent=HWND_DESKTOP);
	
	VOID OnInitDialog(void);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGINFO_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clrefcnt.cpp ===
/*
 * refcount.cpp - RefCount class implementation.
 *
 * Taken from URL code - essentially identical to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "clrefcnt.hpp"

/****************************** Public Functions *****************************/


#ifdef DEBUG

BOOL IsValidPCRefCount(PCRefCount pcrefcnt)
{
   // m_ulcRef may be any value.

   return(IS_VALID_READ_PTR(pcrefcnt, CRefCount) &&
          (! pcrefcnt->m_ObjectDestroyed ||
           IS_VALID_CODE_PTR(pcrefcnt->m_ObjectDestroyed, OBJECTDESTROYEDPROC)));
}

#endif


/********************************** Methods **********************************/


RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   DebugEntry(RefCount::RefCount);

   /* Don't validate this until after initialization. */

   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   m_ulcRef = 1;
   m_ObjectDestroyed = ObjectDestroyed;
   DBGAPI_REF("Ref: %08X c=%d (created)", this, m_ulcRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitVOID(RefCount::RefCount);

   return;
}


RefCount::~RefCount(void)
{
   DebugEntry(RefCount::~RefCount);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   // m_ulcRef may be any value.
   DBGAPI_REF("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

   if (m_ObjectDestroyed)
   {
      m_ObjectDestroyed();
      m_ObjectDestroyed = NULL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitVOID(RefCount::~RefCount);

   return;
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   DebugEntry(RefCount::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   ASSERT(m_ulcRef < ULONG_MAX);
   m_ulcRef++;
   DBGAPI_REF("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitULONG(RefCount::AddRef, m_ulcRef);

   return(m_ulcRef);
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
   ULONG ulcRef;

   DebugEntry(RefCount::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   if (EVAL(m_ulcRef > 0))
      m_ulcRef--;

   ulcRef = m_ulcRef;
   DBGAPI_REF("Ref: %08X c=%d (Release)", this, m_ulcRef);

   if (! ulcRef)
      delete this;

   DebugExitULONG(RefCount::Release, ulcRef);

   return(ulcRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\dlginfo.cpp ===
// File: dlginfo.cpp

#include "precomp.h"
#include <windowsx.h>
#include "resource.h"
#include "help_ids.h"
#include "nmhelp.h"

#include "mrulist2.h"

#include "dlginfo.h"
#include "nmsysinfo.h"

extern HINSTANCE g_hInst;

const int MRU_MAX_ENTRIES = 15; // This MUST be the same as the constant in ui\conf\mrulist.h

const int CCHMAXSZ =            256;   // Maximum generic string length
const int CCHMAXSZ_EMAIL =      128;   // Maximum length of an email name
const int CCHMAXSZ_FIRSTNAME =  128;   // Maximum length of a first name
const int CCHMAXSZ_LASTNAME =   128;   // Maximum length of a last name
const int CCHMAXSZ_NAME =       256;   // Maximum user name, displayed (combined first+last name)
const int CCHMAXSZ_LOCATION =   128;   // Maximum length of a Location
const int CCHMAXSZ_SERVER =     128;   // Maximum length of an address

///////////////////////////////////////////////////////////////////////////
// Local Data

static const DWSTR _rgMruServer[] = {
	{1, DIR_MRU_KEY},
	{MRUTYPE_SZ, TEXT("Name")},
};

static const DWORD _mpIdHelpDlgInfo[] = {
	IDG_UI_MYINFO,        IDH_MYINFO_MYINFO,
	IDE_UI_FIRSTNAME,     IDH_MYINFO_FIRSTNAME,
	IDE_UI_LASTNAME,      IDH_MYINFO_LASTNAME,
	IDE_UI_EMAIL,         IDH_MYINFO_EMAIL,
	IDE_UI_LOCATION,      IDH_MYINFO_LOCATION,
	IDG_UI_DIRECTORY,     IDH_MYINFO_ULS_SERVER,
	IDE_UI_DIRECTORY,     IDH_MYINFO_ULS_SERVER,
	0, 0   // terminator
};


// Local functions
VOID FillServerComboBox(HWND hwndCombo);
BOOL FLegalEmailName(HWND hdlg, UINT id);
BOOL FLegalEmailSz(PTSTR pszName);
BOOL FLoadString(UINT id, LPTSTR lpsz, UINT cch);
BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax);
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cchMax);
BOOL FEmptyDlgItem(HWND hdlg, UINT id);
VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast);

BOOL FGetPropertySz(NM_SYSPROP nmProp, LPTSTR psz, int cchMax);
BOOL FSetPropertySz(NM_SYSPROP nmProp, LPCTSTR pcsz);
CMRUList2 * GetMruListServer(void);


/*  C  D L G  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: CDlgInfo

-------------------------------------------------------------------------*/
CDlgInfo::CDlgInfo():
	m_hwnd(NULL)
{
}

CDlgInfo::~CDlgInfo(void)
{
}

/*  D O  M O D A L  */
/*-------------------------------------------------------------------------
    %%Function: DoModal

-------------------------------------------------------------------------*/
INT_PTR CDlgInfo::DoModal(HWND hwndParent)
{
	return DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_USERINFO),
						hwndParent, CDlgInfo::DlgProc, (LPARAM) this);
}

/*  I N I T  C T R L  */
/*-------------------------------------------------------------------------
    %%Function: InitCtrl

-------------------------------------------------------------------------*/
VOID CDlgInfo::InitCtrl(NM_SYSPROP nmProp, HWND hwnd, int cchMax)
{
	::SendMessage(hwnd, WM_SETFONT, (WPARAM)(HFONT)::GetStockObject(DEFAULT_GUI_FONT), 0);
	Edit_LimitText(hwnd, cchMax);

	TCHAR sz[MAX_PATH];
	if (!FGetPropertySz(nmProp, sz, CCHMAX(sz)))
		return;

	::SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM) sz);
}

/*  F  S E T  P R O P E R T Y  */
/*-------------------------------------------------------------------------
    %%Function: FSetProperty

-------------------------------------------------------------------------*/
BOOL CDlgInfo::FSetProperty(NM_SYSPROP nmProp, int id)
{
	TCHAR sz[MAX_PATH];
	if (0 == GetDlgItemTextTrimmed(m_hwnd, id, sz, CCHMAX(sz)))
		return FALSE;

	return FSetPropertySz(nmProp, sz);
}


/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgInfo::OnInitDialog(void)
{
	InitCtrl(NM_SYSPROP_FIRST_NAME, GetDlgItem(m_hwnd, IDE_UI_FIRSTNAME), CCHMAXSZ_FIRSTNAME-1);
	InitCtrl(NM_SYSPROP_LAST_NAME,  GetDlgItem(m_hwnd, IDE_UI_LASTNAME), CCHMAXSZ_LASTNAME-1);
	InitCtrl(NM_SYSPROP_EMAIL_NAME, GetDlgItem(m_hwnd, IDE_UI_EMAIL), CCHMAXSZ_EMAIL-1);
	InitCtrl(NM_SYSPROP_USER_CITY, GetDlgItem(m_hwnd, IDE_UI_LOCATION), CCHMAXSZ_LOCATION-1);

	m_hwndCombo = GetDlgItem(m_hwnd, IDE_UI_DIRECTORY);
	InitCtrl(NM_SYSPROP_SERVER_NAME, m_hwndCombo, CCHMAXSZ_SERVER-1);
	FillServerComboBox(m_hwndCombo);

	ValidateData();
}


/*  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: DlgProc

-------------------------------------------------------------------------*/
INT_PTR CALLBACK CDlgInfo::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		ASSERT(NULL != lParam);
		::SetWindowLongPtr(hdlg, DWLP_USER, lParam);

		CDlgInfo * pDlg = (CDlgInfo*) lParam;
		pDlg->m_hwnd = hdlg;
		pDlg->OnInitDialog();
		return TRUE; // default focus is ok
	}

	case WM_COMMAND:
	{
		CDlgInfo * pDlg = (CDlgInfo*) GetWindowLongPtr(hdlg, DWLP_USER);
		if (NULL != pDlg)
		{
			pDlg->OnCommand(wParam, lParam);
		}
		break;
	}

	case WM_HELP:
		DoHelp(lParam, _mpIdHelpDlgInfo);
		break;
	case WM_CONTEXTMENU:
		DoHelpWhatsThis(wParam, _mpIdHelpDlgInfo);
		break;

	default:
		break;
	}

	return FALSE;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
BOOL CDlgInfo::OnCommand(WPARAM wParam, LPARAM lParam)
{
	ASSERT(NULL != m_hwnd);

	WORD wCmd = GET_WM_COMMAND_ID(wParam, lParam);
	switch (wCmd)
	{
	case IDE_UI_FIRSTNAME:
	case IDE_UI_LASTNAME:
	case IDE_UI_EMAIL:
	{
		if (GET_WM_COMMAND_CMD(wParam,lParam) == EN_CHANGE)
		{
			ValidateData();
		}
		break;
	}
	case IDE_UI_DIRECTORY:
	{
		switch (GET_WM_COMMAND_CMD(wParam,lParam))
			{
		case CBN_SELCHANGE:
			// The data isn't available yet
			PostMessage(m_hwnd, WM_COMMAND, MAKELONG(IDE_UI_DIRECTORY, CBN_EDITCHANGE), lParam);
			break;
		case CBN_EDITCHANGE:
			ValidateData();
		default:
			break;
			}
		break;
	}

	case IDOK:
	{
		if (FSaveData())
		{
			::EndDialog(m_hwnd, wCmd);
		}
		return TRUE;
	}

	case IDCANCEL:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

	default:
		break;
	}

	return FALSE;
}

VOID CDlgInfo::ValidateData(void)
{
	BOOL fOk = !FEmptyDlgItem(m_hwnd, IDE_UI_FIRSTNAME) &&
	           !FEmptyDlgItem(m_hwnd, IDE_UI_LASTNAME) &&
	           !FEmptyDlgItem(m_hwnd, IDE_UI_EMAIL);

	if (fOk)
	{
		TCHAR sz[CCHMAXSZ_EMAIL];
		GetDlgItemTextTrimmed(m_hwnd, IDE_UI_EMAIL, sz, CCHMAX(sz));
		fOk = FLegalEmailSz(sz);
	}

	if (fOk)
	{
		TCHAR sz[CCHMAXSZ_SERVER];
		fOk = (0 != ComboBox_GetText(m_hwndCombo, sz, CCHMAX(sz)));
		if (fOk)
		{
			fOk = 0 != TrimSz(sz);
		}
	}

	Button_Enable(GetDlgItem(m_hwnd, IDOK), fOk);
}



/*  F  S A V E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: FSaveData

-------------------------------------------------------------------------*/
BOOL CDlgInfo::FSaveData(void)
{
	if (!FSetProperty(NM_SYSPROP_FIRST_NAME,  IDE_UI_FIRSTNAME) ||
		!FSetProperty(NM_SYSPROP_LAST_NAME,   IDE_UI_LASTNAME) ||
		!FSetProperty(NM_SYSPROP_EMAIL_NAME,  IDE_UI_EMAIL) ||
		!FSetProperty(NM_SYSPROP_SERVER_NAME, IDE_UI_DIRECTORY)
	   )
	{
		return FALSE;
	}

	// The city name (can be blank)
	TCHAR sz[CCHMAXSZ];
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_LOCATION, sz, CCHMAX(sz));
	FSetPropertySz(NM_SYSPROP_USER_CITY, sz);

	// Full Name = First + Last
	TCHAR szFirst[CCHMAXSZ_FIRSTNAME];
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_FIRSTNAME, szFirst, CCHMAX(szFirst));

	TCHAR szLast[CCHMAXSZ_LASTNAME];
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_LASTNAME, szLast, CCHMAX(szLast));

	CombineNames(sz, CCHMAX(sz), szFirst, szLast);
	if (!FSetPropertySz(NM_SYSPROP_USER_NAME, sz))
		return FALSE;

	// Resolve Name = server / email
	UINT cch = GetDlgItemTextTrimmed(m_hwnd, IDE_UI_DIRECTORY, sz, CCHMAX(sz));
	GetDlgItemTextTrimmed(m_hwnd, IDE_UI_EMAIL, &sz[cch], CCHMAX(sz)-cch);
	return FSetPropertySz(NM_SYSPROP_RESOLVE_NAME, sz);
}


///////////////////////////////////////////////////////////////////////////

/*  C O M B I N E  N A M E S  */
/*-------------------------------------------------------------------------
    %%Function: CombineNames

	Combine the two names into one string.
	The result is a "First Last" (or Intl'd "Last First") string
-------------------------------------------------------------------------*/
VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast)
{
	ASSERT(pszResult);
	TCHAR szFmt[32]; // A small value: String is "%1 %2" or "%2 %1"
	TCHAR sz[CCHMAXSZ_NAME];
	LPCTSTR argw[2];

	argw[0] = pcszFirst;
	argw[1] = pcszLast;

	*pszResult = _T('\0');

	if (!FLoadString(IDS_NAME_ORDER, szFmt, CCHMAX(szFmt)))
		return;

	if (0 == FormatMessage(FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
			szFmt, 0, 0, sz, CCHMAX(sz), (va_list *)argw ))
		return;

	// REVIEW: Use STRCPYN or make this a utility function
	lstrcpyn(pszResult, sz, cchResult);

#ifndef _UNICODE
	// lstrcpyn() can clip a DBCS character in half at the end of the string
	// we need to walk the string with ::CharNext() and replace the last byte
	// with a NULL if the last byte is half of a DBCS char.
	PTSTR pszSource = sz;
	while (*pszSource && (pszSource - sz < cchResult))
	{
		PTSTR pszPrev = pszSource;
		pszSource = ::CharNext(pszPrev);
		// If we've reached the first character that didn't get copied into
		// the destination buffer, and the previous character was a double
		// byte character...
		if (((pszSource - sz) == cchResult) && ::IsDBCSLeadByte(*pszPrev))
		{
			// Replace the destination buffer's last character with '\0'
			// NOTE: pszResult[cchResult - 1] is '\0' thanks to lstrcpyn()
			pszResult[cchResult - 2] = _T('\0');
			break;
		}
	}
#endif // ! _UNICODE
}



/*  F  L E G A L  E M A I L  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailSz

    A legal email name contains only ANSI characters.
	"a-z, A-Z, numbers 0-9 and some common symbols"
	It cannot include extended characters or < > ( ) /
-------------------------------------------------------------------------*/
BOOL FLegalEmailSz(PTSTR pszName)
{
    if (IS_EMPTY_STRING(pszName))
    	return FALSE;

    for ( ; ; )
    {
		UINT ch = (UINT) ((*pszName++) & 0x00FF);
		if (0 == ch)
			break;

		switch (ch)
			{
		default:
			if ((ch > (UINT) _T(' ')) && (ch <= (UINT) _T('~')) )
				break;
		// else fall thru to error code
		case '(': case ')':
		case '<': case '>':
		case '[': case ']':
		case '/': case '\\':
		case ':': case ';':
		case '+':
		case '=':
		case ',':
		case '\"':
			WARNING_OUT(("FLegalEmailSz: Invalid character '%s' (0x%02X)", &ch, ch));
			return FALSE;
			}
	}

	return TRUE;
}


/*  F  L E G A L  E M A I L  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FLegalEmailName

-------------------------------------------------------------------------*/
BOOL FLegalEmailName(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	
	GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz));
	return FLegalEmailSz(sz);
}


/*  F I L L  S E R V E R  C O M B O  B O X  */
/*-------------------------------------------------------------------------
    %%Function: FillServerComboBox

-------------------------------------------------------------------------*/
VOID FillServerComboBox(HWND hwnd)
{
	CMRUList2 * pMru = GetMruListServer();
	if (NULL == pMru)
		return;

	int cServers = pMru->GetNumEntries();
	for (int i = 0; i < cServers; i++)
	{
		int iPos = ComboBox_AddString(hwnd, pMru->PszEntry(i));
		if (iPos < 0)
			break;
	}

	delete pMru;
}

inline VOID DwToSz(DWORD dw, LPTSTR psz)
{
	wsprintf(psz, TEXT("%d"), dw);
}

BOOL FGetPropertySz(NM_SYSPROP nmProp, LPTSTR psz, int cchMax)
{
	HKEY   hkey;
	LPTSTR pszSubKey;
	LPTSTR pszValue;
	bool   fString;

	LONG lVal;

	if (!CNmSysInfoObj::GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString))
	{
		return FALSE;
	}

	RegEntry re(pszSubKey, hkey);
	if (fString)
	{
		lstrcpyn(psz, re.GetString(pszValue), cchMax);
	}
	else
	{
		lVal = re.GetNumber(pszValue, 0);
		DwToSz(lVal, psz);
		ASSERT(lstrlen(psz) < cchMax);
	}

	return TRUE;
}

BOOL FSetPropertySz(NM_SYSPROP nmProp, LPCTSTR pcsz)
{
	HKEY   hkey;
	LPTSTR pszSubKey;
	LPTSTR pszValue;
	bool   fString;

	if (!CNmSysInfoObj::GetKeyDataForProp(nmProp, &hkey, &pszSubKey, &pszValue, &fString))
	{
		return FALSE;
	}

	RegEntry re(pszSubKey, hkey);
	if (fString)
	{
		return (0 == re.SetValue(pszValue, pcsz));
	}

	DWORD dw = DecimalStringToUINT(pcsz);
	return (0 == re.SetValue(pszValue, dw));
}

CMRUList2 * GetMruListServer(void)
{
	CMRUList2 * pMruList = new CMRUList2(&_rgMruServer[0], MRU_MAX_ENTRIES, TRUE /* fReverse */);
	if (NULL != pMruList)
	{
		TCHAR sz[MAX_PATH];
		if (FGetDefaultServer(sz, CCHMAX(sz)))
		{
			pMruList->AddEntry(sz);

			TCHAR	ldapDirectory[ MAX_PATH ];

			if( FLoadString( IDS_MS_INTERNET_DIRECTORY, ldapDirectory, CCHMAX( ldapDirectory ) ) )
			{
				pMruList->DeleteEntry( ldapDirectory );
			}

			RegEntry	re( CONFERENCING_KEY, HKEY_CURRENT_USER );
			TCHAR *		webViewServer	= re.GetString( REGVAL_WEBDIR_DISPLAY_NAME );

			if( lstrlen( webViewServer ) > 0 )
			{
				pMruList->DeleteEntry( webViewServer );
			}

			pMruList->SetDirty(FALSE);
		}
	}

	return pMruList;
}

///////////////////////////////////////////////////////////////////////////

/*  F  V A L I D  U S E R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: FValidUserInfo

    Return TRUE if all of the necessary user information is available.
-------------------------------------------------------------------------*/
BOOL FValidUserInfo(void)
{
	{	// Fail if not a valid installation directory
		TCHAR sz[MAX_PATH];

		if (!GetInstallDirectory(sz) || !FDirExists(sz))
			return FALSE;
	}


	{	// Validate ULS entries
		RegEntry reUls(ISAPI_KEY "\\" REGKEY_USERDETAILS, HKEY_CURRENT_USER);

		if (FEmptySz(reUls.GetString(REGVAL_ULS_EMAIL_NAME)))
			return FALSE;
			
		if (FEmptySz(reUls.GetString(REGVAL_SERVERNAME)))
			return FALSE;

		if (FEmptySz(reUls.GetString(REGVAL_ULS_RES_NAME)))
			return FALSE;
	}

#if 0
	{	// Check Wizard key
		RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

		// check to see if the wizard has been run in UI mode
		DWORD dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_UI, 0);
		BOOL fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
		if (fForceWizard)
		{
			// the wizard has not been run in UI mode, check to see if its been run in NOUI mode
			dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_NOUI, 0);
			fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
		}

		if (fForceWizard)
			return FALSE;  // Wizard has never been run
	}
#endif /* 0 */

	// Everything is properly installed and the Wizard will not run
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////

/*  F  L O A D  S T R I N G */
/*----------------------------------------------------------------------------
    %%Function: FLoadString

	Load a resource string.
	Assumes the buffer is valid and can hold the resource.
----------------------------------------------------------------------------*/
BOOL FLoadString(UINT id, LPTSTR lpsz, UINT cch)
{
	ASSERT(NULL != _Module.GetModuleInstance());
	ASSERT(NULL != lpsz);

	if (0 == ::LoadString(g_hInst, id, lpsz, cch))
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		*lpsz = _T('\0');
		return FALSE;
	}

	return TRUE;
}

/*  F G E T  D E F A U L T  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: FGetDefaultServer

-------------------------------------------------------------------------*/
BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax)
{
	RegEntry ulsKey(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
	LPTSTR psz = ulsKey.GetString(REGVAL_SERVERNAME);
	if (FEmptySz(psz))
		return FALSE;

	lstrcpyn(pszServer, psz, cchMax);
	return TRUE;
}

/*  G E T  D L G  I T E M  T E X T  T R I M M E D  */
/*-------------------------------------------------------------------------
    %%Function: GetDlgItemTextTrimmed

-------------------------------------------------------------------------*/
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cchMax)
{
	UINT cch = GetDlgItemText(hdlg, id, psz, cchMax);
	if (0 != cch)
	{
		cch = TrimSz(psz);
	}

	return cch;
}

/*  F  E M P T Y  D L G  I T E M  */
/*-------------------------------------------------------------------------
    %%Function: FEmptyDlgItem

    Return TRUE if the dialog control is empty
-------------------------------------------------------------------------*/
BOOL FEmptyDlgItem(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	return (0 == GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz)) );
}



/*  V E R I F Y  U S E R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: VerifyUserInfo

    Return S_OK if the data is valid or S_FALSE if it is not.
-------------------------------------------------------------------------*/
HRESULT WINAPI VerifyUserInfo(HWND hwnd, NM_VUI options)
{
	BOOL fOk = FALSE;
	BOOL fShow = (options & NM_VUI_SHOW) || !FValidUserInfo();
	if (fShow)
	{
		CDlgInfo * pDlg = new CDlgInfo();
		if (NULL == pDlg)
			return E_OUTOFMEMORY;

		fOk = (IDOK == pDlg->DoModal(hwnd));
		delete pDlg;
	}

	if (!FValidUserInfo())
	{
		// The app should not continue with this.
		return S_FALSE;
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\clpersis.cpp ===
/*
 * persist.cpp - IPersist, IPersistFile, and IPersistStream implementations for
 *               CConfLink class.
 *
 * Taken from URL code - very similar to DavidDi's original code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "CLinkID.h"
#include "clrefcnt.hpp"
#include "clenumft.hpp"
#include "clCnfLnk.hpp"

/* Global Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

static const UINT g_ucMaxNameLen					= MAX_DIALINFO_STRING; // (was 1024)
static const UINT g_ucMaxAddrLen					= MAX_DIALINFO_STRING; // (was 1024)
static const UINT g_ucMaxRemoteConfNameLen			= MAX_DIALINFO_STRING; // (was 1024)

static const char g_cszConfLinkExt[]                    = ".cnf";
static const char g_cszConfLinkDefaultFileNamePrompt[]  = "*.cnf";
static const char g_cszCRLF[]                      = "\r\n";

static const char g_cszEmpty[] = "";
#define EMPTY_STRING  g_cszEmpty

#pragma data_seg()




/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

// case-insensitive

const char s_cszSectionBefore[]       = "[";
const char s_cszSectionAfter[]        = "]";
const char s_cszKeyValueSep[]         = "=";

const char s_cszConferenceShortcutSection[] = "ConferenceShortcut";

const char s_cszNameKey[]             = "ConfName";
const char s_cszAddressKey[]          = "Address";
const char s_cszTransportKey[]        = "Transport";
const char s_cszRemoteConfNameKey[]   = "RemoteConfName";
const char s_cszCallFlagsKey[]        = "CallFlags";

const char s_cszIconFileKey[]         = "IconFile";
const char s_cszIconIndexKey[]        = "IconIndex";
const char s_cszHotkeyKey[]           = "Hotkey";
const char s_cszWorkingDirectoryKey[] = "WorkingDirectory";
const char s_cszShowCmdKey[]          = "ShowCommand";

const UINT s_ucMaxIconIndexLen        = 1 + 10 + 1; // -2147483647
const UINT s_ucMaxTransportLen        = 10 + 1;  //  4294967296
const UINT s_ucMaxCallFlagsLen        = 10 + 1;  //  4294967296
const UINT s_ucMaxHotkeyLen           = s_ucMaxIconIndexLen;
const UINT s_ucMaxShowCmdLen          = s_ucMaxIconIndexLen;

#pragma data_seg()


/***************************** Private Functions *****************************/


BOOL DeletePrivateProfileString(PCSTR pcszSection, PCSTR pcszKey,
                                             PCSTR pcszFile)
{
   ASSERT(IS_VALID_STRING_PTR(pcszSection, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszKey, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   return(WritePrivateProfileString(pcszSection, pcszKey, NULL, pcszFile));
}

HRESULT ReadConfNameFromFile(PCSTR pcszFile, PSTR *ppszName)
{
   HRESULT hr;
   PSTR pszNewName;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszName, PSTR));

   *ppszName = NULL;

   pszNewName = new(char[g_ucMaxNameLen]);

   if (pszNewName)
   {
      DWORD dwcValueLen;

      dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                            s_cszNameKey, EMPTY_STRING,
                                            pszNewName, g_ucMaxNameLen, pcszFile);

      if (dwcValueLen > 0)
      {
         hr = S_OK;
         
         *ppszName = pszNewName;
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadConfNameFromFile: No Name found in file %s.",
                      pcszFile));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   if (FAILED(hr) ||
       hr == S_FALSE)
   {
      if (pszNewName)
      {
         delete pszNewName;
         pszNewName = NULL;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszName, STR)) ||
          (hr != S_OK &&
           ! *ppszName));

   return(hr);
}


HRESULT WriteConfNameToFile(PCSTR pcszFile, PCSTR pcszName)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszName ||
          IS_VALID_STRING_PTR(pcszName, CSTR));

   if (AnyMeat(pcszName))
   {
      ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
      ASSERT(IS_VALID_STRING_PTR(pcszName, PSTR));

      // (- 1) for null terminator.

      hr = (WritePrivateProfileString(s_cszConferenceShortcutSection, s_cszNameKey, 
   	                                  pcszName, pcszFile)) ? S_OK : E_FAIL;

   }
   else
      hr = (DeletePrivateProfileString(s_cszConferenceShortcutSection, s_cszNameKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}

HRESULT ReadAddressFromFile(PCSTR pcszFile, PSTR *ppszAddress)
{
   HRESULT hr;
   PSTR pszNewAddr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszAddress, PSTR));

   *ppszAddress = NULL;

   pszNewAddr = new(char[g_ucMaxAddrLen]);

   if (pszNewAddr)
   {
      DWORD dwcValueLen;

      dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                            s_cszAddressKey, EMPTY_STRING,
                                            pszNewAddr, g_ucMaxAddrLen, pcszFile);

      if (dwcValueLen > 0)
      {
         hr = S_OK;
         
         *ppszAddress = pszNewAddr;
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadAddressFromFile: No Address found in file %s.",
                      pcszFile));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   if (FAILED(hr) ||
       hr == S_FALSE)
   {
      if (pszNewAddr)
      {
         delete pszNewAddr;
         pszNewAddr = NULL;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszAddress, STR)) ||
          (hr != S_OK &&
           ! *ppszAddress));

   return(hr);
}

HRESULT WriteAddressToFile(PCSTR pcszFile, PCSTR pcszAddress)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszAddress ||
          IS_VALID_STRING_PTR(pcszAddress, CSTR));

   if (AnyMeat(pcszAddress))
   {
      ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
      ASSERT(IS_VALID_STRING_PTR(pcszAddress, PSTR));

      // (- 1) for null terminator.

      hr = (WritePrivateProfileString(s_cszConferenceShortcutSection, s_cszAddressKey, 
   	                                  pcszAddress, pcszFile)) ? S_OK : E_FAIL;

   }
   else
      hr = (DeletePrivateProfileString(s_cszConferenceShortcutSection, s_cszAddressKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}

HRESULT ReadRemoteConfNameFromFile(PCSTR pcszFile,
												PSTR *ppszRemoteConfName)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszRemoteConfName, PSTR));

   *ppszRemoteConfName = NULL;

   PSTR pszNewRemoteConfName = new(char[g_ucMaxAddrLen]);

   if (pszNewRemoteConfName)
   {
      DWORD dwcValueLen;

      dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                            s_cszRemoteConfNameKey, EMPTY_STRING,
                                            pszNewRemoteConfName,
											g_ucMaxRemoteConfNameLen, pcszFile);

      if (dwcValueLen > 0)
      {
         hr = S_OK;
         
         *ppszRemoteConfName = pszNewRemoteConfName;
      }
      else
      {
         hr = S_FALSE;

         TRACE_OUT(("ReadRemoteConfNameFromFile: No RemoteConfName found in file %s.",
                      pcszFile));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   if (FAILED(hr) ||
       hr == S_FALSE)
   {
     delete pszNewRemoteConfName;
     pszNewRemoteConfName = NULL;
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszRemoteConfName, STR)) ||
          (hr != S_OK &&
           ! *ppszRemoteConfName));

   return(hr);
}

HRESULT WriteRemoteConfNameToFile(PCSTR pcszFile,
											   PCSTR pcszRemoteConfName)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszRemoteConfName ||
          IS_VALID_STRING_PTR(pcszRemoteConfName, CSTR));

   if (AnyMeat(pcszRemoteConfName))
   {
      ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
      ASSERT(IS_VALID_STRING_PTR(pcszRemoteConfName, PSTR));

      // (- 1) for null terminator.

      hr = (WritePrivateProfileString(s_cszConferenceShortcutSection, s_cszRemoteConfNameKey, 
   	                                  pcszRemoteConfName, pcszFile)) ? S_OK : E_FAIL;

   }
   else
   {
      hr = (DeletePrivateProfileString(	s_cszConferenceShortcutSection,
										s_cszRemoteConfNameKey,
										pcszFile))
           ? S_OK
           : E_FAIL;
   }

   return(hr);
}

HRESULT ReadTransportFromFile(PCSTR pcszFile, PDWORD pdwTransport)
{
   HRESULT hr;
   char rgchNewTransport[s_ucMaxTransportLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwTransport, INT));

   *pdwTransport = 0;

   dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                         s_cszTransportKey, EMPTY_STRING,
                                         rgchNewTransport,
                                         sizeof(rgchNewTransport), pcszFile);

   if (dwcValueLen > 0)
   {
		*pdwTransport = DecimalStringToUINT(rgchNewTransport);
		hr = S_OK;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadTransportFromFile: No transport found in file %s.",
                 pcszFile));
   }

   ASSERT((hr == S_OK) ||
          (hr == S_FALSE &&
           EVAL(*pdwTransport == 0)));

   return(hr);
}

HRESULT WriteTransportToFile(PCSTR pcszFile, DWORD dwTransport)
{
	HRESULT hr;

	ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

	char rgchTransportRHS[s_ucMaxTransportLen];
	int ncLen;

	ncLen = wsprintf(rgchTransportRHS, "%u", dwTransport);
	ASSERT(ncLen > 0);
	ASSERT(ncLen < sizeof(rgchTransportRHS));
	ASSERT(ncLen == lstrlen(rgchTransportRHS));

	hr = (WritePrivateProfileString(s_cszConferenceShortcutSection,
									s_cszTransportKey, rgchTransportRHS,
									pcszFile))
			? S_OK
			: E_FAIL;

	return(hr);
}

HRESULT ReadCallFlagsFromFile(PCSTR pcszFile, PDWORD pdwCallFlags)
{
   HRESULT hr;
   char rgchNewCallFlags[s_ucMaxCallFlagsLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwCallFlags, INT));

   *pdwCallFlags = 0;

   dwcValueLen = GetPrivateProfileString(s_cszConferenceShortcutSection,
                                         s_cszCallFlagsKey, EMPTY_STRING,
                                         rgchNewCallFlags,
                                         sizeof(rgchNewCallFlags), pcszFile);

   if (dwcValueLen > 0)
   {
		*pdwCallFlags = DecimalStringToUINT(rgchNewCallFlags);
		hr = S_OK;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadCallFlagsFromFile: No CallFlags found in file %s.",
                 pcszFile));
   }

   ASSERT((hr == S_OK) ||
          (hr == S_FALSE &&
           EVAL(*pdwCallFlags == 0)));

   return(hr);
}

HRESULT WriteCallFlagsToFile(PCSTR pcszFile, DWORD dwCallFlags)
{
	HRESULT hr;

	ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

	char rgchCallFlagsRHS[s_ucMaxCallFlagsLen];
	int ncLen;

	ncLen = wsprintf(rgchCallFlagsRHS, "%u", dwCallFlags);
	ASSERT(ncLen > 0);
	ASSERT(ncLen < sizeof(rgchCallFlagsRHS));
	ASSERT(ncLen == lstrlen(rgchCallFlagsRHS));

	hr = (WritePrivateProfileString(s_cszConferenceShortcutSection,
									s_cszCallFlagsKey, rgchCallFlagsRHS,
									pcszFile))
			? S_OK
			: E_FAIL;

	return(hr);
}


#if 0

HRESULT ReadIconLocationFromFile(PCSTR pcszFile,
                                              PSTR *ppszIconFile, PINT pniIcon)
{
   HRESULT hr;
   char rgchNewIconFile[MAX_PATH_LEN];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszIconFile, PSTR));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

   *ppszIconFile = NULL;
   *pniIcon = 0;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszIconFileKey, EMPTY_STRING,
                                         rgchNewIconFile,
                                         sizeof(rgchNewIconFile), pcszFile);

   if (dwcValueLen > 0)
   {
      char rgchNewIconIndex[s_ucMaxIconIndexLen];

      dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                            s_cszIconIndexKey,
                                            EMPTY_STRING, rgchNewIconIndex,
                                            sizeof(rgchNewIconIndex),
                                            pcszFile);

      if (dwcValueLen > 0)
      {
		int niIcon = DecimalStringToUINT(rgchNewIconIndex);

           *ppszIconFile = new(char[lstrlen(rgchNewIconFile) + 1]);

            if (*ppszIconFile)
            {
               lstrcpy(*ppszIconFile, rgchNewIconFile);
               *pniIcon = niIcon;

               hr = S_OK;
            }
            else
               hr = E_OUTOFMEMORY;
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadIconLocationFromFile(): No icon index found in file %s.",
                      pcszFile));
      }
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadIconLocationFromFile(): No icon file found in file %s.",
                 pcszFile));
   }

   ASSERT(IsValidIconIndex(hr, *ppszIconFile, MAX_PATH_LEN, *pniIcon));

   return(hr);
}


HRESULT WriteIconLocationToFile(PCSTR pcszFile,
                                             PCSTR pcszIconFile,
                                             int niIcon)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszIconFile ||
          IS_VALID_STRING_PTR(pcszIconFile, CSTR));
   ASSERT(IsValidIconIndex((pcszIconFile ? S_OK : S_FALSE), pcszIconFile, MAX_PATH_LEN, niIcon));

   if (AnyMeat(pcszIconFile))
   {
      char rgchIconIndexRHS[s_ucMaxIconIndexLen];
      int ncLen;

      ncLen = wsprintf(rgchIconIndexRHS, "%d", niIcon);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchIconIndexRHS));
      ASSERT(ncLen == lstrlen(rgchIconIndexRHS));

      hr = (WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszIconFileKey, pcszIconFile,
                                      pcszFile) &&
            WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszIconIndexKey, rgchIconIndexRHS,
                                      pcszFile))
           ? S_OK
           : E_FAIL;
   }
   else
      hr = (DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszIconFileKey, pcszFile) &&
            DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszIconIndexKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


HRESULT ReadHotkeyFromFile(PCSTR pcszFile, PWORD pwHotkey)
{
   HRESULT hr = S_FALSE;
   char rgchHotkey[s_ucMaxHotkeyLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));

   *pwHotkey = 0;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszHotkeyKey, EMPTY_STRING,
                                         rgchHotkey, sizeof(rgchHotkey),
                                         pcszFile);

   if (dwcValueLen > 0)
   {
		*pwHotkey = (WORD) DecimalStringToUINT(rgchHotkey);
		hr = S_OK;
   }
   else
      WARNING_OUT(("ReadHotkeyFromFile(): No hotkey found in file %s.",
                   pcszFile));

   ASSERT((hr == S_OK &&
           IsValidHotkey(*pwHotkey)) ||
          (hr == S_FALSE &&
           ! *pwHotkey));

   return(hr);
}


HRESULT WriteHotkeyToFile(PCSTR pcszFile, WORD wHotkey)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! wHotkey ||
          IsValidHotkey(wHotkey));

   if (wHotkey)
   {
      char rgchHotkeyRHS[s_ucMaxHotkeyLen];
      int ncLen;

      ncLen = wsprintf(rgchHotkeyRHS, "%u", (UINT)wHotkey);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchHotkeyRHS));
      ASSERT(ncLen == lstrlen(rgchHotkeyRHS));

      hr = WritePrivateProfileString(s_cszInternetShortcutSection,
                                     s_cszHotkeyKey, rgchHotkeyRHS,
                                     pcszFile)
           ? S_OK
           : E_FAIL;
   }
   else
      hr = DeletePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszHotkeyKey, pcszFile)
           ? S_OK
           : E_FAIL;

   return(hr);
}


HRESULT ReadWorkingDirectoryFromFile(PCSTR pcszFile,
                                                  PSTR *ppszWorkingDirectory)
{
   HRESULT hr;
   char rgchDirValue[MAX_PATH_LEN];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszWorkingDirectory, PSTR));

   *ppszWorkingDirectory = NULL;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszWorkingDirectoryKey,
                                         EMPTY_STRING, rgchDirValue,
                                         sizeof(rgchDirValue), pcszFile);

   if (dwcValueLen > 0)
   {
      char rgchFullPath[MAX_PATH_LEN];
      PSTR pszFileName;

      if (GetFullPathName(rgchDirValue, sizeof(rgchFullPath), rgchFullPath,
                          &pszFileName) > 0)
      {
         // (+ 1) for null terminator.

         *ppszWorkingDirectory = new(char[lstrlen(rgchFullPath) + 1]);

         if (*ppszWorkingDirectory)
         {
            lstrcpy(*ppszWorkingDirectory, rgchFullPath);

            hr = S_OK;
         }
         else
            hr = E_OUTOFMEMORY;
      }
      else
         hr = E_FAIL;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadWorkingDirectoryFromFile: No working directory found in file %s.",
                 pcszFile));
   }

   ASSERT(IsValidPathResult(hr, *ppszWorkingDirectory, MAX_PATH_LEN));

   return(hr);
}


HRESULT WriteWorkingDirectoryToFile(PCSTR pcszFile,
                                                 PCSTR pcszWorkingDirectory)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszWorkingDirectory ||
          IS_VALID_STRING_PTR(pcszWorkingDirectory, CSTR));

   if (AnyMeat(pcszWorkingDirectory))
      hr = (WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszWorkingDirectoryKey,
                                      pcszWorkingDirectory, pcszFile))
           ? S_OK
           : E_FAIL;
   else
      hr = (DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszWorkingDirectoryKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


HRESULT ReadShowCmdFromFile(PCSTR pcszFile, PINT pnShowCmd)
{
   HRESULT hr;
   char rgchNewShowCmd[s_ucMaxShowCmdLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));

   *pnShowCmd = g_nDefaultShowCmd;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszShowCmdKey, EMPTY_STRING,
                                         rgchNewShowCmd,
                                         sizeof(rgchNewShowCmd), pcszFile);

   if (dwcValueLen > 0)
   {
		*pnShowCmd = DecimalStringToUINT(rgchNewShowCmd);
		hr = S_OK;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadShowCmdFromFile: No show command found in file %s.",
                 pcszFile));
   }

   ASSERT((hr == S_OK &&
           EVAL(IsValidShowCmd(*pnShowCmd))) ||
          (hr == S_FALSE &&
           EVAL(*pnShowCmd == g_nDefaultShowCmd)));

   return(hr);
}


HRESULT WriteShowCmdToFile(PCSTR pcszFile, int nShowCmd)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IsValidShowCmd(nShowCmd));

   if (nShowCmd != g_nDefaultShowCmd)
   {
      char rgchShowCmdRHS[s_ucMaxShowCmdLen];
      int ncLen;

      ncLen = wsprintf(rgchShowCmdRHS, "%d", nShowCmd);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchShowCmdRHS));
      ASSERT(ncLen == lstrlen(rgchShowCmdRHS));

      hr = (WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszShowCmdKey, rgchShowCmdRHS,
                                      pcszFile))
           ? S_OK
           : E_FAIL;
   }
   else
      hr = (DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszShowCmdKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}

#endif // 0

/****************************** Public Functions *****************************/

// BUGBUG - Isn't this already in NMUTIL?
HRESULT UnicodeToANSI(LPCOLESTR pcwszUnicode, PSTR *ppszANSI)
{
   HRESULT hr;
   int ncbLen;

   // BUGBUG: Need OLESTR validation function to validate pcwszUnicode here.
   ASSERT(IS_VALID_WRITE_PTR(ppszANSI, PSTR));

   *ppszANSI = NULL;

   // Get length of translated string.

   ncbLen = WideCharToMultiByte(CP_ACP, 0, pcwszUnicode, -1, NULL, 0, NULL,
                                NULL);

   if (ncbLen > 0)
   {
      PSTR pszNewANSI;

      // (+ 1) for null terminator.

      pszNewANSI = new(char[ncbLen]);

      if (pszNewANSI)
      {
         // Translate string.

         if (WideCharToMultiByte(CP_ACP, 0, pcwszUnicode, -1, pszNewANSI,
                                 ncbLen, NULL, NULL) > 0)
         {
            *ppszANSI = pszNewANSI;
            hr = S_OK;
         }
         else
         {
            delete pszNewANSI;
            pszNewANSI = NULL;

            hr = E_UNEXPECTED;

            WARNING_OUT(("UnicodeToANSI(): Failed to translate Unicode string to ANSI."));
         }
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = E_UNEXPECTED;

      WARNING_OUT(("UnicodeToANSI(): Failed to get length of translated ANSI string."));
   }

   ASSERT(FAILED(hr) ||
          IS_VALID_STRING_PTR(*ppszANSI, STR));

   return(hr);
}


HRESULT ANSIToUnicode(PCSTR pcszANSI, LPOLESTR *ppwszUnicode)
{
   HRESULT hr;
   int ncbWideLen;

   ASSERT(IS_VALID_STRING_PTR(pcszANSI, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppwszUnicode, LPOLESTR));

   *ppwszUnicode = NULL;

   // Get length of translated string.

   ncbWideLen = MultiByteToWideChar(CP_ACP, 0, pcszANSI, -1, NULL, 0);

   if (ncbWideLen > 0)
   {
      PWSTR pwszNewUnicode;

      // (+ 1) for null terminator.

      pwszNewUnicode = new(WCHAR[ncbWideLen]);

      if (pwszNewUnicode)
      {
         // Translate string.

         if (MultiByteToWideChar(CP_ACP, 0, pcszANSI, -1, pwszNewUnicode,
                                 ncbWideLen) > 0)
         {
            *ppwszUnicode = pwszNewUnicode;
            hr = S_OK;
         }
         else
         {
            delete pwszNewUnicode;
            pwszNewUnicode = NULL;

            hr = E_UNEXPECTED;

            WARNING_OUT(("ANSIToUnicode(): Failed to translate ANSI path string to Unicode."));
         }
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = E_UNEXPECTED;

      WARNING_OUT(("ANSIToUnicode(): Failed to get length of translated Unicode string."));
   }

   // BUGBUG: Need OLESTR validation function to validate *ppwszUnicode here.

   return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CConfLink::SaveToFile(PCSTR pcszFile,
												BOOL bRemember)
{
	HRESULT hr;

	DebugEntry(CConfLink::SaveToFile);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

#if 0
	PSTR pszName;
	hr = GetName(&pszName);

	if (SUCCEEDED(hr))
	{
		hr = WriteConfNameToFile(pcszFile, pszName);

		// Free the string:
		if (pszName)
		{
			LPMALLOC pMalloc = NULL;

			if (SUCCEEDED(SHGetMalloc(&pMalloc)))
			{
				pMalloc->Free(pszName);
				pMalloc->Release();
				pMalloc = NULL;
				pszName = NULL;
			}
		}
	}
#endif // 0

	hr = S_OK;
	
	if (NULL != m_pszName)
	{
		hr = WriteConfNameToFile(pcszFile, m_pszName);
	}
	
	if ((S_OK == hr) &&
		(NULL != m_pszAddress))
	{
		hr = WriteAddressToFile(pcszFile, m_pszAddress);
	}

	if ((S_OK == hr) &&
		(NULL != m_pszRemoteConfName))
	{
		hr = WriteRemoteConfNameToFile(pcszFile, m_pszRemoteConfName);
	}

	if (S_OK == hr)
	{
		hr = WriteCallFlagsToFile(pcszFile, m_dwCallFlags);
	} 

	if (S_OK == hr)
	{
		hr = WriteTransportToFile(pcszFile, m_dwTransport);
	} 

#if 0
      if (hr == S_OK)
      {
         char rgchBuf[MAX_PATH_LEN];
         int niIcon;

         hr = GetIconLocation(rgchBuf, sizeof(rgchBuf), &niIcon);

         if (SUCCEEDED(hr))
         {
            hr = WriteIconLocationToFile(pcszFile, rgchBuf, niIcon);

            if (hr == S_OK)
            {
               WORD wHotkey;

               hr = GetHotkey(&wHotkey);

               if (SUCCEEDED(hr))
               {
                  hr = WriteHotkeyToFile(pcszFile, wHotkey);

                  if (hr == S_OK)
                  {
                     hr = GetWorkingDirectory(rgchBuf, sizeof(rgchBuf));

                     if (SUCCEEDED(hr))
                     {
                        hr = WriteWorkingDirectoryToFile(pcszFile, rgchBuf);

                        if (hr == S_OK)
                        {
                           int nShowCmd;

                           GetShowCmd(&nShowCmd);

                           hr = WriteShowCmdToFile(pcszFile, nShowCmd);

                           if (hr == S_OK)
                           {
                              /* Remember file if requested. */

#endif
                              if (bRemember)
                              {
                                 // Replace existing file string, if any
                                 if (m_pszFile)
                                 {
                                     delete m_pszFile;
                                 }

                                 m_pszFile = new TCHAR[lstrlen(pcszFile)+1];
                                 if (NULL != m_pszFile)
                                 {
                                    lstrcpy(m_pszFile, pcszFile);

                                    TRACE_OUT(("CConfLink::SaveToFile(): Remembering file %s, as requested.",
                                               m_pszFile));
                                 }
                                 else
                                 {
                                    hr = E_OUTOFMEMORY;
                                 }
                              }

                              if (hr == S_OK)
                              {
                                 Dirty(FALSE);

                                 SHChangeNotify(SHCNE_UPDATEITEM,
                                                (SHCNF_PATH | SHCNF_FLUSH), pcszFile,
                                                NULL);

#ifdef DEBUG
                                 TRACE_OUT(("CConfLink::SaveToFile(): Conf Link saved to file %s:",
                                            pcszFile));
                                 Dump();
#endif // DEBUG
                              }
#if 0
                           }
                        }
                     }
                  }
               }
            }
         }
      }

   }
#endif // 0

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::SaveToFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::LoadFromFile(	PCSTR pcszFile,
													BOOL bRemember)
{
   HRESULT hr;
   PSTR pszName;
   PSTR pszAddr;
   PSTR pszRemoteConfName;
   DWORD dwTransport;
   DWORD dwCallFlags;

   DebugEntry(CConfLink::LoadFromFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   hr = ReadConfNameFromFile(pcszFile, &pszName);

   if (S_OK == hr)
   {
	  hr = SetName(pszName);

      if (pszName)
      {
         delete pszName;
         pszName = NULL;
      }
   }
      
	if (SUCCEEDED(hr))
	{
		hr = ReadAddressFromFile(pcszFile, &pszAddr);

		if (S_OK == hr)
		{
			hr = SetAddress(pszAddr);

			if (NULL != pszAddr)
			{
				delete pszAddr;
				pszAddr = NULL;
			}
		}
	}

	  if (SUCCEEDED(hr))
	  {
		  hr = ReadTransportFromFile(pcszFile, &dwTransport);

		  if (S_OK == hr)
		  {
			  hr = SetTransport(dwTransport);
		  }
	  }

	  if (SUCCEEDED(hr))
	  {
		  hr = ReadCallFlagsFromFile(pcszFile, &dwCallFlags);

		  if (S_OK == hr)
		  {
			  hr = SetCallFlags(dwCallFlags);
		  }
	  }
	   
	if (SUCCEEDED(hr))
	{
		hr = ReadRemoteConfNameFromFile(pcszFile, &pszRemoteConfName);

		if (S_OK == hr)
		{
			hr = SetRemoteConfName(pszRemoteConfName);

			delete pszRemoteConfName;
			pszRemoteConfName = NULL;
		}
	}
#if 0
      if (hr == S_OK)
      {
         PSTR pszIconFile;
         int niIcon;

         hr = ReadIconLocationFromFile(pcszFile, &pszIconFile, &niIcon);

         if (SUCCEEDED(hr))
         {
            hr = SetIconLocation(pszIconFile, niIcon);

            if (pszIconFile)
            {
               delete pszIconFile;
               pszIconFile = NULL;
            }

            if (hr == S_OK)
            {
               WORD wHotkey;

               hr = ReadHotkeyFromFile(pcszFile, &wHotkey);

               if (SUCCEEDED(hr))
               {
                  hr = SetHotkey(wHotkey);

                  if (hr == S_OK)
                  {
                     PSTR pszWorkingDirectory;

                     hr = ReadWorkingDirectoryFromFile(pcszFile,
                                                       &pszWorkingDirectory);

                     if (SUCCEEDED(hr))
                     {
                        hr = SetWorkingDirectory(pszWorkingDirectory);

                        if (pszWorkingDirectory)
                        {
                           delete pszWorkingDirectory;
                           pszWorkingDirectory = NULL;
                        }

                        if (hr == S_OK)
                        {
                           int nShowCmd;

                           hr = ReadShowCmdFromFile(pcszFile, &nShowCmd);

 #endif // 0
                           if (SUCCEEDED(hr))
                           {
                              /* Remember file if requested. */

                              if (bRemember)
                              {
                                 // PSTR pszFileCopy;

                                 //
                                 if (NULL != m_pszFile)
								 {
								    delete m_pszFile;
								 }

								 m_pszFile = new TCHAR[lstrlen(pcszFile) + 1];
								 
								 if (NULL != m_pszFile)
								 {
								    lstrcpy(m_pszFile, pcszFile);
								 }
								 else
								 {
								    hr = E_OUTOFMEMORY;
								 }

                                 
                                 // if (StringCopy(pcszFile, &pszFileCopy))
                                 // {
                                 //    if (m_pszFile)
                                 //       delete m_pszFile;

                                 //    m_pszFile = pszFileCopy;

                                 //    TRACE_OUT(("CConfLink::LoadFromFile(): Remembering file %s, as requested.",
                                 //               m_pszFile));
                                 // }
                                 // else
                                 //    hr = E_OUTOFMEMORY;
                              }

                              if (SUCCEEDED(hr))
                              {
                                 // SetShowCmd(nShowCmd);

                                 Dirty(FALSE);

                                 hr = S_OK;

#ifdef DEBUG
                                 TRACE_OUT(("CConfLink::LoadFromFile(): Conf Link loaded from file %s:",
                                            pcszFile));
                                 Dump();
#endif
                              }
                           }
#if 0
                        }
                     }
                  }
               }
            }
         }
      }
   }
#endif // 0

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::LoadFromFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::GetCurFile(PSTR pszFile,
												UINT ucbLen)
{
   HRESULT hr;

   DebugEntry(CConfLink::GetCurFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszFile, STR, ucbLen));

   if (m_pszFile)
   {
      lstrcpyn(pszFile, m_pszFile, ucbLen);

      TRACE_OUT(("CConfLink::GetCurFile(): Current file name is %s.",
                 pszFile));

      hr = S_OK;
   }
   else
      hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_STRING_PTR(pszFile, STR) &&
          EVAL((UINT)lstrlen(pszFile) < ucbLen));
   ASSERT(hr == S_OK ||
          hr == S_FALSE);

   DebugExitHRESULT(CConfLink::GetCurFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Dirty(BOOL bDirty)
{
   HRESULT hr;

   DebugEntry(CConfLink::Dirty);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   if (bDirty)
   {
      if (IS_FLAG_CLEAR(m_dwFlags, CONFLNK_FL_DIRTY))
	  {
         TRACE_OUT(("CConfLink::Dirty(): Now dirty."));
	  }

      SET_FLAG(m_dwFlags, CONFLNK_FL_DIRTY);
   }
   else
   {
      if (IS_FLAG_SET(m_dwFlags, CONFLNK_FL_DIRTY))
	  {
         TRACE_OUT(("CConfLink::Dirty(): Now clean."));
	  }

      CLEAR_FLAG(m_dwFlags, CONFLNK_FL_DIRTY);
   }

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(hr == S_OK);

   DebugExitVOID(CConfLink::Dirty);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::GetClassID(PCLSID pclsid)
{
   HRESULT hr;

   DebugEntry(CConfLink::GetClassID);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   *pclsid = CLSID_ConfLink;
   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   DebugExitHRESULT(CConfLink::GetClassID, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::IsDirty(void)
{
   HRESULT hr;

   DebugEntry(CConfLink::IsDirty);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   if (IS_FLAG_SET(m_dwFlags, CONFLNK_FL_DIRTY))
      hr = S_OK;
   else
      hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::IsDirty, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Save(	LPCOLESTR pcwszFile,
											BOOL bRemember)
{
   HRESULT hr;
   PSTR pszFile;

   DebugEntry(CConfLink::Save);

   // bRemember may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   // BUGBUG: Need OLESTR validation function to validate pcwszFile here.

   if (pcwszFile)
   {
      hr = UnicodeToANSI(pcwszFile, &pszFile);

      if (hr == S_OK)
      {
         hr = SaveToFile(pszFile, bRemember);

         delete pszFile;
         pszFile = NULL;
      }
   }
   else if (m_pszFile)
      // Ignore bRemember.
      hr = SaveToFile(m_pszFile, FALSE);
   else
      hr = E_FAIL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Save, hr);

   return(hr);
}


// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::SaveCompleted(LPCOLESTR pcwszFile)
{
   HRESULT hr;

   DebugEntry(CConfLink::SaveCompleted);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   // BUGBUG: Need OLESTR validation function to validate pcwszFile here.

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::SaveCompleted, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Load(	LPCOLESTR pcwszFile,
											DWORD dwMode)
{
   HRESULT hr;
   PSTR pszFile;

   DebugEntry(CConfLink::Load);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   // BUGBUG: Need OLESTR validation function to validate pcwszFile here.
   // BUGBUG: Validate dwMode here.

   // BUGBUG: Implement dwMode flag support.

   hr = UnicodeToANSI(pcwszFile, &pszFile);

   if (hr == S_OK)
   {
      hr = LoadFromFile(pszFile, TRUE);

      delete pszFile;
      pszFile = NULL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Load, hr);

   return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE CConfLink::GetCurFile(LPOLESTR *ppwszFile)
{
   HRESULT hr;
   LPOLESTR pwszTempFile;

   DebugEntry(CConfLink::GetCurFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_WRITE_PTR(ppwszFile, LPOLESTR));

   if (m_pszFile)
   {
      hr = ANSIToUnicode(m_pszFile, &pwszTempFile);

      if (hr == S_OK)
	  {
         TRACE_OUT(("CConfLink::GetCurFile(): Current file name is %s.",
                    m_pszFile));
	  }
   }
   else
   {
      hr = ANSIToUnicode(g_cszConfLinkDefaultFileNamePrompt, &pwszTempFile);

      if (hr == S_OK)
      {
         hr = S_FALSE;

         TRACE_OUT(("CConfLink::GetCurFile(): No current file name.  Returning default file name prompt %s.",
                    g_cszConfLinkDefaultFileNamePrompt));
      }
   }

   if (SUCCEEDED(hr))
   {
      // We should really call OleGetMalloc() to get the process IMalloc here.
      // Use SHAlloc() here instead to avoid loading ole32.dll.
      // SHAlloc() / SHFree() turn in to IMalloc::Alloc() and IMalloc::Free()
      // once ole32.dll is loaded.

      // N.b., lstrlenW() returns the length of the given string in characters,
      // not bytes.

      // (+ 1) for null terminator.

	   	LPMALLOC pMalloc = NULL;
		*ppwszFile = NULL;

		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			*ppwszFile = (LPOLESTR) pMalloc->Alloc((lstrlenW(pwszTempFile) + 1) *
													sizeof(*pwszTempFile));
			pMalloc->Release();
			pMalloc = NULL;
		}


      if (*ppwszFile)
	{
         LStrCpyW(*ppwszFile, pwszTempFile);
	}
      else
         hr = E_OUTOFMEMORY;

      delete pwszTempFile;
      pwszTempFile = NULL;
   }

   // BUGBUG: Need OLESTR validation function to validate *ppwszFile here.

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::GetCurFile, hr);

   return(hr);
}


// #pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE CConfLink::Load(PIStream pistr)
{
   HRESULT hr;

   DebugEntry(CConfLink::Load);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_INTERFACE_PTR(pistr, IStream));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Load, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::Save(	PIStream pistr,
											BOOL bClearDirty)
{
   HRESULT hr;

   DebugEntry(CConfLink::Save);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_INTERFACE_PTR(pistr, IStream));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::Save, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE CConfLink::GetSizeMax(PULARGE_INTEGER pcbSize)
{
   HRESULT hr;

   DebugEntry(CConfLink::GetSizeMax);

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
   ASSERT(IS_VALID_WRITE_PTR(pcbSize, ULARGE_INTEGER));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   DebugExitHRESULT(CConfLink::GetSizeMax, hr);

   return(hr);
}

// #pragma warning(default:4100) /* "unreferenced formal parameter" warning */


DWORD STDMETHODCALLTYPE CConfLink::GetFileContentsSize(void)
{
	DWORD dwcbLen;

	DebugEntry(CConfLink::GetFileContentsSize);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	// Section length.

	// (- 1) for each null terminator.

	dwcbLen = sizeof(s_cszSectionBefore) - 1 +
				sizeof(s_cszConferenceShortcutSection) - 1 +
				sizeof(s_cszSectionAfter) - 1;
	
	if (m_pszName)
	{
		// Name length.
		dwcbLen += sizeof(g_cszCRLF) - 1 +
					sizeof(s_cszNameKey) - 1 +
					sizeof(s_cszKeyValueSep) - 1 +
					lstrlen(m_pszName);
	}

	if (m_pszAddress)
	{
		// Address length.
		dwcbLen += sizeof(g_cszCRLF) - 1 +
					sizeof(s_cszAddressKey) - 1 +
					sizeof(s_cszKeyValueSep) - 1 +
					lstrlen(m_pszAddress);
	}

	if (m_pszRemoteConfName)
	{
		// RemoteConfName length.
		dwcbLen += sizeof(g_cszCRLF) - 1 +
					sizeof(s_cszRemoteConfNameKey) - 1 +
					sizeof(s_cszKeyValueSep) - 1 +
					lstrlen(m_pszRemoteConfName);
	}

	// CallFlags length
	dwcbLen += sizeof(g_cszCRLF) - 1 +
				sizeof(s_cszCallFlagsKey) - 1 +
				sizeof(s_cszKeyValueSep) - 1 +
				s_ucMaxCallFlagsLen;

	// Transport length
	dwcbLen += sizeof(g_cszCRLF) - 1 +
				sizeof(s_cszTransportKey) - 1 +
				sizeof(s_cszKeyValueSep) - 1 +
				s_ucMaxTransportLen;
	
	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

	DebugExitDWORD(CConfLink::GetFileContentsSize, dwcbLen);

	return(dwcbLen);
}


#ifdef DEBUG

void STDMETHODCALLTYPE CConfLink::Dump(void)
{
   ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));

   TRACE_OUT(("m_dwFlags = %#08lx", m_dwFlags));
   TRACE_OUT(("m_pszFile = \"%s\"", CHECK_STRING(m_pszFile)));
   TRACE_OUT(("m_pszName = \"%s\"", CHECK_STRING(m_pszName)));
#if 0
   TRACE_OUT(("m_pszIconFile = \"%s\"", CHECK_STRING(m_pszIconFile)));
   TRACE_OUT(("m_niIcon = %d", m_niIcon));
   TRACE_OUT(("m_wHotkey = %#04x", (UINT)m_wHotkey));
   TRACE_OUT(("m_pszWorkingDirectory = \"%s\"", CHECK_STRING(m_pszWorkingDirectory)));
   TRACE_OUT(("m_nShowCmd = %d", m_nShowCmd));
#endif // 0

   return;
}

#endif

#if 0
HRESULT STDMETHODCALLTYPE CConfLink::TransferConfLink(	PFORMATETC pfmtetc,
														PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferConfLink);

	ASSERT(0 && "If we hit this assert, we need to implement this function");

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
	ASSERT(pfmtetc->lindex == -1);

	ZeroMemory(pstgmed, sizeof(*pstgmed));

	if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
	{
		// BUGBUG: ChrisPi 9-15-95
		// This only transfers the conference name
		// (It does not transfer the address)
		
		if (m_pszName)
		{
			HGLOBAL hgName;

			hr = E_OUTOFMEMORY;

			// (+ 1) for null terminator.
			hgName = GlobalAlloc(0, lstrlen(m_pszName) + 1);

			if (hgName)
			{
				PSTR pszName;

				pszName = (PSTR)GlobalLock(hgName);

				if (EVAL(pszName))
				{
					lstrcpy(pszName, m_pszName);

					pstgmed->tymed = TYMED_HGLOBAL;
					pstgmed->hGlobal = hgName;
					ASSERT(! pstgmed->pUnkForRelease);

					hr = S_OK;

					GlobalUnlock(hgName);
					pszName = NULL;
				}

				if (hr != S_OK)
				{
					GlobalFree(hgName);
					hgName = NULL;
				}
			}
		}
		else
		{
			hr = DV_E_FORMATETC;
		}
	}
	else
	{
		hr = DV_E_TYMED;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
			IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
			(FAILED(hr) &&
			(EVAL(pstgmed->tymed == TYMED_NULL) &&
			EVAL(! pstgmed->hGlobal) &&
			EVAL(! pstgmed->pUnkForRelease))));

	DebugExitHRESULT(CConfLink::TransferConfLink, hr);

	return(hr);
}
#endif // 0

#if 0
HRESULT STDMETHODCALLTYPE CConfLink::TransferText(	PFORMATETC pfmtetc,
													PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferText);

	// Assume CConfLink::TransferConfLink() will perform
	// input and output validation.

	hr = TransferConfLink(pfmtetc, pstgmed);

	DebugExitHRESULT(CConfLink::TransferText, hr);

	return(hr);
}
#endif // 0

#if 0
HRESULT STDMETHODCALLTYPE CConfLink::TransferFileGroupDescriptor(	PFORMATETC pfmtetc,
																	PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferFileGroupDescriptor);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
	ASSERT(pfmtetc->lindex == -1);

	pstgmed->tymed = TYMED_NULL;
	pstgmed->hGlobal = NULL;
	pstgmed->pUnkForRelease = NULL;

	if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
	{
		HGLOBAL hgFileGroupDesc;

		hr = E_OUTOFMEMORY;

		hgFileGroupDesc = GlobalAlloc(GMEM_ZEROINIT,
		                            sizeof(FILEGROUPDESCRIPTOR));

		if (hgFileGroupDesc)
		{
			PFILEGROUPDESCRIPTOR pfgd;

			pfgd = (PFILEGROUPDESCRIPTOR)GlobalLock(hgFileGroupDesc);

			if (EVAL(pfgd))
			{
				PFILEDESCRIPTOR pfd = &(pfgd->fgd[0]);

				// Do we already have a file name to use?

				if (m_pszName)
				{
					TCHAR szFileName[MAX_PATH];
					
					// copy shortcut
					// BUGBUG: needs to be a resource INTL
					lstrcpy(szFileName, _TEXT("Shortcut to "));
					
					// copy Conference Name
					lstrcat(szFileName, m_pszName);
					
					// copy extension
					lstrcat(szFileName, g_cszConfLinkExt);
										
					MyLStrCpyN(pfd->cFileName, szFileName,
								sizeof(pfd->cFileName));
					hr = S_OK;
				}
				else
				{
					// BUGBUG: need resource here! INTL
					//if (EVAL(LoadString(GetThisModulesHandle(),
					//		IDS_NEW_INTERNET_SHORTCUT, pfd->cFileName,
					//		sizeof(pfd->cFileName))))
					
					MyLStrCpyN(pfd->cFileName, "New Conference Shortcut.cnf",
								sizeof(pfd->cFileName));
					hr = S_OK;
				}

				if (hr == S_OK)
				{
					pfd->dwFlags = (FD_FILESIZE |
					               FD_LINKUI);
					pfd->nFileSizeHigh = 0;
					
					pfd->nFileSizeLow = GetFileContentsSize();

					pfgd->cItems = 1;

					pstgmed->tymed = TYMED_HGLOBAL;
					pstgmed->hGlobal = hgFileGroupDesc;
					ASSERT(! pstgmed->pUnkForRelease);
				}

				GlobalUnlock(hgFileGroupDesc);
				pfgd = NULL;
			}

			if (hr != S_OK)
			{
				GlobalFree(hgFileGroupDesc);
				hgFileGroupDesc = NULL;
			}
		}
	}
	else
	{
		hr = DV_E_TYMED;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
			IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
			(FAILED(hr) &&
				(EVAL(pstgmed->tymed == TYMED_NULL) &&
					EVAL(! pstgmed->hGlobal) &&
					EVAL(! pstgmed->pUnkForRelease))));

	DebugExitHRESULT(CConfLink::TransferFileGroupDescriptor, hr);

	return(hr);
}
#endif // 0

HRESULT STDMETHODCALLTYPE CConfLink::TransferFileContents(	PFORMATETC pfmtetc,
															PSTGMEDIUM pstgmed)
{
	HRESULT hr;

	DebugEntry(CConfLink::TransferFileContents);

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
	ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

	ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
	ASSERT(! pfmtetc->lindex);

	pstgmed->tymed = TYMED_NULL;
	pstgmed->hGlobal = NULL;
	pstgmed->pUnkForRelease = NULL;

	if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
	{
		DWORD dwcbLen;
		HGLOBAL hgFileContents;

		hr = E_OUTOFMEMORY;

		dwcbLen = GetFileContentsSize();

		hgFileContents = GlobalAlloc(0, dwcbLen);

		if (hgFileContents)
		{
			PSTR pszFileContents;

			pszFileContents = (PSTR)GlobalLock(hgFileContents);

			if (EVAL(pszFileContents))
			{
				PSTR psz = pszFileContents;

				// Copy section.

				CopyMemory(psz, s_cszSectionBefore, sizeof(s_cszSectionBefore) - 1);
				psz += sizeof(s_cszSectionBefore) - 1;

				CopyMemory(psz, s_cszConferenceShortcutSection, sizeof(s_cszConferenceShortcutSection) - 1);
				psz += sizeof(s_cszConferenceShortcutSection) - 1;

				CopyMemory(psz, s_cszSectionAfter, sizeof(s_cszSectionAfter) - 1);
				psz += sizeof(s_cszSectionAfter) - 1;

				if (m_pszName)
				{
					// Copy Name.

					CopyMemory(psz, g_cszCRLF, sizeof(g_cszCRLF) - 1);
					psz += sizeof(g_cszCRLF) - 1;

					CopyMemory(psz, s_cszNameKey, sizeof(s_cszNameKey) - 1);
					psz += sizeof(s_cszNameKey) - 1;

					CopyMemory(psz, s_cszKeyValueSep, sizeof(s_cszKeyValueSep) - 1);
					psz += sizeof(s_cszKeyValueSep) - 1;

					CopyMemory(psz, m_pszName, lstrlen(m_pszName));
					psz += lstrlen(m_pszName);
				}

				if (m_pszAddress)
				{
					// Copy Name.

					CopyMemory(psz, g_cszCRLF, sizeof(g_cszCRLF) - 1);
					psz += sizeof(g_cszCRLF) - 1;

					CopyMemory(psz, s_cszAddressKey, sizeof(s_cszAddressKey) - 1);
					psz += sizeof(s_cszAddressKey) - 1;

					CopyMemory(psz, s_cszKeyValueSep, sizeof(s_cszKeyValueSep) - 1);
					psz += sizeof(s_cszKeyValueSep) - 1;

					CopyMemory(psz, m_pszAddress, lstrlen(m_pszAddress));
					psz += lstrlen(m_pszAddress);
				}

				// Copy Transport.
				CopyMemory(psz, g_cszCRLF, sizeof(g_cszCRLF) - 1);
				psz += sizeof(g_cszCRLF) - 1;

				CopyMemory(psz, s_cszTransportKey, sizeof(s_cszTransportKey) - 1);
				psz += sizeof(s_cszTransportKey) - 1;

				CopyMemory(psz, s_cszKeyValueSep, sizeof(s_cszKeyValueSep) - 1);
				psz += sizeof(s_cszKeyValueSep) - 1;

				TCHAR szBuf[s_ucMaxTransportLen];
				wsprintf(szBuf, "%10u", m_dwTransport);
				CopyMemory(psz, szBuf, lstrlen(szBuf));
				psz += lstrlen(szBuf);

				
				
				ASSERT(psz == pszFileContents + dwcbLen);

				pstgmed->tymed = TYMED_HGLOBAL;
				pstgmed->hGlobal = hgFileContents;
				ASSERT(! pstgmed->pUnkForRelease);

				hr = S_OK;

				GlobalUnlock(hgFileContents);
			}

			if (hr != S_OK)
			{
				GlobalFree(hgFileContents);
				hgFileContents = NULL;
			}
		}
	}
	else
	{
		hr = DV_E_TYMED;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CConfLink));
	ASSERT((hr == S_OK &&
			IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
			(FAILED(hr) &&
				(EVAL(pstgmed->tymed == TYMED_NULL) &&
					EVAL(! pstgmed->hGlobal) &&
					EVAL(! pstgmed->pUnkForRelease))));

	DebugExitHRESULT(CConfLink::TransferFileContents, hr);

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\launstub.h ===
#ifndef _LAUNSTUB_H_
#define _LAUNSTUB_H_

#include "ulsapi.h"
////////////////////////////////////////////////////////
//
// CULSLaunch_Stub
//

class CULSLaunch_Stub
{
public:

    STDMETHOD  (ParseUlsHttpRespFile) ( PTSTR, ULS_HTTP_RESP * );
    STDMETHOD  (ParseUlsHttpRespBuffer) ( PTSTR, ULONG, ULS_HTTP_RESP * );
    STDMETHOD  (FreeUlsHttpResp) ( ULS_HTTP_RESP * );

private:

    HRESULT  ParseB3HttpRespBuffer ( PTSTR, ULONG, ULS_HTTP_RESP * );
    HRESULT  ParseB4HttpRespBuffer ( PTSTR, ULONG, ULS_HTTP_RESP * );

};


#endif // _LAUNSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\marshalableti.h ===
// MarshalableTI.h : Declaration of the CMarshalableTI

#ifndef __MARSHALABLETI_H_
#define __MARSHALABLETI_H_

#include "mslablti.h"
#include "resource.h"       // main symbols


// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder2
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
	};
	stringdispid* m_pMap;
	int m_nCount;

	~CComTypeInfoHolder2()
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
		delete [] m_pMap;
		m_pMap = NULL;
	}

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
	HRESULT GetTI(LCID lcid);
	HRESULT EnsureTI(LCID lcid)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		return hr;
	}

	HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
	{
		HRESULT hRes = E_POINTER;
		if (pptinfo != NULL)
			hRes = GetTI(lcid, pptinfo);
		return hRes;
	}
	HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
		{
			for (int i=0; i<(int)cNames; i++)
			{
				int n = ocslen(rgszNames[i]);
				for (int j=m_nCount-1; j>=0; j--)
				{
					if ((n == m_pMap[j].nLen) &&
						(memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
					{
						rgdispid[i] = m_pMap[j].id;
						break;
					}
				}
				if (j < 0)
				{
					hRes = m_pInfo->GetIDsOfNames(rgszNames + i, 1, &rgdispid[i]);
					if (FAILED(hRes))
						break;
				}
			}
		}
		return hRes;
	}

	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		return hRes;
	}
	HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
	{
		TYPEATTR* pta;
		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
		if (SUCCEEDED(hr))
		{
			m_nCount = pta->cFuncs;
			m_pMap = m_nCount == 0 ? 0 : new stringdispid[m_nCount];
			for (int i=0; i<m_nCount; i++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
				{
					CComBSTR bstrName;
					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
					{
						m_pMap[i].bstr.Attach(bstrName.Detach());
						m_pMap[i].nLen = SysStringLen(m_pMap[i].bstr);
						m_pMap[i].id = pfd->memid;
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			pTypeInfo->ReleaseTypeAttr(pta);
		}
		return S_OK;
	}
};


inline HRESULT CComTypeInfoHolder2::GetTI(LCID lcid)
{
	//If this assert occurs then most likely didn't initialize properly
	ATLASSERT(m_plibid != NULL && m_pguid != NULL);
	ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

	if (m_pInfo != NULL)
		return S_OK;
	HRESULT hRes = E_FAIL;
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
			if (SUCCEEDED(hRes))
			{
				CComPtr<ITypeInfo> spInfo(spTypeInfo);
				CComPtr<ITypeInfo2> spTypeInfo2;
				if (SUCCEEDED(spTypeInfo->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void**>(&spTypeInfo2))))
					spInfo = spTypeInfo2;

				LoadNameCache(spInfo);
				m_pInfo = spInfo.Detach();
			}
			pTypeLib->Release();
		}
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// CMarshalableTI
class ATL_NO_VTABLE CMarshalableTI : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMarshalableTI, &CLSID_MarshalableTI>,
	public IMarshalableTI,
	public IMarshal,
	public ITypeInfo
{
private:
	CComTypeInfoHolder2	m_TIHolder;
	GUID				m_guid;
	GUID				m_libid;
	LCID				m_lcid;
	bool				m_bCreated;

public:
	

DECLARE_REGISTRY_RESOURCEID(IDR_MSLABLTI)
DECLARE_NOT_AGGREGATABLE(CMarshalableTI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshal)
	COM_INTERFACE_ENTRY(ITypeInfo)
END_COM_MAP()

	HRESULT FinalConstruct();

/////////////////////////////////////////////////////////////////////////////////
// IMarshalableTI methods

	STDMETHOD(Create)(/*[in]*/ REFIID clsid, 
					  /*[in]*/ REFIID iidLib, 
					  /*[in]*/ LCID lcid,
					  /*[in]*/ WORD dwMajorVer, 
					  /*[in]*/ WORD dwMinorVer);

/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid);

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm);

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved);

/////////////////////////////////////////////////////////////////////////////////
// ITypeInfo methods

    STDMETHOD(GetTypeAttr)(
                TYPEATTR ** ppTypeAttr);

    STDMETHOD(GetTypeComp)(
                ITypeComp ** ppTComp);

    STDMETHOD(GetFuncDesc)(
                UINT index,
                FUNCDESC ** ppFuncDesc);

    STDMETHOD(GetVarDesc)(
                UINT index,
                VARDESC ** ppVarDesc);

    STDMETHOD(GetNames)(
                MEMBERID memid,
                BSTR * rgBstrNames,
                UINT cMaxNames,
                UINT * pcNames);


    STDMETHOD(GetRefTypeOfImplType)(
                UINT index,
                HREFTYPE * pRefType);

    STDMETHOD(GetImplTypeFlags)(
                UINT index,
                INT * pImplTypeFlags);


    STDMETHOD(GetIDsOfNames)(
                LPOLESTR * rgszNames,
                UINT cNames,
                MEMBERID * pMemId);

    STDMETHOD(Invoke)(
                PVOID pvInstance,
                MEMBERID memid,
                WORD wFlags,
                DISPPARAMS * pDispParams,
                VARIANT * pVarResult,
                EXCEPINFO * pExcepInfo,
                UINT * puArgErr);

    STDMETHOD(GetDocumentation)(
                MEMBERID memid,
                BSTR * pBstrName,
                BSTR * pBstrDocString,
                DWORD * pdwHelpContext,
                BSTR * pBstrHelpFile);


    STDMETHOD(GetDllEntry)(
                MEMBERID memid,
                INVOKEKIND invKind,
                BSTR * pBstrDllName,
                BSTR * pBstrName,
                WORD * pwOrdinal);


    STDMETHOD(GetRefTypeInfo)(
                HREFTYPE hRefType,
                ITypeInfo ** ppTInfo);


    STDMETHOD(AddressOfMember)(
                MEMBERID memid,
                INVOKEKIND invKind,
                PVOID * ppv);

    STDMETHOD(CreateInstance)(
                IUnknown * pUnkOuter,
                REFIID riid,
                PVOID * ppvObj);


    STDMETHOD(GetMops)(
                MEMBERID memid,
                BSTR * pBstrMops);


    STDMETHOD(GetContainingTypeLib)(
                ITypeLib ** ppTLib,
                UINT * pIndex);

    STDMETHOD_(void, ReleaseTypeAttr)(
                TYPEATTR * pTypeAttr);

    STDMETHOD_(void, ReleaseFuncDesc)(
                FUNCDESC * pFuncDesc);

    STDMETHOD_(void, ReleaseVarDesc)(
                VARDESC * pVarDesc);


private:
	HRESULT _GetClassInfo(ITypeInfo** ppTI);
};

#endif //__MARSHALABLETI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\launstub.cpp ===
//--------------------------------------------------------------------------
//
// Module Name:  LaunStub.Cpp
//
// Brief Description:
//      This module contains the code that parses HTTP-based
//      response from the ULS server.
//
// Author:  Chu, Lon-Chan (lonchanc)
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "launstub.h"


PTSTR LocalStrDup ( PTSTR pszToDup )
{
	UINT uLen;
	PTSTR psz = NULL;

	if (pszToDup)
	{
		uLen = lstrlen (pszToDup);
		psz = (PTSTR) new TCHAR[uLen + 1];
		if (psz)
		{
			lstrcpy (psz, pszToDup);
		}
	}

	return psz;
}

ULONG DecStrToInt ( PTSTR psz )
{
    ULONG ul = 0;
    WORD w;

    if (psz)
    {
        while ((w = (WORD) *psz++) != NULL)
        {
            if (TEXT ('0') <= w && w <= TEXT ('9'))
            {
                w -= TEXT ('0');
                ul = ul * 10 + w;
            }
            else
            {
                break;
            }
        }
    }

    return ul;
}


ULONG HexStrToInt ( PTSTR psz )
{
    ULONG ul = 0;
    WORD w;

    if (psz)
    {
        while ((w = (WORD) *psz++) != NULL)
        {
            if (TEXT ('0') <= w && w <= TEXT ('9'))
            {
                w -= TEXT ('0');
            }
            else
            if (TEXT ('a') <= w && w <= TEXT ('f'))
            {
                w -= (TEXT ('a') - 10);
            }
            else
            if (TEXT ('A') <= w && w <= TEXT ('F'))
            {
                w -= (TEXT ('A') - 10);
            }
            else
            {
                break;
            }

            ul = (ul << 4) + w;
        }
    }

    return ul;
}

BOOL IsWhiteSpace ( TCHAR c )
{
    return (c == TEXT (' ') || c == TEXT ('\t') || c == TEXT ('\r') || c == TEXT ('\n'));
}

enum
{
    // beta 3 strings
    ATTR_HR,
    ATTR_PORT,
    ATTR_HA,
    ATTR_HC,
    ATTR_CID,
    ATTR_UID,
    ATTR_URL,
    ATTR_IP,
    ATTR_MT,

    B3ATTR_COUNT
};


static PTSTR g_B3Attr[B3ATTR_COUNT] =
{
    // beta 3 strings
    TEXT ("HR"),
    TEXT ("PORT"),
    TEXT ("HA"),
    TEXT ("HC"),
    TEXT ("CID"),
    TEXT ("UID"),
    TEXT ("URL"),
    TEXT ("IP"),
    TEXT ("MT"),
};


enum
{
    // beta 4 strings
    ATTR_HRESULT,
    ATTR_HCLIENT,
    ATTR_HAPPLICATION,
    ATTR_NAPPS,
    ATTR_IPADDRESS,
    ATTR_PORTNUM,
    ATTR_APPID,
    ATTR_PROTID,
    ATTR_USERID,
    ATTR_MIMETYPE,
    ATTR_APPMIME,
    ATTR_PROTMIME,
    ATTR_QUERYURL,

    B4ATTR_COUNT
};

    
static PTSTR g_B4Attr[B4ATTR_COUNT] =
{
    // beta 4 strings
    TEXT ("hresult"),
    TEXT ("hclient"),
    TEXT ("happlication"),
    TEXT ("napps"),
    TEXT ("ipaddress"),
    TEXT ("portnum"),
    TEXT ("appid"),
    TEXT ("protid"),
    TEXT ("userid"),
    TEXT ("mimetype"),
    TEXT ("appmime"),
    TEXT ("protmime"),
    TEXT ("queryurl"),
};


typedef struct tagULPCMD
{
    PTSTR   pszCmd;
    ULONG   nCmdId;
}
    ULPCMD;


static ULPCMD g_B3Cmd[] =
{
    { TEXT ("ON"),    CLIENT_MESSAGE_ID_LOGON     },
    { TEXT ("OFF"),   CLIENT_MESSAGE_ID_LOGOFF    },
    { TEXT ("KA"),    CLIENT_MESSAGE_ID_KEEPALIVE },
    { TEXT ("RES"),   CLIENT_MESSAGE_ID_RESOLVE   },
};


static ULPCMD g_B4Cmd[] =
{
    { TEXT ("on"),    CLIENT_MESSAGE_ID_LOGON     },
    { TEXT ("off"),   CLIENT_MESSAGE_ID_LOGOFF    },
    { TEXT ("ka"),    CLIENT_MESSAGE_ID_KEEPALIVE },
    { TEXT ("res"),   CLIENT_MESSAGE_ID_RESOLVE   },
};


/*
    @doc    EXTERNAL    ULCLIENT
    @api    HRESULT | CULSLaunch_Stub::ParseUlsHttpRespFile |
            Parses a HTTP-based response from the ULS server.
    @parm   PTSTR | pszUlsFile | A pointer to the HTTP-based response
            file name string.
    @parm   ULS_HTTP_RESP * | pResp | A pointer to the generic 
            HTTP response structure.
    @rdesc  Returns ULS_SUCCESS if this operation succeeds.
    @comm   This method parses the responses from the commands
            defined in the g_B3Cmd array. The attributes this method
            understands are listed in the g_B3Attr array.
*/

STDMETHODIMP CULSLaunch_Stub::ParseUlsHttpRespFile
                ( PTSTR pszUlsFile, ULS_HTTP_RESP *pResp )
{
    HANDLE hf = INVALID_HANDLE_VALUE;
    HRESULT hr;
    PTSTR pszBuf = NULL;
    ULONG cbFileSize;


    // clean up the structure first
    ZeroMemory (pResp, sizeof (ULS_HTTP_RESP));
    pResp->cbSize = sizeof (ULS_HTTP_RESP);

    // open the uls file
    hf = CreateFile (pszUlsFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                                    FILE_FLAG_SEQUENTIAL_SCAN |
//                                  FILE_FLAG_DELETE_ON_CLOSE, NULL);
                                    0, NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        return ULS_E_INVALID_HANDLE;
    }

    // get the size of the uls file
    cbFileSize = GetFileSize (hf, NULL);
    if (! cbFileSize)
    {
        return ULS_E_INVALID_HANDLE;
    }

    // round up to align with the paragraph boundary
    cbFileSize = ((cbFileSize + 4) & (~ 0x0F)) + 0x10;

    // allocate a buffer to hold the entire uls file
    pszBuf = (PTSTR) new TCHAR[cbFileSize];
    if (! pszBuf)
    {
        hr = ULS_E_OUTOFMEMORY;
        goto MyExit;
    }

    // read the file in
    if (! ReadFile (hf, pszBuf, cbFileSize, &cbFileSize, NULL))
    {
        hr = ULS_E_IO_ERROR;
        goto MyExit;
    }

    // parse the uls buffer
    hr = ParseUlsHttpRespBuffer (pszBuf, cbFileSize, pResp);
    if (hr != ULS_SUCCESS)
    {
        goto MyExit;
    }

MyExit:

    if (hf != INVALID_HANDLE_VALUE) CloseHandle (hf);

   delete [] pszBuf;

    if (hr != ULS_SUCCESS && pResp)
    {
        FreeUlsHttpResp (pResp);
    }

    return hr;
}


/*
    @doc    EXTERNAL    ULCLIENT
    @api    HRESULT | CULSLaunch_Stub::ParseUlsHttpRespBuffer |
            Parses a HTTP-based response from the ULS server.
    @parm   PTSTR | pszBuf | A pointer to the buffer holding
            the entire HTTP-based response data.
    @parm   ULONG | cbBufSize | The size in byte of the buffer.
    @parm   ULS_HTTP_RESP * | pResp | A pointer to the generic 
            HTTP response structure.
    @rdesc  Returns ULS_SUCCESS if this operation succeeds.
    @comm   This method parses the responses from the commands
            defined in the g_B3Cmd array. The attributes this method
            understands are listed in the g_B3Attr array.
*/

STDMETHODIMP CULSLaunch_Stub::ParseUlsHttpRespBuffer
                    ( PTSTR pszBuf, ULONG cbBufSize, ULS_HTTP_RESP *pResp )
{
    HRESULT hr;

#ifdef SANITY_CHECK
    // sanity check
    if (MyIsBadReadPtr (pszBuf, cbBufSize) ||
        MyIsBadWritePtr (pResp, sizeof (ULS_HTTP_RESP)))
    {
        return ULS_E_INVALID_POINTER;
    }
#endif

    hr = ParseB3HttpRespBuffer (pszBuf, cbBufSize, pResp);

    if (hr == ULS_E_INVALID_FORMAT)
    {
        ZeroMemory (pResp, sizeof (ULS_HTTP_RESP));
        pResp->cbSize = sizeof (ULS_HTTP_RESP);
        hr = ParseB4HttpRespBuffer (pszBuf, cbBufSize, pResp);
    }

    return hr;
}


HRESULT CULSLaunch_Stub::ParseB3HttpRespBuffer // beta 3 implementation
                    ( PTSTR pszBuf, ULONG cbBufSize, ULS_HTTP_RESP *pResp )
{
    PTSTR psz;
    int i;

    // get mime type
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('<'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('>'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    *psz = TEXT ('\0');
    lstrcpyn (pResp->szMimeType, pszBuf, MAX_MIME_TYPE_LENGTH);

    // get to the type of response
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('<'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('['));
    if (! psz) return ULS_E_INVALID_FORMAT;
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT (']'));
    if (! psz) return ULS_E_INVALID_FORMAT;
    *psz = TEXT ('\0');
    pResp->nCmdId = (ULONG) -1;
    for (i = 0; i < sizeof (g_B3Cmd) / sizeof (g_B3Cmd[0]); i++)
    {
        if (! lstrcmpi (pszBuf, g_B3Cmd[i].pszCmd))
        {
            pResp->nCmdId = g_B3Cmd[i].nCmdId;
            break;
        }
    }
    if (pResp->nCmdId == (ULONG) -1) return ULS_E_INVALID_FORMAT;

    // skip any white space
    for (pszBuf = psz + 1; *pszBuf; pszBuf++) { if (! IsWhiteSpace (*pszBuf)) break; }

    // main loop
    while (*pszBuf && *pszBuf != TEXT ('>'))
    {
        // locate the equal sign
        psz = (LPTSTR)_StrChr (pszBuf, TEXT ('='));
        if (! psz) return ULS_E_INVALID_FORMAT;
        *psz = TEXT ('\0');

        // search for attribute
        for (i = 0; i < sizeof (g_B3Attr) / sizeof (g_B3Attr[0]); i++)
        {
            if (! lstrcmpi (pszBuf, g_B3Attr[i]))
            {
                break;
            }
        }
        if (i >= sizeof (g_B3Attr) / sizeof (g_B3Attr[0])) return ULS_E_INVALID_FORMAT;

        // locate the attribute value
        for (pszBuf = psz + 1; *pszBuf; pszBuf++) { if (! IsWhiteSpace (*pszBuf)) break; }
        for (psz = pszBuf + 1; *psz; psz++) { if (IsWhiteSpace (*psz)) break; }
        *psz = TEXT ('\0');
        // now the attribute value is a null-terminated string pointed by pszBuf

        // parse the attribute value
        switch (i)
        {
        case ATTR_HR:
            pResp->hr = HexStrToInt (pszBuf);
            break;

        case ATTR_PORT:
            pResp->nPort = DecStrToInt (pszBuf);
            break;

        case ATTR_HA:
            pResp->dwAppSession = HexStrToInt (pszBuf);
            break;

        case ATTR_HC:
            pResp->dwClientSession = HexStrToInt (pszBuf);
            break;

        case ATTR_CID:
            pResp->dwClientId = HexStrToInt (pszBuf);
            break;

        case ATTR_UID:
			ASSERT(!pResp->pszUID);
            pResp->pszUID = LocalStrDup (pszBuf);
            break;

        case ATTR_URL:
			ASSERT(!pResp->pszURL);
            pResp->pszURL = LocalStrDup (pszBuf);
            break;

        case ATTR_IP:
            lstrcpyn (pResp->szIPAddress, pszBuf, MAX_IP_ADDRESS_STRING_LENGTH);
            break;

        case ATTR_MT:
            // already got it
            break;
       }

        // skip any white space
        for (pszBuf = psz + 1; *pszBuf; pszBuf++) { if (! IsWhiteSpace (*pszBuf)) break; }
    }

    return ULS_SUCCESS;
}


HRESULT CULSLaunch_Stub::ParseB4HttpRespBuffer // beta 4 implementation
                    ( PTSTR pszBuf, ULONG cbBufSize, ULS_HTTP_RESP *pResp )
{
    PTSTR psz, pszSave;
    int i;

    // get mime type
    psz = (LPTSTR)_StrChr (pszBuf, TEXT ('['));
    if (! psz)
    {
        return ULS_E_INVALID_FORMAT;
    }
    pszBuf = psz + 1;
    psz = (LPTSTR)_StrChr (pszBuf, TEXT (']'));
    if (! psz)
    {
        return ULS_E_INVALID_FORMAT;
    }
    *psz = TEXT ('\0');

    // now pszBuf is ptr to the string inside [], such on, off, ka, res.
    pResp->nCmdId = (ULONG) -1;
    for (i = 0; i < sizeof (g_B4Cmd) / sizeof (g_B4Cmd[0]); i++)
    {
        if (! lstrcmpi (pszBuf, g_B4Cmd[i].pszCmd))
        {
            pResp->nCmdId = g_B4Cmd[i].nCmdId;
            break;
        }
    }

    // to see if this cmd is something I don't know
    if (pResp->nCmdId == (ULONG) -1)
    {
        return ULS_E_INVALID_FORMAT;
    }

    // update the buf ptr
    pszBuf = psz + 1;

    // main loop
    while (*pszBuf)
    {
        // locate a \r \n
        while (*pszBuf != TEXT ('\r') && *pszBuf != TEXT ('\n'))
        {
            pszBuf++;
        }

        // skip any white space including \r \n
        while (*pszBuf)
        {
            if (! IsWhiteSpace (*pszBuf))
            {
                break;
            }
            pszBuf++;
        }

        // end of file
        if (! *pszBuf)
        {
            return ULS_SUCCESS;
        }
        
        // locate the equal sign
        psz = (LPTSTR)_StrChr (pszBuf, TEXT ('='));
        if (! psz)
        {
            continue; // cannot goto NextLine because psz==NULL
        }

        // to make pszBuf ptr to the attr name
        *psz = TEXT ('\0');

        // search for attribute
        for (i = 0; i < sizeof (g_B4Attr) / sizeof (g_B4Attr[0]); i++)
        {
            if (! lstrcmpi (pszBuf, g_B4Attr[i]))
            {
                break;
            }
        }

        // is this attribute valid? if not, ignore it!
        if (i >= sizeof (g_B4Attr) / sizeof (g_B4Attr[0]))
        {
            goto NextLine;
        }

        // locate pszBuf now ptr to attr value
        pszBuf = psz + 1;

        // get to the end of line
        for (psz = pszBuf; *psz; psz++)
        {
            if (*psz == TEXT ('\r') || *psz == TEXT ('\n'))
            {
                break;
            }
        }        

        // deal with   attrname=\r\nEOF
        if (! *psz)
        {
            return ULS_SUCCESS;
        }

        // make the attr value is a null-terminated string pointed by pszBuf
        *psz = TEXT ('\0');

        // parse the attribute value
        switch (i)
        {
        case ATTR_HRESULT:
            pResp->hr = HexStrToInt (pszBuf);
            break;

        case ATTR_PORTNUM:
            pResp->nPort = DecStrToInt (pszBuf);
            break;

        case ATTR_HAPPLICATION:
            pResp->dwAppSession = HexStrToInt (pszBuf);
            break;

        case ATTR_HCLIENT:
            pResp->dwClientSession = HexStrToInt (pszBuf);
            break;

        case ATTR_USERID:
            pszSave = pResp->pszUID;
            pResp->pszUID = LocalStrDup (pszBuf);
            if (pResp->pszUID)
            {
                delete [] pszSave;
            }
            else
            {
                pResp->pszUID = pszSave; // restore
            }
            break;

        case ATTR_QUERYURL:
            pszSave = pResp->pszURL;
            pResp->pszURL = LocalStrDup (pszBuf);
            if (pResp->pszURL)
            {
                delete [] pszSave;
            }
            else
            {
                pResp->pszURL = pszSave; // restore
            }
            break;

        case ATTR_IPADDRESS:
            lstrcpyn (pResp->szIPAddress, pszBuf,
                sizeof (pResp->szIPAddress) / sizeof (pResp->szIPAddress[0]));
            break;

        case ATTR_MIMETYPE:
            lstrcpyn (pResp->szMimeType, pszBuf,
                sizeof (pResp->szMimeType) / sizeof (pResp->szMimeType[0]));
            break;

        case ATTR_APPMIME:
            lstrcpyn (pResp->szAppMime, pszBuf,
                sizeof (pResp->szAppMime) / sizeof (pResp->szAppMime[0]));
            break;

        case ATTR_PROTMIME:
            lstrcpyn (pResp->szProtMime, pszBuf,
                sizeof (pResp->szProtMime) / sizeof (pResp->szProtMime[0]));
            break;

        case ATTR_APPID:
            lstrcpyn (pResp->szAppId, pszBuf,
                sizeof (pResp->szAppId) / sizeof (pResp->szAppId[0]));
            break;

        case ATTR_PROTID:
            lstrcpyn (pResp->szProtId, pszBuf,
                sizeof (pResp->szProtId) / sizeof (pResp->szProtId[0]));
            break;

        case ATTR_NAPPS:
            pResp->nApps = DecStrToInt (pszBuf);
            break;

        default:
            break;
        }

    NextLine:

        // make sure we are at \r \n
        *psz = TEXT ('\r');
        pszBuf = psz;
    }

    return ULS_SUCCESS;
}


 
/*
    @doc    EXTERNAL    ULCLIENT
    @api    HRESULT | CULSLaunch_Stub::FreeUlsHttpResp |
            Frees internal resources in a generic HTTP-based
            response structure.
    @parm   ULS_HTTP_RESP * | pResp | A pointer to the generic 
            HTTP response structure.
    @rdesc  Returns ULS_SUCCESS if this operation succeeds.
    @comm   The internal resources must be created by
            the ParseUlsHttpRespFile method or
            the ParseUlsHttpRespBuffer method.
*/

STDMETHODIMP CULSLaunch_Stub::FreeUlsHttpResp ( ULS_HTTP_RESP *pResp )
{
    if (pResp->pszUID)
    {
        delete [] pResp->pszUID;
        pResp->pszUID = NULL;
    }

    if (pResp->pszURL)
    {
        delete [] pResp->pszURL;
        pResp->pszURL = NULL;
    }

    return ULS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\marshalableti.cpp ===
// MarshalableTI.cpp : Implementation of CMarshalableTI
#include "precomp.h"
#include "MarshalableTI.h"

/////////////////////////////////////////////////////////////////////////////
// CMarshalableTI methods
/////////////////////////////////////////////////////////////////////////////

HRESULT CMarshalableTI::FinalConstruct()
{
	HRESULT hr = S_OK;
	
	m_bCreated = false;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IMarshalableTI methods
/////////////////////////////////////////////////////////////////////////////
 
STDMETHODIMP CMarshalableTI::Create(REFIID clsid, REFIID iidLib, LCID lcid, WORD dwMajorVer, WORD dwMinorVer)
{
	HRESULT hr = S_OK;
	if( !m_bCreated )
	{
		m_guid = clsid;
		m_libid = iidLib;
		m_lcid = lcid;
		
		m_TIHolder.m_pguid = &m_guid;
		m_TIHolder.m_plibid = &m_libid;
		m_TIHolder.m_wMajor = dwMajorVer;
		m_TIHolder.m_wMinor = dwMinorVer;
		m_TIHolder.m_pInfo = NULL;
		m_TIHolder.m_dwRef = 0;
		m_TIHolder.m_pMap = NULL;
		m_TIHolder.m_nCount = 0;
	}
	else
	{
		ATLASSERT(0);
		hr = E_UNEXPECTED;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IMarshal Methods
/////////////////////////////////////////////////////////////////////////////

HRESULT CMarshalableTI::GetUnmarshalClass(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid)
{
	HRESULT hr = S_OK;

	*pCid = CLSID_MarshalableTI;

    return hr;
}

HRESULT CMarshalableTI::GetMarshalSizeMax(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize)
{

	*pSize = (2 * sizeof(GUID) + 2 * sizeof(ULONG) + sizeof(LCID) );
	return S_OK;
}

HRESULT CMarshalableTI::MarshalInterface(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags)
{

	BYTE buf[(2 * sizeof(GUID) + 2 * sizeof(ULONG) + sizeof(LCID))];
    BYTE * pByte = buf;

    const GUID* pGuid = m_TIHolder.m_plibid;
	DWORD dwVer = m_TIHolder.m_wMajor;
    const DWORD* pDword = &dwVer;

	// Ugly because it is yanked from tested, shipped system code
    for (int i = 0; i < 2; i++) {

        DWORD dword = pGuid->Data1;
        *pByte++ = (BYTE)(dword);
        *pByte++ = (BYTE)(dword >> 8);
        *pByte++ = (BYTE)(dword >> 16);
        *pByte++ = (BYTE)(dword >> 24);

        WORD word = pGuid->Data2;
        *pByte++ = (BYTE)(word);
        *pByte++ = (BYTE)(word >> 8);

        word = pGuid->Data3;
        *pByte++ = (BYTE)(word);
        *pByte++ = (BYTE)(word >> 8);

        const BYTE* pData4 = pGuid->Data4;
        for (int j = 0; j < 8; j++) {
            *pByte++ = *pData4++;
        }

        dword = *pDword;
        *pByte++ = (BYTE)(dword);
        *pByte++ = (BYTE)(dword >> 8);
        *pByte++ = (BYTE)(dword >> 16);
        *pByte++ = (BYTE)(dword >> 24);

        pGuid = m_TIHolder.m_pguid;
		dwVer = m_TIHolder.m_wMinor;
    }

    *pByte++ = (BYTE)(m_lcid);
    *pByte++ = (BYTE)(m_lcid >> 8);
    *pByte++ = (BYTE)(m_lcid >> 16);
    *pByte++ = (BYTE)(m_lcid >> 24);

    HRESULT hr = pStm->Write(buf, sizeof(buf), NULL);

    return S_OK;
}

HRESULT CMarshalableTI::UnmarshalInterface(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv)
{


    // Since we don't know the endian-ness of the other side,
    // we use a private wire format for custom marshaling here.
    //
    BYTE buf[(2 * sizeof(GUID) + 2 * sizeof(ULONG) + sizeof(LCID) )];
    HRESULT hr = S_OK;

	if( !m_bCreated )
	{

		*ppv = NULL;

		hr = pStm->Read(buf, sizeof(buf), NULL);

		if(SUCCEEDED(hr))
		{
			GUID guidTypeLib;
			GUID guidTypeInfo;
			LCID lcidTypeLib;
			ULONG verMajor;
			ULONG verMinor;

			BYTE * pByte;
			GUID * pGuid;
			DWORD * pDword;

			pByte = buf;
			pGuid = &guidTypeLib;
			pDword = &verMajor;
			int i;

			// Ugly because it is yanked from tested, shipped system code
			for (i = 0; i < 2; i++) {
				DWORD dword;
				WORD word;

				dword  = (DWORD)(*pByte++);
				dword += (DWORD)(*pByte++ << 8);
				dword += (DWORD)(*pByte++ << 16);
				dword += (DWORD)(*pByte++ << 24);
				pGuid->Data1 = dword;

				word  = (WORD)(*pByte++);
				word += (WORD)(*pByte++ << 8);
				pGuid->Data2 = word;

				word  = (WORD)(*pByte++);
				word += (WORD)(*pByte++ << 8);
				pGuid->Data3 = word;

				BYTE * pData4 = pGuid->Data4;
				for (int j = 0; j < 8; j++) {
					*pData4++ = *pByte++;
				}

				dword  = (DWORD)(*pByte++);
				dword += (DWORD)(*pByte++ << 8);
				dword += (DWORD)(*pByte++ << 16);
				dword += (DWORD)(*pByte++ << 24);
				*pDword = dword;

				pGuid = &guidTypeInfo;
				pDword = &verMinor;
			}

			lcidTypeLib  = (DWORD)(*pByte++);
			lcidTypeLib += (DWORD)(*pByte++ << 8);
			lcidTypeLib += (DWORD)(*pByte++ << 16);
			lcidTypeLib += (DWORD)(*pByte++ << 24);

			hr = Create(guidTypeInfo, guidTypeLib,lcidTypeLib, static_cast<WORD>(verMajor), static_cast<WORD>(verMinor));
		}
	}

	if( SUCCEEDED(hr) )
	{
		hr = QueryInterface(riid, ppv);
	}

	return hr;
}

HRESULT CMarshalableTI::ReleaseMarshalData(
            /* [unique][in] */ IStream *pStm)
{
	return S_OK;
}

HRESULT CMarshalableTI::DisconnectObject(
            /* [in] */ DWORD dwReserved)
{
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ITypeInfo Methods
/////////////////////////////////////////////////////////////////////////////

HRESULT CMarshalableTI::GetTypeAttr(
                TYPEATTR ** ppTypeAttr
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetTypeAttr(ppTypeAttr);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetTypeComp(
                ITypeComp ** ppTComp
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetTypeComp(ppTComp);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetFuncDesc(
                UINT index,
                FUNCDESC ** ppFuncDesc
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetFuncDesc(index, ppFuncDesc);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetVarDesc(
                UINT index,
                VARDESC ** ppVarDesc
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetVarDesc(index, ppVarDesc);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetNames(
                MEMBERID memid,
                BSTR * rgBstrNames,
                UINT cMaxNames,
                UINT * pcNames
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetNames(memid, rgBstrNames, cMaxNames, pcNames);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetRefTypeOfImplType(
                UINT index,
                HREFTYPE * pRefType
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetRefTypeOfImplType(index, pRefType);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetImplTypeFlags(
                UINT index,
                INT * pImplTypeFlags
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetImplTypeFlags(index, pImplTypeFlags);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetIDsOfNames(
                LPOLESTR * rgszNames,
                UINT cNames,
                MEMBERID * pMemId
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetIDsOfNames(rgszNames, cNames, pMemId);
	}
	return hr; 
}


HRESULT CMarshalableTI:: Invoke(
                PVOID pvInstance,
                MEMBERID memid,
                WORD wFlags,
                DISPPARAMS * pDispParams,
                VARIANT * pVarResult,
                EXCEPINFO * pExcepInfo,
                UINT * puArgErr
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->Invoke(pvInstance, memid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
	return hr; 
}

HRESULT CMarshalableTI:: GetDocumentation(
                MEMBERID memid,
                BSTR * pBstrName,
                BSTR * pBstrDocString,
                DWORD * pdwHelpContext,
                BSTR * pBstrHelpFile
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetDocumentation(memid, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetDllEntry(
                MEMBERID memid,
                INVOKEKIND invKind,
                BSTR * pBstrDllName,
                BSTR * pBstrName,
                WORD * pwOrdinal
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetDllEntry(memid, invKind, pBstrDllName, pBstrName, pwOrdinal);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetRefTypeInfo(
                HREFTYPE hRefType,
                ITypeInfo ** ppTInfo
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetRefTypeInfo(hRefType, ppTInfo);
	}
	return hr; 
}


HRESULT CMarshalableTI:: AddressOfMember(
                MEMBERID memid,
                INVOKEKIND invKind,
                PVOID * ppv
            ) 
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->AddressOfMember(memid, invKind, ppv);
	}
	return hr; 
}



HRESULT CMarshalableTI:: CreateInstance(
                IUnknown * pUnkOuter,
                REFIID riid,
                PVOID * ppvObj
            ) 
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->CreateInstance(pUnkOuter, riid, ppvObj );
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetMops(
                MEMBERID memid,
                BSTR * pBstrMops
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetMops(memid, pBstrMops);
	}
	return hr; 
}


HRESULT CMarshalableTI:: GetContainingTypeLib(
                ITypeLib ** ppTLib,
                UINT * pIndex
            )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		hr = spTI->GetContainingTypeLib(ppTLib, pIndex);
	}
	return hr; 
}

void CMarshalableTI::ReleaseTypeAttr(
            TYPEATTR * pTypeAttr
        )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		spTI->ReleaseTypeAttr(pTypeAttr);
	}
}

void CMarshalableTI::ReleaseFuncDesc(
            FUNCDESC * pFuncDesc
        )
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		spTI->ReleaseFuncDesc(pFuncDesc);
	}
}

void CMarshalableTI::ReleaseVarDesc(
            VARDESC * pVarDesc
        ) 
{ 
	HRESULT hr = S_OK;
	CComPtr<ITypeInfo> spTI;
	if( SUCCEEDED( hr = _GetClassInfo(&spTI) ) )
	{
		spTI->ReleaseVarDesc(pVarDesc);
	}
}


HRESULT CMarshalableTI::_GetClassInfo(ITypeInfo** ppTI)
{
	HRESULT hr = S_OK;

	hr = m_TIHolder.GetTI(m_lcid, ppTI);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\nmapp.h ===
#ifndef __NmApp_h__
#define __NmApp_h__

#include "resource.h"       // main symbols
#include "imsconf3.h"
#include "NetMeeting.h"

/////////////////////////////////////////////////////////////////////////////
// CNetMeetingObj
class ATL_NO_VTABLE CNetMeetingObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNetMeetingObj, &CLSID_NetMeeting>
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMAPP)

BEGIN_COM_MAP(CNetMeetingObj)
END_COM_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CNmManagerObj
class ATL_NO_VTABLE CNmManagerObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmManagerObj, &CLSID_NmManager>
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMMANAGER)

BEGIN_COM_MAP(CNmManagerObj)
END_COM_MAP()

};


#endif //__NmApp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\mrulist2.h ===
// File: mrulist.h

#ifndef _MRULIST_H_
#define _MRULIST_H_

typedef struct  DWSTR
    {
    DWORD dw;
    LPTSTR psz;
    }	DWSTR;


typedef VOID * PMRUE;  // MRU Entries

enum {
	MRUTYPE_SZ = 1,
	MRUTYPE_DW = 2,
};

class CMRUList2
{
private:
	const DWSTR * m_prgDwStr;// {{cCol, pszKey}, {mruType, pszPrefix1}, {mruType, pszPrefix2},...}
	int     m_cCol;       // number of "columns" (data entries in m_prgDwStr)
	int     m_cEntryMax;  // maximum number of entries
	int	    m_cEntry;     // current number of entries
	PMRUE * m_rgpEntry;   // array of pointers to MRU data
	BOOL    m_fDirty;     // TRUE if data was changed
	BOOL    m_fReversed;  // Load/Save data reversed (old style)

	BOOL    FValidCol(int i)    {return ((i >= 0) && (i < m_cCol));}
	BOOL    FValidIndex(int i)  {return ((i >= 0) && (i < m_cEntry));}
	BOOL    FDirty()            {return m_fDirty;}
	BOOL    FReversed()         {return m_fReversed;}

	inline PMRUE GetEntry(int iItem)
	{
		ASSERT(FValidIndex(iItem));
		return m_rgpEntry[iItem];
	}

	inline int MruTypeForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].dw;
	}

	inline LPCTSTR PszPrefixForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].psz;
	}

	inline LPCTSTR PszRegKey(void)
	{
		return m_prgDwStr[0].psz;
	}

	VOID    ShiftEntriesDown(int cItem);

public:
	CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReverse = FALSE);
	~CMRUList2();

	int     GetNumEntries()     {return m_cEntry;}
	VOID    SetDirty(BOOL fDirty)     {m_fDirty = fDirty;}

	// Generic functions
	int     FindEntry(PMRUE pEntry);
	VOID    MoveEntryToTop(int iItem);
	int     CompareEntry(int iItem, PMRUE pEntry);
	PMRUE   LoadEntry(RegEntry * pre, int iItem);
	VOID    StoreEntry(RegEntry * pre, int iItem);
	VOID    DeleteEntry(PMRUE pEntry);
	VOID    DeleteEntry(int iItem);

	void
	DeleteEntry
	(
		const TCHAR * const	primaryString
	);
	
	HRESULT Save(void);
	LPCTSTR PszEntry(int iItem);
	LPCTSTR PszData2(int iItem);
	DWORD_PTR PszData3(int iItem);

	HRESULT AddEntry(PMRUE pEntry);
	HRESULT AddEntry(LPCTSTR pcsz);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3);
};


#endif /* _MRULIST_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\mrulist2.cpp ===
// File: mrulist.cpp

#include "precomp.h"

#include "mrulist2.h"

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
} SZSZ;
typedef SZSZ * PSZSZ;

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
	DWORD  dw;
} SZSZDW;
typedef SZSZDW * PSZSZDW;


static LPTSTR PszAlloc(LPCTSTR pszSrc)
{
	if (NULL == pszSrc)
		return NULL;

	LPTSTR pszDest = new TCHAR[lstrlen(pszSrc) + 1];
	if (NULL != pszDest)
	{
		lstrcpy(pszDest, pszSrc);
	}
	return pszDest;
}

/*  C  M  R  U  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: CMRUList2

-------------------------------------------------------------------------*/
CMRUList2::CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReversed) :
	m_prgDwStr   (prgDwStr),
	m_cEntryMax (cEntryMax),
	m_fReversed (fReversed),
	m_cEntry    (0),
	m_rgpEntry  (NULL),
	m_fDirty    (FALSE)
{
	DBGENTRY(CMRUList2::CMRUList2);

	ASSERT(NULL != prgDwStr);
	m_cCol = m_prgDwStr[0].dw;

	int cb = m_cEntryMax * sizeof(PMRUE);
	m_rgpEntry = new PMRUE[cb];
	if (NULL == m_rgpEntry)
	{
		ERROR_OUT(("CMRUList2 - out of memory"));
		return;
	}
	ZeroMemory(m_rgpEntry, cb);

	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return;

	m_cEntry = min(re.GetNumber(REGVAL_MRU_COUNT, 0), m_cEntryMax);
	for (int i = 0; i < m_cEntry; i++)
	{
		m_rgpEntry[i] = LoadEntry(&re, i);
	}
}

CMRUList2::~CMRUList2()
{
	DBGENTRY(CMRUList2::~CMRUList2);

	if (m_fDirty)
	{
		Save();
	}

	for (int i = 0; i < m_cEntry; i++)
	{
		DeleteEntry(m_rgpEntry[i]);
	}
	delete m_rgpEntry;
}


///////////////////////////////////////////////////////////////////////////

PMRUE CMRUList2::LoadEntry(RegEntry * pre, int iItem)
{
	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	PMRUE pEntry = (PMRUE) new PVOID[m_cCol*sizeof(PVOID)];
	if (NULL != pEntry)
	{
		PVOID ** ppv = (PVOID **) pEntry;
		for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
			switch (MruTypeForCol(iCol))
				{
			default:
			case MRUTYPE_SZ:
				* (LPTSTR *)ppv = PszAlloc(pre->GetString(szKey));
				break;
			case MRUTYPE_DW:
				* (DWORD *) ppv = pre->GetNumber(szKey);
				break;
				}
		}
	}

	return pEntry;
}

VOID CMRUList2::StoreEntry(RegEntry * pre, int iItem)
{
	PVOID ** ppv = (PVOID **) GetEntry(iItem);

	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		TCHAR szKey[MAX_PATH];
		wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			pre->SetValue(szKey, * (LPCTSTR *)ppv);
			break;
		case MRUTYPE_DW:
			pre->SetValue(szKey, * (ULONG *) ppv);
			break;
			}
	}
}

VOID CMRUList2::DeleteEntry(PMRUE pEntry)
{
	PVOID ** ppv = (PVOID **) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			delete *ppv;
			break;
		case MRUTYPE_DW:
			break;
			}
	}
	delete pEntry;
}

VOID CMRUList2::DeleteEntry(int iItem)
{
	if ((iItem < 0) || (iItem >= m_cEntry))
		return; // nothing to do

	// delete the data
	DeleteEntry(m_rgpEntry[iItem]);

	// decrement the count
	m_cEntry--;

	// shift items up
	for ( ; iItem < m_cEntry; iItem++)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem+1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


//--------------------------------------------------------------------------//
//	CMRUList2::DeleteEntry.													//
//		This DeleteEntry() deletes the first entry it finds thats primary	//
//		string matches the one passed in.									//
//--------------------------------------------------------------------------//
void
CMRUList2::DeleteEntry
(
	const TCHAR * const	primaryString
){
	int	items	= GetNumEntries();

	for( int nn = 0; nn < items; nn++ )
	{
		if( StrCmpI( primaryString, * ((const TCHAR * const * const) m_rgpEntry[ nn ]) ) == 0 )
		{
			DeleteEntry( nn );
			break;
		}
	}

}	//	End of CMRUList2::DeleteEntry.


/*  C O M P A R E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CompareEntry

-------------------------------------------------------------------------*/
int CMRUList2::CompareEntry(int iItem, PMRUE pEntry)
{
	ASSERT(NULL != pEntry);

	int iRet = 0;

	PVOID * ppv1 = (PVOID *) GetEntry(iItem);
	PVOID * ppv2 = (PVOID *) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv1++, ppv2++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			iRet = lstrcmpi(* (LPCTSTR *) ppv1, * (LPCTSTR *) ppv2);
			break;
		case MRUTYPE_DW:
			iRet = (* (int *) ppv1) - (* (int *) ppv2);
			break;
			}

		if (0 != iRet)
			break;
	}

	return iRet;
}


/*  F I N D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: FindEntry

     Return -1 if the item is not found.
-------------------------------------------------------------------------*/
int CMRUList2::FindEntry(PMRUE pEntry)
{
	int cItems = GetNumEntries();
	for (int i = 0; i < cItems; i++)
	{
		if (0 == CompareEntry(i, pEntry))
		{
			return i;
		}
	}

	return -1; // not found
}



		
/*  S A V E  */
/*-------------------------------------------------------------------------
    %%Function: Save

-------------------------------------------------------------------------*/
HRESULT CMRUList2::Save(void)
{
	DBGENTRY(CMRUList2::Save);

	// Retrieve the data from the registry
	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return E_FAIL;

	re.SetValue(REGVAL_MRU_COUNT, m_cEntry);
	for (int i = 0; i < m_cEntry; i++)
	{
		StoreEntry(&re, i);
	}

	return S_OK;
}


/*  S H I F T  E N T R I E S  D O W N  */
/*-------------------------------------------------------------------------
    %%Function: ShiftEntriesDown

    Shift the entires down by one slot leaving the first position open.
-------------------------------------------------------------------------*/
VOID CMRUList2::ShiftEntriesDown(int cItem)
{
	if (cItem < 1)
		return; // nothing to do

	int iItem;
	for (iItem = cItem; iItem > 0; iItem--)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem-1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


/*  M O V E  E N T R Y  T O  T O P  */
/*-------------------------------------------------------------------------
    %%Function: MoveEntryToTop

-------------------------------------------------------------------------*/
VOID CMRUList2::MoveEntryToTop(int iItem)
{
	DBGENTRY(CMRUList2::MoveEntryToTop);

	if ((iItem < 1) || (iItem >= m_cEntry))
		return; // nothing to do

	PMRUE pEntry = GetEntry(iItem);
	ShiftEntriesDown(iItem);
	m_rgpEntry[0] = pEntry;
}


/*  A D D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: AddEntry

	Put the entry into the top of the list.
	The data is owned by the list after this.
	
    Returns:
    	S_OK    - added to the head of the list
    	S_FALSE - already in list (item is moved to top)
-------------------------------------------------------------------------*/
HRESULT CMRUList2::AddEntry(PMRUE pEntry)
{
	DBGENTRY(CMRUList2::AddEntry);

	// the list has been modified
	m_fDirty = TRUE;

	int iItem = FindEntry(pEntry);
	if (-1 != iItem)
	{
		// This entry already exists, move it to the top:
		MoveEntryToTop(iItem);
		DeleteEntry(pEntry); // don't need this data
		return S_FALSE; // Success, but already in the list
	}

	int cShift;
	if (m_cEntryMax == m_cEntry)
	{
		// drop the last item
		DeleteEntry(m_rgpEntry[m_cEntry-1]);
		cShift = m_cEntry-1;
	}
	else
	{
		cShift = m_cEntry;
		m_cEntry++;
	}
	ShiftEntriesDown(cShift);

	// add it to the head of the list
	m_rgpEntry[0] = pEntry;

	return S_OK;
}


HRESULT CMRUList2::AddEntry(LPCTSTR pcsz)
{
	LPTSTR * ppsz = new LPTSTR;
	LPTSTR psz = PszAlloc(pcsz);
	if ((NULL == ppsz) || (NULL == psz))
	{
		delete ppsz;
		delete psz;
		return E_OUTOFMEMORY;
	}

	*ppsz = psz;

	return AddEntry((PMRUE) ppsz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2)
{
	PSZSZ pSzSz = new SZSZ;
	if (NULL == pSzSz)
		return E_OUTOFMEMORY;

	pSzSz->psz1 = PszAlloc(pcsz1);
	pSzSz->psz2 = PszAlloc(pcsz2);
	if ((NULL == pSzSz->psz1) || (NULL == pSzSz->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pSzSz);
		return E_OUTOFMEMORY;
	}
	
	return AddEntry((PMRUE) pSzSz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3)
{
	PSZSZDW pData = new SZSZDW;
	if (NULL == pData)
		return E_OUTOFMEMORY;

	pData->psz1 = PszAlloc(pcsz1);
	pData->psz2 = PszAlloc(pcsz2);
	if ((NULL == pData->psz1) || (NULL == pData->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pData);
		return E_OUTOFMEMORY;
	}
	pData->dw = dw3;
	
	return AddEntry((PMRUE) pData);
}


/*  P S Z  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: PszEntry

    Return the main string associated with the entry
-------------------------------------------------------------------------*/
LPCTSTR CMRUList2::PszEntry(int iItem)
{
	PMRUE pEntry = GetEntry(iItem);
	return (LPCTSTR) * ((LPTSTR *)pEntry);
}

LPCTSTR CMRUList2::PszData2(int iItem)
{
	PMRUE pEntry = GetEntry(iItem);
	LPTSTR * ppsz = ((LPTSTR *)pEntry);
	return * (ppsz+1);
}

DWORD_PTR CMRUList2::PszData3(int iItem)
{
	PMRUE pEntry = GetEntry(iItem);
	LPTSTR * ppsz = ((LPTSTR *)pEntry);
	return (DWORD_PTR) * (ppsz+2);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\nmsysinfo.cpp ===
#include "precomp.h"
#include "version.h"
#include "nacguids.h"
#include "RegEntry.h"
#include "ConfReg.h"
#include "NmSysInfo.h"
#include "capflags.h"

#define SZ_YES 	_T("1")
#define SZ_NO	_T("0")	

//
//  Hack alert:
//  
//      The follwoing system property constant is used to inform
//  the Netmeeting Manager object that the caller is Whistler
//  RTC client so that it can take some actions for performance
//  purpose, i.e. don't poll A/V capabilities and don't do
//  ILS logon.
//
//  This value MUST NOT collide with the NM_SYSPROP_Consts defined
//  in imsconf3.idl
//
#define NM_SYSPROP_CALLERISRTC 300

///////////////////////////////////////////////
// Init and construction methods
///////////////////////////////////////////////

HRESULT CNmSysInfoObj::FinalConstruct()
{	
	DBGENTRY(CNmSysInfoObj::FinalConstruct);
	HRESULT hr = S_OK;

	m_dwID = 0;

	DBGEXIT_HR(CNmSysInfoObj::FinalConstruct,hr);
	return hr;
}


void CNmSysInfoObj::FinalRelease()
{
	DBGENTRY(CNmSysInfoObj::FinalRelease);
	
	m_spConfHook = NULL;

	DBGEXIT(CNmSysInfoObj::FinalRelease);
}

///////////////////////////////////////////////
// INmSysInfo2 methods
///////////////////////////////////////////////

STDMETHODIMP CNmSysInfoObj::IsInstalled(void)
{
	DBGENTRY(CNmSysInfoObj::IsInstalled);
	HRESULT hr = S_OK;
	TCHAR sz[MAX_PATH];

		// Fail if not a valid installation directory
	if (GetInstallDirectory(sz) && FDirExists(sz))
	{
			// Validate ULS entries
		RegEntry reUls(ISAPI_KEY "\\" REGKEY_USERDETAILS, HKEY_CURRENT_USER);
		LPTSTR psz;

		hr = NM_E_NOT_INITIALIZED;
		psz = reUls.GetString(REGVAL_ULS_EMAIL_NAME);
		if (lstrlen(psz))
		{
			psz = reUls.GetString(REGVAL_ULS_RES_NAME);
			{

				RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

				// check to see if the wizard has been run in UI mode
				DWORD dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_UI, 0);
				BOOL fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
				if (fForceWizard)
				{
					// the wizard has not been run in UI mode, check to see if its been run in NOUI mode
					dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_NOUI, 0);
					fForceWizard = (VER_PRODUCTVERSION_DW != dwVersion);
				}

				if (fForceWizard)
				{
					hr = S_FALSE;  // Wizard has never been run
				}
				else
				{
					hr = S_OK;
				}
			}
		}
	}
	else
	{
		hr = E_FAIL;
	}

	DBGEXIT_HR(CNmSysInfoObj::IsInstalled,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetProperty(NM_SYSPROP uProp, BSTR *pbstrProp)
{
	DBGENTRY(CNmSysInfoObj::GetProperty);

	HRESULT hr = S_OK;

	if(pbstrProp)
	{
		switch (uProp)
		{
			case NM_SYSPROP_BUILD_VER:
				*pbstrProp = T2BSTR(VER_PRODUCTVERSION_STR);
				break;

			case NM_SYSPROP_LOGGED_ON:
				_EnsureConfHook();
				if(m_spConfHook)
				{
					*pbstrProp = T2BSTR((S_OK == m_spConfHook->LoggedIn()) ? SZ_YES : SZ_NO);
				}
				break;

			case NM_SYSPROP_IS_RUNNING:
				_EnsureConfHook();
				if(m_spConfHook)
				{
					*pbstrProp = T2BSTR((S_OK == m_spConfHook->IsRunning()) ? SZ_YES : SZ_NO);
				}
				break;

			case NM_SYSPROP_IN_CONFERENCE:
				_EnsureConfHook();
				if(m_spConfHook)
				{
					*pbstrProp = T2BSTR((S_OK == m_spConfHook->InConference()) ? SZ_YES : SZ_NO);
				}
				break;

			case NM_SYSPROP_USER_CITY:
			case NM_SYSPROP_USER_COUNTRY:
			case NM_SYSPROP_USER_CATEGORY:
				*pbstrProp = T2BSTR((""));
				break;

			case NM_SYSPROP_ICA_ENABLE:
				*pbstrProp = T2BSTR(("0"));
				break;

			default:
			{
				HKEY   hkey;
				LPTSTR pszSubKey;
				LPTSTR pszValue;
				bool   fString;
				TCHAR  sz[MAX_PATH];

				if(GetKeyDataForProp(uProp, &hkey, &pszSubKey, &pszValue, &fString))
				{
					RegEntry re(pszSubKey, hkey);
					if (fString)
					{
						*pbstrProp = T2BSTR(re.GetString(pszValue));
					}
					else
					{
						DWORD dw = re.GetNumber(pszValue, 0);
						wsprintf(sz, "%d", dw);
						*pbstrProp = T2BSTR(sz);
						break;
					}
				}
				else
				{
					pbstrProp = NULL;
					hr = E_INVALIDARG;
				}
			}
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmSysInfoObj::GetProperty,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::SetProperty(NM_SYSPROP uProp, BSTR bstrName)
{
	DBGENTRY(CNmSysInfoObj::SetProperty);
	USES_CONVERSION;

	HRESULT hr = S_OK;
	LPTSTR  psz;

	if( bstrName )
	{
		// Special processing for new NM 2.x functions
		switch (uProp)
		{
			case NM_SYSPROP_LOGGED_ON:
			{

				_EnsureConfHook();
				if(m_spConfHook)
				{
					if(0 == lstrcmp(SZ_YES,OLE2T(bstrName)))
					{
						m_spConfHook->LDAPLogon(TRUE);
					}
					else
					{
						m_spConfHook->LDAPLogon(FALSE);
					}
				}

				break;
			}
			
			case NM_SYSPROP_DISABLE_H323:
			{
				_EnsureConfHook();

				if(m_spConfHook)
				{
					hr = m_spConfHook->DisableH323(0 == lstrcmp(SZ_YES,OLE2T(bstrName)));
				}
			}
				break;

			case NM_SYSPROP_DISABLE_INITIAL_ILS_LOGON:
			{
				_EnsureConfHook();

				if(m_spConfHook)
				{
					hr = m_spConfHook->DisableInitialILSLogon(0 == lstrcmp(SZ_YES,OLE2T(bstrName)));
				}

			}
				break;

			case NM_SYSPROP_CALLERISRTC:
			{
				_EnsureConfHook();

				if(m_spConfHook)
				{
					hr = m_spConfHook->SetCallerIsRTC(0 == lstrcmp(SZ_YES,OLE2T(bstrName)));
				}
			}
				break;

			case NM_SYSPROP_ICA_ENABLE:
			case NM_SYSPROP_USER_CITY:
			case NM_SYSPROP_USER_COUNTRY:
			case NM_SYSPROP_USER_CATEGORY:
			case NM_SYSPROP_USER_LOCATION:
				// We don't support these properties anymore
				hr = S_OK;
				break;

			case NM_SYSPROP_WB_HELPFILE:
			case NM_SYSPROP_CB_HELPFILE:
			{	
					// We don't use these anymare
				hr = S_OK;
				break;
			}

			default:
			{
				LPTSTR  pszSubKey;
				LPTSTR  pszValue;
				LPTSTR  pszData;
				bool    fString;
				HKEY    hkey;

				if(GetKeyDataForProp(uProp, &hkey, &pszSubKey, &pszValue, &fString))
				{
					pszData = NULL;
					pszData = OLE2T(bstrName);
					RegEntry re(pszSubKey, hkey);

					if (fString)
					{
						if (0 != re.SetValue(pszValue, pszData))
						{
							hr = E_UNEXPECTED;
						}
					}
					else
					{
						DWORD dw = DecimalStringToUINT(pszData);
						if (0 != re.SetValue(pszValue, dw))
						{
							hr = E_UNEXPECTED;
						}
					}
				}
				else
				{
					hr = E_INVALIDARG;
				}
				break;
			}
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}


	DBGEXIT_HR(CNmSysInfoObj::SetProperty,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	HRESULT hr = E_FAIL;

	_EnsureConfHook();

	if(m_spConfHook)
	{
		return m_spConfHook->GetUserData(rguid, ppb, pcb);
	}

	return hr;
}

STDMETHODIMP CNmSysInfoObj::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	HRESULT hr = E_FAIL;

	_EnsureConfHook();

	if(m_spConfHook)
	{
		return m_spConfHook->SetUserData(rguid, pb, cb);
	}

	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetNmApp(REFGUID rguid,BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory)
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmSysInfoObj::GetNmApp);
	bool bErr = FALSE;
	TCHAR szKey[MAX_PATH];

	// Validate parameters
	if ((!pbstrApplication) || (!IsBadWritePtr(pbstrApplication, sizeof(BSTR *))) &&
		(!pbstrCommandLine) || (!IsBadWritePtr(pbstrCommandLine, sizeof(BSTR *))) &&
		(!pbstrDirectory)   || (!IsBadWritePtr(pbstrDirectory,   sizeof(BSTR *))) )
	{
		
		_GetSzKeyForGuid(szKey, rguid);
		RegEntry re(szKey, HKEY_LOCAL_MACHINE);
		
		if(pbstrApplication)
		{
			*pbstrApplication = T2BSTR(re.GetString(REGVAL_GUID_APPNAME));
			if(NULL == *pbstrApplication)
			{
				bErr = true;
			}
		}
		if(pbstrCommandLine)
		{
			*pbstrCommandLine = T2BSTR(re.GetString(REGVAL_GUID_CMDLINE));
			if(NULL == *pbstrCommandLine)
			{
				bErr = true;
			}
		}
		if(pbstrDirectory)
		{
			*pbstrDirectory = T2BSTR(re.GetString(REGVAL_GUID_CURRDIR));
			if(NULL == *pbstrDirectory)
			{
				bErr = true;
			}
		}

		if(bErr)
		{
			if (NULL != pbstrApplication)
			{
				SysFreeString(*pbstrApplication);
				*pbstrApplication = NULL;
			}
			if (NULL != pbstrCommandLine)
			{
				SysFreeString(*pbstrCommandLine);
				*pbstrCommandLine = NULL;
			}
			if (NULL != pbstrDirectory)
			{
				SysFreeString(*pbstrDirectory);
				*pbstrDirectory = NULL;
			}
			hr = E_OUTOFMEMORY;
		}

	}
	else
	{
		hr = E_POINTER;
	}


	DBGEXIT_HR(CNmSysInfoObj::GetNmApp,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::SetNmApp(REFGUID rguid,BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory)
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmSysInfoObj::SetNmApp);
	USES_CONVERSION;

	bool    bDeleteKey = TRUE;
	LPTSTR  psz = NULL;
	TCHAR   szKey[MAX_PATH];

	_GetSzKeyForGuid(szKey, rguid);
	RegEntry re(szKey, HKEY_LOCAL_MACHINE);
	
	if(!bstrApplication)
	{
		re.DeleteValue(REGVAL_GUID_APPNAME);
	}
	else
	{
		psz = OLE2T(bstrApplication);
		if(psz)
		{
			re.SetValue(REGVAL_GUID_APPNAME, psz);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		bDeleteKey = false;
	}
	
	if (NULL == bstrCommandLine)
	{
		re.DeleteValue(REGVAL_GUID_CMDLINE);
	}
	else
	{
		psz = OLE2T(bstrCommandLine);
		if(psz)
		{
			re.SetValue(REGVAL_GUID_CMDLINE, psz);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		bDeleteKey = false;
	}

	if (NULL == bstrDirectory)
	{
		re.DeleteValue(REGVAL_GUID_CURRDIR);
	}
	else
	{	
		psz = OLE2T(bstrDirectory);
		if(psz)
		{
			re.SetValue(REGVAL_GUID_CURRDIR, psz);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

		bDeleteKey = false;
	}

	if (bDeleteKey)
	{
		// All keys were NULL - delete the entire key
		RegEntry reApps(GUID_KEY, HKEY_LOCAL_MACHINE);
		GuidToSz((GUID *) &rguid, szKey);
		reApps.DeleteValue(szKey);
	}

	DBGEXIT_HR(CNmSysInfoObj::SetNmApp,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetNmchCaps(ULONG *pchCaps)
{
	DBGENTRY(CNmSysInfoObj::GetNmchCaps);
	HRESULT hr = S_OK;

	_EnsureConfHook();

	if(m_spConfHook)
	{
		if(pchCaps && !IsBadWritePtr(pchCaps, sizeof(ULONG *)))
		{
			ULONG nmch = NMCH_DATA;  // Always capable of data
			RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);

			if ((DEFAULT_POL_NO_FILETRANSFER_SEND == re.GetNumber(REGVAL_POL_NO_FILETRANSFER_SEND,
				 DEFAULT_POL_NO_FILETRANSFER_SEND)) &&
				(DEFAULT_POL_NO_FILETRANSFER_RECEIVE == re.GetNumber(REGVAL_POL_NO_FILETRANSFER_RECEIVE,
				 DEFAULT_POL_NO_FILETRANSFER_RECEIVE)) )
			{
				nmch |= NMCH_FT;
			}

			if (DEFAULT_POL_NO_APP_SHARING == re.GetNumber(REGVAL_POL_NO_APP_SHARING,
				DEFAULT_POL_NO_APP_SHARING))
			{
				nmch |= NMCH_SHARE;
			}

			if (DEFAULT_POL_NO_AUDIO == re.GetNumber(REGVAL_POL_NO_AUDIO,
				DEFAULT_POL_NO_AUDIO))
			{
				if(S_OK == m_spConfHook->IsNetMeetingRunning())
				{
					DWORD dwLocalCaps;
					if(SUCCEEDED(m_spConfHook->GetLocalCaps(&dwLocalCaps)) && (dwLocalCaps & CAPFLAG_SEND_AUDIO))
					{
						nmch |= NMCH_AUDIO;
					}
				}
			}

			if ((DEFAULT_POL_NO_VIDEO_SEND == re.GetNumber(REGVAL_POL_NO_VIDEO_SEND,
				 DEFAULT_POL_NO_VIDEO_SEND)) &&
				(DEFAULT_POL_NO_VIDEO_RECEIVE == re.GetNumber(REGVAL_POL_NO_VIDEO_RECEIVE,
				 DEFAULT_POL_NO_VIDEO_RECEIVE)) )
			{
				if(S_OK == m_spConfHook->IsNetMeetingRunning())
				{
					DWORD dwLocalCaps;
					if(SUCCEEDED(m_spConfHook->GetLocalCaps(&dwLocalCaps)) && (dwLocalCaps & CAPFLAG_SEND_VIDEO))
					{
						nmch |= NMCH_VIDEO;
					}
				}
			}

			*pchCaps = nmch;
		}
		else
		{
			hr = E_POINTER;
		}

		if(SUCCEEDED(hr))
		{
			hr = m_spConfHook->IsNetMeetingRunning();
		}
	}
	else
	{
		ERROR_OUT(("The confhook should be valid"));
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmSysInfoObj::GetNmchCaps,hr);
	return hr;
}

STDMETHODIMP CNmSysInfoObj::GetLaunchInfo(INmConference **ppConference, INmMember **ppMember)
{
	DBGENTRY(CNmSysInfoObj::GetLaunchInfo);
	HRESULT hr = S_OK;


	if(ppMember)
	{
		*ppMember = NULL;
	}

	if(ppConference)
	{
		*ppConference = NULL;
	}

	_EnsureConfHook();

	if(m_spConfHook)
	{			
		// If NetMeeting is not initialized, return NM_E_NOT_INITIALIZED
		hr = m_spConfHook->IsNetMeetingRunning();
		if(S_OK != hr) goto end;

		// If there is no default conference, return S_FALSE
		CComPtr<INmConference> spConf;
		hr = m_spConfHook->GetActiveConference(&spConf);
		if(S_OK != hr) goto end;

		// If the confID environment variable is not there, return S_FALSE
		TCHAR sz[MAX_PATH];
		if (0 == GetEnvironmentVariable(ENV_CONFID, sz, CCHMAX(sz)))
		{
			hr = S_FALSE;
			goto end;
		}

		// If the conference ID from the environment variable is not there, return S_FALSE
		DWORD dw = DecimalStringToUINT(sz);

		DWORD dwGCCConfID;

		if(SUCCEEDED(hr = spConf->GetID(&dwGCCConfID)))
		{
			if(dw != dwGCCConfID)
			{		
					// Conferenec does not exist anymore
				hr = S_FALSE;
				goto end;
			}

			// If the nodeID environment variable is note there, return S_FALSE
			if (0 == GetEnvironmentVariable(ENV_NODEID, sz, CCHMAX(sz)))
			{
				hr = S_FALSE;
				goto end;
			}

			// If ppMember is not NULL, fill it with a new SDKMember object from the nodeID
			if(ppMember)
			{	
				CComPtr<IInternalConferenceObj> spConfObj = com_cast<IInternalConferenceObj>(spConf);
				if(spConfObj)
				{
					hr = spConfObj->GetMemberFromNodeID(DecimalStringToUINT(sz), ppMember);
				}
				else
				{
					hr = E_UNEXPECTED;
					goto end;
				}
			}
	
			// If ppConferenec is not NULL, fill it with a new SDKMember object 
			if(ppConference)
			{	
				*ppConference = spConf;
				(*ppConference)->AddRef();
			}
		}
	}
	else
	{	
		hr = E_UNEXPECTED;
	}

end:

	DBGEXIT_HR(CNmSysInfoObj::GetLaunchInfo,hr);
	return hr;
}


///////////////////////////////////////////////
// Helper Fns
///////////////////////////////////////////////

/*static*/ bool CNmSysInfoObj::GetKeyDataForProp(NM_SYSPROP uProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, bool *pfString)
{
	DBGENTRY(CNmSysInfoObj::GetKeyDataForProp);
	// Default to ULS registry key
	*phkey = HKEY_CURRENT_USER;
	*ppszSubKey = ISAPI_KEY "\\" REGKEY_USERDETAILS;
	*pfString = true;
	bool bRet = true;

	switch (uProp)
	{

		case NM_SYSPROP_EMAIL_NAME:    *ppszValue = REGVAL_ULS_EMAIL_NAME;    break;
		case NM_SYSPROP_SERVER_NAME:   *ppszValue = REGVAL_SERVERNAME;        break;
		case NM_SYSPROP_RESOLVE_NAME:  *ppszValue = REGVAL_ULS_RES_NAME;      break;
		case NM_SYSPROP_FIRST_NAME:    *ppszValue = REGVAL_ULS_FIRST_NAME;    break;
		case NM_SYSPROP_LAST_NAME:     *ppszValue = REGVAL_ULS_LAST_NAME;     break;
		case NM_SYSPROP_USER_NAME:     *ppszValue = REGVAL_ULS_NAME;          break;
		case NM_SYSPROP_USER_COMMENTS: *ppszValue = REGVAL_ULS_COMMENTS_NAME; break;
		case NM_SYSPROP_USER_CITY:     *ppszValue = REGVAL_ULS_LOCATION_NAME; break;

		case NM_SYSPROP_H323_GATEWAY:
			*ppszSubKey = AUDIO_KEY;
			*ppszValue = REGVAL_H323_GATEWAY;
			break;

		case NM_SYSPROP_H323_GATEWAY_ENABLE:
			*ppszSubKey = AUDIO_KEY;
			*ppszValue = REGVAL_USE_H323_GATEWAY;
			*pfString = FALSE;
			break;		

		case NM_SYSPROP_INSTALL_DIRECTORY:
			*phkey = HKEY_LOCAL_MACHINE;
			*ppszSubKey = CONFERENCING_KEY;
			*ppszValue = REGVAL_INSTALL_DIR;
			break;

		case NM_SYSPROP_APP_NAME:
			*phkey = HKEY_LOCAL_MACHINE;
			*ppszSubKey = CONFERENCING_KEY;
			*ppszValue = REGVAL_NC_NAME;
			break;

		default:
			WARNING_OUT(("GetKeyDataForProp - invalid argument %d", uProp));
			bRet = false;
			break;

	} /* switch (uProp) */

	DBGEXIT_BOOL(CNmSysInfoObj::GetKeyDataForProp,bRet ? TRUE : FALSE);
	return bRet;
}

/*static*/ void CNmSysInfoObj::_GetSzKeyForGuid(LPTSTR psz, REFGUID rguid)
{
	DBGENTRY(CNmSysInfoObj::_GetSzKeyForGuid);

	lstrcpy(psz, GUID_KEY "\\");
	GuidToSz((GUID *) &rguid, &psz[lstrlen(psz)]);

	DBGEXIT(CNmSysInfoObj::_GetSzKeyForGuid);
}

HRESULT CNmSysInfoObj::_EnsureConfHook(void)
{
	HRESULT hr = S_OK;

	if(!m_spConfHook)
	{
		hr = CoCreateInstance(CLSID_NmManager, NULL, CLSCTX_ALL, IID_IInternalConfExe, reinterpret_cast<void**>(&m_spConfHook));

		if(SUCCEEDED(hr))
		{
			m_spConfHook->SetSysInfoID(m_dwID);
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by si.rc
//
#define IDS_LAUNCH_ERROR                1
#define IDS_COULD_NOT_CALL              2
#define IDS_MSGBOX_TITLE                3
#define IDS_MS_INTERNET_DIRECTORY       4
#define IDS_NAME_ORDER                  5
#define IDI_SHORTCUT_ICON               103
#define IDI_USERINFO                    107
#define IDI_SERVER                      108
#define IDR_NMAPP                       200
#define IDR_NMMANAGER                   201
#define IDR_NMSYSINFO                   202
#define IDR_MSLABLTI					203
#define IDD_USERINFO                    300
#define IDG_UI_MYINFO                   301
#define IDE_UI_FIRSTNAME                302
#define IDE_UI_LASTNAME                 303
#define IDE_UI_EMAIL                    304
#define IDE_UI_LOCATION                 305
#define IDG_UI_DIRECTORY                306
#define IDE_UI_DIRECTORY                307

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        400
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\precomp.cpp ===
// precomp.cpp : source file that includes just the standard includes
//  precomp.pch will be the pre-compiled header
//  precomp.obj will contain the pre-compiled type information
#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
    #include <statreg.h>
    #include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\sidebug.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1996, Microsoft Corporation
	All rights reserved

	siDebug.c

  ---------------------------------------------------------------------- */

#include "precomp.h"

#ifdef DEBUG /* These functions are only available for DEBUG */


HDBGZONE ghZoneApi = NULL; // API zones
static PTCHAR _rgZonesApi[] = {
	TEXT("API"),
	TEXT("Warning"),
	TEXT("Events"),
	TEXT("Trace"),
	TEXT("Data"),
	TEXT("Objects"),
	TEXT("RefCount"),
};


VOID InitDebug(void)
{
	// Enable memory leak checking and keep freed memory blocks on the
	// heap's linked list (filled with 0xDD)
	//
	// This depends on the use of the debug c runtime library from VC++ 4.x
#if 0
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	tmpFlag |= (_CRTDBG_DELAY_FREE_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	_CrtSetDbgFlag(tmpFlag);
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box

//  To track down memory leaks, uncomment the following lines
	LONG cAlloc = 0; // Allocation number
	if (0 != cAlloc)
	{
		_CrtSetBreakAlloc(cAlloc);
	}
#endif // 0
	InitDebugModule(TEXT("MSCONF"));

	DBGINIT(&ghZoneApi, _rgZonesApi);
}

VOID DeInitDebug(void)
{
	DBGDEINIT(&ghZoneApi);
	ExitDebugModule();
}

UINT DbgApiWarn(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Warning", pszFormat, v1);
	va_end(v1);
	return 0;
}

UINT DbgApiEvent(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Event", pszFormat, v1);
	va_end(v1);
	return 0;
}

UINT DbgApiTrace(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Trace", pszFormat, v1);
	va_end(v1);
	return 0;
}

UINT DbgApiData(PCSTR pszFormat,...)
{
	va_list v1;
	va_start(v1, pszFormat);
	DbgPrintf("API:Data", pszFormat, v1);
	va_end(v1);
	return 0;
}






#endif /* DEBUG - the whole file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\precomp.h ===
// File: Precomp.h

// Standard Windows SDK includes
#include <windows.h>

#pragma warning( disable : 4786 )

    // default threading model
#define _ATL_APARTMENT_THREADED

// We should really only put this in for w2k
#define _ATL_NO_DEBUG_CRT

#define _ATL_NO_FORCE_LIBS

#if 0
	#define _ATL_DEBUG_QI
	#define _ATL_DEBUG_INTERFACES
	#define ATL_TRACE_LEVEL 4
#else
	#define ATL_TRACE_LEVEL 0
#endif

    // Our Override of ATLTRACE and other debug stuff
#include <ConfDbg.h>

// We should really only put this in for w2k
#define _ASSERTE(expr) ASSERT(expr)

    // ATLTRACE and other stuff
#include <atlbase.h>
#include <shellapi.h>


//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <limits.h>
#include <shlobj.h>
#include <shlwapi.h>

#include <debspew.h>
#include <confreg.h>
#include <oprahcom.h>
#include <regentry.h>
#include <cstring.hpp>
#include <oblist.h>

// COM interfaces
//
#include <ConfCli.h>


#include "siGlobal.h"

#include "CLink.h"
#include "clRefCnt.hpp"
#include "clEnumFt.hpp"
class CConfLink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\nmsysinfo.h ===
#ifndef __NmSysInfo_h__
#define __NmSysInfo_h__

#include "SDKInternal.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CNmSysInfoObj
class ATL_NO_VTABLE CNmSysInfoObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmSysInfoObj, &CLSID_NmSysInfo>,
	public IConnectionPointContainerImpl<CNmSysInfoObj>,
	public IConnectionPointImpl<CNmSysInfoObj, &IID_INmSysInfoNotify, CComDynamicUnkArray>,
	public IMarshal,
	public INmSysInfo,
	public IInternalSysInfoObj
{

	CComPtr<IInternalConfExe> m_spConfHook;
	DWORD m_dwID;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMSYSINFO)
DECLARE_NOT_AGGREGATABLE(CNmSysInfoObj)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNmSysInfoObj)
	COM_INTERFACE_ENTRY(INmSysInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMarshal)
	COM_INTERFACE_ENTRY(IInternalSysInfoObj)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmSysInfoObj)
	CONNECTION_POINT_ENTRY(IID_INmSysInfoNotify)
END_CONNECTION_POINT_MAP()

	HRESULT FinalConstruct();
	void FinalRelease();

///////////////////////////////////////////////
// INmSysInfo methods

	STDMETHOD(IsInstalled)(void);
	STDMETHOD(GetProperty)(NM_SYSPROP uProp, BSTR *pbstrProp);
	STDMETHOD(SetProperty)(NM_SYSPROP uProp, BSTR bstrName);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(SetUserData)(REFGUID rguid, BYTE *pb, ULONG cb);
	STDMETHOD(GetNmApp)(REFGUID rguid,BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory);
	STDMETHOD(SetNmApp)(REFGUID rguid,BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory);
	STDMETHOD(GetNmchCaps)(ULONG *pchCaps);
	STDMETHOD(GetLaunchInfo)(INmConference **ppConference, INmMember **ppMember);

//--------------------------------------------------------------------------
// IInternalSysInfoObj

	STDMETHOD(SetID)(DWORD ID)	  { m_dwID = ID;   return S_OK; }

/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid) { *pCid = CLSID_NmSysInfo; return S_OK; };

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize) { *pSize = sizeof(ULONG); return S_OK; }

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags) 
			{ 
				// Since we don't know the endian-ness of the other side,
				// we use a private wire format for custom marshaling here.
				//
				BYTE buf[sizeof(DWORD)];
				BYTE * pByte = buf;
				*pByte++ = (BYTE)(m_dwID);
				*pByte++ = (BYTE)(m_dwID >> 8);
				*pByte++ = (BYTE)(m_dwID >> 16);
				*pByte++ = (BYTE)(m_dwID >> 24);

				pStm->Write(buf, sizeof(buf), NULL);

				return S_OK; 
			}

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv)
			{
				// Since we don't know the endian-ness of the other side,
				// we use a private wire format for custom marshaling here.
				//
				BYTE buf[sizeof(DWORD)];
				pStm->Read(buf, sizeof(buf), NULL);

				BYTE * pByte = buf;

				m_dwID = (DWORD)(*pByte++);
				m_dwID += (DWORD)(*pByte++ << 8);
				m_dwID += (DWORD)(*pByte++ << 16);
				m_dwID += (DWORD)(*pByte++ << 24);

				return QueryInterface(riid, ppv);
			}

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm) { return S_OK; }

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved) { return S_OK; }

///////////////////////////////////////////////
// Notifications and callbacks
public:

///////////////////////////////////////////////
// Helper Fns

	HRESULT _EnsureConfHook(void);
	static bool GetKeyDataForProp(NM_SYSPROP uProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, bool *pfString);

private:
	static void _GetSzKeyForGuid(LPTSTR psz, REFGUID rguid);
};


#endif // __NmSysInfo_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\siload.cpp ===
#include "precomp.h"
#include "atlbase.h"

#include "resource.h"
#include "clcnflnk.hpp"
#include "launstub.h"

#define DISPLAYNAME_STRING _T( "+displayName=" )

void WINAPI NewMediaPhone(   HWND hwndParent,
							 HINSTANCE hinst,
							 PSTR pszCmdLine,
							 int nShowCmd)
{

	CULSLaunch_Stub MyLaunchStub;
	ULS_HTTP_RESP br;
	if(SUCCEEDED(MyLaunchStub.ParseUlsHttpRespFile(pszCmdLine, &br)))
	{
		long	l = lstrlen( br.szIPAddress ) + 1;		// We will always have an IP address

		if(br.pszUID)
		{
			l += lstrlen(DISPLAYNAME_STRING);
			l += lstrlen(br.pszUID);
		}

		LPTSTR sz = new TCHAR[l];

		if( sz != NULL )
		{
			lstrcpy( sz, br.szIPAddress );

			if(br.pszUID)
			{
				lstrcat( sz, DISPLAYNAME_STRING );
				lstrcat( sz, br.pszUID );
			}

			shellCallto(sz, true);
			delete [] sz;
		}

		MyLaunchStub.FreeUlsHttpResp(&br);
	}
}       


//--------------------------------------------------------------------------//
//	CallToProtocolHandler.													//
//--------------------------------------------------------------------------//
extern "C"
void
WINAPI
CallToProtocolHandler
(
	HWND		,//parent,
	HINSTANCE	,//instance,
	PSTR		commandLine,
	int			//cmdShow
){

	shellCallto( commandLine, true );

}	//	End of CallToProtocolHandler.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\siglobal.h ===
/* ----------------------------------------------------------------------

	Copyright (c) 1995-1996, Microsoft Corporation
	All rights reserved

	siGlobal.h

  ---------------------------------------------------------------------- */

#ifndef GLOBAL_H
#define GLOBAL_H

//-------------------------------------------------------
// Useful macros

#define ARRAY_ELEMENTS(rg)   (sizeof(rg) / sizeof((rg)[0]))
#define ARRAYSIZE(x)         (sizeof(x)/sizeof(x[0]))

//-------------------------------------------------------
// Function Prototypes


#ifdef DEBUG  /* These are only avaible for debug */
VOID InitDebug(void);
VOID DeInitDebug(void);
#endif /* DEBUG */

#ifdef DEBUG
extern HDBGZONE ghZoneApi;
#define ZONE_API_WARN_FLAG   0x01
#define ZONE_API_EVENT_FLAG  0x02
#define ZONE_API_TRACE_FLAG  0x04
#define ZONE_API_DATA_FLAG   0x08
#define ZONE_API_OBJ_FLAG    0x10
#define ZONE_API_REF_FLAG    0x20

UINT DbgApiWarn(PCSTR pszFormat,...);
UINT DbgApiEvent(PCSTR pszFormat,...);
UINT DbgApiTrace(PCSTR pszFormat,...);
UINT DbgApiData(PCSTR pszFormat,...);

#define DBGAPI_WARN   (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_WARN_FLAG))  ? 0 : DbgApiWarn
#define DBGAPI_EVENT  (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_EVENT_FLAG)) ? 0 : DbgApiEvent
#define DBGAPI_TRACE  (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_TRACE_FLAG)) ? 0 : DbgApiTrace
#define DBGAPI_DATA   (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_DATA_FLAG))  ? 0 : DbgApiData

#define DBGAPI_REF    (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_REF_FLAG))   ? 0 : DbgApiTrace
#define DBGAPI_OBJ    (!IS_ZONE_ENABLED(ghZoneApi, ZONE_API_OBJ_FLAG))   ? 0 : DbgApiTrace
#else
inline void WINAPI DbgMsgApi(LPCTSTR, ...) { }
#define DBGAPI_WARN   1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_EVENT  1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_TRACE  1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_DATA   1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_REF    1 ? (void)0 : ::DbgMsgApi
#define DBGAPI_OBJ    1 ? (void)0 : ::DbgMsgApi
#endif

/////////////////////////////////
// Global Variables


extern HINSTANCE g_hInst;

#endif /* GLOBAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\simain.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1995-1996, Microsoft Corporation
	All rights reserved

	siMain.cpp - main Scrapi Interface

	Routines to interface with calling application.
  ---------------------------------------------------------------------- */

#include "precomp.h"
#include "clcnflnk.hpp"
#include "version.h"


// SDK stuff
#include "NmApp.h"				// To register CLSID_NetMeeting
#include "NmSysInfo.h"			// For CNmSysInfoObj
#include "SDKInternal.h"		// For NmManager, etc.
#include "MarshalableTI.h"		// For Marshalable Type Info


// Global variable definitions (local to each instance)
HINSTANCE  g_hInst        = NULL;    // This dll's instance


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_NetMeeting, CNetMeetingObj)
	OBJECT_ENTRY(CLSID_NmSysInfo, CNmSysInfoObj)
	OBJECT_ENTRY(CLSID_NmManager, CNmManagerObj)
	OBJECT_ENTRY(CLSID_MarshalableTI, CMarshalableTI)
END_OBJECT_MAP()


/*  D L L  M A I N */
/*-------------------------------------------------------------------------
	%%Function: DllMain
-------------------------------------------------------------------------*/
BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
	{
#ifdef DEBUG
		InitDebug();
		DBG_INIT_MEMORY_TRACKING(hDllInst);
		TRACE_OUT(("*** MSCONF.DLL: Attached process thread %X", GetCurrentThreadId()));
#endif
		g_hInst = hDllInst;
		_Module.Init(ObjectMap, g_hInst);

		DisableThreadLibraryCalls(hDllInst);

		InitDataObjectModule();
		break;
	}

	case DLL_PROCESS_DETACH:

		_Module.Term();

#ifdef DEBUG
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
		TRACE_OUT(("*** MSCONF.DLL: Detached process thread %X", GetCurrentThreadId()));
		DeInitDebug();
#endif

		break;

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	default:
		break;
	}
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	HRESULT hr = S_OK;

	if( InlineIsEqualGUID(rclsid, CLSID_NetMeeting) || InlineIsEqualGUID(rclsid, CLSID_NmManager) )
	{	
		hr = CoGetClassObject(rclsid, CLSCTX_LOCAL_SERVER, NULL, riid, ppv);
	}
	else
	{
		hr = _Module.GetClassObject(rclsid, riid, ppv);
	}

	return hr;
}

/*  D L L  G E T  V E R S I O N  */
/*-------------------------------------------------------------------------
    %%Function: DllGetVersion

-------------------------------------------------------------------------*/
STDAPI DllGetVersion(IN OUT DLLVERSIONINFO * pinfo)
{
	HRESULT hr;

	if ((NULL == pinfo) ||
		IsBadWritePtr(pinfo, sizeof(*pinfo)) ||
		sizeof(*pinfo) != pinfo->cbSize)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		pinfo->dwMajorVersion = (VER_PRODUCTVERSION_DW & 0xFF000000) >> 24;
		pinfo->dwMinorVersion = (VER_PRODUCTVERSION_DW & 0x00FF0000) >> 16;
		pinfo->dwBuildNumber  = (VER_PRODUCTVERSION_DW & 0x0000FFFF);
		pinfo->dwPlatformID   = DLLVER_PLATFORM_WINDOWS;
		hr = S_OK;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;

	hr = _Module.UnregisterServer();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\ulserror.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSERROR.H
//
// Brief Description:  This module contains declarations for the MS Internet
//                     User Location Service error codes.
//
// Author:  Kent Settle (kentse)
// Created: 27-Feb-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef _ULSERROR_H_
#define _ULSERROR_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

// HRESULTS

#define FACILITY_ULS			0x321		// random, sort of.
#define ULS_HR(x)				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ULS, x)

#define ULS_SUCCESS				NOERROR
#define ULS_E_INVALID_POINTER	E_POINTER
#define ULS_E_OUTOFMEMORY		E_OUTOFMEMORY
#define ULS_E_INVALID_HANDLE	E_HANDLE
#define ULS_E_NOINTERFACE		E_NOINTERFACE // interface not supported.
#define ULS_E_THREAD_FAILURE	ULS_HR(1)	// thread creation failed.
#define ULS_E_NO_SERVER		ULS_HR(2)	// server connection failed.
#define ULS_E_ERROR_ON_SERVER	ULS_HR(3)	// generic error on server.
#define ULS_E_INVALID_PROPERTY	ULS_HR(4)	// invalid user property.
#define ULS_E_INVALID_PARAMETER	ULS_HR(5)	// invalid parameter.
#define ULS_E_IO_ERROR			ULS_HR(6)	// device io (such as disk) failed
#define ULS_E_INVALID_FORMAT	ULS_HR(7)	// invalid format.
#define ULS_E_REGISTRY			ULS_HR(8)	// registry error.
#define ULS_E_PROCESS			ULS_HR(9)	// process creation error.
#define ULS_E_SOCKET_FAILURE	ULS_HR(10)	// socket failure.
#define ULS_E_NAME_NOT_FOUND	ULS_HR(11)	// could not resolve name.
#define ULS_E_REFUSED_BY_SERVER ULS_HR(12)	// server refused the request.
#define ULS_E_DUP_ENTRY			ULS_HR(13)	// already exists in database.
#define ULS_E_APP_NOT_FOUND		ULS_HR(14)	// specified app not found.
#define ULS_E_INVALID_VERSION	ULS_HR(15)	// client version invalid.
#define ULS_E_CLIENT_NOT_FOUND	ULS_HR(16)	// specified client not found.
#define ULS_E_UNKNOWN			ULS_HR(17)	// unknown error on client.
#define ULS_E_WIZARD			ULS_HR(18)	// wizard error.
#define ULS_E_EVENT_FAILURE		ULS_HR(19)	// CreateEvent failed.
#define ULS_E_QUEUE_CORRUPT		ULS_HR(20)	// read queue corrupted.
#define ULS_E_MUTEX			ULS_HR(21)	// mutex creation error.
#define ULS_E_OLD_TIMEOUT		ULS_HR(22)	// timeout
#define ULS_E_LOGON_CANCEL		ULS_HR(23)	// cancel in failure/retry dialog
#define ULS_E_CLIENT_NEED_RELOGON	ULS_HR(24)	// client needs to relogon (server crashes and comes up again)
#define ULS_E_NEED_SERVER_NAME  ULS_HR(25)	// missing server name in logon
#define ULS_E_NO_PROPERTY		ULS_HR(26)	// no such property
#define ULS_E_NOT_LOGON_YET		ULS_HR(27)	// save change before logon
#define ULS_E_INVALID_NAME      ULS_HR(28)  // name contains invalid characters
#define ULS_E_OUT_OF_SOCKET     ULS_HR(29)  // too many sockets used
#define ULS_E_OUT_OF_DATA       ULS_HR(30)  // data underflow
#define ULS_E_NETWORK          	ULS_HR(31)  // network is down, somehow


#define ULS_W_DATA_NOT_READY    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ULS, 101)



#include <poppack.h> /* End byte packing */

#endif // _ULSERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\applet.cpp ===
#include "mbftpch.h"
#include <it120app.h>
#include <regentry.h>
#include <iappldr.h>
#include <version.h>


HINSTANCE g_hDllInst;
DWORD g_dwWorkThreadID = 0;
HANDLE g_hWorkThread = NULL;
CFileTransferApplet *g_pFileXferApplet = NULL;
CRITICAL_SECTION     g_csWorkThread;
TCHAR g_szMBFTWndClassName[32];
const TCHAR g_cszFtHiddenWndClassName[] = _TEXT("FtHiddenWindow");

extern CFtLoader *g_pFtLoader;
extern T120Error CALLBACK CreateAppletLoaderInterface(IAppletLoader**);


BOOL    g_fSendAllowed = FALSE;
BOOL    g_fRecvAllowed = FALSE;
UINT_PTR    g_cbMaxSendFileSize = 0;
BOOL    g_fShutdownByT120 = FALSE;

// Local functions
void ReadSettingsFromRegistry(void);
void BuildAppletCapabilities(void);
void BuildDefaultAppletSessionKey(void);


DWORD __stdcall FTWorkThreadProc(LPVOID lpv);


#define FT_VERSION_STR	"MS FT Version"
OSTR FT_VERSION_ID = {sizeof(FT_VERSION_STR), (unsigned char*)FT_VERSION_STR};


BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hDllInst = hDllInst;
        ::DisableThreadLibraryCalls(hDllInst);
        InitDebug();
        DBG_INIT_MEMORY_TRACKING(hDllInst);
        ::InitializeCriticalSection(&g_csWorkThread);
        ::wsprintf(&g_szMBFTWndClassName[0], TEXT("MBFTWnd%0X_%0X"), ::GetCurrentProcessId(), ::GetTickCount());
        ASSERT(::lstrlenA(&g_szMBFTWndClassName[0]) < sizeof(g_szMBFTWndClassName));
        ::BuildAppletCapabilities();
        ::BuildDefaultAppletSessionKey();
        TRACE_OUT(("*** MSCONFFT.DLL: Attached process thread %X", GetCurrentThreadId()));
        ::T120_AppletStatus(APPLET_ID_FT, APPLET_LIBRARY_LOADED);
        break;

    case DLL_PROCESS_DETACH:
        TRACE_OUT(("*** NMFT.DLL: Detaching process thread %X", GetCurrentThreadId()));
        if (NULL != g_hWorkThread)
        {
            ::CloseHandle(g_hWorkThread);
        }
        ::T120_AppletStatus(APPLET_ID_FT, APPLET_LIBRARY_FREED);
        ::DeleteCriticalSection(&g_csWorkThread);
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
        DeInitDebugMbft();
        break;

    default:
        break;
    }
    return TRUE;
}


HRESULT WINAPI FT_CreateInterface(IMbftControl **ppMbft, IMbftEvents *pEvents)
{
    HRESULT hr;

    if (NULL != ppMbft && NULL != pEvents)
    {
        if (NULL != g_pFileXferApplet)
        {
            ReadSettingsFromRegistry();

            DBG_SAVE_FILE_LINE
            MBFTInterface *pObject = new MBFTInterface(pEvents, &hr);
            if (NULL != pObject)
            {
                if (S_OK == hr)
    			{
                    *ppMbft = (IMbftControl *) pObject;
                    return S_OK;
    			}

                ERROR_OUT(("CreateMbftObject: cannot create MBFTInterface"));
                pObject->Release();
                *ppMbft = NULL;
                return hr;
            }

            ERROR_OUT(("CreateMbftObject: cannot allocate MBFTInterface"));
            return E_OUTOFMEMORY;
        }

        WARNING_OUT(("CreateMbftObject: applet object is not created"));
    }
    else
    {
        ERROR_OUT(("CreateMbftObject: invalid pointer, ppMbft=0x%x, pEvents=0x%x", ppMbft, pEvents));
    }
    return E_POINTER;
}


void CALLBACK FileXferAppletCallback
(
    T120AppletMsg   *pMsg
)
{
    CFileTransferApplet *pThisApplet = (CFileTransferApplet *) pMsg->pAppletContext;
    if (pThisApplet == g_pFileXferApplet && NULL != g_pFileXferApplet)
    {
        pThisApplet->T120Callback(pMsg);
    }
}


BOOL CFtHiddenWindow::Create(void)
{
    return(CGenWindow::Create(NULL, NULL,
                               WS_POPUP, // not visible!
                               0,
                               0, 0, 0, 0,
                               g_hDllInst,
                               NULL,
                               g_cszFtHiddenWndClassName
                                ));
}


CFileTransferApplet::CFileTransferApplet(HRESULT *pHr)
:	m_pHwndHidden(NULL)
{
    T120Error rc = ::T120_CreateAppletSAP(&m_pAppletSAP);
	if (T120_NO_ERROR == rc)
	{
	    m_pAppletSAP->Advise(FileXferAppletCallback, this);
	    *pHr = S_OK;
	}
	else
	{
		ERROR_OUT(("CFileTransferApplet::CFileTransferApplet: cannot create app sap, rc=%u", rc));
		*pHr = E_OUTOFMEMORY;
	}

	// Create Hidden Window for processing MBFTMSG
    DBG_SAVE_FILE_LINE
	m_pHwndHidden = new CFtHiddenWindow();
	if (m_pHwndHidden)
	{
		*pHr = (m_pHwndHidden->Create())?S_OK:E_FAIL;
	}
	else
	{
		*pHr = E_OUTOFMEMORY;
	}
}


CFileTransferApplet::~CFileTransferApplet(void)
{
    m_EngineList.Clear();

    CAppletWindow *pWindow;
    while (NULL != (pWindow = m_WindowList.Get()))
    {
        pWindow->Release(); // add ref while being put to the list
        pWindow->OnExit();
    }

    if (NULL != m_pAppletSAP)
    {
        m_pAppletSAP->ReleaseInterface();
    }

	if (NULL != m_pHwndHidden)
	{
		HWND hwndHidden = m_pHwndHidden->GetWindow();
		DestroyWindow(hwndHidden);
		m_pHwndHidden->Release();
		m_pHwndHidden = NULL;
	}
}


BOOL CFileTransferApplet::QueryShutdown(BOOL fGoAheadShutdown)
{
    CAppletWindow *pWindow;
    m_WindowList.Reset();
    while (NULL != (pWindow = m_WindowList.Iterate()))
    {
        if (! pWindow->QueryShutdown(fGoAheadShutdown))
        {
            return FALSE; // do not shut down now
        }
    }
    return TRUE;
}


void CFileTransferApplet::T120Callback
(
    T120AppletMsg   *pMsg
)
{
    switch (pMsg->eMsgType)
    {
    case GCC_PERMIT_TO_ENROLL_INDICATION:
        {
            MBFTEngine *pEngine = m_EngineList.FindByConfID(pMsg->PermitToEnrollInd.nConfID);
            if (NULL == pEngine)
            {
                pEngine = m_EngineList.FindByConfID(0);
                if (NULL == pEngine)
                {
                    if (pMsg->PermitToEnrollInd.fPermissionGranted)
                    {
                        DBG_SAVE_FILE_LINE
                        pEngine = new MBFTEngine(NULL, MBFT_STATIC_MODE, _iMBFT_DEFAULT_SESSION);
                        ASSERT(NULL != pEngine);
                    }
                }
            }
            if (NULL != pEngine)
            {
                pEngine->OnPermitToEnrollIndication(&pMsg->PermitToEnrollInd);
            }

            // deal with unattended conference
            if (pMsg->PermitToEnrollInd.fPermissionGranted)
            {
                if (NULL == pEngine)
                {
                    m_UnattendedConfList.Append(pMsg->PermitToEnrollInd.nConfID);
                }
            }
            else
            {
                m_UnattendedConfList.Remove(pMsg->PermitToEnrollInd.nConfID);
            }
        }
        break;

    case T120_JOIN_SESSION_CONFIRM:
        break;

    default:
        ERROR_OUT(("CFileTransferApplet::T120Callback: unknown t120 msg type=%u", pMsg->eMsgType));
        break;
    }
}


void CFileTransferApplet::RegisterEngine(MBFTEngine *p)
{
    m_EngineList.Append(p);

    // relay any unattended conference
    if (! m_UnattendedConfList.IsEmpty())
    {
        GCCAppPermissionToEnrollInd Ind;
        Ind.nConfID = m_UnattendedConfList.Get();
        Ind.fPermissionGranted = TRUE;
        p->OnPermitToEnrollIndication(&Ind);
    }
}

void CFileTransferApplet::UnregisterEngine(MBFTEngine *p)
{
    if (m_EngineList.Remove(p))
    {
        CAppletWindow *pWindow;
        m_WindowList.Reset();
        while (NULL != (pWindow = m_WindowList.Iterate()))
        {
            if (pWindow->GetEngine() == p)
            {
                pWindow->UnregisterEngine();
                break;
            }
        }

        p->Release(); // AddRef in MBFTEngine()
    }
}


MBFTEngine * CFileTransferApplet::FindEngineWithIntf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->GetInterfacePointer())
        {
            break;
        }
    }
    return pEngine;
}

MBFTEngine * CFileTransferApplet::FindEngineWithNoIntf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (! pEngine->GetInterfacePointer())
        {
            break;
        }
    }
    return pEngine;
}


void CFileTransferApplet::RegisterWindow(CAppletWindow *pWindow)
{
    pWindow->AddRef();
    m_WindowList.Append(pWindow);

    if (1 == m_WindowList.GetCount() && 1 == m_EngineList.GetCount())
    {
        MBFTEngine *pEngine = m_EngineList.PeekHead();
        pWindow->RegisterEngine(pEngine);
        pEngine->SetWindow(pWindow);
		pEngine->AddAllPeers();
    }
}

void CFileTransferApplet::UnregisterWindow(CAppletWindow *pWindow)
{
    if (m_WindowList.Remove(pWindow))
    {
        pWindow->Release();
    }

    if (m_WindowList.IsEmpty())
    {
        g_fNoUI = FALSE;

        ::T120_AppletStatus(APPLET_ID_FT, APPLET_CLOSING);

        BOOL fRet = ::PostMessage(GetHiddenWnd(), WM_QUIT, 0, 0);
        ASSERT(fRet);
    }
}


CAppletWindow *CFileTransferApplet::GetUnattendedWindow(void)
{
    CAppletWindow *pWindow;
    m_WindowList.Reset();
    while (NULL != (pWindow = m_WindowList.Iterate()))
    {
        if (! pWindow->IsInConference())
        {
            return pWindow;
        }
    }
    return NULL;
}

LRESULT CFileTransferApplet::BringUIToFront(void)
{
    CAppletWindow *pWindow;
	if (m_WindowList.IsEmpty())
    {
        // The g_pFileXferApplet was created by fNoUI == TRUE,
        // Now we need to create the UI
        HRESULT hr;
        DBG_SAVE_FILE_LINE
        pWindow = new CAppletWindow(g_fNoUI, &hr);
        if (NULL != pWindow)
        {
            if (S_OK != hr)
            {
                ERROR_OUT(("BringUIToFrong: cannot create CAppletWindow"));
                pWindow->Release();
                pWindow = NULL;
            }
        }
        else
        {
            ERROR_OUT(("FTBringUIToFrong: cannot allocate CAppletWindow"));
            hr = E_OUTOFMEMORY;
        }
    }
    m_WindowList.Reset();
    while (NULL != (pWindow = m_WindowList.Iterate()))
    {
		pWindow->BringToFront();
	}
	return 0;
}

BOOL CFileTransferApplet::Has2xNodeInConf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->Has2xNodeInConf())
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CFileTransferApplet::InConf(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->GetPeerCount() > 1)
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CFileTransferApplet::HasSDK(void)
{
    MBFTEngine *pEngine;
    m_EngineList.Reset();
    while (NULL != (pEngine = m_EngineList.Iterate()))
    {
        if (pEngine->HasSDK())
        {
            return TRUE;
        }
    }
    return FALSE;
}

MBFTEngine * CEngineList::FindByConfID(T120ConfID nConfID)
{
    MBFTEngine *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (nConfID == p->GetConfID())
        {
            return p;
        }
    }
    return NULL;
}


#ifdef ENABLE_HEARTBEAT_TIMER
MBFTEngine * CEngineList::FindByTimerID(UINT_PTR nTimerID)
{
    MBFTEngine *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (nTimerID == p->GetTimerID())
        {
            return p;
        }
    }
    return NULL;
}
#endif


//
// File Transfer Capabilities
//

static GCCAppCap s_CapArray[4];
const GCCAppCap* g_aAppletCaps[4] = { &s_CapArray[0], &s_CapArray[1], &s_CapArray[2], &s_CapArray[3] };

static GCCNonCollCap s_NCCapArray[2];
const GCCNonCollCap* g_aAppletNonCollCaps[2] = { &s_NCCapArray[0], &s_NCCapArray[1] };

static const OSTR s_AppData[2] =
    {
        {
            sizeof(PROSHARE_STRING) + sizeof(MY_APP_STR),
            (LPBYTE) PROSHARE_STRING "\0" MY_APP_STR
        },
        {
            sizeof(PROSHARE_FILE_END_STRING),
            (LPBYTE) PROSHARE_FILE_END_STRING
        },
    };


void BuildAppletCapabilities(void)
{
    //
    // Capabilities
    //

	//Say that we can handle a max. of 4GBs...
	s_CapArray[0].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_CapArray[0].capability_id.standard_capability = _MBFT_MAX_FILE_SIZE_ID;
	s_CapArray[0].capability_class.eType = GCC_UNSIGNED_MAXIMUM_CAPABILITY;
	s_CapArray[0].capability_class.nMinOrMax = _iMBFT_MAX_FILE_SIZE;
	s_CapArray[0].number_of_entities = 0;

	//And that we can handle only about 25K of data per
	//FileData PDU
	s_CapArray[1].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_CapArray[1].capability_id.standard_capability = _MBFT_MAX_DATA_PAYLOAD_ID;
	s_CapArray[1].capability_class.eType = GCC_UNSIGNED_MAXIMUM_CAPABILITY;
	s_CapArray[1].capability_class.nMinOrMax = _iMBFT_MAX_FILEDATA_PDU_LENGTH;
	s_CapArray[1].number_of_entities = 0;

	//and that we don't support V.42..
	s_CapArray[2].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_CapArray[2].capability_id.standard_capability = _MBFT_V42_COMPRESSION_ID;
	s_CapArray[2].capability_class.eType = GCC_LOGICAL_CAPABILITY;
	s_CapArray[2].capability_class.nMinOrMax = 0;
	s_CapArray[2].number_of_entities = 0;

	//Tell other node about this node's version number
	s_CapArray[3].capability_id.capability_id_type = GCC_NON_STANDARD_CAPABILITY;
	s_CapArray[3].capability_id.non_standard_capability.key_type = GCC_H221_NONSTANDARD_KEY;
	s_CapArray[3].capability_id.non_standard_capability.h221_non_standard_id = FT_VERSION_ID;
	//s_CapArray[3].capability_id.non_standard_capability.h221_non_standard_id.value = (unsigned char *)FT_VERSION_ID;
	s_CapArray[3].capability_class.eType = GCC_UNSIGNED_MINIMUM_CAPABILITY;
	s_CapArray[3].capability_class.nMinOrMax = VER_PRODUCTVERSION_DW;
	s_CapArray[3].number_of_entities = 0;

	//
    // Non-Collapsed Capabilities
    //

	s_NCCapArray[0].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_NCCapArray[0].capability_id.standard_capability = _iMBFT_FIRST_PROSHARE_CAPABILITY_ID;
	s_NCCapArray[0].application_data = (OSTR *) &s_AppData[0];

	s_NCCapArray[1].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	s_NCCapArray[1].capability_id.standard_capability = _iMBFT_PROSHARE_FILE_EOF_ACK_ID;
	s_NCCapArray[1].application_data = (OSTR *) &s_AppData[1];
}


GCCSessionKey g_AppletSessionKey;
static ULONG s_MBFTKeyNodes[] = {0,0,20,127,0,1};

void BuildDefaultAppletSessionKey(void)
{
    ::ZeroMemory(&g_AppletSessionKey, sizeof(g_AppletSessionKey)); // SessionID is zero
    g_AppletSessionKey.application_protocol_key.key_type = GCC_OBJECT_KEY;
    g_AppletSessionKey.application_protocol_key.object_id.long_string = s_MBFTKeyNodes;
    g_AppletSessionKey.application_protocol_key.object_id.long_string_length = sizeof(s_MBFTKeyNodes) / sizeof(s_MBFTKeyNodes[0]);
}




void ReadSettingsFromRegistry(void)
{
    static BOOL s_fReadAlready = FALSE;

    if (! s_fReadAlready)
    {
        s_fReadAlready = TRUE;

        RegEntry rePolicies(POLICIES_KEY, HKEY_CURRENT_USER);

        g_fSendAllowed = (0 == rePolicies.GetNumber(REGVAL_POL_NO_FILETRANSFER_SEND,
                                                    DEFAULT_POL_NO_FILETRANSFER_SEND));
        g_fRecvAllowed = (0 == rePolicies.GetNumber(REGVAL_POL_NO_FILETRANSFER_RECEIVE,
                                                    DEFAULT_POL_NO_FILETRANSFER_RECEIVE));
        g_cbMaxSendFileSize = rePolicies.GetNumber(REGVAL_POL_MAX_SENDFILESIZE,
                                                   DEFAULT_POL_MAX_FILE_SIZE);

        // initialize the delays
        RegEntry reFt(FILEXFER_KEY, HKEY_CURRENT_USER);
        g_nSendDisbandDelay = reFt.GetNumber(REGVAL_FILEXFER_DISBAND, g_nSendDisbandDelay);
        g_nChannelResponseDelay = reFt.GetNumber(REGVAL_FILEXFER_CH_RESPONSE, g_nChannelResponseDelay);
    }
}


/////////////////////////////////////////////////////////////////
//
//  Hidden windows procedure
//

LRESULT CFtHiddenWindow::ProcessMessage(HWND hwnd, UINT uMsg,
										WPARAM wParam, LPARAM lParam)
{
    LRESULT rc = T120_NO_ERROR;
	MBFTEngine *pEngine = (MBFTEngine *) lParam;
	MBFTMsg *pMsg = (MBFTMsg *) wParam;
	MBFTInterface *pIntf;

	switch(uMsg)
	{
	case WM_BRING_TO_FRONT:
		g_pFileXferApplet->BringUIToFront();
		break;
	
	case MBFTMSG_CREATE_ENGINE:
        pIntf = (MBFTInterface *) lParam;
        pEngine = g_pFileXferApplet->FindEngineWithNoIntf();
        if (NULL == pEngine)
        {
            DBG_SAVE_FILE_LINE
            pEngine = new MBFTEngine(NULL, MBFT_STATIC_MODE, _iMBFT_DEFAULT_SESSION);
            ASSERT(NULL != pEngine);
        }
        if (NULL != pEngine)
        {
            pIntf->SetEngine(pEngine);
            pEngine->SetInterfacePointer(pIntf);
        }
        ::SetEvent((HANDLE) wParam);
		break;

	case MBFTMSG_DELETE_ENGINE:
        ASSERT(NULL != g_pFileXferApplet);
        g_pFileXferApplet->UnregisterEngine(pEngine);
        break;

    case MBFTMSG_HEART_BEAT:
        pEngine->DoStateMachine(NULL);
        break;

    case MBFTMSG_BASIC:
        ASSERT(NULL != pMsg);
        if (pEngine->DoStateMachine(pMsg))
        {
            delete pMsg;
            pEngine->Release();
        }
        else
        {
            // put it back to the queue
            ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), uMsg, wParam, lParam);
        }
        break;

	default:
		return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}


DWORD __stdcall FTWorkThreadProc(LPVOID lpv)
{
    HRESULT hr;
	CAppletWindow *pAppletWnd;

    // allocate the applet object first
    DBG_SAVE_FILE_LINE
    g_pFileXferApplet = new CFileTransferApplet(&hr);

	::SetEvent((HANDLE) lpv); // signaling that the work hread has been started

    if (NULL != g_pFileXferApplet)
    {
        if (S_OK == hr)
        {
            // CAppletWindow's constructor will register itself to g_pFileXferApplet
            DBG_SAVE_FILE_LINE
            CAppletWindow *pWindow = new CAppletWindow(g_fNoUI, &hr);
            if (NULL != pWindow)
            {
                if (S_OK != hr)
                {
                    ERROR_OUT(("FTWorkThreadProc: cannot create CAppletWindow"));
                    pWindow->Release();
                    pWindow = NULL;
                }
            }
            else
            {
                ERROR_OUT(("FTWorkThreadProc: cannot allocate CAppletWindow"));
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            ERROR_OUT(("FTWorkThreadProc: cannot create CFileTransferApplet"));
            delete g_pFileXferApplet;
            g_pFileXferApplet = NULL;
        }
    }
    else
    {
        ERROR_OUT(("FTWorkThreadProc: cannot allocate CFileTransferApplet"));
        hr = E_OUTOFMEMORY;
    }

    ::T120_AppletStatus(APPLET_ID_FT, APPLET_WORK_THREAD_STARTED);

    // the work thread loop
    if (S_OK == hr)
    {
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

        MSG msg;
        while (::GetMessage(&msg, NULL, 0, 0))
        {
            ::EnterCriticalSection(&g_csWorkThread);

			pAppletWnd = g_pFileXferApplet->GetMainUI();	
			if (!pAppletWnd || !pAppletWnd->FilterMessage(&msg))
			{
				::TranslateMessage(&msg);
				::DispatchMessage(&msg);
            }

            ::LeaveCriticalSection(&g_csWorkThread);
        }
	
        CGenWindow::DeleteStandardPalette();
        delete g_pFileXferApplet;
        g_pFileXferApplet = NULL;

		::CoUninitialize();
    }

    ::T120_AppletStatus(APPLET_ID_FT, APPLET_WORK_THREAD_EXITED);

    g_dwWorkThreadID = 0;

    if (! g_fShutdownByT120)
    {
		// Wait for other dependent threads to finish their work
		::Sleep(100);
        ::FreeLibraryAndExitThread(g_hDllInst, 0);
    }
    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\ulp.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULP.H
//
// Brief Description:  This module contains declarations for the MS Internet
//                     User Location Protocol.
//
// Author:  Kent Settle (kentse)
// Created: 22-Mar-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------

#ifndef ULP_H
#define ULP_H

#include <pshpack1.h> /* Assume 1 byte packing throughout */

#define MAX_MIME_TYPE_LENGTH        32  // need to be changed later
#define SIZEOF_MIME_TYPE            (MAX_MIME_TYPE_LENGTH * sizeof (TCHAR))
#define MAX_NM_APP_ID				32
#define MAX_PROTOCOL_ID				32

// ULP opcodes.

#define ULP_OPCODE_CLIENT_REG		0	// register client.
#define ULP_OPCODE_CLIENT_UNREG		1	// unregister client.
#define ULP_OPCODE_APP_REG			2	// register app.
#define ULP_OPCODE_APP_UNREG		3	// unregister app.
#define ULP_OPCODE_RESOLVE			4	// resolve name.
#define ULP_OPCODE_DIRECTORY		5	// directory query.
#define ULP_OPCODE_KEEPALIVE		6	// keepalive record.
#define ULP_OPCODE_SETPROPS			7	// set properties.
#define ULP_OPCODE_RESOLVE_EX		8	// expanded resolve.
#define ULP_OPCODE_APP_REG_EX		9	// expanded register app.
#define ULP_OPCODE_DIRECTORY_EX		10	// expanded directory.

// return codes.

#define ULP_RCODE_SUCCESS				0
#define ULP_RCODE_SERVER_ERROR			1
#define ULP_RCODE_REFUSED				2
#define ULP_RCODE_CONFLICT				3
#define ULP_RCODE_NAME_NOT_FOUND		4
#define ULP_RCODE_APP_NOT_FOUND			5
#define ULP_RCODE_INCORRECT_VERSION		6
#define ULP_RCODE_CLIENT_NOT_FOUND		7
#define ULP_RCODE_CLIENT_NEED_RELOGON	8
#define ULP_RCODE_INVALID_PARAMETER		9
#define ULP_RCODE_NEED_APPLICATION_ID	10

// ULP flags.

#define ULP_FLAG_PUBLISH		0x01	// show in directory.

// default TTL value.

#define ULP_TTL_DEFAULT			10		// ten minutes.

// ULP protocol version.  the version number is in 5.3 format.  that is
// 5 bits of major version, and 3 bits of minor version.

#define ULP_VERSION					0x04		// version 1.0.
#define ULP_MAJOR_VERSION_MASK		0xF8
#define ULP_MINOR_VERSION_MASK		0x07

// version macros.

#define ULP_GET_MAJOR_VERSION(ver)	(((ver) & ULP_MAJOR_VERSION_MASK) >> 3)
#define ULP_GET_MINOR_VERSION(ver)	((ver) & ULP_MINOR_VERSION_MASK)
#define ULP_MAKE_VERSION(maj, min)	(((maj) << 3) |		\
									((min) & ULP_MINOR_VERSION_MASK))

// structures.

typedef struct _ULP_PROP
{
	DWORD		dwPropertyTag;
	BYTE		Value[1];
} ULP_PROP;

typedef struct _ULP_PROPERTY_ARRAY
{
	DWORD		dwTotalSize;
	DWORD		dwVariableSize;
	DWORD		dwPropCount;
	ULP_PROP	Properties[1];
} ULP_PROPERTY_ARRAY;

typedef struct _ULP_CLIENT_REGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	WORD		wFlags;
	WORD		wCRP;
	DWORD		dwLastClientSig;
	DWORD		dwIPAddress;
	BYTE		bData[1];
} ULP_CLIENT_REGISTER;

typedef struct _ULP_CLIENT_REG_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	HANDLE		hClient;
	DWORD		dwClientSig;
} ULP_CLIENT_REG_RESPONSE;

typedef struct _ULP_CLIENT_UNREGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	HANDLE		hClient;
	DWORD		dwClientSig;
} ULP_CLIENT_UNREGISTER;

typedef struct _ULP_CLIENT_UNREG_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
} ULP_CLIENT_UNREG_RESPONSE;

typedef 	struct _ULP_CLIENT_KEEPALIVE
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	HANDLE		hClient;
	DWORD		dwClientSig;
	DWORD       dwIPAddress;
} ULP_CLIENT_KEEPALIVE;

typedef struct _ULP_KEEPALIVE_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	WORD		wNewCRP;
	DWORD		dwReserved;
} ULP_KEEPALIVE_RESPONSE;
#define ULP_KA_RESERVED		((DWORD) 0xFFF98052)

typedef  struct _ULP_APP_REGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	HANDLE		hClient;
	GUID		ApplicationID;
	GUID		ProtocolID;
	WORD		wPort;
	BYTE		bData[1];
} ULP_APP_REGISTER;

typedef  struct _ULP_APP_REGISTER_EX
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	HANDLE		hClient;
	WORD		wPort;
	BYTE		bData[1];
	// appid
	// appmime
	// protid
	// protmime
	// PROPERTIES
} ULP_APP_REGISTER_EX;

typedef struct _ULP_APP_REGISTER_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	HANDLE		hApplication;
} ULP_APP_REGISTER_RESPONSE;

typedef  struct _ULP_APP_UNREGISTER
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	HANDLE		hApplication;
	HANDLE		hClient;
	DWORD		dwClientSig;
} ULP_APP_UNREGISTER;

typedef struct _ULP_APP_UNREG_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
} ULP_APP_UNREG_RESPONSE;

typedef struct _ULP_SETPROP
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	HANDLE		hClient;
	HANDLE		hApplication;
	DWORD		dwClientSig;
	BYTE		bData[1];
} ULP_SETPROP;

typedef struct _ULP_SETPROP_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
} ULP_SETPROP_RESPONSE;

typedef  struct _ULP_RESOLVE
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	GUID		ApplicationID;
	BYTE		bData[1];
} ULP_RESOLVE;

typedef struct _ULP_RESOLVE_EX
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	BYTE		bData[1];
	// appid
	// protid
	// OTHERS
} ULP_RESOLVE_EX;

typedef struct _ULP_RESOLVE_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	DWORD		dwIPAddress;
	WORD		wPort;
	BYTE		bData[1];
} ULP_RESOLVE_RESPONSE;

typedef struct _ULP_DIRECTORY
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	GUID		ApplicationID;
	GUID		ProtocolID;
	DWORD		dwFilterSize;
	WORD		wNextNameCount;
	BYTE		bData[1];
} ULP_DIRECTORY;

typedef struct _ULP_DIRECTORY_EX
{
	BYTE		bOpcode;
	BYTE		bVersion;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	DWORD		dwFilterSize;
	WORD		wNextNameCount;
	BYTE		bData[1];
} ULP_DIRECTORY_EX;

typedef struct _ULP_DIRECTORY_RESPONSE
{
	BYTE		bOpcode;
	BYTE		bRetcode;
	WORD		wMessageID;
	DWORD		dwMessageSize;
	DWORD		dwMatchesReturned;
	BYTE		bData[1];
} ULP_DIRECTORY_RESPONSE;

#include <poppack.h> /* End byte packing */

#endif // ULP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\ulsapi.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSAPI.H
//
// Brief Description:
//		This module contains declarations for all COM style APIs
//		of ULS Client.
//
// Author:  Chu, Lon-Chan (lonchanc)
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef _ULSAPI_H_
#define _ULSAPI_H_

#include <winnt.h>
#include <basetyps.h>	// IUnknown & IClassFactory
#include <mapidefs.h>
#include "ulserror.h"
#include "ulstags.h"
#include "ulp.h"

#ifdef IN
#undef IN
#endif
#define IN		

#ifdef OUT
#undef OUT
#endif
#define OUT		

// client specific definitions. (in between stub and service)
#define CLIENT_MESSAGE_ID_LOGON             1
#define CLIENT_MESSAGE_ID_LOGOFF            2
#define CLIENT_MESSAGE_ID_RESOLVE           3
#define CLIENT_MESSAGE_ID_DIRECTORY         4
#define CLIENT_MESSAGE_ID_KEEPALIVE         5


// define ULS Client version
#ifndef ULS_VERSION
#define ULS_VERSION		MAKELONG (1, 1)		// version 1.1
#endif


#define ULS_MAX_GUID_LENGTH			16
#define ULS_MAX_IP_ADDR_LENGTH		20

// window messages
#define ULS_MSG_DIRECTORY_UI		0x5001
#define ULS_MSG_LAUNCH		  		0x5002


#define ULS_DEFAULT_CRP				2 // refresh period 2 minutes, Internal, BUGS BUGS


/* ----- ULS_F_* (common flags) ------ */

#define ULS_F_ASYNC					0x10000000UL
#define ULS_F_CONN_EXISTS			0x20000000UL	// use existing connection


/* ----- ULSLOGON_F_* (logon flags) ------ */

#define ULSREG_F_PUBLISH			0x00000001UL	// indicates server publishes client's name (also used in PR_ULS_MODE)
#define ULSREG_F_REGISTER			0x00000010UL	// register objects
#define ULSREG_F_UNREGISTER			0x00000020UL	// unregister objects


/* ----- ULSRESOLVE_F_* (resolve flags) ------ */


/* ----- ULSDIR_F_* (directory flags) ------ */

#define ULSDIR_F_DEF_PROPS			0x00000400UL	// indicates default properties to retrieve
#define ULSDIR_F_LAST_SERVER		0x00000800UL	// indicates using the server in registry


/* ----- ULSCONF_F_* ------ */

#define ULSCONF_F_PUBLISH			0X00000001UL
#define ULSCONF_F_SERVER_NAME		0X00000002UL
#define ULSCONF_F_FIRST_NAME		0X00000004UL
#define ULSCONF_F_EMAIL_NAME		0X00000008UL
#define ULSCONF_F_LAST_NAME			0X00000010UL
#define ULSCONF_F_CITY				0X00000020UL
#define ULSCONF_F_COUNTRY			0X00000040UL
#define ULSCONF_F_COMMENTS			0X00000080UL
#define ULSCONF_F_USER_NAME			0x00000100UL

#define ULSCONF_F_DEF_SERVER_NAME	0X00001000UL // use default uls.microsoft.com


/* ----- ULSWIZ_F_* ------ */

#define ULSWIZ_F_SHOW_BACK			0X00010000UL
#define ULSWIZ_F_NO_FINISH			0X00020000UL


/* ----- ULSQUERYPROVIDER_F_* ------ */

#define ULSQUERYPROVIDER_F_ALL		0x00000001UL
#define ULSQUERYPROVIDER_F_ENABLED	0x00000002UL
#define ULSQUERYPROVIDER_F_DISABLED	0x00000004UL


/* ------ common handle types ------ */

typedef PVOID	ULS_HCONN;			// handle of connection
typedef PVOID	ULS_HOBJECT;		// handle of object
typedef PVOID	ULS_HASYNC;			// handle of async operation
typedef WCHAR	ULS_GUID_W[ULS_MAX_GUID_LENGTH];
typedef CHAR	ULS_GUID_A[ULS_MAX_GUID_LENGTH];


/* ----- ULS_OBJECT_TYPE ------ */

typedef enum
{
	ULSOBJECT_PERSON,
	ULSOBJECT_APPLICATION,
	ULSOBJECT_PROTOCOL,
	ULSOBJECT_CONFERENCE,
	ULSOBJECT_ALIAS_TO_PERSON,
	ULSOBJECT_ALIAS_TO_CONFERENCE,
}
	ULS_OBJECT_TYPE;


/* ------ async callback procedures ------ */

typedef HRESULT (WINAPI *ULS_SIMPLE_CB) (
							IN		ULS_HASYNC hAsyncReq,
							IN		LPARAM lParamCB,
							IN		HRESULT hr,
							IN		DWORD dwResult );

/* ------ ULS_CONN ------ */

typedef struct tag_ULS_CONN_INFO_W
{
	DWORD		dwFlags;
	ULONG		nTimeout;
	PWSTR		pszServerName;
	PWSTR		pszUlsBase;		// eg. "c=US, o=Microsoft, ou=ULS"
	PWSTR		pszUserName;	// if NULL, the client puts default
	PWSTR		pszPassword;	// if NULL, the client puts default
}
	ULS_CONN_INFO_W;

typedef struct tag_ULS_CONN_INFO_A
{
	DWORD		dwFlags;
	ULONG		nTimeout;
	PSTR		pszServerName;
	PSTR		pszUlsBase;		// eg. "c=US, o=Microsoft, ou=ULS"
	PSTR		pszUserName;	// if NULL, the client puts default
	PSTR		pszPassword;	// if NULL, the client puts default
}
	ULS_CONN_INFO_A;

#ifdef UNICODE
typedef ULS_CONN_INFO_W		ULS_CONN_INFO;
#else
typedef ULS_CONN_INFO_A		ULS_CONN_INFO;
#endif


/* ------ ULS_CONN_REQ ------ */

typedef struct tag_ULS_CONN_REQ_W
{
	DWORD			dwFlags;
	ULS_CONN_INFO_W	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_CONN_REQ_W;

typedef struct tag_ULS_CONN_REQ_A
{
	DWORD			dwFlags;
	ULS_CONN_INFO_A	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_CONN_REQ_A;

#ifdef UNICODE
typedef ULS_CONN_REQ_W		ULS_CONN_REQ;
#else
typedef ULS_CONN_REQ_A		ULS_CONN_REQ;
#endif


/* ------ ULS_DISCONN_REQ ------ */

typedef struct tag_ULS_DISCONN_REQ_W
{
	DWORD			dwFlags;
	ULS_HCONN		hConn;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DISCONN_REQ_W;

typedef struct tag_ULS_DISCONN_REQ_A
{
	DWORD			dwFlags;
	ULS_HCONN		hConn;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DISCONN_REQ_A;

#ifdef UNICODE
typedef ULS_DISCONN_REQ_W		ULS_DISCONN_REQ;
#else
typedef ULS_DISCONN_REQ_A		ULS_DISCONN_REQ;
#endif


/* ------ ULS_REG_REQ ------ */

typedef struct tag_ULS_REG_REQ_W
{
	DWORD			dwFlags;	// 32-bit flags.
	ULS_HCONN		hConn;		// handle to connection to server
	ULS_CONN_INFO_W	ConnInfo;
	ULS_HOBJECT		hObject1;	// first level object
	ULS_HOBJECT		hObject2;	// second level object
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM 			lParamCB;	// 32-bit callback parameter
}
	ULS_REG_REQ_W;
	
typedef struct tag_ULS_REG_REQ_A
{
	DWORD			dwFlags;	// 32-bit flags.
	ULS_HCONN		hConnect;	// handle to connection to server
	ULS_CONN_INFO_A	ConnInfo;
	ULS_HOBJECT		hObject1;	// first level object
	ULS_HOBJECT		hObject2;	// second level object
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_REG_REQ_A;

#ifdef UNICODE
typedef ULS_REG_REQ_W		ULS_REG_REQ;
#else
typedef ULS_REG_REQ_A		ULS_REG_REQ;
#endif


/* ------ ULS_RESOLVE_REQ ------ */

typedef struct tag_ULS_RESOLVE_REQ_W
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PWSTR			pszObject1Uid;
	PWSTR			pszObject2Uid;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_W	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_RESOLVE_REQ_W;

typedef struct tag_ULS_RESOLVE_REQ_A
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PSTR			pszObject1Uid;
	PSTR			pszObject2Uid;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_A	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_RESOLVE_REQ_A;

#ifdef UNICODE
typedef ULS_RESOLVE_REQ_W		ULS_RESOLVE_REQ;
#else
typedef ULS_RESOLVE_REQ_A		ULS_RESOLVE_REQ;
#endif


/* ------ ULS_DIR_REQ ------ */

typedef struct tag_ULS_DIR_REQ_W
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PWSTR			pszFilter;
	PWSTR			pszToMatch;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_W	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DIR_REQ_W;

typedef struct tag_ULS_DIR_REQ_A
{
	DWORD			dwFlags;
	ULS_OBJECT_TYPE	ObjectType;
	PSTR			pszFilter;
	PSTR			pszToMatch;
	ULONG			cPropTags;
	PDWORD			pdwPropTags;
	ULS_HCONN		hConn;
	ULS_CONN_INFO_A	ConnInfo;
	ULS_SIMPLE_CB	pfnCB;		// callback function
	LPARAM  		lParamCB;	// 32-bit callback parameter
}
	ULS_DIR_REQ_A;

#ifdef UNICODE
typedef ULS_DIR_REQ_W		ULS_DIR_REQ;
#else
typedef ULS_DIR_REQ_A		ULS_DIR_REQ;
#endif


/* ------ ULS_DIR_UNIT ------ */

typedef struct tag_ULS_DIR_UNIT_W
{
	ULONG		cProps;
	SPropValue	*pProps;
}
	ULS_DIR_UNIT_W;

typedef ULS_DIR_UNIT_W		ULS_DIR_UNIT_A;

#ifdef UNICODE
typedef ULS_DIR_UNIT_W		ULS_DIR_UNIT;
#else
typedef ULS_DIR_UNIT_A		ULS_DIR_UNIT;
#endif


/* ------ ULS_DIR_RESULT ------ */

typedef struct tag_ULS_DIR_RESULT_W
{
	ULONG			cbSize;
	ULONG			cEntries;
	ULS_DIR_UNIT_W	audeiEntries[1];
}
	ULS_DIR_RESULT_W;

typedef ULS_DIR_RESULT_W		ULS_DIR_RESULT_A;

#ifdef UNICODE
typedef ULS_DIR_RESULT_W		ULS_DIR_RESULT;
#else
typedef ULS_DIR_RESULT_A		ULS_DIR_RESULT;
#endif


/* ------ ULS_ASYNC_DIR_RESULT ------ */

typedef struct tag_ULS_ASYNC_DIR_RESULT_W
{
	ULONG			cbSize;
	ULONG			cTotalEntries;
	ULONG			cbTotalDataSize;
	ULONG			nFirstEntry;
	ULONG			cEntriess;
	ULS_DIR_UNIT_W	audeiEntries[1];
}
	ULS_ASYNC_DIR_RESULT_W;

typedef struct tag_ULS_ASYNC_DIR_RESULT_A
{
	ULONG			cbSize;
	ULONG			nFirstEntry;
	ULONG			cEntriess;
	ULS_DIR_UNIT_A	audeiEntries[1];
}
	ULS_ASYNC_DIR_RESULT_A;

#ifdef UNICODE
typedef ULS_ASYNC_DIR_RESULT_W		ULS_ASYNC_DIR_RESULT;
#else
typedef ULS_ASYNC_DIR_RESULT_A		ULS_ASYNC_DIR_RESULT;
#endif


/* ------ ULS_CONF ------ */

// same as INTERNET_MAX_USER_NAME_LENGTH in wininet.h.
#define ULS_MAX_UID_LENGTH		  	256
#define ULS_MAX_SERVER_NAME_LENGTH	128
#define ULS_MAX_FIRST_NAME_LENGTH	128
#define ULS_MAX_LAST_NAME_LENGTH	128
#define ULS_MAX_EMAIL_NAME_LENGTH	128
#define ULS_MAX_CITY_NAME_LENGTH	128
#define ULS_MAX_COUNTRY_NAME_LENGTH	128
#define ULS_MAX_COMMENTS_LENGTH		256
#define ULS_MAX_CLNTSTRING_LENGTH	256 //max of above
//SS: username is concatenated first name with last name with space in between
#define ULS_MAX_USER_NAME_LENGTH	(ULS_MAX_FIRST_NAME_LENGTH + ULS_MAX_LAST_NAME_LENGTH)
#define	UI_COMMENTS_LENGTH			60	// ;Internal BUGS BUGS to remove

#define MAX_IP_ADDRESS_STRING_LENGTH    20

typedef struct tagULS_HTTP_RESP
{
    ULONG   cbSize;
    ULONG   nCmdId;
    HRESULT hr;
    ULONG   nPort;
    DWORD   dwAppSession;
    DWORD   dwClientSession;
    DWORD   dwClientId;
    CHAR    *pszUID;
    CHAR    *pszURL;
    CHAR    szIPAddress[MAX_IP_ADDRESS_STRING_LENGTH];
    CHAR    szMimeType[MAX_MIME_TYPE_LENGTH];
    CHAR    szAppMime[MAX_MIME_TYPE_LENGTH];
    CHAR    szProtMime[MAX_MIME_TYPE_LENGTH];
    CHAR    szAppId[MAX_NM_APP_ID];
    CHAR    szProtId[MAX_PROTOCOL_ID];
    ULONG   nApps;
}
    ULS_HTTP_RESP;

/* ------ ULS_PROVIDER_INFO ------ */

#define ULS_MAX_PROVIDER_COMPANY_NAME_LENGTH		64
#define ULS_MAX_PROVIDER_PRODUCT_NAME_LENGTH		64
#define ULS_MAX_PROVIDER_PROTOCOL_NAME_LENGTH		16

typedef struct tag_ULS_PROVIDER_INFO_W
{
	ULONG	cbSize;
	DWORD	dwVersion;	// hiword major; loword minor
	ULONG	nProviderId; // created by the uls client, valid only in this process
	WCHAR	szCompanyName[ULS_MAX_PROVIDER_COMPANY_NAME_LENGTH];
	WCHAR	szProductName[ULS_MAX_PROVIDER_PRODUCT_NAME_LENGTH];
	WCHAR	szProtocolName[ULS_MAX_PROVIDER_PROTOCOL_NAME_LENGTH];
}
	ULS_PROVIDER_INFO_W;

typedef struct tag_ULS_PROVIDER_INFO_A
{
	ULONG	cbSize;
	DWORD	dwVersion;	// hiword major; loword minor
	ULONG	nProviderId; // created by the uls client, valid only in this process
	CHAR	szCompanyName[ULS_MAX_PROVIDER_COMPANY_NAME_LENGTH];
	CHAR	szProductName[ULS_MAX_PROVIDER_PRODUCT_NAME_LENGTH];
	CHAR	szProtocolName[ULS_MAX_PROVIDER_PROTOCOL_NAME_LENGTH];
}
	ULS_PROVIDER_INFO_A;

#ifdef UNICODE
typedef ULS_PROVIDER_INFO_W		ULS_PROVIDER_INFO;
#else
typedef ULS_PROVIDER_INFO_A		ULS_PROVIDER_INFO;
#endif


#endif // _ULSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\applet.hpp ===
#ifndef _FILE_TRANSFER_APPLET_H_
#define _FILE_TRANSFER_APPLET_H_

#include <it120app.h>
#include "cntlist.h"
#include <gencontainers.h>

#define FT_SHUTDOWN_TIMEOUT         5000    // 5 seconds
#define FT_STARTUP_TIMEOUT          5000    // 5 seconds


class MBFTEngine;
class CEngineList : public CList
{
    DEFINE_CLIST(CEngineList, MBFTEngine*)
    MBFTEngine *FindByConfID(T120ConfID nConfID);
#ifdef ENABLE_HEARTBEAT_TIMER
    MBFTEngine *FindByTimerID(UINT_PTR nTimerID);
#endif
};

class CAppletWindow;
class CWindowList : public CList
{
    DEFINE_CLIST(CWindowList, CAppletWindow*)
};


class CConfList : public CList
{
    DEFINE_CLIST_(CConfList, T120ConfID)
};


class CFtHiddenWindow : public CGenWindow
{
public:
    CFtHiddenWindow() {}

    BOOL Create();

    virtual ~CFtHiddenWindow() {}

protected:
    virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
};


class CFileTransferApplet
{
public:

    CFileTransferApplet(HRESULT *);
    ~CFileTransferApplet(void);

    IT120Applet *GetAppletSAP(void) { return m_pAppletSAP; }

    void RegisterEngine(MBFTEngine *p);
    void UnregisterEngine(MBFTEngine *p);
    MBFTEngine * FindEngineWithNoIntf(void);
	MBFTEngine * FindEngineWithIntf(void);

    void RegisterWindow(CAppletWindow *pWindow);
    void UnregisterWindow(CAppletWindow *pWindow);
    CAppletWindow *GetUnattendedWindow(void);

    CWindowList *GetWindowList(void) { return &m_WindowList; }

    T120Error CreateAppletSession(IT120AppletSession **pp, T120ConfID nConfID)
    {
        return m_pAppletSAP->CreateSession(pp, nConfID);
    }

    MBFTEngine *FindEngineByTimerID(UINT_PTR nTimerID) { return m_EngineList.FindByTimerID(nTimerID); }

    void T120Callback(T120AppletMsg *);

    BOOL QueryShutdown(BOOL fGoAheadShutdown);
	CAppletWindow *GetMainUI(void) { m_WindowList.Reset();  return m_WindowList.Iterate(); }
	LRESULT BringUIToFront(void);
    BOOL    Has2xNodeInConf(void);
	BOOL	InConf(void);
	BOOL	HasSDK(void);
	HWND	GetHiddenWnd(void) { return m_pHwndHidden->GetWindow(); }

private:

    IT120Applet    *m_pAppletSAP;
    CEngineList     m_EngineList;
    CConfList       m_UnattendedConfList;
    CWindowList     m_WindowList;
	CFtHiddenWindow	*m_pHwndHidden;			// hidden window for processing MBFTMSG
};


extern CFileTransferApplet *g_pFileXferApplet;

#endif // _FILE_TRANSFER_APPLET_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\asn1hdr.h ===
#ifndef ASN1HDR
#define ASN1HDR



typedef char ossBoolean;

typedef char Nulltype;

typedef struct {
  short          year;         /* YYYY format when used for GeneralizedTime */
                               /* YY format when used for UTCTime */
  short          month;
  short          day;
  short          hour;
  short          minute;
  short          second;
  short          millisec;
  short          mindiff;          /* UTC +/- minute differential     */  
  ossBoolean        utc;              /* TRUE means UTC time             */  
} GeneralizedTime; 

typedef GeneralizedTime UTCTime;

typedef struct {
  int            pduNum;
  long           length;           /* length of encoded */
  void          *encoded;
  void          *decoded;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
  void          *userField;
#endif
} OpenType;

enum MixedReal_kind {OSS_BINARY, OSS_DECIMAL};

typedef struct {
  enum MixedReal_kind kind;
  union {
      double base2;
      char  *base10;
  } u;
} MixedReal;

typedef struct ObjectSetEntry {
  struct ObjectSetEntry *next;
  void                  *object;
} ObjectSetEntry; 

#endif     /* #ifndef ASN1HDR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\cntlist.cpp ===
#include "mbftpch.h"
#include "cntlist.h"


CList::CList(ULONG cMaxItems, BOOL fQueue)
:
    m_fQueue(fQueue),
    m_cMaxEntries(cMaxItems)
{
    Init();
}


CList::CList(CList *pSrc)
:
    m_fQueue(pSrc->m_fQueue),
    m_cMaxEntries(pSrc->GetCount())
{

    Init();

    LPVOID p;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate()))
    {
        Append(p);
    }
}


BOOL CList::Init(void)
{
    if (m_cMaxEntries < CLIST_DEFAULT_MAX_ITEMS)
    {
        m_cMaxEntries = CLIST_DEFAULT_MAX_ITEMS;
    }

    m_cEntries = 0;
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    // it is kind of bad here because there is no way to return an error.
    // unfortunately it won't fault here and later.
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[m_cMaxEntries * sizeof(LPVOID)];
    return (BOOL) (m_aEntries != NULL);
}


CList::~CList(void)
{
    delete m_aEntries;
}


BOOL CList::Expand(void)
{
    if (NULL == m_aEntries)
    {
        // it is impossible.
        ASSERT(FALSE);
        return Init();
    }

    // the current array is full
    ASSERT(m_cEntries == m_cMaxEntries);

    // remember the old array to free or to restore
    LPVOID  *aOldEntries = m_aEntries;

    // we need to allocate a bigger array to hold more data.
    // the new array has twice the size of the old one
    ULONG cNewMaxEntries = m_cMaxEntries << 1;
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[cNewMaxEntries * sizeof(LPVOID)];
    if (NULL == m_aEntries)
    {
        // we failed; we have to restore the array and return
        m_aEntries = aOldEntries;
        return FALSE;
    }

    // copy the old entries into the new array, starting from the beginning
    ULONG nIdx = m_cMaxEntries - m_nHeadOffset;
    ::CopyMemory(m_aEntries, &aOldEntries[m_nHeadOffset], nIdx * sizeof(LPVOID));
    ::CopyMemory(&m_aEntries[nIdx], aOldEntries, m_nHeadOffset * sizeof(LPVOID));

    // set the new max entries (required for the key array)
    m_cMaxEntries = cNewMaxEntries;

    // Free the old array of entries
    delete aOldEntries;

    // Set the instance variables
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    return TRUE;
}


BOOL CList::Append(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_aEntries[(m_nHeadOffset + (m_cEntries++)) % m_cMaxEntries] = pData;

    return TRUE;
}


BOOL CList::Prepend(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_cEntries++;
    m_nHeadOffset = (0 == m_nHeadOffset) ? m_cMaxEntries - 1 : m_nHeadOffset - 1;
    m_aEntries[m_nHeadOffset] = pData;

    return TRUE;
}


BOOL CList::Find(LPVOID pData)
{
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        if (pData == m_aEntries[(m_nHeadOffset + i) % m_cMaxEntries])
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL CList::Remove(LPVOID pData)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (pData == m_aEntries[nIdx])
        {
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                    }
                }
            }

            m_cEntries--;
            return TRUE;
        }
    }
    return FALSE;
}


LPVOID CList::Get(void)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
    }
    return pRet;
}


LPVOID CList::Iterate(void)
{
    if (0 == m_cEntries)
    {
        return NULL;
    }

    if (m_nCurrOffset == CLIST_END_OF_ARRAY_MARK)
    {
        // start from the beginning
        m_nCurrOffset = 0;
    }
    else
    {
        if (++m_nCurrOffset >= m_cEntries)
        {
            // reset the iterator
            m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
            return NULL;
        }
    }

    return m_aEntries[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries];
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconf\watcher.cpp ===
#include "precomp.h"

//
// watcher.cpp
//
// This file is a big ugly hack to make sure that NetMeeting 
// will cleanup is display driver (nmndd.sys) properly. This is
// needed because it uses a mirrored driver which will prevent DX
// games from running if NetMeeting is not shut down cleanly.
//
// Copyright(c) Microsoft 1997-
//


//
// This function actually disables the "NetMeeting driver" display driver
//
BOOL DisableNetMeetingDriver()
{
    BOOL bRet = TRUE;   // assume success
    DISPLAY_DEVICE dd = {0};
    int i;

    dd.cb = sizeof(dd);
    
    for (i = 0; EnumDisplayDevices(NULL, i, &dd, 0); i++)
    {
        if ((dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) &&
            (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) &&
            !lstrcmpi(dd.DeviceString, TEXT("NetMeeting driver")))
        {
            DEVMODE devmode = {0};

            devmode.dmSize = sizeof(devmode);
            devmode.dmFields = DM_POSITION | DM_PELSWIDTH | DM_PELSHEIGHT;

            if ((ChangeDisplaySettingsEx(dd.DeviceName,
                                         &devmode,
                                         NULL,
                                         CDS_UPDATEREGISTRY | CDS_NORESET,
                                         NULL) != DISP_CHANGE_SUCCESSFUL) ||
                (ChangeDisplaySettings(NULL, 0) != DISP_CHANGE_SUCCESSFUL))
            {
                // we failed for some unknown reason
                bRet = FALSE;
            }

            // we found the driver, no need to look further
            break;
        }
    }

    if (i == 0)
    {
        // this means that EnumDisplayDevices failed, which we consider a
        // failure case
        bRet = FALSE;
    }

    return bRet;
}


//
// Constructs the proper ""C:\windows\system32\rundll32.exe" nmasnt.dll,CleanupNetMeetingDispDriver 0"
// commandline to put into the registry in case the machine is rebooted while netmeeting is
// running.
//
BOOL GetCleanupCmdLine(LPTSTR pszCmdLine)
{
    BOOL bRet = FALSE;
    TCHAR szWindir[MAX_PATH];

    if (GetSystemDirectory(szWindir, sizeof(szWindir)/sizeof(szWindir[0])))
    {
        wsprintf(pszCmdLine, TEXT("\"%s\\rundll32.exe\" msconf.dll,CleanupNetMeetingDispDriver 0"), szWindir);
        bRet = TRUE;
    }

    return bRet;
}


//
// This will either add or remove ourself from the runonce section of the registry
//
BOOL SetCleanupInRunone(BOOL bAdd)
{
    BOOL bRet = FALSE;
    TCHAR szCleanupCmdLine[MAX_PATH * 2];

    if (GetCleanupCmdLine(szCleanupCmdLine))
    {
        HKEY hk;

        // first try HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                         0,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &hk) == ERROR_SUCCESS)
        {
            if (bAdd)
            {
                if (RegSetValueEx(hk,
                                  TEXT("!CleanupNetMeetingDispDriver"),
                                  0,
                                  REG_SZ,
                                  (LPBYTE)szCleanupCmdLine,
                                  (lstrlen(szCleanupCmdLine) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                {
                    bRet = TRUE;
                }
            }
            else
            {
                if (RegDeleteValue(hk, TEXT("!CleanupNetMeetingDispDriver")) == ERROR_SUCCESS)
                {
                    bRet = TRUE;
                }
            }

            RegCloseKey(hk);
        }

        if (!bRet)
        {
            // if we failed, then try HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               NULL,
                               &hk,
                               NULL) == ERROR_SUCCESS)
            {
                if (bAdd)
                {
                    if (RegSetValueEx(hk,
                                      TEXT("!CleanupNetMeetingDispDriver"),
                                      0,
                                      REG_SZ,
                                      (LPBYTE)szCleanupCmdLine,
                                      (lstrlen(szCleanupCmdLine) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                    {
                        bRet = TRUE;
                    }
                }
                else
                {
                    if (RegDeleteValue(hk, TEXT("!CleanupNetMeetingDispDriver")) == ERROR_SUCCESS)
                    {
                        bRet = TRUE;
                    }
                }

                RegCloseKey(hk);
            }
        }
    }

    return bRet;
}

// on retail builds we don't have CRT's so we need this
#ifndef DBG

int _wchartodigit(WCHAR ch)
{
#define DIGIT_RANGE_TEST(zero)  \
    if (ch < zero)              \
        return -1;              \
    if (ch < zero + 10)         \
    {                           \
        return ch - zero;       \
    }

    DIGIT_RANGE_TEST(0x0030)        // 0030;DIGIT ZERO
    if (ch < 0xFF10)                // FF10;FULLWIDTH DIGIT ZERO
    {
        DIGIT_RANGE_TEST(0x0660)    // 0660;ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x06F0)    // 06F0;EXTENDED ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x0966)    // 0966;DEVANAGARI DIGIT ZERO
        DIGIT_RANGE_TEST(0x09E6)    // 09E6;BENGALI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0A66)    // 0A66;GURMUKHI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0AE6)    // 0AE6;GUJARATI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0B66)    // 0B66;ORIYA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0C66)    // 0C66;TELUGU DIGIT ZERO
        DIGIT_RANGE_TEST(0x0CE6)    // 0CE6;KANNADA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0D66)    // 0D66;MALAYALAM DIGIT ZERO
        DIGIT_RANGE_TEST(0x0E50)    // 0E50;THAI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0ED0)    // 0ED0;LAO DIGIT ZERO
        DIGIT_RANGE_TEST(0x0F20)    // 0F20;TIBETAN DIGIT ZERO
        DIGIT_RANGE_TEST(0x1040)    // 1040;MYANMAR DIGIT ZERO
        DIGIT_RANGE_TEST(0x17E0)    // 17E0;KHMER DIGIT ZERO
        DIGIT_RANGE_TEST(0x1810)    // 1810;MONGOLIAN DIGIT ZERO


        return -1;
    }
#undef DIGIT_RANGE_TEST

    if (ch < 0xFF10 + 10) 
    { 
        return ch - 0xFF10; 
    }

    return -1;
}


__int64 __cdecl _wtoi64(const WCHAR *nptr)
{
        int c;              /* current char */
        __int64 total;      /* current total */
        int sign;           /* if '-', then negative, otherwise positive */

        if (!nptr)
            return 0i64;

        c = (int)(WCHAR)*nptr++;

        total = 0;

        while ((c = _wchartodigit((WCHAR)c)) != -1)
        {
            total = 10 * total + c;     /* accumulate digit */
            c = (WCHAR)*nptr++;    /* get next char */
        }

        return total;
}
#endif //!DBG


//
// The purpose of this function is two-fold:
//
//  1. It is passed the decimal value of the NetMeeting process handle on the cmdline
//     so that it can wait for NetMeeting to terminate and make sure that the mnmdd
//     driver is disabled.
//
//  2. We also add ourselves to the runonce in case the machine is rebooted or bugchecks
//     while NetMeeting is running so we can disable the driver at next logon.
//
STDAPI_(void) CleanupNetMeetingDispDriverW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pswszCmdLine, int nCmdShow)
{
    HANDLE hNetMeetingProcess = NULL;
    HANDLE hEvent;
    BOOL bAddedToRunOnce = FALSE;
    BOOL bNetMeetingStillRunning = FALSE;

    // the handle of the process to watch is passed to us on the cmdline as a decimal string value
    if (pswszCmdLine && *pswszCmdLine)
    {
        hNetMeetingProcess = (HANDLE)_wtoi64(pswszCmdLine);
    }

    if (hNetMeetingProcess)
    {
        // add ourselves to the runonce in case the machine bugchecks or is rebooted, we can still disable the
        // mnmdd driver at next logon
        bAddedToRunOnce = SetCleanupInRunone(TRUE);

        for (;;)
        {
            MSG msg;
            DWORD dwReturn = MsgWaitForMultipleObjects(1, &hNetMeetingProcess, FALSE, INFINITE, QS_ALLINPUT);

            if (dwReturn != (WAIT_OBJECT_0 + 1))
            {
                // something other than a message (either our event is signaled or MsgWait failed)
                break;
            }

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    else
    {
        // If hNetMeetingProcess is NULL, this means we are running as part of RunOnce due to a reboot
        // or a bugcheck. We have to signal the "msgina: ShellReadyEvent" early so that the desktop switch
        // will take place or else our call to ChangeDisplaySettingsEx will fail becuase the input desktop
        // will still be winlogon's secure desktop
        hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("msgina: ShellReadyEvent"));
        if (hEvent)
        {
            SetEvent(hEvent);
            CloseHandle(hEvent);
        }

        // we also wait 10 seconds just to be sure that the desktop switch has taken place
        Sleep(10 * 1000);
    }
    
    // Only disable the driver if conf.exe/mnmsrvc.exe is not running. We need this extra check since the service (mnmsrvc.exe)
    // can stop and start but conf.exe might still be running, and we don't want to disable the driver while the app
    // is still using it. Conversely, we dont want to detach the driver if mnmsrvc.exe is still running.
    hEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("CONF:Init"));
    if (hEvent)
    {
        bNetMeetingStillRunning = TRUE;
        CloseHandle(hEvent);
    }

    if (FindWindow(TEXT("MnmSrvcHiddenWindow"), NULL))
    {
        bNetMeetingStillRunning = TRUE;
    }

    if (bNetMeetingStillRunning)
    {
        // make sure we are in the runonce
        bAddedToRunOnce = SetCleanupInRunone(TRUE);
    }
    else
    {
        // this will detach the mnmdd driver from the hw, allowing DX games to run
        if (DisableNetMeetingDriver() && bAddedToRunOnce)
        {
            // remove ourselves from the runonce
            SetCleanupInRunone(FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\cntlist.h ===
#ifndef _CONTAINED_LIST_H_
#define _CONTAINED_LIST_H_


#define CLIST_DEFAULT_MAX_ITEMS   4
#define CLIST_END_OF_ARRAY_MARK   ((UINT) -1)


class CList
{
public:

    CList(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS, BOOL fQueue = FALSE);
    CList(CList *pSrc);

    ~CList(void);

    BOOL Append(LPVOID pData);
    BOOL Prepend(LPVOID pData);

    BOOL Find(LPVOID pData);
    BOOL Remove(LPVOID pData);

    LPVOID Get(void);

    LPVOID Iterate(void);

    void Reset(void) { m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };
    void Clear(void) { m_cEntries = 0; m_nHeadOffset = 0; m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };

    UINT GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

    LPVOID PeekHead(void) { return (0 != m_cEntries) ? m_aEntries[m_nHeadOffset] : NULL; }

protected:

    ULONG      m_cEntries;
    ULONG      m_cMaxEntries;
    ULONG      m_nHeadOffset;
    ULONG      m_nCurrOffset;
    BOOL       m_fQueue;       // TRUE for CQueue, FALSE for CList

    LPVOID    *m_aEntries;

private:

    BOOL Expand(void);
    BOOL Init(void);
};


#define DEFINE_CLIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CList() { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CLIST_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CList() { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }


class CQueue : public CList
{
public:

    CQueue(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, TRUE) { };
    CQueue(CQueue *pSrc) : CList((CList *) pSrc) { };
};


#define DEFINE_CQUEUE(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CQueue() { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CQUEUE_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CQueue() { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }



typedef LPVOID          BOOL_PTR;
#define TRUE_PTR        ((LPVOID) (UINT_PTR)  1)
#define FALSE_PTR       ((LPVOID) (UINT_PTR) -1)

#define LPVOID_NULL     ((LPVOID) (UINT_PTR) -1)


#endif // _CONTAINED_LIST_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\combotb.cpp ===
#include "mbftpch.h"
#include "combotb.h"

const static COLORREF EditBack = RGB(255, 255, 255);
const static COLORREF EditFore = RGB(0, 0, 0 );
const static int	FtTBHMargin	= 5;
const static int	FtTBVMargin	= 5;
const static int	FtHGap		= 3;


CComboToolbar::CComboToolbar() :
	m_Combobox(NULL),
	m_iCount(0),
	m_Buttons(NULL),
	m_iNumButtons(0)
{
	m_nAlignment = Center;
}

CComboToolbar::~CComboToolbar()
{
	delete [] m_Buttons;
}


typedef CBitmapButton *		LPBITMAPBTN;

BOOL CComboToolbar::Create(HWND hwndParent, struct Buttons *buttons,
						   int iNumButtons, LPVOID  pOwner)
{
	int i;
	BOOL	fRet;

	m_pOwner = pOwner;
	if (!CToolbar::Create(hwndParent))
	{
		return FALSE;
	}

	m_iNumButtons = iNumButtons;	
	m_hMargin	= FtTBHMargin;
	m_vMargin	= FtTBVMargin;
	m_gap		= FtHGap;
	m_bMinDesiredSize	= TRUE;
	m_bHasCenterChild = TRUE;
	m_uRightIndex	= m_iNumButtons + 1;

    DBG_SAVE_FILE_LINE
	m_Buttons = (CGenWindow**) new LPBITMAPBTN [m_iNumButtons];
	if (NULL != m_Buttons)
	{
		::ZeroMemory(m_Buttons, m_iNumButtons * sizeof(LPBITMAPBTN));

		for (i = 0; i < m_iNumButtons; i++)
		{
			if (buttons[i].idCommand)
			{
				DBG_SAVE_FILE_LINE
				m_Buttons[i] = new CBitmapButton();
				if (NULL != m_Buttons[i])
				{
					fRet = ((CBitmapButton*)m_Buttons[i])->Create(GetWindow(), buttons[i].idCommand,
									g_hDllInst, buttons[i].idbStates, TRUE,
									buttons[i].nInputStates, buttons[i].nCustomStates, NULL);
					m_Buttons[i]->SetTooltip(buttons[i].pszTooltip);
					ASSERT(fRet);
				}
			}
			else
			{
				DBG_SAVE_FILE_LINE
				CSeparator *pSep = new CSeparator();
				m_Buttons[i] = pSep;
				if (NULL != pSep)
				{
					fRet = pSep->Create(GetWindow(), CSeparator::Blank);
					ASSERT (fRet);
				}
			}
			m_Buttons[i]->Release();
		}
	}

    DBG_SAVE_FILE_LINE
	m_Combobox = new CComboBox();
	if (NULL != m_Combobox)
	{
		if (m_Combobox->Create(GetWindow(), 100, CBS_AUTOHSCROLL|CBS_DROPDOWNLIST,
								NULL, NULL))
		{
			m_Combobox->SetColors(CreateSolidBrush(EditBack), EditBack, EditFore);
            m_Combobox->SetTooltip((LPSTR)IDS_RECEIVER_TT);
			m_Combobox->SetFont((HFONT)::GetStockObject(DEFAULT_GUI_FONT));
			m_Combobox->Release();
		}
	}

	return TRUE;
}
	

void CComboToolbar::OnDesiredSizeChanged()
{
	ScheduleLayout();
}


LRESULT CComboToolbar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

	default:
		break;
	}
	return (CToolbar::ProcessMessage(hwnd, message, wParam, lParam));
}


void CComboToolbar::OnCommand(HWND hwnd, int wId, HWND hwndCtl, UINT codeNotify)
{
	if (m_pOwner)
	{
		CAppletWindow *pWindow = (CAppletWindow*)m_pOwner;
		pWindow->OnCommand((WORD)wId, hwndCtl, (WORD)codeNotify);
		return;
	}
	else
	{
		WARNING_OUT(("CComboToolbar::OnCommand--Received unhandlable message.\n"));
	}
}


void CComboToolbar::HandlePeerNotification(T120ConfID confID, T120NodeID nodeID,
										   PeerMsg *pMsg)
{
	int iLen, iIndex, iCount;
	char  szName[MAX_PATH];

	if (pMsg->m_NodeID != nodeID)
	{
		iLen = T120_GetNodeName(confID, pMsg->m_NodeID, szName, MAX_PATH);
		if (iLen)
		{
			ASSERT (iLen < MAX_PATH);
			MEMBER_ID nMemberID = MAKE_MEMBER_ID(pMsg->m_MBFTPeerID, pMsg->m_NodeID);

			if (pMsg->m_bPeerAdded)
			{
				if (m_iCount == 0)
				{
					char szAll[MAX_PATH];
					::LoadString(g_hDllInst, IDS_ALL_RECEIVER, szAll, MAX_PATH);
					m_Combobox->AddText(TEXT(szAll));
					WARNING_OUT(("Insert ALL"));
				}
				m_Combobox->AddText(szName, nMemberID);
				WARNING_OUT(("Insert %s.\n", szName));
				m_iCount++;
			}
			else
			{
				// Scan through the whole list to find the user
				iCount = m_Combobox->GetNumItems();
				for (iIndex = 0; iIndex < iCount; iIndex++)
				{
					if (nMemberID == (MEMBER_ID)m_Combobox->GetUserData(iIndex))
						break;
					
				}

				if (iIndex < iCount)
				{  // found
					m_Combobox->RemoveItem(iIndex);
					WARNING_OUT(("delete %s", szName));
					m_iCount--;
					if (0 == m_iCount)
					{
						ASSERT (m_Combobox->GetNumItems() == 1);
						m_Combobox->RemoveItem(0);
						WARNING_OUT(("delete ALL"));
					}
				}
				else
				{
					WARNING_OUT(("Can't find to be deleted peer, %s.\n", szName));
				}
			}
		}
		else
		{
			WARNING_OUT(("Can't find node name for nConfID=%d, nNodeID=%d.\n",
				(UINT) confID, (UINT) pMsg->m_NodeID));
		}
	}
	else
	{   // delete all items. Bacause MBFTEngine does not explicitly send PeerNotify message for every peer
		// when the node leaves message, so it is up to the host to remove all the peers during its close.
		if (!pMsg->m_bPeerAdded)
		{
			iCount = m_Combobox->GetNumItems();
			for (iIndex = iCount - 1; iIndex >= 0; iIndex--)
			{
				m_Combobox->RemoveItem(iIndex);
			}
			m_iCount = 0;
		}
	}

	if (m_iCount)
	{	
		// Default select "ALL"
		m_Combobox->SetSelectedIndex(0);
	}
	else
	{
		// Deselect
		m_Combobox->SetSelectedIndex(-1);
	}
}


//
//  Return item selected and its associated itemdata
//
UINT  CComboToolbar::GetSelectedItem(LPARAM *ItemData)
{
	int  iIndex = m_Combobox->GetSelectedIndex();
	if (iIndex >= 0)
	{
		*ItemData = m_Combobox->GetUserData(iIndex);
	}
	return iIndex;
}


static const int c_iCommands[] =
{ IDM_ADD_FILES, IDM_REMOVE_FILES, IDM_SEND_ALL, IDM_SEND_ONE, IDM_STOP_SENDING,
IDM_OPEN_RECV_FOLDER};

void CComboToolbar::UpdateButton(int *iFlags)
{
	for (int iIndex = 0; iIndex < m_iNumButtons; iIndex++)
	{
		if (NULL != m_Buttons[iIndex])
		{
			::EnableWindow(m_Buttons[iIndex]->GetWindow(), iFlags[iIndex]);
		}
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\combotb.h ===
#ifndef COMBO_TOOLBAR_H
#define COMBO_TOOLBAR_H

#include <gencontrols.h>
#include <gencontainers.h>

// Private structure for defining a button
struct Buttons
{
    int idbStates;      // Bitmap ID for the states
    UINT nInputStates;  // Number of input states in the bitmap
    UINT nCustomStates; // Number of custom states in the bitmap
    int idCommand;      // Command ID for WM_COMMAND messages
    LPCTSTR pszTooltip; // Tooltip text
} ;

class CComboToolbar : public CToolbar
{
private:
	CComboBox		*m_Combobox;
	int				m_iCount;
	CGenWindow		**m_Buttons;
	int				m_iNumButtons;
	void			*m_pOwner;  // pointer to owner (CAppletWindow*)

public:
	CComboToolbar();
	BOOL Create(HWND	hwndParent, struct Buttons* buttons, 
				int iNumButtons, LPVOID  owner);

	virtual void OnDesiredSizeChanged();

	void OnCommand(int id) { OnCommand(GetWindow(), id, NULL, 0); }
	void HandlePeerNotification(T120ConfID confId,	// handle PeerMsg
			T120NodeID nodeID, PeerMsg *pMsg);		
	UINT GetSelectedItem(LPARAM *ItemData);			// get selected item and data
	void UpdateButton(int *iFlags);					// update button state
	
protected:
	virtual ~CComboToolbar();
	virtual LRESULT	ProcessMessage(HWND hwnd, UINT message, 
							WPARAM wParam, LPARAM lParam);

private:
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
};

#endif /* COMBO_TOOLBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\fileio.hpp ===
#ifndef __FILEIO_HPP__
#define __FILEIO_HPP__

class CMBFTFile
{
protected:

	HANDLE 		m_FileHandle;
	DWORD		m_LastIOError;
    char        m_szFileName[_MAX_PATH];
    char        m_szTempDirectory[_MAX_PATH];

private:
	enum OpenModeFlags
	{
    	FDW_Read 	= 0x0001,
    	FDW_Write 	= 0x0002,
    	FDW_Create	= 0x0010,
    	FDW_RDeny	= 0x0100,
    	FDW_WDeny	= 0x0200
	};

public:
    enum OpenMode
    {
        OpenReadOnly 	= FDW_Read,
        OpenReadWrite 	= FDW_Read|FDW_Write,
        OpenBinary		= 0,
        CreateReadOnly	= FDW_Read|FDW_Create,
        CreateWrite		= FDW_Write|FDW_Create,
        CreateReadWrite	= FDW_Write|FDW_Read|FDW_Create,
        ShareExclusive	= FDW_RDeny|FDW_WDeny,
        ShareDenyNone	= 0,
        ShareDenyRead	= FDW_RDeny,
        ShareDenyWrite	= FDW_WDeny,
    };

    enum SeekMode
    {
        SeekFromBegin   =   0,
        SeekFromCurrent =   1,
        SeekFromEnd     =   2
    };

    CMBFTFile();
    ~CMBFTFile();

    BOOL Open(LPCSTR lpszFileName,unsigned iOpenMode);
    BOOL Close(BOOL status=TRUE);
    BOOL Create(LPCSTR lpszDirName, LPCSTR lpszFileName);
    BOOL DeleteFile(void);
    LONG Seek(LONG lOffset,int lFromWhere);
    ULONG Read(LPSTR lpszBuffer, ULONG iNumBytes);
    BOOL Write(LPCSTR lpszBuffer, ULONG iNumBytes);
    LONG GetFileSize(void);
    time_t GetFileDateTime(void);
    BOOL SetFileDateTime(time_t FileDateTime);
    LPCSTR  GetTempDirectory(void);
    LPCSTR  GetFileName(void) { return m_szFileName; }
    int     GetLastErrorCode(void);
    BOOL	GetIsEOF();
};

#endif  //__FILEIO_HPP__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\fileio.cpp ===
/**************************************************************************
** FILENAME:
**
 *              INTEL CORPORATION PROPRIETARY INFORMATION
 *                     Copyright Intel Corporation
 *
 *  This software  is supplied under the terms  of a license agreement or
 *  non-disclosure agreement with Intel Corporation and may not be copied
 *  or disclosed in accordance with the terms of that agreement.
 *
 *
** PURPOSE:
**
** $Header:
**
**
** $Log:
*********************************************************************************/

#include "mbftpch.h"
#include "fileio.hpp"

#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>

extern int MyLoadString(UINT, LPTSTR);
extern int MyLoadString(UINT, LPTSTR, LPTSTR);
extern int MyLoadString(UINT, LPTSTR, LPTSTR, LPTSTR);

CMBFTFile::CMBFTFile()
{
    m_FileHandle = INVALID_HANDLE_VALUE;
    m_LastIOError   = 0;
    m_szFileName[0]	= 0;
}

CMBFTFile::~CMBFTFile()
{
	/* close file if still open */
	Close ();
}

BOOL CMBFTFile::Open(LPCSTR lpszFileName,unsigned iOpenMode)
{
    lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
	DWORD fdwAccess = ((0!=(iOpenMode&FDW_Read))*GENERIC_READ)
					| ((0!=(iOpenMode&FDW_Write))*GENERIC_WRITE);
	DWORD fdwShareMode 	= ((0==(iOpenMode&FDW_RDeny))*FILE_SHARE_READ)
						| ((0==(iOpenMode&FDW_WDeny))*FILE_SHARE_WRITE);
	DWORD fdwCreate	= (iOpenMode&FDW_Create)?CREATE_ALWAYS:OPEN_EXISTING;
	
	m_LastIOError = 0;
	m_FileHandle = CreateFile(
		lpszFileName,
		fdwAccess,
		fdwShareMode,
		NULL,
		fdwCreate,
		FILE_ATTRIBUTE_NORMAL,
		NULL );

	if( INVALID_HANDLE_VALUE == m_FileHandle )
	{
		m_LastIOError = GetLastError();
	}
    return(m_LastIOError == 0);
}


BOOL CMBFTFile::Close(BOOL status)
{
	m_LastIOError = 0;

	/* nothing to do if file already closed */
	if( m_FileHandle == INVALID_HANDLE_VALUE )
		return ( m_LastIOError == 0 );

	/* close the file */
	if( !CloseHandle( m_FileHandle ) )
	{
		m_LastIOError = GetLastError();
	}

    m_FileHandle = INVALID_HANDLE_VALUE;

	/* just delete file if status==FALSE */
	if( status == FALSE )
	{
		::DeleteFile(m_szFileName);
	}

    return( m_LastIOError == 0 );
}

BOOL CMBFTFile::Create(LPCSTR lpszDirName, LPCSTR lpszFileName)
{
	DWORD dwTick;
    BOOL bCreateFile = TRUE;

    /* protect against path info embedded in received file name */
    lpszFileName = GetFileNameFromPath(lpszFileName);

    /* copy original file name */
    if(FAILED(StringCchPrintfA(m_szFileName, CCHMAX(m_szFileName), "%s\\%s", lpszDirName, lpszFileName)))
    {
        m_LastIOError = ERROR_BUFFER_OVERFLOW;
        return FALSE;
    }

    /* generate temp file name if file exists */
    if (FFileExists(m_szFileName))
    {
		// REVIEW
        //Small hack here -- if file already exists, check to see if we have write access.
        //If not, we say report an access denied error...

        if (FFileExists(m_szFileName))
        {
			TCHAR szNewFileName[_MAX_PATH];
			INT_PTR nCount = 1;
			while (1)
			{
				MyLoadString(IDS_COPY_N_OF, szNewFileName, (LPTSTR)nCount, (LPTSTR)lpszFileName);
			    if(FAILED(StringCchPrintfA(m_szFileName, CCHMAX(m_szFileName), "%s\\%s", lpszDirName, szNewFileName)))
			    {
                    m_LastIOError = ERROR_BUFFER_OVERFLOW;
                    return FALSE;
			    }
			    
				if (!FFileExists(m_szFileName))
				{
					break;
				}
				nCount++;
			}
        }
        else
        {
            bCreateFile     =   FALSE;
        }
    }

    //This flag is reset only if file already exists and is read only...

    if(bCreateFile)
    {
        /* finally, create the file */
		m_LastIOError = 0;
		m_FileHandle = CreateFile(
			m_szFileName,
			GENERIC_READ|GENERIC_WRITE,
			FILE_SHARE_READ,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL );

		if( INVALID_HANDLE_VALUE == m_FileHandle )
		{
			m_LastIOError = GetLastError();
		}
	}
    else
    {
        m_szFileName[0] = TEXT('\0'); // Clear file name
    }
    return(bCreateFile && (m_LastIOError == 0));
}

LONG CMBFTFile::Seek( LONG lOffset, int iFromWhere )
{
	DWORD MoveMethod[] = { FILE_BEGIN, FILE_CURRENT, FILE_END };
    LONG Position = (LONG)SetFilePointer( m_FileHandle, lOffset, NULL, MoveMethod[min((unsigned)iFromWhere,2)] );
	m_LastIOError = 0;

    if( Position == -1L )
    {
        m_LastIOError = GetLastError();
    }

    return( Position );
}

ULONG CMBFTFile::Read(LPSTR lpszBuffer, ULONG iNumBytes)
{
    ULONG iBytesRead = 0;

    if(iNumBytes)
    {
		m_LastIOError = 0;
		if( !ReadFile( m_FileHandle, lpszBuffer, iNumBytes, (LPDWORD)&iBytesRead, NULL ) )
		{
			m_LastIOError = GetLastError();
		}

        if(m_LastIOError != 0)
        {
            iBytesRead = (ULONG)-1;
        }
    }

    return(iBytesRead);
}

BOOL CMBFTFile::Write(LPCSTR lpszBuffer, ULONG iNumBytes)
{
    ULONG iBytesWritten = 0;

    if(iNumBytes)
    {
		if( !WriteFile( m_FileHandle, lpszBuffer, iNumBytes, (LPDWORD)&iBytesWritten, NULL ) )
		{
			m_LastIOError = GetLastError();
		}
        if(!m_LastIOError)
        {
            if(iBytesWritten != iNumBytes)
            {
                m_LastIOError = (ULONG)-1;     //Kludge for insufficient disk space...
            }
        }
    }

    return(iBytesWritten == iNumBytes);
}

LONG CMBFTFile::GetFileSize(void)
{
	return( (LONG)::GetFileSize( m_FileHandle, NULL ) );
}


BOOL CMBFTFile::DeleteFile(void)
{
    BOOL bReturn = FALSE;

	/* delete if has name */
    if(lstrlen(m_szFileName))
    {
    	/* close file before deleting */
		CloseHandle( m_FileHandle );
		bReturn = ::DeleteFile( m_szFileName );
		if( !bReturn )
		{
			m_LastIOError = GetLastError();
		}
    }

    return(bReturn);
}

time_t CMBFTFile::GetFileDateTime(void)
{
    WORD Date = 0;
    WORD Time = 0;

	BY_HANDLE_FILE_INFORMATION bhfi;
	if( !GetFileInformationByHandle( m_FileHandle, &bhfi ) )
	{
		return( 0 );
	}
	FileTimeToDosDateTime( &bhfi.ftLastWriteTime, &Date, &Time );
    return(MAKELONG(Time,Date));
}

BOOL CMBFTFile::SetFileDateTime(time_t FileDateTime)
{
    BOOL bReturn = FALSE;

	FILETIME ft;
	DosDateTimeToFileTime( HIWORD(FileDateTime), LOWORD(FileDateTime), &ft );
	bReturn = SetFileTime( m_FileHandle, NULL, NULL, &ft );
    return(bReturn);
}


int CMBFTFile::GetLastErrorCode(void)
{
    struct XLAT
    {
	    unsigned Win32ErrorCode;
	    int      MBFTErrorCode;
    };

    static XLAT MBFTXlatTable[] =
    {
      {0,iMBFT_OK},
      {ERROR_FILE_NOT_FOUND,iMBFT_FILE_NOT_FOUND},
      {ERROR_PATH_NOT_FOUND,iMBFT_INVALID_PATH},
      {ERROR_TOO_MANY_OPEN_FILES,iMBFT_TOO_MANY_OPEN_FILES},
      {ERROR_ACCESS_DENIED,iMBFT_FILE_ACCESS_DENIED},
      {ERROR_SHARING_VIOLATION,iMBFT_FILE_SHARING_VIOLATION},
      {ERROR_HANDLE_DISK_FULL,iMBFT_INSUFFICIENT_DISK_SPACE}
    };

    int Index;
    int MBFTErrorCode = iMBFT_FILE_IO_ERROR;

    for(Index = 0;Index < (sizeof(MBFTXlatTable) / sizeof(MBFTXlatTable[0]));Index++)
    {
        if(MBFTXlatTable[Index].Win32ErrorCode == m_LastIOError)
        {
            MBFTErrorCode = MBFTXlatTable[Index].MBFTErrorCode;
            break;
        }
    }
    return(MBFTErrorCode);
}

LPCSTR CMBFTFile::GetTempDirectory(void)
{
    LPSTR lpszPointer = NULL;

    if( GetTempFileName( 0, "Junk", 0, m_szTempDirectory ) ) /*Localization OK*/
    {
		::DeleteFile( m_szTempDirectory );
        lpszPointer = SzFindLastCh(m_szTempDirectory,'\\');

        if(lpszPointer)
        {
            *lpszPointer  = '\0';
        }
    }

    if(!lpszPointer)
    {
        lstrcpy(m_szTempDirectory,"");
    }

    return((LPCSTR)m_szTempDirectory);
}


BOOL CMBFTFile::GetIsEOF()
{
	BOOL fReturn = FALSE;
	if( INVALID_HANDLE_VALUE != m_FileHandle )
	{
		DWORD dwCurrentPosition = SetFilePointer( m_FileHandle, 0, NULL, FILE_CURRENT );
		DWORD dwEndPosition		= SetFilePointer( m_FileHandle, 0, NULL, FILE_END );

		fReturn = dwCurrentPosition >= dwEndPosition;

		SetFilePointer( m_FileHandle, dwCurrentPosition, NULL, FILE_BEGIN );
	}
	return( fReturn );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ftdebug.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1994-1995, Microsoft Corporation
	All rights reserved

	ftDebug.cpp

  ---------------------------------------------------------------------- */

#include "mbftpch.h"

#ifdef DEBUG  /* THIS WHOLE FILE */


#define STRING_CASE(val)     case val: pcsz = #val; break

HDBGZONE ghZoneMbft = NULL;
static PTSTR _rgszZonesMbft[] = {
	TEXT("T.127"),
	TEXT("Send"),     // 0x0001  _TRACE_SEND    
	TEXT("Mcs"),      // 0x0002  _TRACE_MCS     
	TEXT("Receive"),  // 0x0004  _TRACE_RECEIVE 
	TEXT("State"),    // 0x0008  _TRACE_STATE   
	TEXT("Init"),     // 0x0010  _TRACE_INIT    
	TEXT("Gcc"),      // 0x0020  _TRACE_GCC     
	TEXT("Pdu"),      // 0x0040  _TRACE_PDU     
	TEXT("Delete"),   // 0x0080  _TRACE_DELETE  
	TEXT("Api"),      // 0x0100  _TRACE_API     
	TEXT("Compress"), // 0x0200  _TRACE_COMPRESS
	TEXT("Debug"),    // 0x0400  _TRACE_OTHER
};



///////////////////////////////////////////////////////////////////////////


VOID InitDebug(void)
{
	DBGINIT(&ghZoneMbft, _rgszZonesMbft);
	InitDebugModule(TEXT("FT"));
}


VOID DeInitDebugMbft(void)
{
	ExitDebugModule();
	DBGDEINIT(&ghZoneMbft);
}



void DbgMsgMbft(PCHAR pszFormat,...)    
{
	va_list arglist;

	va_start(arglist, pszFormat);
	DbgPrintf("mbft", pszFormat, arglist);
	va_end(arglist);
}


PCSTR FAR PASCAL GetMbftRcString(DWORD dwRc)
{
	PCSTR pcsz;
	static char sz[128] = {0};

	switch (dwRc)
		{
	default:
	{
		wsprintf(sz, "iMBFT err (%d)", dwRc);
		return sz;
	}
	STRING_CASE(iMBFT_OK);
	STRING_CASE(iMBFT_FIRST_ERROR);
	STRING_CASE(iMBFT_NOT_INITIALIZED);
	STRING_CASE(iMBFT_ALREADY_INITIALIZED);
	STRING_CASE(iMBFT_INVALID_SESSION_ID);
	STRING_CASE(iMBFT_INVALID_ATTACHMENT_HANDLE);
	STRING_CASE(iMBFT_NO_MORE_RECIPIENTS);
	STRING_CASE(iMBFT_NO_MORE_FILES);
	STRING_CASE(iMBFT_INVALID_EVENT_HANDLE);
	STRING_CASE(iMBFT_INVALID_FILE_HANDLE);
	STRING_CASE(iMBFT_INSUFFICIENT_DISK_SPACE);
	STRING_CASE(iMBFT_FILE_NOT_FOUND);
	STRING_CASE(iMBFT_FILE_IO_ERROR);
	STRING_CASE(iMBFT_MEMORY_ALLOCATION_ERROR);
	STRING_CASE(iMBFT_ASN1_ENCODING_ERROR);
	STRING_CASE(iMBFT_RECIPIENT_NOT_FOUND);
	STRING_CASE(iMBFT_SENDER_ABORTED);
	STRING_CASE(iMBFT_RECEIVER_ABORTED);
	STRING_CASE(iMBFT_RECEIVER_REJECTED);
	STRING_CASE(iMBFT_INVALID_PARAMETERS);
	STRING_CASE(iMBFT_COMPRESSION_ERROR);
	STRING_CASE(iMBFT_DECOMPRESSION_ERROR);
	STRING_CASE(iMBFT_INVALID_PATH);
	STRING_CASE(iMBFT_FILE_ACCESS_DENIED);
	STRING_CASE(iMBFT_FILE_HARD_IO_ERROR);
	STRING_CASE(iMBFT_FILE_SHARING_VIOLATION);
	STRING_CASE(iMBFT_DIRECTORY_FULL_ERROR);
	STRING_CASE(iMBFT_TOO_MANY_OPEN_FILES);
	STRING_CASE(iMBFT_OPERATION_IN_PROGRESS);
	STRING_CASE(iMBFT_INSUFFICIENT_PRIVILEGE);
	STRING_CASE(iMBFT_CONDUCTOR_ABORTED);
	STRING_CASE(iMBFT_PACKET_SIZE_ERROR);
	STRING_CASE(iMBFT_UNKNOWN_ERROR);
		}
	return pcsz;
}

LPCTSTR GetMcsErrorString(MCSError mcsError)
{
	LPCTSTR pcsz;
	static CHAR sz[MAX_PATH];

	switch (mcsError)
		{
	default:
		wsprintf(sz, "MCSError %d", mcsError);
		pcsz = sz;
		return pcsz;
	STRING_CASE(MCS_NO_ERROR);
	STRING_CASE(MCS_COMMAND_NOT_SUPPORTED);
	STRING_CASE(MCS_NOT_INITIALIZED);
	STRING_CASE(MCS_ALREADY_INITIALIZED);
	STRING_CASE(MCS_NO_TRANSPORT_STACKS);
	STRING_CASE(MCS_DOMAIN_ALREADY_EXISTS);
	STRING_CASE(MCS_NO_SUCH_DOMAIN);
	STRING_CASE(MCS_USER_NOT_ATTACHED);
	STRING_CASE(MCS_NO_SUCH_USER);
	STRING_CASE(MCS_TRANSMIT_BUFFER_FULL);
	STRING_CASE(MCS_NO_SUCH_CONNECTION);
	STRING_CASE(MCS_DOMAIN_NOT_HIERARCHICAL);
	STRING_CASE(MCS_INVALID_ADDRESS_PREFIX);
	STRING_CASE(MCS_ALLOCATION_FAILURE);
	STRING_CASE(MCS_INVALID_PARAMETER);
	STRING_CASE(MCS_CALLBACK_NOT_PROCESSED);
	STRING_CASE(MCS_DOMAIN_MERGING);
//	STRING_CASE(MCS_INVALID_TRANSPORT);
//	STRING_CASE(MCS_TRANSPORT_ALREADY_LOADED);
//	STRING_CASE(MCS_TRANSPORT_BUSY);
	STRING_CASE(MCS_TRANSPORT_NOT_READY);
	STRING_CASE(MCS_DOMAIN_PARAMETERS_UNACCEPTABLE);
		}
	return pcsz;
}



#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ftldr.h ===
#ifndef _FileTransfer_AppletLoader_H_
#define _FileTransfer_AppletLoader_H_

#include <iappldr.h>


class CFtLoader : public CRefCount, public IAppletLoader
{
public:

    CFtLoader(void);
    ~CFtLoader(void);

    // IAppletLoader methods
    STDMETHOD_(void,           ReleaseInterface)(void);
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(BOOL fNoUI);
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(DWORD dwTimeout);
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(BOOL fLocal, T120ConfID nConfID, LPSTR pszCmdLine);
	STDMETHOD_(APPLDR_RESULT,  AppletQuery)(APPLET_QUERY_ID eQueryId);
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(void);
};


#endif // _FileTransfer_AppletLoader_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ftldr.cpp ===
#include "mbftpch.h"
#include "ftldr.h"
#include "ftui.h"
// #include "SDKInternal.h"

CFtLoader  *g_pFtLoader = NULL;
BOOL        g_fNoUI = FALSE;

extern void ReadSettingsFromRegistry(void);
extern void LoadDefaultStrings(void);
extern DWORD __stdcall FTWorkThreadProc(LPVOID lpv);
extern HANDLE g_hWorkThread;
extern BOOL g_fShutdownByT120;

T120Error WINAPI CreateAppletLoaderInterface
(
    IAppletLoader     **ppOutIntf
)
{
    if (NULL != ppOutIntf)
    {
        *ppOutIntf = NULL;
        if (NULL == g_pFtLoader)
        {
            ::ReadSettingsFromRegistry();
            ::LoadDefaultStrings();
            if (g_fSendAllowed || g_fRecvAllowed)
            {
                DBG_SAVE_FILE_LINE
                *ppOutIntf = (IAppletLoader *) new CFtLoader();
                return ((NULL != *ppOutIntf) ? T120_NO_ERROR : T120_ALLOCATION_FAILURE);
            }
            return T120_POLICY_PROHIBIT;
        }
        return T120_ALREADY_INITIALIZED;
    }
    return T120_INVALID_PARAMETER;
}



//
// FT Applet Loader
//

CFtLoader::CFtLoader(void)
:
    CRefCount(MAKE_STAMP_ID('F','T','L','D'))
{
    ASSERT(NULL == g_pFtLoader);

    g_pFtLoader = this;
}


CFtLoader::~CFtLoader(void)
{
    ASSERT(this == g_pFtLoader);

    g_pFtLoader = NULL;
}


//
// Create the work thread and wait for its being started.
//
APPLDR_RESULT CFtLoader::AppletStartup
(
    BOOL        fNoUI
)
{

    APPLDR_RESULT eRet = APPLDR_FAIL;
    if (0 == g_dwWorkThreadID)
    {
        g_fNoUI = fNoUI;

        ASSERT(NULL == g_pFileXferApplet);
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            g_hWorkThread = ::CreateThread(NULL, 0, FTWorkThreadProc, hSync, 0, &g_dwWorkThreadID);
            if (NULL != g_hWorkThread)
            {
                DWORD dwRet = ::WaitForSingleObject(hSync, FT_STARTUP_TIMEOUT);
                // ASSERT(NULL != g_pFileXferApplet);
                eRet = APPLDR_NO_ERROR;
            }
            ::CloseHandle(hSync);
        }
    }

	TCHAR szRecvFolder[MAX_PATH];
    ::GetRecvFolder(NULL, szRecvFolder);

    return eRet;
}



APPLDR_RESULT CFtLoader::AppletCleanup
(
    DWORD           dwTimeout
)
{
	::EnterCriticalSection(&g_csWorkThread);
    if (NULL != g_pFileXferApplet)
    {
        if (! g_pFileXferApplet->QueryShutdown(TRUE))
        {
			::LeaveCriticalSection(&g_csWorkThread);
            return APPLDR_CANCEL_EXIT;
        }
    }
	::LeaveCriticalSection(&g_csWorkThread);

    //
    // shut down the worker thread now
    //
    g_fShutdownByT120 = TRUE;

    T120_AppletStatus(APPLET_ID_FT, APPLET_CLOSING);

    // shuting down the work thread
    ASSERT(::GetCurrentThreadId() != g_dwWorkThreadID);

    if (NULL != g_pFileXferApplet)
    {   // Shutdown MBFTInterface ourself to make things simpler
        MSG msg;
        MBFTEngine *pEngine = g_pFileXferApplet->FindEngineWithIntf();
        if (pEngine)
        {
            DBG_SAVE_FILE_LINE
            InitUnInitNotifyMsg *pMsg = new InitUnInitNotifyMsg(EnumInvoluntaryUnInit);
            pEngine->GetInterfacePointer()->HandleInitUninitNotification(pMsg);
            delete pMsg;
        }
    }

    // shut down by T.120
	::EnterCriticalSection(&g_csWorkThread);

    // remember the event such that the work thread can access it
    if (NULL != g_pFileXferApplet)
    {
        CAppletWindow *pWindow;
        CWindowList *pList = g_pFileXferApplet->GetWindowList();
		pList->Reset();
		while (NULL != (pWindow = pList->Iterate()))
		{
			BOOL fRet = ::PostMessage(pWindow->GetHwnd(), WM_CLOSE, 0, 0);
			ASSERT(fRet);
		}
    } // if applet ptr

    ::LeaveCriticalSection(&g_csWorkThread);

    // wait for the worker thread's going down
    DWORD dwRet = ::WaitForSingleObject(g_hWorkThread, dwTimeout);

    return APPLDR_NO_ERROR;
}


APPLDR_RESULT CFtLoader::AppletQuery(APPLET_QUERY_ID eQueryId)
{
    ::EnterCriticalSection(&g_csWorkThread);
    if (NULL != g_pFileXferApplet)
    {
        switch (eQueryId)
        {
        case APPLET_QUERY_SHUTDOWN:
			// Don't really shuts down
        if (! g_pFileXferApplet->QueryShutdown(FALSE))  
        {
            ::LeaveCriticalSection(&g_csWorkThread);
            return APPLDR_CANCEL_EXIT;
        }
        break;
        }
    }
    ::LeaveCriticalSection(&g_csWorkThread);

    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CFtLoader::OnNM2xNodeJoin(void)
{
    // Do nothing here
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CFtLoader::AppletInvoke
(
		BOOL            fLocal,
		T120ConfID      nConfID,
	    LPSTR           pszCmdLine
)
{
	// fLocal == TRUE  ==> local invoke
	if (fLocal && g_pFileXferApplet)  // Only bring UI to front for local invoke
	{
		::PostMessage(g_pFileXferApplet->GetHiddenWnd(), WM_BRING_TO_FRONT, 0, 0);
	} 
    return APPLDR_NO_ERROR;
}


void CFtLoader::ReleaseInterface(void)
{
    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ftres.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Icons
//

#define IDI_FILE_TRANSFER               100
#define IDI_INCALL                      101
#define IDI_NOT_INCALL                  102

/////////////////////////////////////////////////////////////////////////////
//
// ACCELERATOR
//

#define RECVDLGACCELTABLE               130
#define LISTVIEWACCELTABLE              131


/////////////////////////////////////////////////////////////////////////////
//
// AVI
//

#define IDA_RECVDLG_ANIMATION           150
#define IDA_RECVDLG_DONE                151

/////////////////////////////////////////////////////////////////////////////
//
//  Bitmap
//

#define  IDB_ADDFILES                   180
#define  IDB_REMOVEFILES                181
#define  IDB_SENDFILE                   182
#define  IDB_STOPSEND                   183
#define  IDB_FOLDER                     184



/////////////////////////////////////////////////////////////////////////////
//
// Menus
//

#define IDR_MENU_FT                     200


/////////////////////////////////////////////////////////////////////////////
//
// Dialogs
//

#define IDD_ABOUTBOX                    300
#define IDC_ABOUT_VERSION               301

#define IDC_FILEXFER_PATH               305


#define IDD_RECVDLG                     310
#define IDC_RECVDLG_ANIMATE             311
#define IDC_RECVDLG_PROGRESS            312
#define IDE_RECVDLG_TIME                313
#define IDE_RECVDLG_RECFILE             314
#define IDE_RECVDLG_RECDIR              315
#define IDE_RECVDLG_SENDER              316
#define IDE_RECVDLG_RECBYTES            317
#define IDC_RECVDLG_MSG                 318

#define IDM_RECVDLG_ACCEPT              320
#define IDM_RECVDLG_OPEN                321
#define IDM_RECVDLG_DELETE              322

#define IDD_MSGBOX2                     330
#define IDE_MSGBOX2_TEXT                331


/////////////////////////////////////////////////////////////////////////////
//
// Controls
//
#define IDC_TOOL_BAR                    401
#define IDC_LIST_VIEW                   402
#define IDC_STATUS_BAR                  403
#define IDC_PROGRESS_BAR                404


/////////////////////////////////////////////////////////////////////////////
//
// Commands
//

#define IDM_EXIT                        1000

#define IDM_ADD_FILES                   1001
#define IDM_REMOVE_FILES                1002
#define IDM_SEND_ALL                    1003
#define IDM_SEND_ONE					1004
#define IDM_STOP_SENDING                1005
#define IDM_OPEN_RECV_FOLDER            1006
#define IDM_CHANGE_FOLDER               1007

#define IDM_HELP                        1200
#define IDM_ABOUT                       1201

#define IDM_RECEIVER                    1210


/////////////////////////////////////////////////////////////////////////////
//
// Strings
//
#define IDS_LANGNAME                    1997
#define IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION                    1998
#define IDS_MSFT_IN_CALL_WINDOW_CAPTION                        1999

#define NUM_LIST_VIEW_COLUMNS           4
#define IDS_LV_FILE_NAME                2000
#define IDS_LV_FILE_SIZE                2001
#define IDS_LV_FILE_STATUS              2002
#define IDS_LV_FILE_MODIFIED			2003
#define IDS_LV_FILE_SENT                2010
#define IDS_LV_FILE_SENDING             2011
#define IDS_LV_FILE_CANCELED            2012
#define IDS_LV_FILE_FAILED              2013

#define IDS_FILEDLG_TITLE               2020
#define IDS_FILEDLG_FILTER              2021
#define IDS_FILEDLG_SEND                2022

#define IDS_COPY_OF                     2031
#define IDS_COPY_N_OF                   2032
#define IDS_INVALID_NAME                2033

#define IDS_STBAR_NOT_IN_CALL           2040
#define IDS_STBAR_NOT_TRANSFERING       2041
#define IDS_STBAR_SENDING_XYZ           2042
#define IDS_STBAR_IN_CONFERENCE         2043

#define IDS_BROWSETITLE                 2045

#define IDS_MENU_FILE                   2048
#define IDS_MENU_HELP                   2049
#define IDS_MENU_ADD_FILES              2050
#define IDS_MENU_REMOVE_FILES           2051
#define IDS_MENU_SEND_ALL               2052
#define IDS_MENU_SEND_ONE				2053
#define IDS_MENU_STOP_SENDING           2054
#define IDS_MENU_OPEN_RECV_FOLDER       2055
#define IDS_MENU_CHANGE_FOLDER          2056
#define IDS_MENU_EXIT                   2057
#define IDS_RECEIVER_TT                 2058
 
#define IDS_MSGBOX2_CANCELED            2060
#define IDS_MSGBOX2_SEND_FAILED         2061
#define IDS_MSGBOX2_SEND_SUCCESS        2062
#define IDS_MSGBOX2_MULT_CANCEL         2063
#define IDS_INVALID_FILENAME            2064
#define IDS_MSGBOX2_INVALID_DIRECTORY   2065
#define IDS_MSGBOX2_DIRECTORY_FULL      2066
#define IDS_MSGBOX2_FILE_CREATE_FAILED  2067

#define IDS_MSGBOX_NO_CONF              2070
#define IDS_MSGBOX_BAD_RECDIR           2071
#define IDS_MSGBOX_POL_PREVENT          2072
#define IDS_MSGBOX_SEND_BIG_FILE        2073
#define IDS_QUERY_SEND_SHUTDOWN         2074
#define IDS_QUERY_SEND_HANGUP           2075
#define IDS_QUERY_RECVING_SHUTDOWN      2076
#define IDS_QUERY_RECVING_HANGUP        2077
#define IDS_QUERY_RECV_SHUTDOWN         2078
#define IDS_QUERY_RECV_HANGUP           2079

#define IDS_RECDIR_DEFAULT              2080


#define IDS_ALL_RECEIVER                2109
#define IDS_RECVDLG_CLOSE               2100
#define IDS_RECVDLG_FAILED              2101
#define IDS_RECVDLG_CANCEL              2102
#define IDS_RECVDLG_TITLE               2103
#define IDS_RECVDLG_RECBYTES            2104
#define IDS_RECVDLG_START               2105
#define IDS_RECVDLG_SECONDS             2106
#define IDS_RECVDLG_MINUTES             2107
#define IDS_RECVDLG_COMPLETE            2108

#define IDS_RECVDLG_DIRNOEXIST          2110
#define IDS_RECVDLG_DIRTOOSMALL         2111
#define IDS_RECVDLG_SENDER_CANCEL       2112

#define IDS_FILERECV_FILEREPLACE        2120
#define IDS_RECVDLG_FILESAVE            2121
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ftui.cpp ===
// File: ftui.h
#include "mbftpch.h"
#include <commctrl.h>
#include <regentry.h>
#include "ftui.h"
#include "version.h"
#include <iappldr.h>
#include <nmhelp.h>

static ULONG s_cMsgBox2Dlg = 0; // for alignment
static ULONG s_cRecvDlg = 0; // for alignment

TCHAR s_szMSFT[64];
static TCHAR s_szScratchText[MAX_PATH*2];
static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

#define MAX_FILE_NAME_LENGTH    30

LRESULT CALLBACK FtMainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RecvDlgProc(HWND, UINT, WPARAM, LPARAM);
LPTSTR PathNameToFileName(LPTSTR pszPathName);
HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr);
BOOL MsgBox2(CAppletWindow *pWindow, LPTSTR pszText);

void EnsureTrailingSlash(LPTSTR);
int MyLoadString(UINT idStr);
int MyLoadString(UINT idStr, LPTSTR pszDstStr);
int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement);
int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement1, LPTSTR pszElement2);
__inline int MyLoadString(UINT idStr, LPTSTR pszDstStr, UINT_PTR nElement)
                { return MyLoadString(idStr, pszDstStr, (LPTSTR) nElement); }
__inline int MyLoadString(UINT idStr, LPTSTR pszDstStr, UINT_PTR nElement1, UINT_PTR nElement2)
                { return MyLoadString(idStr, pszDstStr, (LPTSTR) nElement1, (LPTSTR) nElement2); }
int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement1, UINT_PTR nElement2)
                { return MyLoadString(idStr, pszDstStr, pszElement1, (LPTSTR) nElement2); }
__inline int MyLoadString(UINT idStr, LPTSTR pszDstStr, UINT_PTR nElement1, LPTSTR pszElement2)
                { return MyLoadString(idStr, pszDstStr, (LPTSTR) nElement1, pszElement2); }

#define count_of(array)    (sizeof(array) / sizeof(array[0]))

void OnChangeFolder(void);
BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle);
extern BOOL g_fShutdownByT120;


void OPT_GetFTWndPosition(RECT *pRect)
{
	int   iLeft, iTop, iRight, iBottom;
	RegEntry  reWnd( FILEXFER_KEY, HKEY_CURRENT_USER);

	iLeft   = reWnd.GetNumber(REGVAL_WINDOW_XPOS, 0);
	iTop    = reWnd.GetNumber(REGVAL_WINDOW_YPOS, 0);
	iRight  = reWnd.GetNumber(REGVAL_WINDOW_WIDTH, 0) + iLeft;
	iBottom = reWnd.GetNumber(REGVAL_WINDOW_HEIGHT, 0) + iTop;

	// If it was empty, use the new rect
	if (!(iBottom || iTop || iLeft || iRight))
	{
		return;
	}

   // Make sure that the window rectangle is (at least partially) on
   // screen, and not too large.  First get the screen size
   int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
   int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);
	// Check the window size
   if ((iRight - iLeft) > screenWidth)
   {
       iRight = iLeft + screenWidth;
   }

   if ((iBottom - iTop) > screenHeight)
   {
       iTop = screenHeight;
   }

   // Check the window position
   if (iLeft >= screenWidth)
   {
       // Off screen to the right - keep the width the same
       iLeft  = screenWidth - (iRight - iLeft);
       iRight = screenWidth;
   }

   if (iRight < 0)
   {
       // Off screen to the left - keep the width the same
       iRight = iRight - iLeft;
       iLeft  = 0;
   }

   if (iTop >= screenHeight)
   {
       // Off screen to the bottom - keep the height the same
       iTop    = screenHeight - (iBottom - iTop);
       iBottom = screenHeight;
   }

   if (iBottom < 0)
   {
       // Off screen to the top - keep the height the same
       iBottom = (iBottom - iTop);
       iTop    = 0;
   }

   pRect->left = iLeft;
   pRect->top = iTop;
   pRect->right = iRight - iLeft;
   pRect->bottom = iBottom - iTop;	
}


CAppletWindow::CAppletWindow(BOOL fNoUI, HRESULT *pHr)
:
    CRefCount(MAKE_STAMP_ID('F','T','U','I')),
    m_hwndMainUI(NULL),
	m_pToolbar(NULL),
    m_hwndListView(NULL),
    m_hwndStatusBar(NULL),
    m_pEngine(NULL),
    m_fInFileOpenDialog(FALSE),
    m_pCurrSendFileInfo(NULL),
    m_nCurrSendEventHandle(0),
	m_hIconInCall(NULL),
	m_hIconNotInCall(NULL)
{	
	m_UIMode = fNoUI ? FTUIMODE_NOUI : FTUIMODE_UIHIDDEN;
	::GetCurrentDirectory(MAX_PATH, m_szDefaultDir);

    *pHr = E_FAIL; // failure, at default

	// create window class name
	::wsprintf(&m_szFtMainWndClassName[0], TEXT("FTMainWnd%0X_%0X"), ::GetCurrentProcessId(), ::GetTickCount());
	ASSERT(::lstrlenA(&m_szFtMainWndClassName[0]) < sizeof(m_szFtMainWndClassName));

    // register window class first
    WNDCLASS wc;
    ::ZeroMemory(&wc, sizeof(wc));
    //wc.style			= 0;
    wc.lpfnWndProc      = FtMainWndProc;
    // wc.cbClsExtra    = 0;
    // wc.cbWndExtra    = 0;
    wc.hInstance        = g_hDllInst;
    wc.hIcon            = ::LoadIcon(g_hDllInst, MAKEINTRESOURCE(IDI_FILE_TRANSFER));
    // wc.hbrBackground = NULL;
    // wc.hCursor       = NULL;
    wc.lpszMenuName     = MAKEINTRESOURCE(IDR_MENU_FT);
    wc.lpszClassName    = m_szFtMainWndClassName;
    if (::RegisterClass(&wc))
    {
		::MyLoadString(IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION);
        m_hwndMainUI = ::CreateWindow(
                    m_szFtMainWndClassName,
                    s_szScratchText,
                    WS_OVERLAPPEDWINDOW,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL,   // no parent window
                    NULL,   // use class' menu
                    g_hDllInst,
                    (LPVOID) this);  // this window is for this object
        if (NULL != m_hwndMainUI)
        {
            ASSERT(NULL != g_pFileXferApplet);
            g_pFileXferApplet->RegisterWindow(this);

            // success
            *pHr = S_OK;
        }
    }
	m_hAccel = ::LoadAccelerators(g_hDllInst, MAKEINTRESOURCE(RECVDLGACCELTABLE));
	m_hLVAccel = ::LoadAccelerators(g_hDllInst, MAKEINTRESOURCE(LISTVIEWACCELTABLE));
}


CAppletWindow::~CAppletWindow(void)
{
    ASSERT(NULL == m_hwndMainUI);

    ::UnregisterClass(m_szFtMainWndClassName, g_hDllInst);

    ClearSendInfo(FALSE);
    ClearRecvInfo();

	if (m_hIconInCall)
		::DestroyIcon(m_hIconInCall);
	if (m_hIconNotInCall)
		::DestroyIcon(m_hIconNotInCall);

    ASSERT(NULL == m_pEngine);
}


BOOL CAppletWindow::FilterMessage(MSG *pMsg)
{
	CRecvDlg *pRecvDlg;
	HWND      hwndError;
	HWND		hwndForeground = ::GetForegroundWindow();

	m_RecvDlgList.Reset();
	while (NULL != (pRecvDlg = m_RecvDlgList.Iterate()))
	{
		if (::IsDialogMessage(pRecvDlg->GetHwnd(), pMsg))
		{
			return TRUE;
		}
	}
	if (hwndForeground == m_hwndMainUI)
	{
		BOOL fRet = ::TranslateAccelerator(m_hwndMainUI, m_hLVAccel, pMsg);
		return fRet;
	}

	m_ErrorDlgList.Reset();
	while (NULL != (hwndError = m_ErrorDlgList.Iterate()))
	{
		if (::IsDialogMessage(hwndError, pMsg))
		{
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CAppletWindow::QueryShutdown(BOOL fShutdown)
{
	if (m_UIMode != FTUIMODE_NOUI)
	{
		int id = 0;
		if (m_nCurrSendEventHandle)
		{
			id = (fShutdown)?IDS_QUERY_SEND_SHUTDOWN:IDS_QUERY_SEND_HANGUP;
		}
		else if (IsReceiving())
		{
			id = (fShutdown)?IDS_QUERY_RECVING_SHUTDOWN:IDS_QUERY_RECVING_HANGUP;
		}

		if (id)
		{
			// could be in any thread
			TCHAR szText[MAX_PATH];
			if (::MyLoadString(id, szText))
			{
				if (IDNO == ::MessageBox(NULL, szText, s_szMSFT, MB_TASKMODAL | MB_YESNO | MB_ICONQUESTION))
				{
					return FALSE;
				}
			}
		}
	}

	if (m_nCurrSendEventHandle)
    {
		OnStopSending();
	}
	if (IsReceiving())
	{
		CRecvDlg *pRecvDlg = NULL;
		m_RecvDlgList.Reset();
		while (NULL != (pRecvDlg = m_RecvDlgList.Iterate()))
		{
            DBG_SAVE_FILE_LINE
			GetEngine()->SafePostMessage(
                   new FileTransferControlMsg(
                                        pRecvDlg->GetEventHandle(),
                                        pRecvDlg->GetFileHandle(),
                                        NULL,
                                        NULL,
                                        FileTransferControlMsg::EnumAbortFile));
		}
	}
    return TRUE;
}


void CAppletWindow::RegisterEngine(MBFTEngine *pEngine)
{
    ASSERT(NULL == m_pEngine);
    pEngine->AddRef();
    m_pEngine = pEngine;
    UpdateUI();
}


void CAppletWindow::UnregisterEngine(void)
{
    if (NULL != m_pEngine)
    {
        m_pEngine->Release();
        m_pEngine = NULL;
        ClearSendInfo(TRUE);
        ClearRecvInfo();
    }
	if (UIHidden())
	{   // exit
		::PostMessage(m_hwndMainUI, WM_CLOSE, 0, 0);
	}
	else
	{
		UpdateUI();  // don't quit
	}
}


void CAppletWindow::RegisterRecvDlg(CRecvDlg *pDlg)
{
    m_RecvDlgList.Prepend(pDlg);
}


void CAppletWindow::UnregisterRecvDlg(CRecvDlg *pDlg)
{
    m_RecvDlgList.Remove(pDlg);
	FocusNextRecvDlg();
}


BOOL CAppletWindow::IsReceiving(void)
{
	BOOL fRet = FALSE;
	CRecvDlg *pDlg;
	CUiRecvFileInfo *pRecvFile;
	m_RecvDlgList.Reset();
    while (NULL != (pDlg = m_RecvDlgList.Iterate()))
    {
		pRecvFile = pDlg->GetRecvFileInfo();
		if (pRecvFile && (pRecvFile->GetTotalRecvSize() < pRecvFile->GetSize()))
        {
			fRet = TRUE;
            break;
        }
    }
    return fRet;
}

CRecvDlg * CAppletWindow::FindDlgByHandles(MBFTEVENTHANDLE nEventHandle, MBFTFILEHANDLE nFileHandle)
{
    CRecvDlg *pDlg;
    m_RecvDlgList.Reset();
    while (NULL != (pDlg = m_RecvDlgList.Iterate()))
    {
        if (nEventHandle == pDlg->GetEventHandle() &&
            nFileHandle == pDlg->GetFileHandle())
        {
            break;
        }
    }
    return pDlg;
}


/////////////////////////////////////////////////////////////////
//
//  WM_CREATE
//

LRESULT OnCreate(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CREATESTRUCT *p = (CREATESTRUCT *) lParam;
    CAppletWindow *pWindow = (CAppletWindow *) p->lpCreateParams;

    ASSERT(NULL != pWindow);
    ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) p->lpCreateParams);

    pWindow->SetHwnd(hwnd);

    ::InitCommonControls();

    pWindow->CreateToolBar();
    pWindow->CreateStatusBar();
    pWindow->CreateListView();

    ::DragAcceptFiles(hwnd, g_fSendAllowed);

    // resize the window
    MINMAXINFO mmi;
    ::ZeroMemory(&mmi, sizeof(mmi));
    pWindow->OnGetMinMaxInfo(&mmi);
    RECT rcUI;

    ::GetWindowRect(pWindow->GetHwnd(), &rcUI);
	rcUI.right  = mmi.ptMinTrackSize.x;
	rcUI.bottom = mmi.ptMinTrackSize.y + 30;
	OPT_GetFTWndPosition(&rcUI);

    ::MoveWindow(pWindow->GetHwnd(), rcUI.left, rcUI.top,
                 rcUI.right, rcUI.bottom, TRUE);

    pWindow->UpdateUI();

#if defined(TEST_PLUGABLE) && defined(_DEBUG)
    ::OnPluggableBegin(hwnd);
#endif
    return 0;
}


enum
{
    TB_IDX_ADD_FILES = 0,
    TB_IDX_REMOVE_FILES,
    TB_IDX_BREAK_1,
    TB_IDX_IDM_SEND_ALL,
	TB_IDX_IDM_SEND_ONE,
    TB_IDX_IDM_STOP_SENDING,
    TB_IDX_BREAK_2,
    TB_IDX_IDM_OPEN_RECV_FOLDER,
	TB_IDX_IDM_CHANGE_FOLDER,
    TB_IDX_BREAK_3,
    TB_IDX_IDM_HELP,
};


static Buttons buttons [] =
{
	{IDB_ADDFILES,		CBitmapButton::Disabled+1,	1,	IDM_ADD_FILES,          (LPCSTR)IDS_MENU_ADD_FILES,},
	{IDB_REMOVEFILES,	CBitmapButton::Disabled+1,	1,	IDM_REMOVE_FILES,       (LPCSTR)IDS_MENU_REMOVE_FILES,},
	{0,					0,							0,	0,						0,},
	{IDB_SENDFILE,		CBitmapButton::Disabled+1,	1,	IDM_SEND_ALL,           (LPCSTR)IDS_MENU_SEND_ALL,},
	{IDB_STOPSEND,		CBitmapButton::Disabled+1,	1,	IDM_STOP_SENDING,       (LPCSTR)IDS_MENU_STOP_SENDING,},
	{0,					0,							0,	0,						0,},
	{IDB_FOLDER,		CBitmapButton::Disabled+1,	1,	IDM_OPEN_RECV_FOLDER,   (LPCSTR)IDS_MENU_OPEN_RECV_FOLDER,},
	{0,					0,							0,	0,						0},
};


BOOL CAppletWindow::CreateToolBar(void)
{
    DBG_SAVE_FILE_LINE
	m_pToolbar = new CComboToolbar();
	if (m_pToolbar)
	{
		m_pToolbar->Create(m_hwndMainUI, &buttons[0], count_of(buttons), this);
		m_pToolbar->Release();
		return TRUE;
	}
    return FALSE;
}


BOOL CAppletWindow::CreateStatusBar(void)
{
    m_hwndStatusBar = ::CreateWindowEx(0,
                        STATUSCLASSNAME, // status bar class
                        TEXT(""), // no default text
                        WS_CHILD | WS_VISIBLE | SBS_SIZEGRIP,
                        0, 0, 0, 0,
                        m_hwndMainUI,
                        (HMENU) IDC_STATUS_BAR,
                        g_hDllInst,
                        NULL);
    ASSERT(NULL != m_hwndStatusBar);
    if (NULL != m_hwndStatusBar)
    {	
		// Load Call Icons
		m_hIconInCall = (HICON) ::LoadImage(g_hDllInst,
							MAKEINTRESOURCE(IDI_INCALL),
							IMAGE_ICON,
							::GetSystemMetrics(SM_CXSMICON),
							::GetSystemMetrics(SM_CYSMICON),
							LR_DEFAULTCOLOR);
		m_hIconNotInCall = (HICON) ::LoadImage(g_hDllInst,
							MAKEINTRESOURCE(IDI_NOT_INCALL),
							IMAGE_ICON,
							::GetSystemMetrics(SM_CXSMICON),
							::GetSystemMetrics(SM_CYSMICON),
							LR_DEFAULTCOLOR);
		if (CreateProgressBar())
		{
			return TRUE;
		}
    }
    return FALSE;
}


BOOL CAppletWindow::CreateProgressBar(void)
{
	RECT  rcl;

	GetClientRect(m_hwndStatusBar, &rcl);
	m_hwndProgressBar = ::CreateWindowEx(0, PROGRESS_CLASS, TEXT(""),
				WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
				rcl.right/2 + 2, 2, rcl.right - rcl.right/2 - 40, rcl.bottom - 8,
				m_hwndStatusBar,  (HMENU)IDC_PROGRESS_BAR,
				g_hDllInst, NULL);
	
	if (m_hwndProgressBar)
	{
		::SendMessage(m_hwndProgressBar, PBM_SETRANGE, 0L, MAKELONG(0, 100));
		return TRUE;
	}
	return FALSE;
}


BOOL CAppletWindow::CreateListView(void)
{
    // get the size and position of the main window
    RECT rcWindow, rcToolBar, rcStatusBar;
	SIZE	szToolBar;
    ::GetClientRect(m_hwndMainUI, &rcWindow);
	m_pToolbar->GetDesiredSize(&szToolBar);
    ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);

    ULONG x = 0;
    ULONG y = szToolBar.cy - 1;
    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = rcWindow.bottom - rcWindow.top - y - (rcStatusBar.bottom - rcStatusBar.top) + 1;

    // create the list view window
    m_hwndListView = ::CreateWindowEx(WS_EX_CLIENTEDGE,  // sunken look
                        WC_LISTVIEW , // list view class
                        TEXT(""), // no default text
                        WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT |
                        LVS_AUTOARRANGE | WS_CLIPCHILDREN | LVS_SHOWSELALWAYS,
                        x, y, cx, cy,
                        m_hwndMainUI,
                        (HMENU) IDC_LIST_VIEW,
                        g_hDllInst,
                        NULL);
    ASSERT(NULL != m_hwndListView);
    if (NULL != m_hwndListView)
    {
        // set extended list view styles
        DWORD dwExtStyle = ListView_GetExtendedListViewStyle(m_hwndListView);
        dwExtStyle |= (LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES | LVS_EX_FULLROWSELECT);
        ListView_SetExtendedListViewStyle(m_hwndListView, dwExtStyle);

        // enable window only if we can send files
        ::EnableWindow(m_hwndListView, g_fSendAllowed);

        // set up the columns
        ULONG i;
        LVCOLUMN  lvc;
        LVITEM lvi;
        TCHAR szText[64];
		int iColumnSize[NUM_LIST_VIEW_COLUMNS] = {150, 80, 70, 130}; // listview column size

        // initialize the common part of the columns
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT; // left-aligned column
        lvc.pszText = szText;

        // initialize columns one by one
        for (i = 0; i < NUM_LIST_VIEW_COLUMNS; i++)
        {
            lvc.iSubItem = i;
            ::LoadString(g_hDllInst, IDS_LV_FILE_NAME + i, szText, count_of(szText));
			lvc.cx = iColumnSize[i];
            int iRet = ListView_InsertColumn(m_hwndListView, lvc.iSubItem, &lvc);
            ASSERT(-1 != iRet);
        }
        return TRUE;
    }
    return FALSE;
}



BOOL  CAppletWindow::DrawItem(LPDRAWITEMSTRUCT pdis)
{
    ASSERT(pdis);
    if (NULL != (pdis->itemData))
    {
        int nWidth = pdis->rcItem.right - pdis->rcItem.left;
        int nHeight = pdis->rcItem.bottom - pdis->rcItem.top;
        int nLeft = pdis->rcItem.left;
        int nTop = pdis->rcItem.top;
        int xSmIcon = ::GetSystemMetrics(SM_CXSMICON);
        int ySmIcon = ::GetSystemMetrics(SM_CYSMICON);

        if (nWidth > xSmIcon)
        {
            nLeft += (nWidth - xSmIcon) / 2 - 5;
            nWidth = xSmIcon;
        }
        if (nHeight > ySmIcon)
        {
            nTop += (nHeight - ySmIcon) / 2;
            nHeight = ySmIcon;
        }

        ::DrawIconEx(   pdis->hDC,
                        nLeft,
                        nTop,
                        (HICON) (pdis->itemData),
                        nWidth,
                        nHeight,
                        0,
                        NULL,
                        DI_NORMAL);
    }

    return TRUE;
}


void CAppletWindow::OnCommand(WORD  wId, HWND hwndCtl, WORD codeNotify)
{
	switch (wId)
	{
	case IDM_ADD_FILES:
		OnAddFiles();
		UpdateUI();
		break;

	case IDM_REMOVE_FILES:
		OnRemoveFiles();
		UpdateUI();
		break;

	case IDM_SEND_ALL:
		s_cMsgBox2Dlg = 0;
		SetSendMode(TRUE);
		OnSendAll();
		UpdateUI();
		break;

	case IDM_SEND_ONE:
		s_cMsgBox2Dlg = 0;
		SetSendMode(FALSE);
		OnSendOne();
		UpdateUI();
		break;

	case IDM_STOP_SENDING:
		OnStopSending();
		UpdateUI();
		break;

	case IDM_OPEN_RECV_FOLDER:
		OnOpenRecvFolder();
		break;

	case IDM_CHANGE_FOLDER:
		OnChangeFolder();
		break;

	case IDM_EXIT:
		OnExit();
		break;

	case IDM_HELP:
		OnHelp();
		break;

	case IDM_ABOUT:
		OnAbout();
		break;

	default:
		WARNING_OUT(("FT::OnCommand: unknown command ID=%u", (UINT) wId));
		break;
	}
	return;
}



/////////////////////////////////////////////////////////////////
//
//  WM_COMMAND
//

LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (NULL != pWindow)
	{
		WORD    wNotifyCode = GET_WM_COMMAND_CMD(wParam, lParam); // notification code
		WORD    wID = GET_WM_COMMAND_ID(wParam, lParam); // item, control, or accelerator identifier
		HWND    hwndCtl = (HWND) lParam; // handle of control

		pWindow->OnCommand(wID, hwndCtl, wNotifyCode);
		return 0;
	}
	else
	{
		WARNING_OUT((" CAppletWindow::OnCommand--Received unhandled window message.\n"));
	}
	return (DefWindowProc(hwnd, WM_COMMAND, wParam, lParam));
}


//
// OnAddFiles
//

UINT_PTR APIENTRY SendFileDlgHookProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (WM_INITDIALOG == uMsg)
    {
        hdlg = ::GetParent(hdlg);  // Real dialog is this window's parent

        if (::MyLoadString(IDS_FILEDLG_SEND))
        {
            ::SetDlgItemText(hdlg, IDOK, s_szScratchText);
        }
    }
    return 0;
}

void CAppletWindow::OnAddFiles(void)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szFilter[MAX_PATH];
    TCHAR szDirSav[MAX_PATH];
    TCHAR szSendDir[MAX_PATH];

    // Load dialog title and filter strings
    if (::MyLoadString(IDS_FILEDLG_TITLE, szTitle) &&
        ::MyLoadString(IDS_FILEDLG_FILTER, szFilter))
    {
        // replace '|' to '\0'
        LPTSTR pszFltr = szFilter;
        while (TEXT('\0') != *pszFltr)
        {
            if (TEXT('|') == *pszFltr)
            {
                *pszFltr = TEXT('\0');
                pszFltr++; // cannot use CharNext
            }
            else
            {
                pszFltr = ::CharNext(pszFltr);
            }
        }

        // only allow one "Select a file to send" dialog
        if (! m_fInFileOpenDialog)
        {
            m_fInFileOpenDialog = TRUE;

            // Allocate a really large buffer to hold the file list
            ULONG cbBufSize = 8192;
            DBG_SAVE_FILE_LINE
            LPTSTR pszBuffer = new TCHAR[cbBufSize];
            if (NULL != pszBuffer)
            {
                *pszBuffer = TEXT('\0'); // start with null string

                OPENFILENAME ofn;
                ::ZeroMemory(&ofn, sizeof(ofn));
                ofn.lStructSize   = sizeof(ofn);
                ofn.hwndOwner     = m_hwndMainUI;
                ofn.hInstance     = g_hDllInst;
                ofn.lpstrFilter   = &szFilter[0];
                ofn.nFilterIndex  = 1L; // FUTURE: remember filter preference
                ofn.lpstrFile     = pszBuffer;
                ofn.nMaxFile      = cbBufSize - 1; // Number of TCHAR in pszFiles (not including NULL)
                ofn.lpstrTitle    = &szTitle[0];
                ofn.lpstrInitialDir = m_szDefaultDir;
                ofn.lpfnHook      = SendFileDlgHookProc;

                ofn.Flags = OFN_ALLOWMULTISELECT | OFN_ENABLEHOOK | // OFN_HIDEREADONLY |
                            OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;

                // remember current directory
				::ZeroMemory(szSendDir, sizeof(szSendDir));
                ::GetCurrentDirectory(count_of(szDirSav), szDirSav);
                ::lstrcpyn(szSendDir, szDirSav, count_of(szSendDir));

                if (::GetOpenFileName(&ofn))
                {
                    // if there is only a single file, the first string is the full path.
                    // if there are more than one file, the first string is the directory path
                    // and followed by a list of file names. terminated by double null

                    // remember the working directory for next time
                    ULONG cchDirPath;
                    LPTSTR pszFileName;
                    ULONG cchFile = ::lstrlen(ofn.lpstrFile);
                    if (TEXT('\0') == ofn.lpstrFile[cchFile] && TEXT('\0') == ofn.lpstrFile[cchFile+1])
                    {
                        //
                        // only a single file
                        //
                        pszFileName = ::PathNameToFileName(ofn.lpstrFile);
                        cchDirPath = (ULONG)(pszFileName - ofn.lpstrFile);
                        if (cchDirPath)
                        {
                            cchDirPath--; // back to '\\'
                        }
                        ASSERT(TEXT('\\') == ofn.lpstrFile[cchDirPath]);
                        ofn.lpstrFile[cchDirPath] = TEXT('\0');
                    }
                    else
                    {
                        //
                        // multiple files
                        //
                        cchDirPath = ::lstrlen(ofn.lpstrFile);
                        pszFileName = ofn.lpstrFile + cchDirPath + 1;
                    }
					::lstrcpy(m_szDefaultDir, ofn.lpstrFile);

					EnsureTrailingSlash(m_szDefaultDir);

					::ZeroMemory(szSendDir, sizeof(szSendDir));
                    ::CopyMemory(szSendDir, ofn.lpstrFile, cchDirPath * sizeof(TCHAR));
					EnsureTrailingSlash(szSendDir);

                    // set up the common portion of list view item
                    LVITEM lvi;
                    ::ZeroMemory(&lvi, sizeof(lvi));
                    // lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

                    // iterate the file name
                    while ('\0' != *pszFileName)
                    {
                        BOOL fRet;
                        DBG_SAVE_FILE_LINE
                        CUiSendFileInfo *pFileInfo = new CUiSendFileInfo(this, szSendDir, pszFileName, &fRet);
                        if (NULL != pFileInfo && fRet)
                        {
                            // put it to the list view
                            lvi.iItem = ListView_GetItemCount(m_hwndListView);
                            lvi.iSubItem = 0;
                            // we are responsible for storing the text to display
                            lvi.pszText = LPSTR_TEXTCALLBACK;
                            lvi.cchTextMax = MAX_PATH;
                            lvi.lParam = (LPARAM) pFileInfo;
                            int iRet = ListView_InsertItem(m_hwndListView, &lvi);
                            ASSERT(-1 != iRet);
                            // UpdateListView(pFileInfo);
                        }
                        else
                        {
                            delete pFileInfo;
                        }

                        // get to the next file name
                        pszFileName += ::lstrlen(pszFileName) + 1;
                    } // while
                }
                else
                {
                    // err code for cancel is zero, which is ok.
                    ASSERT(! ::CommDlgExtendedError());
                }

                // restore old working directory
                ::SetCurrentDirectory(szDirSav);
            }

            delete pszBuffer;
            m_fInFileOpenDialog = FALSE;
        }
        else
        {
            // bring the active dialog to the front
            BringToFront();
        }
    } // if LoadString
}


//
// OnRemoveFiles
//

void CAppletWindow::OnRemoveFiles(void)
{
    UINT nState;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);
    LVITEM lvi;
    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_SELECTED;
    ULONG i = 0;
    while (i < cItems)
    {
        lvi.iItem = i;
        BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
        if (fRet && lvi.state & LVIS_SELECTED)
        {
            CUiSendFileInfo *pFileInfo = (CUiSendFileInfo *) lvi.lParam;
            if (pFileInfo == m_pCurrSendFileInfo)
            {
                OnStopSending();
                ClearSendInfo(FALSE);
            }
            delete pFileInfo;

            fRet = ListView_DeleteItem(m_hwndListView, i);
            ASSERT(fRet);

            cItems--;
            ASSERT((ULONG) ListView_GetItemCount(m_hwndListView) == cItems);
        }
        else
        {
            i++;
        }
    }
	if (cItems > 0)  // set focus to first remaining item
	{
		ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED | LVIS_FOCUSED,
							LVIS_SELECTED | LVIS_FOCUSED);
	}
}


void CAppletWindow::OnRemoveAllFiles(void)
{
    BOOL fRet;
    CUiSendFileInfo *pFileInfo;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);
    LVITEM lvi;
    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;
    for (ULONG i = 0; i < cItems; i++)
    {
        lvi.iItem = i;
        fRet = ListView_GetItem(m_hwndListView, &lvi);
        ASSERT(fRet);
        pFileInfo = (CUiSendFileInfo *) lvi.lParam;
        if (pFileInfo == m_pCurrSendFileInfo)
        {
            ClearSendInfo(FALSE);
        }
        delete pFileInfo;
    }

    fRet = ListView_DeleteAllItems(m_hwndListView);
    ASSERT(fRet);
}


void CAppletWindow::OnSendAll(void)
{
	if ((NULL == m_pCurrSendFileInfo)&&(NULL != m_pEngine))
    {
		CUiSendFileInfo *pFileInfo = ChooseFirstUnSentFile();
		SendNow(pFileInfo);
	}
}

void CAppletWindow::OnSendOne(void)
{
	if ((NULL == m_pCurrSendFileInfo)&&(NULL != m_pEngine))
    {	
		CUiSendFileInfo *pFileInfo = ChooseSelectedFile();
		if (!pFileInfo)
		{
			pFileInfo = ChooseFirstUnSentFile();
		}
		SendNow(pFileInfo);
	}
}


//
// SendNow
//

BOOL CAppletWindow::SendNow(CUiSendFileInfo *pFileInfo)
{
	BOOL fRet;

    if (NULL != pFileInfo)
    {
        // send this file now...
        m_pCurrSendFileInfo = pFileInfo;
        m_nCurrSendEventHandle = ::GetNewEventHandle();
        pFileInfo->SetFileHandle(::GetNewFileHandle());

        // duplicate full file name
        ULONG cbSize = ::lstrlen(pFileInfo->GetFullName()) + 1;
        DBG_SAVE_FILE_LINE
        LPTSTR pszFullName = new TCHAR[cbSize];
        if (NULL != pszFullName)
        {
            ::CopyMemory(pszFullName, pFileInfo->GetFullName(), cbSize);

            DBG_SAVE_FILE_LINE
            if (S_OK == m_pEngine->SafePostMessage(
                                     new CreateSessionMsg(MBFT_PRIVATE_SEND_TYPE,
                                                          m_nCurrSendEventHandle)))
            {
				int iSelect;
				MEMBER_ID nMemberID;
				iSelect = m_pToolbar->GetSelectedItem((LPARAM*)&nMemberID);
				if (0 == iSelect)
				{   // Send to All
					DBG_SAVE_FILE_LINE
					if (S_OK == m_pEngine->SafePostMessage(
										new SubmitFileSendMsg(0, 0, pszFullName,
													pFileInfo->GetFileHandle(),
													m_nCurrSendEventHandle,
													FALSE)))
					{
						return TRUE;
					}
					else
					{
						ERROR_OUT(("CAppletWindow::SendNow: cannot create SubmitFileSendMsg"));
					}
				}
				else
				{   // Send to one
					T120UserID uidRecv = GET_PEER_ID_FROM_MEMBER_ID(nMemberID);

					DBG_SAVE_FILE_LINE
					if (S_OK == m_pEngine->SafePostMessage(
										new SubmitFileSendMsg(uidRecv, 0, pszFullName,
													pFileInfo->GetFileHandle(),
													m_nCurrSendEventHandle,
													FALSE)))
					{
						return TRUE;
					}
					else
					{
						ERROR_OUT(("CAppletWindow::SendNow: cannot create SubmitFileSendMsg to 1"));
					}
				}
            }
            else
            {
                ERROR_OUT(("CAppletWindow::SendNow: cannot create CreateSessionMsg"));
            }

            delete [] pszFullName;
        }
		ClearSendInfo(TRUE);
	}
	return FALSE;
}


CUiSendFileInfo *CAppletWindow::ChooseFirstUnSentFile(void)
{
    CUiSendFileInfo *pFileInfo = NULL;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);

    if (cItems > 0)
    {
        // examine each item one by one
        LVITEM lvi;
        ::ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_PARAM;
        for (ULONG i = 0; i < cItems; i++, pFileInfo = NULL)
        {
            lvi.iItem = i;
            BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
            ASSERT(fRet);
            pFileInfo = (CUiSendFileInfo *) lvi.lParam;
            // if file handle is not zero, then it has been sent
            if (! pFileInfo->GetFileHandle())
            {
                break;
            }
        }
	}
	return pFileInfo;
}

CUiSendFileInfo *CAppletWindow::ChooseSelectedFile(void)
{
	CUiSendFileInfo *pFileInfo = NULL;
    ULONG cItems = ListView_GetItemCount(m_hwndListView);
    LVITEM lvi;
    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_SELECTED;
    ULONG i = 0;
    while (i < cItems)
    {
        lvi.iItem = i;
        BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
        if (fRet && lvi.state & LVIS_SELECTED)
        {
            pFileInfo = (CUiSendFileInfo *) lvi.lParam;
			pFileInfo->SetErrorCode(iMBFT_OK);
			break;
        }
        else
        {
            i++;
			pFileInfo = NULL;
        }
    }
	return pFileInfo;
}


//
// OnMenuSelect
//

void CAppletWindow::OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu)
{
    UINT   firstMenuId;
    UINT   statusId;

    //
    // Work out the help ID for the menu item.  We have to store this now
    // because when the user presses F1 from a menu item, we can't tell
    // which item it was.
    //
	
    if ((uiFlags & MF_POPUP) && (uiFlags & MF_SYSMENU))
    {
        // System menu selected
        statusId = (m_pCurrSendFileInfo)?IDS_STBAR_SENDING_XYZ:IDS_STBAR_NOT_TRANSFERING;
    }
    else if (uiFlags & MF_POPUP)
	{
        // get popup menu handle and first item
        HMENU hPopup = ::GetSubMenu( hSysMenu, uiItemID );
        firstMenuId = ::GetMenuItemID( hPopup, 0 );

		switch(firstMenuId)
		{
		case IDM_ADD_FILES:
			statusId = IDS_MENU_FILE;
			break;

		case IDM_HELP:
			statusId = IDS_MENU_HELP;
			break;

		default:
			statusId = (m_pCurrSendFileInfo)?IDS_STBAR_SENDING_XYZ:IDS_STBAR_NOT_TRANSFERING;
		}
	}
	else
    {
        // A normal menu item has been selected
        statusId   = uiItemID;
    }

    // Set the new help text
    TCHAR   szStatus[256];

    if (::LoadString(g_hDllInst, statusId, szStatus, 256))
    {
        ::SendMessage(m_hwndStatusBar, SB_SETTEXT, SBP_TRANSFER_FILE, (LPARAM)szStatus);
    }	
}


//
// OnStopSending
//

void CAppletWindow::OnStopSending(void)
{
	m_fSendALL = FALSE;
    if (m_nCurrSendEventHandle)
    {
        DBG_SAVE_FILE_LINE
        HRESULT hr = m_pEngine->SafePostMessage(
                            new FileTransferControlMsg(
                                            m_nCurrSendEventHandle,
                                            m_pCurrSendFileInfo->GetFileHandle(),
                                            NULL,
                                            NULL,
                                            FileTransferControlMsg::EnumAbortFile));
        ASSERT(hr == S_OK);
    }
}


//
// OnOpenRecvFolder
//

void CAppletWindow::OnOpenRecvFolder(void)
{
    TCHAR szRecvFolder[MAX_PATH];

	while (1)
	{
	    if (S_OK == ::GetRecvFolder(NULL, szRecvFolder))
		{
			::ShellExecute(NULL, NULL, szRecvFolder, NULL, NULL, SW_SHOWNORMAL);
			break;
		}
		else if (m_UIMode != FTUIMODE_NOUI)
		{
			::MyLoadString(IDS_RECVDLG_DIRNOEXIST, s_szScratchText, szRecvFolder);
			if (IDYES == ::MessageBox(m_hwndMainUI, s_szScratchText, s_szMSFT, MB_YESNO))
			{
				OnChangeFolder();
			}
			else
			{
				break;
			}
		}
    }
}


//
// OnChageFolder
//

void OnChangeFolder(void)
{
	BOOL rc;
	TCHAR szPath[MAX_PATH];

    ::GetRecvFolder(NULL, szPath);
    if (::lstrlen(szPath) > MAX_FILE_NAME_LENGTH)
    {
        LPTSTR psz = szPath;
        int i = MAX_FILE_NAME_LENGTH - 1;
        while (i)
        {
            psz = CharNext(psz);
            i--;
        }
        ::lstrcpy(psz, TEXT("..."));
    }
	::MyLoadString(IDS_BROWSETITLE, s_szScratchText, szPath);

	if (FBrowseForFolder(szPath, CCHMAX(szPath), s_szScratchText))
	{
		::GetRecvFolder(szPath, szPath);
	}
}


//
// OnExit
//

void CAppletWindow::OnExit(BOOL fNoQuery)
{
    if ((g_pFileXferApplet->InConf() || g_pFileXferApplet->HasSDK())
		&& ! g_fShutdownByT120)
    {
        // There 2.x node inside the conference
        // hide the window
        ::ShowWindow(m_hwndMainUI, SW_HIDE);
		m_UIMode = g_fNoUI ? FTUIMODE_NOUI : FTUIMODE_UIHIDDEN;
    }
    else
    if (fNoQuery || QueryShutdown())
    {	
#if defined(TEST_PLUGABLE) && defined(_DEBUG)
        ::OnPluggableEnd();
#endif

		MBFTEngine *pEngine = m_pEngine;

        ::T120_AppletStatus(APPLET_ID_FT, APPLET_CLOSING);

        if (NULL != m_pEngine)
        {
            GCCAppPermissionToEnrollInd Ind;
            ::ZeroMemory(&Ind, sizeof(Ind));
            Ind.nConfID = m_pEngine->GetConfID();
            Ind.fPermissionGranted = FALSE;
            m_pEngine->OnPermitToEnrollIndication(&Ind);
            UnregisterEngine();
        }

        OnRemoveAllFiles();

        ::SetWindowLongPtr(m_hwndMainUI, GWLP_USERDATA, 0);
		
		SaveWindowPosition();
        HWND hwnd = m_hwndMainUI;
        m_hwndMainUI = NULL;
        ::DestroyWindow(hwnd);

        if (NULL != g_pFileXferApplet)
        {
            g_pFileXferApplet->UnregisterWindow(this);
            g_pFileXferApplet->UnregisterEngine(pEngine);
        }

        Release();
    }
}


//
// OnHelp
//

void CAppletWindow::OnHelp(void)
{
    DebugEntry(CAppletWindow::OnHelp);
    ShowNmHelp(s_cszHtmlHelpFile);
    DebugExitVOID(CAppletWindow::OnHelp);
}


//
// OnAbout
//

INT_PTR AboutDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szFormat[256];
            TCHAR szVersion[512];

            ::GetDlgItemText(hdlg, IDC_ABOUT_VERSION, szFormat, count_of(szFormat));
            ::wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hdlg, IDC_ABOUT_VERSION, szVersion);

            fHandled = TRUE;
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
        case IDCANCEL:
        case IDCLOSE:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
                ::EndDialog(hdlg, IDCANCEL);
                break;
            }
            break;
        }

        fHandled = TRUE;
        break;
    }

    return(fHandled);
}

void CAppletWindow::OnAbout(void)
{
    ::DialogBoxParam(g_hDllInst, MAKEINTRESOURCE(IDD_ABOUTBOX), m_hwndMainUI,
        AboutDlgProc, 0);
}


BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle)
{
    LPITEMIDLIST pidlRoot;
    SHGetSpecialFolderLocation(HWND_DESKTOP, CSIDL_DRIVES, &pidlRoot);

    BROWSEINFO bi;
    ClearStruct(&bi);
    bi.hwndOwner = NULL;
    bi.lpszTitle = pszTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS;
    bi.pidlRoot = pidlRoot;

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    BOOL fRet = (pidl != NULL);
    if (fRet)
    {
        ASSERT(cchMax >= MAX_PATH);
        SHGetPathFromIDList(pidl, pszFolder);
        ASSERT(lstrlen(pszFolder) < (int) cchMax);
    }

    // Get the shell's allocator to free PIDLs
    LPMALLOC lpMalloc;
    if (!SHGetMalloc(&lpMalloc) && (NULL != lpMalloc))
    {
        if (NULL != pidlRoot)
        {
            lpMalloc->Free(pidlRoot);
        }
        if (pidl)
        {
            lpMalloc->Free(pidl);
        }
        lpMalloc->Release();
    }
    return fRet;
}


/////////////////////////////////////////////////////////////////
//
//  WM_NOTIFY
//

LRESULT OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (NULL != pWindow)
    {
        switch (wParam)
        {
        case IDC_LIST_VIEW:
            pWindow->OnNotifyListView(lParam);
            break;

        default:
            if (TTN_NEEDTEXT == ((NMHDR *) lParam)->code)
            {
                // display the tool tip text
                TOOLTIPTEXT *pToolTipText = (TOOLTIPTEXT *) lParam;
                ULONG_PTR nID;

                // get id and hwnd
                if (pToolTipText->uFlags & TTF_IDISHWND)
                {
                    // idFrom is actually the HWND of the tool
                    nID = ::GetDlgCtrlID((HWND) pToolTipText->hdr.idFrom);
                }
                else
                {
                    nID = pToolTipText->hdr.idFrom;
                }

                // give it to em
                pToolTipText->lpszText = MAKEINTRESOURCE(nID);
                pToolTipText->hinst = g_hDllInst;
            }
            break;
        }
    }

    return 0;
}


int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CUiSendFileInfo *pFileInfo1 = (CUiSendFileInfo *) lParam1;
    CUiSendFileInfo *pFileInfo2 = (CUiSendFileInfo *) lParam2;
    int iResult;

    iResult = 0; // equal, at default
    switch (lParamSort)
    {
    case (IDS_LV_FILE_NAME - IDS_LV_FILE_NAME):
        iResult = ::lstrcmpi(pFileInfo1->GetName(), pFileInfo2->GetName());
        break;
    case (IDS_LV_FILE_SIZE - IDS_LV_FILE_NAME):
        if (pFileInfo1->GetSize() > pFileInfo2->GetSize())
        {
            iResult = 1;
        }
        else
        if (pFileInfo1->GetSize() < pFileInfo2->GetSize())
        {
            iResult = -1;
        }
        break;
    case (IDS_LV_FILE_STATUS - IDS_LV_FILE_NAME):
	case (IDS_LV_FILE_MODIFIED - IDS_LV_FILE_NAME):
        // do nothing at all, for now...
		break;
    }
    return iResult;
}


void CAppletWindow::OnNotifyListView(LPARAM lParam)
{
    LV_DISPINFO *pDispInfo = (LV_DISPINFO *) lParam;
    NM_LISTVIEW *pLVN = (NM_LISTVIEW *) lParam;
	FILETIME	ftFileTime;
	SYSTEMTIME	stSystemTime;
    CUiSendFileInfo *pFileInfo;
	int iSize;
	TCHAR	szBuffer[MAX_PATH];



    switch (pLVN->hdr.code)
    {
    case LVN_GETDISPINFO:
        pFileInfo = (CUiSendFileInfo *) pDispInfo->item.lParam;
        ASSERT(NULL != pFileInfo);

        switch (pDispInfo->item.iSubItem)
        {
        case (IDS_LV_FILE_NAME - IDS_LV_FILE_NAME):
            pDispInfo->item.pszText = pFileInfo->GetName();
            break;
        case (IDS_LV_FILE_SIZE - IDS_LV_FILE_NAME):
            ::wsprintf(szBuffer, TEXT("%u"), pFileInfo->GetSize());
			iSize = GetNumberFormat(LOCALE_SYSTEM_DEFAULT, LOCALE_NOUSEROVERRIDE,
							szBuffer, NULL, s_szScratchText, MAX_PATH);	
			s_szScratchText[iSize - 4] = '\0'; // remove the trailing ".00"
            pDispInfo->item.pszText = s_szScratchText;
            break;
        case (IDS_LV_FILE_STATUS - IDS_LV_FILE_NAME):
            {
                ULONG cbTotalSend = pFileInfo->GetTotalSend();
                ULONG cbFileSize = pFileInfo->GetSize();
                s_szScratchText[0] = TEXT('\0');

                switch (pFileInfo->GetErrorCode())
                {
                case iMBFT_OK:
				case iMBFT_MULT_RECEIVER_ABORTED:
					if (!pFileInfo->GetFileHandle())
						break;   // handle == NULL, if cbTotalSend == 0, zero length file to be sent.
                    if (cbTotalSend >= cbFileSize)
                    {
                        ::MyLoadString(IDS_LV_FILE_SENT);
                    }
                    else
                    if (cbTotalSend)
                    {
						if (m_pEngine)
						{
							::MyLoadString(IDS_LV_FILE_SENDING);
						}
						else
						{
							::MyLoadString(IDS_LV_FILE_CANCELED);
						}
                    }
                    break;

                case iMBFT_SENDER_ABORTED:
                case iMBFT_RECEIVER_ABORTED:
                case iMBFT_NO_MORE_FILES:
                    ::MyLoadString(IDS_LV_FILE_CANCELED);
                    break;

                default:
                    ::MyLoadString(IDS_LV_FILE_FAILED);
                    break;
                }

                pDispInfo->item.pszText = s_szScratchText;
            }
            break;

		case (IDS_LV_FILE_MODIFIED - IDS_LV_FILE_NAME):
			ftFileTime = pFileInfo->GetLastWrite();
			FileTimeToSystemTime(&ftFileTime, &stSystemTime);
			iSize = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &stSystemTime,
							"MM'/'dd'/'yyyy", s_szScratchText, MAX_PATH);
			GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stSystemTime,
							"  hh':'mm tt", &s_szScratchText[iSize - 1], MAX_PATH-iSize-1);
			pDispInfo->item.pszText = s_szScratchText;
			break;
        }
        break;

    case LVN_COLUMNCLICK:
        {
            BOOL fRet = ListView_SortItems(pLVN->hdr.hwndFrom, ListViewCompareProc, (LPARAM) pLVN->iSubItem);
            ASSERT(fRet);
        }
        break;
    }
}


/////////////////////////////////////////////////////////////////
//
//  WM_DROPFILES
//

LRESULT OnDropFiles(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (g_fSendAllowed)
    {
        return pWindow->OnDropFiles((HANDLE) wParam);
    }
    else
    {
        ::MyLoadString(IDS_MSGBOX_POL_PREVENT);
        ::MessageBox(pWindow->GetHwnd(), s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
        return 1;
    }
}


LRESULT CAppletWindow::OnDropFiles(HANDLE hDrop)
{
    if (NULL != m_pEngine && m_pEngine->GetPeerCount() > 1)
    {
        HRESULT hr;

        // get the number of dropped files
        ULONG cFiles = ::DragQueryFile((HDROP) hDrop, 0xFFFFFFFF, NULL, 0);

        // set up the common portion of list view item
        LVITEM lvi;
        ::ZeroMemory(&lvi, sizeof(lvi));
        // lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

        // iterate on these files
        for (ULONG i = 0; i < cFiles; i++)
        {
            BOOL fRet;
            TCHAR szFile[MAX_PATH];

            if (::DragQueryFile((HDROP) hDrop, i, szFile, count_of(szFile)))
            {
                DBG_SAVE_FILE_LINE
                CUiSendFileInfo *pFileInfo = new CUiSendFileInfo(this, NULL, szFile, &fRet);
                if (NULL != pFileInfo && fRet)
                {
                    // put it to the list view
                    lvi.iItem = ListView_GetItemCount(m_hwndListView);
                    lvi.iSubItem = 0;
                    // we are responsible for storing the text to display
                    lvi.pszText = LPSTR_TEXTCALLBACK;
                    lvi.cchTextMax = MAX_PATH;
                    lvi.lParam = (LPARAM) pFileInfo;
                    int iRet = ListView_InsertItem(m_hwndListView, &lvi);
                    ASSERT(-1 != iRet);
                    // UpdateListView(pFileInfo);
                }
                else
                {
                    // BUGBUG: we should pop up some error message box here!
					::MyLoadString(IDS_INVALID_FILENAME, s_szScratchText, szFile);
					::MessageBox(m_hwndMainUI, s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
                    delete pFileInfo;
                }
            }
        }

        ::DragFinish((HDROP) hDrop);
		SetForegroundWindow(m_hwndMainUI);

        UpdateUI();
        return 0;
    }

    ::MyLoadString(IDS_MSGBOX_NO_CONF);
    ::SetForegroundWindow(m_hwndMainUI);
    ::MessageBox(m_hwndMainUI, s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
    return 1;
}



/////////////////////////////////////////////////////////////////
//
//  WM_CONTEXTMENU
//

LRESULT OnContextMenu(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT rc = 0;

    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if ((WPARAM) pWindow->GetHwnd() == wParam)
    {
        // BUGBUG use TrackPopupMenu to show context sensitive menu
        pWindow->OnContextMenuForMainUI(lParam);
    }
    else
    if ((WPARAM) pWindow->GetListView() == wParam)
    {
        // BUGBUG use TrackPopupMenu to show context sensitive menu
        pWindow->OnContextMenuForListView(lParam);
    }
    else
    {
        rc = 1;
    }

    return rc;
}


enum
{
    MENU_IDX_ADD_FILES,
    MENU_IDX_REMOVE_FILES,
    MENU_IDX_BREAK_1,
    MENU_IDX_SEND_ALL,
	MENU_IDX_SEND_ONE,
    MENU_IDX_STOP_SENDING,
    MENU_IDX_BREAK_2,
    MENU_IDX_OPEN_RECV_FOLDER,
};

static UI_MENU_INFO s_aMenuInfo[] =
{
    { IDS_MENU_ADD_FILES,           IDM_ADD_FILES,          MF_ENABLED | MF_STRING },
    { IDS_MENU_REMOVE_FILES,        IDM_REMOVE_FILES,       MF_ENABLED | MF_STRING },
    { 0,                            0,                      MF_SEPARATOR}, // menu break
    { IDS_MENU_SEND_ALL,            IDM_SEND_ALL,           MF_ENABLED | MF_STRING },
	{ IDS_MENU_SEND_ONE,			IDM_SEND_ONE,			MF_ENABLED | MF_STRING },
    { IDS_MENU_STOP_SENDING,        IDM_STOP_SENDING,       MF_ENABLED | MF_STRING },
    { 0,                            0,                      MF_SEPARATOR}, // menu break
    { IDS_MENU_OPEN_RECV_FOLDER,    IDM_OPEN_RECV_FOLDER,   MF_ENABLED | MF_STRING },
	{ IDS_MENU_CHANGE_FOLDER,		IDM_CHANGE_FOLDER,		MF_ENABLED | MF_STRING },
    { 0,                            0,                      MF_SEPARATOR }, // menu break
    { IDS_MENU_EXIT,                IDM_EXIT,               MF_ENABLED | MF_STRING },
};


void CAppletWindow::SetContextMenuStates(void)
{
    if (g_fSendAllowed)
    {
        BOOL fMoreThanOne = (NULL != m_pEngine) && (m_pEngine->GetPeerCount() > 1);
        s_aMenuInfo[MENU_IDX_ADD_FILES].nFlags = fMoreThanOne ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);

        ULONG cItems = ListView_GetItemCount(m_hwndListView);
        s_aMenuInfo[MENU_IDX_REMOVE_FILES].nFlags = cItems ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_SEND_ALL].nFlags = (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(TRUE)) ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
		s_aMenuInfo[MENU_IDX_SEND_ONE].nFlags = (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(FALSE)) ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_STOP_SENDING].nFlags = m_nCurrSendEventHandle ? (MF_ENABLED | MF_STRING) : (MF_GRAYED | MF_STRING);
    }
    else
    {	
        s_aMenuInfo[MENU_IDX_ADD_FILES].nFlags =(MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_REMOVE_FILES].nFlags =(MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_SEND_ALL].nFlags = (MF_GRAYED | MF_STRING);
		s_aMenuInfo[MENU_IDX_SEND_ONE].nFlags = (MF_GRAYED | MF_STRING);
        s_aMenuInfo[MENU_IDX_STOP_SENDING].nFlags = (MF_GRAYED | MF_STRING);
    }
}


void CAppletWindow::OnContextMenuForMainUI(LPARAM lParam)
{
    SetContextMenuStates();
    CreateMenu(lParam, count_of(s_aMenuInfo), &s_aMenuInfo[0]);
}


void CAppletWindow::OnContextMenuForListView(LPARAM lParam)
{
    SetContextMenuStates();
    CreateMenu(lParam, 6, &s_aMenuInfo[0]);
}


void CAppletWindow::CreateMenu(LPARAM lParam, ULONG cItems, UI_MENU_INFO aMenuInfo[])
{
    HMENU hMenu = ::CreatePopupMenu();
    if (NULL != hMenu)
    {
        for (ULONG i = 0; i < cItems; i++)
        {
            if (aMenuInfo[i].idCommand)
            {
                if (::MyLoadString(aMenuInfo[i].idString))
                {
                    ::AppendMenu(hMenu, aMenuInfo[i].nFlags, aMenuInfo[i].idCommand, s_szScratchText);
                }
            }
            else
            {
                ::AppendMenu(hMenu, aMenuInfo[i].nFlags, 0, 0);
            }
        }

        ::TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RIGHTBUTTON,
                         GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam),
                         0, // reserved, must be zero
                         m_hwndMainUI,
                         NULL); // ignore
    }
}


/////////////////////////////////////////////////////////////////
//
//  WM_SIZE
//

LRESULT OnSize(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    pWindow->OnSizeToolBar();
    pWindow->OnSizeStatusBar();
    pWindow->OnSizeListView();

    return 0;
}


void CAppletWindow::OnSizeToolBar(void)
{
    RECT rcWindow;
	SIZE szToolBar;

    ::GetClientRect(m_hwndMainUI, &rcWindow);
	m_pToolbar->GetDesiredSize(&szToolBar);

    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = szToolBar.cy;;
    ULONG x = 0;
    ULONG y = 0;

    ::MoveWindow(m_pToolbar->GetWindow(), x, y, cx, cy, TRUE);
}


void CAppletWindow::OnSizeStatusBar(void)
{
    RECT rcWindow, rcStatusBar;
    ::GetClientRect(m_hwndMainUI, &rcWindow);
    ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);

    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = rcStatusBar.bottom - rcStatusBar.top;
    ULONG x = 0;
    ULONG y = rcWindow.bottom - cy;

    ::MoveWindow(m_hwndStatusBar, x, y, cx, cy, TRUE);
	::MoveWindow(m_hwndProgressBar, x + cx/2, y, cx/2 - 40, cy, TRUE);

    int aWidths[NUM_STATUS_BAR_PARTS];
    aWidths[0] = cx / 2;  // conference state
    aWidths[1] = cx - 40; // transfer name
    aWidths[2] = -1;  // transfer percentage
    ASSERT(3 == NUM_STATUS_BAR_PARTS);

    ::SendMessage(m_hwndStatusBar, SB_SETPARTS, NUM_STATUS_BAR_PARTS, (LPARAM) &aWidths[0]);
}


void CAppletWindow::OnSizeListView(void)
{
    // get the size and position of the main window
    RECT rcWindow, rcToolBar, rcStatusBar;
	SIZE	szToolBar;
    ::GetClientRect(m_hwndMainUI, &rcWindow);
	m_pToolbar->GetDesiredSize(&szToolBar);
    ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);

    ULONG x = 0;
    ULONG y = szToolBar.cy - 1;
    ULONG cx = rcWindow.right - rcWindow.left;
    ULONG cy = rcWindow.bottom - rcWindow.top - y - (rcStatusBar.bottom - rcStatusBar.top) + 1;

    ::MoveWindow(m_hwndListView, x, y, cx, cy, TRUE);
}


/////////////////////////////////////////////////////////////////
//
//  WM_HELP
//

LRESULT OnHelp(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    pWindow->OnHelp();
    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_CLOSE
//

LRESULT OnClose(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (NULL != pWindow)
    {
        pWindow->OnExit();
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_INITMENUPOPUP
//
/*
LRESULT OnInitMenuPopup(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if (0 != HIWORD(lParam)) // System menu flag
    {
        HMENU hMenu = (HMENU) wParam;         // handle of pop-up menu
        ::EnableMenuItem(hMenu, SC_MAXIMIZE, MF_GRAYED);
        ::EnableMenuItem(hMenu, SC_SIZE, MF_GRAYED);
        return 0;
    }
    return 1;
}
*/


/////////////////////////////////////////////////////////////////
//
//  WM_MENUSELECT
//

LRESULT OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (NULL != pWindow)
    {
        pWindow->OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam),
							  GET_WM_MENUSELECT_FLAGS(wParam, lParam),
							  GET_WM_MENUSELECT_HMENU(wParam, lParam));
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_INITMENUPOPUP
//

LRESULT OnGetMinMaxInfo(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (NULL != pWindow)
    {
        pWindow->OnGetMinMaxInfo((LPMINMAXINFO) lParam);
        return 0;
    }
    return 1;
}


void CAppletWindow::OnGetMinMaxInfo(LPMINMAXINFO pMMI)
{
    static BOOL s_fEnterBefore = FALSE;

    static SIZE s_csFrame;
    static SIZE s_csSeparator;
    static SIZE s_csScrollBars;
    static SIZE s_csToolBar;
    static SIZE s_csStatusBar;
    static SIZE s_csSum;

    if (! s_fEnterBefore)
    {
        s_fEnterBefore = TRUE;

        s_csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
        s_csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

        s_csSeparator.cx = ::GetSystemMetrics(SM_CXEDGE);
        s_csSeparator.cy = ::GetSystemMetrics(SM_CYEDGE);

        s_csScrollBars.cx = ::GetSystemMetrics(SM_CXVSCROLL);
        s_csScrollBars.cy = ::GetSystemMetrics(SM_CYHSCROLL);

		m_pToolbar->GetDesiredSize(&s_csToolBar);

        RECT    rcStatusBar;
        ::GetWindowRect(m_hwndStatusBar, &rcStatusBar);
        s_csStatusBar.cx = rcStatusBar.right - rcStatusBar.left;
        s_csStatusBar.cy = rcStatusBar.bottom - rcStatusBar.top;

        s_csSum.cx = (s_csFrame.cx << 1);
        s_csSum.cy = (s_csFrame.cy << 1) + (s_csSeparator.cy << 3) +
                     s_csToolBar.cy + (rcStatusBar.bottom - rcStatusBar.top) +
                     ::GetSystemMetrics( SM_CYCAPTION ) + ::GetSystemMetrics( SM_CYMENU );
    }

    RECT    rcListViewItem;
    SIZE    csListView;
    csListView.cx = 0;
    for (ULONG i = 0; i < NUM_LIST_VIEW_COLUMNS; i++)
    {
        csListView.cx += ListView_GetColumnWidth(m_hwndListView, i);
    }
    if (ListView_GetItemRect(m_hwndListView, 0, &rcListViewItem, LVIR_BOUNDS))
    {
        csListView.cy = 20 + 3 * (rcListViewItem.bottom - rcListViewItem.top);
    }
    else
    {
        csListView.cy = 20 + 30;
    }

    // Set the minimum width and height of the window
    pMMI->ptMinTrackSize.x = s_csSum.cx + max(s_csToolBar.cx, csListView.cx);
    pMMI->ptMinTrackSize.y = s_csSum.cy + csListView.cy;

    //
    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //

    RECT    rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );

    SIZE    csMaxSize;
    csMaxSize.cx = rcWorkArea.right - rcWorkArea.left;
    csMaxSize.cy = rcWorkArea.bottom - rcWorkArea.top;

    pMMI->ptMaxPosition.x  = 0;
    pMMI->ptMaxPosition.y  = 0;
    pMMI->ptMaxSize.x      = csMaxSize.cx;
    pMMI->ptMaxSize.y      = csMaxSize.cy;
    pMMI->ptMaxTrackSize.x = csMaxSize.cx;
    pMMI->ptMaxTrackSize.y = csMaxSize.cy;
}


/////////////////////////////////////////////////////////////////
//
//  WM_QUERYENDSESSION
//

LRESULT OnQueryEndSession(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(NULL != pWindow);

    if (NULL != pWindow)
    {
        return pWindow->QueryShutdown(); // TRUE: ok to send session; FALSE, no.
    }
    return TRUE; // ok to end session
}


/////////////////////////////////////////////////////////////////
//
//  WM_ENDSESSION
//

LRESULT OnEndSession(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (wParam && NULL != pWindow)
    {
        pWindow->OnExit(TRUE);
    }

    return 0;
}



/////////////////////////////////////////////////////////////////
//
//  WM_DRAWITEM
//

LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (wParam && NULL != pWindow)
    {
        pWindow->DrawItem((DRAWITEMSTRUCT *)lParam);
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  WM_SEND_NEXT
//

LRESULT OnSendNext(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    CAppletWindow *pWindow = (CAppletWindow *) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (NULL != pWindow)
    {
        pWindow->OnSendAll();
        pWindow->UpdateUI();
    }

    return 0;
}


/////////////////////////////////////////////////////////////////
//
//  Main windows procedure
//

LRESULT CALLBACK FtMainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT rc;

    switch (uMsg)
    {
    case WM_CREATE:
        rc = ::OnCreate(hwnd, wParam, lParam);
        break;

    case WM_COMMAND:
        rc = ::OnCommand(hwnd, wParam, lParam);
        break;

    case WM_NOTIFY:
        rc = ::OnNotify(hwnd, wParam, lParam);
        break;

    case WM_DROPFILES:
        rc = ::OnDropFiles(hwnd, wParam, lParam);
        break;

    case WM_CONTEXTMENU:
        rc = ::OnContextMenu(hwnd, wParam, lParam);
        break;

    case WM_SIZE:
        rc = ::OnSize(hwnd, wParam, lParam);
        break;

    case WM_HELP:
        rc = ::OnHelp(hwnd, wParam, lParam);
        break;

	case WM_DRAWITEM:
		rc = ::OnDrawItem(hwnd, wParam, lParam);
		break;

    case WM_CLOSE:
        rc = ::OnClose(hwnd, wParam, lParam);
        break;

    case WM_INITMENUPOPUP:
        //  rc = ::OnInitMenuPopup(hwnd, wParam, lParam);
        break;

	case WM_MENUSELECT:
        rc = ::OnMenuSelect(hwnd, wParam, lParam);
        break;

    case WM_GETMINMAXINFO:
        rc = ::OnGetMinMaxInfo(hwnd, wParam, lParam);
        break;

    case WM_QUERYENDSESSION:
        rc = OnQueryEndSession(hwnd, wParam, lParam);
        break;

    case WM_ENDSESSION:
        rc = ::OnEndSession(hwnd, wParam, lParam);
        break;

    case WM_SEND_NEXT:
        rc = ::OnSendNext(hwnd, wParam, lParam);
        break;

#if defined(TEST_PLUGABLE) && defined(_DEBUG)
    case WM_PLUGABLE_SOCKET:
        rc = ::OnPluggableSocket(hwnd, wParam, lParam);
        break;
#endif

    default:
        rc = ::DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    }

    return rc;
}


/////////////////////////////////////////////////////////////////
//
//  OnEngineNotify
//

void CAppletWindow::OnEngineNotify(MBFTMsg *pMsg)
{
    BOOL fHeartBeat = FALSE;

    switch (pMsg->GetMsgType())
    {
    case EnumFileOfferNotifyMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleFileOfferNotify((FileOfferNotifyMsg *) pMsg);
		}
        break;

    case EnumFileTransmitMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleProgressNotify((FileTransmitMsg *) pMsg);
		}
        fHeartBeat = TRUE;
        break;

    case EnumFileErrorMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleErrorNotify((FileErrorMsg *) pMsg);
		}
        break;

    case EnumPeerMsg:
        HandlePeerNotification((PeerMsg *) pMsg);
        break;

    case EnumInitUnInitNotifyMsg:
        HandleInitUninitNotification((InitUnInitNotifyMsg *) pMsg);
        break;

    case EnumFileEventEndNotifyMsg:
		if (m_UIMode != FTUIMODE_NOUI)
		{
			HandleFileEventEndNotification((FileEventEndNotifyMsg *) pMsg);
		}
        break;

    default:
        ASSERT(0);
        break;
    } // switch
}


void CAppletWindow::HandleFileOfferNotify(FileOfferNotifyMsg *pMsg)
{
    HRESULT hr = S_OK;
    if (g_fRecvAllowed)
    {
        DBG_SAVE_FILE_LINE
        CUiRecvFileInfo *pRecvFileInfo = new CUiRecvFileInfo(pMsg, &hr);
        if (NULL != pRecvFileInfo && S_OK == hr)
        {
            if (NULL != m_pEngine)
            {
                DBG_SAVE_FILE_LINE
                CRecvDlg *pDlg = new CRecvDlg(this,
                                              m_pEngine->GetConfID(),
                                              pMsg->m_NodeID,
                                              pMsg->m_EventHandle,
                                              pRecvFileInfo,
                                              &hr);
                if (NULL != pDlg && S_OK == hr)
                {
                    DBG_SAVE_FILE_LINE
                    if (S_OK == m_pEngine->SafePostMessage(
                                    new FileTransferControlMsg(
                                                pMsg->m_EventHandle,
                                                pMsg->m_hFile,
                                                pRecvFileInfo->GetRecvFolder(),
                                                pMsg->m_szFileName,
                                                FileTransferControlMsg::EnumAcceptFile)))
                    {
                        return;
                    }
                    else
                    {
                        ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot confirm file offer"));
                    }
                }
                else
                {
                    ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot allocate CRecvDlg, hr=0x%x", hr));
                }
                delete pDlg;
            }
            else
            {
                ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: no file transfer engine"));
            }
        }
        else
        {
            ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot allocate CUiRecvFileInfo, hr=0x%x", hr));
        }
        delete pRecvFileInfo;
    }
    else
    {
        DBG_SAVE_FILE_LINE
        if (S_OK != m_pEngine->SafePostMessage(
                        new FileTransferControlMsg(
                                    pMsg->m_EventHandle,
                                    pMsg->m_hFile,
                                    NULL,
                                    pMsg->m_szFileName,
                                    FileTransferControlMsg::EnumRejectFile)))
        {
            ERROR_OUT(("CAppletWindow::HandleFileOfferNotify: cannot confirm file offer"));
        }
    }
}


void CAppletWindow::HandleProgressNotify(FileTransmitMsg *pMsg)
{
    CRecvDlg *pDlg = NULL;
    MBFT_NOTIFICATION wMBFTCode = (MBFT_NOTIFICATION) pMsg->m_TransmitStatus;

    switch (wMBFTCode)
    {
    case iMBFT_FILE_SEND_BEGIN:
        // fall through... because the file start PDU can have data.

    case iMBFT_FILE_SEND_PROGRESS:
        if (NULL != m_pCurrSendFileInfo)
        {
            ASSERT(m_nCurrSendEventHandle == pMsg->m_EventHandle);
            ASSERT(m_pCurrSendFileInfo->GetFileHandle() == pMsg->m_hFile);
            ASSERT(m_pCurrSendFileInfo->GetSize() == pMsg->m_FileSize);
            m_pCurrSendFileInfo->SetTotalSend(pMsg->m_BytesTransmitted);

            UpdateListView(m_pCurrSendFileInfo);
            UpdateStatusBar();
        }
        break;

    case iMBFT_FILE_SEND_END:
        if (NULL != m_pCurrSendFileInfo)
        {
            UpdateListView(m_pCurrSendFileInfo);
            UpdateStatusBar();
        }
        break;


    case iMBFT_FILE_RECEIVE_BEGIN:
        // fall through... because the file start PDU can have data.

    case iMBFT_FILE_RECEIVE_PROGRESS:
        pDlg = FindDlgByHandles(pMsg->m_EventHandle, pMsg->m_hFile);
        if (NULL != pDlg)
        {
            pDlg->OnProgressUpdate(pMsg);
        }
        break;

    case iMBFT_FILE_RECEIVE_END:
        // doing nothing...
        break;

    default:
        ASSERT(0);
        break;
    }
}


void CAppletWindow::HandleErrorNotify(FileErrorMsg *pMsg)
{
    MBFTFILEHANDLE nFileHandle = pMsg->m_hFile;
    if(LOWORD(nFileHandle) == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
    {
        nFileHandle = _iMBFT_PROSHARE_ALL_FILES;
    }

    if (m_nCurrSendEventHandle == pMsg->m_EventHandle &&
        m_pCurrSendFileInfo->GetFileHandle() == nFileHandle)
    {
        m_pCurrSendFileInfo->SetErrorCode((MBFT_ERROR_CODE) pMsg->m_ErrorCode);

        UINT idString;
        switch ((MBFT_ERROR_CODE) pMsg->m_ErrorCode)
        {
        case iMBFT_OK:
            idString = 0;
            break;
        case iMBFT_SENDER_ABORTED:
        case iMBFT_RECEIVER_ABORTED:
        case iMBFT_NO_MORE_FILES:
            idString = IDS_MSGBOX2_CANCELED;
            break;
        case iMBFT_MULT_RECEIVER_ABORTED:
            idString = IDS_MSGBOX2_MULT_CANCEL;
            break;
        // case iMBFT_RECEIVER_REJECTED:
        default:
            idString = IDS_MSGBOX2_SEND_FAILED;
            break;
        }
        if (idString)
        {
            if (! m_pCurrSendFileInfo->HasShownUI())
            {
                if (::MyLoadString(idString, s_szScratchText, m_pCurrSendFileInfo->GetName()))
                {
                    m_pCurrSendFileInfo->SetShowUI();
                    ::MsgBox2(this, s_szScratchText);
                }
                else
                {
                    ASSERT(0);
                }
            }
        }

        UpdateListView(m_pCurrSendFileInfo);
        UpdateStatusBar();

        ClearSendInfo(TRUE);
        if (! idString)
        {
            // send the next one now
			if (m_fSendALL)
			{
				::PostMessage(m_hwndMainUI, WM_SEND_NEXT, 0, 0);
			}
        }
    }
    else
    {
        CRecvDlg *pDlg = FindDlgByHandles(pMsg->m_EventHandle, nFileHandle);
        if (NULL != pDlg)
        {
            switch ((MBFT_ERROR_CODE) pMsg->m_ErrorCode)
            {
            case iMBFT_RECEIVER_ABORTED:
            case iMBFT_MULT_RECEIVER_ABORTED:
                pDlg->OnCanceled();
                break;
            default:
                pDlg->OnRejectedFile();
                break;
            }
        }
        else
        {
			switch((MBFT_ERROR_CODE) pMsg->m_ErrorCode)
            {
			case iMBFT_INVALID_PATH:
				::MyLoadString(IDS_MSGBOX2_INVALID_DIRECTORY,
					s_szScratchText, pMsg->m_stFileInfo.szFileName);
				break;

			case iMBFT_DIRECTORY_FULL_ERROR:
				::MyLoadString(IDS_MSGBOX2_DIRECTORY_FULL,
					s_szScratchText, pMsg->m_stFileInfo.lFileSize,
					pMsg->m_stFileInfo.szFileName);
				break;

			case iMBFT_FILE_ACCESS_DENIED:
				::MyLoadString(IDS_MSGBOX2_FILE_CREATE_FAILED,
					s_szScratchText, pMsg->m_stFileInfo.szFileName);
				break;

			default:
				return;
			}
			::MsgBox2(this, s_szScratchText);
        }
    }
}


void CAppletWindow::HandlePeerNotification(PeerMsg *pMsg)
{
	
	m_pToolbar->HandlePeerNotification(m_pEngine->GetConfID(),
								m_pEngine->GetNodeID(), pMsg);
}


void CAppletWindow::HandleInitUninitNotification(InitUnInitNotifyMsg *pMsg)
{
    if (pMsg->m_iNotifyMessage == EnumInvoluntaryUnInit)
    {
        UnregisterEngine();
    }
}


void CAppletWindow::HandleFileEventEndNotification(FileEventEndNotifyMsg *pMsg)
{
    if (m_nCurrSendEventHandle == pMsg->m_EventHandle)
    {
        ClearSendInfo(TRUE);
        // send the next one now
		if (m_fSendALL)
		{
			::PostMessage(m_hwndMainUI, WM_SEND_NEXT, 0, 0);
		}
    }
}



/////////////////////////////////////////////////////////////////
//
//  Main UI methods
//

void CAppletWindow::BringToFront(void)
{
    if (NULL != m_hwndMainUI)
    {
        int nCmdShow = SW_SHOW;

        WINDOWPLACEMENT wp;
        ::ZeroMemory(&wp, sizeof(wp));
        wp.length = sizeof(wp);

        if (::GetWindowPlacement(m_hwndMainUI, &wp))
        {
            if (SW_MINIMIZE == wp.showCmd || SW_SHOWMINIMIZED == wp.showCmd)
            {
                // The window is minimized - restore it:
                nCmdShow = SW_RESTORE;
            }
        }

        // show the window now
        ::ShowWindow(m_hwndMainUI, nCmdShow);
		m_UIMode = FTUIMODE_SHOWUI;
        // bring it to the foreground
        ::SetForegroundWindow(m_hwndMainUI);
    }
}


void CAppletWindow::ClearSendInfo(BOOL fUpdateUI)
{
    m_pCurrSendFileInfo = NULL;
    m_nCurrSendEventHandle = NULL;

    if (fUpdateUI)
    {
        UpdateUI();
    }
}


void CAppletWindow::ClearRecvInfo(void)
{
    CRecvDlg *pDlg;
    while (NULL != (pDlg = m_RecvDlgList.Get()))
    {
        ::EndDialog(pDlg->GetHwnd(), IDCLOSE);
        pDlg->Release();
    }
}


BOOL CAppletWindow::HasUnSentFiles(BOOL fUnSentOnly)
{
	BOOL  fRc = FALSE;
	ULONG	cItems = ListView_GetItemCount(m_hwndListView);
	CUiSendFileInfo *pFileInfo;
    LVITEM lvi;

	if (!fUnSentOnly && cItems) {
		return TRUE;
	}

    ::ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;  // examine each item one by one
    for (ULONG i = 0; i < cItems; i++, pFileInfo = NULL)
    {
		lvi.iItem = i;
        BOOL fRet = ListView_GetItem(m_hwndListView, &lvi);
        ASSERT(fRet);
        pFileInfo = (CUiSendFileInfo *) lvi.lParam;
        if (!pFileInfo->GetFileHandle())  // if file handle is not zero, then it has been sent or cancelled
        {
			fRc = TRUE;
            break;
        }
    }
    return fRc;
}


void CAppletWindow::UpdateUI(void)
{
    UpdateTitle();
    UpdateMenu();
    UpdateToolBar();
	UpdateStatusBar();
}


void CAppletWindow::UpdateTitle(void)
{
    UINT captionID;
    if ((! m_pEngine) || (m_pEngine->GetPeerCount() <= 1))
    {
        captionID = IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION;
    }
    else
    {
        captionID = IDS_MSFT_IN_CALL_WINDOW_CAPTION;
    }

    ::LoadString(g_hDllInst, captionID, s_szMSFT, sizeof(s_szMSFT));

    SetWindowText(m_hwndMainUI, s_szMSFT);
}


void CAppletWindow::UpdateMenu(void)
{
    HMENU hMenu = ::GetMenu(m_hwndMainUI);
    if (NULL != hMenu)
    {
        if (g_fSendAllowed)
        {
            BOOL fMoreThanOne = (NULL != m_pEngine) && (m_pEngine->GetPeerCount() > 1);
            ::EnableMenuItem(hMenu, IDM_ADD_FILES, fMoreThanOne ? MF_ENABLED : MF_GRAYED);

            ULONG cItems = ListView_GetItemCount(m_hwndListView);
            ::EnableMenuItem(hMenu, IDM_REMOVE_FILES, cItems ? MF_ENABLED : MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_SEND_ALL, (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(TRUE)) ? MF_ENABLED : MF_GRAYED);
			::EnableMenuItem(hMenu, IDM_SEND_ONE, (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(FALSE)) ? MF_ENABLED : MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_STOP_SENDING, m_nCurrSendEventHandle ? MF_ENABLED : MF_GRAYED);
        }
        else
        {
            ::EnableMenuItem(hMenu, IDM_ADD_FILES,    MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_REMOVE_FILES, MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_SEND_ALL,     MF_GRAYED);
			::EnableMenuItem(hMenu, IDM_SEND_ONE,	  MF_GRAYED);
            ::EnableMenuItem(hMenu, IDM_STOP_SENDING, MF_GRAYED);
        }
    }
}


void CAppletWindow::UpdateToolBar(void)
{
	int iFlags[count_of(buttons)];

	::ZeroMemory(iFlags, sizeof(iFlags));

	iFlags[2] = iFlags[5] = iFlags[6] = 1;  // separators
	iFlags[7] = 1;							// open recv folders

	
    if (g_fSendAllowed)
    {
		BOOL fMoreThanOne = (NULL != m_pEngine) && (m_pEngine->GetPeerCount() > 1);
        ULONG cItems = ListView_GetItemCount(m_hwndListView);
	
		iFlags[0] = fMoreThanOne ? TRUE : FALSE;		// Add files
		iFlags[1] = cItems ? TRUE : FALSE;				// Delete files
		iFlags[3] = (fMoreThanOne && ! m_nCurrSendEventHandle && HasUnSentFiles(TRUE)) ? TRUE : FALSE;	// Send file(s)
		iFlags[4] = m_nCurrSendEventHandle ? TRUE : FALSE;	// Stop sending

		m_pToolbar->UpdateButton(iFlags);
	}
    else
    {
		m_pToolbar->UpdateButton(iFlags);
    }
	
}


void CAppletWindow::UpdateStatusBar(void)
{
    int    idString, iPos = 0;
	HICON  hIcon;
	RECT	rc;

	// set the text in part 0
    s_szScratchText[0] = TEXT('\0');
    if ((NULL != m_pEngine) && (NULL != m_pCurrSendFileInfo))
    {
        idString = IDS_STBAR_SENDING_XYZ;
        ::MyLoadString(idString, s_szScratchText, m_pCurrSendFileInfo->GetName());
    }
    else if (NULL == m_pEngine)
    {
        ::MyLoadString(IDS_STBAR_NOT_IN_CALL);
    }
	else
	{
		::MyLoadString(IDS_STBAR_NOT_TRANSFERING);
	}
    ::SendMessage(m_hwndStatusBar, SB_SETTEXT, SBP_TRANSFER_FILE, (LPARAM) s_szScratchText);
	
	// set the progres bar in part 1
    if ((NULL != m_pCurrSendFileInfo)&&m_pCurrSendFileInfo->GetSize())
    {
        iPos = 100 * m_pCurrSendFileInfo->GetTotalSend() / m_pCurrSendFileInfo->GetSize();
    }
	::SendMessage(m_hwndStatusBar, SB_GETRECT, SBP_PROGRESS, (LPARAM)&rc);
	::MoveWindow(m_hwndProgressBar,
				rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
				FALSE);
	::SendMessage(m_hwndProgressBar, PBM_SETPOS, iPos, 0);
	
    // set the icon in part 2
	hIcon = (NULL != m_pEngine) ? m_hIconInCall : m_hIconNotInCall;
	::SendMessage(m_hwndStatusBar, SB_SETTEXT,  SBP_SBICON | SBT_OWNERDRAW,  (LPARAM)hIcon);
}


void CAppletWindow::UpdateListView(CUiSendFileInfo *pFileInfo)
{
    LVFINDINFO lvfi;
    ::ZeroMemory(&lvfi, sizeof(lvfi));
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) pFileInfo;
    int iItem = ListView_FindItem(m_hwndListView, -1, &lvfi);

    if (-1 != iItem)
    {
		for (ULONG i = 0; i < NUM_LIST_VIEW_COLUMNS; i++)
        {
            ListView_SetItemText(m_hwndListView, iItem, i, LPSTR_TEXTCALLBACK);
        }
    }
}

////////////////////////////////////////////////////////////////////
//
//   Save window position for File Transfer
//

void CAppletWindow::SaveWindowPosition(void)
{
    RECT    rcWnd;
    RegEntry    reWnd( FILEXFER_KEY, HKEY_CURRENT_USER);

	// If we are not maximized or minimized
    if (!::IsZoomed(m_hwndMainUI) && !::IsIconic(m_hwndMainUI))
    {
		::GetWindowRect(m_hwndMainUI, &rcWnd);

		reWnd.SetValue (REGVAL_WINDOW_XPOS, rcWnd.left);
		reWnd.SetValue (REGVAL_WINDOW_YPOS, rcWnd.top);
		reWnd.SetValue (REGVAL_WINDOW_WIDTH, rcWnd.right - rcWnd.left);
		reWnd.SetValue (REGVAL_WINDOW_HEIGHT, rcWnd.bottom - rcWnd.top);
	}
}

void CAppletWindow::FocusNextRecvDlg(void)
{
	if (!m_RecvDlgList.IsEmpty())
	{
		m_RecvDlgList.Reset();
		CRecvDlg *pRecvDlg = m_RecvDlgList.Iterate();
		if (pRecvDlg)
		{
			SetFocus(pRecvDlg->GetHwnd());
		}
	}
}

void CAppletWindow::FocusNextErrorDlg(void)
{
	if (!m_ErrorDlgList.IsEmpty())
	{
		m_ErrorDlgList.Reset();
		HWND hwndErrorDlg = m_ErrorDlgList.Iterate();
		if (hwndErrorDlg)
		{
			::SetFocus(hwndErrorDlg);
		}
	}
}

/////////////////////////////////////////////////////////////////
//
//  Utilities
//

LPTSTR PathNameToFileName(LPTSTR pszPathName)
{
    LPTSTR psz = pszPathName;
    while (*psz != '\0')
    {
        BOOL fDirChar = (*psz == TEXT('\\'));
        psz = ::CharNext(psz);
        if (fDirChar)
        {
            pszPathName = psz;
        }
    }
    return pszPathName;
}


int MyLoadString(UINT idStr)
{
    s_szScratchText[0] = TEXT('\0');
    int iRet = ::LoadString(g_hDllInst, idStr, s_szScratchText, MAX_PATH);
    ASSERT(iRet);
    return iRet;
}


int MyLoadString(UINT idStr, LPTSTR pszDstStr)
{
    *pszDstStr = TEXT('\0');
    int iRet = ::LoadString(g_hDllInst, idStr, pszDstStr, MAX_PATH);
    ASSERT(iRet);
    return iRet;
}


int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement)
{
    int cch;
    TCHAR szText[MAX_PATH];

    cch = ::LoadString(g_hDllInst, idStr, szText, count_of(szText));
    if (cch)
    {
        ::wsprintf(pszDstStr, szText, pszElement);
    }
    else
    {
        ASSERT(0);
        *pszDstStr = TEXT('\0');
    }
    return cch;
}


int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement1, LPTSTR pszElement2)
{
    int cch;
    TCHAR szText[MAX_PATH];

    cch = ::LoadString(g_hDllInst, idStr, szText, count_of(szText));
    if (cch)
    {
        ::wsprintf(pszDstStr, szText, pszElement1, pszElement2);
    }
    else
    {
        ASSERT(0);
        *pszDstStr = TEXT('\0');
    }
    return cch;
}


void LoadDefaultStrings(void)
{
    // load file transfer name
    s_szMSFT[0] = TEXT('\0');
    ::LoadString(g_hDllInst, IDS_MSFT_NOT_IN_CALL_WINDOW_CAPTION,
                s_szMSFT, count_of(s_szMSFT));
}


/////////////////////////////////////////////////////////////////
//
//  CUiSendFileInfo
//

CUiSendFileInfo::CUiSendFileInfo(CAppletWindow *pWindow, TCHAR szDir[], TCHAR szFile[], BOOL *pfRet)
:
    m_nFileHandle(0),
    m_cbTotalSend(0),
    m_eSendErrorCode(iMBFT_OK),
    m_fAlreadyShowUI(FALSE),
	m_pszFullName(NULL)
{
    *pfRet = FALSE; // failure as default
	HANDLE hFile;

    // build a full name
	hFile = GetOpenFile(pWindow, szDir, szFile, TRUE);  // try to resolve
	if (INVALID_HANDLE_VALUE == hFile)
	{
		hFile = GetOpenFile(pWindow, szDir, szFile, FALSE);
	}
	
	if (INVALID_HANDLE_VALUE != hFile)
    {
        // get the file info
        ::ZeroMemory(&m_FileInfo, sizeof(m_FileInfo));
        BOOL rc = ::GetFileInformationByHandle(hFile, &m_FileInfo);
        ::CloseHandle(hFile);
        if (rc)
        {
            ASSERT(0 == m_FileInfo.nFileSizeHigh);

            // make sure the file size is smaller than what the policy says
            if ((! g_cbMaxSendFileSize) || GetSize() <= g_cbMaxSendFileSize * 1024)
            {
                *pfRet = TRUE;
            }
            else if (pWindow->GetUIMode() != FTUIMODE_NOUI)
            {
                ::MyLoadString(IDS_MSGBOX_SEND_BIG_FILE, s_szScratchText, (LPTSTR) g_cbMaxSendFileSize, m_pszFileName);
                ::MessageBox(pWindow->GetHwnd(), s_szScratchText, s_szMSFT, MB_OK | MB_ICONSTOP);
            }
        }
    }
}


CUiSendFileInfo::~CUiSendFileInfo(void)
{
    delete m_pszFullName;
}


HANDLE CUiSendFileInfo::GetOpenFile(CAppletWindow *pWindow, TCHAR szDir[], TCHAR szFile[], BOOL fResolve)
{
    // build a full name
    ULONG cch;
    TCHAR szName[MAX_PATH*2];
	HANDLE hFile = INVALID_HANDLE_VALUE;

    if ((NULL != szDir)&&(!_StrChr(szFile, '\\')))
    {
        cch = ::lstrlen(szDir);
        ::wsprintf(szName, (TEXT('\\') == szDir[cch-1]) ? TEXT("%s%s") : TEXT("%s\\%s"), szDir, szFile);
    }
    else
    {
        // file name is the full name
        ::lstrcpy(szName, szFile);
    }

    // resolve shortcut if necessary
    cch = ::lstrlen(szName) + 1;
    if (fResolve&&(cch >= 4))
    {
        if (! ::lstrcmpi(&szName[cch-5], TEXT(".lnk")))
        {
            pWindow->ResolveShortcut(szName, szName);
            cch = ::lstrlen(szName) + 1;
        }
    }

	if (m_pszFullName)
	{
		delete [] m_pszFullName;
	}

    // construct the full name
    DBG_SAVE_FILE_LINE
    m_pszFullName = new TCHAR[cch];
    if (NULL != m_pszFullName)
    {
        ::CopyMemory(m_pszFullName, szName, cch * sizeof(TCHAR));
        m_pszFileName = ::PathNameToFileName(m_pszFullName);

        // open the file
        hFile = ::CreateFile(m_pszFullName, GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,  OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL, NULL);	
	}
	return hFile;
}


/////////////////////////////////////////////////////////////////
//
//  CUiRecvFileInfo
//

CUiRecvFileInfo::CUiRecvFileInfo(FileOfferNotifyMsg *pMsg, HRESULT *pHr)
:
    m_nFileHandle(pMsg->m_hFile),
    m_FileDateTime(pMsg->m_FileDateTime),
    m_cbFileSize(pMsg->m_FileSize),
    m_cbTotalRecvSize(0),
    m_pszFullName(NULL),
    m_pszRecvFolder(NULL)
{
    *pHr = E_FAIL; // failure, at default

	ULONG cchTotal = ::lstrlen(pMsg->m_szFileName);

	// construct the full name
	DBG_SAVE_FILE_LINE
	m_pszFullName = new TCHAR[cchTotal+2];
	if (NULL != m_pszFullName)
	{
		// construct full name and file name
		::wsprintf(m_pszFullName, TEXT("%s"), pMsg->m_szFileName);
		m_pszFileName = PathNameToFileName(m_pszFullName);
		ULONG cchFile = ::lstrlen(m_pszFileName);
		DBG_SAVE_FILE_LINE
		m_pszRecvFolder = new TCHAR[cchTotal - cchFile + 2];
		if (NULL != m_pszRecvFolder)
		{
			::CopyMemory(m_pszRecvFolder, m_pszFullName, cchTotal - cchFile);
			m_pszRecvFolder[cchTotal - cchFile - 1] = TEXT('\0');
			*pHr = S_OK;
		}
	}
}


CUiRecvFileInfo::~CUiRecvFileInfo(void)
{
    delete m_pszFullName;
    delete m_pszRecvFolder;
}


/////////////////////////////////////////////////////////////////
//
//  Receive Dialog
//

CRecvDlg::CRecvDlg
(
    CAppletWindow      *pWindow,
    T120ConfID          nConfID,
    T120NodeID          nidSender,
    MBFTEVENTHANDLE     nEventHandle,
    CUiRecvFileInfo    *pFileInfo,
    HRESULT            *pHr
)
:
    CRefCount(MAKE_STAMP_ID('F','T','R','D')),
    m_pWindow(pWindow),
    m_nConfID(nConfID),
    m_nidSender(nidSender),
    m_nEventHandle(nEventHandle),
    m_pRecvFileInfo(pFileInfo),
    m_fRecvComplete(FALSE),
    m_fShownRecvCompleteUI(FALSE),
    m_idResult(0),
    m_dwEstTimeLeft(0),
    m_dwPreviousTime(0),
    m_dwPreviousTransferred(0),
    m_dwBytesPerSec(0),
    m_dwStartTime(::GetTickCount())
{
    *pHr = E_FAIL; // failure, at default

    m_hwndRecvDlg = ::CreateDialogParam(g_hDllInst, MAKEINTRESOURCE(IDD_RECVDLG),
                            pWindow->GetHwnd(), RecvDlgProc, (LPARAM) this);
    ASSERT(NULL != m_hwndRecvDlg);
    if (NULL != m_hwndRecvDlg)
    {
        ::ShowWindow(m_hwndRecvDlg, SW_SHOWNORMAL);
        m_pWindow->RegisterRecvDlg(this);
        *pHr = S_OK;
		::SetForegroundWindow(m_hwndRecvDlg);
    }
}


CRecvDlg::~CRecvDlg(void)
{
    delete m_pRecvFileInfo;

    m_pWindow->UnregisterRecvDlg(this);

    if (NULL != m_hwndRecvDlg)
    {
        HWND hwnd = m_hwndRecvDlg;
        m_hwndRecvDlg = NULL;
        ::EndDialog(hwnd, IDCLOSE);
    }
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg_OnInitDialog
//

void RecvDlg_OnInitDialog(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    CRecvDlg *pDlg = (CRecvDlg *) ::GetWindowLongPtr(hdlg, DWLP_USER);
    ASSERT(NULL != pDlg);

    CUiRecvFileInfo *pFileInfo = (CUiRecvFileInfo *) pDlg->GetRecvFileInfo();
    ASSERT(NULL != pFileInfo);

    // move the window to proper location
    ULONG nCaptionHeight = ::GetSystemMetrics(SM_CYCAPTION);
    ULONG nShift = nCaptionHeight * (s_cRecvDlg++ % 8);
    RECT rcDlg;
    ::GetWindowRect(hdlg, &rcDlg);
    ::MoveWindow(hdlg, rcDlg.left + nShift, rcDlg.top + nShift,
                 rcDlg.right - rcDlg.left, rcDlg.bottom - rcDlg.top, FALSE);

    // Set font (for international)
    HFONT hfont = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);
    ASSERT(NULL != hfont);
    ::SendDlgItemMessage(hdlg, IDE_RECVDLG_RECFILE, WM_SETFONT, (WPARAM) hfont, 0);
    ::SendDlgItemMessage(hdlg, IDE_RECVDLG_RECDIR,  WM_SETFONT, (WPARAM) hfont, 0);
    ::SendDlgItemMessage(hdlg, IDE_RECVDLG_SENDER,  WM_SETFONT, (WPARAM) hfont, 0);

    // cache names
    LPTSTR pszFileName = pFileInfo->GetName();
    LPTSTR pszFullName = pFileInfo->GetFullName();

    // title
    TCHAR szText[MAX_PATH*2];
    if (::MyLoadString(IDS_RECVDLG_TITLE, szText, pszFileName))
    {
        ::SetWindowText(hdlg, szText);
    }

    // filename
    ::lstrcpyn(szText, pszFileName, MAX_FILE_NAME_LENGTH);
    if (::lstrlen(pszFileName) > MAX_FILE_NAME_LENGTH)
    {
		LPTSTR psz = szText;
        int i = MAX_FILE_NAME_LENGTH - 1;
        while (i)
        {
            psz = CharNext(psz);
            i--;
        }
        ::lstrcpy(psz, TEXT("..."));
    }
    ::SetDlgItemText(hdlg, IDE_RECVDLG_RECFILE, szText);

    // directory Name
    LPTSTR psz = szText;
    ::lstrcpyn(szText, pszFullName, (int)(pszFileName - pszFullName));
    HDC hdc = ::GetDC(hdlg);
    if (NULL != hdc)
    {
        SIZE size;
        if (::GetTextExtentPoint32(hdc, szText, ::lstrlen(szText), &size))
        {
            RECT rc;
            ::GetWindowRect(::GetDlgItem(hdlg, IDE_RECVDLG_RECDIR), &rc);
            if (size.cx > (rc.right - rc.left))
            {
                // Just display the folder name
                psz = (LPTSTR) ::GetFileNameFromPath(szText);
            }
        }
    }
    ::ReleaseDC(hdlg, hdc);
    ::SetDlgItemText(hdlg, IDE_RECVDLG_RECDIR, psz);

    // sender Name
    if (::T120_GetNodeName(pDlg->GetConfID(), pDlg->GetSenderID(), szText, count_of(szText)))
    {
        ::SetDlgItemText(hdlg, IDE_RECVDLG_SENDER, szText);
    }

    // update "Received xxx bytes of yyy"
    if (::MyLoadString(IDS_RECVDLG_RECBYTES, szText, pFileInfo->GetTotalRecvSize(), pFileInfo->GetSize()))
    {
        ::SetDlgItemText(hdlg, IDE_RECVDLG_RECBYTES, szText);
    }

    // progress bar
    ::SendMessage(GetDlgItem(hdlg, IDC_RECVDLG_PROGRESS), PBM_SETPOS, pDlg->GetPercent(), 0);

    // start animation
    Animate_Open(GetDlgItem(hdlg, IDC_RECVDLG_ANIMATE), MAKEINTRESOURCE(IDA_RECVDLG_ANIMATION));

    // do the animation work
    if (! pDlg->IsRecvComplete())
    {
        Animate_Play(GetDlgItem(hdlg, IDC_RECVDLG_ANIMATE), 0, -1, -1);
        if (::LoadString(g_hDllInst, IDS_RECVDLG_START, szText, count_of(szText)))
        {
            ::SetDlgItemText(hdlg, IDE_RECVDLG_TIME, szText);
        }
    }

    // show the window now
    ::ShowWindow(hdlg, SW_SHOWNORMAL);

    // UpdateProgress();
    pDlg->OnProgressUpdate();
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg_OnCommand
//

void RecvDlg_OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    CRecvDlg *pDlg = (CRecvDlg *) ::GetWindowLongPtr(hdlg, DWLP_USER);
    ASSERT(NULL != pDlg);

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case IDM_RECVDLG_DELETE:
        pDlg->OnDelete();
        break;

    case IDM_RECVDLG_OPEN:
        pDlg->OnOpen();
        break;

    case IDM_RECVDLG_ACCEPT:
    case IDOK:
    case IDCANCEL:
    case IDCLOSE:
        pDlg->OnAccept();
        break;

    default:
        return;
    }

    // dismiss the dialog
    ::EndDialog(hdlg, GET_WM_COMMAND_ID(wParam, lParam));
    pDlg->Release();
}


void CRecvDlg::OnOpen(void)
{
	// create short version of the path name
	TCHAR szDir[MAX_PATH];
	::GetShortPathName(m_pRecvFileInfo->GetRecvFolder(), szDir, count_of(szDir));

	// create short version of the full name
	TCHAR szFile[MAX_PATH];
	szFile[0] = TEXT('\0');
	::wsprintf(szFile, TEXT("%s\\%s"), szDir, m_pRecvFileInfo->GetName());

	TRACE_OUT(("FT: Opening [%s] in [%]", m_pRecvFileInfo->GetName(), szDir));

	HINSTANCE hInst = ::ShellExecute(m_pWindow->GetHwnd(),
									 NULL,
									 szFile,
									 NULL,
									 szDir,
									 SW_SHOWDEFAULT);
	if (32 >= (DWORD_PTR) hInst)
	{
		WARNING_OUT(("Unable to open [%s] - showing file", szFile));
		::ShellExecute(m_pWindow->GetHwnd(),
					   NULL,
					   szDir,
					   m_pRecvFileInfo->GetFullName(),
					   NULL,
					   SW_SHOWDEFAULT);
	}
}


void CRecvDlg::OnDelete(void)
{
	StopAnimation();

    // check if transfer has completed
    if (! m_fRecvComplete)
    {
        DBG_SAVE_FILE_LINE
        m_pWindow->GetEngine()->SafePostMessage(
                    new FileTransferControlMsg(
                                        m_nEventHandle,
                                        m_pRecvFileInfo->GetFileHandle(),
                                        NULL,
                                        NULL,
                                        FileTransferControlMsg::EnumAbortFile));
    }
    else
    {
		::DeleteFile(m_pRecvFileInfo->GetFullName());
    }
}


void CRecvDlg::OnAccept(void)
{
    StopAnimation();
}



/////////////////////////////////////////////////////////////////
//
//  RecvDlg_OnInitMenuPopup
//

void RecvDlg_OnInitMenuPopup(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    if (0 != HIWORD(lParam)) // System menu flag
    {
        HMENU hMenu = (HMENU) wParam;         // handle of pop-up menu
        ::EnableMenuItem(hMenu, SC_MAXIMIZE, MF_GRAYED);
        ::EnableMenuItem(hMenu, SC_SIZE, MF_GRAYED);
    }
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlgProc
//

INT_PTR CALLBACK RecvDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE; // processed

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ASSERT(NULL != lParam);
        ::SetWindowLongPtr(hdlg, DWLP_USER, lParam);
        RecvDlg_OnInitDialog(hdlg, wParam, lParam);
        break;

    case WM_COMMAND:
        RecvDlg_OnCommand(hdlg, wParam, lParam);
        break;

   case WM_INITMENUPOPUP:
        RecvDlg_OnInitMenuPopup(hdlg, wParam, lParam);
        fRet = FALSE;
        break;

		// This means user wants to delete the file.
   case WM_CLOSE:
	   RecvDlg_OnCommand(hdlg, IDCLOSE, lParam);
	   break;;

    default:
        fRet = FALSE; // not processed
        break;
    }

    return fRet;
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg Animation
//

void CRecvDlg::StopAnimation(void)
{
    HWND hwnd = ::GetDlgItem(m_hwndRecvDlg, IDC_RECVDLG_ANIMATE);
    if (NULL != hwnd)
    {
        Animate_Stop(hwnd);
        Animate_Close(hwnd);
    }
}


/////////////////////////////////////////////////////////////////
//
//  RecvDlg Progress
//

ULONG CRecvDlg::GetPercent(void)
{
    ULONG cbFileSize = m_pRecvFileInfo->GetSize();
    ULONG cbTotalRecvSize = m_pRecvFileInfo->GetTotalRecvSize();

    if (! cbFileSize || (cbTotalRecvSize >= cbFileSize))
    {
        return 100;
    }

    // FUTURE: Consider using EnlargedUnsignedMultiply

    if (cbFileSize < 0x01000000)
    {
        return (cbTotalRecvSize * 100) / cbFileSize;
    }

    return cbTotalRecvSize / (cbFileSize / 100);
}


void CRecvDlg::OnProgressUpdate(FileTransmitMsg *pMsg)
{

    if (NULL != pMsg)
    {
        ASSERT(iMBFT_FILE_RECEIVE_PROGRESS == (MBFT_NOTIFICATION) pMsg->m_TransmitStatus ||
               iMBFT_FILE_RECEIVE_BEGIN    == (MBFT_NOTIFICATION) pMsg->m_TransmitStatus);

        ASSERT(m_nEventHandle == pMsg->m_EventHandle);
        ASSERT(m_pRecvFileInfo->GetFileHandle() == pMsg->m_hFile);
        ASSERT(m_pRecvFileInfo->GetSize() == pMsg->m_FileSize);

        m_pRecvFileInfo->SetTotalRecvSize(pMsg->m_BytesTransmitted);

        if (pMsg->m_BytesTransmitted >= pMsg->m_FileSize)
        {
            m_fRecvComplete = TRUE;
            m_idResult = IDS_RECVDLG_COMPLETE;
        }
    }

    if (m_fRecvComplete && ! m_fShownRecvCompleteUI)
    {
        m_fRecvComplete = TRUE;

        TCHAR szText[MAX_PATH];
        if (::LoadString(g_hDllInst, IDS_RECVDLG_CLOSE, szText, count_of(szText)))
        {
            ::SetDlgItemText(m_hwndRecvDlg, IDM_RECVDLG_ACCEPT, szText);
        }

        if (IDS_RECVDLG_COMPLETE == m_idResult)
        {
            ::EnableWindow(::GetDlgItem(m_hwndRecvDlg, IDM_RECVDLG_OPEN), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwndRecvDlg, IDM_RECVDLG_DELETE), FALSE);
        }

        // Reset animation
        HWND hwnd = ::GetDlgItem(m_hwndRecvDlg, IDC_RECVDLG_ANIMATE);
        Animate_Stop(hwnd);
        Animate_Close(hwnd);
        Animate_Open(hwnd, MAKEINTRESOURCE(IDA_RECVDLG_DONE));
        Animate_Seek(hwnd, ((IDS_RECVDLG_COMPLETE == m_idResult) ? 0 : 1));

        m_fShownRecvCompleteUI = TRUE;
    }

    ULONG cbTotalRecvSize = m_pRecvFileInfo->GetTotalRecvSize();
    ULONG cbFileSize = m_pRecvFileInfo->GetSize();

    DWORD dwNow = ::GetTickCount();
    DWORD dwBytesPerSec;
    DWORD dwBytesRead;
    TCHAR szOut[MAX_PATH];

    if (m_dwPreviousTransferred != cbTotalRecvSize)
    {
        TCHAR szFmt[MAX_PATH];

        // Update "Received xxx bytes of yyy"
        if (::LoadString(g_hDllInst, IDS_RECVDLG_RECBYTES, szFmt, count_of(szFmt)))
        {
            ::wsprintf(szOut, szFmt, cbTotalRecvSize, cbFileSize);
            ::SetDlgItemText(m_hwndRecvDlg, IDE_RECVDLG_RECBYTES, szOut);
        }

        // Update Progress Bar
        if (cbTotalRecvSize)
        {
            ::SendMessage(GetDlgItem(m_hwndRecvDlg, IDC_RECVDLG_PROGRESS), PBM_SETPOS, GetPercent(), 0);
        }
    }

    // check if no time estimate is required
    if (m_fRecvComplete)
    {
        if (::LoadString(g_hDllInst, m_idResult, szOut, count_of(szOut)))
        {
            ::SetDlgItemText(m_hwndRecvDlg, IDE_RECVDLG_TIME, szOut);
        }
        return;
    }

    // first time we're in here for this file?
    if (! m_dwPreviousTime || ! cbTotalRecvSize)
    {
        // no data, yet
        m_dwPreviousTime = dwNow - 1000;
        ASSERT(! m_dwPreviousTransferred);
        ASSERT(! m_dwBytesPerSec);
        return;
    }

    // Has enough time elapsed to update the display?
    // We do this about every 5 seconds (note the adjustment for first time)
    if ((dwNow - m_dwPreviousTime) < 5000)
        return;

    dwBytesRead = cbTotalRecvSize - m_dwPreviousTransferred;

    // We take 10 times the number of bytes and divide by the number of
    // tenths of a second to minimize both overflow and roundoff
    dwBytesPerSec = dwBytesRead * 10 / ((dwNow - m_dwPreviousTime) / 100);
    if (! dwBytesPerSec)
    {
        // very low transmission rate!  Ignore the information?
        return;
    }
    if (m_dwBytesPerSec)
    {
        // Take the average of the current transfer rate and the
        // previously computed one, just to try to smooth out
        // some random fluctuations
        dwBytesPerSec = (dwBytesPerSec + m_dwBytesPerSec) / 2;
    }
    m_dwBytesPerSec = dwBytesPerSec;

    // Calculate time remaining (round up by adding 1)
    m_dwEstTimeLeft = ((cbFileSize - cbTotalRecvSize) / m_dwBytesPerSec) + 1;

    // Reset time and # of bytes read
    m_dwPreviousTime = dwNow;
    m_dwPreviousTransferred = cbTotalRecvSize;

    if (m_dwEstTimeLeft < 3)
    {
//        szOut[0] = _T('\0');  // don't bother updating when almost done
        return;
    }
    if (m_dwEstTimeLeft > 99)
    {
        // dwTime is about 2 mintes
        ::MyLoadString(IDS_RECVDLG_MINUTES, szOut, ((m_dwEstTimeLeft / 60) + 1));
    }
    else
    {
        // Round up to 5 seconds so it doesn't look so random
        ::MyLoadString(IDS_RECVDLG_SECONDS, szOut, (((m_dwEstTimeLeft + 4) / 5) * 5) );
    }

    ::SetDlgItemText(m_hwndRecvDlg, IDE_RECVDLG_TIME, szOut);
}


void CRecvDlg::OnCanceled(void)
{
    m_idResult = IDS_RECVDLG_CANCEL;
    m_fRecvComplete = TRUE;
    OnProgressUpdate();
}


void CRecvDlg::OnRejectedFile(void)
{
    m_idResult = IDS_RECVDLG_SENDER_CANCEL;
    m_fRecvComplete = TRUE;
    OnProgressUpdate();
}



//////////////////////////////////////////////////////////////////////
//
// Shortcut/Link Management
//

void CAppletWindow::ResolveShortcut(LPTSTR pszSrcFile, LPTSTR pszDstFile)
{
    ASSERT(NULL != pszSrcFile && '\0' != *pszSrcFile);
    ASSERT(NULL != pszDstFile);

    IShellLink *psl;
    HRESULT hr = ::CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IShellLink, (LPVOID *) &psl);
    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;
        hr = psl->QueryInterface(IID_IPersistFile, (LPVOID *) &ppf);
        if (SUCCEEDED(hr))
        {
            WCHAR wsz[MAX_PATH]; /* Buffer for unicode string */
#ifdef _UNICODE
            ::lstrcpyn(wsz, pszSrcFile, MAX_PATH);
#else
            ::MultiByteToWideChar(CP_ACP, 0, pszSrcFile, -1, wsz, MAX_PATH);
#endif

            hr = ppf->Load(wsz, STGM_READ);
            if (SUCCEEDED(hr))
            {
                /* Resolve the link, this may post UI to find the link */
                hr = psl->Resolve(m_hwndMainUI, SLR_ANY_MATCH);
                if (SUCCEEDED(hr))
                {
                    psl->GetPath(pszDstFile, MAX_PATH, NULL, 0);
                }

                TRACE_OUT(("CAppletWindow::ResolveShortcut: File resolved to [%s]", pszDstFile));
            }
            ppf->Release();
        }
        psl->Release();
    }
}


/////////////////////////////////////////////////////////////////
//
//  Non-blocking Message Box
//

INT_PTR MsgBox2DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;
	CAppletWindow *pWindow;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // get the text to display
            LPTSTR pszText = (LPTSTR) lParam;
            ASSERT(NULL != pszText && TEXT('\0') != *pszText);

            // estimate how big the read-only edit control should be
            HDC hdc = ::GetDC(hdlg);
            if (NULL != hdc)
            {
                SIZE csEdit;
                if (::GetTextExtentPoint32(hdc, pszText, ::lstrlen(pszText), &csEdit))
                {
                    const ULONG c_nMarginX = 0;
                    const ULONG c_nMarginY = 10;

                    ULONG nCaptionHeight = ::GetSystemMetrics(SM_CYCAPTION);
                    ULONG nShift = nCaptionHeight * (s_cMsgBox2Dlg++ % 8);

                    // move the edit control
                    HWND hwndEdit = ::GetDlgItem(hdlg, IDE_MSGBOX2_TEXT);
                    POINT ptEdit;
                    ptEdit.x = c_nMarginX;
                    ptEdit.y = c_nMarginY + (c_nMarginY >> 1);
                    csEdit.cx += c_nMarginX << 1;
                    csEdit.cy += c_nMarginY << 1;
                    ::MoveWindow(hwndEdit, ptEdit.x, ptEdit.y, csEdit.cx, csEdit.cy, FALSE);

                    // move the ok button
                    HWND hwndOK = ::GetDlgItem(hdlg, IDOK);
                    RECT rcOK;
                    ::GetWindowRect(hwndOK, &rcOK);
                    SIZE csOK;
                    csOK.cx = rcOK.right - rcOK.left;
                    csOK.cy = rcOK.bottom - rcOK.top;
                    POINT ptOK;
                    ptOK.x = ptEdit.x + (csEdit.cx >> 1) - (csOK.cx >> 1);
                    ptOK.y = ptEdit.y + csEdit.cy + (c_nMarginY >> 1);
                    ::MoveWindow(hwndOK, ptOK.x, ptOK.y, csOK.cx, csOK.cy, FALSE);

                    // adjust all the windows
                    RECT rcDlg, rcClient;
                    ::GetWindowRect(hdlg, &rcDlg);
                    POINT ptDlg;
                    ptDlg.x = rcDlg.left + nShift;
                    ptDlg.y = rcDlg.top + nShift;
                    ::GetClientRect(hdlg, &rcClient);
                    SIZE csDlg;
                    csDlg.cx = (rcDlg.right - rcDlg.left) - (rcClient.right - rcClient.left);
                    csDlg.cy = (rcDlg.bottom - rcDlg.top) - (rcClient.bottom - rcClient.top);
                    csDlg.cx += ptEdit.x + csEdit.cx + c_nMarginX;
                    csDlg.cy += ptOK.y + csOK.cy + c_nMarginY;
                    ::MoveWindow(hdlg, ptDlg.x, ptDlg.y, csDlg.cx, csDlg.cy, FALSE);
                }
                ::ReleaseDC(hdlg, hdc);
            }

            ::SetDlgItemText(hdlg, IDE_MSGBOX2_TEXT, pszText);
            delete [] pszText; // free the display text
            fHandled = TRUE;
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
        case IDCANCEL:
        case IDCLOSE:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
				pWindow = (CAppletWindow*)::GetWindowLongPtr(hdlg, DWLP_USER);
				ASSERT (pWindow);
				if (pWindow)
				{
					pWindow->RemoveErrorDlg(hdlg);	
					pWindow->FocusNextErrorDlg();
				}
                ::EndDialog(hdlg, IDOK);
                break;
            }
            break;
        }

        fHandled = TRUE;
        break;
    }

    return(fHandled);
}


BOOL MsgBox2(CAppletWindow *pWindow, LPTSTR pszText)
{
    BOOL fRet = FALSE;
    ULONG cch = ::lstrlen(pszText) + 1;
    DBG_SAVE_FILE_LINE
    LPTSTR pszNew = new TCHAR[cch];
    if (NULL != pszNew)
    {
        ::CopyMemory(pszNew, pszText, cch);
        HWND hwndDlg = ::CreateDialogParam(g_hDllInst, MAKEINTRESOURCE(IDD_MSGBOX2),
                            pWindow->GetHwnd(), MsgBox2DlgProc, (LPARAM) pszNew);

        ASSERT(NULL != hwndDlg);
        if (NULL != hwndDlg)
        {
            ::ShowWindow(hwndDlg, SW_SHOWNORMAL);
            fRet = TRUE;
            ::SetForegroundWindow(hwndDlg);
			::SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)pWindow);
			pWindow->AddErrorDlg(hwndDlg);
        }
    }
    else
    {
        ERROR_OUT(("FT::MsgBox2: cannot duplicate string [%s]", pszText));
    }
    return fRet;
}


/////////////////////////////////////////////////////////////////
//
//  Receive Folder Management
//

HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr)
{
    LPTSTR psz;
    TCHAR szPath[MAX_PATH];

    RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);

    if (NULL == pszInFldr)
    {
        // NULL directory specified - get info from registry or use default
        psz = reFileXfer.GetString(REGVAL_FILEXFER_PATH);
        if (NULL != psz && TEXT('\0') != *psz)
        {
            ::lstrcpyn(szPath, psz, count_of(szPath));
        }
        else
        {
            TCHAR szInstallDir[MAX_PATH];
            ::GetInstallDirectory(szInstallDir);
            ::MyLoadString(IDS_RECDIR_DEFAULT, szPath, szInstallDir);
        }

        pszInFldr = szPath;
    }

    ::lstrcpyn(pszOutFldr, pszInFldr, MAX_PATH);

    // Remove trailing backslash, if any
    for (psz = pszOutFldr; *psz; psz = CharNext(psz))
    {
        if ('\\' == *psz && '\0' == *CharNext(psz))
        {
            *psz = '\0';
            break;
        }
    }

    HRESULT hr;
    if (!FEnsureDirExists(pszOutFldr))
    {
        WARNING_OUT(("ChangeRecDir: FT directory is invalid [%s]", pszOutFldr));
        hr = E_FAIL;
    }
    else
    {
        // update the registry
        reFileXfer.SetValue(REGVAL_FILEXFER_PATH, pszOutFldr);
        hr = S_OK;
    }
    return hr;
}


void EnsureTrailingSlash(LPTSTR psz)
{
    LPTSTR psz2;

    // Make sure the directory name has a trailing '\'
    while (TEXT('\0') != *psz)
    {
        psz2 = ::CharNext(psz);
        if (TEXT('\\') == *psz && TEXT('\0') == *psz2)
        {
            // The path already ends with a backslash
            return;
        }
        psz = psz2;
    }

    // Append a trailing backslash
    *psz = TEXT('\\');
	psz = ::CharNext(psz);
	*psz = TEXT('\0');
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\localver.h ===
/* Version resource specific to msconfft.exe */

#define VER_DESCRIPTION_STR  "Conferencing File Transfer Utility\0"
#define VER_INTERNALNAME_STR "MsConfFt\0"
#define VER_ORIGNAME_STR     "MsConfFt.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ftui.h ===
#ifndef _FT_MAIN_UI_H_
#define _FT_MAIN_UI_H_

#include "ftres.h"
#include "combotb.h"
#if defined(TEST_PLUGABLE) && defined(_DEBUG)
#include "plugable.h"
#endif


#define WM_SEND_NEXT            (WM_APP + 0x201)
#define WM_BRING_TO_FRONT       (WM_APP + 0x202)


#define NUM_STATUS_BAR_PARTS    3
#define SBP_TRANSFER_FILE		0
#define SBP_PROGRESS			1
#define SBP_SBICON				2

typedef struct
{
    ULONG   idString;
    ULONG   idCommand;
    UINT    nFlags;
}
    UI_MENU_INFO;

typedef enum
{
	FTUIMODE_SHOWUI = 0,
	FTUIMODE_UIHIDDEN,
	FTUIMODE_NOUI,
}	
	FTUIMode;

class CAppletWindow;

class CUiSendFileInfo
{
public:

    CUiSendFileInfo(CAppletWindow *, TCHAR szDir[], TCHAR szFile[], BOOL *pfRet);
    ~CUiSendFileInfo(void);

    // name
    LPTSTR GetFullName(void) { return m_pszFullName; }
    LPTSTR GetName(void) { return m_pszFileName; }

    // numbers
    ULONG GetSize(void) { return m_FileInfo.nFileSizeLow; }
    DWORD GetFileAttribute(void) { return m_FileInfo.dwFileAttributes; }
	FILETIME GetLastWrite(void) { return m_FileInfo.ftLastWriteTime; }
    ULONG GetTotalSend(void) { return m_cbTotalSend; }
    void SetTotalSend(ULONG cb) { m_cbTotalSend = cb; }

    // time
    FILETIME *GetLastWriteTime(void) { return &m_FileInfo.ftLastWriteTime; }
    FILETIME *GetLastAccessTime(void) { return &m_FileInfo.ftLastAccessTime; }
    FILETIME *GetCreationTime(void) { return &m_FileInfo.ftCreationTime; }

    // file handle
    MBFTFILEHANDLE GetFileHandle(void) { return m_nFileHandle; }
    void SetFileHandle(MBFTFILEHANDLE nFileHandle) { m_nFileHandle = nFileHandle; }

    // error code
    MBFT_ERROR_CODE GetErrorCode(void) { return m_eSendErrorCode; }
    void SetErrorCode(MBFT_ERROR_CODE err) { m_eSendErrorCode = err; }

    void SetShowUI(void) { m_fAlreadyShowUI = TRUE; }
    BOOL HasShownUI(void) { return m_fAlreadyShowUI; }

private:
	HANDLE GetOpenFile(CAppletWindow *, TCHAR szDir[], TCHAR szFile[], BOOL fResolve);

    LPTSTR          m_pszFullName; // allocated
    LPTSTR          m_pszFileName; // handy shortcut

    ULONG           m_cbTotalSend;
    MBFTFILEHANDLE  m_nFileHandle;

    MBFT_ERROR_CODE m_eSendErrorCode;

    BOOL            m_fAlreadyShowUI;

    BY_HANDLE_FILE_INFORMATION  m_FileInfo;
};


class CUiRecvFileInfo
{
public:

    CUiRecvFileInfo(FileOfferNotifyMsg *pMsg, HRESULT *pHr);
    ~CUiRecvFileInfo(void);

    // name
    LPTSTR GetFullName(void) { return m_pszFullName; }
    LPTSTR GetName(void) { return m_pszFileName; }
    LPTSTR GetRecvFolder(void) { return m_pszRecvFolder; }

    // numbers
    ULONG GetSize(void) { return m_cbFileSize; }
    ULONG GetTotalRecvSize(void) { return m_cbTotalRecvSize; }
    void SetTotalRecvSize(ULONG cbTotalRecvSize) { m_cbTotalRecvSize = cbTotalRecvSize; }

    // file handle
    MBFTFILEHANDLE GetFileHandle(void) { return m_nFileHandle; }
    void SetFileHandle(MBFTFILEHANDLE nFileHandle) { m_nFileHandle = nFileHandle; }

private:

    LPTSTR          m_pszFullName; // allocated
    LPTSTR          m_pszFileName; // handy shortcut

    MBFTFILEHANDLE  m_nFileHandle;
    time_t          m_FileDateTime;

    ULONG           m_cbFileSize;
    ULONG           m_cbTotalRecvSize;

    LPTSTR          m_pszRecvFolder;
};


class CRecvDlg : public CRefCount
{
public:

    CRecvDlg(CAppletWindow*, T120ConfID, T120NodeID, MBFTEVENTHANDLE, CUiRecvFileInfo *, HRESULT *);
    ~CRecvDlg(void);

    void OnOpen(void);
    void OnDelete(void);
    void OnAccept(void);

    void StopAnimation(void);

    ULONG GetPercent(void);
    void OnProgressUpdate(FileTransmitMsg *pMsg = NULL);

    void OnCanceled(void);
    void OnRejectedFile(void);

    CUiRecvFileInfo *GetRecvFileInfo(void) { return m_pRecvFileInfo; }
    MBFTEVENTHANDLE GetEventHandle(void) { return m_nEventHandle; }
    MBFTFILEHANDLE GetFileHandle(void) { return m_pRecvFileInfo->GetFileHandle(); }

    HWND GetHwnd(void) { return m_hwndRecvDlg; }

    T120ConfID GetConfID(void) { return m_nConfID; }
    T120NodeID GetSenderID(void) { return m_nidSender; }

    ULONG GetTotalRecvSize(void) { return m_pRecvFileInfo->GetTotalRecvSize(); }

    BOOL IsRecvComplete(void) { return m_fRecvComplete; }

private:

    HWND                m_hwndRecvDlg;
    UINT                m_idResult;

    CAppletWindow      *m_pWindow;
    T120ConfID          m_nConfID;
    T120NodeID          m_nidSender;
    MBFTEVENTHANDLE     m_nEventHandle;

    CUiRecvFileInfo    *m_pRecvFileInfo;

    BOOL                m_fRecvComplete;
    BOOL                m_fShownRecvCompleteUI;
    HRESULT             m_hr;

    DWORD               m_dwEstTimeLeft;
	DWORD               m_dwPreviousTime;
	DWORD               m_dwPreviousTransferred;
	DWORD               m_dwBytesPerSec;
	DWORD               m_dwStartTime;
};


class CRecvDlgList : public CQueue
{
    DEFINE_CQUEUE(CRecvDlgList, CRecvDlg*)
};

class CErrorDlgList : public CList
{
	DEFINE_CLIST(CErrorDlgList, HWND);
};

class CAppletWindow : public CRefCount
{
    friend LRESULT OnCreate(HWND hwnd, WPARAM wParam, LPARAM lParam);

public:

    CAppletWindow(BOOL fNoUI, HRESULT *);
    ~CAppletWindow(void);

public:
	BOOL FilterMessage(MSG *msg);
    //
    // Applet operation
    //
    void RegisterEngine(MBFTEngine *);
    void UnregisterEngine(void);
    void RegisterRecvDlg(CRecvDlg *);
    void UnregisterRecvDlg(CRecvDlg *);
    CRecvDlg *FindDlgByHandles(MBFTEVENTHANDLE, MBFTFILEHANDLE);

    BOOL IsInConference(void) { return (NULL != m_pEngine); }
    HWND GetHwnd(void) { return m_hwndMainUI; }
    HWND GetListView(void) { return m_hwndListView; }
    MBFTEngine *GetEngine(void) { return m_pEngine; }

    void OnEngineNotify(MBFTMsg *);
    BOOL QueryShutdown(BOOL fShutdown = TRUE);

    //
    // Windows message derivatives
    //
    // WM_CREATE
    BOOL CreateToolBar(void);
    BOOL CreateStatusBar(void);
    BOOL CreateListView(void);
	BOOL CreateProgressBar(void);


    // WM_NOTIFY
    void OnNotifyListView(LPARAM);
    // WM_DROPFILES
    LRESULT OnDropFiles(HANDLE hDrop);
    // WM_CONTEXTMENU
    void SetContextMenuStates(void);
    void OnContextMenuForMainUI(LPARAM lParam);
    void OnContextMenuForListView(LPARAM lParam);
    void CreateMenu(LPARAM lParam, ULONG cItems, UI_MENU_INFO aMenuInfo[]);
    // WM_SIZE
    void OnSizeToolBar(void);
    void OnSizeStatusBar(void);
    void OnSizeListView(void);
    // WM_GETMINMAXINFO
    void OnGetMinMaxInfo(LPMINMAXINFO);
	// WM_DRAWITEM
	void OnDrawItem(void);

    //
    // OnCommand
    //
    void OnAddFiles(void);
    void OnRemoveFiles(void);
    void OnRemoveAllFiles(void);
    void OnSendAll(void);
	void OnSendOne(void);
    void OnStopSending(void);
    void OnOpenRecvFolder(void);
    void OnExit(BOOL fNoQuery = FALSE); // exit point
    void OnHelp(void);
    void OnAbout(void);
	void OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu);

    //
    // OnEngineNotify
    //
    void HandleFileOfferNotify(FileOfferNotifyMsg *);
    void HandleProgressNotify(FileTransmitMsg *);
    void HandleErrorNotify(FileErrorMsg *);
    void HandleInitUninitNotification(InitUnInitNotifyMsg *);
    void HandleFileEventEndNotification(FileEventEndNotifyMsg *);
	void HandlePeerNotification(PeerMsg  *pMdg);

    //
    // Other methods
    //
    void BringToFront(void);
    void ClearSendInfo(BOOL fUpdateMenu);
    void ClearRecvInfo(void);

    void UpdateUI(void); // UpdateMenu && UpdateToolBar
    void UpdateTitle(void);
    void UpdateMenu(void);
    void UpdateToolBar(void);
    void UpdateStatusBar(void);
    void UpdateListView(CUiSendFileInfo *);

    void ResolveShortcut(LPTSTR pszFile, LPTSTR pszFileDest);
	BOOL DrawItem(LPDRAWITEMSTRUCT);
	void OnCommand(WORD wId, HWND hwndCtl, WORD codeNotify);
	void SetSendMode(BOOL fSendALL)  { m_fSendALL = fSendALL; };
	void FocusNextRecvDlg(void);
	void FocusNextErrorDlg(void);
	CUiSendFileInfo *ChooseFirstUnSentFile(void);
	CUiSendFileInfo *ChooseSelectedFile(void);
	BOOL UIHidden(void) { return m_UIMode != FTUIMODE_SHOWUI; }
	FTUIMode GetUIMode(void) { return m_UIMode; }
	void AddErrorDlg(HWND hwndErrorDlg) { m_ErrorDlgList.Prepend(hwndErrorDlg); }
	void RemoveErrorDlg(HWND hwndErrorDlg) { m_ErrorDlgList.Remove(hwndErrorDlg);	}

protected:

    void SetHwnd(HWND hwnd) { ASSERT(NULL == m_hwndMainUI); m_hwndMainUI = hwnd; }
	void SaveWindowPosition(void);
	BOOL HasUnSentFiles(BOOL fUnSentOnly = TRUE);
	BOOL SendNow(CUiSendFileInfo *pFileInfo);
	BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle);
	BOOL IsReceiving(void);

private:
    HWND            m_hwndMainUI;
    HWND            m_hwndStatusBar;
    HWND            m_hwndListView;	
	HWND			m_hwndProgressBar;		// progress bar
	CComboToolbar	*m_pToolbar;

	HACCEL			m_hAccel;
	HACCEL			m_hLVAccel;
	TCHAR			m_szDefaultDir[MAX_PATH];

	HICON			m_hIconInCall;          // Incall icon
	HICON			m_hIconNotInCall;		// Not incall icon

    MBFTEngine     *m_pEngine;

    CRecvDlgList    m_RecvDlgList;
	CErrorDlgList   m_ErrorDlgList;

    BOOL            m_fInFileOpenDialog;
	BOOL			m_fSendALL;				// flag indicating whether to send one file only
    FTUIMode        m_UIMode;	            // whether the UI is hidden
	
    CUiSendFileInfo*m_pCurrSendFileInfo;
    MBFTEVENTHANDLE m_nCurrSendEventHandle;

    TCHAR           m_szFtMainWndClassName[32];
};

HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr);

#endif // _FT_MAIN_UI_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbft.cpp ===
/* file: mbft.cpp */

#include "mbftpch.h"
#include <it120app.h>
#include <version.h>

#define __NO_EXTERNS__
#include "mbft.hpp"
#include "osshelp.hpp"
#include "messages.hpp"
#include "mbftrecv.hpp"
#include "mbftsend.hpp"

void CALLBACK T120Callback(T120AppletSessionMsg *);

// from mbftapi.cpp
BOOL g_fWaitingForBufferAvailable = FALSE;


#ifdef ENABLE_HEARTBEAT_TIMER

// WM_TIMER has the lowest priority among window messages
#define  IDLE_TIMER_SPEED   5000
#define  SESSION_TIMER_SPEED   20

void HeartBeatTimerProc(HWND hWnd, UINT uMsg, UINT_PTR nTimerID, DWORD dwTime)
{
    if (NULL != g_pFileXferApplet)
    {
        MBFTEngine *pEngine = g_pFileXferApplet->FindEngineByTimerID(nTimerID);
        if (NULL != pEngine)
        {
            ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_HEART_BEAT, 
                                                0, (LPARAM) pEngine);
        }
    }
}
#endif





MBFTEngine::MBFTEngine
(
    MBFTInterface          *pMBFTIntf,
    MBFT_MODE               eMode,
    T120SessionID           nSessionID
)
:
    CRefCount(MAKE_STAMP_ID('F','T','E','g')),

    m_pAppletSession(NULL),
    m_eLastSendDataError(T120_NO_ERROR),

    m_pMBFTIntf(pMBFTIntf),

    m_fConfAvailable(FALSE),
    m_fJoinedConf(FALSE),

    m_uidMyself(0), // user id
    m_nidMyself(0), // node id
    m_eidMyself(0), // entity id

    m_eMBFTMode(eMode),
    m_SessionID(nSessionID),

    m_MBFTControlChannel(nSessionID),
    m_MBFTDataChannel(0),

    m_nRosterInstance(0),
 
    m_nConfID(0),

    m_MBFTMaxFileSize(_iMBFT_MAX_FILE_SIZE),
    
    m_MBFTMaxDataPayload(_iMBFT_DEFAULT_MAX_FILEDATA_PDU_LENGTH),
    m_MBFTMaxSendDataPayload(_iMBFT_DEFAULT_MAX_MCS_SIZE - _iMBFT_FILEDATA_PDU_SUBTRACT),

    m_bV42CompressionSupported(FALSE),
    m_v42bisP1(_iMBFT_V42_NO_OF_CODEWORDS),
    m_v42bisP2(_iMBFT_V42_MAX_STRING_LENGTH),
    
    // LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
    m_bInConductedMode(FALSE),
    m_ConductorNodeID(0),
    m_MBFTConductorID(0),
    m_ConductedModePermission(0),
    m_bWaitingForPermission(FALSE),
#endif // ENABLE_CONDUCTORSHIP

    m_pWindow(NULL),
    m_State(IdleNotInitialized)
{
    g_fWaitingForBufferAvailable = FALSE;

    switch (m_eMBFTMode)
    {
    case MBFT_STATIC_MODE:
        ASSERT(m_MBFTControlChannel == _MBFT_CONTROL_CHANNEL);
        m_MBFTDataChannel = _MBFT_DATA_CHANNEL;
        break;

#ifdef USE_MULTICAST_SESSION
    case MBFT_MULTICAST_MODE:
        break;
#endif

    default:
        ERROR_OUT(("MBFTEngine::MBFTEngine: invalid session type=%u", m_eMBFTMode));
        break;
    }

    // clear join session structures
    ::ZeroMemory(&m_aStaticChannels, sizeof(m_aStaticChannels));
#ifdef USE_MULTICAST_SESSION
    ::ZeroMemory(&m_aJoinResourceReqs, sizeof(m_aJoinResourceReqs));
#endif
    ::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));

    ASSERT(NULL != g_pFileXferApplet);
    g_pFileXferApplet->RegisterEngine(this);

    m_pWindow = g_pFileXferApplet->GetUnattendedWindow();
    if (NULL != m_pWindow)
    {
        m_pWindow->RegisterEngine(this);
    }

#ifdef ENABLE_HEARTBEAT_TIMER
    m_nTimerID = ::SetTimer(NULL, 0, IDLE_TIMER_SPEED, HeartBeatTimerProc);
#endif
}

MBFTEngine::~MBFTEngine(void)
{
#ifdef ENABLE_HEARTBEAT_TIMER
    // kill the timer now
    ::KillTimer(NULL, m_nTimerID);
#endif

    // the interface object is already gone
    m_pMBFTIntf = NULL;

    MBFTSession *pSession;
    while (NULL != (pSession = m_SessionList.Get()))
    {
        pSession->UnInitialize(FALSE);
        delete pSession; // LONCHANC: not sure about this delete
    }

    if (NULL != m_pAppletSession)
    {
        m_pAppletSession->ReleaseInterface();
    }

    ASSERT(! m_fJoinedConf);

    m_PeerList.DeleteAll();
}

void MBFTEngine::SetInterfacePointer( MBFTInterface *pIntf )
{ 
        CPeerData       *pPeerData;

        ASSERT (pIntf);
        m_pMBFTIntf = pIntf; 
        m_PeerList.Reset();
        while (NULL != (pPeerData = m_PeerList.Iterate()))
        {
                if (pPeerData->GetNodeID() != m_nidMyself)
                {
                        AddPeerNotification(pPeerData->GetNodeID(), 
                                                        pPeerData->GetUserID(),
                                                        pPeerData->GetIsLocalNode(), 
                                                        pPeerData->GetIsProshareNode(), TRUE,
                                                        pPeerData->GetAppKey(),
                                                        m_SessionID);
                }
        }
}

BOOL MBFTEngine::Has2xNodeInConf(void)
{
    CPeerData *pPeerData;
    m_PeerList.Reset();
    while (NULL != (pPeerData = m_PeerList.Iterate()))
    {
        // if (pPeerData->GetVersion() < HIWORD(VER_PRODUCTVERSION_DW))
        if (pPeerData->GetVersion() < 0x0404)
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL MBFTEngine::HasSDK(void)
{
        return (m_pMBFTIntf ? TRUE : FALSE);
}


HRESULT MBFTEngine::SafePostMessage
(
    MBFTMsg     *pMsg
)
{
    if (NULL != pMsg)
    {
        AddRef();
        ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_BASIC, (WPARAM) pMsg, (LPARAM) this);
        return S_OK;
    }
    ERROR_OUT(("MBFTEngine::SafePostMessage: null msg ptr"));
    return E_OUTOFMEMORY;
}


void MBFTEngine::OnPermitToEnrollIndication
(
    GCCAppPermissionToEnrollInd     *pInd
)
{
    T120Error rc;

    TRACEGCC( " Permission to enroll in conference [%d] is %sgranted.\n",
        pInd->nConfID, pInd->fPermissionGranted?"":"not " );

    m_fConfAvailable = pInd->fPermissionGranted;

    if (pInd->fPermissionGranted)
    {
        m_nConfID = pInd->nConfID;

        // build the common part of the join session request for the base session
        ASSERT(m_SessionID == m_MBFTControlChannel);
        ::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));
        m_JoinSessionReq.dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS;
        m_JoinSessionReq.fConductingCapable = FALSE;
        m_JoinSessionReq.nStartupChannelType = MCS_STATIC_CHANNEL;
        m_JoinSessionReq.cNonCollapsedCaps = sizeof(g_aAppletNonCollCaps) / sizeof(g_aAppletNonCollCaps[0]);
        m_JoinSessionReq.apNonCollapsedCaps = (GCCNonCollCap **) &g_aAppletNonCollCaps[0];
        m_JoinSessionReq.cCollapsedCaps = sizeof(g_aAppletCaps) / sizeof(g_aAppletCaps[0]);
        m_JoinSessionReq.apCollapsedCaps = (GCCAppCap **) &g_aAppletCaps[0];

        // put in the session ID which is the control channel ID
        m_JoinSessionReq.SessionKey = g_AppletSessionKey;
        m_JoinSessionReq.SessionKey.session_id = m_SessionID;
        m_aStaticChannels[0] = m_MBFTControlChannel;

        // at least one static channel to join
        m_JoinSessionReq.aStaticChannels = &m_aStaticChannels[0];

        // build the complete join session request for the base session
        switch (m_eMBFTMode)
        {
        case MBFT_STATIC_MODE:
            ASSERT(m_MBFTControlChannel == _MBFT_CONTROL_CHANNEL);
            ASSERT(m_MBFTDataChannel = _MBFT_DATA_CHANNEL);
            m_aStaticChannels[1] = m_MBFTDataChannel;
            m_JoinSessionReq.cStaticChannels = 2; // control and data channels
            // m_JoinSessionReq.cResourceReqs = 0;
            break;

#ifdef USE_MULTICAST_SESSION
        case MBFT_MULTICAST_MODE:
            m_JoinSessionReq.cStaticChannels = 1; // control channel only
            ::ZeroMemory(&m_aJoinResourceReqs, sizeof(m_aJoinResourceReqs));
            m_aJoinResourceReqs[0].eCommand = APPLET_RETRIEVE_N_JOIN_CHANNEL;
            m_aJoinResourceReqs[0].RegKey.resource_id.length = sizeof(DATA_CHANNEL_RESOURCE_ID) - 1;
            m_aJoinResourceReqs[0].RegKey.resource_id.value = DATA_CHANNEL_RESOURCE_ID;
            m_aJoinResourceReqs[0].RegKey.session_key = m_JoinSessionReq.SessionKey;
            m_JoinSessionReq.cResourceReqs = sizeof(m_aJoinResourceReqs) / sizeof(m_aJoinResourceReqs[0]);
            m_JoinSessionReq.aResourceReqs = &m_aJoinResourceReqs[0];
            break;
#endif

        default:
            ERROR_OUT(("MBFTEngine::OnPermitToEnrollIndication: invalid session type=%u", m_eMBFTMode));
            break;
        }

        // now, create the applet session
        rc = g_pFileXferApplet->CreateAppletSession(&m_pAppletSession, m_nConfID);
        if (T120_NO_ERROR == rc)
        {
            ASSERT(NULL != m_pAppletSession);
            m_pAppletSession->Advise(T120Callback,          // callback function
                                     g_pFileXferApplet,     // applet context
                                     this);                 // session context

            rc = m_pAppletSession->Join(&m_JoinSessionReq);
        }

        if (T120_NO_ERROR != rc)
        {
                        WARNING_OUT(("MBFTEngine::OnPermitToEnrollIndication: CreateAppletSession failed, rc=%u", rc));
            DBG_SAVE_FILE_LINE
            SafePostNotifyMessage(new InitUnInitNotifyMsg(EnumInitFailed));
        }
    } // in conference
    else
    // leaving the conference here
    {                     
        LPMBFTSESSION pSession;
        m_SessionList.Reset();
        while (NULL != (pSession = m_SessionList.Iterate()))
        {
            pSession->UnInitialize( TRUE );
        }

        //Time to say goodbye...
        AddPeerNotification( m_nidMyself, m_uidMyself, TRUE, TRUE, FALSE, MY_APP_STR, m_SessionID );

        //Clear the peer list...                    
        m_PeerList.DeleteAll();                       
                
        //Nuke all sessions except for the first one....
        while (NULL != (pSession = m_SessionList.Get()))
        {
            delete pSession;
        }

        // leave the conference if not done so
        if (NULL != m_pAppletSession)
        {
            m_pAppletSession->Unadvise();

            // LONCHANC: I commented out the following line because we should not
            // leave the conference until we are sure that we can release the interface.
            // There are outstanding send-data-indication messages. If we leave now,
            // we will not be able to free them...
            // m_pAppletSession->Leave();

            // let the core know we left the conference
            DBG_SAVE_FILE_LINE
            SafePostNotifyMessage(new InitUnInitNotifyMsg(EnumInvoluntaryUnInit));
        }

        // we are not in the conference anymore
        m_fJoinedConf = FALSE;

        // release this engine object in the next tick
        ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_DELETE_ENGINE, 0, (LPARAM) this);
    }
}


void MBFTEngine::OnJoinSessionConfirm
(
    T120JoinSessionConfirm      *pConfirm
)
{
    if (T120_RESULT_SUCCESSFUL == pConfirm->eResult)
    {
        if (pConfirm->pIAppletSession == m_pAppletSession)
        {
            m_uidMyself = pConfirm->uidMyself;
            m_eidMyself = pConfirm->eidMyself;   
            m_nidMyself = pConfirm->nidMyself;
            ASSERT(m_SessionID == pConfirm->sidMyself);

#ifdef USE_MULTICAST_SESSION
            if (MBFT_MULTICAST_MODE == m_eMBFTMode)
            {
                ASSERT(1 == pConfirm->cResourceReqs);
                ASSERT(0 == m_MBFTDataChannel);
                ASSERT(APPLET_RETRIEVE_N_JOIN_CHANNEL == pConfirm->aResourceResults[0].eCommand);
                m_MBFTDataChannel = pConfirm->aResourceResults[0].nChannelID;
                ASSERT(0 != m_MBFTDataChannel);
            }
#endif

            // we are now officially in the conference
            m_fJoinedConf = TRUE;
        }
        else
        {
            ERROR_OUT(("MBFTEngine::OnJoinSessionConfirm: not my session confirm, pConfirm->pI=0x%x, m_pI=0x%x", pConfirm->pIAppletSession, m_pAppletSession));
        }
    }
    else
    {
        WARNING_OUT(("MBFTEngine::OnJoinSessionConfirm: failed, result=%u", pConfirm->eResult));
        DBG_SAVE_FILE_LINE
        SafePostNotifyMessage(new InitUnInitNotifyMsg(EnumInitFailed));
    }
}


CPeerData::CPeerData
(
    T120NodeID          NodeID,
    T120UserID          MBFTUserID,
    BOOL                bIsLocalNode,
    BOOL                IsProshareNode,
    BOOL                bCanConduct,
    BOOL                bEOFAcknowledgment,
    LPCSTR              lpszAppKey,
    DWORD               dwVersion
)
:
    m_NodeID(NodeID),
    m_MBFTUserID(MBFTUserID),    
    m_bIsLocalNode(bIsLocalNode),
    m_bIsProshareNode(IsProshareNode),
    m_bCanConduct(bCanConduct),
    m_bEOFAcknowledgment(bEOFAcknowledgment),
    m_dwVersion(dwVersion)
{
    if (lpszAppKey)
    {
        ::lstrcpynA(m_szAppKey, lpszAppKey, sizeof(m_szAppKey));
    }
    else
    {
        m_szAppKey[0] = '\0';
    }
}
            

void MBFTEngine::AddPeerNotification
(
    T120NodeID          NodeID,
    T120UserID          MBFTUserID,
    BOOL                IsLocalNode,
    BOOL                IsProshareNode,
    BOOL                bPeerAdded,
    LPCSTR              lpszAppKey,
    T120SessionID       SessionID
)
{
    DBG_SAVE_FILE_LINE
    SafePostNotifyMessage(
        new PeerMsg(NodeID, MBFTUserID, IsLocalNode, IsProshareNode,
                    lpszAppKey, bPeerAdded, SessionID));
}


void MBFTEngine::AddAllPeers(void)
{
        T120NodeID nNodeId;
        CPeerData *pPeerData;

        m_PeerList.Reset();
        while (NULL != (pPeerData = m_PeerList.Iterate()))
        {
                nNodeId = pPeerData->GetNodeID();
                if (nNodeId != m_nidMyself)
                {
                        DBG_SAVE_FILE_LINE
                        SafePostNotifyMessage(new PeerMsg(nNodeId, pPeerData->GetUserID(),
                                                                  FALSE, pPeerData->GetIsProshareNode(), 
                                                                  pPeerData->GetAppKey(), TRUE, m_SessionID));
                }
        }
}


// LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
void MBFTEngine::OnConductAssignIndication(GCCConductorAssignInd *pInd)
{
    m_ConductorNodeID           =   pInd->nidConductor;
    m_MBFTConductorID           =   0;
    m_ConductedModePermission   =   0;
    m_bWaitingForPermission     =   FALSE;
    
    if (m_nidMyself == m_ConductorNodeID)
    {
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileTransfer; 
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileRequest;
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumPriority;
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumPrivateChannel; 
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumAbort;
        m_ConductedModePermission |= PrivilegeAssignPDU::EnumNonStandard;
    }
    else
    {
        CPeerData *lpPeer;
        if (NULL != (lpPeer = m_PeerList.Find(m_ConductorNodeID)))
        {
            if (lpPeer->GetCanConduct())
            {
                //Now that we have found a conductor on the conducting node,
                //our search is over....
                m_MBFTConductorID = lpPeer->GetUserID();
            }
        }                

        //MBFT 8.11.1
        //If there is a change in the conductor, and there is no MBFT conductor at the
        //new conducting node, all transactions must cease....
        //The m_bInConductedMode flag tells us if we were already in the conducted mode.
        if( !m_MBFTConductorID && m_bInConductedMode )
        {
            //Abort all transactions....
            AbortAllSends();
        }
    }

    m_bInConductedMode  =  TRUE;
}                                                                  

void MBFTEngine::OnConductReleaseIndication( GCCConferenceID ConfID )
{
    m_bInConductedMode          =   FALSE;
    m_ConductorNodeID           =   0;
    m_MBFTConductorID           =   0;
    m_ConductedModePermission   =   0;
    m_bWaitingForPermission     =   FALSE;
}

void MBFTEngine::OnConductGrantIndication(GCCConductorPermitGrantInd *pInd)
{
    UINT Index;
    
    for( Index = 0; Index < pInd->Granted.cNodes; Index++ )
    {
        if (pInd->Granted.aNodeIDs[Index] == m_nidMyself)
        {
            if( pInd->fThisNodeIsGranted )
            {
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileTransfer; 
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumFileRequest;
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumPriority;
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumPrivateChannel; 
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumAbort;
                m_ConductedModePermission |= PrivilegeAssignPDU::EnumNonStandard;
            }
            else
            {
                //TO DO:    
                //MBFT 8.11.1 and 8.12.1
                //If the MBFT provider receives a GCCConductorPermissionGrantIndication
                //with permission_flag = FALSE, all privileges are revoked and all
                //transactions should be terminated....
                m_ConductedModePermission = 0;
                AbortAllSends();
            }
            break;
        }
    }
}                                                                  

void MBFTEngine::AbortAllSends(void)
{
    if( m_bInConductedMode )
    {
        MBFTSession *pSession;
        m_SessionList.Reset();
        while (NULL != (pSession = m_SessionList.Iterate()))
        {
            if (pSession->GetSessionType() == MBFT_PRIVATE_SEND_TYPE)
            {
                pSession->OnControlNotification(
                    _iMBFT_PROSHARE_ALL_FILES,
                    FileTransferControlMsg::EnumConductorAbortFile,
                    NULL,
                    NULL );
            }
        } 
    }
}
#endif // ENABLE_CONDUCTORSHIP


void MBFTEngine::OnDetachUserIndication
(
    T120UserID          mcsUserID,
    T120Reason          eReason
)
{
    TRACEMCS(" Detach User Indication [%u]\n",mcsUserID);
    
    if (mcsUserID == m_uidMyself)
    {
        m_fJoinedConf = FALSE;
        m_pAppletSession->Unadvise();

        //Time to say goodbye...
        AddPeerNotification(m_nidMyself, m_uidMyself, TRUE, TRUE, FALSE, MY_APP_STR, m_SessionID);
    } 
}


BOOL MBFTEngine::ProcessMessage(MBFTMsg *pMsg)
{
    BOOL bWasHandled = FALSE;
    BOOL bBroadcastFileOfferHack  = FALSE;
    MBFTSession *pSession;

    // lonchanc: it is possible that the channel admit indication comes in
    // before the session is created. in this case, put the message back to the queue.
    if (m_SessionList.IsEmpty())
    {
        if (EnumMCSChannelAdmitIndicationMsg == pMsg->GetMsgType())
        {
            return FALSE; // do not delete the message and put it back to the queue
        }
    }

    m_SessionList.Reset();
    while (!bWasHandled && NULL != (pSession = m_SessionList.Iterate()))
    {
        switch (pMsg->GetMsgType())
        {
        case EnumMCSChannelAdmitIndicationMsg:
            if (pSession->IsReceiveSession())
            {
                MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) pSession;
                MCSChannelAdmitIndicationMsg *p = (MCSChannelAdmitIndicationMsg *) pMsg;
                //We have to make an exception in the case because we get this
                //message before the PrivateChannelInvitePDU() !!!
                bWasHandled = pRecvSession->OnMCSChannelAdmitIndication(p->m_wChannelId, p->m_ManagerID);
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Admit Indication [%u], Manager [%u]\n", p->m_wChannelId, p->m_ManagerID);
                }
            }
            break;

        case EnumMCSChannelExpelIndicationMsg:
            if (pSession->IsReceiveSession())
            {
                MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) pSession;
                MCSChannelExpelIndicationMsg *p = (MCSChannelExpelIndicationMsg *) pMsg;
                bWasHandled = pRecvSession->OnMCSChannelExpelIndication(p->m_wChannelId, p->m_iReason);
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Expel Indication [%u]\n", p->m_wChannelId);
                }
            }
            break;

        case EnumMCSChannelJoinConfirmMsg:
            {
                MCSChannelJoinConfirmMsg *p = (MCSChannelJoinConfirmMsg *) pMsg;
                bWasHandled = pSession->OnMCSChannelJoinConfirm(p->m_wChannelId, p->m_bSuccess);
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Join Confirm [%u], Success = [%d]\n", p->m_wChannelId, p->m_bSuccess);
                }
            }
            break;

        case EnumMCSChannelConveneConfirmMsg:
            if (pSession->IsSendSession())
            {
                MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) pSession;
                MCSChannelConveneConfirmMsg *p = (MCSChannelConveneConfirmMsg *) pMsg;
                bWasHandled = pSendSession->OnMCSChannelConveneConfirm(p->m_wChannelId, p->m_bSuccess);  
                if(bWasHandled)
                {
                    TRACEMCS(" Channel Convene Confirm [%u], Success = [%d]\n", p->m_wChannelId, p->m_bSuccess);
                }
            }
            break;

        case EnumGenericMBFTPDUMsg:
            {
                MBFTPDUMsg *p = (MBFTPDUMsg *) pMsg;
                bWasHandled = DispatchPDUMessage(pSession, p);

                //Background on this hack:
                //In the broadcast mode, we may get a FileOfferPDU followed by a FileStart
                //PDU and may therefore not give the client application sufficient time
                //to process the File Offer. Therefore, we make sure that we stop processing
                //other messages if we get a broadcast FileOffer...
                if(bWasHandled)
                {
                    if (p->m_PDUType == EnumFileOfferPDU)
                    {
                        LPFILEOFFERPDU lpNewFileOfferPDU = (LPFILEOFFERPDU) p->m_lpNewPDU;
                        if(lpNewFileOfferPDU->GetAcknowledge() == 0)
                        {
                            bBroadcastFileOfferHack  = TRUE;
                        }
                    }
                }
            }
            break;

        case EnumPeerDeletedMsg:
            {
                PeerDeletedMsg *p = (PeerDeletedMsg *) pMsg;
                pSession->OnPeerDeletedNotification(p->m_lpPeerData);
            }
            break;

        case EnumSubmitFileSendMsg:
            {
                SubmitFileSendMsg *p = (SubmitFileSendMsg *) pMsg;
                if (p->m_EventHandle == pSession->GetEventHandle())
                {
                    if(pSession->GetSessionType() == MBFT_PRIVATE_SEND_TYPE)
                    {
                        bWasHandled = TRUE;
                        ((MBFTPrivateSend *) pSession)->SubmitFileSendRequest(p);
                    }
                }
            }
            break;

        case EnumFileTransferControlMsg:
            {
                FileTransferControlMsg *p = (FileTransferControlMsg *) pMsg;
                if (p->m_EventHandle == pSession->GetEventHandle())
                {
                    bWasHandled = TRUE;
                    pSession->OnControlNotification(
                                p->m_hFile,
                                p->m_ControlCommand,
                                p->m_szDirectory,
                                p->m_szFileName);
                }                               
            }
            break;

        default:
            ASSERT(0);
            break;
        } // switch

        if(bBroadcastFileOfferHack)
        {
            TRACE("(MBFT:) BroadcastFileOfferHack detected, aborting message processing\n");
            break;  //Out of message for loop
        }
    } //Message for loop

    return TRUE; // delete the message
}



#ifdef ENABLE_CONDUCTORSHIP
BOOL MBFTEngine::ConductedModeOK(void)
{
    BOOL bReturn = TRUE;
        
    if(m_bInConductedMode)
    {
        bReturn  = (m_ConductedModePermission & PrivilegeRequestPDU::EnumFileTransfer) && 
                   (m_ConductedModePermission & PrivilegeRequestPDU::EnumPrivateChannel); 
        
    }
    
    return(bReturn);
}
#endif // ENABLE_CONDUCTORSHIP


BOOL MBFTEngine::HandleSessionCreation(MBFTMsg *pMsg)
{
    switch (pMsg->GetMsgType())
    {
    case EnumCreateSessionMsg:
        {
            CreateSessionMsg *p = (CreateSessionMsg *) pMsg;
            MBFTSession *lpNewSession = NULL;
            MBFTEVENTHANDLE EventHandle = p->m_EventHandle;
            T120SessionID SessionID = p->m_SessionID;
#ifdef ENABLE_CONDUCTORSHIP
            BOOL bDeleteMessage = TRUE;
#endif

            switch (p->m_iSessionType)
            {
            case MBFT_PRIVATE_SEND_TYPE:
                if(m_State == IdleInitialized)
                {
                    if(ConductedModeOK())
                    {
                        TRACESTATE(" Creating new acknowledged send session\n");
                        DBG_SAVE_FILE_LINE
                        lpNewSession = new MBFTPrivateSend(this,EventHandle,
                                                        m_uidMyself,
                                                        m_MBFTMaxSendDataPayload);
                        ASSERT(NULL != lpNewSession);
                    }
#ifdef ENABLE_CONDUCTORSHIP
                    else
                    {
                        bDeleteMessage  = FALSE;
                    }
#endif
                }                                    
                else
                {
                    TRACE(" Invalid attempt to create session before initialization\n");
                }
                break;
                
            case MBFT_PRIVATE_RECV_TYPE:
                if(m_State == IdleInitialized)
                {
                    TRACESTATE(" Creating new acknowledge session\n");
                    DBG_SAVE_FILE_LINE
                    lpNewSession = new MBFTPrivateReceive(this,
                                                          EventHandle,
                                                          p->m_ControlChannel,
                                                          p->m_DataChannel);
                    ASSERT(NULL != lpNewSession);
                }
                else
                {
                    TRACE(" Invalid attempt to create session before initialization\n");
                }
                break;

            case MBFT_BROADCAST_RECV_TYPE:
#ifdef USE_BROADCAST_RECEIVE
                if(m_State == IdleInitialized)
                {
                    TRACESTATE(" Creating new broadcast receive session\n");
                    DBG_SAVE_FILE_LINE
                    lpNewSession = new MBFTBroadcastReceive(this,
                                                            EventHandle,
                                                            p->m_ControlChannel,
                                                            p->m_DataChannel,
                                                            p->m_SenderID,
                                                            p->m_FileHandle);
                    ASSERT(NULL != lpNewSession);
                }
                else
                {
                   TRACE(" Invalid attempt to create session before initialization\n");
                }
#endif    // USE_BROADCAST_RECEIVE
                break;

            default:
                ASSERT(0);
                break;
            } // switch

            if (lpNewSession)
            {
#ifdef ENABLE_HEARTBEAT_TIMER
                if (lpNewSession->IsSendSession())
                {
                    KillTimer(NULL, m_nTimerID);
                    m_nTimerID = ::SetTimer(NULL, 0, SESSION_TIMER_SPEED, HeartBeatTimerProc);
                }
#endif                
                m_SessionList.Append(lpNewSession);
            }
        } // if create session message
        break;

   case EnumDeleteSessionMsg:
        {
            DeleteSessionMsg *p = (DeleteSessionMsg *) pMsg;
#ifdef ENABLE_HEARTBEAT_TIMER
                        if (NULL != p->m_lpDeleteSession)
                        {
                                if (p->m_lpDeleteSession->IsSendSession())
                                {
                                        BOOL fSendSessExists = FALSE;
                                        MBFTSession *pSess;
                                        m_SessionList.Reset();
                                        while (NULL != (pSess = m_SessionList.Iterate()))
                                        {
                                                if (pSess->IsSendSession())
                                                {
                                                        fSendSessExists = TRUE;
                                                        break;
                                                }
                                        }
                                        if (! fSendSessExists)
                                        {
                                                ::KillTimer(NULL, m_nTimerID);
                                                m_nTimerID = ::SetTimer(NULL, 0, IDLE_TIMER_SPEED, HeartBeatTimerProc);
                                        }
                                }
                        }
#endif
            m_SessionList.Delete(p->m_lpDeleteSession);
        } // if delete session message
        break;

    default:
        return FALSE; // not handled
    }

    return TRUE; // handled
}                                


BOOL MBFTEngine::DispatchPDUMessage(MBFTSession *lpMBFTSession,MBFTPDUMsg * lpNewMessage)
{
    T120ChannelID wChannelID   = lpNewMessage->m_wChannelId;
    T120Priority iPriority     = lpNewMessage->m_iPriority;
    T120UserID SenderID        = lpNewMessage->m_SenderID;
        T120NodeID NodeID                  = GetNodeIdByUserID(SenderID);
    BOOL IsUniformSendData = lpNewMessage->m_IsUniformSendData;

    LPGENERICPDU lpNewPDU = lpNewMessage->m_lpNewPDU;
    MBFTPDUType DecodedPDUType = lpNewMessage->m_PDUType;

    BOOL bWasHandled = FALSE;

    ASSERT(NULL != lpNewPDU);
    switch(DecodedPDUType)
    {
    case EnumFileOfferPDU:
        if (lpMBFTSession->IsReceiveSession())
        {
            MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) lpMBFTSession;
            bWasHandled = pRecvSession->OnReceivedFileOfferPDU(wChannelID,
                                                               iPriority,
                                                               SenderID,
                                                                                                                           NodeID,
                                                               (LPFILEOFFERPDU)lpNewPDU,
                                                               IsUniformSendData);
            if(bWasHandled)
            {
                TRACEPDU(" File Offer PDU from [%u]\n",SenderID);
            }
        }
        break;            

    case EnumFileAcceptPDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedFileAcceptPDU(wChannelID,
                                                                iPriority,
                                                                SenderID,
                                                                (LPFILEACCEPTPDU)lpNewPDU,
                                                                IsUniformSendData);
            if(bWasHandled)
            {
                TRACEPDU(" File Accept PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileRejectPDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedFileRejectPDU(wChannelID,
                                                                iPriority,
                                                                SenderID,
                                                                (LPFILEREJECTPDU)lpNewPDU,
                                                                IsUniformSendData);
            if(bWasHandled)
            {
                TRACEPDU(" File Reject PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileAbortPDU:
#ifdef ENABLE_CONDUCTORSHIP
        if(m_bInConductedMode)
        {
            LPFILEABORTPDU lpAbortPDU  = (LPFILEABORTPDU)lpNewPDU;
            T120UserID MBFTUserID = lpAbortPDU->GetTransmitterID();

            //MBFT 8.11.2
            //If no MBFTUserID is specified, all providers must stop transmission...

            if(!MBFTUserID)
            {
                AbortAllSends();
                bWasHandled = TRUE;
            }
            else if(MBFTUserID == m_uidMyself)
            {
                //If only MBFTUserID is specified, all transmissions by that
                //MBFT provider must cease....
            
                if(!lpAbortPDU->GetFileHandle() && !lpAbortPDU->GetDataChannelID())
                {
                    AbortAllSends();
                    bWasHandled = TRUE;
                }
                else
                {
                    if (lpMBFTSession->IsSendSession())
                    {
                        MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
                        bWasHandled = pSendSession->OnReceivedFileAbortPDU(
                            wChannelID,
                            iPriority,
                            SenderID,
                            (LPFILEABORTPDU)lpNewPDU,
                            IsUniformSendData);
                    }
                }
            }
            else
            {
                //Message was not meant for us...
                bWasHandled = TRUE;
            }
        }
        else
#endif // ENABLE_CONDUCTORSHIP
        {
            bWasHandled = TRUE;
        }                

        if(bWasHandled)
        {
            TRACEPDU(" File Abort PDU from [%u]\n",SenderID);
        }                                                                
        break;

    case EnumFileStartPDU:
        if (lpMBFTSession->IsReceiveSession())
        {
            MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) lpMBFTSession;
            bWasHandled = pRecvSession->OnReceivedFileStartPDU(wChannelID,
                                                               iPriority,
                                                               SenderID,
                                                               (LPFILESTARTPDU)lpNewPDU,
                                                               IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" File Start PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileDataPDU:
        if (lpMBFTSession->IsReceiveSession())
        {
            MBFTPrivateReceive *pRecvSession = (MBFTPrivateReceive *) lpMBFTSession;
            bWasHandled = pRecvSession->OnReceivedFileDataPDU(wChannelID,
                                                              iPriority,
                                                              SenderID,
                                                              (LPFILEDATAPDU)lpNewPDU,
                                                              IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" File Data PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumPrivateChannelInvitePDU:
        bWasHandled    =   TRUE;                                                            
        TRACEPDU(" Private Channel Invite PDU from [%u]\n",SenderID);
        break;

    case EnumPrivateChannelResponsePDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedPrivateChannelResponsePDU(wChannelID,
                                                                            iPriority,
                                                                            SenderID,
                                                                            (LPPRIVATECHANNELRESPONSEPDU)lpNewPDU,
                                                                            IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" Private Channel Response PDU from [%u]\n",SenderID);
            }                                                                             
        }
        break;

    case EnumNonStandardPDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedNonStandardPDU(wChannelID,
                                                                 iPriority,
                                                                 SenderID,
                                                                 (LPNONSTANDARDPDU)lpNewPDU,
                                                                 IsUniformSendData);                
            if(bWasHandled)
            {
                TRACEPDU(" Non Standard PDU from [%u]\n",SenderID);
            }
        }
        break;

    case EnumFileErrorPDU:
        bWasHandled = lpMBFTSession->OnReceivedFileErrorPDU(wChannelID,
                                                            iPriority,
                                                            SenderID,
                                                            (LPFILEERRORPDU)lpNewPDU,
                                                            IsUniformSendData);                
        if(bWasHandled)
        {
            TRACEPDU(" File Error PDU from [%u]\n",SenderID);
        }
        break;

    case EnumFileRequestPDU:
        bWasHandled = OnReceivedFileRequestPDU(wChannelID,
                                            iPriority,
                                            SenderID,
                                            (LPFILEREQUESTPDU)lpNewPDU,
                                            IsUniformSendData);
        if(bWasHandled)
        {
            TRACEPDU(" File Request PDU from [%u]\n",SenderID);
        }
        break;

    case EnumFileDenyPDU:
        TRACE(" *** WARNING (MBFT): Received File Deny PDU from [%u] *** \n",SenderID);
        bWasHandled = TRUE;
        break;

    case EnumDirectoryRequestPDU:
        bWasHandled = OnReceivedDirectoryRequestPDU(wChannelID,
                                                    iPriority,
                                                    SenderID,
                                                    (LPDIRECTORYREQUESTPDU)lpNewPDU,
                                                    IsUniformSendData);
        if(bWasHandled)
        {
            TRACEPDU(" DirectoryRequest PDU from [%u]\n",SenderID);
        }
        break;

    case EnumDirectoryResponsePDU:
        TRACE(" *** WARNING (MBFT): Received Directory Response PDU from [%u] *** \n",SenderID);
        bWasHandled = TRUE;
        break;

    case EnumPrivilegeAssignPDU:
        bWasHandled = OnReceivedPrivilegeAssignPDU(wChannelID,
                                                   iPriority,
                                                   SenderID,
                                                   (LPPRIVILEGEASSIGNPDU)lpNewPDU,
                                                   IsUniformSendData);
        break;

#if     0        
//Do not delete this code...
//It may become part of the MBFT standard in the future...
    
    case EnumFileEndAcknowledgePDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedFileEndAcknowledgePDU(wChannelID,
                                                                        iPriority,
                                                                        SenderID,
                                                                        (LPFILEENDACKNOWLEDGEPDU)lpNewPDU,
                                                                        IsUniformSendData);
        }
        break;
 
    case EnumChannelLeavePDU:
        if (lpMBFTSession->IsSendSession())
        {
            MBFTPrivateSend *pSendSession = (MBFTPrivateSend *) lpMBFTSession;
            bWasHandled = pSendSession->OnReceivedChannelLeavePDU(wChannelID,
                                                                  iPriority,
                                                                  SenderID,
                                                                  (LPCHANNELLEAVEPDU)lpNewPDU,
                                                                  IsUniformSendData);
        }
        break;
//Do not delete this code...
//It may become part of the MBFT standard in the future...
#endif
    
    default:
       TRACE(" *** WARNING (MBFT): Unhandled PDU from [%u] *** \n",SenderID);
       bWasHandled = TRUE; // LONCHANC: this should be false, right? why true?
       break;
    } // switch

    return(bWasHandled);
}

                                
BOOL MBFTEngine::OnReceivedPrivateChannelInvitePDU(T120ChannelID wChannelID,
                                                   T120Priority iPriority,
                                                   T120UserID SenderID,
                                                   LPPRIVATECHANNELINVITEPDU lpNewPDU,
                                                   BOOL IsUniformSendData)
{                                                   
    if(m_State == IdleInitialized)
    {
        DBG_SAVE_FILE_LINE
        MBFTMsg *pMsg = new CreateSessionMsg(MBFT_PRIVATE_RECV_TYPE,
                                             ::GetNewEventHandle(),
                                             0,
                                             lpNewPDU->GetControlChannel(),
                                             lpNewPDU->GetDataChannel());
        if (NULL != pMsg)
        {
            DoStateMachine(pMsg);
            delete pMsg;
        }
    }

    return(TRUE);
}

                                          
BOOL MBFTEngine::OnReceivedFileRequestPDU(T120ChannelID wChannelId,
                                          T120Priority iPriority,
                                          T120UserID SenderID,
                                          LPFILEREQUESTPDU lpNewPDU,
                                          BOOL IsUniformSendData)
{
    BOOL bReturn = FALSE;
    
    DBG_SAVE_FILE_LINE
    LPFILEDENYPDU lpDenyPDU = new FileDenyPDU(lpNewPDU->GetRequestHandle());
    if(lpDenyPDU)
    {
        if(lpDenyPDU->Encode())
        {
            if (SendDataRequest(SenderID, APPLET_HIGH_PRIORITY,
                                (LPBYTE)lpDenyPDU->GetBuffer(),
                                lpDenyPDU->GetBufferLength()))
            {
                bReturn = TRUE;
            }                                                 
        }
    }
    
    return(bReturn);
}

BOOL MBFTEngine::OnReceivedDirectoryRequestPDU(T120ChannelID wChannelId,
                                               T120Priority iPriority,
                                               T120UserID SenderID,
                                               LPDIRECTORYREQUESTPDU lpNewPDU,
                                               BOOL IsUniformSendData)
{
    BOOL bReturn = FALSE;

    DBG_SAVE_FILE_LINE
    LPDIRECTORYRESPONSEPDU lpDirPDU = new DirectoryResponsePDU();
    if(lpDirPDU)
    {
        if(lpDirPDU->Encode())
        {
            if (SendDataRequest(SenderID, APPLET_HIGH_PRIORITY,
                                (LPBYTE)lpDirPDU->GetBuffer(),
                                lpDirPDU->GetBufferLength()))
            {
                bReturn = TRUE;
            }                                                 
        }
    }
    
    return(bReturn);
}
                                        
BOOL MBFTEngine::OnReceivedPrivilegeAssignPDU(T120ChannelID wChannelId,
                                              T120Priority iPriority,
                                              T120UserID SenderID,
                                              LPPRIVILEGEASSIGNPDU lpNewPDU,
                                              BOOL IsUniformSendData)
{
#ifdef ENABLE_CONDUCTORSHIP
    if(m_bInConductedMode)
    {
        m_ConductedModePermission  =  lpNewPDU->GetPrivilegeWord();
    }
#endif

    return(TRUE);
}
                                                                             

#ifdef ENABLE_CONDUCTORSHIP
void MBFTEngine::ApplyForPermission(void)
{
    //m_bWaitingForPermission is set to make sure that we don't keep
    //reapplying for permission until the conductor changes...
    
    if(!m_bWaitingForPermission && m_bInConductedMode)
    {
        //MBFT 8.11.1
        //If there is a MBFT conductor at the conducting node, we send
        //a PrivilegeRequestPDU to the conductor....
        
        if(m_MBFTConductorID)
        {
            DBG_SAVE_FILE_LINE
            PrivilegeRequestPDU * lpNewPDU  =   new PrivilegeRequestPDU(PrivilegeRequestPDU::EnumFileTransfer | 
                                                                        PrivilegeRequestPDU::EnumPrivateChannel | 
                                                                        PrivilegeRequestPDU::EnumNonStandard);
            if(lpNewPDU)
            {
                if(lpNewPDU->Encode())
                {
                    if (SendDataRequest(m_MBFTConductorID, APPLET_HIGH_PRIORITY,
                                        (LPBYTE)lpNewPDU->GetBuffer(),
                                        lpNewPDU->GetBufferLength()))       
                    {
                        m_bWaitingForPermission = TRUE;
                    }
                }
                
                delete  lpNewPDU;
            }
        }
        else
        {
            //MBFT 8.11.2
            //Ask for permission via Node Controller...
        }
    }
}                                        
#endif // ENABLE_CONDUCTORSHIP

        
BOOL MBFTEngine::DoStateMachine(MBFTMsg *pMsg)
{
    BOOL fDeleteThisMessage = TRUE;
    if (m_fConfAvailable)
    {
        BOOL fHandled = (NULL != pMsg) ? HandleSessionCreation(pMsg) : FALSE;

#ifdef ENABLE_CONDUCTORSHIP
        //Logic:    If we are in the conducted mode, we check to see if
        //          we have sufficient privileges. If not, we make
        //          an attempt to secure the requisite privileges....
        if(m_bInConductedMode)
        {
            if(!ConductedModeOK())
            {
                if(!m_bWaitingForPermission)
                {
                    ApplyForPermission();
                }
            }
        }
#endif // ENABLE_CONDUCTORSHIP

        if (NULL != pMsg && ! fHandled)
        {
            fDeleteThisMessage = ProcessMessage(pMsg);
        }

        if (m_State == IdleInitialized && ! m_SessionList.IsEmpty())
        {
            CSessionList SessionListCopy(&m_SessionList);
            MBFTSession *pSession;
            while (NULL != (pSession = SessionListCopy.Get()))
            {
                pSession->DoStateMachine();
            }
        }
    }
    return fDeleteThisMessage;
}


//
//  T120 Callback
//


void MBFTEngine::OnSendDataIndication
(
    BOOL                IsUniformSendData,
    T120UserID          SenderID,
    T120ChannelID       wChannelID,
    T120Priority        iPriority,
    ULONG               ulDataLength,
    LPBYTE              lpBuffer
)
{
    GenericPDU * lpNewPDU   = NULL;
    LPCSTR lpDecodeBuffer   = NULL;        
    BOOL bAddToPendingList  = FALSE;
    
    {
        MBFTPDUType DecodedPDUType = GenericPDU::DecodePDU(
                        (LPSTR) lpBuffer,
                        ulDataLength,
                        &lpNewPDU,
                        &lpDecodeBuffer,
                        m_uidMyself,
                        m_pAppletSession);
        if(DecodedPDUType != EnumUnknownPDU)
        {
            ASSERT (m_pAppletSession != NULL);
            DBG_SAVE_FILE_LINE
            MBFTPDUMsg * lpNewMessage = new MBFTPDUMsg(wChannelID,
                                                       iPriority,
                                                       SenderID, 
                                                       lpNewPDU,               
                                                       IsUniformSendData,
                                                       DecodedPDUType,
                                                       (LPSTR)lpDecodeBuffer);
            
            //Now that we have received a valid PDU, we must make sure that
            //we know about this particular MBFT peer. If not, we add the PDU
            //message to a different list....
            
            if(IsValidPeerID(SenderID)  && m_State == IdleInitialized)
            {
                //If the FileOffer is received on the default Control channel, it
                //cannot be a private subsession send. Therefore, we create a special
                //receive session to handle this case....
#ifdef USE_BROADCAST_RECEIVE
                if(DecodedPDUType == EnumFileOfferPDU && wChannelID == m_MBFTControlChannel)
                {
                    FileOfferPDU * lpFileOffer = (FileOfferPDU *)lpNewPDU;

                    DBG_SAVE_FILE_LINE
                    MBFTMsg *pMsg = new CreateSessionMsg(MBFT_BROADCAST_RECV_TYPE,
                                                         ::GetNewEventHandle(),
                                                         0,
                                                         m_MBFTControlChannel,
                                                         lpFileOffer->GetDataChannelID(),
                                                         SenderID,
                                                         lpFileOffer->GetFileHandle());
                    if (NULL != pMsg)
                    {
                        DoStateMachine(pMsg);
                        delete pMsg;
                    }
                }            
                else
#endif    // USE_BROADCAST_RECEIVE

                if(DecodedPDUType == EnumPrivateChannelInvitePDU && wChannelID == m_uidMyself)
                {
                    //In theory, the PrivateChannelInvitePDU marks the beginning of
                    //a PrivateSubsession receive. Therefore, we create one to handle all subsequent
                    //notifications....
                    
                    OnReceivedPrivateChannelInvitePDU(wChannelID,
                                                      iPriority,
                                                      SenderID,
                                                      (LPPRIVATECHANNELINVITEPDU)lpNewPDU,
                                                      IsUniformSendData);                                
                }            

                SafePostMessage(lpNewMessage);
            }   //  if(IsValidPeerID(SenderID))
            else
            {
                WARNING_OUT((" Received PDU from unknown peer [%u], adding to pending message list\n", (UINT) SenderID));
                delete lpNewMessage;
            }
        }
        else
        {
            TRACE(" PDU Decoding Error or Invalid PDU\n");
            
        }

        // Unless this is one of the special 3 types of PDUs, we also
        // need to free the MCS buffer.  In the 3 special cases, the PDUs
        // are responsible for freeing the buffer when they are done.
        if ((DecodedPDUType != EnumFileDataPDU) &&
            (DecodedPDUType != EnumNonStandardPDU) &&
            (DecodedPDUType != EnumFileStartPDU))
        {
            m_pAppletSession->FreeSendDataBuffer((void *) lpBuffer);
        }
    }
}


void MBFTEngine::OnRosterReportIndication
(
    ULONG               cRosters,
    GCCAppRoster       *aAppRosters[] // array, size_is(cRosters)
)
{
    TRACEGCC(" RosterReport: Session count %u\n", (UINT) cRosters); 

    UINT Index, PeerIndex, CapIndex;
    LPCSTR lpszAppKey = NULL;
    BOOL fConductorFound = FALSE;

    CPeerList NewPeerList;
    CPeerData *pOldPeer;

    if (0 == cRosters) // not bloody likely
    {
        return;
    }

    for (Index = 0; Index < cRosters; Index++ )
    {
        GCCAppRoster *pRoster = aAppRosters[Index];
        if (pRoster->session_key.session_id != m_SessionID)
        {
            // this roster is not for our session...ignore it
            continue;
        }

        //Added by Atul on 7/18 to fix missing roster instance bug...
        m_nRosterInstance = pRoster->instance_number;

        TRACEGCC( " Peer count [%u]\n", (UINT) pRoster->number_of_records );
        
        for (PeerIndex = 0; PeerIndex < pRoster->number_of_records; PeerIndex++)
        {
            GCCAppRecord *pRecord = pRoster->application_record_list[PeerIndex];
            lpszAppKey = NULL;

            TRACE( "Local Entity ID [%u], Entity ID [%u], Node ID [%u], MBFTUser ID [%u]\n",
                   (UINT) m_eidMyself,
                   (UINT) pRecord->entity_id,
                   (UINT) pRecord->node_id,
                   (UINT) pRecord->application_user_id );

            BOOL IsProshareNode = FALSE;
            BOOL bEOFAcknowledgment = FALSE;

            if (0 == Index)
            {
                for (CapIndex=0; CapIndex < pRoster->number_of_capabilities; CapIndex++)
                {
                    GCCAppCap *pCap = pRoster->capabilities_list[CapIndex];
                    if (GCC_STANDARD_CAPABILITY != pCap->capability_id.capability_id_type)
                    {
                        continue;
                    }
                    switch (pCap->capability_id.standard_capability)
                    {
                    case _MBFT_MAX_FILE_SIZE_ID:
                        m_MBFTMaxFileSize = pCap->capability_class.nMinOrMax;
                        TRACEGCC( "max file size set to %u\n", (UINT) m_MBFTMaxFileSize );
                        break;

                    case _MBFT_MAX_DATA_PAYLOAD_ID:
                        m_MBFTMaxDataPayload   =  _iMBFT_DEFAULT_MAX_FILEDATA_PDU_LENGTH;
                        if (pCap->number_of_entities == pRoster->number_of_records)
                        {
                            m_MBFTMaxDataPayload = pCap->capability_class.nMinOrMax;
                        }                            
                        TRACEGCC( "max data payload set to %u\n", (UINT) m_MBFTMaxDataPayload );
                        break;

                    case _MBFT_V42_COMPRESSION_ID:
                        m_bV42CompressionSupported = (BOOL) (pCap->number_of_entities == pRoster->number_of_records);
                        TRACEGCC( "V.42bis compression is now %ssupported\n", m_bV42CompressionSupported ? "" : "not " );
                        break;
                    }
                } // for CapIndex
            } // if 0 == Index

            // TODO: only check for 'ProShare node' if this node is new to us
            for (CapIndex = 0; CapIndex < pRecord->number_of_non_collapsed_caps; CapIndex++)
            {
                GCCNonCollCap *pCap2 = pRecord->non_collapsed_caps_list[CapIndex];
                if (GCC_STANDARD_CAPABILITY == pCap2->capability_id.capability_id_type)
                {
                    if (_iMBFT_FIRST_PROSHARE_CAPABILITY_ID == pCap2->capability_id.standard_capability)
                    {
                        LPSTR pszData = (LPSTR) pCap2->application_data->value;
                        if (pCap2->application_data->length > sizeof(PROSHARE_STRING))
                        {
                            if (0 == ::memcmp(pszData, PROSHARE_STRING, sizeof(PROSHARE_STRING)))
                            {
                                IsProshareNode = TRUE;
                                lpszAppKey     = &pszData[sizeof(PROSHARE_STRING)]; 
                            }
                        }
                    } 
                    else
                    if (_iMBFT_PROSHARE_FILE_EOF_ACK_ID == pCap2->capability_id.standard_capability)
                    {
                        LPSTR pszData = (LPSTR) pCap2->application_data->value;
                        if (pCap2->application_data->length >= sizeof(PROSHARE_FILE_END_STRING) - 1)
                        {
                            if (0 == ::memcmp(pszData, PROSHARE_FILE_END_STRING, sizeof(PROSHARE_FILE_END_STRING) - 1))
                            {
                                bEOFAcknowledgment = TRUE;
                            }
                        }
                    } 
                } // if std cap
            } // for CapIndex
    
            BOOL IsLocalNode = (m_eidMyself == pRecord->entity_id) && (m_nidMyself == pRecord->node_id);
    
            if( ( IdleNotInitialized == m_State )
            &&     IsLocalNode 
            &&     pRecord->is_enrolled_actively )
            {
                m_State                 = IdleInitialized;
                // m_uidMyself             = pRecord->application_user_id;
                m_MBFTControlChannel    = m_SessionID;
            }
            
#ifdef ENABLE_CONDUCTORSHIP
            if( m_bInConductedMode )
            {
                if (pRecord->node_id == m_ConductorNodeID &&
                    pRecord->is_conducting_capable)
                {
                    //Now that we have found a conductor on the conducting node,
                    //our search is over....
                    
                    //Make sure that the previously assigned conductor is still 
                    //present in the roster report...
                    
                    if( m_MBFTConductorID )
                    {
                        if( m_MBFTConductorID == pRecord->application_user_id )
                        {
                            fConductorFound  = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        //First time conductor assignment.....
                        m_MBFTConductorID = pRecord->application_user_id;
                        fConductorFound = TRUE;
                        if(m_ConductorNodeID != m_nidMyself)
                        {
                            m_ConductedModePermission = 0;
                            m_bWaitingForPermission = FALSE;
                        }
                        break;
                    }
                }
            }
#endif // ENABLE_CONDUCTORSHIP

            // build a new peer list
            if (pRecord->is_enrolled_actively)
            {
                DBG_SAVE_FILE_LINE
                CPeerData *lpPeer = new CPeerData( 
                            pRecord->node_id, 
                            pRecord->application_user_id, 
                            IsLocalNode, 
                            IsProshareNode,
                            pRecord->is_conducting_capable,
                            bEOFAcknowledgment,
                            lpszAppKey,
                            (DWORD)((pRecord->node_id == m_nidMyself)?((VER_PRODUCTVERSION_DW&0xffff0000)>>16):
                            T120_GetNodeVersion(m_nConfID, pRecord->node_id)));
                if (NULL == lpPeer)
                {
                    ASSERT(0);
                    return;
                }
                NewPeerList.Append(lpPeer);
                pOldPeer = m_PeerList.FindSamePeer(lpPeer);
                if (NULL != pOldPeer)
                {
                    // we already new about this peer
                    m_PeerList.Delete(pOldPeer);
                }
                else 
                {
                    // this is a new peer
                    AddPeerNotification(
                        pRecord->node_id,
                        pRecord->application_user_id,
                        IsLocalNode,
                        IsProshareNode,
                        TRUE,
                        lpszAppKey ? lpszAppKey : "", // TODO: address appkey issue here; needed?
                        pRoster->session_key.session_id );
                }
            }
        }
    }

#ifdef ENABLE_CONDUCTORSHIP
    //If we are on the conducting node, we need no privileges...
    if (m_bInConductedMode && (m_ConductorNodeID != m_nidMyself))
    {
        //MBFT 8.11.1
        //If the previously assigned conductor is not present in the roster report, 
        //all privileges are revoked and we should abort all sends...
        if( !fConductorFound )
        {
            AbortAllSends();
        }
    }
#endif // ENABLE_CONDUCTORSHIP

    while (NULL != (pOldPeer = m_PeerList.Get()))
    {
        AddPeerNotification( 
            pOldPeer->GetNodeID(),
            pOldPeer->GetUserID(),
            pOldPeer->GetIsLocalNode(),
            pOldPeer->GetIsProshareNode(),
            FALSE,
            MY_APP_STR, 
            m_SessionID );

        DBG_SAVE_FILE_LINE
        CPeerData *p = new CPeerData(
                        pOldPeer->GetNodeID(),
                        pOldPeer->GetUserID(),
                        pOldPeer->GetIsLocalNode(),
                        pOldPeer->GetIsProshareNode(),
                        pOldPeer->GetCanConduct(),
                        pOldPeer->GetEOFAcknowledge(),
                        pOldPeer->GetAppKey(),
                        pOldPeer->GetVersion());
        ASSERT(NULL != p);
        if (p)
        {
            DBG_SAVE_FILE_LINE
            SafePostMessage(new PeerDeletedMsg(p));
        }
        TRACEGCC("Peer Removed: Node [%u], UserID [%u]\n", pOldPeer->GetNodeID(), pOldPeer->GetUserID() );
        delete pOldPeer;
    }

    while (NULL != (pOldPeer = NewPeerList.Get()))
    {
        m_PeerList.Append(pOldPeer);
    }

    // notify UI of new rosters
    if (NULL != m_pWindow)
    {
        m_pWindow->UpdateUI();
    }
}


void MBFTEngine::OnChannelAdmitIndication
(
    T120ChannelID               nChannelID,
    T120UserID                  nManagerID
)
{
    if (IsValidPeerID(nManagerID) && m_State == IdleInitialized)
    {
        DBG_SAVE_FILE_LINE
        SafePostMessage(new MCSChannelAdmitIndicationMsg(nChannelID, nManagerID));
    }
}



void CALLBACK T120Callback
(
    T120AppletSessionMsg   *pMsg
)
{
    MBFTEngine *pEngine = (MBFTEngine *) pMsg->pSessionContext;
    ASSERT(NULL != pEngine);

    BOOL fSuccess;
    T120ChannelID nChannelID;

    switch (pMsg->eMsgType)
    {
    case T120_JOIN_SESSION_CONFIRM:
        pEngine->OnJoinSessionConfirm(&pMsg->JoinSessionConfirm);
        break;

    case GCC_APP_ROSTER_REPORT_INDICATION:
        pEngine->OnRosterReportIndication(pMsg->AppRosterReportInd.cRosters,
                                          pMsg->AppRosterReportInd.apAppRosters);
        break;

    // case GCC_APPLICATION_INVOKE_CONFIRM:
        // break;

    case MCS_SEND_DATA_INDICATION:
    case MCS_UNIFORM_SEND_DATA_INDICATION: 
        pEngine->OnSendDataIndication(
            (pMsg->eMsgType == MCS_UNIFORM_SEND_DATA_INDICATION),
            pMsg->SendDataInd.initiator,
            pMsg->SendDataInd.channel_id,
            (T120Priority) pMsg->SendDataInd.data_priority,
            pMsg->SendDataInd.user_data.length,
            pMsg->SendDataInd.user_data.value);
        break;

    case MCS_CHANNEL_JOIN_CONFIRM:
        fSuccess = (T120_RESULT_SUCCESSFUL == pMsg->ChannelConfirm.eResult);
        DBG_SAVE_FILE_LINE
        pEngine->SafePostMessage(new MCSChannelJoinConfirmMsg(pMsg->ChannelConfirm.nChannelID, fSuccess));
        break;

    case MCS_CHANNEL_CONVENE_CONFIRM:
        fSuccess = (T120_RESULT_SUCCESSFUL == pMsg->ChannelConfirm.eResult);
        DBG_SAVE_FILE_LINE
        pEngine->SafePostMessage(new MCSChannelConveneConfirmMsg(pMsg->ChannelConfirm.nChannelID, fSuccess));
        break;

    // case MCS_CHANNEL_LEAVE_INDICATION:
    //     break;

    // case MCS_CHANNEL_DISBAND_INDICATION:
    //    break;

    case MCS_CHANNEL_ADMIT_INDICATION:
        pEngine->OnChannelAdmitIndication(pMsg->ChannelInd.nChannelID, pMsg->ChannelInd.nManagerID);
        break;

    case MCS_CHANNEL_EXPEL_INDICATION:
        DBG_SAVE_FILE_LINE
        pEngine->SafePostMessage(new MCSChannelExpelIndicationMsg(pMsg->ChannelInd.nChannelID, pMsg->ChannelInd.eReason));
        break;

    // case MCS_TOKEN_GRAB_CONFIRM:
    // case MCS_TOKEN_INHIBIT_CONFIRM:
    // case MCS_TOKEN_GIVE_CONFIRM:
    // case MCS_TOKEN_RELEASE_CONFIRM:
    // case MCS_TOKEN_TEST_CONFIRM:
    //    break;

    // case MCS_TOKEN_GIVE_INDICATION:
    // case MCS_TOKEN_PLEASE_INDICATION:
    // case MCS_TOKEN_RELEASE_INDICATION:
    //     break;

    case MCS_DETACH_USER_INDICATION:
        pEngine->OnDetachUserIndication(pMsg->DetachUserInd.nUserID, pMsg->DetachUserInd.eReason);
        break;

    case MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION:
                g_fWaitingForBufferAvailable = FALSE;
        ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), 
                                                MBFTMSG_HEART_BEAT, 0, (LPARAM) pEngine);
                break;
    }
}


BOOL MBFTEngine::SimpleChannelRequest
(
    AppletChannelCommand    eCommand,
    T120ChannelID           nChannelID
)
{
    T120ChannelRequest req;
    ::ZeroMemory(&req, sizeof(req));
    req.eCommand = eCommand;
    req.nChannelID = nChannelID;
    T120Error rc = m_pAppletSession->ChannelRequest(&req);
    return (T120_NO_ERROR == rc);
}

T120NodeID MBFTEngine::GetNodeIdByUserID(T120UserID nUserID)
{
        CPeerData *p;
        m_PeerList.Reset();
        while (NULL != (p = m_PeerList.Iterate()))
        {
                if (nUserID == p->GetUserID())
                {
                        return p->GetNodeID();
                }
        }
        return 0;
}

BOOL MBFTEngine::MCSChannelAdmitRequest
(
    T120ChannelID       nChannelID,
    T120UserID         *aUsers,
    ULONG               cUsers
)
{
    T120ChannelRequest req;
    ::ZeroMemory(&req, sizeof(req));
    req.eCommand = APPLET_ADMIT_CHANNEL;
    req.nChannelID = nChannelID;
    req.cUsers = cUsers;
    req.aUsers = aUsers;
    T120Error rc = m_pAppletSession->ChannelRequest(&req);
    return (T120_NO_ERROR == rc);
}

BOOL MBFTEngine::SendDataRequest
(
    T120ChannelID       nChannelID,
    T120Priority        ePriority,
    LPBYTE              pBuffer,
    ULONG               cbBufSize
)
{
    if (m_eLastSendDataError == MCS_TRANSMIT_BUFFER_FULL)
    {
        if (g_fWaitingForBufferAvailable == FALSE)
        {
            m_eLastSendDataError = MCS_NO_ERROR;
        }
        else
        {
            TRACEMCS("MBFTEngine::SendDataReques still waiting for a MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION");
            return FALSE;
        }
    }

    m_eLastSendDataError = m_pAppletSession->SendData(
                        NORMAL_SEND_DATA, nChannelID, ePriority,
                        pBuffer, cbBufSize, APP_ALLOCATION);
    //
    // T120 is busy and can't allocate data
    //
    if (m_eLastSendDataError == MCS_TRANSMIT_BUFFER_FULL)
    {
        g_fWaitingForBufferAvailable = TRUE;
        TRACEMCS("MCSSendDataRequest failed we will not send data until we get a MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION");
    }

    return (T120_NO_ERROR == m_eLastSendDataError);
}


//
// CPeerList
//

CPeerData * CPeerList::Find(T120NodeID nNodeID)
{
    CPeerData *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->GetUserID() == nNodeID)
        {
            return p;
        }
    }
    return NULL;
}

CPeerData * CPeerList::FindSamePeer(CPeerData *pPeer)
{
    CPeerData *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (pPeer->GetNodeID() == p->GetNodeID() && pPeer->GetUserID() == p->GetUserID())
        {
            return p;
        }
    }
    return NULL;
}

void CPeerList::Delete(CPeerData *p)
{
    if (Remove(p))
    {
        delete p;
    }
}

void CPeerList::DeleteAll(void)
{
    CPeerData *p;
    while (NULL != (p = Get()))
    {
        delete p;
    }
}


void CSessionList::Delete(MBFTSession *p)
{
    if (Remove(p))
    {
        delete p;
    }
}


// thought it is a pure virtual, we still need a destructor
MBFTSession::~MBFTSession(void) { }


HRESULT MBFTEngine::SafePostNotifyMessage(MBFTMsg *p)
{
    // notify applet UI if it exists
    if (NULL != m_pWindow)
    {
        m_pWindow->OnEngineNotify(p);
    }

    if (NULL != m_pMBFTIntf)
    {
        return m_pMBFTIntf->SafePostNotifyMessage(p);
    }

    delete p;
    return S_OK;
}



MBFTEVENTHANDLE GetNewEventHandle(void)
{
    static ULONG s_nEventHandle = 0x55AA;
    ULONG nEvtHdl;

    ::EnterCriticalSection(&g_csWorkThread);
    if (s_nEventHandle > 0xFFFF)
    {
        s_nEventHandle = 0x55AA;
    }
    nEvtHdl = s_nEventHandle++;
    ::LeaveCriticalSection(&g_csWorkThread);

    return nEvtHdl;
}


MBFTFILEHANDLE GetNewFileHandle(void)
{
    static ULONG s_nFileHandle = 1;
    ULONG nFileHdl;

    ::EnterCriticalSection(&g_csWorkThread);
    if (s_nFileHandle > 0xFFFF)
    {
        s_nFileHandle = 0x1;
    }
    nFileHdl = s_nFileHandle++;
    ::LeaveCriticalSection(&g_csWorkThread);

    return nFileHdl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftdbg.h ===
/* file: mbftdbg.h */

#ifndef __MBFTDBG_H__
#define __MBFTDBG_H__

#ifdef  __cplusplus
extern "C"
{
#endif


#ifdef _DEBUG
    VOID  InitDebug(void);
    VOID  DeInitDebugMbft(void);
    PCSTR FAR PASCAL GetMbftRcString(DWORD dwRc);
    LPCTSTR GetMcsErrorString(MCSError mcsError);
#else
    #define InitDebug()
    #define DeInitDebugMbft()
#endif


#ifdef _DEBUG

VOID DbgMsgMbft(PCHAR psz,...);

extern HDBGZONE ghZoneMbft;

#define ZONE_MBFT_SEND          0x0000
#define ZONE_MBFT_MCS           0x0001
#define ZONE_MBFT_RECEIVE       0x0002
#define ZONE_MBFT_STATE         0x0003
#define ZONE_MBFT_INIT          0x0004
#define ZONE_MBFT_GCC           0x0005
#define ZONE_MBFT_PDU           0x0006
#define ZONE_MBFT_DELETE        0x0007
#define ZONE_MBFT_API           0x0008
#define ZONE_MBFT_COMPRESS      0x0009
#define ZONE_MBFT_OTHER         0x000A

#define _TRACE_SEND             0x0001
#define _TRACE_MCS              0x0002
#define _TRACE_RECEIVE          0x0004
#define _TRACE_STATE            0x0008
#define _TRACE_INIT             0x0010
#define _TRACE_GCC              0x0020
#define _TRACE_PDU              0x0040
#define _TRACE_DELETE           0x0080
#define _TRACE_API              0x0100
#define _TRACE_COMPRESS         0x0200

#define TRACE           DBGMSG(ghZoneMbft, ZONE_MBFT_OTHER, ("Mbft Trace"));\
                        DbgMsgMbft
     
#define TRACESEND       DBGMSG(ghZoneMbft, ZONE_MBFT_SEND, ("SEND(%Fp,%ld): ",m_lpParentEngine,m_EventHandle));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_SEND) \
                        DbgMsgMbft

#define TRACEMCS        DBGMSG(ghZoneMbft, ZONE_MBFT_MCS, ("MCS(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_MCS) \
                        DbgMsgMbft

#define TRACERECEIVE    DBGMSG(ghZoneMbft, ZONE_MBFT_RECEIVE, ("RECEIVE(%Fp,%ld): ",m_lpParentEngine,m_EventHandle));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_RECEIVE) \
                        DbgMsgMbft

#define TRACEAPI        DBGMSG(ghZoneMbft, ZONE_MBFT_API, ("API(%Fp): ",m_pEngine));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_API) \
                        DbgMsgMbft
 
#define TRACESTATE      DBGMSG(ghZoneMbft, ZONE_MBFT_STATE, ("STATE(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_STATE) \
			DbgMsgMbft
                        
#define TRACEINIT       DBGMSG(ghZoneMbft, ZONE_MBFT_INIT, ("INIT(%Fp): ",m_lpParentEngine));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_INIT) \
			DbgMsgMbft
                        
#define TRACEGCC        DBGMSG(ghZoneMbft, ZONE_MBFT_GCC, ("GCC(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_GCC) \
			DbgMsgMbft

#define TRACEPDU        DBGMSG(ghZoneMbft, ZONE_MBFT_PDU, ("PDU(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_PDU) \
			DbgMsgMbft
                        
#define TRACEDELETE     DBGMSG(ghZoneMbft, ZONE_MBFT_DELETE, ("Mbft Delete"));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_DELETE) \
			DbgMsgMbft

#define TRACECOMPRESS   DBGMSG(ghZoneMbft, ZONE_MBFT_COMPRESS, ("Compression: "));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_COMPRESS) \
			DbgMsgMbft

#else

#define TRACE           
     
#define TRACESEND       

#define TRACEMCS        

#define TRACERECEIVE    

#define TRACEAPI        
 
#define TRACESTATE      
                        
#define TRACEINIT       
                        
#define TRACEGCC        

#define TRACEPDU        
                        
#define TRACEDELETE     

#define TRACECOMPRESS   

#endif	// _TRACE


#ifdef  __cplusplus
}
#endif

#endif  //__MBFTDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftapi.hpp ===
#ifndef __MBFTAPI_HPP__
#define __MBFTAPI_HPP__


class MBFTEngine;

class FileOfferNotifyMsg;
class FileTransmitMsg;   
class FileErrorMsg;
class PeerMsg;
class InitUnInitNotifyMsg;
class FileEventEndNotifyMsg;

enum
{
    MBFTNOTIFY_BASIC        = WM_APP + 0x101,
};


class MBFTInterface : public IMbftControl, public CRefCount
{
public:

    STDMETHOD_(void, ReleaseInterface)( THIS);
    STDMETHOD_(void, Update)(           THIS);
    STDMETHOD_(void, CancelFt)(         THIS_
                                        MBFTEVENTHANDLE hEvent,
                                        MBFTFILEHANDLE  hFile);
    STDMETHOD(AcceptFileOffer)(         THIS_
                                        MBFT_FILE_OFFER *pOffer,
                                        LPCSTR pszRecDir,
                                        LPCSTR pszFileName);
    STDMETHOD_(void, RejectFileOffer)(  THIS_
                                        MBFT_FILE_OFFER *pOffer);
    STDMETHOD(SendFile)(                THIS_
                                        LPCSTR pszFileName,
                                        T120NodeID nidReceiver,
                                        MBFTEVENTHANDLE *phEvent,
                                        MBFTFILEHANDLE *phFile);
private:
	
    IMbftEvents        *m_pEvents;

    MBFTEngine  *       m_pEngine;
    HWND                m_hwndNotify;
    BOOL                m_bFileOfferOK;
    LPARAM              m_lpUserDefined;
    MBFTFILEHANDLE      m_FileHandle;
    BOOL                m_InStateMachine;
    T120UserID          m_MBFTUserID;    
    MBFTEVENTHANDLE     m_SendEventHandle;
    MBFTEVENTHANDLE     m_ReceiveEventHandle;

    //Sigh..., the CTK people don't give you a choice...

    static LRESULT PASCAL CTKCallBackFunction(HWND hWnd,UINT Message,
                                                           WPARAM wParam,LPARAM lParam);  
public:
        
    MBFTInterface(IMbftEvents *, HRESULT *);
    ~MBFTInterface(void);

    void SetEngine(MBFTEngine *p) { m_pEngine = p; }

    HRESULT SafePostNotifyMessage(MBFTMsg *pMsg);

    void DoStateMachine(MBFTMsg *pMsg);
    void HandlePeerNotification(PeerMsg * lpNewMessage);
    void HandleFileOfferNotify(FileOfferNotifyMsg * lpNotifyMessage);
    void HandleProgressNotify(FileTransmitMsg * lpProgressMessage);    
    void HandleErrorNotify(FileErrorMsg * lpErrorMessage); 
    void HandleInitUninitNotification(InitUnInitNotifyMsg * lpNewMessage);
    void HandleGenericNotification(FileEventEndNotifyMsg * lpNewMessage);
};

#endif  //__MBFTAPI_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbft.hpp ===
#ifndef __MBFT_HPP__
#define __MBFT_HPP__

#include "osshelp.hpp"
#include "messages.hpp"
#include <it120app.h>

// LONCHANC: temporarily enable conductorship
// #define ENABLE_CONDUCTORSHIP    1

//Intel specific non-collapsing capabilities values....
enum NonCollapsCaps
{
	_iMBFT_FIRST_PROSHARE_CAPABILITY_ID = 0x100,
	_iMBFT_PROSHARE_VERSION_ID____NOT_USED,
	_iMBFT_PROSHARE_FILE_EOF_ACK_ID,
	_iMBFT_LAST_NON_COLLAPSING_CAPABILITIES
};


//Intel specific collapsing capabilities values....

//Note: The size of _iMBFT_MAX_FILEDATA_PDU_LENGTH actually controls the maximum number
//of bytes in the file start and data PDUs. If this is increased, the corresponding constant
//in MCSHELP.HPP (_MAX_MCS_MESSAGE_SIZE) must also be increased...

const USHORT _iMBFT_MAX_FILEDATA_PDU_LENGTH          = 25000;
const USHORT _iMBFT_DEFAULT_MAX_FILEDATA_PDU_LENGTH  = 8192;
const ULONG  _iMBFT_MAX_FILE_SIZE                    = 0xFFFFFFFFUL;
const USHORT _iMBFT_V42_NO_OF_CODEWORDS              = 512;
const USHORT _iMBFT_V42_MAX_STRING_LENGTH            = 6;
const USHORT _iMBFT_V42_COMPRESSION_SUPPORTED        = TRUE;
const USHORT _iMBFT_MAX_COLLAPSING_CAPABILITIES      = 3;

#define    _iMBFT_MAX_NON_COLLAPSING_CAPABILITIES   _iMBFT_LAST_NON_COLLAPSING_CAPABILITIES - _iMBFT_FIRST_PROSHARE_CAPABILITY_ID

//Added by Atul -- another magic number that we subtract from MCSMaxDomainPDU size
//presumably to allow for the overhead added by the lower layers...

const USHORT _iMBFT_FILEDATA_PDU_SUBTRACT            = 64;

//In our implementation we get the max pdu by a proprietary MCS api called
//GetDomainParameters.  No such liberties with MSFT stuff!!
const unsigned int _iMBFT_DEFAULT_MAX_MCS_SIZE = MAX_MCS_DATA_SIZE;

//Standard MBFT identifiers and channel IDs
const USHORT _MBFT_MAX_FILE_SIZE_ID                  = 1;
const USHORT _MBFT_MAX_DATA_PAYLOAD_ID               = 2;
const USHORT _MBFT_V42_COMPRESSION_ID                = 3;
const USHORT _MBFT_V42_NO_OF_CODEWORDS_ID            = 4;
const USHORT _MBFT_V42_MAX_STRING_LENGTH_ID          = 5;


MBFTEVENTHANDLE GetNewEventHandle(void);
MBFTFILEHANDLE GetNewFileHandle(void);


enum MBFTState
{
    IdleNotInitialized,
    IdleInitialized
};

class MBFTInterface;
class MBFTMsg;
class MBFTPDUMsg;
class CAppletWindow;

class MBFTSession;
class CSessionList : public CList
{
    DEFINE_CLIST(CSessionList, MBFTSession *)
    void Delete(MBFTSession *);
};

class CPeerData;
class CPeerList : public CList
{
    DEFINE_CLIST(CPeerList, CPeerData *)
    CPeerData *Find(T120UserID uidPeer);
    BOOL IsValidPeerID(T120UserID uidPeer) { return (NULL != Find(uidPeer)); }
    CPeerData * CPeerList::FindSamePeer(CPeerData *pPeer);
    void CPeerList::Delete(CPeerData *p);
    void DeleteAll(void);
};


//
// MBFT engine, one per conference
//

class MBFTEngine : public CRefCount
{
public:

    MBFTEngine(MBFTInterface *, MBFT_MODE, T120SessionID);
    ~MBFTEngine(void);

private:

    IT120AppletSession     *m_pAppletSession;
    T120Error               m_eLastSendDataError;
    MBFTInterface          *m_pMBFTIntf;

    T120ConfID              m_nConfID;
    MBFT_MODE               m_eMBFTMode;

    T120SessionID           m_SessionID;
    T120UserID              m_uidMyself;
    T120NodeID              m_nidMyself;
    T120EntityID            m_eidMyself;

    T120ChannelID           m_MBFTControlChannel;
    T120ChannelID           m_MBFTDataChannel;

    T120ChannelID           m_aStaticChannels[2];
#ifdef USE_MULTICAST_SESSION
    T120ResourceRequest     m_aJoinResourceReqs[1];
#endif
    T120JoinSessionRequest  m_JoinSessionReq;

    BOOL                    m_fConfAvailable;
    BOOL                    m_fJoinedConf;

    MBFTState               m_State;

    // LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
    BOOL                    m_bInConductedMode;
    T120NodeID              m_ConductorNodeID;
    T120UserID              m_MBFTConductorID;
    ULONG                   m_ConductedModePermission;
    BOOL                    m_bWaitingForPermission;
#endif // ENABLE_CONDUCTORSHIP

    CSessionList            m_SessionList;
    CPeerList               m_PeerList;

    ULONG                   m_nRosterInstance;

    ULONG                   m_MBFTMaxFileSize;
    ULONG                   m_MBFTMaxDataPayload;
    ULONG                   m_MBFTMaxSendDataPayload;
    BOOL                    m_bV42CompressionSupported;
    USHORT                  m_v42bisP1;
    USHORT                  m_v42bisP2;

    MBFTEVENTHANDLE         m_lEventHandle;

    CAppletWindow          *m_pWindow;

#ifdef ENABLE_HEARTBEAT_TIMER
    UINT_PTR                m_nTimerID;
#endif

public:

    //
    // Handy inline methods
    //

    T120Error GetLastSendDataError(void) { return m_eLastSendDataError; }
    CPeerList *GetPeerList(void) { return &m_PeerList; }
    ULONG GetPeerCount(void) { return m_PeerList.GetCount(); }
    T120ConfID GetConfID(void) { return m_nConfID; }
    T120UserID GetUserID(void) { return m_uidMyself; }
    T120NodeID GetNodeID(void) { return m_nidMyself; }
    T120SessionID GetSessionID(void) { return m_SessionID; }

    T120ChannelID GetDefaultControlChannel(void) { return m_MBFTControlChannel; }
    T120ChannelID GetDefaultDataChannel(void) { return m_MBFTDataChannel; }

    BOOL Has2xNodeInConf(void);
	BOOL HasSDK(void);

    void SetConferenceAvailable(BOOL fConfAvailable) { m_fConfAvailable = fConfAvailable; }

    BOOL IsValidPeerID(T120UserID uidPeer) { return m_PeerList.IsValidPeerID(uidPeer); }
    ULONG GetRosterInstance(void) { return m_nRosterInstance; }

    HRESULT SafePostMessage(MBFTMsg *p);
    HRESULT SafePostNotifyMessage(MBFTMsg *p);

    void ClearInterfacePointer(void) { m_pMBFTIntf = NULL; }
    MBFTInterface *GetInterfacePointer(void) { return m_pMBFTIntf; }
    void SetInterfacePointer(MBFTInterface *pIntf);

#ifdef ENABLE_HEARTBEAT_TIMER
    UINT_PTR GetTimerID(void) { return m_nTimerID; }
#endif

    void SetWindow(CAppletWindow *pWindow) { m_pWindow = pWindow; }

    //
    // Conducted-mode methods
    //

// LONCHANC: NetMeeting's Node Controller does not exercise conductorship.
#ifdef ENABLE_CONDUCTORSHIP
    void OnConductAssignIndication(GCCConductorAssignInd *);
    void OnConductReleaseIndication(GCCConferenceID);
    void OnConductGrantIndication(GCCConductorPermitGrantInd *);
    void AbortAllSends(void);
    void ApplyForPermission(void);
    BOOL ConductedModeOK(void);
#else
    BOOL ConductedModeOK(void) { return TRUE; }
#endif // ENABLE_CONDUCTORSHIP


    //
    // Notification for file transfer protocol
    //

    BOOL OnReceivedPrivateChannelInvitePDU(T120ChannelID, T120Priority, T120UserID,
                                       LPPRIVATECHANNELINVITEPDU lpNewPDU,
                                       BOOL IsUniformSendData);
    BOOL OnReceivedFileRequestPDU(T120ChannelID, T120Priority, T120UserID,
                              LPFILEREQUESTPDU lpNewPDU,
                              BOOL IsUniformSendData);
    BOOL OnReceivedDirectoryRequestPDU(T120ChannelID, T120Priority, T120UserID,
                                   LPDIRECTORYREQUESTPDU lpNewPDU,
                                   BOOL IsUniformSendData);
    BOOL OnReceivedPrivilegeAssignPDU(T120ChannelID, T120Priority, T120UserID,
    				 LPPRIVILEGEASSIGNPDU lpNewPDU,
    				 BOOL IsUniformSendData);
    //
    // Common public methods
    //

    BOOL HandleSessionCreation(MBFTMsg *pMsg);
    BOOL DispatchPDUMessage(MBFTSession *, MBFTPDUMsg *);
    BOOL ProcessMessage(MBFTMsg *pMsg);
    BOOL DoStateMachine(MBFTMsg *pMsg);
	void AddAllPeers(void);
	BOOL NoUIMode(void) { return (m_pWindow == NULL); }

private:

    void AddPeerNotification(T120NodeID, T120UserID, BOOL IsLocalNode, BOOL IsProshareNode, BOOL bPeerAdded, LPCSTR lpszAppKey, T120SessionID);

    BOOL SimpleChannelRequest(AppletChannelCommand, T120ChannelID);
	T120NodeID GetNodeIdByUserID(T120UserID UserID);


public:

    //
    // T120 service request
    //

    BOOL MCSChannelJoinRequest(T120ChannelID nChannelID) { return SimpleChannelRequest(APPLET_JOIN_CHANNEL, nChannelID); }
    BOOL MCSChannelLeaveRequest(T120ChannelID nChannelID) { return SimpleChannelRequest(APPLET_LEAVE_CHANNEL, nChannelID); }
    BOOL MCSChannelConveneRequest(void) { return SimpleChannelRequest(APPLET_CONVENE_CHANNEL, 0); }
    BOOL MCSChannelDisbandRequest(T120ChannelID nChannelID) { return SimpleChannelRequest(APPLET_DISBAND_CHANNEL, nChannelID); }

    BOOL MCSChannelAdmitRequest(T120ChannelID, T120UserID *, ULONG cUsers);
    BOOL SendDataRequest(T120ChannelID, T120Priority, LPBYTE lpBuffer, ULONG ulSize);


    //
    // Notification for T.120 applet
    //

    void OnPermitToEnrollIndication(GCCAppPermissionToEnrollInd *);
    void OnJoinSessionConfirm(T120JoinSessionConfirm *);
    void OnDetachUserIndication(T120UserID, T120Reason);
    void OnRosterReportIndication(ULONG cRosters, GCCAppRoster **);
    void OnChannelAdmitIndication(T120ChannelID, T120UserID uidManager);
    void OnSendDataIndication(
                BOOL                fUniformSend,
                T120UserID          nSenderID,
                T120ChannelID       nChannelID,
                T120Priority        ePriority,
                ULONG               cbBufSize,
                LPBYTE              pBufData);
};

typedef MBFTEngine * LPMBFTENGINE;


//
// Peer data
//

class CPeerData
{
private:

    T120UserID      m_NodeID;
    T120UserID      m_MBFTUserID;
    BOOL            m_bIsLocalNode;
    BOOL            m_bIsProshareNode;
    BOOL            m_bCanConduct;
    BOOL            m_bEOFAcknowledgment;
    char            m_szAppKey[MAX_APP_KEY_SIZE];
    DWORD           m_dwVersion;

public:

    CPeerData(UserID NodeID,UserID MBFTUserID,BOOL IsLocalNode,
              BOOL IsProshareNode,BOOL bCanConduct,BOOL m_bEOFAcknowledgment,
              LPCSTR lpszAppKey, DWORD dwVersion);

    ~CPeerData(void) {}

    T120UserID GetUserID(void) { return m_MBFTUserID; }
    T120NodeID GetNodeID(void) { return m_NodeID; }
    BOOL GetIsLocalNode(void) { return m_bIsLocalNode; }
    BOOL GetIsProshareNode(void) { return m_bIsProshareNode; }
    BOOL GetCanConduct(void) { return m_bCanConduct; }
    BOOL GetEOFAcknowledge(void) { return m_bEOFAcknowledgment; }
    LPCSTR GetAppKey(void) { return m_szAppKey; }
    DWORD GetVersion(void) { return m_dwVersion; }
};

typedef CPeerData * LPPEERDATA;


//
// MBFT sub session, the interface class of
//                      MBFTPrivateSend
//                      MBFTPrivateReceive
//                      MBFTBroadcastReceive
//

class MBFTSession
{
public:

    MBFTSession::MBFTSession(MBFTEngine *pEngine, MBFTEVENTHANDLE nEventHandle, MBFT_SESSION_TYPE eType)
    :
        m_lpParentEngine(pEngine),
        m_EventHandle(nEventHandle),
        m_MBFTSessionType(eType)
    {
    }
    virtual ~MBFTSession(void) = 0;

    MBFTEVENTHANDLE GetEventHandle(void) { return m_EventHandle; }
    MBFT_SESSION_TYPE GetSessionType(void) { return m_MBFTSessionType; }
    BOOL IsSendSession(void) { return (MBFT_PRIVATE_SEND_TYPE == m_MBFTSessionType); }
    BOOL IsReceiveSession(void)
    {
        return (MBFT_PRIVATE_SEND_TYPE != m_MBFTSessionType);
    }

    //
    // T120 callback
    //
    virtual BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess) = 0;


    //
    // File transfer protocal callback
    //
    virtual BOOL OnReceivedFileErrorPDU(T120ChannelID, T120Priority, T120UserID,
                                        LPFILEERRORPDU lpNewPDU,
                                        BOOL IsUniformSendData) = 0;
    virtual void OnPeerDeletedNotification(CPeerData * lpPeerData) = 0;
    virtual void OnControlNotification(MBFTFILEHANDLE,
                                       FileTransferControlMsg::FileTransferControl iControlCommand,
                                       LPCSTR lpszDirectory,
                                       LPCSTR lpszFileName) = 0;
    virtual void DoStateMachine(void) = 0;
    virtual void UnInitialize(BOOL bIsShutDown) = 0;

protected:

    LPMBFTENGINE            m_lpParentEngine;
    MBFTEVENTHANDLE         m_EventHandle;
    MBFT_SESSION_TYPE       m_MBFTSessionType;
};

typedef class MBFTSession * LPMBFTSESSION;


#endif  //__MBFT_HPP__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftapi.cpp ===
/* file: mbftApi.cpp */

#include "mbftpch.h"

#include "messages.hpp"
#include "mbftapi.hpp"


MBFT_SEND_FILE_INFO *AllocateSendFileInfo(LPSTR pszPathName);
void FreeSendFileInfo(MBFT_SEND_FILE_INFO *);


MBFTInterface::MBFTInterface
(
    IMbftEvents     *pEvents,
    HRESULT         *pHr
)
:
    CRefCount(MAKE_STAMP_ID('I','F','T','I')),
    m_pEvents(pEvents),
    m_pEngine(NULL),
    m_FileHandle(0),
    m_InStateMachine(FALSE),
    m_bFileOfferOK(TRUE),
    m_MBFTUserID(0),
    m_SendEventHandle(0),
    m_ReceiveEventHandle(0)
{
    // register window class first
    WNDCLASS wc;
    ::ZeroMemory(&wc, sizeof(wc));
    // wc.style         = 0;
    wc.lpfnWndProc      = MBFTNotifyWndProc;
    // wc.cbClsExtra    = 0;
    // wc.cbWndExtra    = 0;
    wc.hInstance        = g_hDllInst;
    // wc.hIcon         = NULL;
    // wc.hbrBackground = NULL;
    // wc.hCursor       = NULL;
    // wc.lpszMenuName  = NULL;
    wc.lpszClassName    = g_szMBFTWndClassName;

    ::RegisterClass(&wc);

    // Create a hidden window for notification
    m_hwndNotify = ::CreateWindowA(g_szMBFTWndClassName, NULL, WS_POPUP,
                        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                        NULL, NULL, g_hDllInst, NULL);
    if (NULL != m_hwndNotify)
    {
        HANDLE hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hEvent)
        {
            if (::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_CREATE_ENGINE, (WPARAM) hEvent, (LPARAM) this))
            {
				DWORD dwRet = ::WaitForSingleObject(hEvent, 1000);
				ASSERT(WAIT_OBJECT_0 == dwRet);
            }
			else
			{
				WARNING_OUT(("MBFTInterface::MBFTInterface: PostMessage failed, err=%d", ::GetLastError()));
			}
           *pHr = (NULL != m_pEngine) ? S_OK : E_FAIL;
            ::CloseHandle(hEvent);
            return;
        }
    }
    *pHr = E_FAIL;
}


MBFTInterface::~MBFTInterface(void)
{
    if (NULL != m_pEngine)
    {
        m_pEngine->ClearInterfacePointer();
        m_pEngine = NULL;
    }

    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
    }
}


void MBFTInterface::ReleaseInterface(void)
{
    Release();
}


void MBFTInterface::Update(void)
{
//    DoStateMachine();
}


HRESULT MBFTInterface::AcceptFileOffer
(
    MBFT_FILE_OFFER    *pOffer,
    LPCSTR              pszRecDir,
    LPCSTR              pszFileName
)
{
    BOOL bAcceptFile = (NULL != pszRecDir) && FEnsureDirExists(pszRecDir);

    DBG_SAVE_FILE_LINE
    return m_pEngine->SafePostMessage(
                new FileTransferControlMsg(
                                pOffer->hEvent,
                                pOffer->lpFileInfoList->hFile,
                                pszRecDir,
                                pszFileName,
                                bAcceptFile ? FileTransferControlMsg::EnumAcceptFile 
                                            : FileTransferControlMsg::EnumRejectFile));
}


void MBFTInterface::RejectFileOffer
(
    MBFT_FILE_OFFER     *pOffer
)
{
    DBG_SAVE_FILE_LINE
    m_pEngine->SafePostMessage(
                new FileTransferControlMsg(
                            pOffer->hEvent,
                            pOffer->lpFileInfoList->hFile,
                            NULL,
                            NULL,
                            FileTransferControlMsg::EnumRejectFile));
}


void MBFTInterface::CancelFt
(
    MBFTEVENTHANDLE     hEvent,
    MBFTFILEHANDLE      hFile
)
{
    DBG_SAVE_FILE_LINE
    m_pEngine->SafePostMessage(
                new FileTransferControlMsg(
                                        hEvent,
                                        hFile,
                                        NULL,
                                        NULL,
                                        FileTransferControlMsg::EnumAbortFile));
}


HRESULT MBFTInterface::SendFile
(
    LPCSTR              lpszFilePath,
	T120NodeID			nidReceiver,
    MBFTEVENTHANDLE    *lpEventHandle,
    MBFTFILEHANDLE     *lpFileHandle
)
{
    if (NULL != m_SendEventHandle)
    {
        // We are waiting for a timeout in a file sent to a 3rd party FT
        // that does not support our file end notification
        return E_PENDING;
    }

#ifdef ENABLE_CONDUCTORSHIP
    if( !m_pEngine->ConductedModeOK() )
    {
        return E_ACCESSDENIED;
    }
#endif

    ::EnterCriticalSection(&g_csWorkThread);

    // set event handle
    *lpEventHandle = ::GetNewEventHandle();

    ::LeaveCriticalSection(&g_csWorkThread);

    DBG_SAVE_FILE_LINE
    HRESULT hr = m_pEngine->SafePostMessage(
                                new CreateSessionMsg(MBFT_PRIVATE_SEND_TYPE, *lpEventHandle));
    if (S_OK == hr)
    {
        *lpFileHandle = ::GetNewFileHandle();

        ULONG cbSize = ::lstrlenA(lpszFilePath)+1;
        DBG_SAVE_FILE_LINE
        LPSTR pszPath = new char[cbSize];
        if (NULL != pszPath)
        {
            ::CopyMemory(pszPath, lpszFilePath, cbSize);

            DBG_SAVE_FILE_LINE
            hr = m_pEngine->SafePostMessage(
                                new SubmitFileSendMsg(
											0, // SDK only knows node ID
											nidReceiver,
                                            pszPath,
                                            *lpFileHandle,
                                            *lpEventHandle,
                                            FALSE));
            if (S_OK == hr)
            {
                m_SendEventHandle = *lpEventHandle;
            }
            else
            {
                delete [] pszPath;
            }
        }
    }

    return hr;
}


void MBFTInterface::DoStateMachine(MBFTMsg *pMsg)
{
    if(!m_InStateMachine)
    {
        BOOL fHeartBeat = FALSE;

        m_InStateMachine = TRUE;

        switch(pMsg->GetMsgType())
        {
        case EnumFileOfferNotifyMsg:
            HandleFileOfferNotify((FileOfferNotifyMsg *) pMsg);
            break;

        case EnumFileTransmitMsg:
            HandleProgressNotify((FileTransmitMsg *) pMsg);
            fHeartBeat = TRUE;
            break;

        case EnumFileErrorMsg:
            HandleErrorNotify((FileErrorMsg *) pMsg);
            break;

        case EnumPeerMsg:
            HandlePeerNotification((PeerMsg *) pMsg);
            break;

        case EnumInitUnInitNotifyMsg:
            HandleInitUninitNotification((InitUnInitNotifyMsg *) pMsg);
            break;

        case EnumFileEventEndNotifyMsg:
            HandleGenericNotification((FileEventEndNotifyMsg *) pMsg);
            break;

        default:
            ASSERT(0);
            break;
        } // switch

        m_InStateMachine = FALSE;

        if (fHeartBeat)
        {
            ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_HEART_BEAT, 0, (LPARAM) m_pEngine);
        }
    }
}



void MBFTInterface::HandleFileOfferNotify(FileOfferNotifyMsg * lpNotifyMessage)
{
    if((m_ReceiveEventHandle == 0) || (m_ReceiveEventHandle != lpNotifyMessage->m_EventHandle))
    {
        TRACEAPI(" File Offer Notification for [%s], Event: [%ld], Size: [%ld], Handle [%Fp]\n",
                 lpNotifyMessage->m_szFileName,lpNotifyMessage->m_EventHandle,
                 lpNotifyMessage->m_FileSize,lpNotifyMessage->m_hFile);        

        MBFT_FILE_OFFER NewFileOffer;
        MBFT_RECEIVE_FILE_INFO FileData;
                                
        NewFileOffer.hEvent          = lpNotifyMessage->m_EventHandle;
        NewFileOffer.SenderID        = lpNotifyMessage->m_SenderID;
		NewFileOffer.NodeID          = lpNotifyMessage->m_NodeID;
        NewFileOffer.uNumFiles       = 1;
        NewFileOffer.lpFileInfoList  = &FileData;  
        NewFileOffer.bIsBroadcastEvent   = !lpNotifyMessage->m_bAckNeeded;  
                                
        ::lstrcpynA(FileData.szFileName, lpNotifyMessage->m_szFileName, sizeof(FileData.szFileName));
        FileData.hFile               = lpNotifyMessage->m_hFile;
        FileData.lFileSize           = lpNotifyMessage->m_FileSize;  
        FileData.FileDateTime        = lpNotifyMessage->m_FileDateTime;

        m_pEvents->OnFileOffer(&NewFileOffer);
    }
}                            

void MBFTInterface::HandleProgressNotify(FileTransmitMsg * lpProgressMessage)
{
    MBFT_NOTIFICATION wMBFTCode = (MBFT_NOTIFICATION)lpProgressMessage->m_TransmitStatus;

    TRACEAPI(" Notification [%x] from Event [%ld], Handle: [%ld] FileSize: [%ld], Bytes Xfered[%ld]\n",
             wMBFTCode,lpProgressMessage->m_EventHandle,
             lpProgressMessage->m_hFile,
             lpProgressMessage->m_FileSize,
             lpProgressMessage->m_BytesTransmitted);

    switch (wMBFTCode)
    {
    case iMBFT_FILE_RECEIVE_BEGIN:
        if(!m_ReceiveEventHandle)
        {
            m_ReceiveEventHandle = lpProgressMessage->m_EventHandle;
        }            
        //m_bFileOfferOK = FALSE;
        break;

    case iMBFT_FILE_RECEIVE_PROGRESS:
    case iMBFT_FILE_SEND_PROGRESS:
        {
            MBFT_FILE_PROGRESS Progress;
            Progress.hEvent             = lpProgressMessage->m_EventHandle;
            Progress.hFile              = lpProgressMessage->m_hFile;
            Progress.lFileSize          = lpProgressMessage->m_FileSize;
            Progress.lBytesTransmitted  = lpProgressMessage->m_BytesTransmitted;
            Progress.bIsBroadcastEvent  = lpProgressMessage->m_bIsBroadcastEvent;

            m_pEvents->OnFileProgress(&Progress);
        }
        break;

    case iMBFT_FILE_RECEIVE_END:
        //m_bFileOfferOK = TRUE;   
        if(m_ReceiveEventHandle == lpProgressMessage->m_EventHandle)
        {
            m_ReceiveEventHandle = 0;
        }
        // fall through
    case iMBFT_FILE_SEND_END:
        m_pEvents->OnFileEnd(lpProgressMessage->m_hFile);
        break;

    default:
        ASSERT(iMBFT_FILE_SEND_BEGIN == wMBFTCode);
        break;
    }
}    
    
void MBFTInterface::HandleErrorNotify(FileErrorMsg * lpErrorMessage) 
{

    TRACEAPI(" Error Notification, Event: [%ld], Handle [%ld], IsLocal = [%d]\n",
             lpErrorMessage->m_EventHandle,lpErrorMessage->m_hFile,
             lpErrorMessage->m_bIsLocalError);        

    
    MBFT_EVENT_ERROR Error;
        
    Error.hEvent         = lpErrorMessage->m_EventHandle;
    Error.bIsLocalError  = lpErrorMessage->m_bIsLocalError;
    Error.UserID         = lpErrorMessage->m_UserID;                            
    Error.hFile          = lpErrorMessage->m_hFile;      
    Error.bIsBroadcastEvent = lpErrorMessage->m_bIsBroadcastEvent;
    
    if(LOWORD(Error.hFile) == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
    {
        Error.hFile = _iMBFT_PROSHARE_ALL_FILES;
    }

    Error.eErrorType     = (MBFT_ERROR_TYPES)lpErrorMessage->m_ErrorType;
    Error.eErrorCode     = (MBFT_ERROR_CODE)lpErrorMessage->m_ErrorCode;  
    
    m_pEvents->OnFileError(&Error);
}                            

void MBFTInterface::HandlePeerNotification(PeerMsg * lpNewMessage)
{

    TRACEAPI(" Peer Notification, Node [%u], UserID [%u], IsProshare = [%u], Added = [%u]\n",
             lpNewMessage->m_NodeID,
             lpNewMessage->m_MBFTPeerID,lpNewMessage->m_bIsProsharePeer,
             lpNewMessage->m_bPeerAdded);        

    
    MBFT_PEER_INFO PeerInfo;

    PeerInfo.NodeID          = lpNewMessage->m_NodeID;  
    PeerInfo.MBFTPeerID      = lpNewMessage->m_MBFTPeerID;  
    PeerInfo.bIsProShareApp  = lpNewMessage->m_bIsProsharePeer;
    PeerInfo.MBFTSessionID   = lpNewMessage->m_MBFTSessionID;
    
    //PeerInfo.bIsLocalPeer    = lpNewMessage->m_bIsLocalPeer;
    
    ::lstrcpynA(PeerInfo.szAppKey,lpNewMessage->m_szAppKey, sizeof(PeerInfo.szAppKey));

    //lstrcpyn(PeerInfo.szProtocolKey,lpNewMessage->m_szProtocolKey, sizeof(PeerInfo.szProtocolKey));

    if(!lpNewMessage->m_bIsLocalPeer)
    {
        TRACEAPI("Delivering PEER Notification\n");
        if (lpNewMessage->m_bPeerAdded)
        {
            m_pEvents->OnPeerAdded(&PeerInfo);
        }
        else
        {
            m_pEvents->OnPeerRemoved(&PeerInfo);
        }
    }  
    
    if(lpNewMessage->m_bIsLocalPeer) 
    {
        if(lpNewMessage->m_bPeerAdded)
        {
            m_MBFTUserID    = PeerInfo.MBFTPeerID;
                
            m_pEvents->OnInitializeComplete();
        }
    }
}


void MBFTInterface::HandleInitUninitNotification(InitUnInitNotifyMsg * lpNewMessage)
{
    if (lpNewMessage->m_iNotifyMessage == EnumInvoluntaryUnInit)
    {
        if (NULL != m_pEvents)
        {
            m_pEvents->OnSessionEnd();
        }
    }
}

void MBFTInterface::HandleGenericNotification(FileEventEndNotifyMsg * lpNewMessage)
{
    if (m_SendEventHandle == lpNewMessage->m_EventHandle)
    {
        m_SendEventHandle  = 0;
    }
    m_pEvents->OnFileEventEnd(lpNewMessage->m_EventHandle);
}



MBFT_SEND_FILE_INFO *AllocateSendFileInfo(LPSTR pszPathName)
{
    MBFT_SEND_FILE_INFO *p = new MBFT_SEND_FILE_INFO;
    if (NULL != p)
    {
        ::ZeroMemory(p, sizeof(*p));
        ULONG cb = ::lstrlenA(pszPathName) + 1;
        p->lpszFilePath = new char[cb];
        if (NULL != p->lpszFilePath)
        {
            ::CopyMemory(p->lpszFilePath, pszPathName, cb);
#ifdef BUG_INTL
            ::AnsiToOem(p->lpszFilePath, p->lpszFilePath);
#endif /* BUG_INTL */
        }
        else
        {
            delete p;
            p = NULL;
        }
    }
    return p;
}

void FreeSendFileInfo(MBFT_SEND_FILE_INFO *p)
{
    if (NULL != p)
    {
        delete p->lpszFilePath;
        delete p;
    }
}


HRESULT MBFTInterface::SafePostNotifyMessage(MBFTMsg *pMsg)
{
    if (NULL != pMsg)
    {
        AddRef();
        ::PostMessage(m_hwndNotify, MBFTNOTIFY_BASIC, (WPARAM) pMsg, (LPARAM) this);
        return S_OK;
    }
    ERROR_OUT(("MBFTInterface::SafePostNotifyMessage: null msg ptr"));
    return E_OUTOFMEMORY;
}


LRESULT CALLBACK
MBFTNotifyWndProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    switch (uMsg)
    {
    case MBFTNOTIFY_BASIC:
        {
            MBFTInterface *pIntf = (MBFTInterface *) lParam;
            MBFTMsg *pMsg = (MBFTMsg *) wParam;
            ASSERT(NULL != pIntf);
            ASSERT(NULL != pMsg);
            pIntf->DoStateMachine(pMsg);
            delete pMsg;
            pIntf->Release();
        }
        break;

    case WM_CLOSE:
        ::DestroyWindow(hwnd);
        break;

    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftper.h ===
/**************************************************************/
/* Copyright (c) 1995 Intel Corporation.  All rights reserved.*/
/**************************************************************/
/* Abstract syntax: mbft */
/* Created: Mon Mar 18 11:56:58 1996 */
/* ASN.1 compiler version: 4.1 */
/* Target operating system: MS-DOS 5.0/Windows 3.1 or later */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -noshortennames -prefix -c++ -per
 */

#ifndef OSS_mbft
#define OSS_mbft

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "asn1hdr.h"

#define          ASNEntity_Reference_PDU 1
#define          ASNMBFTPDU_PDU 2

typedef struct ASN_ObjectID_ {
    struct ASN_ObjectID_ *next;
    unsigned short  value;
} *ASN_ObjectID;

typedef struct ASNABSTRACT_SYNTAX {
    struct ASN_ObjectID_ *id;
    unsigned short  Type;
} ASNABSTRACT_SYNTAX;

typedef struct ASN_choice1 {
    unsigned short  choice;
#       define      ASNsingle_ASN1_type_chosen 1
#       define      ASNoctet_aligned_chosen 2
#       define      ASNarbitrary_chosen 3
    union _union {
	OpenType        ASNsingle_ASN1_type;
	struct ASNExternal_octet_aligned {
	    unsigned int    length;
	    unsigned char   *value;
	} ASNoctet_aligned;
	struct ASNExternal_arbitrary {
	    unsigned int    length;  /* number of significant bits */
	    unsigned char   *value;
	} ASNarbitrary;
    } u;
} ASN_choice1;

typedef struct ASN_External {
    unsigned char   bit_mask;
#       define      ASNdirect_reference_present 0x80
#       define      ASNindirect_reference_present 0x40
    struct ASN_ObjectID_ *ASNdirect_reference;  /* optional */
    int             ASNindirect_reference;  /* optional */
    char            *data_value_descriptor;  /* NULL for not present */
    ASN_choice1     encoding;
} ASN_External;

typedef unsigned short  ASNChannelID;

typedef unsigned short  ASNDynamicChannelID;

typedef ASNDynamicChannelID ASNUserID;

typedef unsigned short  ASNTokenID;

typedef struct ASNObjectID_ {
    struct ASNObjectID_ *next;
    unsigned long   value;
} *ASNObjectID;

typedef struct ASNH221NonStandardIdentifier {
    unsigned short  length;
    unsigned char   value[255];
} ASNH221NonStandardIdentifier;

typedef struct ASNKey {
    unsigned short  choice;
#       define      ASNobject_chosen 1
#       define      ASNh221NonStandard_chosen 2
    union _union {
	struct ASNObjectID_ *ASNobject;
	ASNH221NonStandardIdentifier ASNh221NonStandard;
    } u;
} ASNKey;

typedef struct ASNNonStandardParameter {
    ASNKey          key;
    struct {
	unsigned int    length;
	unsigned char   *value;
    } data;
} ASNNonStandardParameter;

typedef struct ASNTextString {
    unsigned short  length;
    unsigned short  *value;
} ASNTextString;

typedef unsigned short  ASNHandle;

typedef struct ASN_ObjectID_ *ASNDocument_Type_Name;

typedef struct ASNISO_8571_2_Parameters {
    unsigned char   bit_mask;
#       define      ASNuniversal_class_number_present 0x80
#       define      ASNmaximum_string_length_present 0x40
#       define      ASNstring_significance_present 0x20
    int             ASNuniversal_class_number;  /* optional */
    int             ASNmaximum_string_length;  /* optional */
    int             ASNstring_significance;  /* optional */
#       define      ASNvariable 0
#       define      ASNfixed 1
#       define      ASNnot_significant 2
} ASNISO_8571_2_Parameters;

typedef struct ASNContents_Type_Attribute {
    unsigned short  choice;
#       define      ASNdocument_type_chosen 1
    union _union {
	struct ASN_seq1 {
	    unsigned char   bit_mask;
#               define      ASNparameter_present 0x80
	    struct ASN_ObjectID_ *document_type_name;
	    ASNISO_8571_2_Parameters ASNparameter;  /* optional */
	} ASNdocument_type;
    } u;
} ASNContents_Type_Attribute;

typedef int             ASNEntity_Reference;
#define                     ASNno_categorisation_possible 0
#define                     ASNinitiating_file_service_user 1
#define                     ASNinitiating_file_protocol_machine 2
#define                     ASNservice_supporting_the_file_protocol_machine 3
#define                     ASNresponding_file_protocol_machine 4
#define                     ASNresponding_file_service_user 5

typedef struct ASNFilename_Attribute_ {
    struct ASNFilename_Attribute_ *next;
    char            *value;
} *ASNFilename_Attribute;

typedef unsigned char   ASNAccess_Request;
#define                     ASNAccess_Request_read 0x80
#define                     ASNAccess_Request_insert 0x40
#define                     ASNAccess_Request_replace 0x20
#define                     ASNAccess_Request_extend 0x10
#define                     ASNAccess_Request_erase 0x08
#define                     ASNread_attribute 0x04
#define                     ASNchange_attribute 0x02
#define                     ASNdelete_file 0x01

typedef unsigned char   ASNConcurrency_Key;
#define                     ASNnot_required 0x80
#define                     ASNshared 0x40
#define                     ASNexclusive 0x20
#define                     ASNno_access 0x10

typedef struct ASNConcurrency_Access {
    ASNConcurrency_Key read;
    ASNConcurrency_Key insert;
    ASNConcurrency_Key replace;
    ASNConcurrency_Key extend;
    ASNConcurrency_Key erase;
    ASNConcurrency_Key read_attribute;
    ASNConcurrency_Key change_attribute;
    ASNConcurrency_Key delete_file;
} ASNConcurrency_Access;

typedef char            *ASNUser_Identity;

typedef struct ASNPassword {
    unsigned short  choice;
#       define      ASNgraphic_string_chosen 1
#       define      ASNoctet_string_chosen 2
    union _union {
	char            *ASNgraphic_string;
	struct ASN_octet1 {
	    unsigned int    length;
	    unsigned char   *value;
	} ASNoctet_string;
    } u;
} ASNPassword;

typedef struct ASNAccess_Passwords {
    ASNPassword     read_password;
    ASNPassword     insert_password;
    ASNPassword     replace_password;
    ASNPassword     extend_password;
    ASNPassword     erase_password;
    ASNPassword     read_attribute_password;
    ASNPassword     change_attribute_password;
    ASNPassword     delete_password;
} ASNAccess_Passwords;

typedef struct ASNAccess_Control_Element {
    unsigned char   bit_mask;
#       define      ASNconcurrency_access_present 0x80
#       define      ASNpasswords_present 0x40
    ASNAccess_Request action_list;
    ASNConcurrency_Access ASNconcurrency_access;  /* optional */
    ASNUser_Identity identity;  /* NULL for not present */
    ASNAccess_Passwords ASNpasswords;  /* optional */
} ASNAccess_Control_Element;

typedef struct ASNAccess_Control_Attribute {
    unsigned short  choice;
#       define      ASNsimple_password_chosen 1
#       define      ASNactual_values_chosen 2
    union _union {
	struct ASN_octet2 {
	    unsigned int    length;
	    unsigned char   *value;
	} ASNsimple_password;
	struct ASN_setof1 {
	    struct ASN_setof1 *next;
	    ASNAccess_Control_Element value;
	} *ASNactual_values;
    } u;
} ASNAccess_Control_Attribute;

typedef unsigned char   ASNPermitted_Actions_Attribute;
#define                     ASNPermitted_Actions_Attribute_read 0x80
#define                     ASNPermitted_Actions_Attribute_insert 0x40
#define                     ASNPermitted_Actions_Attribute_replace 0x20
#define                     ASNPermitted_Actions_Attribute_extend 0x10
#define                     ASNPermitted_Actions_Attribute_erase 0x08

typedef struct ASNPrivate_Use_Attribute {
    unsigned char   bit_mask;
#       define      ASNmanufacturer_values_present 0x80
    ASN_External    ASNmanufacturer_values;  /* optional */
} ASNPrivate_Use_Attribute;

typedef unsigned char   ASNProtocol_Version;
#define                     ASNversion_1 0x80

typedef struct ASNFileHeader {
    unsigned int    bit_mask;
#       define      ASNprotocol_version_present 0x80000000
#       define      ASNfilename_present 0x40000000
#       define      ASNpermitted_actions_present 0x20000000
#       define      ASNcontents_type_present 0x10000000
#       define      ASNdate_and_time_of_creation_present 0x08000000
#       define      ASNdate_and_time_of_last_modification_present 0x04000000
#       define      ASNdate_and_time_of_last_read_access_present 0x02000000
#       define      ASNfilesize_present 0x01000000
#       define      ASNfuture_filesize_present 0x00800000
#       define      ASNaccess_control_present 0x00400000
#       define      ASNprivate_use_present 0x00200000
#       define      ASNstructure_present 0x00100000
#       define      ASNapplication_reference_present 0x00080000
#       define      ASNmachine_present 0x00040000
#       define      ASNoperating_system_present 0x00020000
#       define      ASNrecipient_present 0x00010000
#       define      ASNcharacter_set_present 0x00008000
#       define      ASNcompression_present 0x00004000
#       define      ASNenvironment_present 0x00002000
#       define      ASNFileHeader_pathname_present 0x00001000
#       define      ASNuser_visible_string_present 0x00000800
    ASNProtocol_Version ASNprotocol_version;  /* default assumed if omitted */
    struct ASNFilename_Attribute_ *ASNfilename;  /* optional */
    ASNPermitted_Actions_Attribute ASNpermitted_actions;  /* optional */
    ASNContents_Type_Attribute ASNcontents_type;  /* optional */
    char            *storage_account;  /* NULL for not present */
    GeneralizedTime ASNdate_and_time_of_creation;  /* optional */
    GeneralizedTime ASNdate_and_time_of_last_modification;  /* optional */
    GeneralizedTime ASNdate_and_time_of_last_read_access;  /* optional */
    char            *identity_of_creator;  /* NULL for not present */
    char            *identity_of_last_modifier;  /* NULL for not present */
    char            *identity_of_last_reader;  /* NULL for not present */
    long            ASNfilesize;  /* optional */
    long            ASNfuture_filesize;  /* optional */
    ASNAccess_Control_Attribute ASNaccess_control;  /* optional */
    char            *legal_qualifications;  /* NULL for not present */
    ASNPrivate_Use_Attribute ASNprivate_use;  /* optional */
    struct ASN_ObjectID_ *ASNstructure;  /* optional */
    struct ASN_seqof1 {
	struct ASN_seqof1 *next;
	char            *value;
    } *ASNapplication_reference;  /* optional */
    struct ASN_seqof2 {
	struct ASN_seqof2 *next;
	char            *value;
    } *ASNmachine;  /* optional */
    struct ASN_ObjectID_ *ASNoperating_system;  /* optional */
    struct ASN_seqof3 {
	struct ASN_seqof3 *next;
	char            *value;
    } *ASNrecipient;  /* optional */
    struct ASN_ObjectID_ *ASNcharacter_set;  /* optional */
    struct ASN_seqof4 {
	struct ASN_seqof4 *next;
	char            *value;
    } *ASNcompression;  /* optional */
    struct ASN_seqof5 {
	struct ASN_seqof5 *next;
	char            *value;
    } *ASNenvironment;  /* optional */
    struct ASN_seqof6 {
	struct ASN_seqof6 *next;
	char            *value;
    } *ASNFileHeader_pathname;  /* optional */
    struct ASN_seqof7 {
	struct ASN_seqof7 *next;
	char            *value;
    } *ASNuser_visible_string;  /* optional */
} ASNFileHeader;

typedef struct ASNV42bis_Parameter_List {
    unsigned short  p1;
    unsigned short  p2;
} ASNV42bis_Parameter_List;

typedef struct ASNCompressionSpecifier {
    unsigned short  choice;
#       define      ASNv42bis_parameters_chosen 1
#       define      ASNnonstandard_compression_parameters_chosen 2
    union _union {
	ASNV42bis_Parameter_List ASNv42bis_parameters;
	struct ASN_setof2 {
	    struct ASN_setof2 *next;
	    ASNNonStandardParameter value;
	} *ASNnonstandard_compression_parameters;
    } u;
} ASNCompressionSpecifier;

typedef enum ASNMBFTPrivilege {
    ASNfile_transmit_privilege = 0,
    ASNfile_request_privilege = 1,
    ASNcreate_private_privilege = 2,
    ASNmedium_priority_privilege = 3,
    ASNabort_privilege = 4,
    ASNnonstandard_privilege = 5
} ASNMBFTPrivilege;

typedef struct ASNDirectoryEntry {
    ossBoolean      subdirectory_flag;
    ASNFileHeader   attributes;
} ASNDirectoryEntry;

typedef enum ASNErrorType {
    ASNinformative = 0,
    ASNtransient_error = 1,
    ASNpermanent_error = 2
} ASNErrorType;

typedef int             ASNErrorID;
#define                     ASNno_reason 0
#define                     ASNresponder_error 1
#define                     ASNsystem_shutdown 2
#define                     ASNbft_management_problem 3
#define                     ASNbft_management_bad_account 4
#define                     ASNbft_management_security_not_passed 5
#define                     ASNdelay_may_be_encountered 6
#define                     ASNinitiator_error 7
#define                     ASNsubsequent_error 8
#define                     ASNtemporal_insufficiency_of_resources 9
#define                     ASNaccess_request_violates_VFS_security 10
#define                     ASNaccess_request_violates_local_security 11
#define                     ASNconflicting_parameter_values 1000
#define                     ASNunsupported_parameter_values 1001
#define                     ASNmandatory_parameter_not_set 1002
#define                     ASNunsupported_parameter 1003
#define                     ASNduplicated_parameter 1004
#define                     ASNillegal_parameter_type 1005
#define                     ASNunsupported_parameter_types 1006
#define                     ASNbft_protocol_error 1007
#define                     ASNbft_protocol_error_procedure_error 1008
#define                     ASNbft_protocol_error_functional_unit_error 1009
#define                     ASNbft_protocol_error_corruption_error 1010
#define                     ASNlower_layer_failure 1011
#define                     ASNtimeout 1013
#define                     ASNinvalid_filestore_password 2020
#define                     ASNfilename_not_found 3000
#define                     ASNinitial_attributes_not_possible 3002
#define                     ASNnon_existent_file 3004
#define                     ASNfile_already_exists 3005
#define                     ASNfile_cannot_be_created 3006
#define                     ASNfile_busy 3012
#define                     ASNfile_not_available 3013
#define                     ASNfilename_truncated 3017
#define                     ASNinitial_attributes_altered 3018
#define                     ASNbad_account 3019
#define                     ASNambiguous_file_specification 3024
#define                     ASNattribute_non_existent 4000
#define                     ASNattribute_not_supported 4003
#define                     ASNbad_attribute_name 4004
#define                     ASNbad_attribute_value 4005
#define                     ASNattribute_partially_supported 4006
#define                     ASNbad_data_element_type 5014
#define                     ASNoperation_not_available 5015
#define                     ASNoperation_not_supported 5016
#define                     ASNoperation_inconsistent 5017
#define                     ASNbad_write 5026
#define                     ASNbad_read 5027
#define                     ASNlocal_failure 5028
#define                     ASNlocal_failure_filespace_exhausted 5029
#define                     ASNlocal_failure_data_corrupted 5030
#define                     ASNlocal_failure_device_failure 5031
#define                     ASNfuture_filesize_exceeded 5032
#define                     ASNfuture_filesize_increased 5034

typedef struct ASNFile_OfferPDU {
    unsigned char   bit_mask;
#       define      ASNroster_instance_present 0x80
#       define      ASNfile_transmit_token_present 0x40
#       define      ASNFile_OfferPDU_file_request_token_present 0x20
#       define      ASNfile_request_handle_present 0x10
#       define      ASNmbft_ID_present 0x08
#       define      ASNFile_OfferPDU_compression_specifier_present 0x04
#       define      ASNcompressed_filesize_present 0x02
    ASNFileHeader   file_header;
    ASNChannelID    data_channel_id;
    ASNHandle       file_handle;
    unsigned short  ASNroster_instance;  /* optional */
    ASNTokenID      ASNfile_transmit_token;  /* optional */
    ASNTokenID      ASNFile_OfferPDU_file_request_token;  /* optional */
    ASNHandle       ASNfile_request_handle;  /* optional */
    ASNUserID       ASNmbft_ID;  /* optional */
    ASNCompressionSpecifier ASNFile_OfferPDU_compression_specifier;  /* optional */
    int             ASNcompressed_filesize;  /* optional */
    ossBoolean      ack_flag;
} ASNFile_OfferPDU;

typedef struct ASNFile_AcceptPDU {
    ASNHandle       file_handle;
} ASNFile_AcceptPDU;

typedef enum ASN_enum1 {
    ASNFile_RejectPDU_reason_unspecified = 0,
    ASNfile_exists = 1,
    ASNfile_not_required = 2,
    ASNinsufficient_resources = 3,
    ASNtransfer_limit = 4,
    ASNcompression_unsupported = 5,
    ASNreason_unable_to_join_channel = 6,
    ASNparameter_not_supported = 7
} ASN_enum1;

typedef struct ASNFile_RejectPDU {
    ASNHandle       file_handle;
    ASN_enum1       reason;
} ASNFile_RejectPDU;

typedef struct ASNFile_RequestPDU {
    unsigned char   bit_mask;
#       define      ASNFile_RequestPDU_file_request_token_present 0x80
    ASNFileHeader   file_header;
    ASNChannelID    data_channel_id;
    ASNHandle       request_handle;
    unsigned short  roster_instance;
    ASNTokenID      file_transmit_token;
    ASNTokenID      ASNFile_RequestPDU_file_request_token;  /* optional */
    int             data_offset;
} ASNFile_RequestPDU;

typedef enum ASN_enum2 {
    ASNFile_DenyPDU_reason_unspecified = 0,
    ASNfile_not_present = 1,
    ASNinsufficient_privilege = 2,
    ASNfile_already_offered = 3,
    ASNambiguous = 4,
    ASNno_channel = 5
} ASN_enum2;

typedef struct ASNFile_DenyPDU {
    ASNHandle       request_handle;
    ASN_enum2       reason;
} ASNFile_DenyPDU;

typedef enum ASN_enum3 {
    ASNreason_unspecified = 0,
    ASNbandwidth_required = 1,
    ASNtokens_required = 2,
    ASNchannels_required = 3,
    ASNpriority_required = 4
} ASN_enum3;

typedef struct ASNFile_AbortPDU {
    unsigned char   bit_mask;
#       define      ASNdata_channel_id_present 0x80
#       define      ASNtransmitter_user_id_present 0x40
#       define      ASNFile_AbortPDU_file_handle_present 0x20
    ASN_enum3       reason;
    ASNChannelID    ASNdata_channel_id;  /* optional */
    ASNUserID       ASNtransmitter_user_id;  /* optional */
    ASNHandle       ASNFile_AbortPDU_file_handle;  /* optional */
} ASNFile_AbortPDU;

typedef struct ASNFile_StartPDU {
    unsigned char   bit_mask;
#       define      ASNFile_StartPDU_compression_specifier_present 0x80
#       define      ASNcomp_filesize_present 0x40
#       define      ASNFile_StartPDU_crc_check_present 0x20
    ASNFileHeader   file_header;
    ASNHandle       file_handle;
    ossBoolean      eof_flag;
    ossBoolean      crc_flag;
    ASNCompressionSpecifier ASNFile_StartPDU_compression_specifier;  /* optional */
    int             ASNcomp_filesize;  /* optional */
    int             data_offset;
    struct {
	unsigned short  length;
	unsigned char   *value;
    } data;
    unsigned int    ASNFile_StartPDU_crc_check;  /* optional */
} ASNFile_StartPDU;

typedef struct ASNFile_DataPDU {
    unsigned char   bit_mask;
#       define      ASNFile_DataPDU_crc_check_present 0x80
    ASNHandle       file_handle;
    ossBoolean      eof_flag;
    ossBoolean      abort_flag;
    struct {
	unsigned short  length;
	unsigned char   *value;
    } data;
    unsigned int    ASNFile_DataPDU_crc_check;  /* optional */
} ASNFile_DataPDU;

typedef struct ASNDirectory_RequestPDU {
    unsigned char   bit_mask;
#       define      ASNDirectory_RequestPDU_pathname_present 0x80
    struct ASN_seqof8 {
	struct ASN_seqof8 *next;
	char            *value;
    } *ASNDirectory_RequestPDU_pathname;  /* optional */
} ASNDirectory_RequestPDU;

typedef enum ASN_enum4 {
    ASNDirectory_ResponsePDU_result_unspecified = 0,
    ASNpermission_denied = 1,
    ASNfunction_not_supported = 2,
    ASNDirectory_ResponsePDU_result_successful = 3
} ASN_enum4;

typedef struct ASNDirectory_ResponsePDU {
    unsigned char   bit_mask;
#       define      ASNDirectory_ResponsePDU_pathname_present 0x80
    ASN_enum4       result;
    struct ASN_seqof9 {
	struct ASN_seqof9 *next;
	char            *value;
    } *ASNDirectory_ResponsePDU_pathname;  /* optional */
    struct ASN_seqof10 {
	struct ASN_seqof10 *next;
	ASNDirectoryEntry value;
    } *directory_list;
} ASNDirectory_ResponsePDU;

typedef struct ASNMBFT_Privilege_RequestPDU {
    struct ASN_setof3 {
	struct ASN_setof3 *next;
	ASNMBFTPrivilege value;
    } *mbft_privilege;
} ASNMBFT_Privilege_RequestPDU;

typedef struct ASNMBFT_Privilege_AssignPDU {
    struct ASN_setof5 {
	struct ASN_setof5 *next;
	struct temptag {
	    ASNUserID       mbftID;
	    struct ASN_setof4 {
		struct ASN_setof4 *next;
		ASNMBFTPrivilege value;
	    } *mbft_privilege;
	} value;
    } *privilege_list;
} ASNMBFT_Privilege_AssignPDU;

typedef struct ASNPrivate_Channel_Join_InvitePDU {
    ASNDynamicChannelID control_channel_id;
    ASNDynamicChannelID data_channel_id;
    ossBoolean      mode;
} ASNPrivate_Channel_Join_InvitePDU;

typedef enum ASN_enum5 {
    ASNPrivate_Channel_Join_ResponsePDU_result_unspecified = 0,
    ASNresult_unable_to_join_channel = 1,
    ASNinvitation_rejected = 2,
    ASNPrivate_Channel_Join_ResponsePDU_result_successful = 3
} ASN_enum5;

typedef struct ASNPrivate_Channel_Join_ResponsePDU {
    ASNDynamicChannelID control_channel_id;
    ASN_enum5       result;
} ASNPrivate_Channel_Join_ResponsePDU;

typedef struct ASNFile_ErrorPDU {
    unsigned char   bit_mask;
#       define      ASNFile_ErrorPDU_file_handle_present 0x80
#       define      ASNerror_text_present 0x40
    ASNHandle       ASNFile_ErrorPDU_file_handle;  /* optional */
    ASNErrorType    error_type;
    ASNErrorID      error_id;
    ASNTextString   ASNerror_text;  /* optional */
} ASNFile_ErrorPDU;

typedef struct ASNMBFT_NonStandardPDU {
    ASNNonStandardParameter data;
} ASNMBFT_NonStandardPDU;

typedef struct ASNMBFTPDU {
    unsigned short  choice;
#       define      ASNfile_OfferPDU_chosen 1
#       define      ASNfile_AcceptPDU_chosen 2
#       define      ASNfile_RejectPDU_chosen 3
#       define      ASNfile_RequestPDU_chosen 4
#       define      ASNfile_DenyPDU_chosen 5
#       define      ASNfile_ErrorPDU_chosen 6
#       define      ASNfile_AbortPDU_chosen 7
#       define      ASNfile_StartPDU_chosen 8
#       define      ASNfile_DataPDU_chosen 9
#       define      ASNdirectory_RequestPDU_chosen 10
#       define      ASNdirectory_ResponsePDU_chosen 11
#       define      ASNmbft_Privilege_RequestPDU_chosen 12
#       define      ASNmbft_Privilege_AssignPDU_chosen 13
#       define      ASNmbft_NonStandardPDU_chosen 14
#       define      ASNprivate_Channel_Join_InvitePDU_chosen 15
#       define      ASNprivate_Channel_Join_ResponsePDU_chosen 16
    union _union {
	ASNFile_OfferPDU ASNfile_OfferPDU;
	ASNFile_AcceptPDU ASNfile_AcceptPDU;
	ASNFile_RejectPDU ASNfile_RejectPDU;
	ASNFile_RequestPDU ASNfile_RequestPDU;
	ASNFile_DenyPDU ASNfile_DenyPDU;
	ASNFile_ErrorPDU ASNfile_ErrorPDU;
	ASNFile_AbortPDU ASNfile_AbortPDU;
	ASNFile_StartPDU ASNfile_StartPDU;
	ASNFile_DataPDU ASNfile_DataPDU;
	ASNDirectory_RequestPDU ASNdirectory_RequestPDU;
	ASNDirectory_ResponsePDU ASNdirectory_ResponsePDU;
	ASNMBFT_Privilege_RequestPDU ASNmbft_Privilege_RequestPDU;
	ASNMBFT_Privilege_AssignPDU ASNmbft_Privilege_AssignPDU;
	ASNMBFT_NonStandardPDU ASNmbft_NonStandardPDU;
	ASNPrivate_Channel_Join_InvitePDU ASNprivate_Channel_Join_InvitePDU;
	ASNPrivate_Channel_Join_ResponsePDU ASNprivate_Channel_Join_ResponsePDU;
    } u;
} ASNMBFTPDU;

extern ASNKey ASNt127Identifier;


extern void *mbft;    /* encoder-decoder control table */
#ifdef __cplusplus
}       /* extern "C" */
#endif /* __cplusplus */
#endif /* OSS_mbft */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftrecv.cpp ===
/* file: mbftRecv.cpp */

#include "mbftpch.h"

#include "mbftrecv.hpp"
#include "fileio.hpp"
#include "messages.hpp"
#include "mbftper.h"

extern TCHAR s_szMSFT[64];

extern HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr);
extern void OnChangeFolder(void);
extern int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement);

LPTSTR GetRootDirPath(LPTSTR pszDirPath, LPTSTR pszRootDirPath, int nSize);

MBFTPrivateReceive::MBFTPrivateReceive
(
    LPMBFTENGINE            lpParentEngine,
    MBFTEVENTHANDLE         EventHandle,
    T120ChannelID           wControlChannel,
    T120ChannelID           wDataChannel
)
:
    MBFTSession(lpParentEngine, EventHandle, MBFT_PRIVATE_RECV_TYPE),
    m_PrivateMBFTControlChannel(wControlChannel),
    m_PrivateMBFTDataChannel(wDataChannel),

    m_MBFTControlSenderID(0),
    m_MBFTDataSenderID(0),
    m_ProshareSenderID(0),
    m_LocalMBFTUserID(0),

    m_bProshareTransfer(FALSE),
    m_JoinedToDataChannel(FALSE),
    m_bOKToLeaveDataChannel(FALSE),
    m_CurrentReceiveEvent(NULL),

    m_bEventEndPosted(FALSE),
    m_CurrentAcceptHandle(0),
    m_CurrentRejectHandle(0),
    m_CurrentFileEndHandle(0),

    m_PreviousRejectState(EnumIdleNotInitialized),

    m_State(EnumWaitAdmitControlChannel)
{
	m_PrivateMBFTDataChannelList.Append(m_PrivateMBFTDataChannel);
}

MBFTPrivateReceive::~MBFTPrivateReceive(void)
{
    m_ReceiveList.DeleteAll();
}

void MBFTPrivateReceive::JoinControlChannel(void)
{
    if(m_lpParentEngine->MCSChannelJoinRequest(m_PrivateMBFTControlChannel))
    {
        m_State = EnumWaitJoinControlChannel;
    }
    else
    {
        m_State = EnumInitializationFailed;
    }
}

void MBFTPrivateReceive::JoinDataChannel(void)
{
    if(m_lpParentEngine->MCSChannelJoinRequest(m_PrivateMBFTDataChannel))
    {
        if(m_State == EnumWaitAdmitDataChannelIndication)
        {
            m_State = EnumWaitJoinDataChannel;
        }
    }
    else
    {
        m_State = EnumInitializationFailed;
    }
}

BOOL MBFTPrivateReceive::OnMCSChannelJoinConfirm
(
    T120ChannelID           wChannelID,
    BOOL                    bSuccess
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitJoinControlChannel)
    {
        if(wChannelID == m_PrivateMBFTControlChannel)
        {
            bReturn = TRUE;

            m_State = bSuccess ? EnumWaitAdmitDataChannelIndication :
                                 EnumInitializationFailed;

            // data channel admit indication may come earlier than this state change.
            // look for unserviced channel admit indication
            if (EnumWaitAdmitDataChannelIndication == m_State)
            {
                UINT_PTR chid_uid;
                m_AdmittedChannelQueue.Reset();
                while (0 != (chid_uid = m_AdmittedChannelQueue.Iterate()))
                {
                    if (m_PrivateMBFTDataChannelList.Find(LOWORD(chid_uid)))
                    {
                        OnMCSChannelAdmitIndication(LOWORD(chid_uid), HIWORD(chid_uid));
                        m_AdmittedChannelQueue.Remove(chid_uid);
                        break;
                    }
                }
            }
        }
    }
    else if(m_State == EnumWaitJoinDataChannel || m_State == EnumWaitRejoinDataChannel)
    {
        if(m_PrivateMBFTDataChannelList.Find(wChannelID))
        {
            bReturn = TRUE;

            if(bSuccess)
            {
                m_JoinedToDataChannel = TRUE;

                if(m_State == EnumWaitJoinDataChannel)
                {
                    m_State = EnumWaitSendChannelResponsePDU;
                }
                else if(m_State == EnumWaitRejoinDataChannel)
                {
                    TRACERECEIVE(" Rejoined Data Channel [%u]\n",wChannelID);

                    if(m_CurrentReceiveEvent)
                    {
                        SendFileAcceptPDU((unsigned)m_CurrentReceiveEvent->m_hFile);
                        m_CurrentReceiveEvent->m_State = EnumWaitFileStartPDU;
                    }
                    else
                    {
                        TRACE(" *** WARNING: Receive Event deleted before Data Channel was rejoined! ***\n");
                    }

                    //m_State = EnumWaitFileOfferPDU;
                }
            }
            else
            {
                m_State = EnumInitializationFailed;
            }
        }
    }

    return(bReturn);
}

void MBFTPrivateReceive::UnInitialize
(
    BOOL            bIsShutDown
)
{
    if(m_State != EnumWaitForTermination)
    {
        m_State = EnumWaitForTermination;

        MBFTReceiveSubEvent * lpReceive;
        m_ReceiveList.Reset();
        while (NULL != (lpReceive = m_ReceiveList.Iterate()))
        {
            if(!lpReceive->m_UserAccepted)
            {
                lpReceive->m_lpFile->DeleteFile();
            }
        }

        m_PrivateMBFTDataChannelList.Clear();

        if(!bIsShutDown)
        {
            DBG_SAVE_FILE_LINE
            m_lpParentEngine->SafePostMessage(new DeleteSessionMsg(this));

            if(!m_bEventEndPosted)
            {
                DBG_SAVE_FILE_LINE
                m_lpParentEngine->SafePostNotifyMessage(
                                    new FileEventEndNotifyMsg(m_EventHandle));
                m_bEventEndPosted   =   TRUE;
            }
        }
    }
}



MBFTReceiveSubEvent::MBFTReceiveSubEvent
(
    MBFTFILEHANDLE          hFile,
    LONG                    FileSize,
    LPCSTR                  lpszFileName,
    time_t                  FileDateTime,
    T120UserID              SenderID,
    BOOL                    bIsBroadcast,
    BOOL                    bIsCompressed,
    BOOL                    bEOFAcknowledge
)
:
    m_bIsBroadcast(bIsBroadcast),
    m_hFile(MAKELONG(hFile,SenderID)),
    m_FileSize(FileSize),
    m_FileDateTime(FileDateTime),
    m_TotalBytesReceived(0),
    m_cbRecvLastNotify(0),
    m_bFileCompressed(bIsCompressed),
    m_bEOFAcknowledge(bEOFAcknowledge),
    m_SenderID(SenderID),
    m_lpFile(NULL),
    m_UserAccepted(FALSE)
{
    if(lpszFileName)
    {
        ::lstrcpynA(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        m_szFileName[0] = '\0';
    }

    m_szFileDirectory[0] = '\0';

    m_State = (! bIsBroadcast) ? MBFTPrivateReceive::EnumWaitUserConfirmation :
                                 MBFTPrivateReceive::EnumWaitFileStartPDU;
}


BOOL MBFTReceiveSubEvent::Init(void)
{
    DBG_SAVE_FILE_LINE
	m_lpFile = new CMBFTFile;
	return(m_lpFile != NULL);
}


MBFTReceiveSubEvent::~MBFTReceiveSubEvent(void)
{
    if(m_lpFile)
    {
		// if the file wasn't completely received, delete it
		if (m_TotalBytesReceived < m_FileSize)
			m_lpFile->Close(FALSE);

        delete m_lpFile;
    }
}

BOOL MBFTReceiveSubEvent::IsEqual
(
    MBFTReceiveSubEvent         *lpObject
)
{
    BOOL bReturn = FALSE;

    if(!lpObject->m_SenderID || !m_SenderID)
    {
        bReturn = (lpObject->m_hFile == (MBFTFILEHANDLE)MAKELONG(m_hFile, lpObject->m_SenderID));
    }
    else
    {
        bReturn = (lpObject->m_hFile == m_hFile) && (lpObject->m_SenderID == m_SenderID);
    }

    return(bReturn);
}

BOOL MBFTPrivateReceive::OnReceivedFileOfferPDU
(
    T120ChannelID           wChannelID,
    T120Priority            iPriority,
    T120UserID              SenderID,
	T120NodeID				NodeID,
    LPFILEOFFERPDU          lpFileOfferPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_INFORMATIVE_ERROR;

    if(wChannelID == m_PrivateMBFTControlChannel)
    {
        bReturn     =   TRUE;

        if(m_State == EnumWaitFileOfferPDU)
        {
			// Sanity checking
			DWORD res;
			// Windows 95 can't take NULL pointers for these
			DWORD SecPerCluster, BytePerSector, FreeCluster, TotalFreeCluster;
			TCHAR  szDirPath[MAX_PATH];
            TCHAR  szRootDirPath[MAX_PATH], *pszRootDir;

			::GetRecvFolder(NULL, szDirPath);

			res = GetFileAttributes(szDirPath);
			if ((0xffffffff == res)||!(res | FILE_ATTRIBUTE_DIRECTORY))
			{   // invalid directory name
				iErrorCode = iMBFT_INVALID_PATH;
				goto ERRORPROCESS;
			}

			pszRootDir = GetRootDirPath(szDirPath, szRootDirPath, MAX_PATH);
			if (GetDiskFreeSpace(pszRootDir, &SecPerCluster,
								&BytePerSector, &FreeCluster, &TotalFreeCluster))
			{
				if (!(BytePerSector && SecPerCluster))
				{
					WARNING_OUT(("BytePerSector %d, SecPerCluster %d\n", BytePerSector,
						SecPerCluster));
				}
				else if ((ULONG)lpFileOfferPDU->GetFileSize()/BytePerSector/SecPerCluster + 1 > FreeCluster)
				{   // not enough space to save the file
					iErrorCode = iMBFT_DIRECTORY_FULL_ERROR;
					goto ERRORPROCESS;
				}
			}
			else
			{
				ERROR_OUT(("GetDiskSpace Failed, error %d\n", GetLastError()));
			}

            BOOL bAckRequired = lpFileOfferPDU->GetAcknowledge();

            m_bOKToLeaveDataChannel = bAckRequired;

            //Change compression handling later -- for now, we assume that a Proshare send is
            //always compressed....

            BOOL bEOFAcknowledge = FALSE;
            CPeerList *pPeerList = m_lpParentEngine->GetPeerList();
            CPeerData *lpPeer;
            pPeerList->Reset();
            while (NULL != (lpPeer = pPeerList->Iterate()))
            {
                if(lpPeer->GetUserID() == SenderID)
                {
                    bEOFAcknowledge = lpPeer->GetEOFAcknowledge();
                    break;
                }
            }

            DBG_SAVE_FILE_LINE
            MBFTReceiveSubEvent * lpNewReceive = new MBFTReceiveSubEvent(lpFileOfferPDU->GetFileHandle(),
                                                                         lpFileOfferPDU->GetFileSize(),
                                                                         lpFileOfferPDU->GetFileName(),
                                                                         lpFileOfferPDU->GetFileDateTime(),
                                                                         SenderID,
                                                                         !bAckRequired,
                                                                         lpFileOfferPDU->GetCompressionFlags() & _MBFT_FILE_COMPRESSED,
                                                                         bEOFAcknowledge);
            if(lpNewReceive)
            {
                if(lpNewReceive->Init())
                {
                    m_ReceiveList.Append(lpNewReceive);
	
                    // lonchanc: how can you use static char szTemp[] here???
					char szRecvDir[MAX_PATH];
					::GetRecvFolder(NULL, szRecvDir);

                    if(lpNewReceive->m_lpFile->Create(szRecvDir, lpNewReceive->m_szFileName))
					{
						DBG_SAVE_FILE_LINE
						m_lpParentEngine->SafePostNotifyMessage(
									   new FileOfferNotifyMsg(m_EventHandle,
															  SenderID,
															  NodeID,
															  lpNewReceive->m_hFile,
															  lpNewReceive->m_lpFile->GetFileName(),
															  lpNewReceive->m_FileSize,
															  lpNewReceive->m_FileDateTime,
															  bAckRequired));
					}
					else
					{
						iErrorCode = iMBFT_FILE_ACCESS_DENIED;
						goto ERRORPROCESS;
					}
                }
                else
                {
                    delete  lpNewReceive;
                }
            }
         }
         else if(m_State == EnumWaitChannelDisband)
         {
			SendFileRejectPDU(lpFileOfferPDU->GetFileHandle());
         }
    }

    return(bReturn);


ERRORPROCESS:
	ReportError(NULL,iErrorType,iErrorCode, TRUE, 0,
			    lpFileOfferPDU->GetFileName(),
				lpFileOfferPDU->GetFileSize());
	SendFileRejectPDU(lpFileOfferPDU->GetFileHandle());
	return (bReturn);
}

BOOL MBFTPrivateReceive::OnReceivedFileStartPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILESTARTPDU          lpFileStartPDU,
    BOOL                    IsUniformSendData
)
{
     BOOL bReturn = FALSE;
     MBFTReceiveSubEvent * lpReceiveEvent;
     MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
     MBFT_ERROR_TYPES iErrorType = MBFT_INFORMATIVE_ERROR;

    if (m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
        if(m_State != EnumWaitForTermination && m_State != EnumWaitChannelDisband)
        {
            bReturn     =   TRUE;

            MBFTReceiveSubEvent TempReceive(lpFileStartPDU->GetFileHandle(),0,NULL,0,SenderID,FALSE,m_bProshareTransfer,FALSE);

            lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
            if(lpReceiveEvent)
            {
                if(lpReceiveEvent->m_State == EnumWaitFileStartPDU)
                {
                    //Double check to make sure....
                    lpReceiveEvent->m_bFileCompressed = lpFileStartPDU->GetCompressionFlags() & _MBFT_FILE_COMPRESSED;
                    if(lpReceiveEvent->m_bFileCompressed)
                    {
    					// We don't handle compressed files
    					iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
                    }

                    BOOL bSuccess = FALSE;
                    int BytesWritten = 0;

                    if(lpReceiveEvent->m_bFileCompressed)
    				{
    					// We don't handle compressed files
    					iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
    				}
    				else
                    {
                        BytesWritten = lpFileStartPDU->GetDataSize();
                        if(BytesWritten)
                        {
                            if(!lpReceiveEvent->m_lpFile->Write(lpFileStartPDU->GetDataBuffer(),
                                                                lpFileStartPDU->GetDataSize()))
                            {
                                iErrorCode = (MBFT_ERROR_CODE)lpReceiveEvent->m_lpFile->GetLastErrorCode();

                                //iMBFT_FILE_IO_ERROR;
                            }
                        }
                    }

                    //lpReceiveEvent->m_TotalBytesReceived += BytesWritten;

                    lpReceiveEvent->m_TotalBytesReceived   =  lpReceiveEvent->m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);
                    lpReceiveEvent->m_FileSize = lpFileStartPDU->GetFileSize();

                    if(iErrorCode == iMBFT_OK)
                    {
                        if(m_State != EnumWaitForTermination)
                        {
                            DBG_SAVE_FILE_LINE
                            m_lpParentEngine->SafePostNotifyMessage(
                                            new FileTransmitMsg(m_EventHandle,
                                                               lpReceiveEvent->m_hFile,
                                                               lpReceiveEvent->m_FileSize,
                                                               lpReceiveEvent->m_TotalBytesReceived,
                                                               iMBFT_FILE_RECEIVE_BEGIN,
                                                               lpReceiveEvent->m_SenderID,
                                                               lpReceiveEvent->m_bIsBroadcast));
                        }

                        if(lpFileStartPDU->GetIsEOF())
                        {
                            lpReceiveEvent->m_lpFile->SetFileDateTime(lpReceiveEvent->m_FileDateTime);

                            lpReceiveEvent->m_lpFile->Close();
                            lpReceiveEvent->m_State = EnumWaitForTermination;

        					if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
        					{
        						SendFileEndAcknowledgePDU(lpReceiveEvent->m_hFile);
        					}
        					DeleteReceiveEvent(lpReceiveEvent,TRUE);
                        }
                        else
                        {
                            lpReceiveEvent->m_State = EnumWaitFileDataPDU;
                        }
                    }

                }
            }    //lpReceiveEvent
        }   //m_State != EnumWaitForTermination

        if(iErrorCode != iMBFT_OK)
        {
            BOOL bSendChannelLeave  =   lpReceiveEvent->m_bEOFAcknowledge;

            ReportError(lpReceiveEvent,iErrorType,iErrorCode);
            ReportReceiverError(lpReceiveEvent,iErrorType,iErrorCode);
            lpReceiveEvent->m_lpFile->Close(FALSE);
            DeleteReceiveEvent(lpReceiveEvent,TRUE);

            if(m_bOKToLeaveDataChannel)
            {
                if(bSendChannelLeave && m_JoinedToDataChannel)
                {
                    SendChannelLeavePDU();
                }
                LeaveDataChannel();
            }
        }

    }        //wChannelId == m_PrivateMBFTDataChannel

    return(bReturn);
}



void MBFTPrivateReceive::ReportError
(
    MBFTReceiveSubEvent    *lpReceiveEvent,
    int                     iErrorType,
    int                     iErrorCode,
    BOOL                    bIsLocalError,
    T120UserID              SenderID,
	const char*				pFileName,
	ULONG					lFileSize
)
{
    if(m_State != EnumWaitForTermination)
    {
        MBFTMsg * lpNewMessage;
		T120UserID id = SenderID ? SenderID : m_LocalMBFTUserID;

        DBG_SAVE_FILE_LINE
        m_lpParentEngine->SafePostNotifyMessage(
                        		new FileErrorMsg(m_EventHandle,
                        			(lpReceiveEvent) ? lpReceiveEvent->m_hFile : 0, iErrorType,
                        			iErrorCode,
                        			bIsLocalError,
                        			id,
                        			(lpReceiveEvent) ?  lpReceiveEvent->m_bIsBroadcast : 0,
									pFileName, lFileSize));
    }
    else
    {
        TRACERECEIVE(" Waiting for termination, not reporting error");
    }
}

void MBFTPrivateReceive::ReportReceiverError
(
    MBFTReceiveSubEvent    *lpReceive,
    int                     iErrorType,
    int                     iErrorCode,
    MBFTFILEHANDLE          iFileHandle
)
{
    if(m_State != EnumWaitForTermination)
    {
        if(lpReceive)
        {
            DBG_SAVE_FILE_LINE
            FileErrorPDU * lpNewPDU = new FileErrorPDU(iFileHandle ? iFileHandle : lpReceive->m_hFile,
                                                       iErrorType,iErrorCode);
			if(lpNewPDU)
			{
	            if(lpNewPDU->Encode())
    	        {
        	        m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
        	                                          APPLET_HIGH_PRIORITY,
              	                                      (LPBYTE)lpNewPDU->GetBuffer(),
                   	                                  lpNewPDU->GetBufferLength());
	            }
	            delete lpNewPDU;
			}
        }
    }
    else
    {
        TRACERECEIVE(" Waiting for termination, not reporting receiver error");
    }
}

void MBFTPrivateReceive::DeleteReceiveEvent
(
    MBFTReceiveSubEvent    *lpReceive,
    BOOL                    bNotifyUser
)
{

    if(lpReceive)
    {
        if(bNotifyUser)
        {
            DBG_SAVE_FILE_LINE
            m_lpParentEngine->SafePostNotifyMessage(
                                     new FileTransmitMsg(m_EventHandle,
                                                         lpReceive->m_hFile,
                                                         lpReceive->m_FileSize,
                                                         lpReceive->m_TotalBytesReceived,
                                                         iMBFT_FILE_RECEIVE_END,
                                                         lpReceive->m_SenderID,
                                                         lpReceive->m_bIsBroadcast));
        }

        m_ReceiveList.Delete(lpReceive);

        if(m_CurrentReceiveEvent == lpReceive)
        {
            m_CurrentReceiveEvent = NULL;
        }
    }
}

BOOL MBFTPrivateReceive::OnReceivedFileDataPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEDATAPDU           lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;
    MBFTReceiveSubEvent * lpReceiveEvent;
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_INFORMATIVE_ERROR;
    BOOL bLocalError = TRUE;

    if(m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
            if(m_State != EnumWaitForTermination && m_State != EnumWaitChannelDisband)
            {
                bReturn     =   TRUE;

                MBFTReceiveSubEvent TempReceive(lpNewPDU->GetFileHandle(),0,NULL,0,SenderID,FALSE,FALSE,FALSE);

                lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
                if(lpReceiveEvent)
                {
                    if(lpReceiveEvent->m_State == EnumWaitFileDataPDU)
                    {
                        MBFTMsg * lpNewMessage;

                        if(!lpNewPDU->GetIsAbort())
                        {
                            BOOL bSuccess = FALSE;
                            int  BytesWritten = 0;

                            if(lpReceiveEvent->m_bFileCompressed)
							{
								// We don't handle compressed files
								iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
							}
							else
                            {
                                BytesWritten = lpNewPDU->GetDataSize();

                                if(BytesWritten)
                                {
                                    if(!lpReceiveEvent->m_lpFile->Write(lpNewPDU->GetDataBuffer(),
                                                                        lpNewPDU->GetDataSize()))
                                    {
                                        iErrorCode = (MBFT_ERROR_CODE) lpReceiveEvent->m_lpFile->GetLastErrorCode();

                                        //iMBFT_FILE_IO_ERROR;
                                    }
                                }
                            }

                            //lpReceiveEvent->m_TotalBytesReceived += BytesWritten;

                            lpReceiveEvent->m_TotalBytesReceived   =  lpReceiveEvent->m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);

                            if(m_State != EnumWaitForTermination)
                            {
                                ASSERT(lpReceiveEvent->m_TotalBytesReceived >= lpReceiveEvent->m_cbRecvLastNotify);
                                ULONG nNotifyDelta = lpReceiveEvent->m_TotalBytesReceived - lpReceiveEvent->m_cbRecvLastNotify;
                                ULONG nNotifyThreshold = lpReceiveEvent->m_FileSize / 100; // 1%
                                if (nNotifyDelta >= nNotifyThreshold ||
                                    lpReceiveEvent->m_TotalBytesReceived >= lpReceiveEvent->m_FileSize)
                                {
                                    DBG_SAVE_FILE_LINE
                                    if (S_OK == m_lpParentEngine->SafePostNotifyMessage(
                                                    new FileTransmitMsg(m_EventHandle,
                                                                       lpReceiveEvent->m_hFile,
                                                                       lpReceiveEvent->m_FileSize,
                                                                       lpReceiveEvent->m_TotalBytesReceived,
                                                                       iMBFT_FILE_RECEIVE_PROGRESS,
                                                                       lpReceiveEvent->m_SenderID,
                                                                       lpReceiveEvent->m_bIsBroadcast)))
                                    {
                                        lpReceiveEvent->m_cbRecvLastNotify = lpReceiveEvent->m_TotalBytesReceived;
                                    }
                                }
                            }

                            if(iErrorCode == iMBFT_OK)
                            {
                                if(lpNewPDU->GetIsEOF())
                                {
                                    lpReceiveEvent->m_lpFile->SetFileDateTime(lpReceiveEvent->m_FileDateTime);

                                    lpReceiveEvent->m_lpFile->Close();
                                    lpReceiveEvent->m_State = EnumWaitForTermination;

									if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
									{
										SendFileEndAcknowledgePDU(lpReceiveEvent->m_hFile);
									}
									DeleteReceiveEvent(lpReceiveEvent,TRUE);
                                }
                            }
                        }
                        else
                        {
                            ReportError(lpReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                                        FALSE,SenderID);

                            if(!lpReceiveEvent->m_bFileCompressed)
                            {
                                lpReceiveEvent->m_lpFile->Write(lpNewPDU->GetDataBuffer(),
                                                                lpNewPDU->GetDataSize());
                            }
                            else
                            {
								// We don't handle compressed files
								iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
                            }

                            lpReceiveEvent->m_lpFile->Close(FALSE);
                            lpReceiveEvent->m_State = EnumWaitForTermination;

                            DeleteReceiveEvent(lpReceiveEvent,TRUE);
                        }
                    }
                }   //lpReceiveEvent
            } //m_State != EnumWaitForTermination

        if(iErrorCode != iMBFT_OK)
        {
			T120UserID id = bLocalError ? m_LocalMBFTUserID : SenderID;
			ReportError(lpReceiveEvent, iErrorType, iErrorCode, bLocalError, id);

            if(bLocalError)
            {
                ReportReceiverError(lpReceiveEvent,iErrorType,iErrorCode);
            }

            if(m_bOKToLeaveDataChannel)
            {
                if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
                {
                    SendChannelLeavePDU();
                }
                LeaveDataChannel();
            }

            DeleteReceiveEvent(lpReceiveEvent,TRUE);
        }
    }   //wChannelId == m_PrivateMBFTDataChannel

    return(bReturn);
}

int MBFTPrivateReceive::DecompressAndWrite
(
    MBFTReceiveSubEvent    *lpReceiveEvent,
    LPCSTR                  lpBuffer,
    LONG                    BufferLength,
    LPINT                   lpDecompressedSize
)
{
    return(iMBFT_MEMORY_ALLOCATION_ERROR);
}



BOOL MBFTPrivateReceive::OnReceivedFileErrorPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEERRORPDU          lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    MBFTReceiveSubEvent TempReceive(lpNewPDU->GetFileHandle(),0,NULL,0,SenderID,FALSE,FALSE,FALSE);
    MBFTReceiveSubEvent *lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
    if(lpReceiveEvent)
    {
        bReturn = TRUE;

        ReportError(lpReceiveEvent,lpNewPDU->GetErrorType(),
                    lpNewPDU->GetErrorCode(),
                    FALSE,SenderID);
    }
    else if(m_bProshareTransfer && m_ProshareSenderID == SenderID &&
            lpNewPDU->GetFileHandle() == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
    {
        ReportError(&TempReceive,lpNewPDU->GetErrorType(),
                    lpNewPDU->GetErrorCode(),
                    FALSE,SenderID);

        bReturn = TRUE;
    }

    return(bReturn);
}

void MBFTPrivateReceive::DoStateMachine(void)
{
    switch(m_State)
    {
    case EnumWaitSendChannelResponsePDU:
        SendChannelResponsePDU();
        break;

    case EnumWaitSendFileAcceptPDU:
        SendFileAcceptPDU();
        break;

    case EnumWaitSendFileRejectPDU:
        SendFileRejectPDU();
        break;

    case EnumWaitSendFileEndAcknowledgePDU:
        SendFileEndAcknowledgePDU();
        break;

    case EnumWaitSendChannelLeavePDU:
        SendChannelLeavePDU();
        break;

    // caseEnumInitializationFailed:
    default:
        break;
    }
}

BOOL MBFTPrivateReceive::OnMCSChannelAdmitIndication
(
    T120ChannelID           wChannelId,
    T120UserID              ManagerID
)
{
    BOOL fHandled = FALSE;
 	//
	// More data channels
	//
	if(m_State == EnumWaitFileOfferPDU)
	{
		if(m_MBFTDataSenderID == ManagerID)
		{
			//
			// Add the data channel to the list
			//
			m_PrivateMBFTDataChannelList.Append(wChannelId);
			T120ChannelID oldChannel = m_PrivateMBFTDataChannel;
			m_PrivateMBFTDataChannel = wChannelId;
			JoinDataChannel();
			m_PrivateMBFTDataChannel = oldChannel;
			fHandled = TRUE;
		}
	}
    else
    if(m_State == EnumWaitAdmitControlChannel)
    {
        if(m_PrivateMBFTControlChannel == wChannelId)
        {
            m_MBFTControlSenderID = ManagerID;

            JoinControlChannel();
            fHandled = TRUE;
        }
    }
    else if(m_State == EnumWaitAdmitDataChannelIndication)
    {
        if (m_PrivateMBFTDataChannelList.Find(wChannelId))
        {
            m_MBFTDataSenderID = ManagerID;

			T120ChannelID oldChannel = m_PrivateMBFTDataChannel;
			m_PrivateMBFTDataChannel = wChannelId;
			JoinDataChannel();
			m_PrivateMBFTDataChannel = oldChannel;
			fHandled = TRUE;
        }
    }

    if (! fHandled)
    {
        UINT chid_uid = MAKELONG(wChannelId, ManagerID);
        m_AdmittedChannelQueue.Append(chid_uid);
    }

    return fHandled;
}

BOOL MBFTPrivateReceive::OnMCSChannelExpelIndication
(
    T120ChannelID           wChannelId,
    Reason                  iReason
)
{
    BOOL bReturn = FALSE;

    if(/*(wChannelId == m_PrivateMBFTControlChannel) ||*/
       m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
        TRACERECEIVE(" Channel [%u] disbanded, terminating receive session\n",wChannelId);

        //Added by Atul to fix this problem:
        //If the sender aborts all files, or the send is aborted when the
        //last file is being sent, the sender sends a FileDataPDU with the
        ///AbortFlag set to TRUE and proceeds to disband the channel. However,
        //on account of a MCS bug, the receiver never sees the PDU (sic).
        //Therefore, when we receive a channel expel indication, we check to
        //see if we were receiving a file and post a iMBFT_SENDER_ABORTED if necessary...

        if(m_CurrentReceiveEvent /* && m_bProshareTransfer */ )
        {
            if(m_CurrentReceiveEvent->m_State == EnumWaitFileDataPDU ||
               m_CurrentReceiveEvent->m_State == EnumWaitFileStartPDU)
            {
                TRACE(" Unexpected channel disband encountered, posting SENDER_ABORTED message\n");

                ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                            FALSE,m_ProshareSenderID);

                m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                m_CurrentReceiveEvent->m_State = EnumWaitForTermination;
                DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
            }
        }

        UnInitialize();

        bReturn = TRUE;
    }

    m_AdmittedChannelQueue.RemoveByChannelID(wChannelId);

    return(bReturn);
}


void MBFTPrivateReceive::SendChannelResponsePDU(void)
{
		if(m_PrivateMBFTControlChannel >= MIN_ASNDynamicChannelID &&
			m_PrivateMBFTControlChannel <= MAX_ASNDynamicChannelID)
		{
			T127_PRIVATE_CHANNEL_RESPONSE ChannelJoinResponsePDU;
			ChannelJoinResponsePDU.pduType = T127_PRIVATE_CHANNEL_JOIN_RESPONSE;
			ChannelJoinResponsePDU.ControlChannel = SWAPWORD(m_PrivateMBFTControlChannel - MIN_ASNDynamicChannelID);
			ChannelJoinResponsePDU.Response = (ASNPrivate_Channel_Join_ResponsePDU_result_successful << 5);
            // if the Mode is FALSE we should use ASNinvitation_rejected
            if(m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)&ChannelJoinResponsePDU,
                                                 4))
            {
                TRACERECEIVE(" Sent Channel response PDU on [%u]\n",m_MBFTControlSenderID);
                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            TRACE(" Receive: Fatal Encoding Failure\n");
            m_State = EnumInitializationFailed;
            //Encoding failed....
        }
}

BOOL MBFTPrivateReceive::SendFileAcceptPDU
(
    MBFTFILEHANDLE          iFileHandle
)
{
    m_State     =   EnumWaitSendFileAcceptPDU;

    if(iFileHandle)
    {
        m_CurrentAcceptHandle   =   iFileHandle;
    }

    BOOL bReturn = FALSE;

    DBG_SAVE_FILE_LINE
    LPFILEACCEPTPDU lpNewPDU = new FileAcceptPDU(m_CurrentAcceptHandle);
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                bReturn = TRUE;
                TRACERECEIVE(" Sent file accept PDU on [%u]\n",m_MBFTControlSenderID);
                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }

        delete lpNewPDU;
    }

    return(bReturn);
}

void MBFTPrivateReceive::OnControlNotification
(
    MBFTFILEHANDLE  hFile,
    FileTransferControlMsg::FileTransferControl iControlCommand,
    LPCSTR          lpszDirectory,
    LPCSTR          lpszFileName
)
{
    MBFTReceiveSubEvent * lpReceiveEvent = NULL;
    MBFTFILEHANDLE iFileHandle;
    BOOL bAbortHack =   FALSE;

    if(m_State  !=  EnumWaitChannelDisband && m_State  !=  EnumWaitForTermination)
    {
		MBFTReceiveSubEvent TempReceive(hFile,0,NULL,0,0,FALSE,FALSE,FALSE);

		lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
        if(lpReceiveEvent)
        {
            iFileHandle = (MBFTFILEHANDLE)lpReceiveEvent->m_hFile;

            if(iControlCommand == FileTransferControlMsg::EnumAcceptFile)
            {
                if(lpReceiveEvent->m_State == EnumWaitUserConfirmation)
                {
                    ::lstrcpynA(lpReceiveEvent->m_szFileDirectory,lpszDirectory,
                             sizeof(lpReceiveEvent->m_szFileDirectory));

                    int Length = ::lstrlenA(lpReceiveEvent->m_szFileDirectory);

                    if(Length >= 3)
                    {
                    	PCHAR pch = SzFindLastCh(lpReceiveEvent->m_szFileDirectory, '\\');
                    	if ('\0' == *(pch+1))
                        {
                            lpReceiveEvent->m_szFileDirectory[Length - 1] = '\0';
                        }
                    }

                    if (::lstrlenA(lpszFileName))
                    {
                        ::lstrcpynA(lpReceiveEvent->m_szFileName, lpszFileName, sizeof(lpReceiveEvent->m_szFileName));
                    }

                    TRACERECEIVE(" File accept notification for [%u]\n",iFileHandle);
                    lpReceiveEvent->m_UserAccepted = TRUE;
                    m_CurrentReceiveEvent = lpReceiveEvent;

                    if(m_JoinedToDataChannel)
                    {
                        SendFileAcceptPDU(iFileHandle);
                        lpReceiveEvent->m_State = EnumWaitFileStartPDU;
                    }
                    else
                    {
                        m_State = EnumWaitRejoinDataChannel;
                        //m_CurrentReceiveEvent = lpReceiveEvent;
                        JoinDataChannel();
                    }
                }
            }
            else if(iControlCommand == FileTransferControlMsg::EnumRejectFile)
            {
                if((lpReceiveEvent->m_State == EnumWaitUserConfirmation) ||
                   (lpReceiveEvent->m_bIsBroadcast && lpReceiveEvent->m_State == EnumWaitFileStartPDU))
                {
                    if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                    {
                        iFileHandle = LOWORD(_iMBFT_PROSHARE_ALL_FILES);
                    }

                    TRACERECEIVE(" Rejecting file [%u]\n",lpReceiveEvent->m_hFile);

                    if(m_bOKToLeaveDataChannel)
                    {
                        LeaveDataChannel();
                    }

                    SendFileRejectPDU(iFileHandle);

                    if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                    {
                        TerminateReceiveSession();
                    }
                    else
                    {
                        DeleteReceiveEvent(lpReceiveEvent,FALSE);
                    }
                }
            }
            else if(iControlCommand == FileTransferControlMsg::EnumAbortFile)
            {
                if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                {
                    iFileHandle = LOWORD(_iMBFT_PROSHARE_ALL_FILES);
                }

                if((lpReceiveEvent->m_State == EnumWaitFileDataPDU) ||
                   (lpReceiveEvent->m_State == EnumWaitFileStartPDU) ||
                   (hFile == _iMBFT_PROSHARE_ALL_FILES))
                {
                    TRACERECEIVE(" Aborting file [%u]\n",iFileHandle);
                    if(lpReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation)
                    {
                        TRACERECEIVE(" Rejecting file [%u]\n",lpReceiveEvent->m_hFile);
                        SendFileRejectPDU(iFileHandle);
                    }
                    else
                    {
                        if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                        {
                            //If the AbortHack flag is set, we are on a sticky wicket.
                            //We have already aborted the current file and are waiting
                            //for another file offer. Therefore we don't inform the sender
                            //about this one...
                            if(!bAbortHack)
                            {
                                ReportReceiverError(lpReceiveEvent,
                                                    MBFT_PERMANENT_ERROR,
                                                    iMBFT_RECEIVER_ABORTED,
                                                    iFileHandle);
                            }
                        }
                        else
                        {
                            ReportReceiverError(lpReceiveEvent,
                                                MBFT_PERMANENT_ERROR,
                                                iMBFT_RECEIVER_ABORTED);
                        }
                    }

                    ReportError(lpReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_RECEIVER_ABORTED);

                    if(m_bOKToLeaveDataChannel)
                    {
                        if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
                        {
                            SendChannelLeavePDU();
                        }
                        LeaveDataChannel();
                    }

                    if(hFile != _iMBFT_PROSHARE_ALL_FILES)
                    {
                        DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);

                        lpReceiveEvent->m_lpFile->Close(FALSE);
    //                    lpReceiveEvent->m_lpFile->DeleteFile();
                        DeleteReceiveEvent(lpReceiveEvent,TRUE);
                    }
                    else if(m_CurrentReceiveEvent)
                    {
                        m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
    //                    m_CurrentReceiveEvent->m_lpFile->DeleteFile();
                        DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
                    }
                }

                if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                {
                    DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);
                    DeleteNotificationMessages(iMBFT_FILE_OFFER);
                    TerminateReceiveSession();
                }
            }
        }
    }
}

void MBFTPrivateReceive::DeleteNotificationMessages
(
    MBFT_NOTIFICATION       iNotificationType
)
{
#if 0 // lonchanc: no way we can delete notify messages which are already in the queue
    MBFTMsg * lpNewMessage;
    CMsgQueue *pNotifyMsgList = m_lpParentEngine->GetNotificationMsgList();
    CMsgQueue DeleteList;

    pNotifyMsgList->Reset();
    while (NULL != (lpNewMessage = pNotifyMsgList->Iterate()))
    {
        switch (lpNewMessage->GetMsgType())
        {
        case EnumFileTransmitMsg:
            {
                FileTransmitMsg *lpFileMsg = (FileTransmitMsg *)lpNewMessage;
                if(lpFileMsg->m_EventHandle == m_EventHandle)
                {
                    if(iNotificationType == lpFileMsg->m_TransmitStatus)
                    {
                        TRACERECEIVE(" NUKING Notification [%x] from Event [%ld], Handle: [%ld] FileSize: [%ld], Bytes Xfered[%ld]\n",
                                     lpFileMsg->m_TransmitStatus,lpFileMsg->m_EventHandle,
                                     lpFileMsg->m_hFile,
                                     lpFileMsg->m_FileSize,
                                     lpFileMsg->m_BytesTransmitted);
                        DeleteList.Append(lpNewMessage);
                    }
                }
            }
            break;

        case EnumFileOfferNotifyMsg:
            {
                FileOfferNotifyMsg *lpFileOfferMsg = (FileOfferNotifyMsg *)lpNewMessage;
                if(lpFileOfferMsg->m_EventHandle == m_EventHandle)
                {
                    if(iNotificationType == iMBFT_FILE_OFFER)
                    {
                        TRACERECEIVE(" NUKING File Offer Notification for [%s], Event: [%ld], Size: [%ld], Handle [%Fp]\n",
                                     lpFileOfferMsg->m_szFileName,lpFileOfferMsg->m_EventHandle,
                                     lpFileOfferMsg->m_FileSize,lpFileOfferMsg->m_hFile);
                        DeleteList.Append(lpNewMessage);
                    }
                }
            }
            break;

        default:
            ASSERT(0);
            break;
        } // switch
    } //for loop

    // remove handled messages
    pNotifyMsgList->DeleteSubset(&DeleteList);
#endif // 0
}

void MBFTPrivateReceive::SendFileRejectPDU
(
    MBFTFILEHANDLE      iFileHandle
)
{
    if(m_State !=  EnumWaitSendFileRejectPDU)
    {
        m_PreviousRejectState     =   m_State;
        m_State                   =   EnumWaitSendFileRejectPDU;
    }

    if(iFileHandle)
    {
        m_CurrentRejectHandle   =   iFileHandle;
    }

    FileRejectPDU * lpNewPDU = NULL;

    DBG_SAVE_FILE_LINE
    lpNewPDU = new FileRejectPDU(m_CurrentRejectHandle);
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                m_State = (m_PreviousRejectState != EnumWaitChannelDisband) ?
                          EnumWaitFileOfferPDU : EnumWaitChannelDisband;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }
    }

    delete lpNewPDU;
}

void MBFTPrivateReceive::SendFileEndAcknowledgePDU
(
    MBFTFILEHANDLE      iFileHandle
)
{
    if(iFileHandle)
    {
        m_CurrentFileEndHandle =   LOWORD(iFileHandle);
    }

    m_State =  EnumWaitSendFileEndAcknowledgePDU;

    DBG_SAVE_FILE_LINE
    FileEndAcknowledgeStruct * lpNewStruct  =   new FileEndAcknowledgeStruct;

    lpNewStruct->m_FileHandle   =  m_CurrentFileEndHandle;

    DBG_SAVE_FILE_LINE
    NonStandardPDU * lpNewPDU = new NonStandardPDU(NULL,
                                                   PROSHARE_FILE_END_STRING,
                                                   lpNewStruct,
                                                   sizeof(FileEndAcknowledgeStruct));
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTControlChannel,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                TRACERECEIVE( " Sent FileEndAcknowledgePDU for [%u] on [%u]\n",m_CurrentFileEndHandle,m_PrivateMBFTControlChannel);

                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }

        delete  lpNewPDU;
    }

    delete  lpNewStruct;
}

void MBFTPrivateReceive::SendChannelLeavePDU(void)
{
    m_State =  EnumWaitSendChannelLeavePDU;

    DBG_SAVE_FILE_LINE
    ChannelLeaveStruct * lpNewStruct  =   new ChannelLeaveStruct;

    lpNewStruct->m_ChannelID   =    m_PrivateMBFTDataChannel;
    lpNewStruct->m_ErrorCode   =    iMBFT_RECEIVER_ABORTED;

    DBG_SAVE_FILE_LINE
    NonStandardPDU * lpNewPDU = new NonStandardPDU(NULL,
                                                   PROSHARE_CHANNEL_LEAVE_STRING,
                                                   lpNewStruct,
                                                   sizeof(ChannelLeaveStruct));
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTControlChannel,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                TRACERECEIVE( " Sent ChannelLeavePDU for [%u] on [%u]\n",m_PrivateMBFTDataChannel,m_PrivateMBFTControlChannel);

                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }

        delete  lpNewPDU;
    }

    delete  lpNewStruct;
}

void MBFTPrivateReceive::LeaveDataChannel(void)
{
    if(m_JoinedToDataChannel)
    {
        if(m_lpParentEngine->MCSChannelLeaveRequest(m_PrivateMBFTDataChannel))
        {
            TRACERECEIVE(" Left data channel\n");
            m_JoinedToDataChannel = FALSE;
        }
    }
}

void MBFTPrivateReceive::TerminateReceiveSession(void)
{
    //if(m_lpParentEngine->MCSChannelLeaveRequest(m_PrivateMBFTControlChannel))
    //{
        //TRACERECEIVE(" Left control channel\n");
    //}

    //Keep the clients happy....

    if(!m_bEventEndPosted)
    {
        DBG_SAVE_FILE_LINE
        m_lpParentEngine->SafePostNotifyMessage(new FileEventEndNotifyMsg(m_EventHandle));
        m_bEventEndPosted   =   TRUE;
    }

    LeaveDataChannel();

    m_State     =   EnumWaitChannelDisband;

    //UnInitialize();
}


void MBFTPrivateReceive::OnPeerDeletedNotification
(
    CPeerData           *lpPeerData
)
{
    if(m_bProshareTransfer)
    {
        if(m_ProshareSenderID == lpPeerData->GetUserID())
        {
            if(m_CurrentReceiveEvent)
            {
                if((m_CurrentReceiveEvent->m_State == EnumWaitFileDataPDU) ||
                  (m_CurrentReceiveEvent->m_State == EnumWaitFileStartPDU))
                {
                    ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                                FALSE,m_ProshareSenderID);

                    m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                    m_CurrentReceiveEvent->m_State = EnumWaitForTermination;
                    DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
                }
            }

            DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);
            DeleteNotificationMessages(iMBFT_FILE_OFFER);
            TerminateReceiveSession();
        }
    }
}




#ifdef USE_BROADCAST_RECEIVE
MBFTBroadcastReceive::MBFTBroadcastReceive
(
    LPMBFTENGINE            lpParentEngine,
    MBFTEVENTHANDLE         EventHandle,
    T120ChannelID           wControlChannel,
    T120ChannelID           wDataChannel,
    T120UserID              SenderID,
    MBFTFILEHANDLE          FileHandle
)
:
    MBFTPrivateReceive(lpParentEngine, EventHandle, wControlChannel, wDataChannel),
    m_SenderID(SenderID),
    m_FileHandle(FileHandle)
{
    m_MBFTControlSenderID = m_SenderID;
    m_State = MBFTPrivateReceive::EnumWaitFileOfferPDU;
}

BOOL MBFTBroadcastReceive::OnReceivedFileOfferPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
	T120NodeID				NodeID,
    LPFILEOFFERPDU          lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitFileOfferPDU)
    {
        bReturn = (wChannelId == m_PrivateMBFTControlChannel) &&
                  (lpNewPDU->GetFileHandle() ==  m_FileHandle) &&
                  (SenderID == m_SenderID);

        if(bReturn)
        {
            MBFTPrivateReceive::OnReceivedFileOfferPDU(wChannelId,
                                                       iPriority,
                                                       SenderID,
													   NodeID,
                                                       lpNewPDU,
                                                       IsUniformSendData);

            m_CurrentReceiveEvent = m_ReceiveList.PeekHead();
            if(m_CurrentReceiveEvent)
            {
                ::lstrcpyA(m_CurrentReceiveEvent->m_szFileName,lpNewPDU->GetFileName());
                if(!lpNewPDU->GetAcknowledge())
                {
                    m_State = m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitFileStartPDU;
                }
                else
                {
                    m_State  =  m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitUserConfirmation;
                }
            }
            else
            {
                UnInitialize();
                //m_State = MBFTPrivateReceive::EnumWaitForTermination;
            }
        }
    }

    return(bReturn);
}

BOOL MBFTBroadcastReceive::OnMCSChannelJoinConfirm
(
    T120ChannelID           wChannelId,
    BOOL                    bSuccess
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitJoinDataChannel &&
    	m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
        bReturn                 = TRUE;
        m_JoinedToDataChannel   = TRUE;

        if(bSuccess && m_CurrentReceiveEvent)
        {
            m_State = MBFTPrivateReceive::EnumWaitSendFileAcceptPDU;
        }
        else
        {
            //m_State  =   MBFTPrivateReceive::EnumWaitForTermination;

            LeaveDataChannel();
            UnInitialize();
        }
    }

    return(bReturn);
}

BOOL MBFTBroadcastReceive::OnReceivedFileStartPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILESTARTPDU          lpFileStartPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitFileStartPDU && m_CurrentReceiveEvent)
    {
        bReturn = m_PrivateMBFTDataChannelList.Find(wChannelId) &&
                  (lpFileStartPDU->GetFileHandle() ==  m_FileHandle) &&
                  (SenderID == m_SenderID);

        if(bReturn)
        {
            if(!lstrlen(m_CurrentReceiveEvent->m_szFileName))
            {
                lstrcpy(m_CurrentReceiveEvent->m_szFileName,lpFileStartPDU->GetFileName());
            }

            if(!lstrlen(m_CurrentReceiveEvent->m_szFileDirectory))
            {
                lstrcpy(m_CurrentReceiveEvent->m_szFileDirectory,m_CurrentReceiveEvent->m_lpFile->GetTempDirectory());
            }

            MBFTPrivateReceive::OnReceivedFileStartPDU(wChannelId,
                                                       iPriority,
                                                       SenderID,
                                                       lpFileStartPDU,
                                                       IsUniformSendData);

            //Assumption: m_CurrentReceiveEvent == NULL indicates an error.

            if(!m_CurrentReceiveEvent || lpFileStartPDU->GetIsEOF())
            {
                //m_State = MBFTPrivateReceive::EnumWaitForTermination;
                UnInitialize();
            }
            else
            {
                m_State = m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitFileDataPDU;
            }
        }
    }

    return(bReturn);
}

BOOL MBFTBroadcastReceive::OnReceivedFileDataPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEDATAPDU           lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitFileDataPDU && m_CurrentReceiveEvent)
    {
        bReturn = m_PrivateMBFTDataChannelList.Find(wChannelId) &&
                  (lpNewPDU->GetFileHandle() ==  m_FileHandle) &&
                  (SenderID == m_SenderID);

        if(bReturn)
        {
            MBFTPrivateReceive::OnReceivedFileDataPDU(wChannelId,
                                                      iPriority,
                                                      SenderID,
                                                      lpNewPDU,
                                                      IsUniformSendData);

            if(!m_CurrentReceiveEvent || lpNewPDU->GetIsEOF())
            {
                //m_State = MBFTPrivateReceive::EnumWaitForTermination;

                //LeaveDataChannel();

                UnInitialize();
            }
        }
    }

    return(bReturn);
}

void MBFTBroadcastReceive::UnInitialize
(
    BOOL        bIsShutDown
)
{
    if(m_State != EnumWaitForTermination)
    {
        m_State = EnumWaitForTermination;

        if(!bIsShutDown)
        {
            DBG_SAVE_FILE_LINE
            m_lpParentEngine->SafePostMessage(new DeleteSessionMsg(this));
            if(!m_bEventEndPosted)
            {
                DBG_SAVE_FILE_LINE
                m_lpParentEngine->SafePostNotifyMessage(new FileEventEndNotifyMsg(m_EventHandle));
                m_bEventEndPosted   =   TRUE;
            }
        }
    }
}

void MBFTBroadcastReceive::DoStateMachine(void)
{
    if(m_State == MBFTPrivateReceive::EnumWaitSendFileAcceptPDU)
    {
        if(m_CurrentReceiveEvent)
        {
            if(SendFileAcceptPDU(m_FileHandle))
            {
                m_State = m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitFileStartPDU;
            }
        }
        else
        {
            //m_State = MBFTPrivateReceive::EnumWaitForTermination;
            UnInitialize();
        }
    }
}

void MBFTBroadcastReceive::OnControlNotification
(
    MBFTFILEHANDLE          hFile,
    FileTransferControlMsg::FileTransferControl iControlCommand,
    LPCSTR                  lpszDirectory,
    LPCSTR                  lpszFileName
)
{
    if(m_State != MBFTPrivateReceive::EnumWaitForTermination)
    {
        if(m_CurrentReceiveEvent)
        {
            MBFTFILEHANDLE iFileHandle = (MBFTFILEHANDLE) m_CurrentReceiveEvent->m_hFile;

            if(iControlCommand == FileTransferControlMsg::EnumAcceptFile)
            {
                if(m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation)
                {
                    ::lstrcpynA(m_CurrentReceiveEvent->m_szFileDirectory,lpszDirectory,
                             sizeof(m_CurrentReceiveEvent->m_szFileDirectory));

                    int Length = ::lstrlenA(m_CurrentReceiveEvent->m_szFileDirectory);

                    if(Length >= 3)
                    {
                    	PCHAR pch = SzFindLastCh(m_CurrentReceiveEvent->m_szFileDirectory, '\\');
                    	if ('\0' == *(pch+1))
                        {
                            m_CurrentReceiveEvent->m_szFileDirectory[Length - 1] = '\0';
                        }
                    }

                    if (::lstrlenA(lpszFileName))
                    {
                        ::lstrcpynA(m_CurrentReceiveEvent->m_szFileName, lpszFileName, sizeof(m_CurrentReceiveEvent->m_szFileName));
                    }

                    TRACERECEIVE(" File accept notification for [%u]\n",iFileHandle);

                    m_CurrentReceiveEvent->m_UserAccepted = TRUE;

                    JoinDataChannel();

                    m_State     =   MBFTPrivateReceive::EnumWaitJoinDataChannel;
                }
            }
#if 0
            else if(iControlCommand == FileTransferControlMsg::EnumRejectFile)
            {
                if((m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation))
                {
                    LeaveDataChannel();
                    SendFileRejectPDU(iFileHandle);
                    DeleteReceiveEvent(m_CurrentReceiveEvent,FALSE);
                    UnInitialize();
                }
            }
#endif
            else if((iControlCommand == FileTransferControlMsg::EnumAbortFile)
                    || (iControlCommand == FileTransferControlMsg::EnumRejectFile))
            {
                if((m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitFileDataPDU) ||
                   (m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitFileStartPDU) ||
                   (m_CurrentReceiveEvent->m_State == EnumWaitUserConfirmation))
                {
                    TRACERECEIVE(" Aborting file [%u]\n",iFileHandle);

                    if(m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation)
                    {
                        //LeaveDataChannel();

                        SendFileRejectPDU(iFileHandle);

                        //DeleteReceiveEvent(m_CurrentReceiveEvent,FALSE);
                        //UnInitialize();
                    }
                    else
                    {
                        ReportReceiverError(m_CurrentReceiveEvent,
                                            MBFT_PERMANENT_ERROR,
                                            iMBFT_RECEIVER_ABORTED);
                    }

                    ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_RECEIVER_ABORTED);

                    LeaveDataChannel();

                    DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);
                    m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                    DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
                    UnInitialize();
                 }
            }
        }
    }
}

void MBFTBroadcastReceive::OnPeerDeletedNotification
(
    CPeerData           *lpPeerData
)
{
    if(lpPeerData->GetUserID() == m_SenderID)
    {
        if(m_CurrentReceiveEvent)
        {
            if(m_State == MBFTPrivateReceive::EnumWaitFileStartPDU ||
               m_State == MBFTPrivateReceive::EnumWaitFileDataPDU)
            {
                ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                            FALSE,m_ProshareSenderID);

                m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
            }

            DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);

            UnInitialize();
        }
    }
}

#endif	// USE_BROADCAST_RECEIVE


MBFTReceiveSubEvent * CRecvSubEventList::FindEquiv
(
    MBFTReceiveSubEvent         *pEvent
)
{
    MBFTReceiveSubEvent *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->IsEqual(pEvent))
        {
            return p;
        }
    }
    return NULL;
}

void CRecvSubEventList::Delete
(
    MBFTReceiveSubEvent         *pEvent
)
{
    if (Remove(pEvent))
    {
        delete pEvent;
    }
}

void CRecvSubEventList::DeleteAll(void)
{
    MBFTReceiveSubEvent *p;
    while (NULL != (p = Get()))
    {
        delete p;
    }
}



BOOL CChannelUidQueue::RemoveByChannelID(T120ChannelID nChannelID)
{
    UINT_PTR chid_uid;
    Reset();
    while (0 != (chid_uid = Iterate()))
    {
        if (LOWORD(chid_uid) == nChannelID)
        {
            return Remove(chid_uid);
        }
    }
    return FALSE;
}

UINT_PTR CChannelUidQueue::FindByChannelID(T120ChannelID nChannelID)
{
    UINT_PTR chid_uid;
    Reset();
    while (0 != (chid_uid = Iterate()))
    {
        if (LOWORD(chid_uid) == nChannelID)
        {
            return chid_uid;
        }
   }
   return 0;
}

LPTSTR GetRootDirPath(LPTSTR pszDirPath, LPTSTR pszRootDirPath, int nSize)
{
	::lstrcpy(pszRootDirPath, pszDirPath);
	if (pszRootDirPath[0] == TEXT('\\'))
	{
		if (pszRootDirPath[1] != TEXT('\\'))
		{
			return NULL;
		}

		// the path starts with two '\\'
		BOOL fFirstSlash = FALSE;
		LPTSTR psz = pszRootDirPath + 2;
		while (*psz && !(fFirstSlash && *psz == TEXT('\\')))
		{
			if (*psz == TEXT('\\'))
			{
				fFirstSlash = TRUE;
			}
			psz = ::CharNext(psz);
		}

		*psz++ = '\\';
		*psz = '\0';
		return pszRootDirPath;
	}

	// the first char is not a '\\', it could be driver letter followed by ':'
	if (pszRootDirPath[1] == TEXT(':'))
	{
		pszRootDirPath[2] = TEXT('\\');
		pszRootDirPath[3] = TEXT('\0');
		return pszRootDirPath;
	}

	// the second char is not a ':' , must be a sub directory
	return NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftpch.h ===
/* ----------------------------------------------------------------------

	Copyright (c) 1996, Microsoft Corporation
	All rights reserved

	mbftpch.h

  ---------------------------------------------------------------------- */

#define _WINDOWS

// System Include files
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <commdlg.h>
#include <shellapi.h>
#include <time.h>

// Oprah files
#include <oprahcom.h>
#include <confdbg.h>
#include <cstring.hpp>

// Local Include files
#include <ConfDbg.h>
#include <debspew.h>
#include <confreg.h>

// MBFT include files

extern "C"
{
#include "t120.h"
}

#include <imcsapp.h>
#include <igccapp.h>
#include <imbft.h>

#include "mbftdbg.h"

#include "ms_util.h"
#include "cntlist.h"

const USHORT _MBFT_CONTROL_CHANNEL                   = 9;
const USHORT _MBFT_DATA_CHANNEL                      = 10;

const ULONG _iMBFT_PROSHARE_ALL_FILES = 0xFFFFFFFF;
const UINT  _iMBFT_DEFAULT_SESSION    = _MBFT_CONTROL_CHANNEL; // 9
const UINT  _iMBFT_CREATE_NEW_SESSION = 0;
const UINT  _iMBFT_MAX_PATH           = MAX_PATH;    //Max chars in file pathname


typedef enum
{
    MBFT_STATIC_MODE,
    MBFT_MULTICAST_MODE,
    // MBFT_PRIVATE_MODE, // not used at all
}
    MBFT_MODE;

typedef enum
{
    MBFT_PRIVATE_SEND_TYPE,
    MBFT_PRIVATE_RECV_TYPE,
    MBFT_BROADCAST_RECV_TYPE,
}
    MBFT_SESSION_TYPE;


// A list of the notification callbacks to the app
typedef enum
{
    iMBFT_FILE_OFFER,
    iMBFT_FILE_SEND_BEGIN,
    iMBFT_FILE_SEND_END,
    iMBFT_FILE_SEND_PROGRESS,
    iMBFT_FILE_RECEIVE_PROGRESS,
    iMBFT_FILE_RECEIVE_BEGIN,
    iMBFT_FILE_RECEIVE_END,
}
    MBFT_NOTIFICATION;


// Prototype of callback function that MBFT client apps must implement
typedef void (CALLBACK * MBFTCALLBACK)(
    MBFT_NOTIFICATION eNotificationCode,
    WPARAM wParam,                      // error code if appropriate
    LPARAM lParam,                      // Ptr to struct with event info
    LPARAM lpCallerDefined);            // Client defined - see MBFTInitialize


// #define MAX_APP_KEY_SIZE 100
#define MAX_APP_KEY_SIZE        16   // applet name

// global strings that should not be localized
#define MY_APP_STR                      "_MSCONFFT"
#define PROSHARE_STRING                 "NetMeeting 1 MBFT"
#define PROSHARE_FILE_END_STRING        "NetMeeting 1 FileEnd"
#define PROSHARE_CHANNEL_LEAVE_STRING   "NetMeeting 1 ChannelLeave"
#define DATA_CHANNEL_RESOURCE_ID        "D0"

// capabilities
extern const GCCAppCap* g_aAppletCaps[4];
extern const GCCNonCollCap* g_aAppletNonCollCaps[2];

// applet session key
extern GCCSessionKey g_AppletSessionKey;

// work thread ID
extern HINSTANCE g_hDllInst;
extern DWORD g_dwWorkThreadID;
extern CRITICAL_SECTION g_csWorkThread;
extern TCHAR g_szMBFTWndClassName[32];

LRESULT CALLBACK MBFTNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

#include "osshelp.hpp"
#include "messages.hpp"
#include "applet.hpp"
#include "mbft.hpp"
#include "mbftapi.hpp"

#include "ftui.h"
#include "ftldr.h"

#include "t127pdus.h"


#define GetFileNameFromPath ExtractFileName

// from mbftsend.cpp
VOID MbftInitDelay(void);

#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))

// nPeerID is actually nUserID of file transfer
typedef DWORD MEMBER_ID;
#define MAKE_MEMBER_ID(nPeerID,nNodeID)         MAKELONG((nPeerID), (nNodeID))
#define GET_PEER_ID_FROM_MEMBER_ID(nMemberID)   LOWORD((nMemberID))
#define GET_NODE_ID_FROM_MEMBER_ID(nMemberID)   HIWORD((nMemberID))


extern ULONG    g_nSendDisbandDelay;
extern ULONG    g_nChannelResponseDelay;

extern BOOL     g_fSendAllowed;
extern BOOL     g_fRecvAllowed;
extern UINT_PTR     g_cbMaxSendFileSize;

extern BOOL     g_fNoUI;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\messages.cpp ===
/* file: messages.cpp */

#include "mbftpch.h"

#include "osshelp.hpp"
#include "mbft.hpp"
#include "messages.hpp"
#include "mbftapi.hpp"


MBFTMsg::~MBFTMsg(void)
{
}


MCSSendDataIndicationMsg::MCSSendDataIndicationMsg
(
    T120ChannelID       wChannelId,
    T120Priority        iPriority,
    T120UserID          SenderID,
    LPBYTE              lpBuffer,
    ULONG               ulDataLength,
    BOOL                IsUniformSendData
)
:
    MBFTMsg(EnumMCSSendDataIndicationMsg),
    m_wChannelId(wChannelId),
    m_iPriority(iPriority),
    m_SenderID(SenderID),
    m_lpBuffer(lpBuffer),
    m_ulDataLength(ulDataLength),
    m_IsUniformSendData(IsUniformSendData)
{
}

MBFTPDUMsg::MBFTPDUMsg
(
    T120ChannelID       wChannelId,
    T120Priority        iPriority,
    T120UserID          SenderID,
    LPGENERICPDU        lpNewPDU,
    BOOL                IsUniformSendData,
    MBFTPDUType         PDUType,
    LPSTR               lpDecodedBuffer
)
:
    MBFTMsg(EnumGenericMBFTPDUMsg),
    m_wChannelId(wChannelId),
    m_iPriority(iPriority),
    m_SenderID(SenderID),
    m_lpNewPDU(lpNewPDU),
    m_IsUniformSendData(IsUniformSendData),
    m_PDUType(PDUType),
    m_lpDecodedBuffer(lpDecodedBuffer)
{
}

MBFTPDUMsg::~MBFTPDUMsg(void)
{
    delete m_lpDecodedBuffer;
    delete m_lpNewPDU;
}


CreateSessionMsg::CreateSessionMsg
(
    MBFT_SESSION_TYPE   iSessionType,
    MBFTEVENTHANDLE     EventHandle,
    T120SessionID       SessionID,
    T120ChannelID       wControlChannel,
    T120ChannelID       wDataChannel,
    T120UserID          SenderID,
    MBFTFILEHANDLE      FileHandle
)
:
    MBFTMsg(EnumCreateSessionMsg),
    m_iSessionType(iSessionType),
    m_SessionID(SessionID),
    m_EventHandle(EventHandle),
    m_ControlChannel(wControlChannel),
    m_DataChannel(wDataChannel),
    m_SenderID(SenderID),
    m_FileHandle(FileHandle)
{
}


SubmitFileSendMsg::SubmitFileSendMsg
(
	T120UserID			uidReceiver,
	T120NodeID			nidReceiver,
    LPCSTR              pszFilePath,
    MBFTFILEHANDLE      nFileHandle,
    MBFTEVENTHANDLE     EventHandle,
    BOOL                bCompressFiles
)
:
    MBFTMsg(EnumSubmitFileSendMsg),
	m_nUserID(uidReceiver),
	m_nNodeID(nidReceiver),
    m_pszFilePath((LPSTR) pszFilePath),
    m_nFileHandle(nFileHandle),
    m_EventHandle(EventHandle),
    m_bCompressFiles(bCompressFiles)
{
}

SubmitFileSendMsg::~SubmitFileSendMsg(void)
{
    delete  m_pszFilePath;
}

FileOfferNotifyMsg::FileOfferNotifyMsg
(
    MBFTEVENTHANDLE     EventHandle,
    T120UserID          SenderID,
	T120NodeID			NodeID,
    MBFTFILEHANDLE      hFile,
    LPCSTR              lpszFilename,
    ULONG               FileSize,
    time_t              FileDateTime,
    BOOL                bAckNeeded
)
:
    MBFTMsg(EnumFileOfferNotifyMsg),
    m_SenderID(SenderID),
	m_NodeID(NodeID),
    m_EventHandle(EventHandle),
    m_FileSize(FileSize),
    m_hFile(hFile),
    m_FileDateTime(FileDateTime),
    m_bAckNeeded(bAckNeeded)
{
    ::lstrcpynA(m_szFileName, lpszFilename, sizeof(m_szFileName));
}


FileTransferControlMsg::FileTransferControlMsg
(
    MBFTEVENTHANDLE     EventHandle,
    MBFTFILEHANDLE      hFile,
    LPCSTR              lpszDirectory,
    LPCSTR              lpszFileName,
    FileTransferControl iControlCommand
)
:
    MBFTMsg(EnumFileTransferControlMsg),
    m_EventHandle(EventHandle),
    m_hFile(hFile),
    m_ControlCommand(iControlCommand)
{
    if(lpszDirectory)
    {
        ::lstrcpynA(m_szDirectory, lpszDirectory, sizeof(m_szDirectory));
#ifdef BUG_INTL
        ::AnsiToOem(m_szDirectory, m_szDirectory);
#endif
    }
    else
    {
        m_szDirectory[0] = '\0';
    }

    if(lpszFileName)
    {
        ::lstrcpynA(m_szFileName, lpszFileName, sizeof(m_szFileName));
#ifdef BUG_INTL
        ::AnsiToOem(m_szFileName, m_szFileName);
#endif
    }
    else
    {
        m_szFileName[0] = '\0';
    }
}

FileTransmitMsg::FileTransmitMsg
(
    MBFTEVENTHANDLE     EventHandle,
    MBFTFILEHANDLE      hFile,
    ULONG               FileSize,
    ULONG               BytesTransmitted,
    int                 iTransmitStatus,
    T120UserID          iUserID,
    BOOL                bIsBroadcastEvent
)
:
    MBFTMsg(EnumFileTransmitMsg),
    m_EventHandle(EventHandle),
    m_hFile(hFile),
    m_FileSize(FileSize),
    m_BytesTransmitted(BytesTransmitted),
    m_TransmitStatus(iTransmitStatus),
    m_UserID(iUserID),
    m_bIsBroadcastEvent(bIsBroadcastEvent)
{
}

FileErrorMsg::FileErrorMsg
(
    MBFTEVENTHANDLE     EventHandle,
    MBFTFILEHANDLE      hFile,
    int                 iErrorType,
    int                 iErrorCode,
    BOOL                bIsLocalError,
    T120UserID          iUserID,
    BOOL                bIsBroadcastEvent,
	const char*			pFileName,
	ULONG				nFileSize
)
:
    MBFTMsg(EnumFileErrorMsg),
    m_EventHandle(EventHandle),
    m_hFile(hFile),
    m_ErrorCode(iErrorCode),
    m_ErrorType(iErrorType),
    m_bIsLocalError(bIsLocalError),
    m_UserID(iUserID),
    m_bIsBroadcastEvent(bIsBroadcastEvent)
{
		::ZeroMemory(&m_stFileInfo, sizeof(m_stFileInfo));
		if (pFileName)
		{
			::lstrcpyn(m_stFileInfo.szFileName, pFileName, sizeof(m_stFileInfo.szFileName));
			m_stFileInfo.lFileSize = nFileSize;
		}
}

PeerMsg::PeerMsg
(
    T120UserID          NodeID,
    T120UserID          MBFTPeerID,
    BOOL                bIsLocalPeer,
    BOOL                bIsProsharePeer,
    LPCSTR              lpszAppKey,
    BOOL                bPeerAdded,
    T120SessionID       SessionID
)
:
    MBFTMsg(EnumPeerMsg),
    m_NodeID(NodeID),
    m_MBFTPeerID(MBFTPeerID),
    m_bIsProsharePeer(bIsProsharePeer),
    m_bIsLocalPeer(bIsLocalPeer),
    m_MBFTSessionID(SessionID),
    m_bPeerAdded(bPeerAdded)
{
    if(lpszAppKey)
    {
        ::lstrcpynA(m_szAppKey, lpszAppKey, sizeof(m_szAppKey));
    }
    else
    {
        m_szAppKey[0] = '\0';
    }
}


PeerDeletedMsg::~PeerDeletedMsg(void)
{
    delete m_lpPeerData;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftrecv.hpp ===
#ifndef __MBFTRECV_HPP__
#define __MBFTRECV_HPP__


class CMBFTFile;
class MBFTReceiveSubEvent;


class CT120ChannelList : public CList
{
    DEFINE_CLIST_(CT120ChannelList, T120ChannelID)
};

class CRecvSubEventList : public CList
{
    DEFINE_CLIST(CRecvSubEventList, MBFTReceiveSubEvent*)
    MBFTReceiveSubEvent * FindEquiv(MBFTReceiveSubEvent *);
    void Delete(MBFTReceiveSubEvent *);
    void DeleteAll(void);
};

class CChannelUidQueue : public CQueue
{
    DEFINE_CQUEUE_(CChannelUidQueue, UINT_PTR)
    BOOL RemoveByChannelID(T120ChannelID nChannelID);
    UINT_PTR FindByChannelID(T120ChannelID nChannelID);
};

class MBFTPrivateReceive : public MBFTSession
{
public:

    enum  MBFTPrivateReceiveState
    {
        EnumIdleNotInitialized,
        EnumIdleInitialized,
        EnumInitializationFailed,
        EnumWaitJoinControlChannel,
        EnumWaitRequestJoinControl,
        EnumWaitRequestControlConvene,
        EnumWaitRequestDataConvene,
        EnumWaitAdmitControlChannelIndication,
        EnumWaitAdmitDataChannelIndication,
        EnumWaitSendChannelResponsePDU,
        EnumWaitUserConfirmation,
        EnumWaitSendFileAcceptPDU,
        EnumWaitSendFileRejectPDU,
        EnumWaitFileOfferPDU,
        EnumWaitFileStartPDU,
        EnumWaitFileDataPDU,
        EnumWaitSendFileEndAcknowledgePDU,
        EnumWaitSendChannelLeavePDU,
        EnumWaitJoinDataChannel,
        EnumWaitRejoinDataChannel,
        EnumWaitRequestJoinData,
        EnumWaitAdmitControlChannel,
        EnumWaitChannelDisband,
        EnumWaitForTermination
    };

    MBFTPrivateReceive(LPMBFTENGINE, MBFTFILEHANDLE, T120ChannelID chidControl, T120ChannelID chidData);
    ~MBFTPrivateReceive(void);

    BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnMCSChannelAdmitIndication(T120ChannelID, T120UserID uidManager);
    BOOL OnMCSChannelExpelIndication(T120ChannelID, Reason);

    virtual BOOL OnReceivedFileOfferPDU(T120ChannelID, T120Priority, T120UserID uidSender, T120NodeID uidNode, LPFILEOFFERPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileStartPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILESTARTPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileDataPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILEDATAPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileErrorPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILEERRORPDU lpNewPDU, BOOL IsUniformSendData);
    void OnPeerDeletedNotification(CPeerData * lpPeerData);
    void OnControlNotification(MBFTFILEHANDLE hFile, FileTransferControlMsg::FileTransferControl iControlCommand, LPCSTR lpszDirectory, LPCSTR lpszFileName);
    void DoStateMachine(void);
    void UnInitialize(BOOL bIsShutDown = FALSE);


protected:

    T120UserID              m_LocalMBFTUserID;
    T120ChannelID           m_PrivateMBFTControlChannel;
	CT120ChannelList        m_PrivateMBFTDataChannelList;
    T120ChannelID           m_PrivateMBFTDataChannel;
    T120UserID              m_MBFTControlSenderID;
    T120UserID              m_MBFTDataSenderID;
    T120UserID              m_ProshareSenderID;
    MBFTFILEHANDLE          m_CurrentAcceptHandle; // ???
    MBFTFILEHANDLE          m_CurrentRejectHandle; // ???
    MBFTFILEHANDLE          m_CurrentFileEndHandle;

    MBFTPrivateReceiveState m_State;
    MBFTPrivateReceiveState m_PreviousRejectState;
    BOOL                    m_bProshareTransfer;
    CRecvSubEventList       m_ReceiveList;
    MBFTReceiveSubEvent    *m_CurrentReceiveEvent;
    BOOL                    m_JoinedToDataChannel;
    BOOL                    m_bOKToLeaveDataChannel;
    BOOL                    m_bEventEndPosted;
    CChannelUidQueue        m_AdmittedChannelQueue;

    void JoinControlChannel(void);
    void JoinDataChannel(void);
    void LeaveDataChannel(void);

    void SendChannelResponsePDU(void);
    BOOL SendFileAcceptPDU(MBFTFILEHANDLE iFileHandle = 0);
    void SendFileRejectPDU(MBFTFILEHANDLE iFileHandle = 0);
    void SendFileEndAcknowledgePDU(MBFTFILEHANDLE iFileHandle = 0);
    void SendChannelLeavePDU(void);

    void DeleteReceiveEvent(MBFTReceiveSubEvent * lpReceive,BOOL bNotifyUser);
    void TerminateReceiveSession(void);

    void ReportError(MBFTReceiveSubEvent * lpReceiveEvent,
                     int iErrorType,
                     int iErrorCode,
                     BOOL bIsLocalError = TRUE,
                     T120UserID SenderID    = 0,
					 const char* pFileName = NULL,
					 ULONG lFileSize = 0);

    void ReportReceiverError(MBFTReceiveSubEvent * lpReceiveEvent,
                             int iErrorType,
                             int iErrorCode,
                             MBFTFILEHANDLE iFileHandle = 0);

    void DeleteNotificationMessages(MBFT_NOTIFICATION iNotificationType);

    int DecompressAndWrite(MBFTReceiveSubEvent * lpReceiveEvent,
                           LPCSTR lpBuffer,LONG BufferLength,LPINT lpDecompressedSize);
};


#ifdef USE_BROADCAST_RECEIVE
class MBFTBroadcastReceive : public MBFTPrivateReceive
{
private:

    T120UserID        m_SenderID;
    MBFTFILEHANDLE    m_FileHandle;

public:

    MBFTBroadcastReceive(LPMBFTENGINE lpParentEngine,
                         MBFTEVENTHANDLE EventHandle,
                         T120ChannelID wControlChannel,
                         T120ChannelID wDataChannel,
                         T120UserID SenderID,
                         MBFTFILEHANDLE FileHandle);

    BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnReceivedFileOfferPDU(T120ChannelID, T120Priority, T120UserID uidSender, T120NodeID uidNode, LPFILEOFFERPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileStartPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILESTARTPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileDataPDU(T120ChannelID, T120Priority, T120UserID, LPFILEDATAPDU lpNewPDU, BOOL IsUniformSendData);
    void OnControlNotification(MBFTFILEHANDLE hFile, FileTransferControlMsg::FileTransferControl iControlCommand, LPCSTR lpszDirectory, LPCSTR lpszFileName);
    void OnPeerDeletedNotification(CPeerData * lpPeerData);
    void DoStateMachine(void);
    void UnInitialize(BOOL bIsShutDown = FALSE);
};

#endif	// USE_BROADCAST_RECEIVE

typedef class MBFTPrivateReceive FAR * LPMBFTPRIVATESUBSESSIONRECEIVE;

class MBFTReceiveSubEvent
{
private:

    friend class MBFTPrivateReceive;
#ifdef USE_BROADCAST_RECEIVE
    friend class MBFTBroadcastReceive;
#endif	// USE_BROADCAST_RECEIVE

    MBFTPrivateReceive::MBFTPrivateReceiveState  m_State;

    BOOL            m_bIsBroadcast;
    MBFTFILEHANDLE  m_hFile;
    ULONG           m_FileSize;
    ULONG           m_TotalBytesReceived;
    ULONG           m_cbRecvLastNotify;
    T120UserID      m_SenderID;
    CMBFTFile      *m_lpFile;
    BOOL            m_UserAccepted;
    BOOL            m_bFileCompressed;
    BOOL            m_bEOFAcknowledge;
    time_t          m_FileDateTime;
    LPVOID          m_lpV42bisPointer;
    char            m_szFileName[_MAX_FNAME];
    char            m_szFileDirectory[_MAX_PATH];

public:

    MBFTReceiveSubEvent(MBFTFILEHANDLE FileHandle,
                        LONG FileSize,
                        LPCSTR lpszFileName,
                        time_t FileDateTime,
                        T120UserID SenderID,
                        BOOL bIsBroadcast,
                        BOOL bIsCompressed,
                        BOOL bEOFAcknowledge);
    ~MBFTReceiveSubEvent(void);

    BOOL Init(void);
    BOOL IsEqual(MBFTReceiveSubEvent *lpObject);
    void InitV42DeCompression(int v42bisP1,int v42bisP2);
};


#endif      //__MBFTRECV_HPP__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ms_util.cpp ===
#include "mbftpch.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        delete this;
        return 0;
    }
    return m_cRefs;
}


void CRefCount::ReleaseNow(void)
{
    m_cRefs = 0;
    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftsend.cpp ===
/* file: mbftsend.cpp */

#include "mbftpch.h"

#include "mbftsend.hpp"
#include "fileio.hpp"
#include "messages.hpp"
#include "mbftapi.hpp"

#define     _MAX_SEND_PACKETS           1

ULONG g_nSendDisbandDelay = 5000; // Previous: Twenty seconds!
ULONG g_nChannelResponseDelay = 60000;


MBFTPrivateSend::MBFTPrivateSend
(
    LPMBFTENGINE        lpParentEngine,
    MBFTEVENTHANDLE     EventHandle,
	T120ChannelID       wMBFTUserID,
    ULONG               MaxDataLength
)
:  
	MBFTSession(lpParentEngine, EventHandle, MBFT_PRIVATE_SEND_TYPE),
    m_PrivateMBFTControlChannel(0),
    m_PrivateMBFTDataChannel(0),    

    m_lpUserArray(NULL),
    m_lpAcceptedUsersArray(NULL),

    m_iUserCount(0),

    m_MBFTChannelID(wMBFTUserID),
    m_MaxDataLength(MaxDataLength),

    m_LastUserCount(0),
    m_ResponseCount(0),
    m_AcceptCount(0),
    m_RejectCount(0),
    m_AbortedCount(0),
    m_AcknowledgeCount(0),

    m_CurrentFileSize(0),
    m_lTotalBytesRead(0),
    m_lpDataBuffer(NULL),

    m_bProshareTransfer(FALSE),
    m_bEOFAcknowledge(FALSE), 

    m_lpFile(NULL),
    m_pszCurrentFilePath(NULL),
    m_CurrentFileHandle(0),
    m_AcceptedIndex(0),
    
    m_bSentFileOfferPDU(FALSE),
    m_bUnInitializing(FALSE),   
    m_bAbortAllFiles(FALSE),
    m_bSendingFile(FALSE),
    m_bAbortFileSend(FALSE),
    m_SentFileStartPDU(FALSE),
    m_TimeOutValue(0),
    m_bCompressFiles(FALSE),
    m_bOKToDisbandChannel(TRUE),

    m_lpV42bisPointer(NULL),
    m_bFlushv42Compression(FALSE),
    m_bEventEndPosted(FALSE),

    m_State(EnumIdleNotInitialized)
{
}

MBFTPrivateSend::~MBFTPrivateSend(void)
{
    delete m_pszCurrentFilePath;
    delete m_lpUserArray;
    delete m_lpAcceptedUsersArray;
    delete m_lpDataBuffer;
    delete m_lpFile;
}

void MBFTPrivateSend::ConveneControlChannel(void)    
{
    if(m_lpParentEngine->MCSChannelConveneRequest())
    {
        m_State = EnumWaitConveneControlChannel;        
    }
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}

void MBFTPrivateSend::ConveneDataChannel(void)    
{
    if(m_lpParentEngine->MCSChannelConveneRequest())
    {
        m_State = EnumWaitConveneDataChannel;        
    }        
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}

void MBFTPrivateSend::JoinControlChannel(void)
{
    if(m_lpParentEngine->MCSChannelJoinRequest(m_PrivateMBFTControlChannel))
    {
        m_State = EnumWaitJoinControlChannel;                
    }                
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}
    
BOOL MBFTPrivateSend::OnMCSChannelJoinConfirm
(
    T120ChannelID           wChannelId,
    BOOL                    bSuccess
)
{
    BOOL bReturn = FALSE;
 
    if(wChannelId == m_PrivateMBFTControlChannel)
    {
        if(m_State == EnumWaitJoinControlChannel)
        {
            if(bSuccess)
            {
                TRACESEND(" Control channel joined [%u]\n",wChannelId);

                ConveneDataChannel();
            }
            else
            {
                ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
                UnInitialize();
            }

            bReturn = TRUE;        
        }
    }

    return(bReturn);
}

void MBFTPrivateSend::AdmitControlChannel(void)
{
   if(m_lpParentEngine->MCSChannelAdmitRequest(m_PrivateMBFTControlChannel,
                                              m_lpUserArray,
                                              m_iUserCount))
    {
        TRACESEND(" Admit Control Channel Successful [%u]\n",m_PrivateMBFTControlChannel);
    }                                                      
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }

    if(m_lpParentEngine->MCSChannelAdmitRequest(m_PrivateMBFTDataChannel,
                                                m_lpUserArray,
                                                m_iUserCount))
    {
        TRACESEND(" Admit Data Channel Successful [%u]\n",m_PrivateMBFTDataChannel);            

        m_State = EnumWaitChannelResponsePDU;

        m_TimeOutValue  = GetTickCount() + g_nChannelResponseDelay;
    }                                                      
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}

BOOL MBFTPrivateSend::OnMCSChannelConveneConfirm
(
    T120ChannelID       wChannelId,
    BOOL                bSuccess
)
{
    BOOL bReturn = FALSE;    

    if(m_State == EnumWaitConveneControlChannel)
    {
        if(bSuccess)
        {
            TRACESEND(" Control channel convened [%u]\n",wChannelId);
            m_PrivateMBFTControlChannel = wChannelId;
            JoinControlChannel();
        }
        else
        {
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
            UnInitialize();
        }        

        bReturn = TRUE;
    }
    else if(m_State == EnumWaitConveneDataChannel)        
    {
        if(bSuccess)
        {                               
            TRACESEND(" Data channel convened [%u]\n",wChannelId);
            m_PrivateMBFTDataChannel = wChannelId;
            m_State = EnumWaitSendChannelInvitePDU;
        }
        else
        {
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
            UnInitialize();
        }

        bReturn = TRUE;
    }

    return(bReturn);
}

BOOL MBFTPrivateSend::SubmitFileSendRequest
(
    SubmitFileSendMsg       *pMsg
)
{
    BOOL bCompressFiles = pMsg->m_bCompressFiles;

    delete m_pszCurrentFilePath; // clean up any possible left over
    m_pszCurrentFilePath = pMsg->m_pszFilePath;
    m_CurrentFileHandle = pMsg->m_nFileHandle;
    pMsg->m_pszFilePath = NULL; // keep this pointer for furure use

    MBFT_ERROR_CODE iErrorCode = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_PERMANENT_ERROR;

	//NOTE: Merely turning this flag to TRUE will NOT
	//enable compression.  I have set it to FALSE here
	//so that certain stubbed routines will not be
	//entered.  If you turn this flag to TRUE....
	//then...have your finger ready on the reset button!!
	//If you want to turn compression on, Then you have
	//to include a bunch of v42.bis compression files etc.
	bCompressFiles = FALSE;

    // get the peer list
    CPeerList *pPeerList = m_lpParentEngine->GetPeerList();

	ASSERT(! (pMsg->m_nUserID && pMsg->m_nNodeID));
    BOOL fBroadcast = (0 == pMsg->m_nUserID && 0 == pMsg->m_nNodeID);
    ULONG iNumNodes = 1;
    if (fBroadcast)
    {
        iNumNodes = pPeerList->GetCount();
        ASSERT(iNumNodes);
    }

    DBG_SAVE_FILE_LINE
	m_lpDataBuffer          =   new char[m_MaxDataLength + MAX_PATH + _iMBFT_FILEDATA_PDU_SUBTRACT]; // enough space for the largest PDU
    DBG_SAVE_FILE_LINE
    m_lpUserArray           =   new UserID[iNumNodes];
    DBG_SAVE_FILE_LINE
    m_lpAcceptedUsersArray  =   new UserID[iNumNodes];

    if (NULL == m_lpDataBuffer || NULL == m_lpUserArray || NULL == m_lpAcceptedUsersArray)
    {
        ERROR_OUT(("MBFTPrivateSend::SubmitFileSendRequest: allocation failure"));
        delete m_lpDataBuffer;          m_lpDataBuffer = NULL;
        delete m_lpUserArray;           m_lpUserArray = NULL;
        delete m_lpAcceptedUsersArray;  m_lpAcceptedUsersArray = NULL;
        iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
    }    

    if(iErrorCode == iMBFT_OK)
    {
        m_iUserCount    = 0;

        ZeroMemory(m_lpUserArray, sizeof(UserID) * iNumNodes);
        ZeroMemory(m_lpAcceptedUsersArray, sizeof(UserID) * iNumNodes);

        m_bProshareTransfer =  TRUE;
        m_bEOFAcknowledge   =  TRUE; 
        if (fBroadcast)
        {
            CPeerData *lpPeer;
            pPeerList->Reset();
            while (NULL != (lpPeer = pPeerList->Iterate()))
            {
                if (lpPeer->GetUserID() != m_lpParentEngine->GetUserID())
                {
                    m_lpUserArray[m_iUserCount++] = lpPeer->GetUserID();

                    if(m_bProshareTransfer)
                    {
                        m_bProshareTransfer = lpPeer->GetIsProshareNode();  
                    }
                    if(m_bEOFAcknowledge)
                    {                                                            
                        m_bEOFAcknowledge  =  lpPeer->GetEOFAcknowledge();
                    }
                }
            } // while
        }
        else
        {
            CPeerData *lpPeer;
            pPeerList->Reset();
            while (NULL != (lpPeer = pPeerList->Iterate()))
            {
                if ((pMsg->m_nUserID && pMsg->m_nUserID == lpPeer->GetUserID())
					||
					(pMsg->m_nNodeID && pMsg->m_nNodeID == lpPeer->GetNodeID()))
                {
                    m_lpUserArray[m_iUserCount++] = lpPeer->GetUserID();

                    if(m_bProshareTransfer)
                    {
                        m_bProshareTransfer = lpPeer->GetIsProshareNode();  
                    }
                    if(m_bEOFAcknowledge)
                    {                                                            
                        m_bEOFAcknowledge  =  lpPeer->GetEOFAcknowledge();
                    }
                    break;
                }
            } // while
            if (NULL == lpPeer)
            {
                iErrorCode = iMBFT_RECIPIENT_NOT_FOUND;
            }
        }

        if(m_bCompressFiles)
        {
			iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
        }            
        else
        {
            DBG_SAVE_FILE_LINE
            m_lpFile  =   new CMBFTFile;
        }

        if(!m_lpFile)
        {
            iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;    
        }

        if(iErrorCode == iMBFT_OK)
        { 
            m_State = EnumFileSendPending;
        }
    }

    if(iErrorCode != iMBFT_OK)    
    {
//        LOGERROR(iErrorCode,0,0);
            
        ReportError(iErrorType,iErrorCode,TRUE);
        TerminateSendSession();
    }

    return(iErrorCode == iMBFT_OK);    
}

void MBFTPrivateSend::ReportSenderError
(
    int             iErrorType,
    int             iErrorCode,
    MBFTFILEHANDLE  hFile
)
{
    DBG_SAVE_FILE_LINE
    FileErrorPDU * lpNewPDU = new FileErrorPDU((hFile) ?
                                               LOWORD(hFile) :  
                                               LOWORD(m_CurrentFileHandle),
                                               iErrorType,iErrorCode); 
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            for (ULONG Index = 0; Index < m_iUserCount; Index++)
            {
                m_lpParentEngine->SendDataRequest(m_lpUserArray[Index],
                                                  APPLET_HIGH_PRIORITY,
                                                  (LPBYTE)lpNewPDU->GetBuffer(),
                                                  lpNewPDU->GetBufferLength());       
            }
        }

        delete  lpNewPDU;
    }
}

void MBFTPrivateSend::ReportError
(
    int                 iErrorType,
    int                 iErrorCode,
    BOOL                bIsLocalError,
    T120UserID          SenderID,
    MBFTFILEHANDLE      FileHandle)
{
	T120UserID id = SenderID ? SenderID : m_MBFTChannelID;

    DBG_SAVE_FILE_LINE
	m_lpParentEngine->SafePostNotifyMessage(
	                    new FileErrorMsg(
                        		m_EventHandle,
                        		FileHandle ? FileHandle : m_CurrentFileHandle, 
                        		iErrorType,
                        		iErrorCode,
                        		bIsLocalError,
                        		id));
}

void MBFTPrivateSend::TerminateSendSession(void)
{
	UnInitialize();
}
        
       
void MBFTPrivateSend::UnInitialize
(
    BOOL        bShutDown
)
{
    BOOL bDataChannelDisbanded      =   FALSE;
    BOOL bControlChannelDisbanded   =   FALSE;

    if(m_State  !=  EnumWaitForTermination)
    {
        m_State = EnumWaitForTermination;

        TRACESEND(" Uninit begin\n");

		if (m_bEOFAcknowledge)
		{
			m_TimeOutValue = 0;
		}
		else
		{
			m_TimeOutValue = GetTickCount() + g_nSendDisbandDelay;
		}
		TRACESEND(" Using TimeOutValue of %d\n", m_TimeOutValue);
    }

    m_bUnInitializing = TRUE;

    if(GetTickCount() >= m_TimeOutValue)
    {
        if(m_PrivateMBFTDataChannel)
        {
            if(m_lpParentEngine->MCSChannelDisbandRequest(m_PrivateMBFTDataChannel))
            {
                TRACESEND(" Uninit: Data Channel disbanded [%u]\n",m_PrivateMBFTDataChannel);
                bDataChannelDisbanded       =   TRUE;
                m_PrivateMBFTDataChannel    =   0;
            }   
            else if(m_lpParentEngine->GetLastSendDataError() ==  MCS_TRANSMIT_BUFFER_FULL)
            {
                TRACESEND("Transmit buffer for [%u] full, data channel disband failed\n",m_PrivateMBFTDataChannel);    
            }
            else
            {
                TRACESEND("Unexpected error [%u] while disbanding data channel [%u]\n",
                           m_lpParentEngine->GetLastSendDataError(),m_PrivateMBFTDataChannel);    
            }
        }
        else
        {
            bDataChannelDisbanded   =   TRUE;
        }

        if(bDataChannelDisbanded)
        {
            if(m_PrivateMBFTControlChannel)
            {
                if(m_lpParentEngine->MCSChannelDisbandRequest(m_PrivateMBFTControlChannel))
                {
                    TRACESEND(" Uninit: Control Channel disbanded [%u]\n",m_PrivateMBFTControlChannel);
                    bControlChannelDisbanded        =   TRUE;
                    m_PrivateMBFTControlChannel     =   0;
                }
                else if(m_lpParentEngine->GetLastSendDataError() ==  MCS_TRANSMIT_BUFFER_FULL)
                {
                    TRACESEND("Transmit buffer for [%u] full, control channel disband failed\n",m_PrivateMBFTDataChannel);    
                }
                else
                {
                    TRACESEND("Unexpected error [%u] while disbanding control channel [%u]\n",
                               m_lpParentEngine->GetLastSendDataError(),m_PrivateMBFTDataChannel);    
                }
            }
            else
            {
                bControlChannelDisbanded    =   TRUE;
            }
        }

        if(!bShutDown)
        {
            if(bDataChannelDisbanded && bControlChannelDisbanded)
            {
                DBG_SAVE_FILE_LINE
                m_lpParentEngine->SafePostMessage(new DeleteSessionMsg(this));

                if(!m_bEventEndPosted)
                {        
                    DBG_SAVE_FILE_LINE
                    m_lpParentEngine->SafePostNotifyMessage(new FileEventEndNotifyMsg(m_EventHandle));
                    m_bEventEndPosted   =   TRUE;
                }
                TRACESEND(" Uninit complete\n");                
            }
        }
        else
        {
            TRACESEND(" Uninit complete\n");
        }
    }
}    

void MBFTPrivateSend::SendChannelInvitePDU(void)
{
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_PERMANENT_ERROR;

    DBG_SAVE_FILE_LINE
    LPPRIVATECHANNELINVITEPDU lpNewPDU = new PrivateChannelInvitePDU(m_PrivateMBFTControlChannel,
                                                                     m_PrivateMBFTDataChannel,
                                                                     FALSE);
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            for (ULONG Index = m_LastUserCount;Index < m_iUserCount;Index++)
            {
                if(m_lpParentEngine->SendDataRequest(m_lpUserArray[Index],
                                                     APPLET_HIGH_PRIORITY,
                                                     (LPBYTE)lpNewPDU->GetBuffer(),
                                                     lpNewPDU->GetBufferLength()))       
                {
                    TRACESEND(" Sent Channel invite PDU, Control Channel [%u], Data Channel [%u] to [%u]\n",m_PrivateMBFTControlChannel,m_PrivateMBFTDataChannel,m_lpUserArray[Index]);
                              
                    m_LastUserCount++; 
                }                                                             
                else
                {
                    m_State = EnumWaitSendChannelInvitePDU;    
                    break;
                }
            }    

            if(Index >= m_iUserCount)
            {
                AdmitControlChannel();
            }
        }
        else
        {
            iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
        }

        delete lpNewPDU;
    }
    else
    {
        iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
    }

    if(iErrorCode != iMBFT_OK)
    {
        ReportError(iErrorType,iErrorCode,TRUE);    
        UnInitialize();
    }
    
}
    
BOOL MBFTPrivateSend::OnReceivedFileAbortPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEABORTPDU          lpFileAbortPDU, 
    BOOL                    IsUniformSendData
)
{
    MBFTFILEHANDLE hFile = lpFileAbortPDU->GetFileHandle();

    if (hFile && hFile == m_CurrentFileHandle)
    {
        if (m_bUnInitializing)
        {
            OnControlNotification(hFile,
                                  FileTransferControlMsg::EnumConductorAbortFile,
                                  NULL,
                                  NULL);  
        }
        return TRUE; // handled
    }

    return FALSE; // not handled
}                                                                                                                                                                       
                                       

void MBFTPrivateSend::DoStateMachine(void)
{
    if(m_State == EnumFileSendPending)
    {
        ConveneControlChannel();    
    }
    else if(m_State == EnumWaitRequestControlConvene)
    {
        ConveneControlChannel();    
    }
    else if(m_State == EnumWaitRequestJoinControl)
    {
        JoinControlChannel();
    }
    else if(m_State == EnumWaitRequestDataConvene)
    {
        ConveneDataChannel();    
    }
    else if(m_State == EnumWaitSendChannelInvitePDU)
    {
        SendChannelInvitePDU();    
    }
    else if(m_State == EnumSendNonStandardPDU)
    {
	    TRACESEND(" Not Sending a NonStandardPDU");
	    m_State = EnumSendFileOfferPDU;
        SendFileOfferPDU();
    }
    else if(m_State == EnumSendFileOfferPDU)
    {
        SendFileOfferPDU();
    }
    else if(m_State == EnumSendFileStartPDU)
    {
        SendFileStartPDU();        
    }
    else if(m_State == EnumSendFileDataPDU)
    {
        SendFileDataPDU();
    }
    else if(m_State == EnumTerminateCurrentSend)                
    {
        TerminateCurrentSend();
    }
    else if(m_State == EnumWaitForTermination)
    {
		UnInitialize();
    }
    else if(m_State == EnumWaitChannelResponsePDU)
    {
        if(GetTickCount() >= m_TimeOutValue)
        {
//            LOGERROR(iMBFT_TIMEOUT_ERROR,0,0);
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_TIMEOUT_ERROR,TRUE);
            UnInitialize();                
        }
    }

    return;
}                                                                                                                                                                                             
BOOL MBFTPrivateSend::OnReceivedPrivateChannelResponsePDU
(
    T120ChannelID               wChannelId,
    T120Priority                iPriority,
    T120UserID                  SenderID,
    LPPRIVATECHANNELRESPONSEPDU lpNewPDU,
    BOOL                        IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitChannelResponsePDU)
    {
        if(wChannelId == m_MBFTChannelID && 
           lpNewPDU->GetControlChannel() == m_PrivateMBFTControlChannel)
        {
            bReturn = TRUE;

            TRACESEND(" Received Channel response PDU from [%u]\n",SenderID); 

            for (ULONG Index = 0; Index < m_iUserCount; Index++)
            {    
                if(m_lpUserArray[Index] == SenderID)
                {
                    m_ResponseCount++;
                }
            }

            if(!lpNewPDU->GetWasChannelJoined())
            {
                ReportError(MBFT_INFORMATIVE_ERROR,
                            iMBFT_RECEIVER_ABORTED,
                            FALSE,
                            SenderID, 
                            _iMBFT_PROSHARE_ALL_FILES);

                RemoveUserFromList(SenderID);
            }

            if(m_iUserCount)
            {
                if(m_ResponseCount >= m_iUserCount)
                {
                    m_State = (! m_bProshareTransfer) ? EnumSendFileOfferPDU :   
                                                        EnumSendNonStandardPDU;
                }
            }
        }
    }

    return(bReturn);
}

void MBFTPrivateSend::SendFileOfferPDU(void)
{
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

    m_AcceptCount       = 0;
    m_RejectCount       = 0;
    m_ResponseCount     = 0;
    m_AcknowledgeCount  = 0;
    m_lTotalBytesRead   = 0;
    m_SentFileStartPDU  = FALSE;
    m_AbortedCount      = 0;
    m_bSentFileOfferPDU = FALSE;
    m_AcceptedIndex     = 0;

    ::ZeroMemory(m_lpAcceptedUsersArray, sizeof(UserID) * m_iUserCount);

    if (m_lpFile->Open(m_pszCurrentFilePath, CMBFTFile::OpenReadOnly | CMBFTFile::OpenBinary))
    {
        m_CurrentFileSize   = m_lpFile->GetFileSize();
        m_CurrentDateTime   = m_lpFile->GetFileDateTime();

        DBG_SAVE_FILE_LINE
        LPFILEOFFERPDU lpNewPDU = new FileOfferPDU(GetFileNameFromPath(m_pszCurrentFilePath),
                                                   LOWORD(m_CurrentFileHandle),
                                                   m_CurrentFileSize,
                                                   m_CurrentDateTime,
                                                   m_PrivateMBFTDataChannel,TRUE,
                                                   m_lpParentEngine->GetRosterInstance(),
                                                   0, NULL, 0, 0);
        if(lpNewPDU)
        {
            if(lpNewPDU->Encode())
            {
                if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTControlChannel,
                                                     APPLET_HIGH_PRIORITY,
                                                     (LPBYTE)lpNewPDU->GetBuffer(),
                                                     lpNewPDU->GetBufferLength()))
                {
                    TRACESEND(" Transmitted File Offer PDU for [%u] on [%u]\n",LOWORD(m_CurrentFileHandle),m_PrivateMBFTControlChannel);

                    //Now that we have sent a FileOfferPDU, we can't disband the channel
                    //without notice....

                    m_bOKToDisbandChannel   = FALSE;

                    m_bSentFileOfferPDU     = TRUE;
                    m_State = EnumWaitFileAcceptPDU;
                }
            }
            else
            {
                iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
            }

            delete lpNewPDU;
        }                                
        else
        {
             iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
        }
    }
    else
    {
        iErrorCode = (MBFT_ERROR_CODE)m_lpFile->GetLastErrorCode();

        //iMBFT_FILE_IO_ERROR;
    }

    if(iErrorCode != iMBFT_OK)
    {
        ReportError(iErrorType,iErrorCode,TRUE);

        if(m_bSentFileOfferPDU)
        {
            //If a FileOffer has been sent out, we need to send a FileStartPDU with 
            //EOF = TRUE...

            TerminateCurrentSend();
        }            
        else
        {
            ReportError(MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,TRUE,
                        m_MBFTChannelID,m_CurrentFileHandle);    

            SendNextFile();
        }
    }
}

BOOL MBFTPrivateSend::OnReceivedFileAcceptPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEACCEPTPDU         lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitFileAcceptPDU)
    {
        if(wChannelId == m_MBFTChannelID)
        {
            if(lpNewPDU->GetFileHandle() == m_CurrentFileHandle)
            {
                TRACESEND(" Received file accept PDU from [%u] for [%u]\n",SenderID,lpNewPDU->GetFileHandle());

                bReturn = TRUE;

                for (ULONG Index = 0; Index < m_iUserCount; Index++)
                {    
                    if(m_lpUserArray[Index] == SenderID)
                    {
                        if(m_AcceptedIndex < m_iUserCount)
                        {
                            m_lpAcceptedUsersArray[m_AcceptedIndex++] = SenderID;
                        }

                        m_AcceptCount++;
                        m_ResponseCount++;
                    }
                }

                if(m_ResponseCount >= m_iUserCount)
                {
                    m_State = EnumSendFileStartPDU;
                }                
            }
        }
    }

    return(bReturn);
}
                             
BOOL MBFTPrivateSend::OnReceivedFileRejectPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEREJECTPDU         lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitFileAcceptPDU)
    {
        if(wChannelId == m_MBFTChannelID)
        {
            MBFTFILEHANDLE iFileHandle = lpNewPDU->GetFileHandle();

            if((iFileHandle == m_CurrentFileHandle) ||
               ((iFileHandle == LOWORD(_iMBFT_PROSHARE_ALL_FILES)) && m_bProshareTransfer))
            {
                TRACESEND(" Received file reject PDU from [%u] for [%u]\n",SenderID,lpNewPDU->GetFileHandle());

                for(ULONG Index = 0;Index < m_iUserCount;Index++)
                {    
                    if(m_lpUserArray[Index] == SenderID)
                    {
                        bReturn = TRUE;
                    }                        
                }

                if(bReturn)
                {                                
                    if(iFileHandle == m_CurrentFileHandle)
                    {
                      m_RejectCount++;
                      m_ResponseCount++;
                      
                    }                  
                    else if((iFileHandle == LOWORD(_iMBFT_PROSHARE_ALL_FILES)) && m_bProshareTransfer)
                    {

                        RemoveUserFromList(SenderID);
                    }

                    if(m_iUserCount)
                    {
                        if(m_ResponseCount >= m_iUserCount)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                m_lpFile->Close();
                                SendNextFile();                                         
                            }                        
                        }                
                    }
                }   //if bReturn
            }
        }   //wChannelId == m_MBFTChannelID
    }       //m_State == EnumWaitFileAcceptPDU

    return(bReturn);    
}

BOOL MBFTPrivateSend::OnReceivedFileErrorPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEERRORPDU          lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;
    MBFTFILEHANDLE FileHandle = lpNewPDU->GetFileHandle();

    if ((m_CurrentFileHandle == FileHandle) ||
        (m_bProshareTransfer && (LOWORD(FileHandle) == LOWORD(_iMBFT_PROSHARE_ALL_FILES))))
    {
        TRACERECEIVE(" FileErrorPDU from [%u] for [%u], ErrorCode: [%u]\n",SenderID,lpNewPDU->GetFileHandle(),lpNewPDU->GetErrorCode());

        if(m_bProshareTransfer)
        {
            if(m_State != EnumWaitForTermination)
            {
                if(lpNewPDU->GetErrorCode() == iMBFT_RECEIVER_ABORTED && 
                   lpNewPDU->GetFileHandle() == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
                {
                    m_AbortedCount++;

                    RemoveUserFromList(SenderID);

                    //If the state is EnumWaitFileAcceptPDU, we don't
                    //have an exact count of the number of recipients who accepted
                    //the file. Therefore, we cannot make a decision on whether or not
                    //to abort the file based on AcceptCount and AbortedCount....

                    if(m_State != EnumWaitFileAcceptPDU)
                    {
                        if(m_iUserCount)
                        {
                            if(m_AbortedCount >= m_AcceptCount)
                            {
		                        m_lpFile->Close();
                                SendNextFile();
                            }
		                }
                        else
                        {
                            m_lpFile->Close();
                        }
                    }
                    else if(m_iUserCount)
                    {
                        //In this case, the FileErrorPDU acts as a FileRejectPDU...

                        TRACERECEIVE(" Treating FileErrorPDU for [%u] as FileRejectPDU\n",lpNewPDU->GetFileHandle());

                        //m_RejectCount++;
                        //m_ResponseCount++;

                        //In this case, response count has to be greater 
                        //because a user was just deleted!!!

                        if(m_ResponseCount >= m_iUserCount)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                SendNextFile();                                         
                            }                        
                        }                
                    }
                }
                else if (FileHandle == m_CurrentFileHandle)
                {
                    m_AbortedCount++;

                    //If the state is EnumWaitFileAcceptPDU, we don't
                    //have an exact count of the number of recipients who accepted
                    //the file. Therefore, we cannot make a decision on whether or not
                    //to abort the file based on AcceptCount and AbortedCount....

                    if(m_State != EnumWaitFileAcceptPDU)
                    {
                        if(m_AbortedCount >= m_AcceptCount)
                        {
                            m_lpFile->Close();
                            SendNextFile();
                        }
                    }
                    else
                    {
                        //In this case, the FileErrorPDU acts as a FileRejectPDU...
                        TRACERECEIVE(" Treating FileErrorPDU for [%u] as FileRejectPDU\n",lpNewPDU->GetFileHandle());

                        m_RejectCount++;
                        m_ResponseCount++;

                        if(m_ResponseCount >= m_iUserCount)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                SendNextFile();                                         
                            }                        
                        }                
                    }
                }
            }   //EnumWaitForTermination
        }       //IsProshare
    }

    return(bReturn);
}

BOOL MBFTPrivateSend::OnReceivedNonStandardPDU
(
    T120ChannelID           wChannelID,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPNONSTANDARDPDU        lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State != EnumWaitForTermination)
    {
        if(wChannelID == m_PrivateMBFTControlChannel)
        {
            if (! ::lstrcmpA(lpNewPDU->GetKey(), PROSHARE_FILE_END_STRING)) 
            {    
                TRACESEND(" Received Non Standard PDU (File End Acknowledge) from  [%u]\n",SenderID);
                FileEndAcknowledgeStruct  * lpStruct  =   (FileEndAcknowledgeStruct *)lpNewPDU->GetDataBuffer();

                DBG_SAVE_FILE_LINE
				LPFILEENDACKNOWLEDGEPDU lpNewPDU = new FileEndAcknowledgePDU(lpStruct->m_FileHandle);
				if (NULL != lpNewPDU)
				{
                    bReturn = OnReceivedFileEndAcknowledgePDU(wChannelID,
                                                          iPriority,
                                                           SenderID,
                                                           lpNewPDU,
                                                           IsUniformSendData);
				    delete lpNewPDU;
				}
            }
            else if (! ::lstrcmpA(lpNewPDU->GetKey(), PROSHARE_CHANNEL_LEAVE_STRING))
            {
                TRACESEND(" Received Non Standard PDU (Channel Leave) from  [%u]\n",SenderID);

                ChannelLeaveStruct * lpStruct = (ChannelLeaveStruct *)lpNewPDU->GetDataBuffer();

                DBG_SAVE_FILE_LINE
                LPCHANNELLEAVEPDU lpNewPDU = new ChannelLeavePDU(lpStruct->m_ChannelID,lpStruct->m_ErrorCode);
				if (NULL != lpNewPDU)
				{
                    bReturn = OnReceivedChannelLeavePDU(wChannelID,
                                                    iPriority,
                                                    SenderID,
                                                    lpNewPDU,
                                                    IsUniformSendData);
                    delete lpNewPDU;
                }
            }
            else
            {
                TRACE("*** Unknown Non Standard PDU received on [%u] *** \n",wChannelID);
            }
        }
    }

    return(bReturn);
}

BOOL MBFTPrivateSend::OnReceivedFileEndAcknowledgePDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEENDACKNOWLEDGEPDU lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL  bReturn   =   FALSE;

    if(m_State == EnumWaitFileEndAcknowledgePDU)
    {
        if(wChannelId == m_PrivateMBFTControlChannel)
        {
            if(lpNewPDU->GetFileHandle() == m_CurrentFileHandle)
            {
                TRACESEND(" Received file end acknowledge PDU from [%u] for [%u]\n",SenderID,lpNewPDU->GetFileHandle());

                bReturn = TRUE;

                for (ULONG Index = 0; Index < m_AcceptedIndex; Index++)
                {    
                    if(m_lpAcceptedUsersArray[Index] == SenderID)
                    {
                        m_AcknowledgeCount++;
                    }
                }

                if(m_AcknowledgeCount >= m_AcceptCount)
                {
                    SendNextFile();
                }                
            }
        }
    }

    return(bReturn);
}                                    
    
BOOL MBFTPrivateSend::OnReceivedChannelLeavePDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPCHANNELLEAVEPDU       lpNewPDU,
    BOOL                    IsUniformSendData
)
{               
    BOOL  bReturn  =  FALSE;

    if(m_State == EnumSendFileStartPDU || m_State == EnumSendFileDataPDU ||
       m_State == EnumWaitFileEndAcknowledgePDU)
    {
        if(lpNewPDU->GetChannelID() == m_PrivateMBFTDataChannel)
        {
            bReturn     =   TRUE;

            TRACESEND(" Received Channel Leave PDU from [%u] for [%u], CurrentFile [%u]\n",
                      SenderID,lpNewPDU->GetChannelID(),m_CurrentFileHandle);

            for (ULONG Index = 0; Index < m_AcceptedIndex; Index++)
            {    
                if(m_lpAcceptedUsersArray[Index] == SenderID)
                {
                    m_AcknowledgeCount++;
                }
            }

            if(m_State == EnumWaitFileEndAcknowledgePDU)
            {
                if(m_AcknowledgeCount >= m_AcceptCount)
                {
                    SendNextFile();
                }                
            }
        }
    }

    return(bReturn);
}

void MBFTPrivateSend::SendFileStartPDU(void)
{
    if(!m_bAbortAllFiles)
    {        
        MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
        MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

        LONG lCurrentPosition = m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);
		FILE_HEADER_INFO fileHeaderInfo;
		fileHeaderInfo.fileName = (LPSTR)GetFileNameFromPath(m_pszCurrentFilePath);
		fileHeaderInfo.fileSize = m_CurrentFileSize;
		fileHeaderInfo.pduType = T127_FILE_START;
		GetFileHeaderSize(&fileHeaderInfo);

		int iSizeofFileHeader = fileHeaderInfo.pduSize  + sizeof(T127_FILE_START_DATA_BLOCK_HEADER);
		int iBytesRead = m_lpFile->Read(m_lpDataBuffer + iSizeofFileHeader ,m_MaxDataLength);
        m_bSendingFile = TRUE;

        if(iBytesRead != -1)
        {
            BOOL bIsEOF =  (m_lTotalBytesRead + iBytesRead) >= m_CurrentFileSize;
            LPFILESTARTPDU lpNewPDU = NULL;

            if(!iBytesRead)
            {
                DBG_SAVE_FILE_LINE
                lpNewPDU = new FileStartPDU(m_lpDataBuffer,
                                            fileHeaderInfo.fileName, // GetFileNameFromPath(m_pszCurrentFilePath),
                                            LOWORD(m_CurrentFileHandle),
                                            m_CurrentFileSize,
                                            m_CurrentDateTime,
                                            m_lpDataBuffer,
                                            0,
                                            bIsEOF);          
            }
            else
            {
                if(!m_bCompressFiles)
                {
                    DBG_SAVE_FILE_LINE
                    lpNewPDU = new FileStartPDU(m_lpDataBuffer,
                                                fileHeaderInfo.fileName, // GetFileNameFromPath(m_pszCurrentFilePath),
                                                LOWORD(m_CurrentFileHandle),
                                                m_CurrentFileSize,
                                                m_CurrentDateTime,
                                                m_lpDataBuffer,
                                                iBytesRead,
                                                bIsEOF);   
                }                                                
                else
                {
                    iErrorCode  = iMBFT_MEMORY_ALLOCATION_ERROR;
                }
            }        

            if(iErrorCode == iMBFT_OK)
            {
                if(lpNewPDU)
                {                 
                    if(lpNewPDU->Encode())
                    {
                        if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTDataChannel,
                                                             APPLET_LOW_PRIORITY,
                                                             (LPBYTE)lpNewPDU->GetBuffer(),
                                                             lpNewPDU->GetBufferLength()))
                        {
                            TRACESEND(" Sent file start PDU for [%ld] on [%u], EOF = [%d]\n",
                                m_CurrentFileHandle, m_PrivateMBFTDataChannel, bIsEOF);

                            m_lTotalBytesRead   += iBytesRead;
                            m_SentFileStartPDU  =  TRUE;

                            SendNotificationMessage(iMBFT_FILE_SEND_BEGIN);

                            if(bIsEOF)
                            {
                                m_lpFile->Close();
								if(!m_bEOFAcknowledge)
								{
									SendNextFile();
								}
								else
								{
									TRACESEND(" Waiting for End of File ack PDU\n");
									m_State  =  EnumWaitFileEndAcknowledgePDU;
								}
                            }
                            else
                            {
                                m_State = EnumSendFileDataPDU;
                            }
                        }   
                        else
                        {
                            m_lpFile->Seek(lCurrentPosition,CMBFTFile::SeekMode::SeekFromBegin);
                        }
                    }
                    else
                    {
                        iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
                    }
                }   //if(lpNewPDU)
                else
                {
                    iErrorCode  = iMBFT_MEMORY_ALLOCATION_ERROR;
                }
            }   //if iErrorCode == iMBFT_OK

            if(lpNewPDU)
            {
				lpNewPDU->NULLDataBuffer();
                delete lpNewPDU;
            }
        }    //If bytes read...
        else
        {
            iErrorCode = (MBFT_ERROR_CODE)m_lpFile->GetLastErrorCode();

            //iMBFT_FILE_IO_ERROR;
        }

        if(iErrorCode != iMBFT_OK)
        {
            ReportError(iErrorType,iErrorCode,TRUE);
            ReportSenderError(iErrorType,iErrorCode);
            TerminateCurrentSend();
        }
    }    
    else
    {
        TerminateCurrentSend();
    }
}                         
    
void MBFTPrivateSend::SendNotificationMessage
(
    int             iProgress,
    T120UserID      iUserID,
    MBFTFILEHANDLE  hFileHandle
)
{
	T120UserID id = iUserID ? iUserID : m_MBFTChannelID;

    DBG_SAVE_FILE_LINE
    m_lpParentEngine->SafePostNotifyMessage(
                new FileTransmitMsg(m_EventHandle,
            				hFileHandle ?  hFileHandle : m_CurrentFileHandle,
            				m_CurrentFileSize,
            				m_lTotalBytesRead,
            				iProgress,
            				id));
}

void MBFTPrivateSend::TerminateCurrentSend(void)
{
    m_State = EnumTerminateCurrentSend;

    ReportError(MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,TRUE,
                m_MBFTChannelID,m_CurrentFileHandle);    

    //We don't care about compression in this case because the buffer is NULL....
    DBG_SAVE_FILE_LINE
    LPFILEDATAPDU lpNewPDU = new FileDataPDU(m_lpDataBuffer,LOWORD(m_CurrentFileHandle),m_lpDataBuffer,0, FALSE, TRUE);
    if(lpNewPDU)
    {    
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTDataChannel,
                                                 APPLET_LOW_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                m_lpFile->Close();
                SendNextFile();
            }                                                            
        }
		lpNewPDU->NULLDataBuffer();
        delete lpNewPDU;
    }
}


void MBFTPrivateSend::SendFileDataPDU(void)
{
    LONG lCurrentPosition = -1;
    LPFILEDATAPDU lpNewPDU = NULL;
    int iBytesRead,Index;
    BOOL bIsEOF = FALSE,bTerminate = FALSE;
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

    if(!m_bAbortFileSend)
    {
        for(Index = 0;(Index < _MAX_SEND_PACKETS) && !bTerminate;Index++)
        {
            lCurrentPosition = m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);
            iBytesRead = m_lpFile->Read(m_lpDataBuffer + sizeof(T127_FILE_DATA_HEADER),m_MaxDataLength);
            if(iBytesRead != -1)
            {
                BOOL bDataSent = FALSE;
                bIsEOF = m_lpFile->GetIsEOF();

                if(!m_bCompressFiles)
                {
                    DBG_SAVE_FILE_LINE
                    lpNewPDU = new FileDataPDU(m_lpDataBuffer,
                                               LOWORD(m_CurrentFileHandle),
                                               m_lpDataBuffer,iBytesRead,bIsEOF,
                                               FALSE);
                }
                else
                {
					// MSFT error - no compression
                }

                if(lpNewPDU)
                {
                    if(lpNewPDU->Encode())
                    {
                        if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTDataChannel,
                                                             APPLET_LOW_PRIORITY,
                                                             (LPBYTE)lpNewPDU->GetBuffer(),
                                                             lpNewPDU->GetBufferLength()))
                        {
                            TRACESEND(" Sent file data PDU on [%u], EOF = [%d], BufferSize = [%d]\n",m_PrivateMBFTDataChannel,bIsEOF,lpNewPDU->GetBufferLength());

                            //m_lTotalBytesRead += iBytesRead;

                            m_lTotalBytesRead = m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);

                            bDataSent = TRUE;    

                            SendNotificationMessage(iMBFT_FILE_SEND_PROGRESS);

                            if(bIsEOF)
                            {
                                m_lpFile->Close();

                                if(!m_bEOFAcknowledge)
                                {
                                    SendNextFile();
                                }
                                else
                                {
									TRACESEND(" Waiting for End of File ack PDU\n");
                                    m_State  =  EnumWaitFileEndAcknowledgePDU;
                                }

                                bTerminate = TRUE;
                            }
                        }

                        if(!bDataSent)
                        {
                            m_lpFile->Seek(lCurrentPosition,CMBFTFile::SeekMode::SeekFromBegin);
                            bTerminate = TRUE;
                        }
                    }
                    else
                    {
                        iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
                        break;
                    }
					lpNewPDU->NULLDataBuffer();
                    delete lpNewPDU;
                }
                else
                {
                    iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
                    break;
                }
            }
            else
            {
                iErrorCode = (MBFT_ERROR_CODE)m_lpFile->GetLastErrorCode();

                //iMBFT_FILE_IO_ERROR;

                break;
            }
        }   //for loop
    }
    else
    {
        TerminateCurrentSend();
    }

    if(iErrorCode != iMBFT_OK)
    {
        ReportError(iErrorType,iErrorCode,TRUE);
        ReportSenderError(iErrorType,iErrorCode);
        TerminateCurrentSend();
    }
}

void MBFTPrivateSend::RemoveFileFromList
(
    MBFTFILEHANDLE      hFile
)
{
    if (hFile == m_CurrentFileHandle)
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_NO_MORE_FILES,TRUE);
        TerminateSendSession();
    }
}

BOOL MBFTPrivateSend::RemoveUserFromAcceptedList
(
    T120UserID          iUserID
)
{
    BOOL bUserRemoved = FALSE;

    for (ULONG Index = 1; Index <= m_AcceptedIndex; Index++)
    {
        if(m_lpAcceptedUsersArray[Index - 1] == iUserID)
        {
            bUserRemoved = TRUE;

            if(Index != m_AcceptedIndex)
            {
                CopyMemory(&m_lpAcceptedUsersArray[Index - 1],&m_lpAcceptedUsersArray[Index],
                         (m_AcceptedIndex - Index) * sizeof(UserID));
            }

            m_AcceptedIndex--;
        }
    }

    return(bUserRemoved);
}

BOOL MBFTPrivateSend::RemoveUserFromList
(
    T120UserID          iUserID
)
{
    BOOL bUserRemoved = FALSE;

    for (ULONG Index = 1; Index <= m_iUserCount; Index++)
    {
        if(m_lpUserArray[Index - 1] == iUserID)
        {
            bUserRemoved = TRUE;

            if(Index != m_iUserCount)
            {
                CopyMemory(&m_lpUserArray[Index - 1],&m_lpUserArray[Index],
                         (m_iUserCount - Index) * sizeof(UserID));
            }

            m_iUserCount--;
        }
    }

    if(bUserRemoved)
    {
        if(!m_iUserCount)
        {
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_NO_MORE_RECIPIENTS,TRUE);

            if(m_State == EnumSendFileDataPDU || m_State == EnumSendFileOfferPDU ||
               m_State == EnumWaitFileAcceptPDU)
            {
                if(m_lpFile)
                {
                    m_lpFile->Close();
                }

                if(m_State == EnumSendFileDataPDU)
                {
                    SendNotificationMessage(iMBFT_FILE_SEND_END);
                }                 
            }

            TerminateSendSession();
        }
    }

    return(bUserRemoved);
}

void MBFTPrivateSend::OnControlNotification
(
    MBFTFILEHANDLE          hFile,
    FileTransferControlMsg::FileTransferControl iControlCommand,
    LPCSTR                  lpszDirectory,
    LPCSTR                  lpszFileName
)
{
    if(iControlCommand == FileTransferControlMsg::EnumAbortFile ||
       iControlCommand == FileTransferControlMsg::EnumConductorAbortFile)
    {
        if(m_bOKToDisbandChannel)
        {
            if(hFile == _iMBFT_PROSHARE_ALL_FILES /*&& m_bProshareTransfer*/)
            {
                //Fix to ensure a iMBFT_SENDER_ABORTED notification if sender aborts way too early...
                ReportError(MBFT_INFORMATIVE_ERROR,
                            (iControlCommand == FileTransferControlMsg::EnumAbortFile) ?
                            iMBFT_SENDER_ABORTED :
                            iMBFT_CONDUCTOR_ABORTED,
                            TRUE,
                            m_MBFTChannelID,
                            _iMBFT_PROSHARE_ALL_FILES);    

                UnInitialize();
            }
            else
            {
                RemoveFileFromList(hFile);
            }
        }
        else if(!m_bUnInitializing)
        {
            if(hFile == _iMBFT_PROSHARE_ALL_FILES)
            {
                AbortAllFiles();
            }
            else if(hFile == m_CurrentFileHandle)
            {
                AbortCurrentFile();
            }
        }
    }
}

void MBFTPrivateSend::AbortAllFiles(void)
{
    AbortCurrentFile();
    
    m_bAbortAllFiles = TRUE;
}

void MBFTPrivateSend::AbortCurrentFile(void)
{
    if(m_bSendingFile)
    {
        m_bAbortFileSend = TRUE;
    }
}
    
void MBFTPrivateSend::SendNextFile(void)
{
	// Notify the ui if some receivers didn't accept the previous file
    if(m_AbortedCount)
	{
		// All the receivers aborted the FT, this is the same as the sender canceling FT
		ReportError(MBFT_PERMANENT_ERROR,
		            m_AbortedCount >= m_AcceptCount ? iMBFT_SENDER_ABORTED : iMBFT_MULT_RECEIVER_ABORTED,
		            TRUE);
	}
    if(m_RejectCount)
	{
		// If we just had one FT an it rejected we say that there was a problem sending the file
		// If we had more receivers we will use the receiver aborted message
		ReportError(MBFT_PERMANENT_ERROR,
					m_AcceptCount == 0 ? iMBFT_RECEIVER_REJECTED : iMBFT_MULT_RECEIVER_ABORTED,
		            TRUE);
	}

    // We are sending or the receiver Rejected before we start sending
	if(m_bSendingFile || m_RejectCount)
    {
        SendNotificationMessage(iMBFT_FILE_SEND_END);
    }

    m_bSendingFile      = FALSE;
    m_bAbortFileSend    = FALSE;                               

    TerminateSendSession();
}

void MBFTPrivateSend::OnPeerDeletedNotification
(
    CPeerData           *lpPeerData
)
{
    if(m_State != EnumWaitForTermination)
    {
        if(RemoveUserFromList(lpPeerData->GetUserID()))
        {
            if(m_iUserCount)
            {
                if(m_State == EnumWaitFileAcceptPDU ||
                   m_State == EnumWaitChannelResponsePDU)
                {
                    //m_RejectCount++;
                    //m_ResponseCount++;
                    
                    if(m_ResponseCount >= m_iUserCount)
                    {
                        if(m_State == EnumWaitFileAcceptPDU)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                SendNextFile();                                         
                            }                        
                        }
                        else if(m_State == EnumWaitChannelResponsePDU)
                        {
                            if(!m_bProshareTransfer)
                            {
                                m_State = EnumSendFileOfferPDU;    
                            }
                            else
                            {
                                m_State = EnumSendNonStandardPDU;
                            }                       
                        }
                    }  //m_ResponseCount >= m_iUserCount              
                }
                else if ((m_State == EnumWaitFileEndAcknowledgePDU) || (m_State == EnumSendFileDataPDU))
                {
                    if(RemoveUserFromAcceptedList(lpPeerData->GetUserID()))
                    {
                        m_AcknowledgeCount++;
                    }
            
                    if(m_AcknowledgeCount >= m_AcceptCount)
                    {
                        SendNextFile();
                    }                
                }
            } //UserCount
        } //RemoveUserFromList
    } //EnumWaitForTermination
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\mbftsend.hpp ===
#ifndef __MBFTSEND_HPP__
#define __MBFTSEND_HPP__


class CMBFTFile;

class MBFTPrivateSend : public MBFTSession
{
private:
    
    enum  MBFTPrivateSendState
    {
        EnumIdleInitialized,
        EnumInitializationFailed,
        EnumIdleNotInitialized,
        EnumWaitConveneControlChannel,
        EnumWaitConveneDataChannel,
        EnumWaitRequestControlConvene,
        EnumWaitRequestDataConvene,
        EnumWaitJoinControlChannel,
        EnumWaitRequestJoinControl,
        EnumFileSendPending,
        EnumSendNonStandardPDU,
        EnumSendFileOfferPDU,
        EnumSendFileStartPDU,
        EnumSendFileDataPDU,
        EnumWaitJoinDataChannel,
        EnumWaitRequestJoinData,
        EnumWaitSendChannelInvitePDU,
        EnumWaitChannelResponsePDU,    
        EnumWaitFileAcceptPDU,
        EnumWaitFileEndAcknowledgePDU,
        EnumTerminateCurrentSend,
        EnumWaitForTermination,
        EnumHackWaitFileOffer
    };
    
    CMBFTFile      *m_lpFile;    
    T120ChannelID   m_MBFTChannelID;
    T120ChannelID   m_PrivateMBFTControlChannel;
    T120ChannelID   m_PrivateMBFTDataChannel;    
    T120UserID     *m_lpUserArray;
    T120UserID     *m_lpAcceptedUsersArray;
    T120NodeID     *m_lpNodeArray;
    ULONG           m_iUserCount;
    ULONG           m_AcceptedIndex;
    unsigned        m_MaxDataLength;
    BOOL            m_SentFileStartPDU;
    DWORD           m_TimeOutValue;

    LPSTR           m_pszCurrentFilePath;
    MBFTFILEHANDLE  m_CurrentFileHandle;
    time_t          m_CurrentDateTime;
    LONG            m_CurrentFileSize;

    MBFTPrivateSendState   m_State;    
    BOOL            m_bProshareTransfer;
    BOOL            m_bEOFAcknowledge;
    BOOL            m_bCompressFiles;
    ULONG           m_LastUserCount;
    ULONG           m_ResponseCount;   
    ULONG           m_AcceptCount;
    ULONG           m_RejectCount;
    ULONG           m_AbortedCount;
    ULONG           m_AcknowledgeCount;
    LONG            m_lTotalBytesRead;
    LPSTR           m_lpDataBuffer;

    BOOL            m_bAbortAllFiles;
    BOOL            m_bSendingFile;
    BOOL            m_bAbortFileSend;
    BOOL            m_bUnInitializing;
    BOOL            m_bSentFileOfferPDU;
    BOOL            m_bOKToDisbandChannel;
    LPVOID          m_lpV42bisPointer;
    BOOL            m_bFlushv42Compression;
    BOOL            m_bEventEndPosted;
    
    int             m_v42bisP1;
    int             m_v42bisP2;
        
    void    ConveneControlChannel(void);
    void    ConveneDataChannel(void);
    
    void    JoinControlChannel(void);
    void    AdmitControlChannel(void);
    void    AdmitDataChannel(void);
    
    void    SendChannelInvitePDU(void);
    void    SendFileOfferPDU(void);
    void    SendFileStartPDU(void);
    void    SendFileDataPDU(void);
    void    SendNextFile(void);
    void    AbortAllFiles(void);
    void    AbortCurrentFile(void);
    
    void    RemoveFileFromList(MBFTFILEHANDLE);
    BOOL    RemoveUserFromList(T120UserID);
    BOOL    RemoveUserFromAcceptedList(T120UserID);
    void    SendNotificationMessage(int iProgress, T120UserID uid = 0, MBFTFILEHANDLE h = 0);
    void    ReportError(int iErrorType,int iTransmitError,
                  BOOL bIsLocalError = TRUE, T120UserID uidSender = 0, MBFTFILEHANDLE h = 0);
    void    ReportSenderError(int iErrorType,int iErrorCode, MBFTFILEHANDLE h = 0);
    void    TerminateCurrentSend(void);
    void    TerminateSendSession(void);
    LPSTR   StripFilePath(LPSTR lpszFileName);
    void    Initv42Compression(void);
    void    Flushv42Compression(void);

public:

    MBFTPrivateSend(LPMBFTENGINE lpParentEngine, MBFTEVENTHANDLE EventHandle,
                    T120UserID wMBFTUserID, ULONG MaxDataLength);
    ~MBFTPrivateSend(void);

    BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnMCSChannelConveneConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnReceivedPrivateChannelResponsePDU(T120ChannelID, T120Priority,
                                             T120UserID SenderID,
                                             LPPRIVATECHANNELRESPONSEPDU lpNewPDU,
                                             BOOL IsUniformSendData);
    BOOL OnReceivedFileAcceptPDU(T120ChannelID, T120Priority,
                                 T120UserID SenderID,
                                 LPFILEACCEPTPDU lpNewPDU,
                                 BOOL IsUniformSendData);
    BOOL OnReceivedFileRejectPDU(T120ChannelID, T120Priority,
                                 T120UserID SenderID,
                                 LPFILEREJECTPDU lpNewPDU,
                                 BOOL IsUniformSendData);                                 
    BOOL OnReceivedFileAbortPDU(T120ChannelID, T120Priority,
                                T120UserID SenderID,
                                LPFILEABORTPDU lpNewPDU,
                                BOOL IsUniformSendData);
    BOOL OnReceivedFileErrorPDU(T120ChannelID, T120Priority,
                                T120UserID SenderID,
                                LPFILEERRORPDU lpNewPDU,
                                BOOL IsUniformSendData);
    BOOL OnReceivedNonStandardPDU(T120ChannelID, T120Priority,
                                  T120UserID SenderID,
                                  LPNONSTANDARDPDU lpNewPDU,
                                  BOOL IsUniformSendData);
    BOOL OnReceivedFileEndAcknowledgePDU(T120ChannelID, T120Priority,
                                        T120UserID SenderID,
                                        LPFILEENDACKNOWLEDGEPDU lpNewPDU,
                                        BOOL IsUniformSendData);
    BOOL OnReceivedChannelLeavePDU(T120ChannelID, T120Priority,
                                   T120UserID SenderID,
                                   LPCHANNELLEAVEPDU lpNewPDU,
                                   BOOL IsUniformSendData);                                        
    void OnControlNotification(MBFTFILEHANDLE hFile,
                               FileTransferControlMsg::FileTransferControl iControlCommand,
                               LPCSTR lpszDirectory,
                               LPCSTR lpszFileName);                            
    BOOL SubmitFileSendRequest(SubmitFileSendMsg *);
    void OnPeerDeletedNotification(CPeerData * lpPeerData);
    void DoStateMachine(void);                                        
    void UnInitialize(BOOL bShutDown = FALSE);  
};

#endif  //__MBFTSEND_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\messages.hpp ===
#ifndef __MESSAGES_HPP__
#define __MESSAGES_HPP__


enum
{
    MBFTMSG_CREATE_ENGINE               = WM_APP +  1,
    MBFTMSG_DELETE_ENGINE               = WM_APP +  2,
    MBFTMSG_HEART_BEAT                  = WM_APP +  3,
    MBFTMSG_BASIC                       = WM_APP +  4,
};


typedef enum
{
    EnumMCSChannelAdmitIndicationMsg,
    EnumMCSChannelExpelIndicationMsg,
    EnumMCSChannelJoinConfirmMsg,
    EnumMCSChannelConveneConfirmMsg,
    EnumMCSSendDataIndicationMsg,
    EnumGenericMBFTPDUMsg,
    EnumCreateSessionMsg,
    EnumDeleteSessionMsg,
    EnumPeerDeletedMsg,
    EnumSubmitFileSendMsg,
    EnumFileOfferNotifyMsg,
    EnumFileTransferControlMsg,
    EnumFileTransmitMsg,
    EnumFileErrorMsg,
    EnumPeerMsg,
    EnumInitUnInitNotifyMsg,
    EnumFileEventEndNotifyMsg,
}
    MBFT_MSG_TYPE;


class MBFTMsg
{
public:

    MBFTMsg(MBFT_MSG_TYPE eMsgType) : m_eMsgType(eMsgType) { }
    virtual ~MBFTMsg(void);

    MBFT_MSG_TYPE GetMsgType(void) { return m_eMsgType; }

protected:

    MBFT_MSG_TYPE     m_eMsgType;
};


class MCSChannelAdmitIndicationMsg : public MBFTMsg
{
public:

    MCSChannelAdmitIndicationMsg(T120ChannelID wChannelId, T120UserID ManagerID) :
        MBFTMsg(EnumMCSChannelAdmitIndicationMsg),
        m_wChannelId(wChannelId),
        m_ManagerID(ManagerID)
    {
    }

    T120ChannelID       m_wChannelId;
    T120UserID          m_ManagerID;
};

class MCSChannelExpelIndicationMsg : public MBFTMsg
{
public:

    MCSChannelExpelIndicationMsg(T120ChannelID wChannelId, Reason iReason) :
        MBFTMsg(EnumMCSChannelExpelIndicationMsg),
        m_wChannelId(wChannelId),
        m_iReason(iReason)
    {
    }

    T120ChannelID       m_wChannelId;
    Reason              m_iReason;
};

class  MCSChannelJoinConfirmMsg : public MBFTMsg
{
public:

    MCSChannelJoinConfirmMsg(T120ChannelID wChannelId, BOOL bSuccess) :
        MBFTMsg(EnumMCSChannelJoinConfirmMsg),
        m_wChannelId(wChannelId),
        m_bSuccess(bSuccess)
    {
    }

    T120ChannelID       m_wChannelId;
    BOOL                m_bSuccess;
};

class MCSChannelConveneConfirmMsg : public MBFTMsg
{
public:

    MCSChannelConveneConfirmMsg(T120ChannelID wChannelId, BOOL bSuccess) :
        MBFTMsg(EnumMCSChannelConveneConfirmMsg),
        m_wChannelId(wChannelId),
        m_bSuccess(bSuccess)
    {
    }

    T120ChannelID       m_wChannelId;
    BOOL                m_bSuccess;
};

class MCSSendDataIndicationMsg : public MBFTMsg
{
public:

    MCSSendDataIndicationMsg(T120ChannelID wChannelId,
                             T120Priority iPriority,
                             T120UserID SenderID,
                             LPBYTE lpBuffer,
                             ULONG ulDataLength,
                             BOOL IsUniformSendData);

    T120ChannelID       m_wChannelId;
    T120Priority        m_iPriority;
    T120UserID          m_SenderID;
    LPBYTE              m_lpBuffer;
    ULONG               m_ulDataLength;
    BOOL                m_IsUniformSendData;
};

class MBFTPDUMsg : public MBFTMsg
{
public:

    MBFTPDUMsg(T120ChannelID wChannelId,
               T120Priority iPriority,
               T120UserID SenderID,
               LPGENERICPDU lpNewPDU,
               BOOL IsUniformSendData,
               MBFTPDUType PDUType,
               LPSTR lpDecodedBuffer);

    ~MBFTPDUMsg(void);

    T120ChannelID       m_wChannelId;
    T120Priority        m_iPriority;
    T120UserID          m_SenderID;
    LPGENERICPDU        m_lpNewPDU;
    BOOL                m_IsUniformSendData;
    MBFTPDUType         m_PDUType;
    LPSTR               m_lpDecodedBuffer;
};

class CreateSessionMsg : public MBFTMsg
{
public:

    CreateSessionMsg(MBFT_SESSION_TYPE iSessionType,
                     MBFTEVENTHANDLE EventHandle,
                     T120SessionID SessionID = 0,
                     T120ChannelID wControlChannel = 0,
                     T120ChannelID wDataChannel = 0,
                     T120UserID SenderID = 0,
                     MBFTFILEHANDLE FileHandle = 0);

    MBFT_SESSION_TYPE   m_iSessionType;
    MBFTEVENTHANDLE     m_EventHandle;
    T120SessionID       m_SessionID;
    T120ChannelID       m_ControlChannel;
    T120ChannelID       m_DataChannel;
    T120UserID          m_SenderID;
    MBFTFILEHANDLE      m_FileHandle;
};

class MBFTSession;
class DeleteSessionMsg : public MBFTMsg
{
public:

    DeleteSessionMsg(MBFTSession * lpDeleteSession) :
        MBFTMsg(EnumDeleteSessionMsg),
        m_lpDeleteSession(lpDeleteSession)
    {
    }

    MBFTSession * m_lpDeleteSession;
};

class CPeerData;
class PeerDeletedMsg : public MBFTMsg
{
public:

    PeerDeletedMsg(CPeerData * lpPeerData) :
        MBFTMsg(EnumPeerDeletedMsg),
        m_lpPeerData(lpPeerData)
    {
    }
    ~PeerDeletedMsg(void);

    CPeerData * m_lpPeerData;
};


class SubmitFileSendMsg  :  public MBFTMsg
{
public:

    SubmitFileSendMsg::SubmitFileSendMsg(T120UserID	uidReceiver,
										 T120NodeID nidReceiver,
										 LPCSTR pszFilePath,
                                         MBFTFILEHANDLE nFileHandle,
                                         MBFTEVENTHANDLE EventHandle,
                                         BOOL bCompressFiles);

    ~SubmitFileSendMsg(void);

	T120UserID		m_nUserID;
	T120NodeID		m_nNodeID;
    LPSTR           m_pszFilePath;
    MBFTFILEHANDLE  m_nFileHandle;
    MBFTEVENTHANDLE m_EventHandle;
    BOOL            m_bCompressFiles;
};

class FileOfferNotifyMsg : public MBFTMsg
{
public:

    FileOfferNotifyMsg(MBFTEVENTHANDLE EventHandle,
                       T120UserID SenderID,
					   T120NodeID NodeID,
                       MBFTFILEHANDLE hFile,
                       LPCSTR lpszFilename,
                       ULONG FileSize,
                       time_t FileDateTime,
                       BOOL bAckNeeded);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    ULONG               m_FileSize;
    time_t              m_FileDateTime;
    BOOL                m_bAckNeeded;
    T120UserID          m_SenderID;
	T120NodeID          m_NodeID;
    char                m_szFileName[_MAX_PATH];
};

class FileTransferControlMsg :  public MBFTMsg
{
public:

    enum FileTransferControl
    {
        EnumAcceptFile,
        EnumRejectFile,
        EnumAbortFile,
        EnumConductorAbortFile
    };

    FileTransferControlMsg(MBFTEVENTHANDLE EventHandle,
                           MBFTFILEHANDLE hFile,
                           LPCSTR lpszDirectory,
                           LPCSTR lpszFileName,
                           FileTransferControl iControlCommand);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    FileTransferControl m_ControlCommand;
    char                m_szDirectory[_MAX_PATH];
    char                m_szFileName[_MAX_FNAME];
};

class FileTransmitMsg :  public MBFTMsg
{
public:

    FileTransmitMsg(MBFTEVENTHANDLE EventHandle,
                    MBFTFILEHANDLE hFile,
                    ULONG FileSize,
                    ULONG BytesTransmitted,
                    int      iTransmitStatus,
                    T120UserID   iUserID = 0,
                    BOOL     bIsBroadcastEvent = FALSE);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    ULONG               m_FileSize;
    ULONG               m_BytesTransmitted;
    T120UserID          m_UserID;
    int                 m_TransmitStatus;
    BOOL                m_bIsBroadcastEvent;
};

class FileErrorMsg :   public MBFTMsg
{
public:

    FileErrorMsg(MBFTEVENTHANDLE EventHandle,
                 MBFTFILEHANDLE hFile,
                 int  iErrorType,
                 int  iErrorCode,
                 BOOL bIsLocalError,
                 T120UserID iUserID = 0,
                 BOOL   bIsBroadcastEvent = FALSE,
				 const char* pFileName = NULL,
				 ULONG nFileSize = 0);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    int                 m_ErrorCode;
    int                 m_ErrorType;
    BOOL                m_bIsLocalError;
    T120UserID          m_UserID;
    BOOL                m_bIsBroadcastEvent;
	MBFT_RECEIVE_FILE_INFO m_stFileInfo;
};

class PeerMsg    :  public MBFTMsg
{
public:

    enum    PeerChange
    {
        EnumPeerAdded,
        EnumPeerRemoved
    };

    PeerMsg(T120NodeID NodeID,
            T120UserID MBFTPeerID,
            BOOL bIsLocalPeer,
            BOOL IsProsharePeer,
            LPCSTR   lpszAppKey,
            BOOL bPeerAdded,
            T120SessionID MBFTSessionID);

    T120NodeID          m_NodeID;
    T120UserID          m_MBFTPeerID;
    BOOL                m_bIsLocalPeer;
    BOOL                m_bIsProsharePeer;
    T120SessionID       m_MBFTSessionID;
    BOOL                m_bPeerAdded;
    char                m_szAppKey[MAX_APP_KEY_SIZE];
};


enum  InitUnInitNotifyType
{
    EnumInitFailed,
    EnumUnInitComplete,
    EnumInvoluntaryUnInit
};

class InitUnInitNotifyMsg   : public MBFTMsg
{
public:

    InitUnInitNotifyMsg(InitUnInitNotifyType iNotifyMessage) :
        MBFTMsg(EnumInitUnInitNotifyMsg),
        m_iNotifyMessage(iNotifyMessage)
    {
    }

    InitUnInitNotifyType    m_iNotifyMessage;
};

class FileEventEndNotifyMsg    :   public MBFTMsg
{
public:

    FileEventEndNotifyMsg(MBFTEVENTHANDLE EventHandle) :
        MBFTMsg(EnumFileEventEndNotifyMsg),
        m_EventHandle(EventHandle)
    {
    }

    MBFTEVENTHANDLE  m_EventHandle;
};

#endif  //__MESSAGES_HPP__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG



// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

    void ReleaseNow(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
};


__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\plugable.h ===
#if defined(TEST_PLUGABLE) && defined(_DEBUG)

#ifndef _FT_PLUGABLE_H_
#define _FT_PLUGABLE_H_

#define WM_PLUGABLE_SOCKET      (WM_APP + 0x601)


void OnPluggableBegin(HWND hwnd);
void OnPluggableEnd(void);

LRESULT OnPluggableSocket(HWND, WPARAM, LPARAM);



#endif // _FT_PLUGABLE_H_

#endif // TEST_PLUGABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\osshelp.hpp ===
#ifndef __OSSHELP_HPP__
#define __OSSHELP_HPP__

#include <windows.h>
#include <stdlib.h>
#include <it120app.h>


typedef enum tagMBFTPDUType
{
    EnumUnknownPDU,
    EnumFileOfferPDU,
    EnumFileAcceptPDU,
    EnumFileRejectPDU,
    EnumFileAbortPDU,
    EnumFileStartPDU,
    EnumFileDataPDU,
    EnumPrivateChannelInvitePDU,
    EnumPrivateChannelResponsePDU,
    EnumNonStandardPDU,
    EnumFileErrorPDU,
    EnumFileRequestPDU,
    EnumFileDenyPDU,
    EnumDirectoryRequestPDU,
    EnumDirectoryResponsePDU,
    EnumPrivilegeRequestPDU,
    EnumPrivilegeAssignPDU,
    EnumFileEndAcknowledgePDU,
    EnumChannelLeavePDU
}
    MBFTPDUType;


class GenericPDU
{
protected:

    LPSTR m_lpEncodedBuffer;
    LONG m_lEncodedDataLength;
    IT120AppletSession     *m_pAppletSession;

public:

    GenericPDU(IT120AppletSession *pAppletSession = NULL, LPCSTR lpszEncodedDataBuffer = NULL)
    :
        m_lpEncodedBuffer((LPSTR) lpszEncodedDataBuffer),
        m_lEncodedDataLength(0),
        m_pAppletSession(pAppletSession)
    {
    }
    ~GenericPDU(void);

    static MBFTPDUType GenericPDU::DecodePDU(LPSTR lpEncodedBuffer,LONG lBufferSize,
                                         class GenericPDU ** lplplpGenericPDU,
                                         LPCSTR * lpDecodedPDU,UserID MBFTUserID,
                                         IT120AppletSession *pAppletSession = NULL);

    void NULLDataBuffer(void) { m_lpEncodedBuffer = NULL; }
    LPCSTR GetBuffer(void) { return m_lpEncodedBuffer; }
    LONG GetBufferLength(void) { return m_lEncodedDataLength; }
    void FreeMCSBuffer (void);
    BOOL Encode(void);
};

typedef class GenericPDU FAR * LPGENERICPDU;

const unsigned  _MBFT_FILE_COMPRESSED           =   0x0001;
const unsigned  _MBFT_STANDARD_COMPRESSSION     =   0x0002;

class FileOfferPDU  :   public GenericPDU
{

 private:
    MBFTFILEHANDLE         m_FileHandle;
    LONG        m_FileSize;
    time_t      m_FileDateTime;
    ChannelID   m_DataChannelID;
    BOOL        m_bAcknowledge;
    int         m_RosterInstance;
    unsigned    m_CompressionFlags;
    int         m_v42bisP1;
    int         m_v42bisP2;
    char        m_szFileName[_MAX_PATH];
    char        m_szCompressionFormat[255];

 public:

    FileOfferPDU(LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                 LONG FileSize,time_t FileDateTime,
                 ChannelID wChannelID,
                 BOOL bAcknowledge,
                 int RosterInstance = 0,
                 unsigned CompressionFlags = 0,
                 LPCSTR lpszCompressionFormat = NULL,
                 int v42bisP1 = 0,
                 int v42bisP2 = 0);

    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    LPCSTR GetFileName(void) { return m_szFileName; }
    BOOL GetAcknowledge(void) { return m_bAcknowledge; }
    LONG GetFileSize(void) { return m_FileSize; }
    time_t GetFileDateTime(void) { return m_FileDateTime; }
    int GetRosterInstance(void) { return m_RosterInstance; }
    unsigned GetCompressionFlags(void) { return m_CompressionFlags; }
    LPCSTR GetCompressionFormat(void) { return m_szCompressionFormat; }
    ChannelID   GetDataChannelID(void) { return m_DataChannelID; }
    int Getv42bisP1(void) { return m_v42bisP1; }
    int Getv42bisP2(void) { return m_v42bisP2; }
    BOOL Encode(void);
};

typedef class FileOfferPDU FAR * LPFILEOFFERPDU;

class FileAcceptPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;
    ChannelID m_DataChannelID;
    BOOL m_bAcknowledge;

 public:

    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    FileAcceptPDU(MBFTFILEHANDLE iFileHandle);
    BOOL Encode(void);
};

typedef class FileAcceptPDU FAR * LPFILEACCEPTPDU;

class FileRejectPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;

 public:

    FileRejectPDU(MBFTFILEHANDLE iFileHandle);
    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    BOOL Encode(void);
};

typedef class FileRejectPDU FAR * LPFILEREJECTPDU;

class FileAbortPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;
    ChannelID m_DataChannelID;
    ChannelID m_TransmitterID;

 public:

    FileAbortPDU(ChannelID wDataChannelID,
                 ChannelID wTransmitterID,
                 MBFTFILEHANDLE iFileHandle);

    MBFTFILEHANDLE    GetFileHandle(void) { return m_FileHandle; }
    ChannelID   GetDataChannelID(void) { return m_DataChannelID; }
    ChannelID   GetTransmitterID(void) { return m_TransmitterID; }

    BOOL Encode(void);
};

typedef class FileAbortPDU FAR * LPFILEABORTPDU;

class FileStartPDU   :   public GenericPDU
{
    MBFTFILEHANDLE    m_FileHandle;
    LONG        m_FileSize;
    time_t      m_FileDateTime;
    LPCSTR	m_lpszDataBuffer;
    BOOL        m_bIsEOF;
    LONG        m_DataLength;
    unsigned    m_CompressionFlags;
    int         m_v42bisP1;
    int         m_v42bisP2;
    char        m_szFileName[_MAX_PATH];
    char        m_szCompressionFormat[255];

public:

    FileStartPDU(LPCSTR lpszEncodedDataBuffer,
    		 LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                 LONG FileSize,time_t FileDateTime,
                 LPCSTR lpszDataBuffer,int iDataLength,
                 BOOL bIsEOF,
                 unsigned CompressionFlags = 0,
                 LPCSTR lpszCompressionFormat = NULL,
                 int v42bisP1 = 0,
                 int v42bisP2 = 0,
                 IT120AppletSession *pAppletSession = NULL);

    LPCSTR GetFileName(void) { return m_szFileName; }
    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    LPCSTR GetDataBuffer(void) { return m_lpszDataBuffer; }
    ULONG GetDataSize(void) { return (ULONG) m_DataLength; }
    BOOL GetIsEOF(void) { return m_bIsEOF; }
    LONG GetFileSize(void) { return m_FileSize; }
    unsigned GetCompressionFlags(void) { return m_CompressionFlags; }
    LPCSTR GetCompressionFormat(void) { return m_szCompressionFormat; }
    int Getv42bisP1(void) { return m_v42bisP1; }
    int Getv42bisP2(void) { return m_v42bisP2; }
    BOOL Encode(void);
};

typedef class FileStartPDU FAR * LPFILESTARTPDU;


class FileDataPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;
    BOOL     m_bIsEOF;
    BOOL     m_bAbort;
    LPCSTR	 m_lpszDataBuffer;
    LONG     m_DataLength;
    int      m_TotalFiles;
    int      m_FileIndex;

 public:

    FileDataPDU(LPCSTR lpszEncodedDataBuffer,
    			MBFTFILEHANDLE iFileHandle,
    			LPCSTR lpszDataBuffer,
                int iDataLength,
                BOOL bIsEOF,
                BOOL bAbort,
                IT120AppletSession *pAppletSession = NULL);

    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    LPCSTR GetDataBuffer(void) { return (LPCSTR) m_lpszDataBuffer; }
    ULONG GetDataSize(void) { return (ULONG) m_DataLength; }
    BOOL GetIsEOF(void) { return m_bIsEOF; }
    BOOL GetIsAbort(void) { return m_bAbort; }
    BOOL Encode(void);
};

typedef class FileDataPDU FAR * LPFILEDATAPDU;

class PrivateChannelInvitePDU   :   public GenericPDU
{
    ChannelID   m_ControlChannelID;
    ChannelID   m_DataChannelID;
    BOOL        m_bIsBroadcast;

 public:

    PrivateChannelInvitePDU(ChannelID wControlChannelID,
                            ChannelID wDataChannelID,
                            BOOL bIsBroadcast);

    ChannelID GetControlChannel(void) { return m_ControlChannelID; }
    ChannelID GetDataChannel(void) { return m_DataChannelID; }
    BOOL Encode(void);
};

typedef class PrivateChannelInvitePDU FAR * LPPRIVATECHANNELINVITEPDU;

class PrivateChannelResponsePDU   :   public GenericPDU
{
    ChannelID   m_ControlChannelID;
    BOOL        m_bJoinedChannel;

 public:

    PrivateChannelResponsePDU(ChannelID wControlChannelID,BOOL bJoinedChannel);
    ChannelID GetControlChannel(void) { return m_ControlChannelID; }
    BOOL GetWasChannelJoined(void) { return m_bJoinedChannel; }
    BOOL Encode(void);
};

typedef class PrivateChannelResponsePDU FAR * LPPRIVATECHANNELRESPONSEPDU;


class NonStandardPDU   :   public GenericPDU
{
	LPCSTR 		m_szKey;
    LPVOID      m_lpBuffer;
    unsigned    m_BufferLength;

public:

    NonStandardPDU(LPCSTR lpszEncodedDataBuffer,
    				LPCSTR lpszKey,
    				LPVOID lpBuffer,
    				unsigned BufferLength,
    				IT120AppletSession *pAppletSession = NULL);
    LPCSTR GetKey(void) { return m_szKey; }
    LPCSTR GetDataBuffer(void) { return (LPCSTR) m_lpBuffer; }
    ULONG GetDataSize(void) { return m_BufferLength; }
    BOOL Encode(void);
};

typedef class NonStandardPDU FAR * LPNONSTANDARDPDU;

class FileErrorPDU     :    public GenericPDU
{

private:

    MBFTFILEHANDLE    m_FileHandle;
    int         m_ErrorType;
    int         m_ErrorCode;

public:

    FileErrorPDU(unsigned iFileHandle,int iErrorType,int iErrorCode);
    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    unsigned GetErrorType(void) { return m_ErrorType; }
    unsigned GetErrorCode(void) { return m_ErrorCode; }
    BOOL Encode(void);

    static BOOL ExtractErrorCode(LPCSTR lpszString,int iLength,
                                 int * lpAPIErrorCode);

    static BOOL XlatErrorCode(int * lpAPIErrorCode,
                              int * lpMBFTErrorCode,
                              BOOL bXlatToAPI);
};

typedef class FileErrorPDU FAR * LPFILEERRORPDU;


class FileRequestPDU    :       public GenericPDU
{

private:

    ChannelID   m_DataChannelID;
    unsigned    m_uRequestHandle;
    char        m_szFileName[_MAX_PATH];

public:

    FileRequestPDU(LPCSTR lpszFileName,ChannelID wDataChannelID,
                   unsigned uRequestHandle);

    unsigned GetRequestHandle(void) { return m_uRequestHandle; }
    BOOL Encode(void);
};

typedef class FileRequestPDU FAR * LPFILEREQUESTPDU;

class FileDenyPDU   :       public GenericPDU
{

private:

    unsigned    m_uRequestHandle;
    unsigned    m_uReason;

public:

    FileDenyPDU(unsigned uRequestHandle,unsigned uReason = 0);
    BOOL Encode(void);
};

typedef class FileDenyPDU FAR * LPFILEDENYPDU;

class DirectoryRequestPDU   :       public GenericPDU
{

private:

    char    m_szPathName[_MAX_PATH];

public:

    DirectoryRequestPDU(LPCSTR lpszPathName);
    BOOL Encode(void);
};

typedef class DirectoryRequestPDU FAR * LPDIRECTORYREQUESTPDU;

class DirectoryResponsePDU   :       public GenericPDU
{

private:

    unsigned    m_uResult;

public:

    DirectoryResponsePDU(unsigned uResult = 0);
    BOOL Encode(void);
};

typedef class DirectoryResponsePDU FAR * LPDIRECTORYRESPONSEPDU;

class PrivilegeRequestPDU   :       public GenericPDU
{

private:

    unsigned    m_PrivilegeWord;

public:

    enum MBFTPrivilege
    {
        EnumFileTransfer   = 0x0001,
        EnumFileRequest    = 0x0002,
        EnumPrivateChannel = 0x0004,
        EnumPriority       = 0x0008,
        EnumAbort          = 0x0010,
        EnumNonStandard    = 0x0020
    };

    PrivilegeRequestPDU(unsigned wPrivilege);
    BOOL Encode(void);
};

class PrivilegeAssignPDU   :       public GenericPDU
{

private:

    unsigned    m_PrivilegeWord;
    UserID      m_MBFTUserID;

public:

    enum MBFTPrivilege
    {
        EnumFileTransfer   = 0x0001,
        EnumFileRequest    = 0x0002,
        EnumPrivateChannel = 0x0004,
        EnumPriority       = 0x0008,
        EnumAbort          = 0x0010,
        EnumNonStandard    = 0x0020
    };

    PrivilegeAssignPDU(unsigned wPrivilege,UserID MBFTUserID = 0);
    BOOL Encode(void);

    static BOOL XlatPrivilegeCode(unsigned iPrivilegeCode,unsigned * lpMBFTCode);

    static unsigned ConstructPrivilegeWord(LPVOID lpStruct,
                                           ChannelID MBFTUserID);
    unsigned    GetPrivilegeWord(void) { return m_PrivilegeWord; }
};

typedef class PrivilegeAssignPDU FAR * LPPRIVILEGEASSIGNPDU;

class   FileEndAcknowledgePDU    :  public GenericPDU
{
private:

    MBFTFILEHANDLE     m_FileHandle;

public:

    FileEndAcknowledgePDU(int iFileHandle);
    BOOL Encode(void);

    MBFTFILEHANDLE    GetFileHandle(void) { return m_FileHandle; }
};

typedef class FileEndAcknowledgePDU FAR * LPFILEENDACKNOWLEDGEPDU;

class   ChannelLeavePDU   :  public GenericPDU
{
private:

    ChannelID   m_ChannelID;
    int         m_ErrorCode;

public:

    ChannelLeavePDU(ChannelID wControlChannelID,int iErrorCode);
    BOOL Encode(void);

    ChannelID   GetChannelID(void) { return m_ChannelID; }
    int         GetErrorCode(void) { return m_ErrorCode; }
};

typedef class ChannelLeavePDU FAR * LPCHANNELLEAVEPDU;

struct FileEndAcknowledgeStruct
{
    MBFTFILEHANDLE     m_FileHandle;
};

struct ChannelLeaveStruct
{
    ChannelID   m_ChannelID;
    int         m_ErrorCode;
};

#endif //__OSSHELP_HPP__



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ftapp.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\plugable.cpp ===
#include "mbftpch.h"

#if defined(TEST_PLUGABLE) && defined(_DEBUG)

#include "plugable.h"
#include "iplgxprt.h"
#include "it120xprt.h"
#include "nullmdm.h"

extern HINSTANCE g_hDllInst;

#define PLUGABLE_PORT_NUMBER    522  // ULS server port number

IT120PluggableTransport *g_pPluggableTransport = NULL;

#ifdef USE_SOCKET
SOCKET g_hListenSocket = INVALID_SOCKET;
#endif


typedef struct
{
    LPSTR   pszHostName;
#ifdef USE_SOCKET
    SOCKET  hSocket;
#else
    CNullModem *pModem;
#endif
    HANDLE  hevtRead;
    HANDLE  hevtWrite;
    HANDLE  hevtClose;
    char    szConnID[64];
}
    HOST_INFO;

#define NUM_HOSTS           2
#define TOP_PROVIDER_ID     0

ULONG g_nMyHostID = (ULONG) -1;
HOST_INFO g_aHostInfo[NUM_HOSTS];

char g_szMyHostName[64];

PLUGXPRT_PARAMETERS g_PluggableParams;

#ifdef USE_SOCKET
SOCKET CreateListenSocket(HWND hwnd);
SOCKET CreateConnectSocket(HWND hwnd, LPSTR pszHostName);
#else
CNullModem * CreateListenModem(void);
void CloseListenModem(CNullModem *p);
CNullModem * CreateConnectModem(LPSTR pszHostName);
void CloseConnectModem(CNullModem *p);
#endif


void OnPluggableBegin(HWND hwnd)
{
#ifdef USE_SOCKET
    WSADATA wsa_data;
    WORD version_requested = MAKEWORD (1,1);
    int error = ::WSAStartup(version_requested, &wsa_data);
    ASSERT(error == 0);
    g_hListenSocket = INVALID_SOCKET;
#endif

    ::ZeroMemory(g_aHostInfo, sizeof(g_aHostInfo));
    g_aHostInfo[0].pszHostName = "lonchanc";
    g_aHostInfo[1].pszHostName = "lon1";
    // g_aHostInfo[2].pszHostName = "lonchanc_nt";
    for (ULONG i = 0; i < NUM_HOSTS; i++)
    {
        g_aHostInfo[i].szConnID[0] = '\0';
#ifdef USE_SOCKET
        g_aHostInfo[i].hSocket = INVALID_SOCKET;
#else
        g_aHostInfo[i].pModem = NULL;
#endif
        g_aHostInfo[i].hevtRead = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        g_aHostInfo[i].hevtWrite = ::CreateEvent(NULL, FALSE, FALSE, NULL);;
        g_aHostInfo[i].hevtClose = ::CreateEvent(NULL, FALSE, FALSE, NULL);;
        ASSERT(g_aHostInfo[i].hevtRead && g_aHostInfo[i].hevtWrite && g_aHostInfo[i].hevtClose);
    }

    T120Error rc = ::T120_CreatePluggableTransport(&g_pPluggableTransport);
    ASSERT(T120_NO_ERROR == rc);

    g_pPluggableTransport->ResetConnCounter();
    g_pPluggableTransport->DisableWinsock();

    gethostname(g_szMyHostName, 64);
    TRACE_OUT(("OnPluggableScript: HostName=%s", g_szMyHostName));
    for (i = 0; i < NUM_HOSTS; i++)
    {
        if (! ::lstrcmpi(g_aHostInfo[i].pszHostName, g_szMyHostName))
        {
            g_nMyHostID = i;
            break;
        }
    }
    ASSERT(i < NUM_HOSTS);
    ASSERT(g_nMyHostID < NUM_HOSTS);

    ::ZeroMemory(&g_PluggableParams, sizeof(g_PluggableParams));
    g_PluggableParams.cbStructSize = sizeof(g_PluggableParams);
    g_PluggableParams.dwFlags = PSTN_PARAM__CALL_CONTROL |
                                PSTN_PARAM__READ_FILE_BUFFER_SIZE |
                                PSTN_PARAM__PHYSICAL_LAYER_SEND_BUFFER_SIZE |
                                PSTN_PARAM__PHSYICAL_LAYER_RECV_BUFFER_SIZE |
                                PSTN_PARAM__MAX_T200_TIMEOUT_COUNT_IN_Q922 |
                                PSTN_PARAM__T203_TIMEOUT_IN_Q922;
    g_PluggableParams.eCallControl = PLUGXPRT_PSTN_CALL_CONTROL_MANUAL;
    g_PluggableParams.cbReadFileBufferSize = 10240; // 10K
    g_PluggableParams.cbPhysicalLayerSendBufferSize = 1024; // 1K
    g_PluggableParams.cbPhysicalLayerReceiveBufferSize = 10240; // 10K
    g_PluggableParams.cMaximumT200TimeoutsInQ922 = 5;
    g_PluggableParams.nT203TimeoutInQ922 = 600;

    if (TOP_PROVIDER_ID == g_nMyHostID)
    {
        for (i = 0; i < NUM_HOSTS; i++)
        {
            if (i != g_nMyHostID)
            {
#ifdef USE_SOCKET
                g_aHostInfo[i].hSocket = ::CreateConnectSocket(hwnd, g_aHostInfo[i].pszHostName);
                ASSERT(INVALID_SOCKET != g_aHostInfo[i].hSocket);
#else
                g_aHostInfo[i].pModem = ::CreateConnectModem(g_aHostInfo[i].pszHostName);
                ASSERT(NULL != g_aHostInfo[i].pModem);
#endif

                HANDLE hCommLink = NULL;
#ifdef USE_SOCKET
                BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), (HANDLE) g_aHostInfo[i].hSocket,
#else
                BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), g_aHostInfo[i].pModem->GetCommLink(),
#endif
                                              ::GetCurrentProcess(), &hCommLink,
                                              0, FALSE, DUPLICATE_SAME_ACCESS);
                ASSERT(fRet);

                rc = g_pPluggableTransport->CreateConnection(
                            g_aHostInfo[i].szConnID,
                            PLUGXPRT_CALLER, // caller
                            hCommLink,
                            g_aHostInfo[i].hevtRead,
                            g_aHostInfo[i].hevtWrite,
                            g_aHostInfo[i].hevtClose,
                            FRAMING_LEGACY_PSTN,
                            &g_PluggableParams);
                ASSERT(T120_NO_ERROR == rc);
            }
        }
    }
    else
    {
#ifdef USE_SOCKET
        g_hListenSocket = ::CreateListenSocket(hwnd);
#else
        g_aHostInfo[i].pModem = ::CreateListenModem();
        ASSERT(NULL != g_aHostInfo[i].pModem);

        HANDLE hCommLink = NULL;
        BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), g_aHostInfo[i].pModem->GetCommLink(),
                                      ::GetCurrentProcess(), &hCommLink,
                                      0, FALSE, DUPLICATE_SAME_ACCESS);
        ASSERT(fRet);

        T120Error rc = g_pPluggableTransport->CreateConnection(
                                    g_aHostInfo[i].szConnID,
                                    PLUGXPRT_CALLEE, // callee
                                    hCommLink,
                                    g_aHostInfo[i].hevtRead,
                                    g_aHostInfo[i].hevtWrite,
                                    g_aHostInfo[i].hevtClose,
                                    FRAMING_LEGACY_PSTN,
                                    &g_PluggableParams);
        ASSERT(T120_NO_ERROR == rc);
#endif
    }
}


void OnPluggableEnd(void)
{
#ifdef USE_SOCKET
    if (INVALID_SOCKET != g_hListenSocket)
    {
        ::closesocket(g_hListenSocket);
    }
    for (ULONG i = 0; i < NUM_HOSTS; i++)
    {
        if (INVALID_SOCKET != g_aHostInfo[i].hSocket)
        {
            ::closesocket(g_aHostInfo[i].hSocket);
        }
    }
#else
    for (ULONG i = 0; i < NUM_HOSTS; i++)
    {
        if (i != g_nMyHostID)
        {
            CloseConnectModem(g_aHostInfo[i].pModem);
        }
        else
        {
            CloseListenModem(g_aHostInfo[i].pModem);
        }
        g_aHostInfo[i].pModem = NULL;
    }
    
#endif

    g_pPluggableTransport->EnableWinsock();
    g_pPluggableTransport->ReleaseInterface();
    g_pPluggableTransport = NULL;

#ifdef USE_SOCKET
    ::WSACleanup();
#endif
}


LRESULT OnPluggableSocket(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
#ifdef USE_SOCKET
	/* This message is generated by WinSock */
	SOCKET hSocket = (SOCKET) wParam;
	ULONG event = WSAGETSELECTEVENT(lParam);
	ULONG error = WSAGETSELECTERROR(lParam);
    ULONG nIdx = (ULONG) -1;

    if (hSocket != g_hListenSocket)
    {
        for (ULONG i = 0; i < NUM_HOSTS; i++)
        {
            if (hSocket == g_aHostInfo[i].hSocket)
            {
                nIdx = i;
                break;
            }
        }
        ASSERT(nIdx < NUM_HOSTS);
    }
    else
    {
        nIdx = TOP_PROVIDER_ID;
    }

	/* We disconnect whenever a socket command generates an error message */
	if (error)
	{
		TRACE_OUT(("OnPluggableSocket: error %d on socket (%d). Event: %d", error, hSocket, event));	
	}
	
	/* We get FD_CLOSE when the socket is closed by the remote site. */
	if (event & FD_CLOSE)
	{
		TRACE_OUT(("OnPluggableSocket FD_CLOSE(%d)", hSocket));
	    ::SetEvent(g_aHostInfo[nIdx].hevtClose);
	}
	
	/* We get FD_READ when there is data available for us to read. */
	if (event & FD_READ)
	{
		TRACE_OUT(("OnPluggableSocket FD_READ(%d)", hSocket));
	    ::SetEvent(g_aHostInfo[nIdx].hevtRead);
	}

	/* We get FD_WRITE when there is space available to write data to WinSock */
	if (event & FD_WRITE)
	{
		TRACE_OUT(("OnPluggableSocket FD_WRITE(%d)", hSocket));
	    ::SetEvent(g_aHostInfo[nIdx].hevtWrite);
	}

	/* We get FD_CONNECT when connecting to a remote site */
	if (event & FD_CONNECT)
	{
		TRACE_OUT(("OnPluggableSocket FD_CONNECT(%d)", hSocket));
        // ::SetEvent(g_aHostInfo[nIdx].hevtWrite);
	}

	/* We get FD_ACCEPT when a remote site is connecting with us */
	if (event & FD_ACCEPT)
	{
		TRACE_OUT(("OnPluggableSocket FD_ACCEPT(%d)", hSocket));
        ASSERT(nIdx == TOP_PROVIDER_ID);

        SOCKADDR_IN socket_control;
        int size = sizeof(socket_control);
        g_aHostInfo[nIdx].hSocket = ::accept(g_hListenSocket, (struct sockaddr *) &socket_control, &size);
        ASSERT(INVALID_SOCKET != g_aHostInfo[nIdx].hSocket);

        int nRet = ::WSAAsyncSelect(g_aHostInfo[nIdx].hSocket, hwnd,
                                    WM_PLUGABLE_SOCKET, 
                                    FD_READ | FD_WRITE | FD_CLOSE | FD_CONNECT);
        ASSERT(SOCKET_ERROR != nRet);

        HANDLE hCommLink = NULL;
        BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), (HANDLE) g_aHostInfo[nIdx].hSocket,
                                      ::GetCurrentProcess(), &hCommLink,
                                      0, FALSE, DUPLICATE_SAME_ACCESS);
        ASSERT(fRet);

        T120Error rc = g_pPluggableTransport->CreateConnection(
                                    g_aHostInfo[nIdx].szConnID,
                                    PLUGXPRT_CALLEE, // callee
                                    hCommLink,
                                    g_aHostInfo[nIdx].hevtRead,
                                    g_aHostInfo[nIdx].hevtWrite,
                                    g_aHostInfo[nIdx].hevtClose,
                                    FRAMING_LEGACY_PSTN,
                                    &g_PluggableParams);
        ASSERT(T120_NO_ERROR == rc);

        // ::SetEvent(g_aHostInfo[nIdx].hevtWrite);
    }
#endif

    return 0;
}


/*	
 *	void CreateListenSocket (VOID)
 *	
 *	Functional Description
 *		This function sets up a listening socket.
 *	returns INVALID_SOCKET if there is any error.
 */
#ifdef USE_SOCKET
SOCKET CreateListenSocket(HWND hwnd)
{
	SOCKADDR_IN		socket_control;
	SOCKET          socket_number;

	// Create the listening socket.
	socket_number = ::socket(AF_INET, SOCK_STREAM, 0);
	ASSERT(INVALID_SOCKET != socket_number);

	// The listen socket only waits for FD_ACCEPT msgs.
	int nRet = ::WSAAsyncSelect(socket_number, hwnd, WM_PLUGABLE_SOCKET, FD_ACCEPT);
	ASSERT(SOCKET_ERROR != nRet);
	
	/*
	 * Load the socket control structure with the parameters necessary.
	 *	- Internet socket
	 *	- Let it assign any address to this socket
	 *	- Assign our port number
	 */
	socket_control.sin_family = AF_INET;
	socket_control.sin_addr.s_addr = INADDR_ANY;
	socket_control.sin_port = htons ( PLUGABLE_PORT_NUMBER );

	/* Issue the bind call */
	nRet = ::bind(socket_number, (LPSOCKADDR) &socket_control, sizeof(SOCKADDR_IN));
	ASSERT(SOCKET_ERROR != nRet);

	/*
	 * Issue a listen to WinSock to tell it we are willing to accept calls.
	 * This is a non-blocking listen, therefore we will receive FD_ACCEPT
	 * if someone is trying to call us.
	 */
	nRet =::listen(socket_number, 3 /* LISTEN_QUEUE_SIZE */);
	ASSERT(SOCKET_ERROR != nRet);

	return socket_number;
}
#else
CNullModem * CreateListenModem(void)
{
    DBG_SAVE_FILE_LINE
    CNullModem *p = new CNullModem(g_hDllInst);
    ASSERT(NULL != p);

    TPhysicalError rc;

    rc = p->TPhysInitialize(NULL, 1);
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysConnectRequest("COM1");
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysListen();
    ASSERT(TPHYS_SUCCESS == rc);

    return p;
}
void CloseListenModem(CNullModem *p)
{
    if (NULL != p)
    {
        TPhysicalError rc;

        rc = p->TPhysUnlisten();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysDisconnect();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysTerminate();
        ASSERT(TPHYS_SUCCESS == rc);

        delete p;
    }
}
#endif


#ifdef USE_SOCKET
SOCKET CreateConnectSocket(HWND hwnd, LPSTR pszHostName)
{
    SOCKET  socket_number;
	u_short uPort = PLUGABLE_PORT_NUMBER;
    PHOSTENT phe = NULL;
    SOCKADDR_IN socket_control;
    DWORD dwIPAddress;

    socket_number = ::socket(AF_INET, SOCK_STREAM, 0);
    ASSERT(INVALID_SOCKET != socket_number);

    /* Enable Tx and Rx messages to the window */
    int nRet = ::WSAAsyncSelect(socket_number, hwnd, WM_PLUGABLE_SOCKET,
                           FD_READ | FD_WRITE | FD_CLOSE);
    ASSERT(SOCKET_ERROR != nRet);

    // fill in other info in SockAddr
    ::ZeroMemory(&socket_control, sizeof(socket_control));
    socket_control.sin_family = AF_INET;
    socket_control.sin_port = htons (PLUGABLE_PORT_NUMBER);

    // get server's IP address
    dwIPAddress = ::inet_addr(pszHostName);
    if (dwIPAddress != INADDR_NONE)
    {
        *((PDWORD) &socket_control.sin_addr) = dwIPAddress;
    }
    else
    {
        phe = ::gethostbyname(pszHostName);
        ASSERT(NULL != phe);

        ::CopyMemory(&socket_control.sin_addr, phe->h_addr, phe->h_length);
    }

	/* Attempt a connection to the remote site */
	nRet = ::connect(socket_number, (const struct sockaddr *) &socket_control, sizeof(socket_control));
	ASSERT(SOCKET_ERROR != nRet || WSAEWOULDBLOCK == ::WSAGetLastError());

	return socket_number;
}
#else
CNullModem * CreateConnectModem(LPSTR pszHostName)
{
    DBG_SAVE_FILE_LINE
    CNullModem *p = new CNullModem(g_hDllInst);
    ASSERT(NULL != p);

    TPhysicalError rc;

    rc = p->TPhysInitialize(NULL, 1);
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysConnectRequest("COM1");
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysListen();
    ASSERT(TPHYS_SUCCESS == rc);

    return p;
}
void CloseConnectModem(CNullModem *p)
{
    if (NULL != p)
    {
        TPhysicalError rc;

        rc = p->TPhysUnlisten();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysDisconnect();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysTerminate();
        ASSERT(TPHYS_SUCCESS == rc);

        delete p;
    }
}
#endif



#endif // TEST_PLUGABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\nullmdm.cpp ===
#include "mbftpch.h"
#include "nullmdm.h"


// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT


BYTE    g_szNULLMStartString[] = "NULLMDM";
ULONG   g_nConnID = 0;

DWORD __stdcall TPhysWorkerThreadProc(void *lpv);



CNullModem::CNullModem(HINSTANCE hDllInst)
:
    m_fInitialized(FALSE),
    m_hDllInst(hDllInst),
    m_pfnCallback(NULL),
    m_fListening(FALSE),
    m_hwnd(NULL),
    m_nTransportID(0),
    m_nConnectionID(0),
    m_dwThreadID(0),
    m_hThread(NULL),
    m_hevtOverlapped(NULL),
    m_dwEventMask(0),
    m_fCommPortInUse(FALSE)
{
    ::ZeroMemory(&m_Line, sizeof(m_Line));
    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
    ::ZeroMemory(&m_DefaultTimeouts, sizeof(m_DefaultTimeouts));

    m_hevtOverlapped = ::CreateEvent(NULL, TRUE, FALSE, NULL); // manual reset
    ASSERT(NULL != m_hevtOverlapped);
}


CNullModem::~CNullModem(void)
{
    if (m_fInitialized)
    {
        TPhysTerminate();
    }

    if (NULL != m_hevtOverlapped)
    {
        ::CloseHandle(m_hevtOverlapped);
    }
}


//////////////////////////////////////////////////////////////////////////////
// TPhysInitialize
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysInitialize
(
    TPhysCallback   callback,
    UINT            nTransportID
)
{
    const char *pszNULLMClassName = "COMMWndClass";
    TPhysicalError rc = TPHYS_SUCCESS;

    TRACE_OUT(("TPhysInitialize"));

    //
    // If we have already been initialized then this is a reinit call from
    // the node controller so just do nothing.
    //
    if (! m_fInitialized)
    {
        //
        // zero out the SESSION INFO structure
        //
        ::ZeroMemory(&m_Line, sizeof(m_Line));

        //
        // Store control information
        //
        m_pfnCallback = callback;
        m_nTransportID  = nTransportID;
        m_fInitialized = TRUE;
        m_nConnectionID = ++g_nConnID;

        //
        // Create a window so we can decouple to the node controller context                                                          
        // Register the main window class.  Since it is invisible, leave
        // the wndclass structure sparse.
        //
        WNDCLASS  wc;
        ::ZeroMemory(&wc, sizeof(wc));
        wc.style         = 0;
        wc.lpfnWndProc   = TPhysWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = m_hDllInst;
        wc.hIcon         = NULL;
        wc.hCursor       = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName  =  NULL;
        wc.lpszClassName = pszNULLMClassName;
        ::RegisterClass(&wc);

        //
        // Create the main window.
        //
        m_hwnd = ::CreateWindow(
            pszNULLMClassName,    // See RegisterClass() call.    
            NULL,                // It's invisible!                  
            0,                    // Window style.                
            0,                    // Default horizontal position.
            0,                    // Default vertical position.      
            0,                    // Default width.                  
            0,                    // Default height.                  
            NULL,                // No parent.                      
            NULL,                // No menu.
            m_hDllInst,            // This instance owns this window.
            NULL                // Pointer not needed.              
        );
        if (NULL == m_hwnd)
        {
            ERROR_OUT(( "Failed to create wnd"));
            return(TPHYS_RESULT_FAIL);
        }

        // rc = g_lpfnPTPhysicalInit(TPhysDriverCallback, NULL);
        ASSERT(TPHYS_SUCCESS == rc);
    }
   
    return rc;
}

//////////////////////////////////////////////////////////////////////////////////
// TPhysTerminate                                                                
//                                                                                
// The node controller is shutting down                                            
// Destroy our window and clean up transports.                                    
//////////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysTerminate(void)
{
    TRACE_OUT(("TPhysTerminate"));

    if (! m_fInitialized)
    {
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    //
    // Clean up the PSTN transport
    //
    // g_lpfnPTPhysicalCleanup();

    //
    // Destroy the window
    //
    if (NULL != m_hwnd)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    m_pfnCallback = NULL;
    m_nTransportID = 0;
    m_fInitialized = FALSE;
    
    return(TPHYS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
// TPhysConnectRequest                                                        
//                                                                            
// The node controller wants to place a call and has determined that it        
// first needs a physical modem connection.  Make a call and flag an        
// outgoing call so that when the call comes active we can tell the modem    
// transport to begin negotiation.                                            
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysConnectRequest(LPSTR pszComPort)
{
    TPhysicalError  rc = TPHYS_SUCCESS;
    HANDLE          hCommLink;
    DCB             dcb;
    DWORD           dwWritten;

    TRACE_OUT(("TPhysConnectRequest"));

    if (! m_fInitialized)
    {
        ERROR_OUT(("NULL MODEM OOB not initialized"));
        return TPHYS_RESULT_NOT_INITIALIZED;
    }

    //
    // Select a comm port for the call.
    //
    if (CALL_STATE_IDLE == m_Line.eCallState || CALL_STATE_DROP == m_Line.eCallState)
    {
        //
        // Also prime our local copy of the conninfo structure for use in callbacks
        //
        m_Line.connInfo.resultCode   = 0;
        m_Line.connInfo.connectionID = m_nConnectionID;
    }
    else
    {
        ERROR_OUT(("No comm port is available"));
        return TPHYS_RESULT_COMM_PORT_BUSY;
    }

    // lonchanc: From now on, we can bail out thru the common exit point
    // because the cleanup checks for m_fCommPortInUse.

    //
    // Only alow one at at time
    //
    // lonchanc: g_COMM_Thread_Users is starting from -1
    // why can we simply use a flag???
    if (m_fCommPortInUse)
    {
        ERROR_OUT(("TPhysConnectRequest: Waiting for a previous null mode connection"));
        rc = TPHYS_RESULT_WAITING_FOR_CONNECTION;
        goto bail;
    }
    m_fCommPortInUse = TRUE;

    //
    // Open the comm port
    //
    hCommLink = ::CreateFile(pszComPort,
                             GENERIC_READ | GENERIC_WRITE,
                             0,                    // exclusive access
                             NULL,                 // no security attrs
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, // overlapped I/O
                             NULL );
    if (hCommLink == INVALID_HANDLE_VALUE)
    {
        ERROR_OUT(("TPhysConnectRequest: CreateFile failed. err=%d", ::GetLastError()));
        rc = TPHYS_RESULT_COMM_PORT_BUSY;
        goto bail;
    }

    m_Line.hCommLink = hCommLink;

    //
    // remember the default timeouts
    //
    ::GetCommTimeouts(hCommLink, &m_DefaultTimeouts);


    //
    // Let the other side know that we are trying to connect
    //
    if (! ::EscapeCommFunction(hCommLink, SETDTR))
    {
        ERROR_OUT(("TPhysConnectRequest: Unable to Set DTR: err=%d", ::GetLastError()));
    }

    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
    m_Overlapped.hEvent = m_hevtOverlapped;
    m_dwEventMask = 0;

    ::ResetEvent(m_hevtOverlapped);

    if (! ::WriteFile(hCommLink, g_szNULLMStartString, sizeof(g_szNULLMStartString),
                      &dwWritten, &m_Overlapped))
    {
        DWORD dwErr = ::GetLastError();
        if (ERROR_IO_PENDING != dwErr)
        {
            ERROR_OUT(("TPhysConnectRequest: WriteFile failed. err=%d", dwErr));
            ::ResetEvent(m_hevtOverlapped);
            rc = TPHYS_RESULT_COMM_PORT_BUSY;
            goto bail;
        }
        else
        {
            DWORD dwWait = ::WaitForSingleObject(m_hevtOverlapped, INFINITE);
            BOOL fRet = ::GetOverlappedResult(hCommLink, &m_Overlapped, &dwWritten, TRUE);
            ASSERT(fRet);
            ASSERT(dwWritten == sizeof(g_szNULLMStartString));
        }
    }
    else
    {
        ASSERT(dwWritten == sizeof(g_szNULLMStartString));
    }

    ::ResetEvent(m_hevtOverlapped);

    //
    // Get the default dcb
    //
    ::ZeroMemory(&dcb, sizeof(dcb));
    ::GetCommState(hCommLink, &dcb);
    dcb.BaudRate = 19200;    // Default: BaudRate

    //
    // Set our state so we can get notification in the comm port
    //
    dcb.DCBlength = sizeof(DCB);
    dcb.fBinary = 1;                        // binary mode, no EOF check 
    dcb.fParity = 0;                        // enable parity checking 
    dcb.fOutxCtsFlow = 1;                   // CTS output flow control 
    dcb.fOutxDsrFlow = 0;                   // DSR output flow control 
    dcb.fDtrControl = DTR_CONTROL_ENABLE;   // DTR flow control type 
    dcb.fDsrSensitivity = 0;                // DSR sensitivity 
    dcb.fTXContinueOnXoff = 0;              // XOFF continues Tx 
    dcb.fOutX = 0;                          // XON/XOFF out flow control 
    dcb.fInX = 0;                           // XON/XOFF in flow control 
    dcb.fErrorChar = 0;                     // enable error replacement 
    dcb.fNull = 0;                          // enable null stripping 
    dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;// RTS flow control 
    dcb.XonLim = 0;                         // transmit XON threshold 
    dcb.XoffLim = 0;                        // transmit XOFF threshold 
    dcb.fErrorChar = 0;                     // enable error replacement 
    dcb.fNull = 0;                          // enable null stripping 
    dcb.fAbortOnError = 0;                  // abort reads/writes on error 
    ::SetCommState(hCommLink, &dcb);

    ::PurgeComm(hCommLink, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);

    m_Line.eCallState = CALL_STATE_MAKE;
    m_Line.hevtCall = m_hevtOverlapped;
    m_Line.pstnHandle = (PHYSICAL_HANDLE) hCommLink;
    m_Line.fCaller = TRUE;

    if (! ::SetCommMask(hCommLink,
                EV_RXCHAR |         // Any Character received
                EV_CTS |            // CTS changed state
                EV_DSR |            // DSR changed state
                EV_RLSD|            // RLSD changed state
                EV_RXFLAG))         // Certain character
    {
        ERROR_OUT(("TPhysConnectRequest:  Unable to SetCommMask: err=%d", ::GetLastError()));
    }

    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
    m_Overlapped.hEvent = m_hevtOverlapped;
    m_dwEventMask = 0;

    ::ResetEvent(m_hevtOverlapped);

    if (! ::WaitCommEvent(hCommLink, &m_dwEventMask, &m_Overlapped))
    {
        DWORD dwErr = ::GetLastError();
        if (ERROR_IO_PENDING != dwErr)
        {
            ERROR_OUT(("TPhysConnectRequest: WaitCommEvent failed, err=%d", dwErr));
            m_fCommPortInUse = FALSE;
        }
    }

#if 1
    WorkerThreadProc();
#else
    //
    // If the comm thread doesn't exist, create it now.
    //
    // lonchanc: I am not sure that the thread will exist, because
    // the while loop inside the thread will exit if m_fCommPortInUse is false.
    // If m_fCommPortInUse is true, then we should bail out already.
    //
    ASSERT(NULL == m_hThread);

    //
    // We need to create another thread that will wait on comm events.
    //
    m_hThread = ::CreateThread(NULL, 0, TPhysWorkerThreadProc, this, 0, &m_dwThreadID);
    ASSERT(NULL != m_hThread);
#endif

bail:

    return(rc);
}

//////////////////////////////////////////////////////////////////////////////
// TPhysDisconnect                                                                                                                      
//                                                                              
// The node controller wants us to bring the call down now. We must first   
// ask the transports to close down their physicall connection.                 
//                                                                              
// Note that in the case of the PSTN transport we use a NOWAIT call which   
// completes syncronously.  Because we will not get a follow on confirm         
// we simulate one from here.  If we switch to using WAIT mode then             
// take the event generation code out!                                          
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysDisconnect(void)
{
    TRACE_OUT(("TPhysDisconnect"));

    if (! m_fInitialized)
    {
        ERROR_OUT(( "Not initialised"));
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    TRACE_OUT(("Disconnect call, state %u", m_Line.eCallState));

    //
    // Otherwise it must be a pstn call in progress so end that.  Note  
    // that NC may still think it is MODEM, but we still need to close  
    // PSTN.                                                            
    //
    // g_lpfnPTPhysicalDisconnectRequest(m_aLines[lineID].pstnHandle, TPHYSICAL_NO_WAIT);
    ::PostMessage(m_hwnd, WM_TPHYS_DISCONNECT_CONFIRM, (WPARAM) this, m_Line.pstnHandle);

    //
    // close the comport
    //
    DropCall();

    return(TPHYS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
// TPhysListen/TPhysUnlisten                                                
//                                                                              
// NULLMMAN does very little with listen/unlisten, just sets a state variable 
// that is interrogated to see if we should accept incoming calls.              
//                                                                            
// NOTE - This is different from the Listen/Unlisten that is used to tell   
// the PSTN transport about the presence of an incoming call.                   
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysListen(void)
{
    TRACE_OUT(("TPhysListen"));

    if (! m_fInitialized)
    {
        ERROR_OUT(("TPhysListen: not initialized"));
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    m_fListening = TRUE;

    return(TPHYS_SUCCESS);
}

TPhysicalError CNullModem::TPhysUnlisten(void)
{
    TRACE_OUT(("TPhysUnlisten"));

    if (! m_fInitialized)
    {
        ERROR_OUT(("TPhysUnlisten: not initialized"));
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    m_fListening = FALSE;

    return(TPHYS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
// DropCall - close the comm port
/////////////////////////////////////////////////////////////////////////////
void CNullModem::DropCall(void)
{
    TRACE_OUT(("DropCall"));

    //
    // close the device handle                                              
    //
    if (NULL != m_Line.hCommLink)
    {
        CALL_STATE eCallState = m_Line.eCallState;
        m_Line.eCallState = CALL_STATE_IDLE;

        //
        // If this call is connected it is not using the comm thread
        //
        if (eCallState != CALL_STATE_CONNECTED)
        {
            m_fCommPortInUse = FALSE;
        }

        //
        // restore comm timeouts
        //
        SetCommTimeouts(m_Line.hCommLink, &m_DefaultTimeouts);

        TRACE_OUT(("Closing device handle %x", m_Line.hCommLink));
        ::CloseHandle(m_Line.hCommLink);
        m_Line.hCommLink = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////
//                                                                              
// FUNCTION: PSTNCallback                                                       
//                                                                              
// DESCRIPTION:                                                                 
//                                                                              
// PSTN callback function, called by the PSTN driver with the resuts of         
// TPhysical operations                                                         
//                                                                              
// See MCATTPRT.H for definitions of the parameters                             
//                                                                              
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CALLBACK TPhysDriverCallback(USHORT msg, ULONG lParam, void *userData)
{
    TRACE_OUT(("NULLM_PSTNCallback"));
    TRACE_OUT(("Hit TPhysical callback, %x %lx %lx", msg, lParam, userData));

    CNullModem *p = (CNullModem *) userData;
    BOOL fRet = ::PostMessage(p->GetHwnd(), msg, (WPARAM) p, lParam);
    ASSERT(fRet);

    return TPHYS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          
// FUNCTION:TPhysWndProc                                                      
//                                                                          
// Window procedure used to decouple callback requests                      
//                                                                          
//////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK TPhysWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNullModem *p = (CNullModem *) wParam;
    if (uMsg >= WM_APP)
    {
        return p->TPhysProcessMessage(uMsg, lParam);
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}


LRESULT CNullModem::TPhysProcessMessage(UINT uMsg, LPARAM lParam)
{
    USHORT      rc;
    USHORT      reason;
    ULONG       status;
    LINE_INFO  *pLine;

    if (WM_TPHYS_STATUS_INDICATION == uMsg)
    {
        return 0;
    }
    
    ASSERT(lParam == (LPARAM) m_Line.pstnHandle);

    switch (uMsg)
    {
    case WM_TPHYS_CONNECT_INDICATION:
        TRACE_OUT(("got a WM_TPHYS_CONNECT_INDICATION"));

        m_Line.connInfo.resultCode = TPHYS_RESULT_INUSE;
        m_Line.eCallState = CALL_STATE_CONNECTED;

        if (NULL != m_pfnCallback)
        {
            (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
        }
        break;

    case WM_TPHYS_CONNECT_CONFIRM:
        //
        // The transport has connected OK!  We will take the line   
        // back when the transport pulls DTR down                   
        //
        TRACE_OUT(("got a WM_TPHYS_CONNECT_CONFIRM"));
        m_Line.connInfo.resultCode = TPHYS_RESULT_SUCCESS_ALTERNATE;
        m_Line.eCallState = CALL_STATE_CONNECTED;

        if (NULL != m_pfnCallback)
        {
            (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
        }
        break;

    case WM_TPHYS_DISCONNECT_INDICATION:
    case WM_TPHYS_DISCONNECT_CONFIRM:
        //
        // If the disconnect is the result of a failed connect request  
        // then tell the NC of the failure (Otherwise it is a           
        // successful disconnect)                                       
        //
        if (WM_TPHYS_DISCONNECT_INDICATION == uMsg)
        {
            TRACE_OUT(("WM_TPHYS_DISCONNECT_INDICATION, %ld", lParam));
        }
        else
        {
            TRACE_OUT(("WM_TPHYS_DISCONNECT_CONFIRM, %ld", lParam));
        }
        if ((m_Line.eCallState == CALL_STATE_MAKE)   ||
            (m_Line.eCallState == CALL_STATE_ANSWER) ||
            (m_Line.eCallState == CALL_STATE_CONNECTED))
        {
            TRACE_OUT(( "T120 connection attempt has failed"));
            if (m_Line.fCaller)
            {
                m_Line.connInfo.resultCode = TPHYS_RESULT_CONNECT_FAILED;
                if (NULL != m_pfnCallback)
                {
                    (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
                }
            }
            DropCall();
        }
        else
        {
            //
            // The transport has disconnected OK.  We can take the line 
            // back as soon as the unlisten returns                     
            //
            TRACE_OUT(("T120 has disconnected - unlistening"));
            if (! m_Line.fCaller)
            {
                // g_lpfnPTPhysicalUnlisten(m_Line.pstnHandle);
            }
            else
            {
                //
                // We only drop the call for outgoing requests - leave  
                // incoming calls to drop when the line goes down       
                //
                DropCall();
            }
        }
        break;
    }
    
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
// SetConnectedPort                                                        
//                                                                        
// Waits for comm port changes                                            
//////////////////////////////////////////////////////////////////////////////
void CNullModem::SetConnectedPort(void)
{
    DCB     dcb;

    TRACE_OUT(("SetConnectedPort"));

    ::ZeroMemory(&dcb, sizeof(dcb));

    //
    //  Set comm mask and state
    //
    ::SetCommMask(m_Line.hCommLink, 0);    // RLSD changed state

    ::GetCommState(m_Line.hCommLink, &dcb);
    dcb.DCBlength = sizeof(DCB);
    dcb.fBinary = 1;           // binary mode, no EOF check 
    dcb.fOutxDsrFlow = 0;      // DSR output flow control 
    dcb.fDsrSensitivity = 0;   // DSR sensitivity 
    dcb.fTXContinueOnXoff = 0; // XOFF continues Tx 
    dcb.fOutX = 0;             // XON/XOFF out flow control 
    dcb.fInX = 0;              // XON/XOFF in flow control 
    dcb.fErrorChar = 0;        // enable error replacement 
    dcb.fNull = 0;             // enable null stripping 
    dcb.XonLim = 0;            // transmit XON threshold 
    dcb.XoffLim = 0;           // transmit XOFF threshold 
    ::SetCommState(m_Line.hCommLink, &dcb);
}

//////////////////////////////////////////////////////////////////////////////
// WaitForConnection                                                    
//                                                                        
// Waits for comm port changes                                            
//////////////////////////////////////////////////////////////////////////////
BOOL CNullModem::WaitForConnection(void)
{
    BOOL fRet = FALSE;

    TRACE_OUT(("WaitForConnection"));

    while (TRUE)
    {
        DWORD dwWait = ::WaitForSingleObject(m_hevtOverlapped, COMM_PORT_TIMEOUT);
        TRACE_OUT(("WaitForConnection: WaitForSingleObject returns %d", dwWait));

        ::ResetEvent(m_hevtOverlapped);

        if (dwWait == WAIT_ABANDONED || dwWait == WAIT_TIMEOUT || dwWait == WAIT_FAILED)
        {
            DropCall();
            m_fCommPortInUse = FALSE;
            ERROR_OUT(("WaitForConnection: Unable to WaitCommEvent: error = %d", ::GetLastError()));
            goto Failure;
        }

        ASSERT(m_hevtOverlapped == m_Line.hevtCall);
        if (CALL_STATE_MAKE != m_Line.eCallState && CALL_STATE_ANSWER != m_Line.eCallState)
        {
            ERROR_OUT(("WaitForConnection: Got a bad event = %d", m_hevtOverlapped));
            goto Failure;
        }

        TRACE_OUT(("WaitForConnection: m_dwEventMask = %d", m_dwEventMask));
        switch (m_Line.eCallState)
        {
        case CALL_STATE_MAKE:
            {
                //
                // The other side was connected and cleared DTR
                //
                if (m_dwEventMask & (EV_RXCHAR))
                {
                    ::EscapeCommFunction(m_Line.hCommLink, CLRDTR);
                    ::EscapeCommFunction(m_Line.hCommLink, SETDTR);
                    SetConnectedPort();
                    m_Line.fCaller = FALSE;
                    goto Success;
                }
                //
                // The other side just connected
                //
                else
                if(m_dwEventMask & (EV_DSR | EV_RLSD | EV_CTS))
                {
                    //
                    // Change the state of this connection so we dont get here again
                    //
                    m_Line.eCallState = CALL_STATE_ANSWER;

                    //
                    // Wait sometime so the other side can transition to the wait state
                    //
                    ::Sleep(2000);
                    
                    //
                    // Tell the other side we connected before
                    //
                    ::EscapeCommFunction(m_Line.hCommLink, SETBREAK);

                    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
                    m_Overlapped.hEvent = m_Line.hevtCall;
                    m_dwEventMask = 0;

                    ::ResetEvent(m_Overlapped.hEvent);

                    if (! ::WaitCommEvent(m_Line.hCommLink, &m_dwEventMask, &m_Overlapped))
                    {
                        DWORD dwErr = ::GetLastError();
                        if (ERROR_IO_PENDING != dwErr)
                        {
                            ERROR_OUT(("TPhysConnectRequest:  Unable to WaitCommEvent: error = %d", dwErr));
                            DropCall();
                            goto Failure;
                        }
                    }
                }
            }
            break;
            
        case CALL_STATE_ANSWER:
            {
                ::EscapeCommFunction(m_Line.hCommLink, CLRBREAK);
                SetConnectedPort();
                goto Success;
            }
            break;
        }
    } // while

Success:

    fRet = TRUE;

Failure:

    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
// COMMThread                                                            
//                                                                        
// Waits for comm port changes                                            
//////////////////////////////////////////////////////////////////////////////
DWORD __stdcall TPhysWorkerThreadProc(void *lParam)
{
    return ((CNullModem *) lParam)->WorkerThreadProc();
}


DWORD CNullModem::WorkerThreadProc(void)
{
    ULONG    rc = 0;
    ULONG    dwResult;

    TRACE_OUT(("TPhysWorkerThreadProc"));

    while (m_fCommPortInUse)
    {
        //
        // Wait for connection to happen
        //
        if (WaitForConnection())
        {
            SetBuffers();
            SetTimeouts();

            //
            // Call T120 physicall request
            //
            if (m_Line.fCaller)
            {
                // rc = g_lpfnPTPhysicalConnectRequest(0, // CALL_CONTROL_MANUAL
                //                        &m_Line.hCommLink, NULL, &m_Line.pstnHandle);
            }
            else
            {
                m_Line.connInfo.connectionID = m_nConnectionID;
                m_Line.connInfo.resultCode = TPHYS_SUCCESS;

                if (NULL != m_pfnCallback)
                {
                    (*m_pfnCallback)(WM_TPHYS_CONNECT_INDICATION, &m_Line.connInfo, m_nTransportID);
                }

                // rc = g_lpfnPTPhysicalListen(0, // CALL_CONTROL_MANUAL
                //                        &m_Line.hCommLink, NULL, &m_Line.pstnHandle);
            }
            
            if (rc != 0)
            {
                TRACE_OUT(( "Failed COMM connect, rc %d",rc));
                m_Line.connInfo.resultCode = TPHYS_RESULT_CONNECT_FAILED;

                if (NULL != m_pfnCallback)
                {
                    (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
                }

                DropCall();
            }
            else
            {
                m_Line.eCallState = CALL_STATE_CONNECTED;
                m_Line.connInfo.resultCode = TPHYS_SUCCESS;

                //
                // This comm port doesn't need the thread anymore
                //
                m_fCommPortInUse = FALSE;
            }
        }
        else
        {
            TRACE_OUT(( "Failed COMM connect, rc %d",rc));
            m_Line.connInfo.resultCode = TPHYS_RESULT_CONNECT_FAILED;

            if (NULL != m_pfnCallback)
            {
                (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
            }
            
            //
            // Something went wrong in the wait, get out of the loop
            //
            break;
        }
    }        

    //
    // We are going down.
    //
    if (NULL != m_hThread)
    {
        ::CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    return 0;
}


void CNullModem::SetBuffers(void)
{
    BOOL fRet = ::SetupComm(m_Line.hCommLink, /* rx */ 10240, /* tx */ 1024);
    ASSERT(fRet);
}


void CNullModem::SetTimeouts(void)
{
    COMMTIMEOUTS    com_timeouts;
    ::ZeroMemory(&com_timeouts, sizeof(com_timeouts));
    com_timeouts.ReadIntervalTimeout = 10;
    com_timeouts.ReadTotalTimeoutMultiplier = 0;
    com_timeouts.ReadTotalTimeoutConstant = 100;
    com_timeouts.WriteTotalTimeoutMultiplier = 0;
    com_timeouts.WriteTotalTimeoutConstant = 10000;
    BOOL fRet = ::SetCommTimeouts(m_Line.hCommLink, &com_timeouts);
    ASSERT(fRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\nullmdm.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Header defining Null Modem structures and prototypes                       
//                                                                          
// Copyright(c) Microsoft 1999
//                                                                          
///////////////////////////////////////////////////////////////////////////////

#ifndef _NULL_MODEM_H_
#define _NULL_MODEM_H_


/****************************************************************************/
/* These are valid return codes from TPhys API functions                    */
/*                                                                          */
/*  TPHYS_SUCCESS                                                           */
/*          The function executed properly, without error.                  */
/*  TPHYS_RESULT_INUSE                                                      */
/*          The TPhysInitialize() function failed because the transport     */
/*          is already initialized                                          */
/*  TPHYS_RESULT_FAIL                                                       */
/*          A general failure, such as a memory allocation error has        */
/*          caused the function to fail                                     */
/*  TPHYS_RESULT_NOT_INITIALIZED                                            */
/*          The user is attempting to use a function even though the        */
/*          TPhysInitialize() function failed.                              */
/*  TPHYS_RESULT_CONNECT_FAILED                                             */
/*          The TPhysConnectRequest() function failed.                      */
/*  TPHYS_CONNECT_RESPONSE_FAILED                                           */
/*          The TPhysConnectResponse() function failed.                     */
/*  TPHYS_RESULT_NOT_LISTENING                                              */
/*          The transport is not currently in a listening state             */
/*  TPHYS_RESULT_INVALID_CONNECTION                                         */
/*          The disconnect references an invalid connection handle          */
/*  TPHYS_RESULT_INVALID_ADDRESS                                            */
/*          The supplied address is invalid                                 */
/*  TPHYS_RESULT_CONNECT_REJECTED                                           */
/*          The node controller has successfully rejected ain incoming      */
/*          connection request.                                             */
/*  TPHYS_RESULT_SUCCESS_ALTERNATE                                          */
/*          The TPHYSICAL driver has connected, but with an alternate       */
/*          ADDRESS_TYPE as indicated in the connect_info in the response   */
/****************************************************************************/
typedef enum tagTPhysicalError
{
    TPHYS_SUCCESS                       =   0,
    TPHYS_RESULT_INUSE                  = 100,
    TPHYS_RESULT_FAIL                   = 101,
    TPHYS_RESULT_NOT_INITIALIZED        = 102,
    TPHYS_RESULT_CONNECT_FAILED         = 103,
    TPHYS_CONNECT_RESPONSE_FAILED       = 104,
    TPHYS_RESULT_NOT_LISTENING          = 105,
    TPHYS_RESULT_INVALID_CONNECTION     = 106,
    TPHYS_RESULT_INVALID_ADDRESS        = 107,
    TPHYS_RESULT_CONNECT_REJECTED       = 108,
    TPHYS_RESULT_SUCCESS_ALTERNATE      = 109,
    TPHYS_RESULT_COMM_PORT_BUSY         = 110,
    TPHYS_RESULT_WAITING_FOR_CONNECTION = 111,
}
    TPhysicalError;

/****************************************************************************/
/* Structure TPHYS_CALLBACK_INFO                                            */
/*                                                                          */
/* This structure is passed back as the second parameter to                 */
/* TPhysCallback for CONNECT notifications.  It contains all the            */
/* information necessary for the node controller to establish a logical     */
/* connection over the physical connection                                  */
/*                                                                          */
/* It is the responsibility of the node controller to format and present    */
/* this information to the transport driver during the in-band portion of   */
/* the physical connection establishment.                                   */
/*                                                                          */
/****************************************************************************/

#define TPHYS_MAX_ADDRESS_INFO  64

typedef struct tphys_connect_info
{
    UINT       connectionID;
    UINT       resultCode;
}
    TPHYS_CONNECT_INFO, * PTPHYS_CONNECT_INFO;

typedef UINT        PHYSICAL_HANDLE;

typedef void (CALLBACK *TPhysCallback) (WORD, PTPHYS_CONNECT_INFO, UINT);


// OOB compatible
#define WM_TPHYS_CONNECT_CONFIRM                   (WM_APP + 1)
#define WM_TPHYS_CONNECT_INDICATION                (WM_APP + 2)
#define WM_TPHYS_DISCONNECT_CONFIRM                (WM_APP + 3)
#define WM_TPHYS_DISCONNECT_INDICATION             (WM_APP + 4)
#define WM_TPHYS_STATUS_INDICATION                 (WM_APP + 5)



///////////////////////////////////////////////////////////////////////////////
// Structure containing state information for each NULLMODEM line
///////////////////////////////////////////////////////////////////////////////
typedef enum tagCALL_STATE
{
    CALL_STATE_IDLE         = 0,    // Call is idle
    CALL_STATE_MAKE         = 1,    // Establishing phone connection
    CALL_STATE_ANSWER       = 2,    // Answering a new call
    CALL_STATE_DROP         = 3,    // Dropping the phone connection
    CALL_STATE_CONNECTED    = 4,    // Phone connection established and passed onto TDD.
}
    CALL_STATE;

typedef struct tagLINE_INFO
{
    HANDLE              hevtCall;       // handle to the call
    HANDLE              hCommLink;      // handle to COM device - call
    BOOL                fCaller;        // FALSE = incoming call
    CALL_STATE          eCallState;     // one of the following states
    PHYSICAL_HANDLE     pstnHandle;
    TPHYS_CONNECT_INFO  connInfo;
}
    LINE_INFO;


#define MAX_NULLMODEM_LINES  4


class CNullModem
{
public:

    CNullModem(HINSTANCE);
    ~CNullModem(void);

    TPhysicalError TPhysInitialize(TPhysCallback callback, UINT transport_id);
    TPhysicalError TPhysTerminate(void);
    TPhysicalError TPhysListen(void);
    TPhysicalError TPhysUnlisten(void);
    TPhysicalError TPhysConnectRequest(LPSTR pszComPort);
    TPhysicalError TPhysDisconnect(void);

    DWORD WorkerThreadProc(void);
    HWND GetHwnd(void) { return m_hwnd; }
    LRESULT TPhysProcessMessage(UINT uMsg, LPARAM lParam);
    HANDLE GetCommLink(void) { return m_Line.hCommLink; }

    void SetBuffers(void);
    void SetTimeouts(void);

private:

    void DropCall(void);
    BOOL WaitForConnection(void);
    void SetConnectedPort(void);

private:

    BOOL            m_fInitialized;
    HINSTANCE       m_hDllInst;
    TPhysCallback   m_pfnCallback;
    BOOL            m_fListening;
    HWND            m_hwnd;
    UINT            m_nTransportID;          // ID required by RNC
    UINT            m_nConnectionID;         // next conn ID to allocate   
    LINE_INFO       m_Line;

    HANDLE          m_hThread;
    DWORD           m_dwThreadID;
    HANDLE          m_hevtOverlapped;
    DWORD           m_dwEventMask;
    BOOL            m_fCommPortInUse;
    OVERLAPPED      m_Overlapped;

    COMMTIMEOUTS    m_DefaultTimeouts;
};



LRESULT CALLBACK TPhysWndProc(HWND, UINT, WPARAM, LPARAM);
TPhysicalError CALLBACK TPhysDriverCallback(USHORT msg, ULONG parm, void *userData);

#define COMM_PORT_TIMEOUT 60000    //  60 seconds

#endif // _NULL_MODEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\osshelp.cpp ===
/* file: ossHelp.cpp */

#include "mbftpch.h"

#include "mbftper.h"
#include "osshelp.hpp"
#include "strutil.h"
#include <imcsapp.h>

static int  nInvalidNameCount = 0;
static char szProshareError[] = "ProshareError#";   /*Localization OK*/
static char szNonStandardCompression[] = "NonStandardCompression";  /*Localization OK*/

LONG CreateFileHeader(LPSTR pFileHeader, WORD pduType, ASNMBFTPDU* GenericPDUStruct);

    typedef struct
    {
        unsigned Second : 5;
        unsigned Minute : 6;
        unsigned Hour   : 5;
    } _DOS_Time;

    typedef struct
    {
        unsigned    Day     :   5;
        unsigned    Month   :   4;
        unsigned    Year    :   7;
    } _DOS_Date;



void GenericPDU::FreeMCSBuffer ()
{
        if (m_lpEncodedBuffer != NULL)
        {
                m_pAppletSession->FreeSendDataBuffer((void *) m_lpEncodedBuffer);
                m_lpEncodedBuffer = NULL;
        }
}

GenericPDU::~GenericPDU()
{
    if (m_pAppletSession != NULL)
    {
                FreeMCSBuffer();
    }
        else
        {
                delete m_lpEncodedBuffer;
                m_lpEncodedBuffer = NULL;
        }
}

FileOfferPDU::FileOfferPDU(LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                           LONG FileSize,time_t FileDateTime,
                           ChannelID wChannelID,BOOL bAcknowledge,int RosterInstance,
                           unsigned CompressionFlags,
                           LPCSTR lpszCompressionFormat,
                           int v42bisP1,
                           int v42bisP2) : GenericPDU()
{
    if(lpszFileName)
    {
        lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        lstrcpy(m_szFileName,"");
    }

    m_FileHandle        = iFileHandle;
    m_FileSize          = FileSize;
    m_FileDateTime      = FileDateTime;
    m_DataChannelID     = wChannelID;
    m_bAcknowledge      = bAcknowledge;
    m_RosterInstance    = RosterInstance;
    m_CompressionFlags  = CompressionFlags;
    m_v42bisP1          = v42bisP1;
    m_v42bisP2          = v42bisP2;

    if(lpszCompressionFormat)
    {
        lstrcpyn(m_szCompressionFormat,lpszCompressionFormat,sizeof(m_szCompressionFormat));
    }
    else
    {
        lstrcpy(m_szCompressionFormat,"");
    }
}

unsigned long DecodeTimeDate(GeneralizedTime & ASNDateTime)
{
    _DOS_Time DecodeTime;
    _DOS_Date DecodeDate;

    if(ASNDateTime.utc)
    {
        //GMDateTime.tm_year  = ASNDateTime.year;

        DecodeDate.Year = ASNDateTime.year - 80;
    }
    else
    {

    }

    DecodeDate.Month        = ASNDateTime.month;
    DecodeDate.Day          = ASNDateTime.day;
    DecodeTime.Hour         = ASNDateTime.hour;
    DecodeTime.Minute       = ASNDateTime.minute;
    DecodeTime.Second       = ASNDateTime.second / 2;

    //DecodeTime.tm_isdst     = -1;                  //Make best guess about daylight savings...
    unsigned * Time, * Date;

    Time   =  (unsigned *)&DecodeTime;
    Date   =  (unsigned *)&DecodeDate;

    return(MAKELONG(*Time,*Date));
}





BOOL FileOfferPDU::Encode(void)
{

    ASNMBFTPDU GenericPDUStruct;
    ASNFilename_Attribute_ FileName;
    BOOL bReturn = FALSE;
        //struct tm * lpGMDateTime;

    ClearStruct(&GenericPDUStruct);
    ClearStruct(&FileName);

    GenericPDUStruct.choice = ASNfile_OfferPDU_chosen;

    FileName.value  = m_szFileName;

    //lpGMDateTime =  localtime(&m_FileDateTime);

    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNfilesize = m_FileSize;

    unsigned Date = HIWORD(m_FileDateTime);
    unsigned Time = LOWORD(m_FileDateTime);

    _DOS_Date * lpDate  =  (_DOS_Date *)&Date;
    _DOS_Time * lpTime  =  (_DOS_Time *)&Time;

    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.year   = lpDate->Year + 80;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.month  = lpDate->Month;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.day    = lpDate->Day;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.hour   = lpTime->Hour;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.minute = lpTime->Minute;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.second = lpTime->Second * 2;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.utc    = TRUE;


    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.bit_mask |= ASNfilename_present;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.bit_mask |= ASNdate_and_time_of_creation_present;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.bit_mask |= ASNfilesize_present;

    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNfilename     = &FileName;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_handle     = (ASNHandle)m_FileHandle;
    GenericPDUStruct.u.ASNfile_OfferPDU.data_channel_id = m_DataChannelID;
    GenericPDUStruct.u.ASNfile_OfferPDU.ack_flag        = (ossBoolean)m_bAcknowledge;

    if(m_CompressionFlags & _MBFT_FILE_COMPRESSED)
    {
        if(m_CompressionFlags & _MBFT_STANDARD_COMPRESSSION)
        {
            GenericPDUStruct.u.ASNfile_OfferPDU.bit_mask |= ASNFile_OfferPDU_compression_specifier_present;

            GenericPDUStruct.u.ASNfile_OfferPDU.ASNFile_OfferPDU_compression_specifier.choice = ASNv42bis_parameters_chosen;
            GenericPDUStruct.u.ASNfile_OfferPDU.ASNFile_OfferPDU_compression_specifier.u.ASNv42bis_parameters.p1 = (unsigned short)m_v42bisP1;
            GenericPDUStruct.u.ASNfile_OfferPDU.ASNFile_OfferPDU_compression_specifier.u.ASNv42bis_parameters.p2 = (unsigned short)m_v42bisP2;
        }
    }

        //Specifying a non standard compression format is simply too complex and not worth the effort


    if(m_RosterInstance)
    {
        GenericPDUStruct.u.ASNfile_OfferPDU.bit_mask  |= ASNroster_instance_present;
        GenericPDUStruct.u.ASNfile_OfferPDU.ASNroster_instance = (unsigned short)m_RosterInstance;
    }

        // Get the needed size for the fileHeader                       
        LONG fileOfferPDUSize = CreateFileHeader(NULL, T127_FILE_OFFER << 8, &GenericPDUStruct);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[fileOfferPDUSize];
        if(m_lpEncodedBuffer)
        {
                m_lEncodedDataLength = CreateFileHeader(m_lpEncodedBuffer, (T127_FILE_OFFER << 8 | ASNroster_instance_present << 2), &GenericPDUStruct);
                bReturn = TRUE;
        }

    return(bReturn);
}


FileAcceptPDU::FileAcceptPDU(MBFTFILEHANDLE iFileHandle) : GenericPDU()
{
    m_FileHandle    = iFileHandle;
}

BOOL FileAcceptPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_PDU_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new  char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_PDU_HEADER* pBuff = (T127_FILE_PDU_HEADER*)m_lpEncodedBuffer;

        pBuff->pduType = T127_FILE_ACCEPT;
        pBuff->fileHandle = SWAPWORD(m_FileHandle);
        return TRUE;
        }
        return FALSE;
}

FileRejectPDU::FileRejectPDU(MBFTFILEHANDLE iFileHandle) : GenericPDU()
{
    m_FileHandle    = iFileHandle;
}

BOOL FileRejectPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_REJECT;
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_FileHandle);
        pBuff->errorCode = (ASNfile_not_required << 4);
        return(TRUE);
        }
        return FALSE;
}


FileAbortPDU::FileAbortPDU(ChannelID wDataChannelID,
                           ChannelID wTransmitterID,
                           MBFTFILEHANDLE iFileHandle) : GenericPDU()
{
    m_DataChannelID = wDataChannelID;
    m_TransmitterID = wTransmitterID;
    m_FileHandle    = iFileHandle;
}

BOOL FileAbortPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ABORT_PDU);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_ABORT_PDU* pBuff = (T127_FILE_ABORT_PDU*)m_lpEncodedBuffer;
        pBuff->pduType_PresentFields = T127_FILE_ABORT |
                                                                                                                                        (WORD)((ASNdata_channel_id_present |
                                                                                                                                         ASNtransmitter_user_id_present |
                                                                                                                                         ASNFile_AbortPDU_file_handle_present |
                                                                                                                                         ASNreason_unspecified) << 10) ;
        pBuff->dataChannel = SWAPWORD(m_DataChannelID - 1);
        pBuff->transmitterUserId = SWAPWORD(m_TransmitterID - MIN_ASNDynamicChannelID);
        pBuff->fileHandle = SWAPWORD(m_FileHandle);

        return(TRUE);
    }
    return FALSE;
}

FileStartPDU::FileStartPDU(
                                                   LPCSTR lpszEncodedDataBuffer,
                                                   LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                           LONG FileSize,time_t FileDateTime,
                           LPCSTR lpszDataBuffer,int iDataLength,
                           BOOL bIsEOF,
                           unsigned CompressionFlags,
                           LPCSTR lpszCompressionFormat,
                           int v42bisP1,
                           int v42bisP2,
                                                   IT120AppletSession *pAppletSession)
:
    GenericPDU()
{
        m_pAppletSession = pAppletSession;
    if(lpszFileName)
    {
        lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        lstrcpy(m_szFileName,"");
    }

    m_FileHandle    = iFileHandle;
    m_FileSize      = FileSize;
    m_FileDateTime  = FileDateTime;
    m_lpszDataBuffer= lpszDataBuffer;
    m_bIsEOF        = bIsEOF;
    m_DataLength    = iDataLength;
    m_lpEncodedBuffer = (LPSTR)lpszEncodedDataBuffer;
    m_CompressionFlags  = CompressionFlags;

    if(lpszCompressionFormat)
    {
        lstrcpyn(m_szCompressionFormat,lpszCompressionFormat,sizeof(m_szCompressionFormat));
    }
    else
    {
        lstrcpy(m_szCompressionFormat,"");
    }

    m_v42bisP1    = v42bisP1;
    m_v42bisP2    = v42bisP2;
}

BOOL FileStartPDU::Encode(void)
{
    ASNMBFTPDU GenericPDUStruct;
    ASNFilename_Attribute_ FileName;

    BOOL bReturn = FALSE;

    ClearStruct(&GenericPDUStruct);
    ClearStruct(&FileName);


    GenericPDUStruct.choice = ASNfile_StartPDU_chosen;

    FileName.value  = m_szFileName;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNfilesize = m_FileSize;

    //struct tm * lpGMDateTime =  localtime(&m_FileDateTime);

    unsigned Date = HIWORD(m_FileDateTime);
    unsigned Time = LOWORD(m_FileDateTime);

    _DOS_Date * lpDate  =  (_DOS_Date *)&Date;
    _DOS_Time * lpTime  =  (_DOS_Time *)&Time;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.year   = lpDate->Year + 80;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.month  = lpDate->Month;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.day    = lpDate->Day;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.hour   = lpTime->Hour;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.minute = lpTime->Minute;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.second = lpTime->Second * 2;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.utc    = TRUE;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.bit_mask |= ASNfilename_present;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.bit_mask |= ASNdate_and_time_of_creation_present;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.bit_mask |= ASNfilesize_present;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNfilename     = &FileName;
    GenericPDUStruct.u.ASNfile_StartPDU.file_handle     = (ASNHandle)m_FileHandle;
    GenericPDUStruct.u.ASNfile_StartPDU.eof_flag        = (ossBoolean)m_bIsEOF;
    GenericPDUStruct.u.ASNfile_StartPDU.data.length     = (unsigned)m_DataLength;
    GenericPDUStruct.u.ASNfile_StartPDU.data.value      = (unsigned char FAR *)m_lpszDataBuffer;

    if(m_CompressionFlags & _MBFT_FILE_COMPRESSED)
    {
        if(m_CompressionFlags & _MBFT_STANDARD_COMPRESSSION)
        {
            GenericPDUStruct.u.ASNfile_StartPDU.bit_mask |= ASNFile_StartPDU_compression_specifier_present;

            GenericPDUStruct.u.ASNfile_StartPDU.ASNFile_StartPDU_compression_specifier.choice = ASNv42bis_parameters_chosen;
            GenericPDUStruct.u.ASNfile_StartPDU.ASNFile_StartPDU_compression_specifier.u.ASNv42bis_parameters.p1 = (unsigned short)m_v42bisP1;
            GenericPDUStruct.u.ASNfile_StartPDU.ASNFile_StartPDU_compression_specifier.u.ASNv42bis_parameters.p2 = (unsigned short)m_v42bisP2;
        }
    }

        //Specifying a non standard compression format is simply too complex!!!


        LPSTR pBuff = (LPSTR)GetDataBuffer();

        m_lpEncodedBuffer = pBuff;
        m_lEncodedDataLength = CreateFileHeader(pBuff, T127_FILE_START << 8, &GenericPDUStruct);

        pBuff += m_lEncodedDataLength;

        m_lEncodedDataLength += m_DataLength + sizeof(T127_FILE_START_DATA_BLOCK_HEADER);
        ((T127_FILE_START_DATA_BLOCK_HEADER*)pBuff)->EOFFlag = m_bIsEOF << 7;
        ((T127_FILE_START_DATA_BLOCK_HEADER*)pBuff)->CompressionFormat = 1;
        ((T127_FILE_START_DATA_BLOCK_HEADER*)pBuff)->FileDataSize = SWAPWORD((unsigned)m_DataLength);   // File size in bytes

        bReturn = TRUE;
                                
 return(bReturn);
}

FileDataPDU::FileDataPDU(
                                                LPCSTR lpszEncodedDataBuffer,
                                                MBFTFILEHANDLE iFileHandle,LPCSTR lpszDataBuffer,
                        int iDataLength,
                        BOOL bIsEOF,BOOL bAbort,
                                                IT120AppletSession *pAppletSession)
:
    GenericPDU(pAppletSession, (LPSTR)lpszEncodedDataBuffer),
    m_FileHandle (iFileHandle),
    m_lpszDataBuffer (lpszDataBuffer),
    m_bIsEOF (bIsEOF),
    m_DataLength (iDataLength),
    m_bAbort (bAbort)
{
}

BOOL FileDataPDU::Encode(void)
{
        m_lpEncodedBuffer = (LPSTR)GetDataBuffer();

        if(m_lpEncodedBuffer)
        {       T127_FILE_DATA_HEADER* pBuff = (T127_FILE_DATA_HEADER*)m_lpEncodedBuffer;
                pBuff->PDUHeader.pduType = T127_FILE_DATA;
                pBuff->PDUHeader.fileHandle =  SWAPWORD(m_FileHandle);
                pBuff->DataHeader.EOFFlag = (m_bIsEOF << 7) | (m_bAbort << 6);
                pBuff->DataHeader.FileDataSize =  SWAPWORD((unsigned)m_DataLength);
        }
        m_lEncodedDataLength = m_DataLength + sizeof(T127_FILE_DATA_HEADER);
        return (TRUE);
}


PrivateChannelInvitePDU::PrivateChannelInvitePDU(ChannelID wControlChannelID,
                                                 ChannelID wDataChannelID,
                                                 BOOL bIsBroadcast)  : GenericPDU()
{
    m_ControlChannelID  = wControlChannelID;
    m_DataChannelID     = wDataChannelID;
    m_bIsBroadcast = bIsBroadcast;
}

BOOL PrivateChannelInvitePDU::Encode(void)
{
    BOOL bReturn = FALSE;
        if(m_ControlChannelID >= MIN_ASNDynamicChannelID &&
                m_ControlChannelID <= MAX_ASNDynamicChannelID &&
                m_DataChannelID  >= MIN_ASNDynamicChannelID &&
                m_DataChannelID  <= MAX_ASNDynamicChannelID)
        {
                m_lEncodedDataLength = sizeof(T127_PRIVATE_CHANNEL_INVITE);
        DBG_SAVE_FILE_LINE
                m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
                T127_PRIVATE_CHANNEL_INVITE * pBuff = (T127_PRIVATE_CHANNEL_INVITE *)&m_lpEncodedBuffer[0];
                pBuff->pduType = T127_PRIVATE_CHANNEL_JOIN_INVITE;
                pBuff->ControlChannel = SWAPWORD(m_ControlChannelID - MIN_ASNDynamicChannelID);
                pBuff->DataChannel =  SWAPWORD(m_DataChannelID - MIN_ASNDynamicChannelID);
                pBuff->EncodingMode =   0;      // Encoding for acknowledge mode (FALSE) = 0
                                                                        // Encoding for broadcast mode (TRUE) = 0x80 10000000b

                bReturn = TRUE;
        }
        }

    return(bReturn);
}


PrivateChannelResponsePDU::PrivateChannelResponsePDU(ChannelID wControlChannelID,
                                                     BOOL bJoinedChannel)  : GenericPDU()
{
    m_ControlChannelID  = wControlChannelID;
    m_bJoinedChannel    = bJoinedChannel;
}

BOOL PrivateChannelResponsePDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_REJECT;
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_ControlChannelID - MIN_ASNDynamicChannelID);
        pBuff->errorCode = m_bJoinedChannel ?
                                           static_cast<BYTE>(ASNPrivate_Channel_Join_ResponsePDU_result_successful << 5) :
                                           static_cast<BYTE>(ASNinvitation_rejected << 5);
        return(TRUE);
    }
    return FALSE;
}


NonStandardPDU::NonStandardPDU(LPCSTR lpszEncodedDataBuffer,
                                                                LPCSTR lpszKey,LPVOID lpBuffer,
                                                                unsigned BufferLength,
                                                                IT120AppletSession *pAppletSession)
:
    GenericPDU()
{
        m_pAppletSession = pAppletSession;
    m_lpEncodedBuffer = (LPSTR)lpszEncodedDataBuffer;
        m_szKey = lpszKey;
    m_lpBuffer      = lpBuffer;
    m_BufferLength  = BufferLength;
}

BOOL NonStandardPDU::Encode(void)
{
        BOOL bReturn = FALSE;
        BYTE nonStandardPDUlenght = lstrlen(m_szKey) + 1;
        m_lEncodedDataLength = nonStandardPDUlenght + m_BufferLength + 4;
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
        LPSTR pBuff = m_lpEncodedBuffer;
        if(m_lpEncodedBuffer)
        {

                *pBuff++ = T127_MBFT_NONSTANDARD | ASNh221NonStandard_chosen;
                *pBuff++ = (BYTE)((nonStandardPDUlenght - 4) << 1);
            memcpy(pBuff,m_szKey,nonStandardPDUlenght);
                pBuff += nonStandardPDUlenght;
                if(m_BufferLength > 0x7F)
                {
                        *pBuff++ = LOBYTE(m_BufferLength) & 0x80;       // List of fields
                }
            *pBuff++ = (m_BufferLength &0x7F);
            memcpy(pBuff,m_lpBuffer,m_BufferLength);
            bReturn = TRUE;
        }
    }
    return(bReturn);
}

FileErrorPDU::FileErrorPDU(unsigned iFileHandle,int ErrorType,int ErrorCode)
{
    m_FileHandle        = iFileHandle;
    m_ErrorType         = ErrorType;
    m_ErrorCode         = ErrorCode;
}

BOOL FileErrorPDU::Encode(void)
{
        BYTE sizeOfErrorID = GetLengthFieldSize(m_ErrorCode);

        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER) + sizeOfErrorID;
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_ERROR |(ASNFile_ErrorPDU_file_handle_present >> 6);
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_FileHandle);
        pBuff->errorCode = ((m_ErrorType == MBFT_INFORMATIVE_ERROR) ?
                                                                                                                                        ASNinformative :
                                                                                                                                        (m_ErrorType == MBFT_PERMANENT_ERROR) ?
                                                                                                                                        ASNpermanent_error : ASNtransient_error) << 5;
        return(TRUE);
    }
    return FALSE;
}

MBFTPDUType GenericPDU::DecodePDU
(
    LPSTR               lpEncodedBuffer,
    LONG                lBufferSize,
    class GenericPDU  **lplpGenericPDU,
    LPCSTR             *lpDecodedPDU,
    UserID              MBFTUserID,
    IT120AppletSession *pAppletSession
)
{
    MBFTPDUType ReturnPDUType = EnumUnknownPDU;
    int PDUNumber = ASNMBFTPDU_PDU;
    LPSTR lpDecodedBuffer = NULL;

    *lplpGenericPDU = NULL;

        // Filter the pdu, they are allways in 8 increments 0x0,0x8,0x10....
        if(lpEncodedBuffer)
        {
                switch((BYTE)*lpEncodedBuffer & 0xF8)
                {

                        case T127_FILE_DATA:
                        {
                                TRACE("DecodePDU: T127_FILE_DATA");

                                T127_FILE_DATA_HEADER* pBuff = (T127_FILE_DATA_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileDataPDU(      lpEncodedBuffer,
                                                                                                        SWAPWORD(pBuff->PDUHeader.fileHandle),
                                                                                                        (LPCSTR)lpEncodedBuffer + sizeof(T127_FILE_DATA_HEADER),
                                                                                                        SWAPWORD(pBuff->DataHeader.FileDataSize),
                                                                                                        pBuff->DataHeader.EOFFlag & 0x80 ? TRUE : FALSE,
                                                                                                        pBuff->DataHeader.EOFFlag & 0x40 ? TRUE : FALSE,
                                                                                                        pAppletSession);                                                        
                                ReturnPDUType  = EnumFileDataPDU;
                        }
                        break;
                
                        case T127_FILE_ACCEPT:
                        {
                                TRACE("DecodePDU: T127_FILE_ACCEPT");

                                T127_FILE_PDU_HEADER* pBuff = (T127_FILE_PDU_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileAcceptPDU(SWAPWORD(pBuff->fileHandle));

                                ReturnPDUType  = EnumFileAcceptPDU;

                        }
                        break;

                        case T127_FILE_REJECT:
                        {
                                TRACE("DecodePDU: T127_FILE_REJECT");

                                T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileRejectPDU(SWAPWORD(pBuff->PDUHeader.fileHandle));
                        
                                ReturnPDUType  = EnumFileRejectPDU;
                        }
                        break;

                        case T127_FILE_DENY:
                        {
                                TRACE("DecodePDU: T127_FILE_DENY");

                                T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileDenyPDU(SWAPWORD(pBuff->PDUHeader.fileHandle), pBuff->errorCode >> 4);
                                ReturnPDUType   = EnumFileDenyPDU;
                        }
                        break;

                        case T127_FILE_ERROR:
                        {
                                TRACE("DecodePDU: T127_FILE_ERROR");

                                T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)lpEncodedBuffer;
                                
                                int ErrorType = (pBuff->errorCode >> 5 == ASNpermanent_error) ?
                                                                        MBFT_PERMANENT_ERROR :
                                                                        (pBuff->errorCode >> 5 == ASNtransient_error) ?
                                                                        MBFT_TRANSIENT_ERROR : MBFT_INFORMATIVE_ERROR;


                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileErrorPDU(SWAPWORD(pBuff->PDUHeader.fileHandle), ErrorType, NULL);

                                ReturnPDUType  = EnumFileErrorPDU;
                        }
                        break;

                        case T127_FILE_ABORT:
                        {
                                TRACE("DecodePDU: T127_FILE_ABORT");
                                
                                T127_FILE_ABORT_PDU* pBuff = (T127_FILE_ABORT_PDU*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileAbortPDU(SWAPWORD(pBuff->dataChannel) + 1,
                                                                                           SWAPWORD(pBuff->transmitterUserId)+ MIN_ASNDynamicChannelID,
                                                                                           SWAPWORD(pBuff->fileHandle));

                                ReturnPDUType  = EnumFileAbortPDU;
                        }
                        break;


                        case T127_MBFT_NONSTANDARD:
                        {
                                TRACE("DecodePDU: T127_MBFT_NONSTANDARD");
                                LPSTR pBuff = lpEncodedBuffer + 1;
                                unsigned int  KeyLength = (((BYTE)*pBuff++) >> 1) + 4;
                                LPCSTR lpszKey  = pBuff;

                                pBuff += KeyLength;

                                unsigned int Length = 0;
                                if((BYTE)*pBuff & 0x80)
                                {
                                        Length = (*pBuff++ & 0x7F) << 8;        // List of fields
                                }
                                Length += *pBuff++;

                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new NonStandardPDU(lpEncodedBuffer,lpszKey,pBuff,Length, pAppletSession);

                                ReturnPDUType  = EnumNonStandardPDU;
                        }
                        break;

                        case T127_FILE_OFFER:
                        {
                                TRACE("DecodePDU: T127_FILE_OFFER");
                                
                                BYTE lpszFileName[2*MAX_PATH];

                                LONG FileSize        = 0;
                                unsigned long FileDateTime  = (unsigned long)-1;
                                T127_FILE_OFFER_PDU * pFileOfferPDU = (T127_FILE_OFFER_PDU * )GetFileInfo(lpEncodedBuffer, &lpszFileName[0], &FileSize, &FileDateTime);
                                
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileOfferPDU(     (LPCSTR)lpszFileName,
                                                                                                        SWAPWORD(pFileOfferPDU->FileHandle),
                                                                                                        FileSize,
                                                                                                        FileDateTime,
                                                                                                        SWAPWORD(pFileOfferPDU->ChannelID) + 1,
                                                                                                        pFileOfferPDU->AckFlag ? TRUE : FALSE,
                                                                                                        SWAPWORD(pFileOfferPDU->RosterInstance),
                                                                                                        0,      // CompressionFlags,
                                                                                                        NULL,// lpszCompressionFormat,
                                                                                                        0,      // v42bisP1,
                                                                                                        0);     // v42bisP2

                                ReturnPDUType  = EnumFileOfferPDU;
                }
                        break;

                        case T127_FILE_START:
                        {
                                TRACE("DecodePDU: T127_FILE_START");

                                BYTE lpszFileName[2*MAX_PATH];
                                LONG FileSize        = 0;
                                unsigned long FileDateTime  = (unsigned long)-1;
                                BYTE * pBuff =  GetFileInfo(lpEncodedBuffer, &lpszFileName[0], &FileSize, &FileDateTime);
                                
                                T127_FILE_START_PDU * pFileStartPDU = (T127_FILE_START_PDU * ) pBuff;
                                T127_FILE_START_DATA_BLOCK_HEADER *pFileDataHeader = (T127_FILE_START_DATA_BLOCK_HEADER*)(pBuff + sizeof(T127_FILE_START_PDU));
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileStartPDU(lpEncodedBuffer,
                                                                                                (LPCSTR)lpszFileName,
                                                                                                SWAPWORD(pFileStartPDU->FileHandle),
                                                                                                FileSize,
                                                                                                FileDateTime,
                                                                                                (LPCSTR)pBuff + sizeof(T127_FILE_START_PDU)+sizeof(T127_FILE_START_DATA_BLOCK_HEADER),
                                                                                                SWAPWORD(pFileDataHeader->FileDataSize),
                                                                                                pFileDataHeader->EOFFlag ? TRUE : FALSE,
                                                                                                0,      // CompressionFlags,
                                                                                                NULL,// lpszCompressionFormat,
                                                                                                0,      // v42bisP1,
                                                                                                0,
                                                                                                pAppletSession);        // v42bisP2
                                ReturnPDUType  = EnumFileStartPDU;
                        }
                        break;

                        case T127_FILE_REQUEST:
                        {
                                TRACE("DecodePDU: T127_FILE_REQUEST");

                                BYTE lpszFileName[2*MAX_PATH];

                                LONG FileSize        = 0;
                                unsigned long FileDateTime  = (unsigned long)-1;
                                BYTE * pBuff =  GetFileInfo(lpEncodedBuffer, &lpszFileName[0], &FileSize, &FileDateTime);

                                T127_FILE_OFFER_PDU * pFileRequestPDU = (T127_FILE_OFFER_PDU * ) pBuff;

                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileRequestPDU(NULL,
                                                                                        SWAPWORD(pFileRequestPDU->ChannelID) + 1,
                                                                                        SWAPWORD(pFileRequestPDU->FileHandle));

                                ReturnPDUType   = EnumFileRequestPDU;
                        }
                        break;

                        case T127_DIRECTORY_REQUEST:
                        {
                                TRACE("DecodePDU: T127_FILE_REQUEST");
                LPCSTR lpszPathName = NULL;

                DBG_SAVE_FILE_LINE
                *lplpGenericPDU = new DirectoryRequestPDU(lpszPathName);

                ReturnPDUType   = EnumDirectoryRequestPDU;
                        }
                        break;

                        case T127_MBFT_PRIVILEGE_ASSIGN:
                        {
                                TRACE("DecodePDU: T127_MBFT_PRIVILEGE_ASSIGN");

                                T127_PRIVILEGE_REQUEST_PDU *pBuff = (T127_PRIVILEGE_REQUEST_PDU*)lpEncodedBuffer;

                                unsigned PrivilegeWord = 0;
                                int Index;

                                for(Index = 0;Index < pBuff->nPrivileges; Index++)
                                {
                                        if(!(Index & 0x01))
                                        {
                                                PrivilegeWord <<=4;
                                                PrivilegeWord |= ((pBuff->privileges[Index >> 1] & 0xF0) >> 4);
                                        }
                                        else
                                        {
                                                PrivilegeWord |= (pBuff->privileges[Index >> 1] & 0x0F);
                                        }
                                }

                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU        = new PrivilegeAssignPDU(PrivilegeWord);

                                ReturnPDUType          = EnumPrivilegeAssignPDU;
                        }
                        break;

                        case T127_PRIVATE_CHANNEL_JOIN_INVITE:
                        {
                                TRACE("DecodePDU: T127_PRIVATE_CHANNEL_JOIN_INVITE");

                                T127_PRIVATE_CHANNEL_INVITE * pBuff = (T127_PRIVATE_CHANNEL_INVITE *)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new PrivateChannelInvitePDU(  SWAPWORD(pBuff->ControlChannel) + MIN_ASNDynamicChannelID,
                                                                                                                                SWAPWORD(pBuff->DataChannel) + MIN_ASNDynamicChannelID,
                                                                                                                                pBuff->EncodingMode);

                                ReturnPDUType  = EnumPrivateChannelInvitePDU;
                        }
                        break;

                        case T127_PRIVATE_CHANNEL_JOIN_RESPONSE:
                        {
                                TRACE("DecodePDU: T127_PRIVATE_CHANNEL_JOIN_RESPONSE");

                                T127_PRIVATE_CHANNEL_RESPONSE* pBuff = (T127_PRIVATE_CHANNEL_RESPONSE*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new PrivateChannelResponsePDU(SWAPWORD(pBuff->ControlChannel) + MIN_ASNDynamicChannelID,
                                                                                        pBuff->Response >> 5 == ASNPrivate_Channel_Join_ResponsePDU_result_successful);

                                ReturnPDUType  = EnumPrivateChannelResponsePDU;
                        }
                        break;

                        case T127_DIRECTORY_RESPONSE:
                        case T127_MBFT_PRIVILEGE_REQUEST:
                        default:
                                TRACE("WARNING DecodePDU: Unknown PDU");

                        break;
                }
        }

 return(ReturnPDUType);
}

BOOL FileErrorPDU::ExtractErrorCode(LPCSTR lpszString,
                                    int iLength,
                                    int * lpAPIErrorCode)
{
    BOOL bCodeExtracted = FALSE;

    if(iLength > sizeof(szProshareError))
    {
        if(!_fmemcmp(lpszString,szProshareError,sizeof(szProshareError) - 1))
        {
            bCodeExtracted = TRUE;
            *lpAPIErrorCode = (int) DecimalStringToUINT(&lpszString[sizeof(szProshareError) - 1]);
        }
    }

    return(bCodeExtracted);
}

BOOL FileErrorPDU::XlatErrorCode(int * lpAPIErrorCode,int * lpMBFTErrorCode,
                                 BOOL bXlatToAPI)
{
 BOOL bMatchFound = FALSE;

 static struct
 {
 ASNErrorID         iMBFTErrorCode;
 MBFT_ERROR_CODE    iAPIErrorCode;
 } ErrorXlat[] =  {
   /*{ASNno_reason,                              iMBFT_UNKNOWN_ERROR},*/
   {ASNresponder_error,                        iMBFT_UNKNOWN_ERROR},
   {ASNsystem_shutdown,                        iMBFT_UNKNOWN_ERROR},
   {ASNbft_management_problem,                 iMBFT_UNKNOWN_ERROR},
   {ASNbft_management_bad_account,             iMBFT_UNKNOWN_ERROR},
   {ASNbft_management_security_not_passed,     iMBFT_UNKNOWN_ERROR},
   {ASNdelay_may_be_encountered,               iMBFT_UNKNOWN_ERROR},
   {ASNinitiator_error,                        iMBFT_UNKNOWN_ERROR},
   {ASNsubsequent_error,                       iMBFT_UNKNOWN_ERROR},
   {ASNtemporal_insufficiency_of_resources,    iMBFT_UNKNOWN_ERROR},
   {ASNaccess_request_violates_VFS_security,   iMBFT_UNKNOWN_ERROR},
   {ASNaccess_request_violates_local_security, iMBFT_UNKNOWN_ERROR},
   {ASNconflicting_parameter_values,           iMBFT_UNKNOWN_ERROR},
   {ASNunsupported_parameter_values,           iMBFT_UNKNOWN_ERROR},
   {ASNmandatory_parameter_not_set,            iMBFT_UNKNOWN_ERROR},
   {ASNunsupported_parameter,                  iMBFT_UNKNOWN_ERROR},
   {ASNduplicated_parameter,                   iMBFT_UNKNOWN_ERROR},
   {ASNillegal_parameter_type,                 iMBFT_UNKNOWN_ERROR},
   {ASNunsupported_parameter_types,            iMBFT_UNKNOWN_ERROR},
   {ASNbft_protocol_error,                     iMBFT_UNKNOWN_ERROR},
   {ASNbft_protocol_error_procedure_error,     iMBFT_UNKNOWN_ERROR},
   /*{ASNbft_protocol_error_functional_unit_err, iMBFT_UNKNOWN_ERROR},*/
   {ASNbft_protocol_error_corruption_error,    iMBFT_UNKNOWN_ERROR},
   {ASNlower_layer_failure,                    iMBFT_UNKNOWN_ERROR},
   {ASNtimeout,                                iMBFT_UNKNOWN_ERROR},
   {ASNbad_account,                            iMBFT_UNKNOWN_ERROR},
   {ASNinvalid_filestore_password,             iMBFT_UNKNOWN_ERROR},
   {ASNfilename_not_found,                     iMBFT_UNKNOWN_ERROR},
   {ASNinitial_attributes_not_possible,        iMBFT_UNKNOWN_ERROR},
   {ASNbad_attribute_name,                     iMBFT_UNKNOWN_ERROR},
   {ASNnon_existent_file,                      iMBFT_UNKNOWN_ERROR},
   {ASNfile_already_exists,                    iMBFT_UNKNOWN_ERROR},
   {ASNfile_cannot_be_created,                 iMBFT_FILE_ACCESS_DENIED},
   {ASNfile_busy,                              iMBFT_FILE_SHARING_VIOLATION},
   {ASNfile_not_available,                     iMBFT_FILE_SHARING_VIOLATION},
   {ASNfilename_truncated,                     iMBFT_UNKNOWN_ERROR},
   {ASNinitial_attributes_altered,             iMBFT_UNKNOWN_ERROR},
   {ASNambiguous_file_specification,           iMBFT_UNKNOWN_ERROR},
   {ASNattribute_non_existent,                 iMBFT_UNKNOWN_ERROR},
   {ASNattribute_not_supported,                iMBFT_UNKNOWN_ERROR},
   {ASNbad_attribute_value,                    iMBFT_UNKNOWN_ERROR},
   {ASNattribute_partially_supported,          iMBFT_UNKNOWN_ERROR},
   {ASNbad_data_element_type,                  iMBFT_UNKNOWN_ERROR},
   {ASNoperation_not_available,                iMBFT_UNKNOWN_ERROR},
   {ASNoperation_not_supported,                iMBFT_UNKNOWN_ERROR},
   {ASNoperation_inconsistent,                 iMBFT_UNKNOWN_ERROR},
   {ASNbad_write,                              iMBFT_FILE_IO_ERROR},
   {ASNbad_read,                               iMBFT_FILE_IO_ERROR},
   {ASNlocal_failure,                          iMBFT_UNKNOWN_ERROR},
   {ASNlocal_failure_filespace_exhausted,      iMBFT_INSUFFICIENT_DISK_SPACE},
   {ASNlocal_failure_data_corrupted,           iMBFT_UNKNOWN_ERROR},
   {ASNlocal_failure_device_failure,           iMBFT_UNKNOWN_ERROR},
   {ASNfuture_filesize_increased,              iMBFT_UNKNOWN_ERROR}};

    int Index;

    for(Index = 0;Index < (sizeof(ErrorXlat) / sizeof(ErrorXlat[0]));Index++)
    {
        if(bXlatToAPI)
        {
            if(ErrorXlat[Index].iMBFTErrorCode == *lpMBFTErrorCode)
            {
                *lpAPIErrorCode = ErrorXlat[Index].iAPIErrorCode;
                bMatchFound = TRUE;
            }
        }
        else
        {
            if(ErrorXlat[Index].iAPIErrorCode == *lpAPIErrorCode)
            {
                *lpMBFTErrorCode = ErrorXlat[Index].iMBFTErrorCode;
                bMatchFound = TRUE;
            }
        }

        if(bMatchFound)
        {
            break;
        }
    }

    if(!bMatchFound)
    {
        if(!bXlatToAPI)
        {
            *lpMBFTErrorCode = ASNno_reason;
        }
    }

    return(bMatchFound);
}

FileRequestPDU::FileRequestPDU(LPCSTR lpszFileName,ChannelID wDataChannelID,
                               unsigned uRequestHandle)
{
    if(lpszFileName)
    {
        lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        lstrcpy(m_szFileName,"");
    }

    m_DataChannelID     = wDataChannelID;
    m_uRequestHandle    = uRequestHandle;
}

BOOL FileRequestPDU::Encode(void)
{
    TRACE("*** WARNING (OSSHELP): Attempt to call unimplemented FileRequestPDU::Encode***\n");
    return(FALSE);
}

FileDenyPDU::FileDenyPDU(unsigned uRequestHandle,unsigned uReason)
{
    m_uRequestHandle =     uRequestHandle;
    m_uReason        =     uReason;
}

BOOL FileDenyPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_REJECT;
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_uRequestHandle);
        pBuff->errorCode = m_uReason ?
                                                                 static_cast<BYTE>((ASN_enum2)m_uReason << 4) :
                                                                 static_cast<BYTE>(ASNFile_DenyPDU_reason_unspecified << 4);
        return(TRUE);
    }
    return FALSE;
}

DirectoryRequestPDU::DirectoryRequestPDU(LPCSTR lpszPathName)
{
    if(lpszPathName)
    {
        lstrcpyn(m_szPathName,lpszPathName,sizeof(m_szPathName));
    }
    else
    {
        lstrcpy(m_szPathName,"");
    }
}

BOOL DirectoryRequestPDU::Encode(void)
{
    TRACE("*** WARNING (OSSHELP): Attempt to call unimplemented DirectoryRequestPDU::Encode***\n");
    return(FALSE);
}

DirectoryResponsePDU::DirectoryResponsePDU(unsigned uResult)
{
    m_uResult  =  uResult;
}

BOOL DirectoryResponsePDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(BYTE)*2;
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        m_lpEncodedBuffer[0] = T127_DIRECTORY_RESPONSE;
        m_lpEncodedBuffer[1] = m_uResult << 6;
        return(TRUE);
    }
    return FALSE;
}

PrivilegeRequestPDU::PrivilegeRequestPDU(unsigned wPrivilege)
{
    m_PrivilegeWord   =  wPrivilege;
}

BOOL PrivilegeRequestPDU::Encode(void)
{
    struct
    {
        MBFTPrivilege       iMBFTPrivilege;
        ASNMBFTPrivilege    iASNPrivilege;
    } static PrivilegeArray[] = {{EnumFileTransfer,ASNfile_transmit_privilege},
                                 {EnumFileRequest,ASNfile_request_privilege},
                               {EnumPrivateChannel,ASNcreate_private_privilege},
                               {EnumPriority,ASNmedium_priority_privilege},
                               {EnumAbort,ASNabort_privilege},
                               {EnumNonStandard,ASNnonstandard_privilege}};
        
        int Index;
    BYTE nPrivileges = 0;
        T127_PRIVILEGE_REQUEST_PDU * pBuff;
        BYTE privilege;

    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[sizeof(T127_PRIVILEGE_REQUEST_PDU)];
    if (NULL != m_lpEncodedBuffer)
    {
        pBuff = (T127_PRIVILEGE_REQUEST_PDU*)m_lpEncodedBuffer;

        for(Index = 0;Index < sizeof(PrivilegeArray) / sizeof(PrivilegeArray[0]);
            Index++)
        {
            if(m_PrivilegeWord & PrivilegeArray[Index].iMBFTPrivilege)
            {
                        privilege = PrivilegeArray[Index].iASNPrivilege;
                        if(!(nPrivileges & 0x01))
                        {
                                pBuff->privileges[nPrivileges >> 1] = 0;
                                privilege <<=4;
                        }
                pBuff->privileges[(nPrivileges >> 1)] |= privilege;
                nPrivileges++;
            }
        }

        pBuff->pduType = T127_MBFT_PRIVILEGE_REQUEST;
        pBuff->nPrivileges = nPrivileges;
        m_lEncodedDataLength = (LONG)(2 * sizeof(BYTE) +
                                                ((nPrivileges >> 1) * sizeof(BYTE)) +
                                                ((nPrivileges & 0x1) ? 1 : 0));

        return(TRUE);
    }
    return FALSE;
}

PrivilegeAssignPDU::PrivilegeAssignPDU(unsigned wPrivilege,UserID MBFTUserID)
{
    m_PrivilegeWord   =  wPrivilege;
    m_MBFTUserID      =  MBFTUserID;
}

BOOL PrivilegeAssignPDU::Encode(void)
{
        TRACE("*** WARNING (OSSHELP): Attempt to call unimplemented PrivilegeRequestPDU::Encode***\n");
    return(FALSE);
}

BOOL PrivilegeAssignPDU::XlatPrivilegeCode(unsigned iPrivilegeCode,unsigned * lpMBFTCode)
{
    BOOL bReturn = FALSE;

    struct
    {
        MBFTPrivilege       iMBFTPrivilege;
        ASNMBFTPrivilege    iASNPrivilege;
    } static PrivilegeArray[] = {{EnumFileTransfer,ASNfile_transmit_privilege},
                                 {EnumFileRequest,ASNfile_request_privilege},
                                 {EnumPrivateChannel,ASNcreate_private_privilege},
                                 {EnumPriority,ASNmedium_priority_privilege},
                                 {EnumAbort,ASNabort_privilege},
                                 {EnumNonStandard,ASNnonstandard_privilege}};

    int Index;

    for(Index = 0;Index < sizeof(PrivilegeArray) / sizeof(PrivilegeArray[0]);
        Index++)
    {
        if((unsigned)PrivilegeArray[Index].iASNPrivilege == iPrivilegeCode)
        {
            *lpMBFTCode = PrivilegeArray[Index].iMBFTPrivilege;
            bReturn = TRUE;
            break;
        }
    }

    return(bReturn);
}

unsigned PrivilegeAssignPDU::ConstructPrivilegeWord(LPVOID lpPrivilegeStruct,
                                                     ChannelID MBFTUserID)
{
    struct ASNMBFT_Privilege_AssignPDU::ASN_setof5 * lpNextSet = (struct ASNMBFT_Privilege_AssignPDU::ASN_setof5 *)lpPrivilegeStruct;
    struct ASNMBFT_Privilege_AssignPDU::ASN_setof5::temptag::ASN_setof4 * lpNextPrivilege;

    unsigned Temp,wPrivilegeWord;

    wPrivilegeWord = 0;

    while(lpNextSet)
    {
        if(lpNextSet->value.mbftID == MBFTUserID)
        {
            lpNextPrivilege = lpNextSet->value.mbft_privilege;

            while(lpNextPrivilege)
            {
                Temp = 0;
                XlatPrivilegeCode(lpNextPrivilege->value,&Temp);
                wPrivilegeWord |= Temp;
                lpNextPrivilege = lpNextPrivilege->next;
            }

            break;
        }

        lpNextSet = lpNextSet->next;
    }


    return(wPrivilegeWord);
}

FileEndAcknowledgePDU::FileEndAcknowledgePDU(int iFileHandle)
{
    m_FileHandle    =   iFileHandle;
}

BOOL FileEndAcknowledgePDU::Encode(void)
{
    TRACE("OSSHELP: Invalid attempt to encode FileEndAcknowledgePDU\n");
    return(FALSE);
}

ChannelLeavePDU::ChannelLeavePDU(ChannelID wControlChannelID,int iErrorCode)
{
    m_ChannelID =   wControlChannelID;
    m_ErrorCode        =   iErrorCode;
}

BOOL ChannelLeavePDU::Encode(void)
{
    TRACE("OSSHELP:Invalid attempt to encode ChannelLeavePDU\n");
    return(FALSE);
}





BYTE GetLengthFieldSize (ULONG length)
{
        BYTE size = 0;
        BOOL bLastBitSet = FALSE;
        do
        {
                bLastBitSet = ((BYTE)length & 0x80 ? TRUE : FALSE);
                size++;
        }while(length >>=8);

        if(bLastBitSet)
        {
                size++;
        }

        return (size);
}


BYTE * GetFirstField (BYTE * pBuff, WORD * bufferLength)
{
        BYTE * pFirstField = NULL;
        WORD fieldSize;
        BYTE * pBuffStart = pBuff;
        BYTE numberOfItems = *pBuff++;  
        
        while(numberOfItems --)
        {
                fieldSize = *pBuff++;
                if(fieldSize & 0x80)
                {
                        fieldSize = ((fieldSize & 0x7F) << 8) + *pBuff++;
                }
                if(!pFirstField)
                {
                        pFirstField = pBuff;
                }
                pBuff += fieldSize;
        }
        *bufferLength = (WORD)(pBuff - pBuffStart);
        return ( pFirstField);
}



VOID SetLengthField(BYTE * pBuff, BYTE sizeOfLength, ULONG lengthOfField)
{

        *pBuff = sizeOfLength;
        pBuff += sizeOfLength;
        
        while(sizeOfLength--)
        {
                *pBuff-- = LOBYTE(lengthOfField);
                lengthOfField >>=8;
        }
        
}

VOID GetFileHeaderSize (FILE_HEADER_INFO* fileHeader)
{

        // File Size
        fileHeader->nBytesForFileSize = GetLengthFieldSize(fileHeader->fileSize);

        // File Name
    fileHeader->fileNameSize = lstrlen(fileHeader->fileName);

        // Pdu Size
        fileHeader->pduSize = 1 +       // PDU type
                                        4 +             // File Header bitmask
                                        ((fileHeader->fileNameSize) > 0x7F ? 2 : 1) + // Number of bytes needed to express the size of the file name
                                        1 +             // File name size, if the file name is size is > 0x80, use the first four bits of the previous byte
                                        fileHeader->fileNameSize +
                                        1 +             // Size of data time info
                                        15 +    // yyyymmddhhmmss[utc]
                                        1 +             // number of bytes to hold filesize
                                        fileHeader->nBytesForFileSize + // file size
                                        (fileHeader->pduType == T127_FILE_START ? sizeof(T127_FILE_START_PDU) : sizeof(T127_FILE_OFFER_PDU) );

}


#define DEFAULT_LOCALE_LANGAUGE  (MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
BOOL  IsEnglishLocale(void)
{
        TCHAR szTemp[16];
        TCHAR szLang[16];

        ::LoadString(g_hDllInst, IDS_LANGNAME, szLang, 16);
    if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                                        LOCALE_ILANGUAGE, szTemp, 16))
    {
                // Compare with Englist language
                return (!_StrCmpN(szLang, szTemp, 4));
    }
    return FALSE;
}

BOOL  HasDBCSCharacter(LPSTR pszStr)
{
        while (*pszStr)
        {
                if (IsDBCSLeadByte((BYTE)*pszStr))
                        return TRUE;
                pszStr = ::CharNext(pszStr);
        }
        return FALSE;
}

BYTE* GetFileInfo (LPSTR lpEncodedBuffer, BYTE * lpszFileName, LONG * FileSize, ULONG* FileDateTime )
{
        WORD fieldSize;
        BYTE * pFields;
        DWORD presentFields;
        T127_FILE_OFFER_PRESENT_FIELDS * ppresentFields;

        pFields =  (BYTE*)(lpEncodedBuffer + 1);

        // Present fields
        presentFields  = *pFields++ << 24;
        presentFields |= *pFields++ << 16;
        presentFields |= *pFields++ << 8;
        presentFields |= *pFields++;
        
        if(*lpEncodedBuffer == T127_FILE_START)
        {
                presentFields >>=4;
        }
        
        ppresentFields = (T127_FILE_OFFER_PRESENT_FIELDS *)&presentFields;
        
        // Skip version
        if ((*ppresentFields).wASNprotocol_version_present)
        {
                pFields += 2;   
        }

        // Get the File Name
        if ((*ppresentFields).wASNfilename_present)
        {
                BYTE * pOldField = pFields;
                BYTE * pFileName = GetFirstField(pFields, &fieldSize);
                BYTE fileNameSize = fieldSize - (BYTE)(pFileName - pOldField);
	            memcpy (lpszFileName, pFileName, fileNameSize);
                lpszFileName[fileNameSize] = 0;
                pFields += fieldSize;
        }

        // Skip actions
        if ((*ppresentFields).wASNpermitted_actions_present)
        {
                pFields += 2;
        }

        // Skip contents
        if ((*ppresentFields).wASNcontents_type_present)
        {
                pFields += 4;
        }

        // Get time of Creation
        if ((*ppresentFields).wASNdate_and_time_of_creation_present)
        {

                GeneralizedTime ASNDateTime;

                BYTE dateTime [SIZE_OF_DATE_TIME_STRING + 1];

                memcpy(dateTime,pFields, SIZE_OF_DATE_TIME_STRING + 1);
                
                // Get UTC
                fieldSize = *pFields;
                if(fieldSize == SIZE_OF_DATE_TIME_STRING + 1)
                {
                        ASNDateTime.utc = TRUE;
                        dateTime[fieldSize] = 0;
                }

                // Null terminate the date,time
                ASNDateTime.second = (short)DecimalStringToUINT((LPCTSTR)&dateTime[13]);
                dateTime[13] = 0;
                ASNDateTime.minute = (short)DecimalStringToUINT((LPCTSTR)&dateTime[11]);
                dateTime[11] = 0;
                ASNDateTime.hour = (short)DecimalStringToUINT((LPCTSTR)&dateTime[9]);
                dateTime[9] = 0;
                ASNDateTime.day = (short)DecimalStringToUINT((LPCTSTR)&dateTime[7]);
                dateTime[7] = 0;
                ASNDateTime.month = (short)DecimalStringToUINT((LPCTSTR)&dateTime[5]);
                dateTime[5] = 0;
                ASNDateTime.year = (short)DecimalStringToUINT((LPCTSTR)&dateTime[1]);
                *FileDateTime = DecodeTimeDate(ASNDateTime);

                pFields += fieldSize + 1;
        
        }

        // Skip time of last modification
        if ((*ppresentFields).wASNdate_and_time_of_last_modification_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
                
        }
        // Skip time of last read access
        if ((*ppresentFields).wASNdate_and_time_of_last_read_access_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Get File Size
        if((*ppresentFields).wASNfilesize_present)
        {
                fieldSize = *pFields++;
                while(fieldSize--)
                {
                        *FileSize <<= 8;
                        *FileSize += LOBYTE(*pFields++);
                }
        }

        // Skip Future File Size
        if((*ppresentFields).wASNfuture_filesize_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }


        // Skip ASNaccess_control_present
        if((*ppresentFields).wASNaccess_control_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;

        }

        // Skip private use itemns
        if((*ppresentFields).wASNprivate_use_present)
        {       
                if(*pFields & ASNdirect_reference_present)
                {       pFields++;
                        pFields += *pFields + 1;
                }
                if(*pFields & ASNindirect_reference_present)
                {       pFields++;
                        pFields += *pFields + 1;
                }
        }

        // Skip ASNstructure_present
        if((*ppresentFields).wASNstructure_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Skip ASNapplication_reference_present
        if((*ppresentFields).wASNapplication_reference_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNmachine_present
        if((*ppresentFields).wASNmachine_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNoperating_system_present
        if((*ppresentFields).wASNoperating_system_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Skip ASNrecipient_present
        if((*ppresentFields).wASNrecipient_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNcharacter_set_present
        if((*ppresentFields).wASNcharacter_set_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Skip ASNcompression_present
        if((*ppresentFields).wASNcompression_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNenvironment_present
        if((*ppresentFields).wASNenvironment_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip pathname
        if((*ppresentFields).wASNFileHeader_pathname_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNuser_visible_string_present
        if((*ppresentFields).wASNuser_visible_string_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        return pFields;
}

LONG   CreateFileHeader(LPSTR pFileHeader, WORD pduType, ASNMBFTPDU* GenericPDUStruct)
{

        FILE_HEADER_INFO fileHeaderInfo;
        fileHeaderInfo.fileName = (((((*GenericPDUStruct).u).ASNfile_StartPDU).file_header).ASNfilename)->value;
        fileHeaderInfo.fileSize = ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNfilesize;
        fileHeaderInfo.pduType = HIBYTE(pduType);
        
        GetFileHeaderSize(&fileHeaderInfo);

        //
        // If we don't have a pointer to return the header, just return the size
        //
        if(pFileHeader == NULL)
        {
                return(fileHeaderInfo.pduSize);
        }


    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

        
        LPSTR pFileOfferPDU = pFileHeader;


        // PDU Type
        *pFileOfferPDU++ = HIBYTE(pduType);

        DWORD fieldsInHeader = filename_present|date_and_time_of_creation_present|filesize_present;
        if(HIBYTE(pduType) == T127_FILE_START)
        {
                fieldsInHeader <<=4;
        }

        // Swap Dword
        fieldsInHeader =        ((fieldsInHeader & 0xFF000000) >> 24) +
                                                ((fieldsInHeader & 0x00FF0000) >> 8) +                                          
                                                ((fieldsInHeader & 0x0000FF00) << 8) +
                                                ((fieldsInHeader & 0x000000FF) << 24) |
                                                LOBYTE(pduType);
                                        
        // Present Fields in file header
        ((T127_FILE_HEADER*)pFileOfferPDU)->presentFields = fieldsInHeader;
        pFileOfferPDU +=sizeof(DWORD);

        // File Name
        *pFileOfferPDU++ = 0x01;
        if(fileHeaderInfo.fileNameSize > 0x7F)
        {
                *pFileOfferPDU++ = 0x80 | HIBYTE(fileHeaderInfo.fileNameSize);
                *pFileOfferPDU++ = LOBYTE(fileHeaderInfo.fileNameSize);
                
        }
        else
        {
                *pFileOfferPDU++ = (BYTE)fileHeaderInfo.fileNameSize;
        }
        lstrcpy((CHAR*)pFileOfferPDU, fileHeaderInfo.fileName);
        pFileOfferPDU += fileHeaderInfo.fileNameSize;
                

        // Date and time
        *pFileOfferPDU++ = SIZE_OF_DATE_TIME_STRING + 1;


        wsprintf((CHAR*)pFileOfferPDU, "%04d%02d%02d%02d%02d%02d",
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.year,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.month,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.day,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.hour,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.minute,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.second);

        ASSERT(SIZE_OF_DATE_TIME_STRING == lstrlen(pFileOfferPDU));
        pFileOfferPDU += SIZE_OF_DATE_TIME_STRING;
        *pFileOfferPDU++ = 90; // Base year

        // File size
        SetLengthField((BYTE*)pFileOfferPDU, fileHeaderInfo.nBytesForFileSize, fileHeaderInfo.fileSize);
        pFileOfferPDU += fileHeaderInfo.nBytesForFileSize + sizeof(BYTE);

        if(HIBYTE(pduType) == T127_FILE_START)
        {
                ((T127_FILE_START_PDU*)pFileOfferPDU)->FileHandle =     SWAPWORD((((*GenericPDUStruct).u).ASNfile_StartPDU).file_handle);
        }
        else
        {
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->RosterInstance = SWAPWORD((((*GenericPDUStruct).u).ASNfile_OfferPDU).ASNroster_instance);
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->ChannelID = SWAPWORD((((*GenericPDUStruct).u).ASNfile_OfferPDU).data_channel_id - 1);
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->FileHandle = SWAPWORD((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_handle);
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->AckFlag = 0x80;
        }
        
        return(fileHeaderInfo.pduSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfft\t127pdus.h ===
//=============================================================================
// T127 PDU Types
//=============================================================================

typedef enum T127_PDU_TYPES
{
T127_FILE_OFFER = 0x0,
T127_FILE_ACCEPT = 0x8,
T127_FILE_REJECT = 0x10,
T127_FILE_REQUEST = 0x18,
T127_FILE_DENY = 0x20,
T127_FILE_ERROR = 0x28,
T127_FILE_ABORT = 0x30,
T127_FILE_START = 0x38,
T127_FILE_DATA = 0x40,
T127_DIRECTORY_REQUEST = 0x48,
T127_DIRECTORY_RESPONSE = 0x50,
T127_MBFT_PRIVILEGE_REQUEST = 0x58,
T127_MBFT_PRIVILEGE_ASSIGN = 0x60,
T127_MBFT_NONSTANDARD = 0x68,
T127_PRIVATE_CHANNEL_JOIN_INVITE = 0x70,
T127_PRIVATE_CHANNEL_JOIN_RESPONSE = 0x78
} T127_PDUS;

#pragma pack(1)

typedef struct _T_T127_FILE_PDU_HEADER
{
    BYTE	pduType;
    WORD    fileHandle;          // File size in bytes
} T127_FILE_PDU_HEADER;

typedef struct _T_T127_FILE_DATA_BLOCK_HEADER
{
    BYTE	EOFFlag;
    WORD    FileDataSize;          // File size in bytes
}T127_FILE_DATA_BLOCK_HEADER;


typedef struct _T_T127_PRIVATE_CHANNEL_INVITE
{
	BYTE	pduType;
    WORD	ControlChannel;
    WORD    DataChannel;
    BYTE	EncodingMode;
}T127_PRIVATE_CHANNEL_INVITE;

typedef struct _T_T127_PRIVATE_CHANNEL_RESPONSE
{
	BYTE	pduType;
    WORD	ControlChannel;
    BYTE	Response;
}T127_PRIVATE_CHANNEL_RESPONSE;

typedef struct _T_T127_FILE_START_DATA_BLOCK_HEADER
{
    BYTE	EOFFlag;
    WORD	CompressionFormat;
    WORD    FileDataSize;          // File size in bytes
}T127_FILE_START_DATA_BLOCK_HEADER;

typedef struct _T_T127_FILE_DATA_HEADER
{
	T127_FILE_PDU_HEADER		PDUHeader;	
	T127_FILE_DATA_BLOCK_HEADER	DataHeader;          // File size in bytes
} T127_FILE_DATA_HEADER;

typedef struct _T_127_FILE_ERROR_HEADER
{
	T127_FILE_PDU_HEADER		PDUHeader;	
	BYTE						errorCode;
} T127_FILE_ERROR_HEADER;

typedef struct _T_T127_FILE_HEADER
{
	DWORD	presentFields;
	BYTE	FileHeader;
} T127_FILE_HEADER;

typedef struct _T_T127_FILE_START_PDU
{
	WORD	FileHandle;
}T127_FILE_START_PDU;

typedef struct _T_T127_FILE_ABORT_PDU
{
	WORD	pduType_PresentFields;
	WORD	dataChannel;
	WORD	transmitterUserId;
	WORD	fileHandle;
} T127_FILE_ABORT_PDU;

typedef struct _T_T127_PRIVILEGE_REQUEST_PDU
{
	BYTE	pduType;
	BYTE	nPrivileges;
	BYTE	privileges[3];	// 6/2 privileges.
} T127_PRIVILEGE_REQUEST_PDU;

typedef struct _T_T127_FILE_OFFER_PDU
{
	WORD	ChannelID;
	WORD	FileHandle;
	WORD	RosterInstance;
	BYTE	AckFlag;
} T127_FILE_OFFER_PDU;

typedef struct _T_FILE_HEADER_INFO
{
	BYTE	pduType;
	PSTR	fileName;
	LONG	fileNameSize;
	LONG	fileSize;
	LONG	pduSize;
	BYTE	nBytesForFileSize;
	
} FILE_HEADER_INFO;
typedef struct
{

	unsigned	wASNuser_visible_string_present					:1;	// 00000000 00000000 00000000 0000000? 0000 0001
	unsigned	wASNFileHeader_pathname_present					:1;	// 00000000 00000000 00000000 000000?0 0000 0002
	unsigned	wASNenvironment_present							:1;	// 00000000 00000000 00000000 00000?00 0000 0004
	unsigned	wASNcompression_present							:1;	// 00000000 00000000 00000000 0000?000 0000 0008
	unsigned	wASNcharacter_set_present						:1;	// 00000000 00000000 00000000 000?0000 0000 0010
	unsigned	wASNrecipient_present							:1;	// 00000000 00000000 00000000 00?00000 0000 0020
	unsigned	wASNoperating_system_present					:1;	// 00000000 00000000 00000000 0?000000 0000 0040
	unsigned	wASNmachine_present								:1;	// 00000000 00000000 00000000 ?0000000 0000 0080
	unsigned	wASNapplication_reference_present				:1;	// 00000000 00000000 0000000? 00000000 0000 0100
	unsigned	wASNstructure_present							:1;	// 00000000 00000000 000000?0 00000000 0000 0200
	unsigned	wASNprivate_use_present							:1;	// 00000000 00000000 00000?00 00000000 0000 0400
	unsigned													:1;	// 00000000 00000000 0000X000 00000000 0000 0800
	unsigned	wASNaccess_control_present						:1;	// 00000000 00000000 000?0000 00000000 0000 1000
	unsigned	wASNfuture_filesize_present						:1;	// 00000000 00000000 00?00000 00000000 0000 2000
	unsigned	wASNfilesize_present							:1;	// 00000000 00000000 0?000000 00000000 0000 4000
	unsigned													:3;	// 00000000 000000XX X0000000 00000000 0003 8000
	unsigned	wASNdate_and_time_of_last_read_access_present	:1;	// 00000000 00000?00 00000000 00000000 0004 0000
	unsigned	wASNdate_and_time_of_last_modification_present	:1;	// 00000000 0000?000 00000000 00000000 0008 0000
	unsigned	wASNdate_and_time_of_creation_present			:1;	// 00000000 000?0000 00000000 00000000 0010 0000
	unsigned													:1;	// 00000000 00X00000 00000000 00000000 0020 0000
	unsigned	wASNcontents_type_present						:1;	// 00000000 0?000000 00000000 00000000 0040 0000
	unsigned	wASNpermitted_actions_present					:1;	// 00000000 ?0000000 00000000 00000000 0080 0000
	unsigned	wASNfilename_present							:1;	// 0000000? 00000000 00000000 00000000 0100 0000
	unsigned	wASNprotocol_version_present					:1;	// 000000?0 00000000 00000000 00000000 0200 0000
	
}T127_FILE_OFFER_PRESENT_FIELDS;

#pragma pack()

typedef enum T127_file_header_fields
{
	user_visible_string_present				=	0x00000001,//0x00010000,	//0x00000001
	FileHeader_pathname_present				=	0x00000002,//0x00020000,	//0x00000002
	environment_present						=	0x00000004,//0x00040000,	//0x00000004
	compression_present						=	0x00000008,//0x00080000,	//0x00000008
	character_set_present					=	0x00000010,//0x00100000,	//0x00000010
	recipient_present						=	0x00000020,//0x00200000,	//0x00000020
	operating_system_present				=	0x00000040,//0x00400000,	//0x00000040
	machine_present							=	0x00000080,//0x00800000,	//0x00000080
	application_reference_present			=	0x00000100,//0x00010000,	//0x00000100
	structure_present						=	0x00000200,//0x00020000,	//0x00000200
	private_use_present						=	0x00000400,//0x00040000,	//0x00000400
	access_control_present					=	0x00001000,//0x00100000,	//0x00001000
	future_filesize_present					=	0x00002000,//0x00200000,	//0x00002000
	filesize_present						=	0x00004000,//0x00400000,	//0x00004000
	date_and_time_of_last_read_access_present=	0x00040000,//0x00000400,	//0x00040000
	date_and_time_of_last_modification_present=	0x00080000,//0x00000800,	//0x00080000
	date_and_time_of_creation_present		=	0x00100000,//0x00001000,	//0x00100000
	contents_type_present					=	0x00400000,//0x00004000,	//0x00400000
	permitted_actions_present				=	0x00800000,//0x00000800,	//0x00800000
	filename_present						=	0x01000000,//0x00000001,	//0x01000000
	protocol_version_present				=	0x02000000 //0x00000002 	//0x02000000
}T127_FILE_HEADER_FIELDS;


VOID GetFileHeaderSize (FILE_HEADER_INFO* fileHeader);
BYTE GetLengthFieldSize (ULONG length);
VOID SetLengthField(BYTE * pBuff, BYTE sizeOfLength, ULONG lengthOfField);
BYTE* GetFileInfo (LPSTR lpEncodedBuffer, BYTE * lpszFileName, LONG * FileSize, ULONG* FileDateTime );

#define SWAPWORD(a)      (WORD)(HIBYTE(LOWORD(a)) | (LOBYTE(LOWORD(a)) << 8))

#define MIN_ASNDynamicChannelID 1001
#define MAX_ASNDynamicChannelID 65535
#define SIZE_OF_DATE_TIME_STRING 14	// yyyymmddhhmmss
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\agrp.hpp ===
//
// AGRP.HPP
// WbAttributesGroup
//
// Copyright Microsoft 1998-
//

#ifndef __AGRP_HPP_
#define __AGRP_HPP_


#define FONTBUTTONWIDTH        100
#define FONTBUTTONHEIGHT        23


#define PAGEBTN_WIDTH	23
#define PAGEBTN_HEIGHT	23
#define MAX_NUMCHARS	3


//
// Local defines
//
#define BORDER_SIZE_X        ::GetSystemMetrics(SM_CXEDGE)
#define BORDER_SIZE_Y        ::GetSystemMetrics(SM_CYEDGE)
#define SEPARATOR_SIZE_X     6
#define SEPARATOR_SIZE_Y     6

#define DEFAULT_PGC_WIDTH   (8*24)

enum
{
    PGC_FIRST = 0,
    PGC_PREV,
    PGC_ANY,
    PGC_NEXT,
    PGC_LAST,
    PGC_INSERT,
    NUM_PAGE_CONTROLS
};


//
// Indexedby PGC_ value
//
typedef struct tagPAGECTRL
{
    HBITMAP     hbmp;
    HWND        hwnd;
}
PAGECTRL;


//
// The buttons are all BS_BITMAP
// The edit field is ES_CENTER | ES_MULTILINE | ES_NUMBER | WS_BORDER
//



class WbTool;

//
//
// Class:   WbAttributesGroup
//
// Purpose: Define Whiteboard tool attributes display group
//
//
class WbAttributesGroup
{
public:
    WbAttributesGroup();
    ~WbAttributesGroup();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent, LPCRECT lprc);

    //
    // Display the attributes of the tool passed as parameter
    //
    void DisplayTool(WbTool* pTool);

    //
    // Hide the tool attributes bar.
    //
    void Hide(void);

    //
    // Resizing functions
    //
    void GetNaturalSize(LPSIZE lpsize);


    //
    // Colors
    //
    void SelectColor(WbTool* pTool);
	
    void SetChoiceColor(COLORREF clr)
		{m_colorsGroup.SetCurColor(clr);}

	void OnEditColors( void )
		{m_colorsGroup.OnEditColors();}

    void SaveSettings( void )
        {m_colorsGroup.SaveSettings();}

    //
    // Page Controls
    //
    BOOL IsChildEditField(HWND hwnd);

    UINT GetCurrentPageNumber(void);
    void SetCurrentPageNumber(UINT number);
    void SetLastPageNumber(UINT number);

    void EnablePageCtrls(BOOL bEnable);
    void EnableInsert(BOOL bEnable);

    BOOL RecolorButtonImages();

    HWND    m_hwnd;

    friend LRESULT CALLBACK AGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void OnSize(UINT nType, int cx, int cy);
    void OnCommand(UINT id, UINT code, HWND hwndCtl);

    //
    // Color palette
    //
	WbColorsGroup     m_colorsGroup;

    //
    // Font Button
    //
    HWND        m_hwndFontButton;

    //
    // Page controls
    //
    PAGECTRL    m_uPageCtrls[NUM_PAGE_CONTROLS];
    HFONT       m_hPageCtrlFont;
    int         m_cxPageCtrls;

    void        SetPageButtonNo(UINT pgcCtrl, UINT uiPageNumber);
};


#endif // __AGRP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\agrp.cpp ===
//
// AGRP.CPP
// Tool Attributes Display Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


// Class name
static const TCHAR szAGClassName[] = "WB_AGRP";

//
// Page Control child IDs
// Index is PGC_ value
//
static UINT_PTR g_uPageIds[NUM_PAGE_CONTROLS] =
{
    IDM_PAGE_FIRST,
    IDM_PAGE_PREV,
    IDM_PAGE_ANY,
    IDM_PAGE_NEXT,
    IDM_PAGE_LAST,
    IDM_PAGE_INSERT_AFTER
};



//
// WbAttributesGroup()
//
WbAttributesGroup::WbAttributesGroup(void)
{
    int             i;

    m_hwnd = NULL;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        m_uPageCtrls[i].hbmp = NULL;
        m_uPageCtrls[i].hwnd = NULL;
    }

    m_hPageCtrlFont = NULL;
    m_cxPageCtrls = DEFAULT_PGC_WIDTH;

    m_hwndFontButton = NULL;
}


//
// ~WbAttibutesGroup()
//
WbAttributesGroup::~WbAttributesGroup(void)
{
    int i;

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szAGClassName, g_hInstance);

    //
    // Delete control bitmaps
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        if (m_uPageCtrls[i].hbmp)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
            m_uPageCtrls[i].hbmp = NULL;
        }
    }

    if (m_hPageCtrlFont != NULL)
    {
        ::DeleteFont(m_hPageCtrlFont);
        m_hPageCtrlFont = NULL;
    }

}



//
// Create()
//
BOOL WbAttributesGroup::Create
(
    HWND    hwndParent,
    LPCRECT lpRect
)
{
    SIZE    size;
    RECT    rectCG;
    RECT    rectFSG;
    TCHAR   szFOBStr[256];
    HFONT   hOldFont;
    HDC     hdc;
    int     i;
    BITMAP  bmpInfo;
    int     x, cx;
    int     yLogPix;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = AGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszClassName    = szAGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbAttributesGroup::Create register class failed"));
        return(FALSE);
    }

    // Create the window
    if (!::CreateWindowEx(0, szAGClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN,
        lpRect->left, lpRect->top,
        lpRect->right - lpRect->left, lpRect->bottom - lpRect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Couldn't create WbAttributesGroup window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Create the page control button bitmaps
    //
    if (!RecolorButtonImages())
    {
        ERROR_OUT(("Error getting page button bitmaps"));
        return(FALSE);
    }

    hdc = ::CreateCompatibleDC(NULL);
    yLogPix = ::GetDeviceCaps(hdc, LOGPIXELSY);
    ::DeleteDC(hdc);

    //
    // Create the font for the edit field and buttons
    //
    ::GetObject(m_uPageCtrls[PGC_LAST].hbmp, sizeof(BITMAP), &bmpInfo);
    m_hPageCtrlFont = ::CreateFont(-bmpInfo.bmHeight,
                                0, 0, 0,
                                FW_NORMAL, 0, 0, 0,
                                DEFAULT_CHARSET,
                                OUT_TT_PRECIS,
                                CLIP_DFA_OVERRIDE,
                                DEFAULT_QUALITY,
                                VARIABLE_PITCH | FF_SWISS,
                                "Arial" );
    if (!m_hPageCtrlFont)
    {
        ERROR_OUT(("WbPagesGroup::Create - couldn't create font"));
        return(FALSE);
    }

    //
    // Create the child controls in inverse order, right to left
    //
    x = lpRect->right;

    for (i = NUM_PAGE_CONTROLS - 1; i >= 0; i--)
    {
        x -= BORDER_SIZE_X;

        switch (i)
        {
            case PGC_ANY:
                cx = (3*PAGEBTN_WIDTH)/2;
                break;

            case PGC_FIRST:
            case PGC_LAST:
                // make button fit bitmap width + standard border
                ::GetObject(m_uPageCtrls[i].hbmp, sizeof(BITMAP), &bmpInfo);
                cx = bmpInfo.bmWidth + 2*::GetSystemMetrics(SM_CXFIXEDFRAME); // standard button border
                break;

            default:
                cx = PAGEBTN_WIDTH;
                break;

        }

        x -= cx;

        if (i == PGC_ANY)
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(WS_EX_CLIENTEDGE,
                _T("EDIT"), NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE |
                ES_NUMBER | ES_CENTER | ES_MULTILINE,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP edit field"));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, EM_LIMITTEXT, MAX_NUMCHARS, 0);
            ::SendMessage(m_uPageCtrls[i].hwnd, WM_SETFONT, (WPARAM)m_hPageCtrlFont, 0);
        }
        else
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(0, _T("BUTTON"),
                NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | BS_BITMAP,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP button ID %x", g_uPageIds[i]));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_uPageCtrls[i].hbmp);
        }
    }

    m_cxPageCtrls = lpRect->right - x;

    SetPageButtonNo(PGC_FIRST, 1);
    SetPageButtonNo(PGC_LAST, 1);

    //
    // Create the color palette
    //

    m_colorsGroup.GetNaturalSize(&size);
    rectCG.left = BORDER_SIZE_X;
    rectCG.right = rectCG.left + size.cx;
    rectCG.top = BORDER_SIZE_Y;
    rectCG.bottom = rectCG.top + size.cy;

    if (!m_colorsGroup.Create(m_hwnd, &rectCG))
    {
        ERROR_OUT(("Couldn't create CGRP window"));
        return(FALSE);
    }

    //
    // Create the font button.
    // Now calculate the real size of the button
    //

    hdc = ::GetDC(m_hwnd);
    if (!hdc)
        return(FALSE);

    hOldFont = SelectFont(hdc, (HFONT)::GetStockObject(DEFAULT_GUI_FONT));

    ::LoadString(g_hInstance, IDS_FONTOPTIONS, szFOBStr, 256);
    ::GetTextExtentPoint(hdc, szFOBStr, lstrlen(szFOBStr), &size);

    SelectFont(hdc, hOldFont);
    ::ReleaseDC(m_hwnd, hdc);

    size.cx += 4 * BORDER_SIZE_X;
    size.cy += 4 * BORDER_SIZE_Y;

    m_hwndFontButton = ::CreateWindowEx(0, _T("BUTTON"), szFOBStr,
        WS_CHILD | WS_CLIPSIBLINGS | BS_PUSHBUTTON,
        rectCG.right + SEPARATOR_SIZE_X, 2*BORDER_SIZE_Y,
        max(size.cx, FONTBUTTONWIDTH), max(size.cy, FONTBUTTONHEIGHT),
        m_hwnd, (HMENU)IDM_FONT, g_hInstance, NULL);

    if (!m_hwndFontButton)
    {
        ERROR_OUT(("Couldn't create FONT button"));
        return(FALSE);
    }

    ::SendMessage(m_hwndFontButton, WM_SETFONT, (WPARAM)::GetStockObject(DEFAULT_GUI_FONT),
        FALSE);

    return(TRUE);
}



//
// RecolorButtonImages()
//
BOOL WbAttributesGroup::RecolorButtonImages(void)
{
    int         i;
    HBITMAP     hbmpNew;

    //
    // This creates button bitmaps tied to the 3D colors, and clears the old
    // ones/sets the new ones if the buttons are around.
    //

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // No bitmaps for the edit field
        if (i == PGC_ANY)
            continue;

        hbmpNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(g_uPageIds[i]),
            IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
        if (!hbmpNew)
        {
            ERROR_OUT(("AG::RecolorButtonImages faile to load bitmap ID %d",
                g_uPageIds[i]));
            return(FALSE);
        }

        // Set the new one
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP,
                (LPARAM)hbmpNew);
        }

        // Delete the old one
        if (m_uPageCtrls[i].hbmp != NULL)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
        }

        // Save this one
        m_uPageCtrls[i].hbmp = hbmpNew;

        // Put the page number on top
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            if (i == PGC_FIRST)
            {
                SetPageButtonNo(i, 1);
            }
            else if (i == PGC_LAST)
            {
                SetPageButtonNo(i, g_pwbCore->WBP_ContentsCountPages());
            }
        }
    }

    return(TRUE);
}




//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the attributes group
//
//
void WbAttributesGroup::GetNaturalSize(LPSIZE lpsize)
{
    SIZE    sizeCG;
    SIZE    sizeFSG;
    RECT    rc;

    m_colorsGroup.GetNaturalSize(&sizeCG);

    if (!m_hwndFontButton)
    {
        sizeFSG.cx = FONTBUTTONWIDTH;
        sizeFSG.cy = FONTBUTTONHEIGHT;
    }
    else
    {
        ::GetWindowRect(m_hwndFontButton, &rc);
        sizeFSG.cx = rc.right - rc.left;
        sizeFSG.cy = rc.bottom - rc.top;
    }

    // m_cxPageCtrls includes BORDER_SIZE_X on right side
    lpsize->cx = BORDER_SIZE_X
               + sizeCG.cx
               + SEPARATOR_SIZE_X
               + sizeFSG.cx
               + SEPARATOR_SIZE_X
               + m_cxPageCtrls;

    sizeFSG.cy = max(sizeFSG.cy, PAGEBTN_HEIGHT) + BORDER_SIZE_Y;
    lpsize->cy = BORDER_SIZE_Y
                + max(sizeCG.cy, sizeFSG.cy)
                + BORDER_SIZE_Y;
}


//
// IsChildEditField()
//
BOOL WbAttributesGroup::IsChildEditField(HWND hwnd)
{
    return(hwnd == m_uPageCtrls[PGC_ANY].hwnd);
}


//
// GetCurrentPageNumber()
//
UINT WbAttributesGroup::GetCurrentPageNumber(void)
{
    return(::GetDlgItemInt(m_hwnd, IDM_PAGE_ANY, NULL, FALSE));
}


//
// SetCurrentPageNumber()
//
void WbAttributesGroup::SetCurrentPageNumber(UINT number)
{
    ::SetDlgItemInt(m_hwnd, IDM_PAGE_ANY, number, FALSE);
}


//
// SetLastPageNumber()
//
void WbAttributesGroup::SetLastPageNumber(UINT number)
{
    SetPageButtonNo(PGC_LAST, number);
}


//
// EnablePageCtrls()
//
void WbAttributesGroup::EnablePageCtrls(BOOL bEnable)
{
    int i;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        ::EnableWindow(m_uPageCtrls[i].hwnd, bEnable);
    }
}


//
// EnableInsert()
//
void WbAttributesGroup::EnableInsert(BOOL bEnable)
{
    ::EnableWindow(m_uPageCtrls[PGC_INSERT].hwnd, bEnable);
}


//
// AGWndProc()
//
LRESULT CALLBACK AGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbAttributesGroup * pag = (WbAttributesGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pag = (WbAttributesGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pag);

            pag->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pag);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pag);
            pag->m_hwnd = NULL;
            break;

        case WM_SIZE:
            ASSERT(pag);
            pag->OnSize((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_COMMAND:
            ASSERT(pag);
            pag->OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                    GET_WM_COMMAND_CMD(wParam, lParam),
                    GET_WM_COMMAND_HWND(wParam, lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    OnSize
//
// Purpose:     The tool window has been resized
//
//
void WbAttributesGroup::OnSize(UINT, int, int)
{
    RECT    rc;
    int     i;
    int     x;
    RECT    rcT;

    //
    // We haven't created our children yet.
    //
    if (!m_uPageCtrls[0].hwnd)
        return;

    ::GetClientRect(m_hwnd, &rc);
    x = rc.right - m_cxPageCtrls;

    //
    // Move the page controls to be right justified.
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // Get width of control
        ::GetWindowRect(m_uPageCtrls[i].hwnd, &rcT);
        rcT.right -= rcT.left;

        ::MoveWindow(m_uPageCtrls[i].hwnd, x, 2*BORDER_SIZE_Y,
            rcT.right, PAGEBTN_HEIGHT, TRUE);

        //
        // Move to the next one
        //
        x += rcT.right + BORDER_SIZE_X;
    }

    //
    // The color palette and font button are left justified, no need to
    // move them.
    //
}



//
// SetPageButtonNo()
//
// Updates the page text in the first/last button
//
void WbAttributesGroup::SetPageButtonNo(UINT pgcIndex, UINT uiPageNumber )
{
    HDC     hdc;
    BITMAP  bmpInfo;
    HBITMAP hbmp;
    HFONT   hOldFont;
    HBITMAP hOldBitmap;
    RECT    rectNumBox;
    TCHAR   NumStr[16];
    TEXTMETRIC tm;
    HWND    hwndButton;

    MLZ_EntryOut(ZONE_FUNCTION, "WbAttributesGroup::SetPageButtonNo");

    hwndButton = m_uPageCtrls[pgcIndex].hwnd;
    hbmp = m_uPageCtrls[pgcIndex].hbmp;

    ASSERT(hwndButton);
    ASSERT(hbmp);
    ASSERT(m_hPageCtrlFont);

    ::GetObject(hbmp, sizeof (BITMAP), (LPVOID)&bmpInfo);

    hdc = ::CreateCompatibleDC(NULL);
    hOldFont = SelectFont(hdc, m_hPageCtrlFont);
    hOldBitmap = SelectBitmap(hdc, hbmp);
    ::GetTextMetrics(hdc, &tm);

    rectNumBox.left = 10;
    rectNumBox.top = -(tm.tmInternalLeading/2);
    rectNumBox.right = bmpInfo.bmWidth;
    rectNumBox.bottom = bmpInfo.bmHeight;

    SelectBrush(hdc, ::GetSysColorBrush( COLOR_3DFACE ) );
    ::SetTextColor(hdc, ::GetSysColor( COLOR_BTNTEXT ) );
    ::SetBkColor(hdc, ::GetSysColor( COLOR_3DFACE ) );

    ::PatBlt(hdc, rectNumBox.left, rectNumBox.top,
        rectNumBox.right - rectNumBox.left, rectNumBox.bottom - rectNumBox.top,
        PATCOPY);

    wsprintf(NumStr, "%d", uiPageNumber);
    ::DrawText(hdc, NumStr, -1, &rectNumBox, DT_CENTER);

    SelectFont(hdc, hOldFont);
    SelectBitmap(hdc, hOldBitmap);

    ::DeleteDC(hdc);

    ::InvalidateRect(hwndButton, NULL, TRUE);
    ::UpdateWindow(hwndButton);
}



//
//
// Function:    DisplayTool
//
// Purpose:     Display a tool in the attributes group
//
//
void WbAttributesGroup::DisplayTool(WbTool* pTool)
{
    SIZE    size;

    // make width bar, etc, obey locks (bug 433)
    if (WB_Locked())
    {
        if (g_pMain->m_WG.m_hwnd != NULL)
        {
            ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_HIDE);
        }
        Hide();
        return;
    }

    // Display the colors group if necessary
    if (!pTool->HasColor())
    {
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);
    }
    else
    {
        // Change the color button to match the tool
        m_colorsGroup.SetCurColor(pTool->GetColor());

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(m_colorsGroup.m_hwnd))
        {
            ::ShowWindow(m_colorsGroup.m_hwnd, SW_SHOW);
        }
    }

    // Display the widths group if necessary
    if( (!pTool->HasWidth()) || (!g_pMain->IsToolBarOn()) )
    {
        ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_HIDE);
    }
    else
    {
        UINT uiWidthIndex = pTool->GetWidthIndex();

        // If the width index isn't valid, then pop up all the buttons
        if (uiWidthIndex < NUM_OF_WIDTHS)
        {
            // Tell the widths group of the new selection
            g_pMain->m_WG.PushDown(uiWidthIndex);
        }

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(g_pMain->m_WG.m_hwnd))
        {
            ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_SHOW);
        }
    }

    // The font sample group is visible for text and select tools
    if (!pTool->HasFont())
    {
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
    }
    else
    {
        if (!::IsWindowVisible(m_hwndFontButton))
        {
            ::ShowWindow(m_hwndFontButton, SW_SHOW);
        }
    }
}


//
//
// Function:    Hide.
//
// Purpose:     Hide the tool attributes bar.
//
//
void WbAttributesGroup::Hide(void)
{
    if (m_colorsGroup.m_hwnd != NULL)
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);

    if (m_hwndFontButton != NULL)
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
}

//
//
// Function:    SelectColor
//
// Purpose:     Set the current color
//
//
void WbAttributesGroup::SelectColor(WbTool* pTool)
{
    if (pTool != NULL)
    {
        pTool->SetColor(m_colorsGroup.GetCurColor());
    }
}




//
// This forwards all button commands to our main window
//
void WbAttributesGroup::OnCommand(UINT id, UINT cmd, HWND hwndCtl)
{
    switch (id)
    {
        case IDM_PAGE_FIRST:
        case IDM_PAGE_PREV:
        case IDM_PAGE_NEXT:
        case IDM_PAGE_LAST:
        case IDM_PAGE_INSERT_AFTER:
        case IDM_FONT:
            if (cmd == BN_CLICKED)
            {
                ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(id, cmd, hwndCtl));
            }
            break;

        case IDM_PAGE_ANY:
            if (cmd == EN_SETFOCUS)
            {
                ::SendMessage(hwndCtl, EM_SETSEL, 0, (LPARAM)-1);
                ::SendMessage(hwndCtl, EM_SCROLLCARET, 0, 0);
            }
            break;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\ccl32.hpp ===
//
// CCL32.HPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

#ifndef CCL32_HPP
#define CCL32_HPP


#define HLP_MENU_ITEM_OFFSET	0x10000

	
#define HLP_BASE				600
enum
{
    IDH_CONTENTS = HLP_BASE + 1,
    IDH_SEARCH,
    IDH_ABOUT,
    IDH_HELPHELP,
    HLP_PROCESSED
};



#define HELPID_WBSAVEASDLG      4070
#define HELPID_WBFILEMENU       4140
#define HELPID_WBEDITMENU       4150
#define HELPID_WBVIEWMENU       4160
#define HELPID_WBTOOLSMENU      4170
#define HELPID_WBOPTIONSMENU    4180
#define HELPID_WBHELPMENU       4190
#define HELPID_WBWIDTHMENU      4210
#define HELPID_WBSYSTEMMENU     4300


//
// IMM32 stuff
//
typedef HIMC (WINAPI * IGC_PROC)(HWND);
typedef BOOL (WINAPI * INI_PROC)(HIMC, DWORD, DWORD, DWORD);


extern void  UT_CaptureMouse( HWND   hwnd );
extern void  UT_ReleaseMouse( HWND  hwnd );



//
// Option entry names
//

#define OPT_MAIN_TOOLBARVISIBLE         "ToolBarVisible"
#define OPT_MAIN_STATUSBARVISIBLE       "StatusBarVisible"
#define OPT_MAIN_MAXIMIZED              "Maximized"
#define OPT_MAIN_MINIMIZED              "Minimized"
#define OPT_MAIN_MAINWINDOWRECT         "MainWindowPosition"
#define OPT_MAIN_SELECTWINDOW_NOTAGAIN  "GrabWindow_dontwarn"
#define OPT_MAIN_SELECTAREA_NOTAGAIN    "GrabArea_dontwarn"
#define OPT_MAIN_COLORPALETTE		    "ColorPalette"
#define OPT_MAIN_CUSTOMCOLORS		    "CustomColors"

#define DFLT_MAIN_TOOLBARVISIBLE        TRUE
#define DFLT_MAIN_STATUSBARVISIBLE      TRUE			
#define DFLT_MAIN_MAXIMIZED             FALSE			
#define DFLT_MAIN_MINIMIZED             FALSE			
#define DFLT_MAIN_SELECTWINDOW_NOTAGAIN FALSE			
#define DFLT_MAIN_SELECTAREA_NOTAGAIN   FALSE			



//
// Settings routines
//

//
// GetIntegerOption retrieves and converts an option string to a long.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
LONG OPT_GetIntegerOption(LPCSTR cstrOptionName,
                          LONG lDefault = 0L);

//
// GetBooleanOption retrieves and converts an option string to a boolean
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_GetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bDefault = FALSE);

//
// GetStringOption  retrieves a string option (no conversion).
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetStringOption(LPCSTR cstrOptionName,
                            LPSTR pcDefault,
                            UINT size);

//
// GetDataOption    retrieves an option string and parses it into an
//                  array of hex bytes.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
int OPT_GetDataOption(LPCSTR optionName,
                      int   iBufferLength,
                      BYTE* pbBuffer);

//
// GetWindowRectOption  retrieves a option string and parses it into a
//                      rectangle representing the corners of the
//                  window.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetWindowRectOption(LPCSTR optionName, LPRECT lprc, LPCRECT lprcDefault);

//
// SetStringOption  writes a string option (no conversion).
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetStringOption(LPCSTR cstrOptionName,
                         LPCSTR cstrValue);

//
// SetBooleanOption writes a boolean option
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bValue);

//
// SetIntegerOption write an integer option
//                  Returns TRUE if the option was successfully written.
	
//
BOOL OPT_SetIntegerOption(LPCSTR cstrOptionName,
                          LONG  lValue);

//
// SetWindowRectOption  write a window rectangle option.
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetWindowRectOption(LPCSTR optionName,
                             LPCRECT lpwindowRect);

//
// SetDataOption    writes a data option.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_SetDataOption(LPCSTR optionName,
                       int   iBufferLength,
                       BYTE* pbBuffer);

BOOL OPT_Lookup(LPCSTR cstrOptionName,
                          LPCSTR cstrResult,
                          UINT size);




//
//
// Class:   WbPrinter
//
// Purpose: Printer class including cancellation dialog
//
//
class WbPrinter
{
public:
    //
    // Constructor
    //
    // The parameter specifies the printer to be used. Under Windows this
    // value can be obtained from the Common Print Dialog.
    //
    WbPrinter(LPCTSTR szDeviceName);
    ~WbPrinter(void);

    void    SetPrintPageNumber(int nPageNumber);

    // Return TRUE if an error has occurred
    BOOL    Error(void)       { return (m_bAborted || (m_nPrintResult < 0)); };

    // Return TRUE if the user has aborted the print
    BOOL    Aborted(void)     { return m_bAborted; };

    // Return the last result code from a print function call
    int     PrintResult(void) { return m_nPrintResult; };

    //
    // Document manipulation functions
    //

    // Start a new print job
    int StartDoc(HDC hdc, LPCTSTR cstrDocName, int nStartPage);

    // Start a new page
    int StartPage(HDC hdc, int nPageNumber);

    // Indicate that the page is now complete
    int EndPage(HDC hdc);

    // Indicate that the document is complete
    int EndDoc(HDC hdc);

    // Abort the print job
    int AbortDoc(void);

protected:
    HWND    m_hwndDialog;

    //
    // Device and port name for this printer
    //
    LPCTSTR m_szDeviceName;
    TCHAR   m_szPrintPageText[_MAX_PATH];

    //
    // Internal state variables
    //
    int     m_nPrintResult;
    BOOL    m_bAborted;

    void    StopDialog(void);

    //
    // Friend callback routine
    //
    friend BOOL CALLBACK AbortProc(HDC, int);
    friend INT_PTR CALLBACK CancelPrintDlgProc(HWND, UINT, WPARAM, LPARAM);
};




//
// Defines for palettes
//
#define PALVERSION  0x300
#define MAXPALETTE  256     

HPALETTE CreateSystemPalette(void);
HPALETTE CreateColorPalette(void);


HBITMAP FromScreenAreaBmp(LPCRECT lprc);


UINT        DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi);
UINT        DIB_PaletteLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_DataLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_TotalLength(LPBITMAPINFOHEADER lpbi);

HPALETTE    DIB_CreatePalette(LPBITMAPINFOHEADER lpbi);
LPSTR       DIB_Bits(LPBITMAPINFOHEADER lpbi);

LPBITMAPINFOHEADER  DIB_FromBitmap(HBITMAP hBitmap, HPALETTE hPalette, BOOL fGHandle);
LPBITMAPINFOHEADER  DIB_FromScreenArea(LPCRECT lprc);
LPBITMAPINFOHEADER  DIB_Copy(LPBITMAPINFOHEADER lpbi);



//
// Extra windows messages for the Whiteboard
//
enum
{
    WM_USER_GOTO_USER_POSITION  =   WM_USER,
    WM_USER_GOTO_USER_POINTER,
    WM_USER_JOIN_CALL,
    WM_USER_DISPLAY_ERROR,
    WM_USER_UPDATE_ATTRIBUTES,
    WM_USER_JOIN_PENDING_CALL,
    WM_USER_PRIVATE_PARENTNOTIFY
};


//
// Internal error codes
//

#define WBFE_RC_BASE       (WB_LAST_RC - 20)

enum
{
    WBFE_RC_WINDOWS = WBFE_RC_BASE,
    WBFE_RC_WB,
    WBFE_RC_JOIN_CALL_FAILED,
    WBFE_RC_CM,
    WBFE_RC_AL,
    WBFE_RC_PRINTER
};

//
// The following functions can be found in wwbapp.cpp
//

//
// Functions displaying a message box from the string resources specified
//
int Message(HWND hwndOwner,
            UINT uiCaption,
            UINT uiMessage,
            UINT uiStyle = (MB_OK | MB_ICONEXCLAMATION));

//
// Functions displaying a message box from return codes
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
// Default exception handler
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
//
// Class:   DCWbPointerColorMap
//
// Purpose: Map from pointer color to pointer structures
//
//
class DCWbColorToIconMap : public COBLIST
{

  public:
    //
    // Destructor
    //
    ~DCWbColorToIconMap(void);
};




//
// BOGUS LAURABU TEMP!
// StrArray
//

#define ALLOC_CHUNK     8

class StrArray
{
public:
	StrArray();
	~StrArray();

	int GetSize() const { return(m_nSize); }
	void SetSize(int nNewSize);

	// Clean up
	void RemoveAll() { SetSize(0); }

	// Adding elements
	void SetAt(int nIndex, LPCTSTR newElement);
	void SetAtGrow(int nIndex, LPCTSTR newElement);
	void Add(LPCTSTR newElement);

	// overloaded operator helpers
	LPCTSTR operator[](int nIndex) const;

// Implementation
protected:
    void ClearOut();

	LPCTSTR * m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
};

char *  StrTok (
        char * string,
        char * control
        );

#endif // CCL32_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\cgrp.hpp ===
//
// CGRP.HPP
// WbColorsGroup
//
// Copyright Microsoft 1998-
//

#ifndef CGRP_HPP
#define CGRP_HPP



#define NUMROWS			2
#define NUMCOLS			14
#define NUMCLRPANES		(NUMROWS*NUMCOLS + 1) // palette + current one
#define INDEX_CHOICE    (NUMCLRPANES-1)     // last one
#define NUMCUSTCOLORS	16

#define CLRPANE_HEIGHT	16
#define CLRPANE_WIDTH	CLRPANE_HEIGHT
#define CLRPANE_BLACK	RGB( 0,0,0 )
#define CLRPANE_WHITE	RGB( 255,255,255 )


#define CLRCHOICE_HEIGHT    (NUMROWS * CLRPANE_HEIGHT)
#define CLRCHOICE_WIDTH     CLRCHOICE_HEIGHT


//
// Colors window proc
//
class WbColorsGroup
{
public:
	WbColorsGroup();
	~WbColorsGroup();
	virtual BOOL Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

	void SaveSettings( void );

    COLORREF GetCurColor(void);
    void    SetCurColor(COLORREF clr);
	void    OnEditColors( void );

    HWND    m_hwnd;

    friend  LRESULT CALLBACK CGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void     OnPaint(void);
    void     OnLButtonDown(UINT nFlags, int x, int y);
    void     OnLButtonDblClk(UINT nFlags, int x, int y);

	int      m_nLastColor;
	COLORREF m_crColors[ NUMCLRPANES ];
	HBRUSH   m_hBrushes[ NUMCLRPANES ];
	COLORREF m_crCustomColors[ NUMCUSTCOLORS ];

	COLORREF GetColorOfBrush( int nColor );
	void     SetColorOfBrush( int nColor, COLORREF crNewColor );
    void     SetColorOfPane(int nColor, COLORREF clr);

	COLORREF DoColorDialog( int nColor );
	void     ClickOwner( void );
};



#endif // CGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\ccl32.cpp ===
//
// CCL32.CPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>

LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam );



HHOOK   g_utMouseHookHandle = NULL;
HWND    g_utCaptureWindow = NULL;





void UT_CaptureMouse( HWND   hwnd )
{
	// disable asynchronous input so we don't lose capture because the
	// left button isn't down
    g_utMouseHookHandle = SetWindowsHookEx( WH_JOURNALRECORD,
                                              DummyMouseHookProc,
                                              g_hInstance,
                                              NULL );

    if( g_utMouseHookHandle == NULL )
    {
        WARNING_OUT(("Failed to insert JournalRecord hook"));
	}

	// grap mouse
    ::SetCapture(hwnd);
    g_utCaptureWindow = hwnd;
}


void UT_ReleaseMouse( HWND  hwnd )
{
    ::ReleaseCapture();
    g_utCaptureWindow = NULL;

    if (g_utMouseHookHandle != NULL )
	{
		// le go my lego
        ::UnhookWindowsHookEx( g_utMouseHookHandle );
        g_utMouseHookHandle = NULL;
	}
}


LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam )
{
    return( CallNextHookEx( g_utMouseHookHandle, code, wParam, lParam ) );
}




//
// General definitions
//
#define MAX_OPTIONS_LINE_LENGTH         255
#define MAX_SECTION_LEN                 200


//
//
// Function: HexDigitToByte
//
// Purpose:  Helper function to convert a single hex digit to a byte value.
//
//
BOOL HexDigitToByte(char cHexDigit, BYTE& byte);

BOOL HexDigitToByte(char cHexDigit, BYTE& byte)
{
  // Decimal digits
  if (   (cHexDigit >= '0')
      && (cHexDigit <= '9'))
  {
    byte = (BYTE) (cHexDigit - '0');
    return(TRUE);
  }

  // Uppercase characters
  if (   (cHexDigit >= 'A')
      && (cHexDigit <= 'F'))
  {
    byte = (BYTE) ((cHexDigit - 'A') + 10);
    return(TRUE);
  }

  // Lowercase characters
  if (   (cHexDigit >= 'a')
      && (cHexDigit <= 'f'))
  {
    byte = (BYTE) ((cHexDigit - 'a') + 10);
    return(TRUE);
  }

  // The character is not a valid hex digit
  return(FALSE);
}




//
//
// Function: GetIntegerOption
//
// Purpose:  Retrieve a named option from the dictionary and convert the
//           option string to a long integer value.
//
//
LONG OPT_GetIntegerOption
(
    LPCSTR  cstrOptionName,
    LONG    lDefault
)
{
    LONG    lResult;
    TCHAR   cstrValue[MAX_OPTIONS_LINE_LENGTH];

    if (OPT_Lookup(cstrOptionName, cstrValue, MAX_OPTIONS_LINE_LENGTH))
    {
        // Option has been found, convert it to a long
        lResult = RtStrToInt(cstrValue);
    }
    else
    {
        // The option is not in the dictionary, return the default
        lResult = lDefault;
    }

    return lResult;
}



//
//
// Function: GetBooleanOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a boolean value.
//
//
BOOL OPT_GetBooleanOption
(
    LPCSTR  cstrOptionName,
    BOOL    bDefault
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];

    // Lookup the option
    if (OPT_Lookup(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH))
    {
        return(cstrValue[0] == 'y' || cstrValue[0] =='Y') ;
    }

    return bDefault;
}



//
//
// Function: GetStringOption
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it. No conversion of the string is performed.
//
//
void OPT_GetStringOption
(
    LPCSTR  cstrOptionName,
    LPSTR   cstrValue,
    UINT	size
)
{
    if (!OPT_Lookup(cstrOptionName, cstrValue, size) || !(lstrlen(cstrValue)))
    {
        *cstrValue = _T('\0');
    }
}


//
//
// Function: Lookup
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it in the CString object passed. No conversion is performed.
//
//
BOOL OPT_Lookup
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrResult,
    UINT		size
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    read_hkey = NULL;
	DWORD	    read_type;
	DWORD	    read_bufsize;

	// open key
	if (RegOpenKeyEx( HKEY_CURRENT_USER,
					  WHITEBOARD_KEY,
					  0,
					  KEY_EXECUTE,
					  &read_hkey )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not open key"));
        goto bail_out;
    }


	// read key's value
	read_bufsize = size;
	if (RegQueryValueEx( read_hkey,
					     cstrOptionName,
						 NULL,
						 &read_type,
						 (LPBYTE)cstrResult,
						 &read_bufsize )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not read key"));
        goto bail_out;
    }


	// check for valid type
	if (read_type != REG_SZ)
    {
        WARNING_OUT(("Bad key data"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (read_hkey != NULL)
		RegCloseKey(read_hkey);

	return (fSuccess);
}




//
//
// Function: GetWindowRectOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a window rectangle.  The rectangle is checked to make sure that
//           it is at least partially on screen, and not zero sized.
//
//
void OPT_GetWindowRectOption
(
    LPCSTR      optionName,
    LPRECT      lprc,
    LPCRECT     lprcDefault
)
{
    int      iLeft;
    int      iTop;
    int      iRight;
    int      iBottom;
    TCHAR    cstrValue[MAX_OPTIONS_LINE_LENGTH];

    if (OPT_Lookup(optionName, cstrValue,MAX_OPTIONS_LINE_LENGTH))
    {
        // Option has been found, parse it to a rectangle
        iLeft   = RtStrToInt(StrTok(cstrValue, " ,"));
        iTop    = RtStrToInt(StrTok(NULL, " ,"));
        iRight  = RtStrToInt(StrTok(NULL, " ,"));
        iBottom = RtStrToInt(StrTok(NULL, " ,"));

        // Check for non-zero size
        if ((iRight <= iLeft) || (iBottom <= iTop))
        {
            *lprc = *lprcDefault;
        }
        else
        {
            // Make sure that the window rectangle is (at least partially) on
            // screen, and not too large.  First get the screen size
            int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
            int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);

            // Check the window size
            if ((iRight - iLeft) > screenWidth)
            {
                iRight = iLeft + screenWidth;
            }

            if ((iBottom - iTop) > screenHeight)
            {
                iTop = screenHeight;
            }

            // Check the window position
            if (iLeft >= screenWidth)
            {
                // Off screen to the right - keep the width the same
                iLeft  = screenWidth - (iRight - iLeft);
                iRight = screenWidth;
            }

            if (iRight < 0)
            {
                // Off screen to the left - keep the width the same
                iRight = iRight - iLeft;
                iLeft  = 0;
            }

            if (iTop >= screenHeight)
            {
                // Off screen to the bottom - keep the height the same
                iTop    = screenHeight - (iBottom - iTop);
                iBottom = screenHeight;
            }

            if (iBottom < 0)
            {
                // Off screen to the top - keep the height the same
                iBottom = (iBottom - iTop);
                iTop    = 0;
            }

            lprc->left = iLeft;
            lprc->top = iTop;
            lprc->right = iRight;
            lprc->bottom = iBottom;
        }
    }
    else
    {
        // The option is not in the dictionary, return the default
        *lprc = *lprcDefault;
    }
}


//
//
// Function: GetDataOption
//
// Purpose:  Retrieve a named option from the dictionary and parse it as
//           an ASCII representation of a string of hex bytes.
//
//
int OPT_GetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbResult
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];
    BYTE* pbSaveResult = pbResult;

    // Lookup the option
    OPT_GetStringOption(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH);
    if (lstrlen(cstrValue))
    {
        // Calculate the maximum number of characters to convert
        int iMaxChars = min(2 * iBufferLength, lstrlen(cstrValue));

        // Option found, convert the string to hex bytes
        for (int iIndex = 0; iIndex < iMaxChars; iIndex += 2)
        {
            BYTE bByteHigh = 0;
            BYTE bByteLow  = 0;

            if (   (HexDigitToByte(cstrValue[iIndex], bByteHigh) == FALSE)
                || (HexDigitToByte(cstrValue[iIndex + 1], bByteLow) == FALSE))
            {
                // The character was not a valid hex digit
                break;
            }

            // Build the result byte
            *pbResult++ = (BYTE) ((bByteHigh << 4) | bByteLow);
        }
    }

    // Return the length of data in the buffer
    return (int)(pbResult - pbSaveResult);
}



//
//
// Function: SetStringOption
//
// Purpose:  Set the value of an option in the dictionary.
//

//
BOOL OPT_SetStringOption
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrValue
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    write_hkey = NULL;
	DWORD       disposition;

    // open or create the key
	if (RegCreateKeyEx( HKEY_CURRENT_USER,
						WHITEBOARD_KEY,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&write_hkey,
						&disposition) != ERROR_SUCCESS)
    {
        WARNING_OUT(("Could not write key"));
        goto bail_out;
    }

    // got data, write the value
    if (RegSetValueEx( write_hkey,
                       cstrOptionName,
					   0,
					   REG_SZ,
					   (LPBYTE)cstrValue,
                       _tcsclen(cstrValue) + sizeof(TCHAR)) != ERROR_SUCCESS )
    {
        WARNING_OUT(("Could not write key value"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (write_hkey != NULL)
		RegCloseKey(write_hkey);

    return(fSuccess);
}



//
//
// Function: SetIntegerOption
//
// Purpose:  Write an integer option
//
//
BOOL OPT_SetIntegerOption
(
    LPCSTR      cstrOptionName,
    LONG        lValue
)
{
    char cBuffer[20];

    // Convert the integer value to ASCII decimal
    wsprintf(cBuffer, "%ld", lValue);

	// Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}


//
//
// Function: SetBooleanOption
//
// Purpose:  Write a boolean option
//
//
BOOL OPT_SetBooleanOption
(
    LPCSTR      cstrOptionName,
    BOOL        bValue
)
{
    char        cBuffer[8];

    wsprintf(cBuffer, "%c", (bValue ? 'Y' : 'N'));

    // Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}



//
//
// Function: SetWindowRectOption
//
// Purpose:  Write a window position rectangle
//
//
BOOL OPT_SetWindowRectOption
(
    LPCSTR      optionName,
    LPCRECT     lpwindowRect
)
{
    char cBuffer[64];

    // Convert the integer values to ASCII decimal
	wsprintf(cBuffer, "%d,%d,%d,%d",
        lpwindowRect->left, lpwindowRect->top, lpwindowRect->right,
        lpwindowRect->bottom);

	  // Write the option
    return OPT_SetStringOption(optionName, cBuffer);
}

//
//
// Function: SetDataOption
//
// Purpose:  Write a data option to the options file
//
//
BOOL OPT_SetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbBuffer
)
{
    char        cBuffer[1024];
    LPSTR       cTmp;

    ASSERT(iBufferLength*2 < sizeof(cBuffer));

    // Loop through the data array converting a byte at a time
    cTmp = cBuffer;
    for (int iIndex = 0; iIndex < iBufferLength; iIndex++)
    {
        // Convert the next byte to ASCII hex
        wsprintf(cTmp, "%02x", pbBuffer[iIndex]);

        // add it to the string to be written
        cTmp += lstrlen(cTmp);
    }

    // Write the option
    return OPT_SetStringOption(cstrOptionName, cBuffer);
}





//
//
// Function:    CreateSystemPalette
//
// Purpose:     Get a palette representing the system palette
//
//
HPALETTE CreateSystemPalette(void)
{
    LPLOGPALETTE    lpLogPal;
    HDC             hdc;
    HPALETTE        hPal = NULL;
    int             nColors;

    MLZ_EntryOut(ZONE_FUNCTION, "CreateSystemPalette");

    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);

    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

    nColors = ::GetDeviceCaps(hdc, SIZEPALETTE);

    ::DeleteDC(hdc);

    if (nColors == 0)
    {
        TRACE_MSG(("CreateSystemPalette: device has no palette"));
        return(NULL);
    }

    // Allocate room for the palette and lock it.
    lpLogPal = (LPLOGPALETTE)::GlobalAlloc(GPTR, sizeof(LOGPALETTE) +
                                    nColors * sizeof(PALETTEENTRY));

    if (lpLogPal != NULL)
    {
        lpLogPal->palVersion    = PALVERSION;
        lpLogPal->palNumEntries = (WORD) nColors;

        for (int iIndex = 0;  iIndex < nColors;  iIndex++)
        {
            lpLogPal->palPalEntry[iIndex].peBlue  = 0;
            *((LPWORD) (&lpLogPal->palPalEntry[iIndex].peRed)) = (WORD) iIndex;
            lpLogPal->palPalEntry[iIndex].peFlags = PC_EXPLICIT;
        }

        hPal = ::CreatePalette(lpLogPal);

        // Free the logical palette structure
        ::GlobalFree((HGLOBAL)lpLogPal);
    }

    return(hPal);
}


//
//
// Function:    CreateColorPalette
//
// Purpose:     Get a 256-color palette
//
//
HPALETTE CreateColorPalette(void)
{
    HDC hdc;
    HPALETTE hPal = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "CreateColorPalette");

	// Find out how many colors are reserved
    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

	UINT uiSystemUse  = ::GetSystemPaletteUse(hdc);

    // Get the number of static colors
    int  iCountStatic = 20;
    int  iHalfCountStatic = 10;
	if (uiSystemUse == SYSPAL_NOSTATIC)
	{
        iCountStatic = 2;
        iHalfCountStatic = 1;
    }

	LOGPALETTE_NM gIndeoPalette = gcLogPaletteIndeo;

    // put system colors in correct lower and upper pal entries (bug NM4db:817)
    ::GetSystemPaletteEntries(hdc,
							  0,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[0]) );

    ::GetSystemPaletteEntries(hdc,
							  MAXPALETTE - iHalfCountStatic,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[MAXPALETTE - iHalfCountStatic]) );

    // Create the windows object for this palette
    // from the logical palette
    hPal = CreatePalette( (LOGPALETTE *)&gIndeoPalette );

	// Delete the display DC
	::DeleteDC(hdc);

	return(hPal);
}





//
//
// Function:    FromScreenAreaBmp
//
// Purpose:     Create a bitmap from an area of the screen
//
//
HBITMAP FromScreenAreaBmp(LPCRECT lprect)
{
    RECT    rcScreen;
    HBITMAP hBitMap = NULL;

    //
    // Get screen boundaries, in a way that works for single and multiple
    // monitor scenarios.
    //
    if (rcScreen.right = ::GetSystemMetrics(SM_CXVIRTUALSCREEN))
    {
        //
        // This is Win98, NT 4.0 SP-3, or NT5
        //
        rcScreen.bottom  = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
        rcScreen.left    = ::GetSystemMetrics(SM_XVIRTUALSCREEN);
        rcScreen.top     = ::GetSystemMetrics(SM_YVIRTUALSCREEN);
    }
    else
    {
        //
        // The VIRTUALSCREEN size metrics are zero on older platforms
        // which don't support them.
        //
        rcScreen.right  = ::GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = ::GetSystemMetrics(SM_CYSCREEN);
        rcScreen.left   = 0;
        rcScreen.top    = 0;
    }

    rcScreen.right += rcScreen.left;
    rcScreen.bottom += rcScreen.top;

    //
    // Clip bitmap rectangle to the screen.
    //
    if (IntersectRect(&rcScreen, &rcScreen, lprect))
    {
        // Create a DC for the screen and create
        // a memory DC compatible to screen DC
        HDC     hdisplayDC;
        hdisplayDC = ::CreateDC("DISPLAY", NULL, NULL, NULL);

        HDC hmemDC;
        hmemDC = ::CreateCompatibleDC(hdisplayDC);

        // Create a bitmap compatible with the screen DC
        hBitMap =  ::CreateCompatibleBitmap(hdisplayDC,
            rcScreen.right - rcScreen.left,
            rcScreen.bottom - rcScreen.top);
        if (hBitMap != NULL)
        {
            // Select new bitmap into memory DC
            HBITMAP  hOldBitmap = SelectBitmap(hmemDC, hBitMap);

            // BitBlt screen DC to memory DC
            ::BitBlt(hmemDC, 0, 0, rcScreen.right - rcScreen.left,
                rcScreen.bottom - rcScreen.top, hdisplayDC,
                rcScreen.left, rcScreen.top, SRCCOPY);

            // Select old bitmap back into memory DC and get handle to
            // bitmap of the screen
            SelectBitmap(hmemDC, hOldBitmap);
        }

        ::DeleteDC(hmemDC);

        ::DeleteDC(hdisplayDC);
    }

    // return handle to the bitmap
    return hBitMap;
}





// Macro to round off the given value to the closest byte
#define WIDTHBYTES(i)   (((i+31)/32)*4)


//
//
// Function:    DIB_NumberOfColors
//
// Purpose:     Calculates the number of colours in the DIB
//
//
UINT DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi)
{
    UINT                numColors;
    int                 bits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_NumberOfColors");

    ASSERT(lpbi != NULL);

    //  With the BITMAPINFO format headers, the size of the palette
    //  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
    //  is dependent on the bits per pixel ( = 2 raised to the power of
    //  bits/pixel).
    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        // Old DIB format, some apps still put this on the clipboard
        numColors = 0;
        bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
    }
    else
    {
        numColors = lpbi->biClrUsed;
        bits = lpbi->biBitCount;
    }

    if ((numColors == 0) && (bits <= 8))
    {
        numColors = (1 << bits);
    }

    return numColors;
}


//
//
// Function:    DIB_PaletteLength
//
// Purpose:     Calculates the palette size in bytes
//
//
UINT DIB_PaletteLength(LPBITMAPINFOHEADER lpbi)
{
    UINT size;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_PaletteLength");

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBTRIPLE);
    }
    else
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBQUAD);
    }

    TRACE_MSG(("Palette length %d", size));
    return(size);
}

//
//
// Function:    DIB_DataLength
//
// Purpose:     Return the length of the DIB data (after the header and the
//              color table.
//
//
UINT DIB_DataLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_DataLength");

    ASSERT(lpbi);

    UINT dwLength = 0;

    // If the image is not compressed, calculate the length of the data
    if (lpbi->biCompression == BI_RGB)
    {
        // Image is not compressed, the size can be given as zero in the header

        // Calculate the width in bytes of the image
        DWORD dwByteWidth = ( ((DWORD) lpbi->biWidth) * (DWORD) lpbi->biBitCount);
        TRACE_MSG(("Data byte width is %ld",dwByteWidth));

        // Round the width to a multiple of 4 bytes
        dwByteWidth = WIDTHBYTES(dwByteWidth);
        TRACE_MSG(("Rounded up to %ld",dwByteWidth));

        dwLength = (dwByteWidth * ((DWORD) lpbi->biHeight));
    }
    else
    {
        // Image is compressed, the length should be correct in the header
        dwLength = lpbi->biSizeImage;
    }

    TRACE_MSG(("Total data length is %d",dwLength));

    return(dwLength);
}


//
//
// Function:    DIB_TotalLength
//
// Purpose:     Return the total length of the DIB (header + colors + data).
//
//
UINT DIB_TotalLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_TotalLength");

    ASSERT(lpbi);

    // Header + Palette + Bits
    return(lpbi->biSize + DIB_PaletteLength(lpbi) + DIB_DataLength(lpbi));
}


//
//
// Function:    DIB_CreatePalette
//
// Purpose:     Create a palette object from the bitmap info color table
//
//
HPALETTE DIB_CreatePalette(LPBITMAPINFOHEADER lpbi)
{
    LOGPALETTE    *pPal;
    HPALETTE      hpal = NULL;
    WORD          nNumColors;
    BYTE          red;
    BYTE          green;
    BYTE          blue;
    WORD          i;
    RGBQUAD FAR * pRgb;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_CreatePalette");

    if (!lpbi)
        return NULL;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return NULL;

    // Get a pointer to the color table and the number of colors in it
    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    nNumColors = (WORD)DIB_NumberOfColors(lpbi);

    if (nNumColors)
    {
        TRACE_MSG(("There are %d colors in the palette",nNumColors));

        // Allocate for the logical palette structure
        pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR, sizeof(LOGPALETTE)
                                    + (nNumColors * sizeof(PALETTEENTRY)));
        if (!pPal)
        {
            ERROR_OUT(("Couldn't allocate palette memory"));
            return(NULL);
        }

        pPal->palNumEntries = nNumColors;
        pPal->palVersion    = PALVERSION;

        // Fill in the palette entries from the DIB color table and
        // create a logical color palette.
        for (i = 0; i < nNumColors; i++)
        {
            pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
            pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
            pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
            pPal->palPalEntry[i].peFlags = (BYTE)0;
        }

        hpal = ::CreatePalette(pPal);

        ::GlobalFree((HGLOBAL)pPal);
    }
    else
    {
        if (lpbi->biBitCount == 24)
        {
            // A 24 bitcount DIB has no color table entries so, set the number
            // of to the maximum value (256).
            nNumColors = MAXPALETTE;

            pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR,  sizeof(LOGPALETTE)
                    + (nNumColors * sizeof(PALETTEENTRY)));
            if (!pPal)
            {
                ERROR_OUT(("Couldn't allocate palette memory"));
                return NULL;
            }

            pPal->palNumEntries = nNumColors;
            pPal->palVersion    = PALVERSION;

            red = green = blue = 0;

            // Generate 256 (= 8*8*4) RGB combinations to fill the palette
            // entries.

            for (i = 0; i < pPal->palNumEntries; i++)
            {
                pPal->palPalEntry[i].peRed   = red;
                pPal->palPalEntry[i].peGreen = green;
                pPal->palPalEntry[i].peBlue  = blue;
                pPal->palPalEntry[i].peFlags = (BYTE) 0;

                if (!(red += 32))
                    if (!(green += 32))
                        blue += 64;
            }

            hpal = ::CreatePalette(pPal);
            ::GlobalFree((HGLOBAL)pPal);
        }
    }

    return hpal;
}


//
//
// Function:    DIB_Bits
//
// Purpose:     Return a pointer to the bitmap bits data (from a pointer
//              to the bitmap info header).
//
//
LPSTR DIB_Bits(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Bits");
    ASSERT(lpbi);

    return ((LPSTR) (((char *) lpbi)
                   + lpbi->biSize
                   + DIB_PaletteLength(lpbi)));
}



//
//
// Function:    DIB_FromScreenArea
//
// Purpose:     Create a DIB from an area of the screen
//
//
LPBITMAPINFOHEADER DIB_FromScreenArea(LPCRECT lprect)
{
    HBITMAP     hBitmap     = NULL;
    HPALETTE    hPalette    = NULL;
    LPBITMAPINFOHEADER lpbi = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromScreenArea");

    //  Get the device-dependent bitmap from the screen area
    hBitmap = FromScreenAreaBmp(lprect);
    if (hBitmap != NULL)
    {
        // Get the current system palette
        hPalette = CreateSystemPalette();
        lpbi = DIB_FromBitmap(hBitmap, hPalette, FALSE);
    }

    if (hPalette != NULL)
        ::DeletePalette(hPalette);

    if (hBitmap != NULL)
        ::DeleteBitmap(hBitmap);

    return(lpbi);
}


//
//
// Function:    DIB_Copy
//
// Purpose:     Make a copy of the DIB memory
//
//
LPBITMAPINFOHEADER DIB_Copy(LPBITMAPINFOHEADER lpbi)
{
    LPBITMAPINFOHEADER  lpbiNew = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Copy");

    ASSERT(lpbi);

    // Get the length of memory
    DWORD dwLen = DIB_TotalLength(lpbi);

    lpbiNew = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
    if (lpbiNew != NULL)
    {
        // Copy the data
        memcpy(lpbiNew, lpbi, dwLen);
    }

    return(lpbiNew);
}

//
//
// Function:    DIB_FromBitmap
//
// Purpose:     Creates a DIB from a bitmap and palette
//
//
LPBITMAPINFOHEADER DIB_FromBitmap
(
    HBITMAP     hBitmap,
    HPALETTE    hPalette,
    BOOL        fGHandle
)
{
    LPBITMAPINFOHEADER  lpbi = NULL;
    HGLOBAL             hmem = NULL;
    BITMAP              bm;
    BITMAPINFOHEADER    bi;
    DWORD               dwLen;
    WORD                biBits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromBitmap");

    // If the bitmap handle given is null, do nothing
    if (hBitmap != NULL)
    {
        if (hPalette == NULL)
            hPalette = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);

        // Get the bitmap information
        ::GetObject(hBitmap, sizeof(bm), (LPSTR) &bm);

        biBits =  (WORD) (bm.bmPlanes * bm.bmBitsPixel);

        if (biBits > 8)
        {
            // If > 8, make life easy and use plain R-G-B 24-bits
            biBits = 24;
        }

        bi.biSize               = sizeof(BITMAPINFOHEADER);
        bi.biWidth              = bm.bmWidth;
        bi.biHeight             = bm.bmHeight;
        bi.biPlanes             = 1;
        bi.biBitCount           = biBits;
        bi.biCompression        = 0;
        bi.biSizeImage          = 0;
        bi.biXPelsPerMeter      = 0;
        bi.biYPelsPerMeter      = 0;
        bi.biClrUsed            = 0;
        bi.biClrImportant       = 0;

        dwLen  = bi.biSize + DIB_PaletteLength(&bi);

        HDC         hdc;
        HPALETTE    hPalOld;

        hdc = ::CreateDC("DISPLAY", NULL, NULL, NULL);
        hPalOld = ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);

        // Allocate memory for the DIB
        if (fGHandle)
        {
            // For the clipboard, we MUST use GHND
            hmem = ::GlobalAlloc(GHND, dwLen);
            lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
        }
        else
        {
            lpbi = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
        }

        if (lpbi != NULL)
        {
            *lpbi = bi;

            // Call GetDIBits with a NULL lpBits param, so it will calculate the
            // biSizeImage field for us
            ::GetDIBits(hdc, hBitmap, 0, (WORD) bi.biHeight, NULL,
                  (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

            bi = *lpbi;

            // If the driver did not fill in the biSizeImage field, make one up
            if (bi.biSizeImage == 0)
            {
                bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;
            }

            // Realloc the buffer big enough to hold all the bits
            dwLen = bi.biSize + DIB_PaletteLength(&bi) + bi.biSizeImage;

            if (fGHandle)
            {
                HGLOBAL hT;

                ::GlobalUnlock(hmem);
                hT = ::GlobalReAlloc(hmem, dwLen, GHND);
                if (!hT)
                {
                    ERROR_OUT(("Can't reallocate DIB handle"));
                    ::GlobalFree(hmem);
                    hmem = NULL;
                    lpbi = NULL;
                }
                else
                {
                    hmem = hT;
                    lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
                }
            }
            else
            {
                LPBITMAPINFOHEADER lpbiT;

                lpbiT = (LPBITMAPINFOHEADER)::GlobalReAlloc((HGLOBAL)lpbi, dwLen, GMEM_MOVEABLE);
                if (!lpbiT)
                {
                    ERROR_OUT(("Can't reallocate DIB ptr"));

                    ::GlobalFree((HGLOBAL)lpbi);
                    lpbi = NULL;
                }
                else
                {
                    lpbi = lpbiT;
                }
            }
        }

        if (lpbi != NULL)
        {
            ::GetDIBits(hdc, hBitmap, 0,
                    (WORD)bi.biHeight,
                    DIB_Bits(lpbi),
                    (LPBITMAPINFO)lpbi,
                    DIB_RGB_COLORS);

            if (fGHandle)
            {
                // We want to return the HANDLE, not the POINTER
                ::GlobalUnlock(hmem);
                lpbi = (LPBITMAPINFOHEADER)hmem;
            }
        }

        // Restore the old palette and give back the device context
        ::SelectPalette(hdc, hPalOld, FALSE);
        ::DeleteDC(hdc);
    }

    return(lpbi);
}





//
// AbortProc()
// Process messages during printing
//
//
BOOL CALLBACK AbortProc(HDC, int)
{
    MSG msg;

    ASSERT(g_pPrinter);

    // Message pump in case user wants to cancel printing
    while (!g_pPrinter->Aborted()
        && PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
    {
        if ( (g_pPrinter->m_hwndDialog == NULL) ||
            !::IsDialogMessage(g_pPrinter->m_hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return !g_pPrinter->Aborted();
}

//
//
// Function:    WbPrinter
//
// Purpose:     Constructor for a printer object
//
//
WbPrinter::WbPrinter(LPCTSTR szDeviceName)
{
    m_szDeviceName = szDeviceName;
    m_szPrintPageText[0] = 0;

    // Set up the global pointer for the abort procedure
    g_pPrinter = this;

    // Create the dialog window
    m_hwndDialog = ::CreateDialogParam(g_hInstance, MAKEINTRESOURCE(PRINTCANCEL),
        g_pMain->m_hwnd, CancelPrintDlgProc, 0);

    // Save the original text for the page number area
    ::GetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, m_szPrintPageText, _MAX_PATH);
}


//
//
// Function:    ~WbPrinter
//
// Purpose:     Destructor for a printer object
//
//
WbPrinter::~WbPrinter(void)
{
    // Kill off the dialog etc. if still around
    StopDialog();

    ASSERT(m_hwndDialog == NULL);

    g_pPrinter = NULL;
}


//
// StopDialog()
// If the dialog is up, ends it.
//
void WbPrinter::StopDialog(void)
{
    ::EnableWindow(g_pMain->m_hwnd, TRUE);

    // Close and destroy the dialog
    if (m_hwndDialog != NULL)
    {
        ::DestroyWindow(m_hwndDialog);
        m_hwndDialog = NULL;
    }

}

//
//
// Function:    StartDoc
//
// Purpose:     Tell the printer we are starting a new document
//
//
int WbPrinter::StartDoc
(
    HDC     hdc,
    LPCTSTR szJobName,
    int     nStartPage
)
{
    // Initialize the result codes and page number
    m_bAborted  = FALSE;         // Not aborted
    m_nPrintResult = 1;        // Greater than 0 implies all is well

    // Disable the main window
    ::EnableWindow(g_pMain->m_hwnd, FALSE);

    // Attach the printer DC
    SetPrintPageNumber(nStartPage);

    // Set up the abort routine for the print
    if (SetAbortProc(hdc, AbortProc) >= 0)
    {
        // Abort routine successfully set
        ::ShowWindow(m_hwndDialog, SW_SHOW);
        ::UpdateWindow(m_hwndDialog);

	    DOCINFO docinfo;

        docinfo.cbSize = sizeof(DOCINFO);
        docinfo.lpszDocName = szJobName;
        docinfo.lpszOutput = NULL;
        docinfo.lpszDatatype = NULL;   // Windows 95 only; ignored on Windows NT
        docinfo.fwType = 0;         // Windows 95 only; ignored on Windows NT

        // Initialize the document.
        m_nPrintResult = ::StartDoc(hdc, &docinfo);
    }

    return m_nPrintResult;
}

//
//
// Function:    StartPage
//
// Purpose:     Tell the printer we are starting a new page
//
//
int WbPrinter::StartPage(HDC hdc, int nPageNumber)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::StartPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        SetPrintPageNumber(nPageNumber);

        // Tell the printer of the new page number
        m_nPrintResult = ::StartPage(hdc);
    }

    return(m_nPrintResult);
}


//
//
// Function:    EndPage
//
// Purpose:     Tell the printer we are finishing a page
//
//
int WbPrinter::EndPage(HDC hdc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::EndPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        // Tell the printer of the new page number
        m_nPrintResult = ::EndPage(hdc);
    }

    return(m_nPrintResult);
}

//
//
// Function:    EndDoc
//
// Purpose:     Tell the printer we have completed a document
//
//
int WbPrinter::EndDoc(HDC hdc)
{
    // If an error has occurred the driver will already have aborted the print
    if (m_nPrintResult > 0)
    {
        if (!m_bAborted)
        {
            // If we have not been aborted, and no error has occurred
            //   end the document
            m_nPrintResult = ::EndDoc(hdc);
        }
        else
        {
            m_nPrintResult = ::AbortDoc(hdc);
        }
    }

    StopDialog();

    // Return an the error indicator
    return m_nPrintResult;
}

//
//
// Function:    AbortDoc
//
// Purpose:     Abort the document currently in progress
//
//
int WbPrinter::AbortDoc()
{
    // Show that we have been aborted, the actual abort is
    // done by the EndDoc call.
    m_bAborted = TRUE;

    //
    // Renable the application window.
    //
    StopDialog();

    // Return a positive value indicating "aborted OK"
    return 1;
}


//
//
// Function:    SetPrintPageNumber
//
// Purpose:     Set the number of the page currently being printed
//
//
void WbPrinter::SetPrintPageNumber(int nPageNumber)
{
	// Display the number of the page currently being printed
	TCHAR szPageNumber [10 + _MAX_PATH];

    wsprintf(szPageNumber, m_szPrintPageText, nPageNumber);
    ::SetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, szPageNumber);
}


//
// CancelPrintDlgProc()
// Dialog message handler for the cancel printing dialog
//
INT_PTR CALLBACK CancelPrintDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ASSERT(g_pPrinter != NULL);
            ::SetDlgItemText(hwnd, IDD_DEVICE_NAME, g_pPrinter->m_szDeviceName);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ASSERT(g_pPrinter != NULL);
                            g_pPrinter->AbortDoc();
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
// Bogus Bogus LAURABU
// STRING ARRAY (TEMP!)
//

StrArray::StrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = 0;
}

StrArray::~StrArray()
{
    ClearOut();
}


void StrArray::ClearOut(void)
{
    int iItem;

    for (iItem = 0; iItem < m_nSize; iItem++)
    {
        if (m_pData[iItem] != NULL)
        {
            delete (LPTSTR)m_pData[iItem];
            m_pData[iItem] = NULL;
        }
    }

    m_nSize = 0;
    m_nMaxSize = 0;

    if (m_pData != NULL)
    {
        delete[] m_pData;
        m_pData = NULL;
    }

}


void StrArray::SetSize(int nNewSize)
{
	if (nNewSize == 0)
	{
		// shrink to nothing
        ClearOut();
	}
    else if (nNewSize <= m_nMaxSize)
    {
        // No shrinking allowed.
        ASSERT(nNewSize >= m_nSize);

        // We're still within the alloced block range
        m_nSize = nNewSize;
    }
	else
	{
        //
		// Make a larger array (isn't this lovely if you already have an
        // array, we alloc a new one and free the old one)
        //
		int nNewMax;

        nNewMax = (nNewSize + (ALLOC_CHUNK -1)) & ~(ALLOC_CHUNK-1);
		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

		LPCTSTR* pNewData = new LPCTSTR[nNewMax];
        if (!pNewData)
        {
            ERROR_OUT(("StrArray::SetSize failed, couldn't allocate larger array"));
        }
        else
        {
            // Zero out the memory
            ZeroMemory(pNewData, nNewMax * sizeof(LPCTSTR));

            // If an old array exists, copy the existing string ptrs.
            if (m_pData != NULL)
            {
                CopyMemory(pNewData, m_pData, m_nSize * sizeof(LPCTSTR));

                //
                // Delete the old array, but not the strings inside, we're
                // keeping them around in the new array
                //
                delete[] m_pData;
            }

    		m_pData = pNewData;
	    	m_nSize = nNewSize;
		    m_nMaxSize = nNewMax;
        }
	}
}


void StrArray::SetAtGrow(int nIndex, LPCTSTR newElement)
{
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);

    SetAt(nIndex, newElement);
}


LPCTSTR StrArray::operator[](int nIndex) const
{
    ASSERT(nIndex >= 0);

    if (nIndex < m_nSize)
    {
        ASSERT(m_pData != NULL);
        return(m_pData[nIndex]);
    }
    else
    {
        WARNING_OUT(("StrArray[] got index outside of bounds"));
        return(NULL);
    }
}


void StrArray::SetAt(int nIndex, LPCTSTR newElement)
{
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
    {
        WARNING_OUT(("StrArray::SetAt got index outside of bounds"));
        return;
    }

    ASSERT(m_pData != NULL);

    m_pData[nIndex] = new TCHAR[lstrlen(newElement) + 1];
    if (!m_pData[nIndex])
    {
        ERROR_OUT(("StrArray::SetAt failed to allocate string %s at pos %d",
            newElement, nIndex));
    }
    else
    {
        lstrcpy((LPTSTR)m_pData[nIndex], newElement);
    }
}


void StrArray::Add(LPCTSTR newElement)
{
	SetAtGrow(m_nSize, newElement);
}


//
//char *StrTok(string, control) - tokenize string with delimiter in control
//
char *  StrTok (char * string, char * control)
{
        char *str;
        char *ctrl = control;

        unsigned char map[32];
        int count;

        static char *nextoken;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. If string is NULL, set str to the saved
         * pointer (i.e., continue breaking tokens out of the string
         * from the last StrTok call) */
        if (string)
                str = string;
        else
                str = nextoken;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
                str++;

        string = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */
        nextoken = str;

        /* Determine if a token has been found. */
        if ( string == str )
                return NULL;
        else
                return string;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\cgrp.cpp ===
//
// CGRP.CPP
// Color Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szCGClassName[] = "WB_CGRP";

// These default colors are the same as MSPaint
COLORREF g_crDefaultColors[NUMCLRPANES] =
{
        PALETTERGB(   0,  0,  0 ),
        PALETTERGB( 128,128,128 ),
        PALETTERGB( 128,  0,  0 ),
        PALETTERGB( 128,128,  0 ),
        PALETTERGB(   0,128,  0 ),
        PALETTERGB(   0,128,128 ),
        PALETTERGB(   0,  0,128 ),
        PALETTERGB( 128,  0,128 ),
        PALETTERGB( 128,128, 64 ),
        PALETTERGB(   0, 64, 64 ),
        PALETTERGB(   0,128,255 ),
        PALETTERGB(   0, 64,128 ),
        PALETTERGB(  64,  0,255 ),
        PALETTERGB( 128, 64,  0 ),

        PALETTERGB( 255,255,255 ),
        PALETTERGB( 192,192,192 ),
        PALETTERGB( 255,  0,  0 ),
        PALETTERGB( 255,255,  0 ),
        PALETTERGB(   0,255,  0 ),
        PALETTERGB(   0,255,255 ),
        PALETTERGB(   0,  0,255 ),
        PALETTERGB( 255,  0,255 ),
        PALETTERGB( 255,255,128 ),
        PALETTERGB(   0,255,128 ),
        PALETTERGB( 128,255,255 ),
        PALETTERGB( 128,128,255 ),
        PALETTERGB( 255,  0,128 ),
        PALETTERGB( 255,128, 64 ),

        PALETTERGB(   0,  0,  0 )    // Current color
};



//
// WbColorsGroup()
//
WbColorsGroup::WbColorsGroup()
{
    int         i;

    m_hwnd = NULL;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        m_crColors[i] = g_crDefaultColors[i];
        m_hBrushes[i] = NULL;
    }


    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        m_crCustomColors[i] = CLRPANE_WHITE;
    }

    m_nLastColor = 0;
}



WbColorsGroup::~WbColorsGroup(void)
{
    int i;

    // clean up
    for (i = 0; i < NUMCLRPANES; i++)
    {
        if (m_hBrushes[i] != NULL)
        {
            ::DeleteBrush(m_hBrushes[i]);
            m_hBrushes[i] = NULL;
        }
    }

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    // Unregister our class
    ::UnregisterClass(szCGClassName, g_hInstance);
}



BOOL WbColorsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    int         i;
    HDC         hdc;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS;
    wc.lpfnWndProc      = CGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szCGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbColorsGroup::Create register class failed"));
        return(FALSE);
    }

    //
    // We should be created the right siez
    //
    ASSERT(lprect->right - lprect->left == CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH);
    ASSERT(lprect->bottom - lprect->top == CLRCHOICE_HEIGHT);

    //
    // Calculate our item colors, then figure out our size.
    //

    hdc = ::GetDC(hwndParent);
    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(hdc, hPal, FALSE);
        ::RealizePalette(hdc);
    }

    // load the colors from last time
    OPT_GetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_GetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

    // make brushes.
    for (i = 0; i < NUMCLRPANES; i++)
    {
        // force color matching
        m_crColors[i] = SET_PALETTERGB( m_crColors[i] );
        m_hBrushes[i] = ::CreateSolidBrush(m_crColors[i]);
    }

    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        // force color matching
        m_crCustomColors[i] = SET_PALETTERGB( m_crCustomColors[i] );
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hdc, hOldPal, TRUE);
    }
    ::ReleaseDC(hwndParent, hdc);

    //
    // Here's our layout:
    //      * The colors window is CHOICEFRAME_HEIGHT pixels high
    //      * The current choice is a rect of CHOICEFRAME_WIDTH by
    //          CHOICEFRAME_HEIGHT pixels, on the left side.  This includes
    //          a sunken EDGE.
    //      * There is no gap horizontally or vertically among panes.

    //
    // Create our window -- we're always visible.  The attribute group
    // shows/hides colors by showing/hiding itself.
    //
    if (!::CreateWindowEx(0, szCGClassName, NULL, WS_CHILD | WS_VISIBLE,
        lprect->left, lprect->top,
        lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbColorsGroup"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);
    return(TRUE);
}


LRESULT CALLBACK CGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbColorsGroup * pcg;

    pcg = (WbColorsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pcg = (WbColorsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pcg);

            pcg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pcg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pcg);
            pcg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pcg);
            pcg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            pcg->OnLButtonDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONDBLCLK:
            pcg->OnLButtonDblClk((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbColorsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cx = CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH;
    lpsize->cy = CLRCHOICE_HEIGHT;
}



COLORREF WbColorsGroup::GetCurColor(void)
{
    return(GetColorOfBrush(INDEX_CHOICE));
}



void WbColorsGroup::SetCurColor(COLORREF clr)
{
    SetColorOfPane(INDEX_CHOICE, clr);
}






//
// OnPaint()
//
// MFC message handler for WM_PAINT
//
void WbColorsGroup::OnPaint(void)
{
    PAINTSTRUCT ps;
    RECT        rc;
    RECT        rcClient;
    int         dx, dy;
    int         i;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    ::BeginPaint(m_hwnd, &ps);

    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(ps.hdc, hPal, FALSE);
        ::RealizePalette(ps.hdc);
    }

    dx = ::GetSystemMetrics(SM_CXEDGE);
    dy = ::GetSystemMetrics(SM_CYEDGE);
    ::GetClientRect(m_hwnd, &rcClient);

    // Draw the current choice
    rc = rcClient;
    rc.right = rc.left + CLRCHOICE_WIDTH;
    ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_RECT);
    ::FillRect(ps.hdc, &rc, m_hBrushes[INDEX_CHOICE]);

    // Draw the colors
    rcClient.left += CLRCHOICE_WIDTH;

    rc = rcClient;
    rc.right = rc.left + CLRPANE_WIDTH;
    rc.bottom = rc.top + CLRPANE_HEIGHT;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        ::FillRect(ps.hdc, &rc, m_hBrushes[i]);
        ::InflateRect(&rc, dx, dy);

        if (i == NUMCOLS - 1)
        {
            ::OffsetRect(&rc, - (NUMCOLS-1)*CLRPANE_WIDTH, CLRPANE_HEIGHT);
        }
        else
        {
            ::OffsetRect(&rc, CLRPANE_WIDTH, 0);
        }

    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(ps.hdc, hOldPal, TRUE);
    }

    ::EndPaint(m_hwnd, &ps);

}

//
// OnLButtonDown()
//
void WbColorsGroup::OnLButtonDown(UINT nFlags, int x, int y)
{
    //
    // If this is the current choice, do nothing.  Otherwise, change the
    // current color.
    //
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        // Set the current color
        SetColorOfPane(INDEX_CHOICE, GetColorOfBrush(pane));
        m_nLastColor = pane;

        // tell Whiteboard about it.
        ClickOwner();
    }
}



//
// OnLButtonDblClk()
//
void  WbColorsGroup::OnLButtonDblClk(UINT nFlags, int x, int y)
// Invoke color dialog to edit this color
{
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        DoColorDialog(pane);
    }
}



// Returns COLORREF of Brushes[] or BLACK if no brush
COLORREF WbColorsGroup::GetColorOfBrush( int nColor )
{
    ASSERT(nColor >= 0);
    ASSERT(nColor < NUMCLRPANES);

    if (m_hBrushes[nColor] != NULL)
    {
        return(m_crColors[nColor]);
    }
    else
    {
        return(CLRPANE_BLACK);
    }
}


// Recreates the nColor-th brush, using the new color
void WbColorsGroup::SetColorOfBrush( int nColor, COLORREF crNewColor )
{
    HBRUSH  hNewBrush;

    // force color matching
    crNewColor = SET_PALETTERGB( crNewColor );

    // check if we need to do anything
    if ((nColor > -1) && (crNewColor != GetColorOfBrush(nColor)))
    {
        // new color is different from old color, make a new brush

        hNewBrush = ::CreateSolidBrush(crNewColor);
        if (hNewBrush != NULL)
        {
            // We managed to create the new brush.  Delete the old one
            if (m_hBrushes[nColor] != NULL)
            {
                ::DeleteBrush(m_hBrushes[nColor]);
            }

            m_hBrushes[nColor] = hNewBrush;
            m_crColors[nColor] = crNewColor;
        }
    }
}



//
// SetColorOfPane()
//
// Replaces brush associated with nPaneId.
//
void WbColorsGroup::SetColorOfPane(int pane, COLORREF crNewColor )
{
    RECT    rcClient;

    // make a new brush
    SetColorOfBrush(pane, crNewColor);

    // update pane
    ::GetClientRect(m_hwnd, &rcClient);
    if (pane == INDEX_CHOICE)
    {
        rcClient.right = rcClient.left + CLRCHOICE_WIDTH;
    }
    else
    {
        rcClient.left += CLRCHOICE_WIDTH;

        rcClient.top += (pane / NUMCOLS) * CLRPANE_HEIGHT;
        rcClient.bottom = rcClient.top + CLRPANE_HEIGHT;
        rcClient.left += (pane % NUMCOLS) * CLRPANE_WIDTH;
        rcClient.right = rcClient.left + CLRPANE_WIDTH;
    }
    ::InvalidateRect(m_hwnd, &rcClient, FALSE);
}




void WbColorsGroup::SaveSettings( void )
    // Saves stuff in registry because we're shutting down
{
    // load the colors from last time
    OPT_SetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_SetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

}



void WbColorsGroup::OnEditColors( void )
{
    DoColorDialog( m_nLastColor );
}



//
// DoColorDialog()
// Put up ComDlg color picker to edit the pane's color value
//
COLORREF WbColorsGroup::DoColorDialog( int nColor )
{
    CHOOSECOLOR cc;

    memset(&cc, 0, sizeof(cc));
    cc.lStructSize = sizeof(cc);
    cc.lpCustColors = m_crCustomColors;
    cc.Flags = CC_RGBINIT;
    cc.rgbResult = GetColorOfBrush(nColor);
    cc.hwndOwner = m_hwnd;

    ::ChooseColor(&cc);

    // force color matching
    cc.rgbResult = SET_PALETTERGB(cc.rgbResult);

    // use the new color
    SetColorOfPane(nColor, cc.rgbResult );

    // set choice pane
    SetColorOfPane(INDEX_CHOICE,  cc.rgbResult );
    m_nLastColor = nColor;

    // tell Whiteboard about it.
    ClickOwner();

    return(cc.rgbResult );
}





void WbColorsGroup::ClickOwner( void )
{
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                    (LPARAM)m_hwnd);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\draw.cpp ===
//
// DRAW.CPP
// Main Drawing Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szDrawClassName[] = "WB_DRAW";

//
//
// Function:    Constructor
//
// Purpose:     Initialize the drawing area object
//
//
WbDrawingArea::WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::WbDrawingArea");

    g_pDraw = this;

    m_hwnd = NULL;

    m_hDCWindow = NULL;
    m_hDCCached = NULL;

    m_originOffset.cx = 0;
    m_originOffset.cy = 0;

    m_posScroll.x     = 0;
    m_posScroll.y     = 0;

    // Show that the drawing area is not zoomed
    m_iZoomFactor = 1;
    m_iZoomOption = 1;

    // Show that the left mouse button is up
    m_bLButtonDown = FALSE;
    m_bIgnoreNextLClick = FALSE;
    m_bBusy = FALSE;
    m_bLocked = FALSE;
    m_HourGlass = FALSE;

    // Indicate that the cached zoom scroll position is invalid
    m_zoomRestoreScroll = FALSE;

    // Show that we are not currently editing text
    m_bGotCaret = FALSE;
    m_bTextEditorActive = FALSE;
    m_pActiveText = NULL;


    // Show that no graphic object is in progress
    m_pGraphicTracker = NULL;

    // Show that the marker is not present.
    m_bMarkerPresent = FALSE;
    m_bNewMarkedGraphic = FALSE;
    m_pSelectedGraphic = NULL;
    m_bTrackingSelectRect = FALSE;

    // Show that no area is currently marked
    ::SetRectEmpty(&m_rcMarkedArea);

    // Show we haven't got a tool yet
    m_pToolCur = NULL;

    // Show that we dont have a page attached yet
    m_hPage = WB_PAGE_HANDLE_NULL;

    m_hStartPaintGraphic = NULL;

    m_pMarker = new DCWbGraphicMarker;
    if (!m_pMarker)
    {
        ERROR_OUT(("Failed to create m_pMarker in WbDrawingArea object constructor"));
    }
}


//
//
// Function:    Destructor
//
// Purpose:     Close down the drawing area
//
//
WbDrawingArea::~WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::~WbDrawingArea");

    if (m_pActiveText != NULL)
    {
        delete m_pActiveText;
        m_pActiveText = NULL;
    }

    if (m_hDCWindow != NULL)
    {
        ::ReleaseDC(m_hwnd, m_hDCWindow);
        m_hDCWindow = NULL;
    }

    m_hDCCached = NULL;

    if (m_pMarker != NULL)
    {
		delete m_pMarker;
		m_pMarker = NULL;
	}

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szDrawClassName, g_hInstance);

	g_pDraw = NULL;

    //
    // Clean the pointer lists
    //
    m_allPointers.EmptyList();
    m_undrawnPointers.EmptyList();
}

//
// WbDrawingArea::Create()
//
BOOL WbDrawingArea::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Create");

    if (!m_pMarker)
    {
        ERROR_OUT(("Failing WbDrawingArea::Create; couldn't allocate m_pMarker"));
        return(FALSE);
    }

    // Get our cursor
    m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENFREEHANDCURSOR));

    //
    // Register the window class
    //
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_OWNDC;
    wc.lpfnWndProc      = DrawWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = m_hCursor;
    wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName    = szDrawClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbDraw::Create register class failed"));
        return(FALSE);
    }

    //
    // Create our window
    //
    ASSERT(m_hwnd == NULL);

    if (!::CreateWindowEx(WS_EX_CLIENTEDGE, szDrawClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
        WS_CLIPCHILDREN,
        lprect->left, lprect->top, lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Initialize remaining data members
    //
    ASSERT(!m_bBusy);
    ASSERT(!m_bLocked);
    ASSERT(!m_HourGlass);

    // Start and end points of the last drawing operation
    m_ptStart.x = m_originOffset.cx;
    m_ptStart.y = m_originOffset.cy;
    m_ptEnd = m_ptStart;

    // Set the width to be used for marker handles.
    ASSERT(m_pMarker);
    m_pMarker->SetPenWidth(DRAW_HANDLESIZE);

    // Get the zoom factor to be used
    m_iZoomOption = DRAW_ZOOMFACTOR;

    m_hDCWindow = ::GetDC(m_hwnd);
    m_hDCCached = m_hDCWindow;

    PrimeDC(m_hDCCached);
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);
    return(TRUE);
}



//
// DrawWndProc()
// Message handler for the drawing area
//
LRESULT CALLBACK DrawWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbDrawingArea * pDraw = (WbDrawingArea *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pDraw = (WbDrawingArea *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pDraw);

            pDraw->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pDraw);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pDraw);
            pDraw->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pDraw);
            pDraw->OnPaint();
            break;

        case WM_MOUSEMOVE:
            ASSERT(pDraw);
            pDraw->OnMouseMove((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pDraw);
            pDraw->OnLButtonDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            ASSERT(pDraw);
            pDraw->OnLButtonUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CONTEXTMENU:
            ASSERT(pDraw);
            pDraw->OnContextMenu(LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SIZE:
            ASSERT(pDraw);
            pDraw->OnSize((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_HSCROLL:
            ASSERT(pDraw);
            pDraw->OnHScroll(GET_WM_HSCROLL_CODE(wParam, lParam),
                GET_WM_HSCROLL_POS(wParam, lParam));
            break;

        case WM_VSCROLL:
            ASSERT(pDraw);
            pDraw->OnVScroll(GET_WM_VSCROLL_CODE(wParam, lParam),
                GET_WM_VSCROLL_POS(wParam, lParam));
            break;

        case WM_CTLCOLOREDIT:
            ASSERT(pDraw);
            lResult = pDraw->OnEditColor((HDC)wParam);
            break;

        case WM_SETFOCUS:
            ASSERT(pDraw);
            pDraw->OnSetFocus();
            break;

        case WM_ACTIVATE:
            ASSERT(pDraw);
            pDraw->OnActivate(GET_WM_ACTIVATE_STATE(wParam, lParam));
            break;

        case WM_SETCURSOR:
            ASSERT(pDraw);
            lResult = pDraw->OnCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CANCELMODE:
            ASSERT(pDraw);
            pDraw->OnCancelMode();
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    RealizePalette
//
// Purpose:     Realize the drawing area palette
//
//
void WbDrawingArea::RealizePalette( BOOL bBackground )
{
    UINT entriesChanged;
    HDC hdc = m_hDCCached;

    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        HPALETTE    hPalette = PG_GetPalette();
        if (hPalette != NULL)
        {
            // get our 2cents in
            m_hOldPalette = ::SelectPalette(hdc, hPalette, bBackground);
            entriesChanged = ::RealizePalette(hdc);

            // if mapping changes go repaint
            if (entriesChanged > 0)
                ::InvalidateRect(m_hwnd, NULL, TRUE);
        }
    }
}


LRESULT WbDrawingArea::OnEditColor(HDC hdc)
{
    HPALETTE    hPalette = PG_GetPalette();

    if (hPalette != NULL)
    {
        ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);
    }

    ::SetTextColor(hdc, SET_PALETTERGB( m_textEditor.m_clrPenColor ) );

    return((LRESULT)::GetSysColorBrush(COLOR_WINDOW));
}

//
//
// Function:    OnPaint
//
// Purpose:     Paint the window. This routine is called whenever Windows
//              issues a WM_PAINT message for the Whiteboard window.
//
//
void WbDrawingArea::OnPaint(void)
{
    RECT        rcUpdate;
    RECT        rcTmp;
    RECT        rcBounds;
    HDC         hSavedDC;
    HPEN        hSavedPen;
    HBRUSH      hSavedBrush;
    HPALETTE    hSavedPalette;
    HPALETTE    hPalette;
    HFONT       hSavedFont;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnPaint");

    // Get the update rectangle
    ::GetUpdateRect(m_hwnd, &rcUpdate, FALSE);

    if (Zoomed())
    {
        ::InflateRect(&rcUpdate, 1, 1);
        InvalidateSurfaceRect(&rcUpdate);
    }

    // Can only do any painting if we have a valid page
    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        // Determine whether any of the remote pointers are to be redrawn.
        // If they are they must be added to the update region to allow them
        // to redraw correctly. This is because they save the bits underneath
        // them and blit them back onto the screen as they are moved.
        if (m_allPointers.IsEmpty() == FALSE)
        {
            TRACE_MSG(("Remote pointer is dispayed"));
            POSITION pos = m_allPointers.GetHeadPosition();
            while (pos != NULL)
            {
                DCWbGraphicPointer* pPointer
                    = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);

                pPointer->GetBoundsRect(&rcBounds);
                if (::IntersectRect(&rcTmp, &rcBounds, &rcUpdate))
                {
                    TRACE_MSG(("Invalidating remote pointer"));
                    InvalidateSurfaceRect(&rcBounds);
                }
            }
        }
    }

    // Start painting
    PAINTSTRUCT     ps;

    ::BeginPaint(m_hwnd, &ps);

    hSavedDC      =   m_hDCCached;
    hSavedFont    =   m_hOldFont;
    hSavedPen     =   m_hOldPen;
    hSavedBrush   =   m_hOldBrush;
    hSavedPalette =   m_hOldPalette;

    TRACE_MSG(("Flipping cache to paint DC"));
    m_hDCCached   =   ps.hdc;
    PrimeDC(m_hDCCached);

    // Only draw anything if we have a valid page attached
    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        // set palette
        hPalette = PG_GetPalette();
        if (hPalette != NULL)
        {
            m_hOldPalette = ::SelectPalette(m_hDCCached, hPalette, FALSE );
            ::RealizePalette(m_hDCCached);
        }

        //
        // Draw the graphic objects
        //
        DCWbGraphic* pGraphic;
        WB_GRAPHIC_HANDLE hStart;

        if( m_hStartPaintGraphic != NULL )
        {
            hStart = m_hStartPaintGraphic;
            m_hStartPaintGraphic = NULL;

            pGraphic = DCWbGraphic::ConstructGraphic(m_hPage, hStart);
        }
        else
        {
            pGraphic = PG_First(m_hPage, &hStart, &rcUpdate);
        }

        while (pGraphic != NULL)
        {
            ASSERT(pGraphic->Handle() == hStart);

            // Do not draw the active text graphic yet (it is drawn topmost)
            if (!m_bTextEditorActive || (hStart != m_textEditor.Handle()))
            {
                TRACE_MSG(("Drawing a normal graphic"));
                pGraphic->Draw(m_hDCCached, this);
            }

            // Release the current graphic
            delete pGraphic;

            // Get the next one
            pGraphic = PG_Next(m_hPage, &hStart, &rcUpdate);
        }

        //
        // Draw the marker
        //
        if (GraphicSelected() == TRUE)
        {
            TRACE_MSG(("Drawing the marker"));
            DrawMarker(m_hDCCached);
        }

        //
        // Draw the remote pointers that are on this page
        //
        if (m_allPointers.IsEmpty() == FALSE)
        {
            POSITION pos = m_allPointers.GetHeadPosition();
            while (pos != NULL)
            {
                DCWbGraphicPointer* pPointer
                    = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);

                pPointer->GetBoundsRect(&rcTmp);
                if (::IntersectRect(&rcTmp, &rcTmp, &rcUpdate))
                {
                    TRACE_MSG(("Drawing remote pointer"));
                    pPointer->DrawSave(m_hDCCached, this);
                }
            }
        }

        //
        // Draw the tracking graphic
        // But not if it is a remote pointer since this has already been done
        // above and Draw() is not the correct function to use for Rem Ptr
        //
        if ((m_pGraphicTracker != NULL)   &&
            !EqualPoint(m_ptStart, m_ptEnd) &&
            !(m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer))
        {
            TRACE_MSG(("Drawing the tracking graphic"));
            m_pGraphicTracker->Draw(m_hDCCached, this);
        }

        if (hPalette != NULL)
        {
            ::SelectPalette(m_hDCCached, m_hOldPalette, TRUE);
        }

        // fixes painting problems for bug 2185
        if( TextEditActive() )
        {
            RedrawTextEditbox();
        }
    }

    //
    // Restore the DC to its original state
    //
    UnPrimeDC(m_hDCCached);

    m_hOldFont      = hSavedFont;
    m_hOldPen       = hSavedPen;
    m_hOldBrush     = hSavedBrush;
    m_hOldPalette   = hSavedPalette;
    m_hDCCached     = hSavedDC;

    // Finish painting
    ::EndPaint(m_hwnd, &ps);
}


//
// Selects all graphic objs contained in rectSelect. If rectSelect is
// NULL then ALL objs are selected
//
void WbDrawingArea::SelectMarkerFromRect(LPCRECT lprcSelect)
{
    BOOL bSomethingWasPicked = FALSE;
    DCWbGraphic* pGraphic;
    WB_GRAPHIC_HANDLE hStart;
    RECT    rc;

    if (g_pwbCore->WBP_PageCountGraphics(m_hPage) <= 0 )
        return;

    m_HourGlass = TRUE;
    SetCursorForState();

    RemoveMarker( NULL );

    pGraphic = PG_First(m_hPage, &hStart, lprcSelect, TRUE);
    while (pGraphic != NULL)
    {
        // add obj to marker list if its not locked - bug 2185
        pGraphic->GetBoundsRect(&rc);

        ASSERT(m_pMarker);
        if (m_pMarker->SetRect(&rc, pGraphic, FALSE))
        {
            m_pSelectedGraphic = pGraphic;
            bSomethingWasPicked = TRUE;
        }

        // Get the next one
        pGraphic = PG_Next(m_hPage, &hStart, lprcSelect, TRUE );
    }

    if( bSomethingWasPicked )
        PutMarker( NULL );

    m_HourGlass = FALSE;
    SetCursorForState();
}



//
//
// Function:    OnTimer
//
// Purpose:     Process a timer event. These are used to update freehand and
//              text objects while they are being drawn/edited and to
//              update the remote pointer position when the mouse stops.
//
//
void WbDrawingArea::OnTimer(UINT idTimer)
{
    TRACE_TIMER(("WbDrawingArea::OnTimer"));

    // We are only interested if the user is drawing something or editing
    if (m_bLButtonDown == TRUE)
    {
        // If the user is dragging an object or drawing a freehand line
        if (m_pGraphicTracker != NULL)
        {
            // If the user is drawing a freehand line
            if (m_pGraphicTracker->IsGraphicTool() == enumGraphicFreeHand)
            {

                // The update only writes the new version if changes have been made
                if (m_pGraphicTracker->Handle() == NULL)
                {
                    m_pGraphicTracker->AddToPageLast(m_hPage);
                }
                else
                {
                    m_pGraphicTracker->Replace();
                }
            }

            //
            // If the user is dragging a remote pointer (have to check
            // m_pGraphicTracker for NULL again in case OnLButtonUp was
            // called (bug 4685))
            //
            if ( m_pGraphicTracker != NULL )
            {
                if (m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer)
                {
                    // The update only writes the new version if changes have been made
                    m_pGraphicTracker->Update();
                }
            }
        }
    }
}



//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbDrawingArea::OnSize(UINT nType, int cx, int cy)
{
    // Only process this message if the window is not minimized
    if (   (nType == SIZEFULLSCREEN)
        || (nType == SIZENORMAL))
    {
        if (TextEditActive())
        {
            TextEditParentResize();
        }

        // Set the new scroll range (based on the new client area)
        SetScrollRange(cx, cy);

        // Ensure that the scroll position lies in the new scroll range
        ValidateScrollPos();

        // make page move if needed
        ScrollWorkspace();

        // Update the scroll bars
        ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
        ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);
    }
}


//
//
// Function:    SetScrollRange
//
// Purpose:     Set the current scroll range. The range is based on the
//              work surface size and the size of the client area.
//
//
void WbDrawingArea::SetScrollRange(int cx, int cy)
{
    SCROLLINFO scinfo;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetScrollRange");

    // If we are in zoom mode, then allow for the magnification
    ASSERT(m_iZoomFactor != 0);
    cx /= m_iZoomFactor;
    cy /= m_iZoomFactor;

    ZeroMemory( &scinfo,  sizeof (SCROLLINFO) );
    scinfo.cbSize = sizeof (SCROLLINFO);
    scinfo.fMask = SIF_PAGE    | SIF_RANGE|
                    SIF_DISABLENOSCROLL;

    // Set the horizontal scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_WIDTH - 1;
    scinfo.nPage = cx;
    ::SetScrollInfo(m_hwnd, SB_HORZ, &scinfo, FALSE);

    // Set the vertical scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_HEIGHT - 1;
    scinfo.nPage = cy;
    ::SetScrollInfo(m_hwnd, SB_VERT, &scinfo, FALSE);
}

//
//
// Function:    ValidateScrollPos
//
// Purpose:     Ensure that the current scroll position is within the bounds
//              of the current scroll range. The scroll range is set to
//              ensure that the window on the worksurface never extends
//              beyond the surface boundaries.
//
//
void WbDrawingArea::ValidateScrollPos()
{
    int iMax;
    SCROLLINFO scinfo;

    // Validate the horixontal scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_HORZ, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage + 1;
    m_posScroll.x = max(m_posScroll.x, 0);
    m_posScroll.x = min(m_posScroll.x, iMax);

    // Validate the vertical scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_VERT, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage + 1;
    m_posScroll.y = max(m_posScroll.y, 0);
    m_posScroll.y = min(m_posScroll.y, iMax);
}

//
//
// Function:    ScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::ScrollWorkspace(void)
{
    RECT rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ScrollWorkspace");

    //
    // Determine whether any of the remote pointers are to be redrawn.  If
    // they are they must be added to the update region to allow them to
    // redraw correctly.  This is because they save the bits underneath them
    // and blit them back onto the screen as they are moved.
    //
    if (!m_allPointers.IsEmpty())
    {
        TRACE_MSG(("Remote pointer is dispayed - invalidate before scroll"));
        POSITION pos = m_allPointers.GetHeadPosition();

        while (pos != NULL)
        {
            DCWbGraphicPointer* pPointer
             = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);

            TRACE_MSG(("Invalidating remote pointer"));
            pPointer->GetBoundsRect(&rc);
            InvalidateSurfaceRect(&rc);
        }
    }

    // Do the scroll
    DoScrollWorkspace();

    // Tell the parent that the scroll position has changed
    HWND    hwndParent;

    hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);
    }
}

//
//
// Function:    DoScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::DoScrollWorkspace()
{
    // Validate the scroll position
    ValidateScrollPos();

    // Set the scroll box position
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Only update the screen if the scroll position has changed
    if ( (m_originOffset.cy != m_posScroll.y)
        || (m_originOffset.cx != m_posScroll.x) )
    {
        // Calculate the amount to scroll
        INT iVScrollAmount = m_originOffset.cy - m_posScroll.y;
        INT iHScrollAmount = m_originOffset.cx - m_posScroll.x;

        // Save the new position (for UpdateWindow)
        m_originOffset.cx = m_posScroll.x;
        m_originOffset.cy = m_posScroll.y;

        ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

        // Scroll and redraw the newly invalidated portion of the window
        ::ScrollWindow(m_hwnd, iHScrollAmount, iVScrollAmount, NULL, NULL);
        ::UpdateWindow(m_hwnd);
    }
}

//
//
// Function:    GotoPosition
//
// Purpose:     Move the top-left corner of the workspace to the specified
//              position in the workspace.
//
//
void WbDrawingArea::GotoPosition(int x, int y)
{
    // Set the new scroll position
    m_posScroll.x = x;
    m_posScroll.y = y;

    // Scroll to the new position
    DoScrollWorkspace();

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnVScroll
//
// Purpose:     Process a WM_VSCROLL messages.
//
//
void WbDrawingArea::OnVScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle HEIGHT
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.top == 0);
    rcClient.bottom -= rcClient.top;

    // Act on the scroll code
    switch(nSBCode)
    {
        // Scroll to bottom
        case SB_BOTTOM:
            m_posScroll.y = DRAW_HEIGHT - rcClient.bottom;
            break;

        // Scroll down a line
        case SB_LINEDOWN:
            m_posScroll.y += DRAW_LINEVSCROLL;
            break;

        // Scroll up a line
        case SB_LINEUP:
            m_posScroll.y -= DRAW_LINEVSCROLL;
            break;

        // Scroll down a page
        case SB_PAGEDOWN:
            m_posScroll.y += rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll up a page
        case SB_PAGEUP:
            m_posScroll.y -= rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll to the top
        case SB_TOP:
            m_posScroll.y = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.y = nPos; // don't round
            break;

        default:
        break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnHScroll
//
// Purpose:     Process a WM_HSCROLL messages.
//
//
void WbDrawingArea::OnHScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle WIDTH
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.left == 0);
    rcClient.right -= rcClient.left;

    switch(nSBCode)
    {
        // Scroll to the far right
        case SB_BOTTOM:
            m_posScroll.x = DRAW_WIDTH - rcClient.right;
            break;

        // Scroll right a line
        case SB_LINEDOWN:
            m_posScroll.x += DRAW_LINEHSCROLL;
            break;

        // Scroll left a line
        case SB_LINEUP:
            m_posScroll.x -= DRAW_LINEHSCROLL;
            break;

        // Scroll right a page
        case SB_PAGEDOWN:
            m_posScroll.x += rcClient.right / m_iZoomFactor;
            break;

        // Scroll left a page
        case SB_PAGEUP:
            m_posScroll.x -= rcClient.right / m_iZoomFactor;
            break;

        // Scroll to the far left
        case SB_TOP:
            m_posScroll.x = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.x = nPos; // don't round
            break;

        default:
            break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}


//
//
// Function:    AutoScroll
//
// Purpose:     Auto-scroll the window to bring the position passed as
//              parameter into view.
//
//
BOOL WbDrawingArea::AutoScroll
(
    int     xSurface,
    int     ySurface,
    BOOL    bMoveCursor,
    int     xCaret,
    int     yCaret
)
{
    int nXPSlop, nYPSlop;
    int nXMSlop, nYMSlop;
    int nDeltaHScroll, nDeltaVScroll;
    BOOL bDoScroll = FALSE;

    nXPSlop = 0;
    nYPSlop = 0;
    nXMSlop = 0;
    nYMSlop = 0;

    if( TextEditActive() )
    {
        POINT   ptDirTest;

        ptDirTest.x = xSurface - xCaret;
        ptDirTest.y = ySurface - yCaret;

        // set up for text editbox
        if( ptDirTest.x > 0 )
            nXPSlop = m_textEditor.m_textMetrics.tmMaxCharWidth;
        else
        if( ptDirTest.x < 0 )
            nXMSlop = -m_textEditor.m_textMetrics.tmMaxCharWidth;

        if( ptDirTest.y > 0 )
            nYPSlop = m_textEditor.m_textMetrics.tmHeight;
        else
        if( ptDirTest.y < 0 )
            nYMSlop = -m_textEditor.m_textMetrics.tmHeight;

        nDeltaHScroll = m_textEditor.m_textMetrics.tmMaxCharWidth;
        nDeltaVScroll = m_textEditor.m_textMetrics.tmHeight;
    }
    else
    {
        // set up for all other objects
        nDeltaHScroll = DRAW_LINEHSCROLL;
        nDeltaVScroll = DRAW_LINEVSCROLL;
    }

    // Get the current visible surface rectangle
    RECT  visibleRect;
    GetVisibleRect(&visibleRect);

    // Check for pos + slop being outside visible area
    if( (xSurface + nXPSlop) >= visibleRect.right )
    {
        bDoScroll = TRUE;
        m_posScroll.x +=
            (((xSurface + nXPSlop) - visibleRect.right) + nDeltaHScroll);
    }

    if( (xSurface + nXMSlop) < visibleRect.left )
    {
        bDoScroll = TRUE;
        m_posScroll.x -=
            ((visibleRect.left - (xSurface + nXMSlop)) + nDeltaHScroll);
    }

    if( (ySurface + nYPSlop) >= visibleRect.bottom)
    {
        bDoScroll = TRUE;
        m_posScroll.y +=
            (((ySurface + nYPSlop) - visibleRect.bottom) + nDeltaVScroll);
    }

    if( (ySurface + nYMSlop) < visibleRect.top)
    {
        bDoScroll = TRUE;
        m_posScroll.y -=
            ((visibleRect.top - (ySurface + nYMSlop)) + nDeltaVScroll);
    }

    if( !bDoScroll )
        return( FALSE );

    // Indicate that scrolling has completed (in both directions)
    ScrollWorkspace();

    // Update the mouse position (if required)
    if (bMoveCursor)
    {
        POINT   screenPos;

        screenPos.x = xSurface;
        screenPos.y = ySurface;

        SurfaceToClient(&screenPos);
        ::ClientToScreen(m_hwnd, &screenPos);
        ::SetCursorPos(screenPos.x, screenPos.y);
    }

    return( TRUE );
}

//
//
// Function:    OnCursor
//
// Purpose:     Process a WM_SETCURSOR messages.
//
//
LRESULT WbDrawingArea::OnCursor(HWND hwnd, UINT uiHit, UINT uMsg)
{
    BOOL bResult = FALSE;

    // Check that this message is for the main window
    if (hwnd == m_hwnd)
    {
        // If the cursor is now in the client area, set the cursor
        if (uiHit == HTCLIENT)
        {
            bResult = SetCursorForState();
        }
        else
        {
            // Restore the cursor to the standard arrow. Set m_hCursor to NULL
            // to indicate that we have not set a special cursor.
            m_hCursor = NULL;
           ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
            bResult = TRUE;
        }
    }

    // Return result indicating whether we processed the message or not
    return bResult;
}

//
//
// Function:    SetCursorForState
//
// Purpose:     Set the cursor for the current state
//
//
BOOL WbDrawingArea::SetCursorForState(void)
{
    BOOL    bResult = FALSE;

    m_hCursor = NULL;

    // If the drawing area is locked, use the "locked" cursor
    if (m_HourGlass)
    {
        m_hCursor = ::LoadCursor( NULL, IDC_WAIT );
    }
    else if (m_bLocked)
    {
        // Return the cursor for the tool
        m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( LOCKCURSOR ));
    }
    else if (m_pToolCur != NULL)
    {
        // Get the cursor for the tool currently in use
        m_hCursor = m_pToolCur->GetCursorForTool();
    }

    if (m_hCursor != NULL)
    {
        ::SetCursor(m_hCursor);
        bResult = TRUE;
    }

    // Return result indicating whether we set the cursor or not
    return bResult;
}

//
//
// Function:    Lock
//
// Purpose:     Lock the drawing area, preventing further updates
//
//
void WbDrawingArea::Lock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Lock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Stop any drawing we are doing.
    CancelDrawingMode();

    // Deselect any selected graphic
    ClearSelection();

    // Show that we are now locked
    m_bLocked = TRUE;
    TRACE_MSG(("Drawing area is now locked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}

//
//
// Function:    Unlock
//
// Purpose:     Unlock the drawing area, preventing further updates
//
//
void WbDrawingArea::Unlock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Unlock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Show that we are now unlocked
    m_bLocked = FALSE;
    TRACE_MSG(("Drawing area is now UNlocked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}



//
//
// Function:    GraphicAdded
//
// Purpose:     A graphic has been added to the page - update the drawing
//              area.
//
//
void WbDrawingArea::GraphicAdded(DCWbGraphic* pAddedGraphic)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    HDC         hDC;
    RECT        rcUpdate;
    RECT        rcBounds;
    RECT        rcT;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicAdded");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Get the current update rectangle
    ::GetUpdateRect(m_hwnd, &rcUpdate, FALSE);

    // Check if the object is the uppermost in the page,
    // if it is we can draw it onto the window without
    // playing the whole contents of the page.
    // (If there the invalid part of the window touches the rectangle of
    // the graphic which has just been added, we just invalidate the area
    // occupied by the new graphic to get it drawn.)

    pAddedGraphic->GetBoundsRect(&rcBounds);
    if ((pAddedGraphic->IsTopmost()) &&
        !::IntersectRect(&rcT, &rcUpdate, &rcBounds))
    {
        // Get a device context for drawing
        hDC = m_hDCCached;

        // set up palette
        if ( (m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
        {
            hOldPal = ::SelectPalette(hDC, hPal, FALSE);
            ::RealizePalette(hDC);
        }

        // Remove the remote pointers from the affected area
        RemovePointers(hDC, &rcBounds);

        // Remove the marker and save whether it is to be restored later
        BOOL bSaveMarkerPresent = m_bMarkerPresent;
        RemoveMarker(NULL);

        // Play the new graphic into the context
        pAddedGraphic->Draw(hDC);

        // Restore the marker (if necessary)
        if (bSaveMarkerPresent == TRUE)
        {
            PutMarker(NULL);
        }

        // Restore the remote pointers
        PutPointers(hDC);

        // If we are editting some text, make editbox redraw
        if (m_bTextEditorActive && (m_textEditor.Handle() != NULL))
        {
            RECT    rcText;

            m_textEditor.GetBoundsRect(&rcText);

            // Include the client border
            InflateRect(&rcText, ::GetSystemMetrics(SM_CXEDGE),
                ::GetSystemMetrics(SM_CYEDGE));
            InvalidateSurfaceRect(&rcText);
        }

        if (hOldPal != NULL)
        {
            ::SelectPalette(hDC, hOldPal, TRUE);
        }
    }
    else
    {
        // Update the area occupied by the object
        InvalidateSurfaceRect(&rcBounds);
    }
}


//
//
// Function:    PointerUpdated
//
// Purpose:     A remote pointer has been added, removed or updated - make
//              the change on the screen.
//
//
void WbDrawingArea::PointerUpdated
(
    DCWbGraphicPointer*     pPointer,
    BOOL                    bForcedRemove
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PointerUpdated");

    ASSERT(pPointer != NULL);

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Determine whether the pointer has been added, removed, or just updated
    DCWbGraphicPointer* pUndrawFrom = pPointer;
    POSITION posBefore = m_allPointers.Lookup(pPointer);
    POSITION posAfter = NULL;
    if (posBefore == NULL)
    {
        // The pointer is not currently drawn

        // Check whether the pointer is active
        if ((pPointer->IsActive()) && !bForcedRemove)
        {
            // Determine where the pointer should go on the drawn list
            if (   (pPointer->IsLocalPointer())
                || (m_allPointers.IsEmpty() == TRUE))
            {
                // The local pointer always goes at the end
                posAfter = m_allPointers.AddTail(pPointer);
            }
            else
            {
                // Find the next active pointer on the page (we already
                // know that allPointers is not empty from the test above).
                posAfter = m_allPointers.GetTailPosition();
                pUndrawFrom = (DCWbGraphicPointer*) m_allPointers.GetFromPosition(posAfter);
                if (!pUndrawFrom->IsLocalPointer())
                {
                    pUndrawFrom = PG_NextPointer(m_hPage, pPointer);
                }

	            posAfter = m_allPointers.AddTail(pPointer);
            }
        }
    }
    else
    {
        // The pointer is already in our list
        pUndrawFrom = pPointer;
    }

    // If we have something to do
    if ((posBefore != NULL) || (posAfter  != NULL))
    {
        if (pUndrawFrom != NULL)
        {
            // Undraw all pointers in the vicinity of the updated pointer
            RECT    rcT;
            RECT    rcBounds;

            pPointer->GetDrawnRect(&rcT);
            pPointer->GetBoundsRect(&rcBounds);
            ::UnionRect(&rcT, &rcT, &rcBounds);
            RemovePointers(NULL, pUndrawFrom, &rcT);
         }

        // If the updated pointer is no longer active we do not want
        // to redraw it, and want to remove it from the active pointer
        // list.
        POSITION posUndrawn = m_undrawnPointers.Lookup(pPointer);
        if ((pPointer->IsActive() == FALSE) || (bForcedRemove == TRUE))
        {
            // Remove it from the undrawn pointers list (so it does not
            // get drawn again).
            if (posUndrawn != NULL)
            {
                m_undrawnPointers.RemoveAt(posUndrawn);
            }

            // Remove it from the list of all active pointers on the page.
            posUndrawn = m_allPointers.Lookup(pPointer);
            if (posUndrawn != NULL)
            {
                m_allPointers.RemoveAt(posUndrawn);
            }
        }
        else
        {
            // If this pointer was not previously active it will not
            // be in the undrawn list and will therefore not get redrawn. So
            // add it to the list to get it drawn. (It goes at the head of the
            // list because we have undrawn all pointers above it.)
            if (posUndrawn == NULL)
            {
                m_undrawnPointers.AddTail(pPointer);
            }
        }

        // Restore all the remote pointers that were removed
        PutPointers(NULL);
    }
}

//
//
// Function:    RemovePointers
//
// Purpose:     Remove all remote pointers that are above and overlap
//              the specified pointer.
//
//
void WbDrawingArea::RemovePointers
(
    HDC                 hPassedDC,
    DCWbGraphicPointer* pPointerUpdate
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemovePointers");

    // Show that we have not removed any pointers yet
    m_undrawnPointers.EmptyList();

    // Do nothing if the pointer specified is NULL
    if (pPointerUpdate != NULL)
    {
        RECT    rcUpdate;

        ::SetRectEmpty(&rcUpdate);
        RemovePointers(hPassedDC, pPointerUpdate, &rcUpdate);
    }
}

//
//
// Function:    RemovePointers
//
// Purpose:     Remove all remote pointers that overlap a rectangle on the
//              surface.
//
//
void WbDrawingArea::RemovePointers
(
    HDC     hPassedDC,
    LPCRECT lprc
)
{
    RECT    rcT;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemovePointers");

    // Show that we have not removed any pointers yet
    m_undrawnPointers.EmptyList();

    // Only do anything if the rectangle given is visible
    GetVisibleRect(&rcT);
    if (::IntersectRect(&rcT, &rcT, lprc))
    {
        RemovePointers(hPassedDC, NULL, lprc);
    }
}

//
//
// Function:    RemovePointers
//
// Purpose:     Remove all remote pointers that overlap a rectangle on the
//              surface.
//
//
void WbDrawingArea::RemovePointers
(
    HDC                 hDC,
    DCWbGraphicPointer* pPointerStart,
    LPCRECT             lprcOverlap
)
{
    RECT                rcT;
    RECT                rcT2;
    RECT                rcDrawn;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemovePointers");

    // Show that we have not removed any pointers yet
    m_undrawnPointers.EmptyList();

    // Get our own DC (if necessary)
    if (!hDC)
        hDC = m_hDCCached;

    // We needn't do anything if the pointer and rectangles given
    // are both off-screen.
    GetVisibleRect(&rcT);

    BOOL bNeedCheck = FALSE;
    if (pPointerStart != NULL)
    {
        pPointerStart->GetDrawnRect(&rcT2);
        if (::IntersectRect(&rcT2, &rcT2, &rcT))
        {
            bNeedCheck = TRUE;
        }
    }

    // A NULL overlap rect means empty
    if (::IntersectRect(&rcT, &rcT, lprcOverlap))
    {
        bNeedCheck = TRUE;
    }

    if (bNeedCheck)
    {
        // Get a list of all pointers on the page (with the local
        // pointer last in the list).
        POSITION allPos = m_allPointers.GetHeadPosition();

        // We must undraw pointers in decreasing Z-order.
        // With more than two pointers the effect of removing
        // a pointer can require another pointer to be removed also:
        // (pointer A overlaps pointer B, and B overlaps C without A and
        // C overlapping each other directly). To get round this we build
        // a list of pointers to be removed (and redrawn) as we go.

        // If we are starting from a pointer
        if (pPointerStart != NULL)
        {
            // Get the position of the start pointer
            POSITION startPos = m_allPointers.Lookup(pPointerStart);

            // If the pointer was not found, this is an error
            ASSERT(startPos != NULL);

            // Save the start position for the search
            m_allPointers.GetNext(startPos);
            allPos = startPos;

            // Add the updated pointer to the remove list
            m_undrawnPointers.AddTail(pPointerStart);

            // If the rectangle passed in is empty, set it to the rectangle
            // of the pointer passed in.
            if (::IsRectEmpty(lprcOverlap))
            {
                pPointerStart->GetDrawnRect(&rcDrawn);
                lprcOverlap = &rcDrawn;
            }
        }

        // For each pointer above the start, check whether it overlaps
        // any pointer in the list already built, or the rectangle passed in.

        DCWbGraphicPointer* pPointerCheck;
        while (allPos != NULL)
        {
            // Get the pointer to be tested
            pPointerCheck = (DCWbGraphicPointer*) m_allPointers.GetNext(allPos);

            // Get the rectangle it is currently occupying on the surface
            // Check for overlap with the passed rectangle
            pPointerCheck->GetDrawnRect(&rcT2);
            if (::IntersectRect(&rcT, &rcT2, lprcOverlap))
            {
                m_undrawnPointers.AddTail(pPointerCheck);
            }
        }

		// Create a reversed list
		CWBOBLIST worklist;
        DCWbGraphicPointer* pPointer;

        POSITION pos = m_undrawnPointers.GetHeadPosition();
        while (pos != NULL)
        {
            pPointer  = (DCWbGraphicPointer*) m_undrawnPointers.GetNext(pos);
			worklist.AddHead(pPointer);
		}

        // Now remove the pointers, walking through the reverde list
        pos = worklist.GetHeadPosition();
        while (pos != NULL)
        {
            // Remove it
            pPointer = (DCWbGraphicPointer*) worklist.GetNext(pos);
            pPointer->Undraw(hDC, this);
        }

		worklist.EmptyList();
    }
}

//
//
// Function:    PutPointers
//
// Purpose:     Draw all remote pointers in the pointer redraw list.
//
//
void WbDrawingArea::PutPointers
(
    HDC         hDC,
    COBLIST*    pUndrawList
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PutPointers");

    if (!hDC)
        hDC = m_hDCCached;

    // Get the start position in the list for drawing
    if (pUndrawList == NULL)
    {
        pUndrawList = &m_undrawnPointers;
    }

    // Do the redrawing
    DCWbGraphicPointer* pPointer;
    POSITION pos = pUndrawList->GetHeadPosition();
    while (pos != NULL)
    {
        // Get the next pointer
        pPointer = (DCWbGraphicPointer*) pUndrawList->GetNext(pos);
        pPointer->Redraw(hDC, this);
    }
}

//
//
// Function:    PageCleared
//
// Purpose:     The page has been cleared
//
//
void WbDrawingArea::PageCleared(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PageCleared");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Discard any text being edited
    if (m_bTextEditorActive)
    {
        if (m_bLocked)
        {
            DeactivateTextEditor();
        }
        else
        {
            EndTextEntry(FALSE);
        }
    }

    // Remove the copy of the marked graphic and the marker
    ClearSelection();

    // Invalidate the whole window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    GraphicDeleted
//
// Purpose:     A graphic has been removed from the page - update the
//              drawing area.
//
//
void WbDrawingArea::GraphicDeleted(DCWbGraphic* pDeletedGraphic)
{
    DCWbGraphic* pDeletedMarker;
    RECT rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicDeleted");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Check whether the graphic being deleted is selected
    ASSERT(m_pMarker);

    if( GraphicSelected() &&
        ((pDeletedMarker = m_pMarker->HasAMarker( pDeletedGraphic )) != NULL) )
    {
        // remove marker corresponding to the deleted graphic
        delete pDeletedMarker;

        // if deleted graphic was also the last selection, use prev selection
        // (carefull...m_pSelectedGraphic is invalid now if this is true)
        if( m_pSelectedGraphic == pDeletedMarker ) //only safe comparision
            m_pSelectedGraphic = m_pMarker->LastMarker();
    }

    // Invalidate the area occupied by the object
    pDeletedGraphic->GetBoundsRect(&rcBounds);
    InvalidateSurfaceRect(&rcBounds);
}

//
//
// Function:    GraphicUpdated
//
// Purpose:     A graphic in the page has been updated - update the
//              drawing area.
//
//
void WbDrawingArea::GraphicUpdated
(
    DCWbGraphic* pUpdatedGraphic,
    BOOL    bUpdateMarker,
    BOOL    bErase
)
{
    DCWbGraphic* pUpdatedMarker;
    BOOL    bWasEqual;
    RECT    rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicUpdated");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // If the graphic being updated is selected update marker status
    ASSERT(m_pMarker);

    if( bUpdateMarker && GraphicSelected() &&
        ((pUpdatedMarker = m_pMarker->HasAMarker( pUpdatedGraphic )) != NULL) )
    {
        // must zap lock flag for old object to prevent UnLock loops
        pUpdatedMarker->ClearLockFlag();
        delete pUpdatedMarker;

        // If the graphic is now locked    deselect it
        if (pUpdatedGraphic->Locked() == TRUE)
        {
            if( m_pSelectedGraphic == pUpdatedMarker ) //only safe comparision
                m_pSelectedGraphic = m_pMarker->LastMarker();
        }
        else
        {
            // the graphic isn't locked, re-select it
            bWasEqual = (m_pSelectedGraphic == pUpdatedMarker);
            pUpdatedMarker = DCWbGraphic::ConstructGraphic(m_hPage, pUpdatedGraphic->Handle());

            pUpdatedMarker->GetBoundsRect(&rcBounds);
            m_pMarker->SetRect(&rcBounds, pUpdatedMarker, FALSE );

            if( bWasEqual ) //only safe comparision
                m_pSelectedGraphic = pUpdatedMarker;
        }
    }


    if (TextEditActive() &&
        (m_textEditor.Handle() == pUpdatedGraphic->Handle()) )
    {
        return; // skip update if object is currently being text edited
                // (fix for bug 3059)
    }

    pUpdatedGraphic->GetBoundsRect(&rcBounds);
    InvalidateSurfaceRect(&rcBounds, bErase);
}



//
//
// Function : GraphicFreehandUpdated
//
// Purpose  : A freehand graphic has been updated
//
//
void WbDrawingArea::GraphicFreehandUpdated(DCWbGraphic* pGraphic)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    RECT        rc;

    // Draw the object
    HDC hDC = m_hDCCached;

    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Remove the remote pointers from the affected area
    pGraphic->GetBoundsRect(&rc);
    RemovePointers(hDC, &rc);

    // Play the new graphic into the context
    pGraphic->Draw(hDC);

    // Restore the remote pointers
    PutPointers(hDC);

    // Get the intersection of the graphic and any objects covering it - if
    // there are any objects over the freehand object, we have to redraw them
    PG_GetObscuringRect(m_hPage, pGraphic, &rc);
    if (!::IsRectEmpty(&rc))
    {
        // The graphic is at least partially obscured - force an update
        InvalidateSurfaceRect(&rc, TRUE);
    }

    if (hOldPal != NULL )
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    InvalidateSurfaceRect
//
// Purpose:     Invalidate the window rectangle corresponding to the given
//              drawing surface rectangle.
//
//
void WbDrawingArea::InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase)
{
    RECT    rc;

    // Convert the surface co-ordinates to client window and invalidate
    // the rectangle.
    rc = *lprc;
    SurfaceToClient(&rc);
    ::InvalidateRect(m_hwnd, &rc, bErase);
}

//
//
// Function:    UpdateRectangles
//
// Purpose:     Updates have affected a region of the drawing area - force
//              a redraw now.
//
//
void WbDrawingArea::UpdateRectangles
(
    LPCRECT     lprc1,
    LPCRECT     lprc2,
    BOOL        bRepaint
)
{
    // Remove the marker and save whether it is to be restored later
    BOOL bSaveMarkerPresent = m_bMarkerPresent;
    RemoveMarker(NULL);

    // Invalidate the bounding rectangles specifying that the background
    // is to be erased when painted.
    if (!::IsRectEmpty(lprc1))
    {
        InvalidateSurfaceRect(lprc1, bRepaint);
    }

    if (!::IsRectEmpty(lprc2))
    {
        InvalidateSurfaceRect(lprc2, bRepaint);
    }

    // Repaint the invalidated regions
    ::UpdateWindow(m_hwnd);

    // Restore the marker (if necessary)
    if (bSaveMarkerPresent)
    {
        PutMarker(NULL);
    }
}

//
//
// Function:    PrimeFont
//
// Purpose:     Insert the supplied font into our DC and return the
//              text metrics
//
//
void WbDrawingArea::PrimeFont(HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeFont");

    //
    // temporarily unzoom to get the font that we want
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
    }

    HFONT hOldFont = SelectFont(hDC, hFont);
    if (hOldFont == NULL)
    {
        WARNING_OUT(("Failed to select font into DC"));
    }

    if (pTextMetrics != NULL)
    {
        ::GetTextMetrics(hDC, pTextMetrics);
    }

    //
    // restore the zoom state
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);
    }
}

//
//
// Function:    UnPrimeFont
//
// Purpose:     Remove the specified font from the DC and clear cache
//              variable
//
//
void WbDrawingArea::UnPrimeFont(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeFont");

    if (hDC != NULL)
    {
        SelectFont(hDC, ::GetStockObject(SYSTEM_FONT));
    }
}

//
//
// Function:    PrimeDC
//
// Purpose:     Set up a DC for drawing
//
//
void WbDrawingArea::PrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeDC");

    ::SetMapMode(hDC, MM_ANISOTROPIC);

    ::SetBkMode(hDC, TRANSPARENT);

    ::SetTextAlign(hDC, TA_LEFT | TA_TOP);
}

//
//
// Function:    UnPrimeDC
//
// Purpose:     Reset the DC to default state
//
//
void WbDrawingArea::UnPrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeDC");

    SelectPen(hDC, (HPEN)::GetStockObject(BLACK_PEN));
    SelectBrush(hDC, (HBRUSH)::GetStockObject(BLACK_BRUSH));

    UnPrimeFont(hDC);
}


//
// WbDrawingArea::OnContextMenu()
//
void WbDrawingArea::OnContextMenu(int xScreen, int yScreen)
{
    POINT   pt;
    RECT    rc;

    pt.x = xScreen;
    pt.y = yScreen;
    ::ScreenToClient(m_hwnd, &pt);

    ::GetClientRect(m_hwnd, &rc);
    if (::PtInRect(&rc, pt))
    {
        // Complete drawing action, if any
        OnLButtonUp(0, pt.x, pt.y);

        // Ask main window to put up context menu
        g_pMain->PopupContextMenu(pt.x, pt.y);
    }
}


//
// WbDrawingArea::OnLButtonDown()
//
void WbDrawingArea::OnLButtonDown(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonDown");

    if( m_bIgnoreNextLClick )
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONDOWN") );
        return;
    }

    // Set the focus to this window. This is done to ensure that we trap
    // the text edit keys and the delete key when they are used.
    ::SetFocus(m_hwnd);

    // Save the operation start point (and current end point)
    // Adjust the mouse position to allow for the zoom factor
    m_ptStart.x = x;
    m_ptStart.y = y;
    ClientToSurface(&m_ptStart);
    m_ptEnd   = m_ptStart;

    // Show that the mouse button is now down
    m_bLButtonDown = TRUE;

    // Show that the drawing area is now busy
    m_bBusy = TRUE;

    // User's can drag their own remote pointer even if the drawing area
    // is locked. So we check before the test for the lock.
    if (m_pToolCur->ToolType() == TOOLTYPE_SELECT)
    {
        if (RemotePointerSelect(m_ptStart))
        {
            return;
        }
    }

    // Only allow the action to take place if the drawing area is unlocked,
    // and we have a valid tool
    if (m_bLocked || (m_pToolCur == NULL))
    {
        // Tidy up the state and leave now
        m_bLButtonDown = FALSE;
        m_bBusy        = FALSE;
        return;
    }

    // Call the relevant initialization routine
    if (m_pToolCur->ToolType() != TOOLTYPE_SELECT)
    {
        // dump selection if not select tool
        ClearSelection();
    }

    switch (m_pToolCur->ToolType())
    {
        case TOOLTYPE_SELECT:
            BeginSelectMode(m_ptStart);
            break;

        case TOOLTYPE_ERASER:
            BeginDeleteMode(m_ptStart);
            break;

        case TOOLTYPE_TEXT:
            break;

        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
            BeginFreehandMode(m_ptStart);
            break;

        case TOOLTYPE_LINE:
            BeginLineMode(m_ptStart);
            break;

        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
            BeginRectangleMode(m_ptStart);
            break;

        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            BeginEllipseMode(m_ptStart);
            break;

        // Do nothing if we do not recognise the pen type
        default:
            ERROR_OUT(("Bad tool type"));
            break;
    }

    // Clamp the cursor to the drawing window
    RECT    rcClient;

    ::GetClientRect(m_hwnd, &rcClient);
    ::MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcClient.left, 2);
    ::InflateRect(&rcClient, 1, 1);
    ::ClipCursor(&rcClient);
}

//
//
// Function:    RemotePointerSelect
//
// Purpose:     Check for the user clicking inside their own remote pointer.
//
//
BOOL WbDrawingArea::RemotePointerSelect
(
    POINT   surfacePos
)
{
    BOOL bResult = FALSE;
    DCWbGraphicPointer* pPointer;

    // Check we have a valid page
    if (m_hPage == WB_PAGE_HANDLE_NULL)
    {
        return(bResult);
    }

    // Assume we do not start dragging a graphic
    m_pGraphicTracker = NULL;

    // Check if we are clicking in the local user's pointer
    pPointer = PG_LocalPointer(m_hPage);
    if (   (pPointer != NULL)
         && (pPointer->PointInBounds(surfacePos)))
    {
        // The user is clicking in their pointer
        m_pGraphicTracker = pPointer;

        // Save the current time (used to determine when to update
        // the external remote pointer information).
        m_dwTickCount = ::GetTickCount();

        // Hide the mouse (helps prevent flicker)
        ::ShowCursor(FALSE);

        // Get all mouse input directed to the this window
        ::SetCapture(m_hwnd);

        // Start the timer for updating the pointer (this is only for updating
        // the pointer position when the user stops moving the pointer but
        // keeps the mouse button down).
        ::SetTimer(m_hwnd, TIMER_GRAPHIC_UPDATE, DRAW_GRAPHICUPDATEDELAY, NULL);

        // Show that we have selected a pointer
        bResult = TRUE;
    }

    return(bResult);
}

//
//
// Function:    SelectPreviousGraphicAt
//
// Purpose:     Select the previous graphic (in the Z-order) at the position
//              specified, and starting at a specified graphic. If the
//              graphic pointer given is NULL the search starts from the
//              top. If the point specified is outside the bounding
//              rectangle of the specified graphic the search starts at the
//              top and chooses the first graphic which contains the point.
//
//              The search process will loop back to the top of the Z-order
//              if it gets to the bottom having failed to find a graphic.
//
//              Graphics which are locked are ignored by the search.
//
//
DCWbGraphic* WbDrawingArea::SelectPreviousGraphicAt
(
    DCWbGraphic* pStartGraphic,
    POINT       point
)
{
    // Set the result to "none found" initially
    DCWbGraphic* pResultGraphic = NULL;

    // If a starting point has been specified
    if (pStartGraphic != NULL)
    {
        RECT rectHit;

        MAKE_HIT_RECT(rectHit, point);

        // If the reference point is within the start graphic
        if ( pStartGraphic->PointInBounds(point) &&
            pStartGraphic->CheckReallyHit( &rectHit ) )
        {
            // Start from the specified graphic
            pResultGraphic = pStartGraphic;

            // Look for the previous one (that is not locked)
            do
            {
                pResultGraphic = PG_SelectPrevious(m_hPage, *pResultGraphic, point);
            }
            while (   (pResultGraphic != NULL)
             && (pResultGraphic->Locked()));
        }
        else
        {
            // We are not looking within the currently selected graphic.
            // Deselect the current one. The start pointer and handle are
            // left at NULL.
            ;
        }
    }

    // If we have not got a result graphic yet. (This catches two cases:
    // - where no start graphic has been given so that we want to start
    //   from the top,
    // - where we have searched back from the start graphic and reached
    //   the bottom of the Z-order without finding a suitable graphic.
    if (pResultGraphic == NULL)
    {
        // Get the topmost graphic that contains the point specified
        pResultGraphic = PG_SelectLast(m_hPage, point);

        // Ensure that we have not got a locked graphic
        while (   (pResultGraphic != NULL)
           && (pResultGraphic->Locked()))
        {
            pResultGraphic = PG_SelectPrevious(m_hPage, *pResultGraphic, point);
        }
    }

    // If we have found an object, draw the marker
    if (pResultGraphic != NULL)
    {
        // Select the new one
        SelectGraphic(pResultGraphic);
    }

    return pResultGraphic;
}

//
//
// Function:    BeginSelectMode
//
// Purpose:     Process a mouse button down in select mode
//
//

void WbDrawingArea::BeginSelectMode(POINT surfacePos, BOOL bDontDrag )
{
    RECT    rc;

    // Assume we do not start dragging a graphic
    m_pGraphicTracker = NULL;

    // Assume that we do not mark a new graphic
    m_bNewMarkedGraphic = FALSE;

    // turn off TRACK-SELECT-RECT
    m_bTrackingSelectRect = FALSE;

    // Check whether there is currently an object marked, and
    // whether we are clicking inside the same object. If we are then
    // we do nothing here - the click will be handled by the tracking or
    // completion routines for select mode.
    ASSERT(m_pMarker);

    if (   (GraphicSelected() == FALSE)
        || (m_pMarker->PointInBounds(surfacePos) == FALSE))
    {
        // We are selecting a new object if bDontDrag == FALSE, find it.
        //  otherwise just turn on the select rect
        DCWbGraphic* pGraphic;
        if( bDontDrag )
            pGraphic = NULL;
        else
            pGraphic = SelectPreviousGraphicAt(NULL, surfacePos);

        // If we have found an object, draw the marker
        if (pGraphic != NULL)
        {
          // Show that a new graphic has now been marked.
          m_bNewMarkedGraphic = TRUE;
        }
        else
        {
            if( (GetAsyncKeyState( VK_SHIFT ) >= 0) &&
                (GetAsyncKeyState( VK_CONTROL ) >= 0) )
            {
                // clicked on dead air, remove all selections
                ClearSelection();
            }

            //TRACK-SELECT-RECT
            m_bTrackingSelectRect = TRUE;

            BeginRectangleMode(surfacePos);

            return;
        }
    }

    // If we now have a selected graphic, and we are clicking inside it
    if (   (GraphicSelected())
        && (m_pMarker->PointInBounds(surfacePos)))
    {
        // Create a rectangle object for tracking the drag
        DCWbGraphicSelectTrackingRectangle* pRectangle
                           = new DCWbGraphicSelectTrackingRectangle();

        m_pSelectedGraphic->GetBoundsRect(&rc);

        if (!pRectangle)
        {
            ERROR_OUT(("BeginSelectMode failed; couldn't create tracking rect object"));
        }
        else
        {
            pRectangle->SetRect(&rc);
            pRectangle->SetColor(RGB(0, 0, 0));
            pRectangle->SetPenWidth(1);
        }

        m_pGraphicTracker = pRectangle;

        // We do not draw the tracking rectangle yet as the user has not yet
        // dragged it anywhere. A single click within an object will then
        // not cause a tracking rectangle to flash on the screen.
    }

    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);
}




void WbDrawingArea::BeginDeleteMode(POINT mousePos )
{
    // turn off object dragging
    BeginSelectMode( mousePos, TRUE );
}




//
//
// Function:    BeginTextMode
//
// Purpose:     Process a mouse button down in text mode
//
//
void WbDrawingArea::BeginTextMode(POINT surfacePos)
{
    RECT    rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::BeginTextMode");

    //
    // Get a DC for passing into the text editor
    //
    HDC hDC = m_hDCCached;

    // If we are already editing a text object, we just move the text cursor
    if (m_bTextEditorActive)
    {
        // If the mouse has been clicked in the currently active object
        // we just move the cursor within the object, otherwise we end the
        // edit for the current object and move to a new one.
        m_textEditor.GetBoundsRect(&rc);
        if (::PtInRect(&rc, surfacePos))
        {
            // Set the new position for the cursor
            m_textEditor.SetCursorPosFromPoint(surfacePos);
        }
        else
        {
            // Complete the text entry accepting the changes
            EndTextEntry(TRUE);

            // LAURABU BOGUS:
            // It would be cooler to now return, that way you don't get
            // another text object just cuz you ended the current editing
            // session.
        }
    }

    // If we are not editing an object we check to see whether there is
    // a text object under the cursor or whether we must start a new one.
    if (!m_bTextEditorActive)
    {
        // Check whether we are clicking over a text object. If we are
        // start editing the object, otherwise we start a new text object.

        // Look back through the Z-order for a text object
        DCWbGraphic* pGraphic = PG_SelectLast(m_hPage, surfacePos);
        DCWbGraphic* pNextGraphic = NULL;
        while (   (pGraphic != NULL)
           && (pGraphic->IsGraphicTool() != enumGraphicText))
        {
            // Get the next one
            pNextGraphic = PG_SelectPrevious(m_hPage, *pGraphic, surfacePos);

            // Release the previous graphic
            delete pGraphic;

            // Use the next one
            pGraphic = pNextGraphic;
        }

        if (pGraphic != NULL)
        {
            // Check whether this graphic object is already being edited by
            // another user in the call.
            if (!pGraphic->Locked())
            {
                // We found a text object under the mouse pointer...
                // ...edit it
                m_pActiveText = (DCWbGraphicText*) pGraphic;

                // Transfer the text from the object into the text editor
                if (!m_textEditor.SetTextObject(m_pActiveText))
                {
                    DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
                    return;
                }

                // Make sure the tool reflects the new information
                if (m_pToolCur != NULL)
                {
                    m_pToolCur->SelectGraphic(pGraphic);
                }

                HWND hwndParent = ::GetParent(m_hwnd);;
                if (hwndParent != NULL)
                {
                    ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0L);
                }

                // Lock the graphic to prevent other users editing it.
                // (This is not currently a real lock but a flag in the object
                //  header. There is a window in which two users can start editing
                //  the same text object at the same time.)
                m_textEditor.Lock();
                m_textEditor.Update();


                // Show that we are now gathering text but dont put up cursor
                // yet. Causes cursor droppings later (bug 2505)
                //ActivateTextEditor( FALSE );
                ActivateTextEditor( TRUE );

                // Set the initial cursor position for the edit
                m_textEditor.SetCursorPosFromPoint(surfacePos);

                // If this is not the topmost object we must redraw to get
                // it to the top so it is visible for editing
                if (PG_IsTopmost(m_hPage, m_pActiveText))
                {
                    m_pActiveText->GetBoundsRect(&rc);
                    InvalidateSurfaceRect(&rc);
                    ::UpdateWindow(m_hwnd);
                }
            }
            else
                delete pGraphic;
        }
        else
        {
            // There are no text objects under the mouse pointer...
            // ...start a new one

            // Clear any old text out of the editor, and reset its graphic
            // handle. This prevents us from replacing an old text object when
            // we next save the text editor contents.
            if (!m_textEditor.New())
            {
                DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
                return;
            }

            // Lock the text editor to prevent other users editing the object.
            // (The object will be added to the page when the update timer pops
            // or when the user hits space or return.)
            m_textEditor.Lock();

            // Set the attributes of the text
            m_textEditor.SetFont(m_pToolCur->GetFont());
            m_textEditor.SetColor(m_pToolCur->GetColor());
            m_textEditor.GraphicTool(m_pToolCur->ToolType());

            // We need to reselect a font now into our DC
            SelectFont(hDC, m_textEditor.GetFont());

            // Set the position of the new object
            SIZE sizeCursor;
            m_textEditor.GetCursorSize(&sizeCursor);
            m_textEditor.CalculateBoundsRect();
            m_textEditor.MoveTo(m_ptEnd.x, m_ptEnd.y - sizeCursor.cy);

            // We are not editing an active text object
            ASSERT(m_pActiveText == NULL);

            // Show that we are now gathering text
            ActivateTextEditor( TRUE );
        }
    }
}

//
//
// Function:    BeginFreehandMode
//
// Purpose:     Process a mouse button down event in draw mode
//
//
void WbDrawingArea::BeginFreehandMode(POINT surfacePos)
{
    // Tracking in draw mode is a special case. We draw directly to the client
    // area of the window and create an object to record the points on the
    // line that we are drawing.
    m_pGraphicTracker = new DCWbGraphicFreehand();

    if (!m_pGraphicTracker)
    {
        ERROR_OUT(("BeginFreehandMode failing; can't create graphic freehand object"));
    }
    else
    {
        ((DCWbGraphicFreehand*) m_pGraphicTracker)->AddPoint(surfacePos);
        m_pGraphicTracker->SetColor(m_pToolCur->GetColor());
        m_pGraphicTracker->SetPenWidth(m_pToolCur->GetWidth());
        m_pGraphicTracker->SetROP(m_pToolCur->GetROP());
        m_pGraphicTracker->GraphicTool(m_pToolCur->ToolType());
        m_pGraphicTracker->Lock();
    }

    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Start the timer for updating the graphic (this is only for updating
    // the graphic when the user stops moving the pointer but keeps the
    // mouse button down).
    ::SetTimer(m_hwnd, TIMER_GRAPHIC_UPDATE, DRAW_GRAPHICUPDATEDELAY, NULL);

    // Save the current time (used to determine when to update
    // the external graphic pointer information while the mouse is
    // being moved).
    m_dwTickCount = ::GetTickCount();
}

//
//
// Function:    BeginLineMode
//
// Purpose:     Process a mouse button down event in line mode
//
//
void WbDrawingArea::BeginLineMode(POINT surfacePos)
{
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Create the object to be used for tracking
    DCWbGraphicTrackingLine* pGraphicLine = new DCWbGraphicTrackingLine();
    if (!pGraphicLine)
    {
        ERROR_OUT(("BeginLineMode failing; can't create tracking line object"));
    }
    else
    {
        pGraphicLine->SetColor(m_pToolCur->GetColor());
        pGraphicLine->SetPenWidth(1);

        pGraphicLine->SetStart(surfacePos);
        pGraphicLine->SetEnd(surfacePos);
    }

    m_pGraphicTracker = pGraphicLine;
}

//
//
// Function:    BeginRectangleMode
//
// Purpose:     Process a mouse button down event in box mode
//
//
void WbDrawingArea::BeginRectangleMode(POINT surfacePos)
{
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Create the object to be used for tracking
    DCWbGraphicTrackingRectangle* pGraphicRectangle
                                 = new DCWbGraphicTrackingRectangle();
    if (!pGraphicRectangle)
    {
        ERROR_OUT(("BeginRectangleMode failing; can't create tracking rect object"));
    }
    else
    {
        pGraphicRectangle->SetColor( CLRPANE_BLACK );
        pGraphicRectangle->SetPenWidth(1);
        pGraphicRectangle->SetRectPts(surfacePos, surfacePos);
    }

    m_pGraphicTracker = pGraphicRectangle;
}

//
//
// Function:    BeginEllipseMode
//
// Purpose:     Process a mouse button down event in ellipse mode
//
//
void WbDrawingArea::BeginEllipseMode(POINT surfacePos)
{
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Create the object to be used for tracking
    DCWbGraphicTrackingEllipse* pGraphicEllipse
                                  = new DCWbGraphicTrackingEllipse();
    if (!pGraphicEllipse)
    {
        ERROR_OUT(("BeginEllipseMode failing; can't create tracking ellipse object"));
    }
    else
    {
        pGraphicEllipse->SetColor(m_pToolCur->GetColor());
        pGraphicEllipse->SetPenWidth(1);
        pGraphicEllipse->SetRectPts(surfacePos, surfacePos);
    }

    m_pGraphicTracker = pGraphicEllipse;
}

//
// WbDrawingArea::OnMouseMove
//
void WbDrawingArea::OnMouseMove(UINT flags, int x, int y)
{
    POINT surfacePos;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnMouseMove");

    surfacePos.x = x;
    surfacePos.y = y;

    // Check if the left mouse button is down
    if (m_bLButtonDown)
    {
        // Calculate the worksurface position
        // Adjust the mouse position to allow for the zoom factor
        ClientToSurface(&surfacePos);

        // Make sure the point is a valid surface position
        MoveOntoSurface(&surfacePos);

        // Check whether the window needs to be scrolled to get the
        // current position into view.
        AutoScroll(surfacePos.x, surfacePos.y, TRUE, 0, 0);

        // Action taken depends on the tool type
        switch(m_pToolCur->ToolType())
        {
            case TOOLTYPE_HIGHLIGHT:
            case TOOLTYPE_PEN:
                TrackFreehandMode(surfacePos);
                break;

            case TOOLTYPE_LINE:
                TrackLineMode(surfacePos);
                break;

            case TOOLTYPE_BOX:
            case TOOLTYPE_FILLEDBOX:
                TrackRectangleMode(surfacePos);
                break;

            case TOOLTYPE_ELLIPSE:
            case TOOLTYPE_FILLEDELLIPSE:
                TrackEllipseMode(surfacePos);
                break;

            case TOOLTYPE_SELECT:
                TrackSelectMode(surfacePos);
                break;

            case TOOLTYPE_ERASER:
                TrackDeleteMode(surfacePos);
                break;

            case TOOLTYPE_TEXT:
                break;

            default:
                ERROR_OUT(("Unknown tool type"));
                break;
        }
    }
}

//
//
// Function:    CancelDrawingMode
//
// Purpose:     Cancels a drawing operation after an error.
//
//
void WbDrawingArea::CancelDrawingMode(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::CancelDrawingMode");

    //
    // Quit if there's nothing to cancel.
    //
    if (!m_bBusy && !m_bTextEditorActive)
    {
        TRACE_DEBUG(("Drawing area not busy and text editor not active..."));
        return;
    }

    // The drawing area is no longer busy
    m_bBusy = FALSE;

    //
    // Redraw the object - we need to discard any local updates which we
    // weren't able to write to the object we are editing.  Ideally we should
    // just invalidate the object itself but because some of the co-ordinates
    // we have already drawn on the page may have been lost, we dont know
    // exactly how big the object is.
    //
    ::InvalidateRect(m_hwnd, NULL, TRUE);

    m_bLButtonDown = FALSE;

    // Release the mouse capture
    if (::GetCapture() == m_hwnd)
    {
        ::ReleaseCapture();
    }

    //
    // Perform any tool specific processing.
    //
    switch(m_pToolCur->ToolType())
    {
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
            CompleteFreehandMode();
            break;

        case TOOLTYPE_SELECT:
            // Stop the pointer update timer
            ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
            break;

        case TOOLTYPE_TEXT:
            if (m_bTextEditorActive)
            {
                m_textEditor.AbortEditGently();
            }
            break;

        default:
            break;
    }

    // Show that we are no longer tracking an object
    if (m_pGraphicTracker != NULL)
    {
        delete m_pGraphicTracker;
        m_pGraphicTracker = NULL;
    }
}


//
//
// Function:    TrackSelectMode
//
// Purpose:     Process a mouse move event in select mode
//
//
void WbDrawingArea::TrackSelectMode(POINT surfacePos)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::TrackSelectMode");

    // If an object is being dragged
    if (m_pGraphicTracker != NULL)
    {
        // Get a device context for the window
        HDC hDC = m_hDCCached;

        // Check whether the marked object is the local pointer
        if (m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer)
        {
            DCWbGraphicPointer* pPointer = (DCWbGraphicPointer*) m_pGraphicTracker;

            // Move the pointer to its new position
            pPointer->MoveBy(surfacePos.x - m_ptEnd.x, surfacePos.y - m_ptEnd.y);

            // Draw the new pointer
            pPointer->Redraw(hDC, this);

            // Save the new box end point (top right)
            m_ptEnd = surfacePos;

    		// Check whether we need to update the external remote pointer
	    	// information. (Based on the time. We will miss one update
		    // when the time wraps.)
    		DWORD dwNewTickCount = ::GetTickCount();
	    	if (dwNewTickCount > m_dwTickCount + DRAW_REMOTEPOINTERDELAY)
		    {
        	    TRACE_DEBUG(("Updating pointer - tick count exceeded"));

    	        // Update the pointer
        	    pPointer->Update();

            	// Set the saved tick count to the new count
	            m_dwTickCount = dwNewTickCount;
    		}
	    }
        else
        {
            if( m_bTrackingSelectRect )
                TrackRectangleMode(surfacePos);
      else
          {

          // In this case we must be dragging a marked object
          ASSERT(GraphicSelected());

          // We never draw the tracking rectangle in the start position of
          // the graphic. This gives the user some feedback when they have
          // positioned the graphic back at its original place.
          if (!EqualPoint(m_ptStart, m_ptEnd))
          {
            // Erase the last box (using XOR property)
            m_pGraphicTracker->Draw(hDC);
            }

          // Save the new box end point (top left)
          m_pGraphicTracker->MoveBy(surfacePos.x - m_ptEnd.x, surfacePos.y - m_ptEnd.y);
          m_ptEnd = surfacePos;

          // Draw the new rectangle (XORing it onto the display)
          if (!EqualPoint(m_ptStart, m_ptEnd))
            {
            // Draw the rectangle
            m_pGraphicTracker->Draw(hDC);
            }
          }
    }
  }
}





void  WbDrawingArea::TrackDeleteMode( POINT mousePos )
{
    TrackSelectMode( mousePos );
}




//
//
// Function:    TrackFreehandMode
//
// Purpose:     Process a mouse move event in draw mode
//
//
void WbDrawingArea::TrackFreehandMode(POINT surfacePos)
{
    HPALETTE    hPal = NULL;
    HPALETTE    hOldPal = NULL;
    HPEN        hPen = NULL;
    HPEN        hOldPen = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::TrackFreehandMode");

    // Get a device context for the client area
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE);
        ::RealizePalette(hDC);
    }

    // Tracking in draw mode is a special case. We draw directly to the client
    // area of the window and to the recording device context.

    // Save the point, checking there aren't too many points
    if (!m_pGraphicTracker ||
        (((DCWbGraphicFreehand*) m_pGraphicTracker)->AddPoint(surfacePos) == FALSE))
    {
        // too many points so end the freehand object
        OnLButtonUp(0, surfacePos.x, surfacePos.y);
        goto TrackFreehandCleanup;
    }

    // Set the DC attributes
    ASSERT(m_pGraphicTracker != NULL);

    hPen = ::CreatePen(m_pGraphicTracker->GetPenStyle(),
           m_pGraphicTracker->GetPenWidth(),
           m_pGraphicTracker->GetColor());
    if (!hPen)
    {
        ERROR_OUT(("Couldn't create pen in track freehand mode"));
        goto TrackFreehandCleanup;
    }

    hOldPen = SelectPen(hDC, hPen);
    if (hOldPen != NULL)
    {
        int iOldROP = ::SetROP2(hDC, m_pGraphicTracker->GetROP());

        // Draw the next segment of the freehand line into the recording context
        // and the client area, and save the new start point.
        ::MoveToEx(hDC, m_ptStart.x, m_ptStart.y, NULL);
        ::LineTo(hDC, surfacePos.x, surfacePos.y);

        // Update the start point for the next line segment
        m_ptStart = surfacePos;

        // Restore the DC attributes
        ::SetROP2(hDC, iOldROP);

        // Check whether we need to update the external graphic information.
        // (Based on the time. We will miss one update when the time wraps.)
        DWORD dwNewTickCount = ::GetTickCount();
        if (dwNewTickCount > m_dwTickCount + DRAW_GRAPHICUPDATEDELAY)
        {
            TRACE_DEBUG(("Updating freehand - tick count exceeded"));

            // Update the pointer
            if (m_pGraphicTracker->Handle() == NULL)
            {
                m_pGraphicTracker->AddToPageLast(m_hPage);
            }
            else
            {
                m_pGraphicTracker->Replace();
            }

            // Set the saved tick count to the new count
            m_dwTickCount = dwNewTickCount;
        }
    }

TrackFreehandCleanup:

    if (hOldPen != NULL)
    {
        SelectPen(hDC, hOldPen);
    }

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    TrackLineMode
//
// Purpose:     Process a mouse move event in line mode
//
//
void WbDrawingArea::TrackLineMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Erase the last line drawn (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }
    }

    // Draw the new line (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
        m_ptEnd = surfacePos;

        if (m_pGraphicTracker != NULL)
        {
            ((DCWbGraphicTrackingLine*) m_pGraphicTracker)->SetEnd(m_ptEnd);
            m_pGraphicTracker->Draw(hDC);
        }
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    TrackRectangleMode
//
// Purpose:     Process a mouse move event in box or filled box mode
//
//
void WbDrawingArea::TrackRectangleMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Draw the rectangle
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }
    }

    // Draw the new rectangle (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
        // Save the new box end point (top right)
        m_ptEnd = surfacePos;

        // Draw the rectangle
        if (m_pGraphicTracker != NULL)
        {
            ((DCWbGraphicTrackingRectangle*) m_pGraphicTracker)->SetRectPts(m_ptStart, m_ptEnd);
            m_pGraphicTracker->Draw(hDC);
        }
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    TrackEllipseMode
//
// Purpose:     Process a mouse move event in ellipse or filled ellipse mode
//
//
void WbDrawingArea::TrackEllipseMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if( (m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE);
        ::RealizePalette(hDC);
    }

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }
    }

    // Draw the new ellipse (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
        // Update the end point of the operation
        m_ptEnd = surfacePos;

        if (m_pGraphicTracker != NULL)
        {
            ((DCWbGraphicTrackingEllipse*) m_pGraphicTracker)->SetRectPts(m_ptStart, m_ptEnd);
            m_pGraphicTracker->Draw(hDC);
        }
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE );
    }
}


//
// WbDrawingArea::OnLButtonUp()
//
void WbDrawingArea::OnLButtonUp(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonUp");

    if (m_bIgnoreNextLClick)
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONUP") );
        m_bIgnoreNextLClick = FALSE;
        return;
    }

    // Only process the event if we saw the button down event
    if (m_bLButtonDown)
    {
        TRACE_MSG(("End of drawing operation"));

        m_bLButtonDown = FALSE;

        // The drawing area is no longer busy
        m_bBusy = FALSE;

        if (m_pGraphicTracker == NULL)
        {
            // Calculate the work surface position
            // Adjust the mouse position to allow for the zoom factor
            POINT surfacePos;

            surfacePos.x = x;
            surfacePos.y = y;
            ClientToSurface(&surfacePos);
            MoveOntoSurface(&surfacePos);
            m_ptEnd = surfacePos;
        }

        // Release the mouse capture
        if (::GetCapture() == m_hwnd)
        {
            ::ReleaseCapture();
        }

        // Check the page is valid - might not be if it has been deleted
        // while the object was being drawn - we would not have been
        // alerted to this because m_bBusy was true.
        if (m_hPage != WB_PAGE_HANDLE_NULL)
        {
            // surround in an exception handler in case of lock errors, etc -
            // we need to remove the graphic tracker
            // Action taken depends on the current tool type
            ASSERT(m_pToolCur != NULL);

            switch(m_pToolCur->ToolType())
            {
                case TOOLTYPE_HIGHLIGHT:
                case TOOLTYPE_PEN:
                    CompleteFreehandMode();
                    break;

                case TOOLTYPE_LINE:
                    CompleteLineMode();
                    break;

                case TOOLTYPE_BOX:
                    CompleteRectangleMode();
                    break;

                case TOOLTYPE_FILLEDBOX:
                    CompleteFilledRectangleMode();
                    break;

                case TOOLTYPE_ELLIPSE:
                    CompleteEllipseMode();
                    break;

                case TOOLTYPE_FILLEDELLIPSE:
                    CompleteFilledEllipseMode();
                    break;

                case TOOLTYPE_SELECT:
                    CompleteSelectMode();
                    break;

                case TOOLTYPE_ERASER:
                    CompleteDeleteMode();
                    break;

                case TOOLTYPE_TEXT:
                    m_ptStart.x = x;
                    m_ptStart.y = y;
                    ClientToSurface(&m_ptStart);
                    BeginTextMode(m_ptStart);
                    break;

                default:
                    ERROR_OUT(("Unknown pen type"));
                    break;
            }
        }

        // Show that we are no longer tracking an object
        if (m_pGraphicTracker != NULL)
        {
            delete m_pGraphicTracker;
            m_pGraphicTracker = NULL;
        }
	}

    // unclamp cursor (bug 589)
    ClipCursor(NULL);
}

//
//
// Function:    CompleteSelectMode
//
// Purpose:     Complete a select mode operation
//
//
void WbDrawingArea::CompleteSelectMode()
{
    // If an object is being dragged
    if (m_pGraphicTracker != NULL)
    {
        // Check if we were dragging a pointer. Pointers track
        // themselves i.e. the original copy of the pointer is not
        // left on the page. We want to leave the last drawn image on
        // the page as this is the new pointer position.
        if (m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer)
        {
            DCWbGraphicPointer* pPointer = (DCWbGraphicPointer*) m_pGraphicTracker;

            // Show the mouse
            ::ShowCursor(TRUE);

            // Update the object's position (if necessary)
            if (!EqualPoint(m_ptStart, m_ptEnd))
            {
                pPointer->Update();
            }

            // We do not want to delete the graphic pointer (it belongs to
            // the page object that created it). So reset the graphic tracker
            // pointer to prevent it being deleted in OnLButtonUp.
            m_pGraphicTracker = NULL;

            // Stop the pointer update timer
            ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
        }
        else
        {
            if( m_bTrackingSelectRect && (!EqualPoint(m_ptStart, m_ptEnd)))
            {
                CompleteMarkAreaMode();
                SelectMarkerFromRect( &m_rcMarkedArea );
            }
            else
            {
                // The select item is a real graphic - not a pointer

                // If we need to remove the rubber band box
                if (!EqualPoint(m_ptStart, m_ptEnd))
                {
                    // Erase the last box (using XOR property).
                    // Get a device context for tracking
                    HDC hDC = m_hDCCached;

                    // Draw the rectangle
                    m_pGraphicTracker->Draw(hDC);

                    // Move selection
                    m_HourGlass = TRUE;
                    SetCursorForState();

                    RemoveMarker( NULL );
                    m_pMarker->MoveBy(m_ptEnd.x - m_ptStart.x, m_ptEnd.y - m_ptStart.y);
                    m_pMarker->Update();

                    PutMarker( NULL, FALSE );

                    m_HourGlass = FALSE;
                    SetCursorForState();

                    // The tracking object will be deleted by OnLButtonUp
                }
                else
                {
                    // Start and end points were the same, in this case the object has
                    // not been moved. We treat this as a request to move the marker
                    // back through the stack of objects.
                    if (m_bNewMarkedGraphic == FALSE)
                    {
                        SelectPreviousGraphicAt(m_pSelectedGraphic, m_ptEnd);
                    }
                }
            }
        }
    }
}




void WbDrawingArea::CompleteDeleteMode()
{
    // select object(s)
    CompleteSelectMode();

    // nuke 'em
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND, MAKELONG(IDM_DELETE, BN_CLICKED), 0);
}



//
//
// Function:    CompleteMarkAreaMode
//
// Purpose:     Process a mouse button up event in mark area mode
//
//
void WbDrawingArea::CompleteMarkAreaMode(void)
{
    // Get a device context for tracking
    HDC hDC = m_hDCCached;

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Draw the rectangle
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }

        // Use normalized coords
        if (m_ptEnd.x < m_ptStart.x)
        {
            m_rcMarkedArea.left = m_ptEnd.x;
            m_rcMarkedArea.right = m_ptStart.x;
        }
        else
        {
            m_rcMarkedArea.left = m_ptStart.x;
            m_rcMarkedArea.right = m_ptEnd.x;
        }

        if (m_ptEnd.y < m_ptStart.y)
        {
            m_rcMarkedArea.top = m_ptEnd.y;
            m_rcMarkedArea.bottom = m_ptStart.y;
        }
        else
        {
            m_rcMarkedArea.top = m_ptStart.y;
            m_rcMarkedArea.bottom = m_ptEnd.y;
        }
    }
}

//
//
// Function:    CompleteTextMode
//
// Purpose:     Complete a text mode operation
//
//
void WbDrawingArea::CompleteTextMode()
{
    // Not much to for text mode. Main text mode actions are taken
    // as a result of a WM_CHAR message and not on mouse events.
    // Just deselect our font if it is still selected
    UnPrimeFont(m_hDCCached);
}

//
//
// Function:    CompleteFreehandMode
//
// Purpose:     Complete a draw mode operation
//
//
void WbDrawingArea::CompleteFreehandMode(void)
{

    // Add the freehand object created during the drawing to the page
    if (m_pGraphicTracker != NULL)
    {
    	if (m_pGraphicTracker->Handle() == NULL)
        {
		    m_pGraphicTracker->ClearLockFlag();
    		m_pGraphicTracker->AddToPageLast(m_hPage);
	    }
    	else
	    {
		    // clear lock flag and let ForceReplace propagate it (fix
    		// for NT bug 4744(new bug#... )
	    	m_pGraphicTracker->ClearLockFlag();
	        m_pGraphicTracker->ForceReplace();
    	}
    }

    // Stop the update timer
    ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
}

//
//
// Function:    CompleteLineMode
//
// Purpose:     Complete a line mode operation
//
//
void WbDrawingArea::CompleteLineMode(void)
{
    // Only draw the line if it has non-zero length
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DCWbGraphicLine line;
        line.SetStart(m_ptStart);
        line.SetEnd(m_ptEnd);
        line.SetColor(m_pToolCur->GetColor());
        line.SetPenWidth(m_pToolCur->GetWidth());
        line.SetROP(m_pToolCur->GetROP());
        line.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        line.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    CompleteRectangleMode
//
// Purpose:     Complete a box mode operation
//
//
void WbDrawingArea::CompleteRectangleMode(void)
{
    // Only draw the box if it is not null
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DCWbGraphicRectangle rectangle;
        rectangle.SetRectPts(m_ptStart, m_ptEnd);
        rectangle.SetPenWidth(m_pToolCur->GetWidth());
        rectangle.SetColor(m_pToolCur->GetColor());
        rectangle.SetROP(m_pToolCur->GetROP());
        rectangle.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        rectangle.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    CompleteFilledRectangleMode
//
// Purpose:     Complete a filled box mode operation
//
//
void WbDrawingArea::CompleteFilledRectangleMode(void)
{
    // Draw the new rectangle
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DCWbGraphicFilledRectangle rectangle;

        rectangle.SetRectPts(m_ptStart, m_ptEnd);
        rectangle.SetPenWidth(m_pToolCur->GetWidth());
        rectangle.SetColor(m_pToolCur->GetColor());
        rectangle.SetROP(m_pToolCur->GetROP());
        rectangle.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        rectangle.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    CompleteEllipseMode
//
// Purpose:     Complete an ellipse mode operation
//
//
void WbDrawingArea::CompleteEllipseMode(void)
{
    // Only draw the ellipse if it is not null
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // The ellipse was defined by taking using start point as the center
        // but was changed to use the bounding tracking rectangle - bug 1608
        // Create the ellipse object
        DCWbGraphicEllipse ellipse;

        ellipse.SetRectPts(m_ptStart, m_ptEnd);
        ellipse.SetColor(m_pToolCur->GetColor());
        ellipse.SetPenWidth(m_pToolCur->GetWidth());
        ellipse.SetROP(m_pToolCur->GetROP());
        ellipse.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        ellipse.AddToPageLast(m_hPage);
    }
}


//
//
// Function:    CompleteFilledEllipseMode
//
// Purpose:     Complete a filled ellipse mode operation
//
//
void WbDrawingArea::CompleteFilledEllipseMode(void)
{
    // Only draw the ellipse if it is not null
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Create the ellipse object
        DCWbGraphicFilledEllipse ellipse;

        ellipse.SetRectPts(m_ptStart, m_ptEnd);
        ellipse.SetColor(m_pToolCur->GetColor());
        ellipse.SetPenWidth(m_pToolCur->GetWidth());
        ellipse.SetROP(m_pToolCur->GetROP());
        ellipse.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        ellipse.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    EndTextEntry
//
// Purpose:     The user has finished entering a text object. The parameter
//              indicates whether the changes are to be accepted or
//              discarded.
//
//
void WbDrawingArea::EndTextEntry(BOOL bAccept)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::EndTextEntry");

    // Only take action if the text editor is active
    if (m_bTextEditorActive)
    {
        RECT    rcBounds;

        // We must at least redraw the bounding rectangle of the
        // text object as it now stands (as it will not longer be
        // on top).
        m_textEditor.GetBoundsRect(&rcBounds);

        // If we are editing an existing text object
        if (m_pActiveText != NULL)
        {
            TRACE_MSG(("Editing an existing object"));

            //
            // If we are not accepting the edited text we must redraw
            // both the old and new rectangles to ensure that everything
            // is shown correctly.
            //
            if (!bAccept)
            {
                //
                // Write the active text object back to restore it. This object
                // will have the same handle as the text editor object if we have
                // written it to the page - we must not delete the text editor
                // object.
                //
                m_pActiveText->ForceReplace();
                m_textEditor.ZapHandle(); // prevent editor from stepping on m_pActiveText
            }
            else
            {
                // If the object is now empty
                if (m_textEditor.IsEmpty())
                {
                    // Remove the object from the list
                    PG_GraphicDelete(m_hPage, *m_pActiveText);
                    m_textEditor.ZapHandle(); // text object is gone now, invalidate
                }
                else
                {
                    // Do a replace to save the final version
                    m_textEditor.Replace();
                }
            }

            // We have finished with the text object now so get rid of it
            // and the fonts it holds
            TRACE_MSG(("Deleting the active object"));
            delete m_pActiveText;
            m_pActiveText = NULL;
        }
        else
        {
            // We were adding a new text object
            TRACE_MSG(("Adding a new object"));

            // If we want to discard the object, or it is empty
            if (!bAccept || (m_textEditor.IsEmpty()))
            {
                // If we have added the text editor to the page, remove it
                if (m_textEditor.Handle() != NULL)
                {
                    m_textEditor.Delete();
                }
            }
            else
            {
                // Check whether we have already added the object to the page
                if (m_textEditor.Handle() == NULL)
                {
                    // Create and add a new object to the page
                    // (No redrawing is required)
                    m_textEditor.AddToPageLast(m_hPage);
                }
                else
                {
                    // Replace the object to send the final version
                    m_textEditor.Replace();
                }
            }
        }

        // Deactivate the text editor
        DeactivateTextEditor();

        // Redraw any altered parts of the screen
        InvalidateSurfaceRect(&rcBounds);
    }
}

//
//
// Function:    Zoom
//
// Purpose:     Toggle the zoom state of the drawing area
//
//
void WbDrawingArea::Zoom(void)
{
    RECT    rcClient;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Zoom");

    // We zoom focusing on the centre of the window
    ::GetClientRect(m_hwnd, &rcClient);
    long xOffset = (rcClient.right - (rcClient.right / m_iZoomOption)) / 2;
    long yOffset = (rcClient.bottom - (rcClient.bottom / m_iZoomOption)) / 2;

    if (m_iZoomFactor != 1)
    {
        // We are already zoomed move back to unzoomed state
        // First save the scroll position in case we return to zoom immediately
        m_posZoomScroll = m_posScroll;
        m_zoomRestoreScroll  = TRUE;

        m_posScroll.x  -= xOffset;
        m_posScroll.y  -= yOffset;
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
        m_iZoomFactor = 1;
    }
    else
    {
        // We are not zoomed so do it
        if (m_zoomRestoreScroll)
        {
            m_posScroll = m_posZoomScroll;
        }
        else
        {
            m_posScroll.x += xOffset;
            m_posScroll.y += yOffset;
        }

        m_iZoomFactor = m_iZoomOption;
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);

        // ADDED BY RAND - don't allow text editing in zoom mode
        if( (m_pToolCur == NULL) || (m_pToolCur->ToolType() == TOOLTYPE_TEXT) )
            ::SendMessage(g_pMain->m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0 );
    }

    TRACE_MSG(("Set zoom factor to %d", m_iZoomFactor));

      // Update the scroll information
    SetScrollRange(rcClient.right, rcClient.bottom);
    ValidateScrollPos();

    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Update the origin offset from the scroll position
    m_originOffset.cx = m_posScroll.x;
    m_originOffset.cy = m_posScroll.y;
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

    // Tell the parent that the scroll position has changed
    ::PostMessage(g_pMain->m_hwnd, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);

    g_pMain->SetMenuStates(::GetSubMenu(::GetMenu(g_pMain->m_hwnd), 3));

    // Redraw the window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    SelectTool
//
// Purpose:     Set the current tool
//
//
void WbDrawingArea::SelectTool(WbTool* pToolNew)
{
    // If we are leaving text mode, complete the text entry
    if (m_bTextEditorActive  && (m_pToolCur->ToolType() == TOOLTYPE_TEXT)
      && (pToolNew->ToolType() != TOOLTYPE_TEXT))
    {
        // End text entry accepting the changes
        EndTextEntry(TRUE);
    }

    ASSERT(m_pMarker);

    // If we are no longer in select mode, and the marker is present,
    // then remove it and let the tool know it's no longer selected
    if (   (m_pToolCur != NULL)
        && (m_pToolCur->ToolType() == TOOLTYPE_SELECT)
        && (pToolNew->ToolType() != TOOLTYPE_SELECT))
    {
        m_pToolCur->DeselectGraphic();

        RemoveMarker(NULL);
        m_pMarker->DeleteAllMarkers( m_pSelectedGraphic );

        delete m_pSelectedGraphic;
        m_pSelectedGraphic = NULL;
    }
    else if (   (m_pToolCur != NULL)
      && (m_pToolCur->ToolType() == TOOLTYPE_ERASER)
      && (pToolNew->ToolType() != TOOLTYPE_ERASER))
    {
        m_pToolCur->DeselectGraphic();

        RemoveMarker(NULL);
        m_pMarker->DeleteAllMarkers( m_pSelectedGraphic );

        delete m_pSelectedGraphic;
        m_pSelectedGraphic = NULL;
    }

    // Save the new tool
    m_pToolCur = pToolNew;
}

//
//
// Function:    SetSelectionColor
//
// Purpose:     Set the color of the selected object
//
//
void WbDrawingArea::SetSelectionColor(COLORREF clr)
{
    RECT    rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionColor");

    // If the text editor is active - redraw the text in the new color
    if (m_bTextEditorActive)
    {
        // Change the color being used by the editor
        m_textEditor.SetColor(clr);

        // Update the screen
        m_textEditor.GetBoundsRect(&rc);
        InvalidateSurfaceRect(&rc);
    }

    // If there is a currently marked object
    if (GraphicSelected())
    {
        // Change color of the selected objects
        ASSERT(m_pMarker);

        m_pMarker->SetColor(clr);

        // Update the objects
        m_pMarker->Update();
    }

    m_textEditor.ForceUpdate();

}

//
//
// Function:    SetSelectionWidth
//
// Purpose:     Set the nib width used to draw the currently selected object
//
//
void WbDrawingArea::SetSelectionWidth(UINT uiWidth)
{
    // If there is a currently marked object
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // Change the width of the object
        m_pMarker->SetPenWidth(uiWidth);

        // Update the object
        m_pMarker->Update();
    }
}

//
//
// Function:    SetSelectionFont
//
// Purpose:     Set the font used by the currently selected object
//
//
void WbDrawingArea::SetSelectionFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionFont");

    // Define rectangles for redrawing
    RECT    rcOldBounds;
    RECT    rcNewBounds;

    m_textEditor.GetBoundsRect(&rcOldBounds);

    // Pass the font onto the text editor
    // If the text editor is active - redraw the text in the new font
    if (m_bTextEditorActive)
    {
        m_textEditor.SetFont(hFont);

        // Get the new rectangle of the text
        m_textEditor.GetBoundsRect(&rcNewBounds);

        // Remove and destroy the text cursor to ensure that it
        // gets re-drawn with the new size for the font

        // Update the screen
        InvalidateSurfaceRect(&rcOldBounds);
        InvalidateSurfaceRect(&rcNewBounds);

        // get the text cursor back
        ActivateTextEditor( TRUE );
    }

    // If there is a currently marked object
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        m_pMarker->SetSelectionFont(hFont);
    }
}

//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbDrawingArea::OnSetFocus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnSetFocus");

    //
    // If we are in text mode, we must make the text cursor visible.
    //
    if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
    {
        ActivateTextEditor(TRUE);
    }
}


//
//
// Function:    OnActivate
//
// Purpose:     The window is being activated or deactivated
//
//
void WbDrawingArea::OnActivate(UINT uiState)
{
    // Check if we are being activated or deactivated
    if (uiState)
    {
        // We are being activated, get the focus as well
        ::SetFocus(m_hwnd);

        // If we are in text mode, we must make the text cursor visible
        if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
        {
            ActivateTextEditor(TRUE);
        }
    }
    else
    {
        // We are being deactivated
        DeactivateTextEditor();
    }
}




//
//
// Function:    DeleteGraphic
//
// Purpose:     Remove an object from the page.
//
//
void WbDrawingArea::DeleteGraphic(DCWbGraphic* pObject)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeleteGraphic");

    ASSERT(pObject != NULL);

    // Delete the object from the recorded list. This is an asynchronous
    // function, completed when a WBP_EVENT_GRAPHIC_DELETED event is received.
    PG_GraphicDelete(m_hPage, *pObject);

    // The caller is responsible for deleting the graphic object.
}

//
//
// Function:    DeleteSelection
//
// Purpose:     Delete the currently selected object
//
//
void WbDrawingArea::DeleteSelection()
{
    // If there is an object currently selected...
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // ...delete it
        m_pMarker->DeleteSelection();
        m_pSelectedGraphic = NULL;
    }
}

//
//
// Function:    GetSelection
//
// Purpose:     Return the currently selected graphic (or NULL if none).
//
//
DCWbGraphic* WbDrawingArea::GetSelection()
{
  DCWbGraphic* pGraphic = NULL;

  // If there is an object currently selected...
  if (GraphicSelected())
  {
    // ...return it
    pGraphic = m_pSelectedGraphic;
  }

  return pGraphic;
}

//
//
// Function:    BringToTopSelection
//
// Purpose:     Bring the currently selected object to the top
//
//
void WbDrawingArea::BringToTopSelection()
{
    // If there is an object currently selected...
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // Bring it to the top
        m_pMarker->BringToTopSelection();

    // The update will be made in the window from the event generated
    // by the change to the page.
  }
}

//
//
// Function:    SendToBackSelection
//
// Purpose:     Send the currently marked object to the back
//
//
void WbDrawingArea::SendToBackSelection()
{
    // If there is an object currently selected...
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // Send it to the back
        m_pMarker->SendToBackSelection();

    // The update will be made in the window from the event generated
    // by the change to the page.
  }
}

//
//
// Function:    Clear
//
// Purpose:     Clear the drawing area.
//
//
void WbDrawingArea::Clear()
{
    // Remove the recorded objects
    PG_Clear(m_hPage);

  // The page will be redrawn after an event generated by the clear request
}

//
//
// Function:    Attach
//
// Purpose:     Change the page the window is displaying
//
//
void WbDrawingArea::Attach(WB_PAGE_HANDLE hPage)
{
    // Remove any pointers on the current page. We are really only doing this
    // to tell the pointers they are no longer drawn as they keep a record
    // of whether they are in order to undraw correctly.
    if (m_allPointers.IsEmpty() == FALSE)
    {
        // Get a DC for drawing
        HDC hDC = m_hDCCached;

        // Remove the pointers, reversing through the list
        DCWbGraphicPointer* pPointer;
        POSITION pos = m_allPointers.GetHeadPosition();

        while (pos != NULL)
        {
            // Remove it
            pPointer = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);
            pPointer->Undraw(hDC, this);
        }
    }

    m_allPointers.EmptyList();
    m_undrawnPointers.EmptyList();

    // Accept any text being edited
    if (m_bTextEditorActive)
    {
        EndTextEntry(TRUE);
    }

    // finish any drawing operation now
    if (m_bLButtonDown)
    {
        OnLButtonUp(0, m_ptStart.x, m_ptStart.y);
    }

    // Get rid of the selection
    ClearSelection();

    // Save the new page details
    m_hPage = hPage;

    // If the new page we are attaching is not the empty page, set up
    // the list of pointers for the new page.
    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        // Get the list of active pointers on the new page. The local
        // pointer must be last in the list so that it is drawn topmost.
        POM_OBJECT  hUserNext;

        DCWbGraphicPointer* pPointer = PG_FirstPointer(m_hPage, &hUserNext);

        while (pPointer != NULL)
        {
            // Check whether we should add this pointer to the list
            if (!pPointer->IsLocalPointer())
            {
                m_allPointers.AddTail(pPointer);
            }

            // Get the next pointer
            pPointer = PG_NextPointer(m_hPage, &hUserNext);
        }

        // Check if the local pointer should also be added
        pPointer = PG_LocalPointer(m_hPage);

        if (pPointer != NULL)
        {
            m_allPointers.AddTail(pPointer);
        }
    }

    // Force a redraw of the window to show the new contents
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    DrawMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::DrawMarker(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DrawMarker");

    ASSERT(m_pMarker);

    if (!hDC)
        hDC = m_hDCCached;

    // Draw the marker
    m_pMarker->Draw(hDC);
}

//
//
// Function:    PutMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::PutMarker(HDC hDC, BOOL bDraw)
{
    ASSERT(m_pMarker);

    // If the marker is not already present, draw it
    if (!m_bMarkerPresent)
    {
        m_pMarker->Present( TRUE );

        // Draw the marker (using XOR)
        if( bDraw )
            DrawMarker(hDC);

        // Show that the marker is present
        m_bMarkerPresent = TRUE;
    }
}

//
//
// Function:    RemoveMarker
//
// Purpose:     Remove the graphic object marker
//
//
void WbDrawingArea::RemoveMarker(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemoveMarker");

    ASSERT(m_pMarker);

    if (!hDC)
        hDC = m_hDCCached;

    // If the marker is not already present, draw it
    if (m_bMarkerPresent)
    {
        // Draw the marker (it is XORed so this removes it)
        m_pMarker->Undraw(hDC, this);

        m_pMarker->Present( FALSE );

        // Show that the marker is no longer present
        m_bMarkerPresent = FALSE;
    }
}




//
//
// Function:    ActivateTextEditor
//
// Purpose:     Start a text editing session
//
//
void WbDrawingArea::ActivateTextEditor( BOOL bPutUpCusor )
{
    // Record that the editor is now active
    m_bTextEditorActive = TRUE;

    // show editbox
    m_textEditor.ShowBox( SW_SHOW );

    // reset our DBCS sync

    // Start the timer for updating the text
    m_textEditor.SetTimer( DRAW_GRAPHICUPDATEDELAY);
}

//
//
// Function:    DeactivateTextEditor
//
// Purpose:     End a text editing session
//
//
void WbDrawingArea::DeactivateTextEditor(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeactivateTextEditor");

    // Stop the update timer
    m_textEditor.KillTimer();

    // Ensure the object is unlocked, if it was ever added to the page
    if (m_textEditor.Handle() != NULL)
    {
        m_textEditor.Unlock();

        // Sync up across all connections - FIXES BUG 521
        m_textEditor.ForceReplace();

        UINT uiReturn;
        uiReturn = g_pwbCore->WBP_GraphicMove(m_hPage, m_textEditor.Handle(),
            LAST);
        if (uiReturn != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
		    return;
        }
        //////////////////////////
    }

    // Show that we are not editing any text
    m_bTextEditorActive = FALSE;

    // hide editbox
    m_textEditor.ShowBox( SW_HIDE );
}



//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a point in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPPOINT lppoint)
{
    lppoint->x -= m_originOffset.cx;
    lppoint->x *= m_iZoomFactor;

    lppoint->y -= m_originOffset.cy;
    lppoint->y *= m_iZoomFactor;
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a point in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPPOINT lppoint)
{
    ASSERT(m_iZoomFactor != 0);

    lppoint->x /= m_iZoomFactor;
    lppoint->x += m_originOffset.cx;

    lppoint->y /= m_iZoomFactor;
    lppoint->y += m_originOffset.cy;
}


//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a rectangle in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPRECT lprc)
{
    SurfaceToClient((LPPOINT)&lprc->left);
    SurfaceToClient((LPPOINT)&lprc->right);
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a rectangle in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPRECT lprc)
{
    ClientToSurface((LPPOINT)&lprc->left);
    ClientToSurface((LPPOINT)&lprc->right);
}

//
//
// Function:    GraphicSelected
//
// Purpose:     Return TRUE if a graphic is currently selected
//
//
BOOL WbDrawingArea::GraphicSelected(void)
{
    ASSERT(m_pMarker);

    BOOL bSelected = (m_bMarkerPresent) && (m_pMarker->GetNumMarkers() > 0);

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicSelected");

    if( bSelected )
        {
        ASSERT(m_pSelectedGraphic != NULL);
        }

    return( bSelected );
    }

//
//
// Function:    SelectGraphic
//
// Purpose:     Select a graphic - save the pointer to the graphic and
//              draw the marker on it.
//
//
void WbDrawingArea::SelectGraphic(DCWbGraphic* pGraphic,
                                      BOOL bEnableForceAdd,
                                      BOOL bForceAdd )
{
    BOOL bZapCurrentSelection;
    RECT rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SelectGraphic");

    ASSERT(m_pMarker);

  if (pGraphic->Locked() == FALSE)
  {
    // Save the pointer to the selected graphic
    m_pSelectedGraphic = pGraphic;


    if( (pGraphic = m_pMarker->HasAMarker( m_pSelectedGraphic )) != NULL )
        {
        // toggle marker (unselect pGraphic)
        delete pGraphic;
        delete m_pSelectedGraphic;
        m_pSelectedGraphic = m_pMarker->LastMarker();
        }
    else
        {

        // new selection, add to list or replace list?
        if( bEnableForceAdd )
            bZapCurrentSelection = !bForceAdd;
        else
            bZapCurrentSelection =
                ((GetAsyncKeyState( VK_SHIFT ) >= 0) &&
                    (GetAsyncKeyState( VK_CONTROL ) >= 0));

        if( bZapCurrentSelection )
            {
            // replace list
            RemoveMarker(NULL);
            m_pMarker->DeleteAllMarkers( m_pSelectedGraphic, TRUE );
            }

        // Add the object rect to the marker rect list
        m_pSelectedGraphic->GetBoundsRect(&rc);
        m_pMarker->SetRect(&rc, m_pSelectedGraphic, FALSE );
    }

    // Draw the marker
    PutMarker(NULL);

    // Update the attributes window to show graphic is selected
    if( m_pSelectedGraphic != NULL )
        m_pToolCur->SelectGraphic(m_pSelectedGraphic);

    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0L);
    }
  }
  else
  {
    // we can delete the graphic now, because we're not selecting it
    delete pGraphic;
    m_pSelectedGraphic = NULL;
    TRACE_MSG(("Tried to select a locked graphic - ignored"));
  }
}

//
//
// Function:    DeselectGraphic
//
// Purpose:     Deselect a graphic - remove the marker and delete the
//              graphic object associated with it.
//
//
void WbDrawingArea::DeselectGraphic(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeselectGraphic");

    //
    // Quit if no graphic selected.
    //
    if( m_pSelectedGraphic == NULL )
    {
        return;
    }

    // Remove the marker
    RemoveMarker(NULL);

    // Delete the graphic object
    delete m_pSelectedGraphic;
    m_pSelectedGraphic = NULL;

    // Update the attributes window to show graphic is unselected
    m_pToolCur->DeselectGraphic();

    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0L);
    }
}



//
//
// Function:    GetVisibleRect
//
// Purpose:     Return the rectangle of the surface currently visible in the
//              drawing area window.
//
//
void WbDrawingArea::GetVisibleRect(LPRECT lprc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::VisibleRect");

    // Get the client rectangle
    ::GetClientRect(m_hwnd, lprc);

    // Convert to surface co-ordinates
    ClientToSurface(lprc);
}


//
//
// Function:    MoveOntoSurface
//
// Purpose:     If a given point is outwith the surface rect, move it on
//
//
void WbDrawingArea::MoveOntoSurface(LPPOINT lppoint)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::MoveOntoSurface");

    //
    // Make sure that the position is within the surface rect
    //

    if (lppoint->x < 0)
    {
        lppoint->x = 0;
    }
    else if (lppoint->x >= DRAW_WIDTH)
    {
        lppoint->x = DRAW_WIDTH - 1;
    }

    if (lppoint->y < 0)
    {
        lppoint->y = 0;
    }
    else if (lppoint->y >= DRAW_HEIGHT)
    {
        lppoint->y = DRAW_HEIGHT - 1;
    }
}


//
//
// Function:    GetOrigin
//
// Purpose:     Provide current origin of display
//
//
void WbDrawingArea::GetOrigin(LPPOINT lppoint)
{
    lppoint->x = m_originOffset.cx;
    lppoint->y = m_originOffset.cy;
}



void WbDrawingArea::ShutDownDC(void)
{
    UnPrimeDC(m_hDCCached);

    if (m_hDCWindow != NULL)
    {
        ::ReleaseDC(m_hwnd, m_hDCWindow);
        m_hDCWindow = NULL;
    }

    m_hDCCached = NULL;
}




void WbDrawingArea::ClearSelection( void )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ClearSelection");

    ASSERT(m_pMarker);

    RemoveMarker( NULL );
    m_pMarker->DeleteAllMarkers( m_pSelectedGraphic );
    DeselectGraphic();
}





void WbDrawingArea::OnCancelMode( void )
{
    // We were dragging but lost mouse control, gracefully end the drag (NM4db:573)
    POINT pt;

    ::GetCursorPos(&pt);
    ::ScreenToClient(m_hwnd, &pt);
    OnLButtonUp(0, pt.x, pt.y);
    m_bLButtonDown = FALSE;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\globals.h ===
//
// Global variables
//

extern WbMainWindow *   g_pMain;
extern HINSTANCE        g_hInstance;
extern IWbClient *      g_pwbCore;
extern UINT             g_uConfShutdown;
extern HPALETTE         g_hRainbowPaletteDisplay;
extern WbPrinter *      g_pPrinter;
extern HINSTANCE        g_hImmLib;
extern IGC_PROC         g_fnImmGetContext;
extern INI_PROC         g_fnImmNotifyIME;

enum
{
    CLIPBOARD_PRIVATE_SINGLE_OBJ = 0,
    CLIPBOARD_PRIVATE_MULTI_OBJ,
    CLIPBOARD_DIB,
    CLIPBOARD_ENHMETAFILE,
    CLIPBOARD_TEXT,
    CLIPBOARD_ACCEPTABLE_FORMATS
};
extern int         g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS];


extern BOOL         g_bPalettesInitialized;
extern BOOL         g_bUsePalettes;

extern UINT         g_PenWidths[NUM_OF_WIDTHS];
extern UINT         g_HighlightWidths[NUM_OF_WIDTHS];


#define NUM_COLOR_ENTRIES   21
extern COLORREF     g_ColorTable[NUM_COLOR_ENTRIES];


//
// Complex object globals
//
extern WbUserList *  g_pUsers;

extern WbDrawingArea *      g_pDraw;

extern DCWbColorToIconMap * g_pIcons;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\clpbd.cpp ===
//
// CLPBD.CPP
// Clipboard Handling
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"



//
// NFC, SFR 5921.  Maximum length of a string pasted from the clipboard.
// We impose this limit as our graphic object code cant
// handle more then this number of chars.
//
#define WB_MAX_TEXT_PASTE_LEN  (INT_MAX-1)

//
//
// Function:    Paste
//
// Purpose:     Paste a format from the clipboard
//
//
DCWbGraphic* WbMainWindow::CLP_Paste(void)
{
    UINT        length = 0;
    HANDLE      handle = NULL;
    DCWbGraphic* pGraphic = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Paste");

    // Get the highest priority acceptable format in the clipboard
    int iFormat = CLP_AcceptableClipboardFormat();
    if (!iFormat)
        goto NoOpenClip;

    TRACE_MSG(("Found acceptable format %d", iFormat));

    // Open the clipboard

    if (!::OpenClipboard(m_hwnd))
    {
        WARNING_OUT(("CLP_Paste: can't open clipboard"));
        goto NoOpenClip;
    }

    handle = ::GetClipboardData(iFormat);
    if (!handle)
    {
        WARNING_OUT(("CLP_Paste: can't get data for format %d", iFormat));
        goto NoFormatData;
    }

    switch (iFormat)
    {
        //
        // Check the standard formats
        //
        case CF_DIB:
        {
            TRACE_MSG(("Pasting CF_DIB"));

            // Lock the handle to get a pointer to the DIB
            LPBITMAPINFOHEADER lpbi;
            lpbi = (LPBITMAPINFOHEADER) ::GlobalLock(handle);
            if (lpbi != NULL)
            {
                LPBITMAPINFOHEADER lpbiNew;

                // Make a copy of the clipboard data
                lpbiNew = DIB_Copy(lpbi);
                if (lpbiNew != NULL)
                {
                    // Create a graphic object
                    DCWbGraphicDIB* pDIB = new DCWbGraphicDIB();
                    if (!pDIB)
                    {
                        ERROR_OUT(("CF_DIB clipboard handling; couldn't create new DCWbGraphicDIB object"));
                    }
                    else
                    {
                        pDIB->SetImage(lpbiNew);
                    }

                    TRACE_MSG(("Set DIB into graphic object %lx",pDIB));
                    pGraphic = pDIB;
                }

                // Release the memory
                ::GlobalUnlock(handle);
            }
        }
        break;

        //
        // We have a metafile. Play it into a bitmap and then use the
        // data.
        //
        case CF_ENHMETAFILE:
        {
            TRACE_MSG(("Pasting CF_ENHMETAFILE"));

            HDC         hDrawingDC;
            ENHMETAHEADER meta_header;
            HBITMAP     hBitmap = NULL;
            HDC         meta_dc = NULL;
            HBITMAP     hSaveBitmap;
            HPEN        hSavePen;
            HPALETTE    hPalette;
            RECT        meta_rect;
            LPBITMAPINFOHEADER lpbiNew;
            int         tmp;

            // We just need a DC compatible with the drawing area wnd
            hDrawingDC = m_drawingArea.GetCachedDC();

            // make a dc
            meta_dc = ::CreateCompatibleDC(hDrawingDC);
            if (!meta_dc)
                goto CleanupMetaFile;

            // figure out image size.
            ::GetEnhMetaFileHeader( (HENHMETAFILE)handle,
                                      sizeof( ENHMETAHEADER ),
                                      &meta_header );
            meta_rect.left = meta_rect.top = 0;

            meta_rect.right = ((meta_header.rclFrame.right - meta_header.rclFrame.left)
                * ::GetDeviceCaps(hDrawingDC, LOGPIXELSX ))/2540;

            meta_rect.bottom = ((meta_header.rclFrame.bottom - meta_header.rclFrame.top)
                * ::GetDeviceCaps(hDrawingDC, LOGPIXELSY ))/2540;

            // Normalize coords
            if (meta_rect.right < meta_rect.left)
            {
                tmp = meta_rect.left;
                meta_rect.left = meta_rect.right;
                meta_rect.right = tmp;
            }
            if (meta_rect.bottom < meta_rect.top)
            {
                tmp = meta_rect.top;
                meta_rect.top = meta_rect.bottom;
                meta_rect.bottom = tmp;
            }

            // make a place to play meta in
            hBitmap = ::CreateCompatibleBitmap(hDrawingDC,
                meta_rect.right - meta_rect.left,
                meta_rect.bottom - meta_rect.top);
            if (!hBitmap)
                goto CleanupMetaFile;

            hSaveBitmap = SelectBitmap(meta_dc, hBitmap);

            // erase our paper
            hSavePen = SelectPen(meta_dc, GetStockObject(NULL_PEN));

            ::Rectangle(meta_dc, meta_rect.left, meta_rect.top,
                meta_rect.right + 1, meta_rect.bottom + 1);

            SelectPen(meta_dc, hSavePen);

            // play the tape
            ::PlayEnhMetaFile(meta_dc, (HENHMETAFILE)handle, &meta_rect);

            // unplug our new bitmap
            SelectBitmap(meta_dc, hSaveBitmap);

            // Check for a palette object in the clipboard
            hPalette = (HPALETTE)::GetClipboardData(CF_PALETTE);

            // Create a new DIB from the bitmap
            lpbiNew = DIB_FromBitmap(hBitmap, hPalette, FALSE);
            if (lpbiNew != NULL)
            {
                // Create a DIB graphic from the DIB
                DCWbGraphicDIB* pDIB = new DCWbGraphicDIB();
                if (!pDIB)
                {
                    ERROR_OUT(("CF_ENHMETAFILE handling; couldn't allocate DCWbGraphicDIB object"));
                }
                else
                {
                    pDIB->SetImage(lpbiNew);
                }

                TRACE_MSG(("Set bitmap DIB into graphic object %lx",pDIB));
                pGraphic = pDIB;
            }

CleanupMetaFile:
            // Free our temp intermediate bitmap
            if (hBitmap != NULL)
            {
                DeleteBitmap(hBitmap);
            }

            if (meta_dc != NULL)
            {
                ::DeleteDC(meta_dc);
            }
        }
        break;

        case CF_TEXT:
        {
            LPSTR   pData;

            TRACE_DEBUG(("Pasting text"));

            // Get a handle to the clipboard contents
            pData = (LPSTR)::GlobalLock(handle);

			if(pData)
			{
	            // Create a text object to hold the data - get the font to
	            // use from the tool attributes group.
	            DCWbGraphicText* pPasteText = new DCWbGraphicText();

    	        // Use the current font attributes
                if (!pPasteText)
                {
                    ERROR_OUT(("CF_TEXT handling; failed to allocate DCWbGraphicText object"));
                }
                else
                {
                    pPasteText->SetFont(m_pCurrentTool->GetFont());
    	            pPasteText->SetText(pData);
                }

        	    pGraphic = pPasteText;
            }

            // Release the handle
            ::GlobalUnlock(handle);
        }
        break;

        default:
        {
            if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ])
            {
                // There is a Whiteboard private format object in the clipboard.
                // The format of this object is exactly as stored in the page, we
                // can therefore use it immediately.
                TRACE_DEBUG(("Pasting a private Whiteboard object"));

                // Get a handle to the clipboard contents
                PWB_GRAPHIC pHeader;
                if (pHeader = (PWB_GRAPHIC) ::GlobalLock(handle))
                {
                    // Add the object to the page
                    pGraphic = DCWbGraphic::CopyGraphic(pHeader);

                    // Release the handle
                    ::GlobalUnlock(handle);
                }
            }
            else if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE_MULTI_OBJ])
            {
                DCWbGraphicMarker * pMarker = m_drawingArea.GetMarker();
                if (!pMarker)
                {
                    ERROR_OUT(("Couldn't get marker from drawing area"));
                }
                else
                {
                    pMarker->Paste(handle);
                }

                pGraphic = pMarker;
            }
        }
        break;
    }

NoFormatData:
    ::CloseClipboard();

NoOpenClip:
    return pGraphic;
}


//
//
// Function:    Copy
//
// Purpose:     Copy a graphic to the clipboard. The second parameter
//              indicates whether immediate rendering is required.
//
//
BOOL WbMainWindow::CLP_Copy(DCWbGraphic* pGraphic, BOOL bRenderNow)
{
    BOOL bResult = FALSE;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Copy");
    ASSERT(pGraphic != NULL);

    //
    // We act according to the format of the selected graphic.
    //
    // For all formats we supply the Whiteboard private format (which is
    // just a copy of the flat representation of the graphic).
    //
    // We supply standard formats as follows.
    //
    // For bitmaps and all others we supply CF_DIB.
    //
    // For text graphics we supply CF_TEXT.
    //

    // Free up the saved delayed rendering graphic since we are about to
    // replace it in the clipboard
    CLP_FreeDelayedGraphic();

    // Save the page and handle of the new graphic, since they'll be used 
    // for/ rendering it, either now or later
    m_hPageClip = pGraphic->Page();
    m_hGraphicClip = pGraphic->Handle();

    if (bRenderNow)
    {
        TRACE_MSG(("Rendering the graphic now"));

        // Have to empty the clipboard before rendering the formats.
        if (::OpenClipboard(m_hwnd))
        {
            // Get ownership of the clipboard
            ::EmptyClipboard();
            ::CloseClipboard();

            // Render the graphic
            bResult = CLP_RenderAllFormats(pGraphic);
        }

        // We can forget about this object now.
        ASSERT(m_pDelayedGraphicClip == NULL);

        m_hPageClip = WB_PAGE_HANDLE_NULL;
        m_hGraphicClip = NULL;
    }
    else
    {
        TRACE_MSG(("Delaying rendering"));

        // For delayed rendering we insist that the graphic has been saved
        // to external storage. It must therefore have a valid page and graphic
        // handle.
        ASSERT(m_hPageClip != WB_PAGE_HANDLE_NULL);
        ASSERT(m_hGraphicClip != NULL);

        // Give formats (but no data) to the clipboard
        bResult = CLP_DelayAllFormats(pGraphic);
    }

    return bResult;
}

//
//
// Function:    DelayAllFormats
//
// Purpose:     Copy a graphic to the clipboard with delayed rendering
//
//
BOOL WbMainWindow::CLP_DelayAllFormats(DCWbGraphic* pGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_DelayAllFormats");
    BOOL bResult = FALSE;

    if (::OpenClipboard(m_hwnd))
    {
        // Empty / get ownership of the clipboard
        bResult = ::EmptyClipboard();

        // Add the private format
        HANDLE hResult;
        hResult = 
            ::SetClipboardData(g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ], NULL);
        TRACE_DEBUG(("Adding Whiteboard object to clipboard"));

        if (pGraphic->IsGraphicTool() == enumGraphicText)
        {
            // Text graphic
            hResult = ::SetClipboardData(CF_TEXT, NULL);
            TRACE_DEBUG(("Adding text to clipboard"));
        }
        else
        {
            // All other graphics
            hResult = ::SetClipboardData(CF_DIB, NULL);
            TRACE_DEBUG(("Adding DIB to clipboard"));
        }

        ::CloseClipboard();
    }

    return bResult;
}


//
//
// Function:    RenderAllFormats
//
// Purpose:     Render a graphic to the clipboard
//
//
BOOL WbMainWindow::CLP_RenderAllFormats(DCWbGraphic* pGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAllFormats");
    BOOL bResult = FALSE;

    // Open the clipboard
    if (bResult = ::OpenClipboard(m_hwnd))
    {
        TRACE_DEBUG(("Rendering all formats of graphic"));

        // Render the private format
        bResult &= CLP_RenderPrivateFormat(pGraphic);

        if (pGraphic->IsGraphicTool() == enumGraphicText)
        {
            // Text graphic
            bResult &= CLP_RenderAsText(pGraphic);
        }
        else if (pGraphic->IsGraphicTool() == enumGraphicDIB)
        {
            // DIBs
            bResult &= CLP_RenderAsImage(pGraphic);
        }
        else
        {
            bResult &= CLP_RenderAsBitmap(pGraphic);
        }

        // Close the clipboard
        ::CloseClipboard();
    }

    return bResult;
}



BOOL WbMainWindow::CLP_RenderPrivateFormat(DCWbGraphic* pGraphic)
{
    if (pGraphic->IsGraphicTool() == enumGraphicMarker)
        return( ((DCWbGraphicMarker*)pGraphic)->RenderPrivateMarkerFormat() );
    else
        return(CLP_RenderPrivateSingleFormat(pGraphic));
}


//
//
// Function:    RenderPrivateSingleFormat
//
// Purpose:     Render the private format of a graphic to the clipboard.
//              The clipboard should be open before this call is made.
//
//
BOOL WbMainWindow::CLP_RenderPrivateSingleFormat(DCWbGraphic* pGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderPrivateFormat");
    ASSERT(pGraphic != NULL);

    BOOL bResult = FALSE;

    // Get a pointer to the graphic data
    PWB_GRAPHIC pHeader = CLP_GetGraphicData();
    if (pHeader != NULL)
    {
        // Allocate memory for the clipboard data
        HANDLE hMem = ::GlobalAlloc(GHND, pHeader->length);
        if (hMem != NULL)
        {
            // Get a pointer to the memory
            LPBYTE pDest = (LPBYTE)::GlobalLock(hMem);
            if (pDest != NULL)
            {
                // Copy the graphic data to the allocated memory
                memcpy(pDest, pHeader, pHeader->length);
                TRACE_MSG(("Copied data %d bytes into %lx",pHeader->length,pDest));

                // make sure copy isn't "locked" (bug 474)
                ((PWB_GRAPHIC)pDest)->locked = WB_GRAPHIC_LOCK_NONE;

                // Release the memory
                ::GlobalUnlock(hMem);

                // Pass the data to the clipboard
                if (::SetClipboardData(g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ], hMem))
                {
                    TRACE_DEBUG(("Rendered data in Whiteboard format"));
                    bResult = TRUE;
                }
            }

            // If we failed to put the data into the clipboard, free the memory.
            // (If we did put it into the clipboard we must not free it).
            if (bResult == FALSE)
            {
                WARNING_OUT(("Render failed"));
                ::GlobalFree(hMem);
            }
        }

        // Release the graphic data
        CLP_ReleaseGraphicData(pHeader);
    }

    return bResult;
}

//
//
// Function:    RenderAsText
//
// Purpose:     Render the text format of a graphic to the clipboard.
//              The clipboard should be open before this call is made.
//              This member should only be called for text graphics.
//
//
BOOL WbMainWindow::CLP_RenderAsText
(
    DCWbGraphic* pGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsText");

    ASSERT(pGraphic != NULL);
    ASSERT(pGraphic->IsGraphicTool() == enumGraphicText);

    BOOL bResult = FALSE;

    // Get the total length of the clipboard format of the text
    StrArray& strText = ((DCWbGraphicText*) pGraphic)->strTextArray;
    int   iCount = strText.GetSize();
    int   iIndex;
    DWORD dwLength = 0;

    for (iIndex = 0; iIndex < iCount; iIndex++)
    {
        // Length of string plus 2 for carriage return and line feed
        dwLength += lstrlen(strText[iIndex]) + 2;
    }

    // One more for the terminating NULL
    dwLength += 1;

    // Allocate memory for the clipboard data
    HANDLE hMem = ::GlobalAlloc(GHND, dwLength);
    if (hMem != NULL)
    {
        // Get a pointer to the memory
        LPSTR pDest = (LPSTR) ::GlobalLock(hMem);
        if (pDest != NULL)
        {
            // Write the graphic data to the allocated memory
            for (iIndex = 0; iIndex < iCount; iIndex++)
            {
                _tcscpy(pDest, strText[iIndex]);
                pDest += lstrlen(strText[iIndex]);

                // Add the carriage return and line feed
                *pDest++ = '\r';
                *pDest++ = '\n';
            }

            // Add the final NULL
            *pDest = '\0';

            // Release the memory
            ::GlobalUnlock(hMem);

            // Pass the data to the clipboard
            if (::SetClipboardData(CF_TEXT, hMem))
            {
                TRACE_DEBUG(("Rendered data in text format"));
                bResult = TRUE;
            }
        }

        // If we failed to put the data into the clipboard, free the memory
        if (bResult == FALSE)
        {
            ::GlobalFree(hMem);
        }
    }

    return bResult;
}

//
//
// Function:    RenderAsImage
//
// Purpose:     Render the bitmap format of a graphic to the clipboard.
//              The clipboard should be open before this call is made.
//              This member should only be called for DIB graphics.
//
//
BOOL WbMainWindow::CLP_RenderAsImage
(
    DCWbGraphic* pGraphic
)
{
    BOOL bResult = FALSE;
    HANDLE hMem = NULL;
    BYTE*  pDest = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsImage");

    ASSERT(pGraphic != NULL);
    ASSERT(pGraphic->IsGraphicTool() == enumGraphicDIB);

    // Get a pointer to the graphic data
    PWB_GRAPHIC pHeader = CLP_GetGraphicData();
    if (pHeader != NULL)
    {
        LPBITMAPINFOHEADER lpbi;

        TRACE_MSG(("Getting a DIB image from %lx",pHeader));
        lpbi = (LPBITMAPINFOHEADER) (((LPBYTE) pHeader) + pHeader->dataOffset);
        DWORD dwLength = pHeader->length - pHeader->dataOffset;

        // Allocate the memory
        hMem = ::GlobalAlloc(GHND, dwLength);
        if (hMem != NULL)
        {
            LPBYTE pDest = (LPBYTE)::GlobalLock(hMem);
            if (pDest != NULL)
            {
                TRACE_MSG(("Building DIB at %lx length %ld",pDest, dwLength));
                memcpy(pDest, lpbi, dwLength);
                ::GlobalUnlock(hMem);

                if (::SetClipboardData(CF_DIB, hMem))
                {
                    TRACE_DEBUG(("Rendered data in DIB format"));
                    bResult = TRUE;
                }

                // If we failed to put the data into the clipboard, free the memory
                if (!bResult)
                {
                    ERROR_OUT(("Error putting DIB into clipboard"));
                    ::GlobalFree(hMem);
                }
            }
        }
        else
        {
            ERROR_OUT(("Could not allocate memory for DIB"));
        }

        // Release the data
        CLP_ReleaseGraphicData(pHeader);
    }

    return bResult;
}


//
// CLP_RenderAsBitmap()
//
// This draws all other graphics into a bitmap and pastes the DIB contents
// onto the clipboard.
//
BOOL WbMainWindow::CLP_RenderAsBitmap(DCWbGraphic* pGraphic)
{
    BOOL    bResult = FALSE;
    HDC     hdcDisplay = NULL;
    HDC     hdcMem = NULL;
    HBITMAP hBitmap = NULL;
    HBITMAP hOldBitmap = NULL;
    HPALETTE hPalette;
    RECT    rcBounds;
    POINT   pt;
    LPBITMAPINFOHEADER lpbi;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsBitmap");

    ASSERT(pGraphic != NULL);
    ASSERT(pGraphic->IsGraphicTool() != enumGraphicText);
    ASSERT(pGraphic->IsGraphicTool() != enumGraphicDIB);

    //
    // First, draw it into a bitmap
    // Second, get the DIB bits of the bitmap
    //

    hdcDisplay = ::CreateDC("DISPLAY", NULL, NULL, NULL);
    if (!hdcDisplay)
    {
        ERROR_OUT(("Can't create DISPLAY dc"));
        goto AsBitmapDone;
    }

    hdcMem = ::CreateCompatibleDC(hdcDisplay);
    if (!hdcMem)
    {
        ERROR_OUT(("Can't create DISPLAY compatible dc"));
        goto AsBitmapDone;
    }

    pGraphic->GetBoundsRect(&rcBounds);

    hBitmap = ::CreateCompatibleBitmap(hdcDisplay,
        (rcBounds.right - rcBounds.left), (rcBounds.bottom - rcBounds.top));
    if (!hBitmap)
    {
        ERROR_OUT(("Can't create compatible bitmap"));
        goto AsBitmapDone;
    }

    hOldBitmap = SelectBitmap(hdcMem, hBitmap);
    if (!hOldBitmap)
    {
        ERROR_OUT(("Failed to select compatible bitmap"));
        goto AsBitmapDone;
    }

    ::SetMapMode(hdcMem, MM_ANISOTROPIC);
    pGraphic->GetPosition(&pt);
    ::SetWindowOrgEx(hdcMem, pt.x, pt.y, NULL);

    // Clear out bitmap with white background -- now that origin has been
    // altered, we can use drawing area coors.
    ::PatBlt(hdcMem, rcBounds.left, rcBounds.top, rcBounds.right - rcBounds.left,
        rcBounds.bottom - rcBounds.top, WHITENESS);

    if (pGraphic->IsGraphicTool() == enumGraphicMarker)
    {
        ((DCWbGraphicMarker *)pGraphic)->Draw(hdcMem, TRUE);
    }
    else
    {
        pGraphic->Draw(hdcMem);
    }

    SelectBitmap(hdcMem, hOldBitmap);

    // Now get the dib bits...
    hPalette = CreateSystemPalette();
    lpbi = DIB_FromBitmap(hBitmap, hPalette, TRUE);
    if (hPalette != NULL)
        ::DeletePalette(hPalette);

    // And put the handle on the clipboard
    if (lpbi != NULL)
    {
        if (::SetClipboardData(CF_DIB, (HGLOBAL)lpbi))
        {
            bResult = TRUE;
        }
        else
        {
            ::GlobalFree((HGLOBAL)lpbi);
        }
    }

AsBitmapDone:
    if (hBitmap != NULL)
        ::DeleteBitmap(hBitmap);

    if (hdcMem != NULL)
        ::DeleteDC(hdcMem);

    if (hdcDisplay != NULL)
        ::DeleteDC(hdcDisplay);

    return(bResult);
}



//
//
// Function:    RenderFormat
//
// Purpose:     Render the specified format of the graphic in the clipboard.
//
//
BOOL WbMainWindow::CLP_RenderFormat(int iFormat)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderFormat");

    BOOL bResult = FALSE;

    // Get a graphic from the handle
    DCWbGraphic* pGraphic = CLP_GetGraphic();

    if (pGraphic != NULL)
    {
        // Check if it is the private format that is wanted
        switch (iFormat)
        {
            default:
            {
                if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ])
                {
                    bResult = CLP_RenderPrivateFormat(pGraphic);
                }
                else
                {
                    ERROR_OUT(("Unrecognized CLP format %d", iFormat));
                }
            }
            break;

            case CF_TEXT:
            {
                bResult = CLP_RenderAsText(pGraphic);
            }
            break;

            case CF_DIB:
            {
                if (pGraphic->IsGraphicTool() == enumGraphicDIB)
                    bResult = CLP_RenderAsImage(pGraphic);
                else
                    bResult = CLP_RenderAsBitmap(pGraphic);
            }
            break;
        }
    }

    return bResult;
}

//
//
// Function:    RenderAllFormats
//
// Purpose:     Render all formats of the graphic in the clipboard.
//
//
BOOL WbMainWindow::CLP_RenderAllFormats(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAllFormats");

    BOOL bResult = FALSE;

    // Get a graphic from the handle
    DCWbGraphic* pGraphic = CLP_GetGraphic();

    if (pGraphic != NULL)
    {
        bResult = CLP_RenderAllFormats(pGraphic);
    }

     return bResult;
}

//
//
// Function:    AcceptableClipboardFormat
//
// Purpose:     Return highest priority clipboard format if an acceptable
//              one is available, else return NULL.
//
//
int WbMainWindow::CLP_AcceptableClipboardFormat(void)
{
    // Look for any of the supported formats being available
    int iFormat = ::GetPriorityClipboardFormat((UINT *)g_ClipboardFormats, CLIPBOARD_ACCEPTABLE_FORMATS);
    if (iFormat == -1)
    {
        iFormat = 0;
    }

    // the following is a performance enhancement: if we have found at some
    // point that the object on the clipboard does not have whiteboard
    // private format, then we can discard the delayed graphic because we
    // know we'll never be asked to render it.
    if (iFormat != g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ])
    {
        CLP_FreeDelayedGraphic();
    }

    return iFormat;
}

//
//
// Function:    LastCopiedPage
//
// Purpose:     Return the handle of the page on which the last graphic
//              copied to the clipboard was located.
//
//
WB_PAGE_HANDLE WbMainWindow::CLP_LastCopiedPage(void) const
{
    // If there's no graphic, there shouldn't be a page either
    ASSERT((m_hGraphicClip != NULL) == (m_hPageClip != WB_PAGE_HANDLE_NULL));
    return(m_hPageClip);
}

WB_GRAPHIC_HANDLE WbMainWindow::CLP_LastCopiedGraphic(void) const
{
    return(m_hGraphicClip);
}

//
//
// Function:    GetGraphic
//
// Purpose:     Retrieve the graphic object for copying to the clipboard. If
//              the object has been saved, then use the local copy,
//              otherwise get the page to construct it now.
//
//
DCWbGraphic* WbMainWindow::CLP_GetGraphic(void)
{
    DCWbGraphic* pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_GetGraphic");

    // if we have not saved the graphic's contents, then we must have a
    // valid page and graphic handle, since we construct the graphic now
    if (m_pDelayedGraphicClip == NULL)
    {
        ASSERT(m_hPageClip != WB_PAGE_HANDLE_NULL);
        ASSERT(m_hGraphicClip != NULL);

        pGraphic = DCWbGraphic::ConstructGraphic(m_hPageClip, m_hGraphicClip);
    }
    else
    {
        pGraphic = m_pDelayedGraphicClip;
        TRACE_MSG(("returning delayed graphic %lx",pGraphic));
    }

    return(pGraphic);
}

//
//
// Function:    GetGraphicData
//
// Purpose:     Retrieve the graphic data for copying to the clipboard. If
//              the data has been saved, then get a pointer to the copy (in
//              global memory), otherwise get it from the page.
//
//              The memory must be released with ReleaseGraphicData as soon
//              as possible.
//
//
PWB_GRAPHIC WbMainWindow::CLP_GetGraphicData(void)
{
    PWB_GRAPHIC pHeader;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_GetGraphicData");

    // if we have not saved the graphic's contents, then we must have a
    // valid page and graphic handle, since we get the graphic data now
    pHeader = m_pDelayedDataClip;
    if (pHeader == NULL)
    {
        ASSERT(m_hPageClip != WB_PAGE_HANDLE_NULL);
        ASSERT(m_hGraphicClip != NULL);

        pHeader = PG_GetData(m_hPageClip, m_hGraphicClip);
    }

    return(pHeader);
}

//
//
// Function:    ReleaseGraphicData
//
// Purpose:     Release the data which was accessed by an earlier call to
//              GetGraphicData.
//
//
void WbMainWindow::CLP_ReleaseGraphicData(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_ReleaseGraphicData");

    // release it in the right way, depending on whether we got the data
    // from the page, or just got a pointer to existing global data in
    // CLP_GetGraphicData
    if (m_pDelayedDataClip == NULL)
    {
        g_pwbCore->WBP_GraphicRelease(m_hPageClip, m_hGraphicClip, pHeader);
    }
}

//
//
// Function:    SaveDelayedGraphic
//
// Purpose:     Create a copy of the graphic which was copied to the
//              clipboard with delayed rendering.
//
//
void WbMainWindow::CLP_SaveDelayedGraphic(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_SaveDelayedGraphic");

    // Free any previously-held delayed graphic
    CLP_FreeDelayedGraphic();

    // Get the new delayed graphic object and a pointer to its data
    DCWbGraphic* pGraphic = CLP_GetGraphic();
    TRACE_MSG(("Got graphic at address %lx",pGraphic));

    m_pDelayedGraphicClip = pGraphic->Copy();
    TRACE_MSG(("Copied to %lx",m_pDelayedGraphicClip));
    delete pGraphic;

    PWB_GRAPHIC pHeader = PG_GetData(m_hPageClip, m_hGraphicClip);
    TRACE_MSG(("Graphic header %lx",pHeader));

    // Copy the graphic's data into global memory, and save the handle
    m_pDelayedDataClip = (PWB_GRAPHIC)::GlobalAlloc(GPTR, pHeader->length);
    if (m_pDelayedDataClip != NULL)
    {
        // Copy the graphic data to the allocated memory
        memcpy(m_pDelayedDataClip, pHeader, pHeader->length);
    }

    // Release the graphic's data (now we have our own copy)
    g_pwbCore->WBP_GraphicRelease(m_hPageClip, m_hGraphicClip, pHeader);

    // set the graphic handle to NULL because we won't be using it
    // any more
    m_hPageClip = WB_PAGE_HANDLE_NULL;
    m_hGraphicClip = NULL;
}


//
//
// Function:    FreeDelayedGraphic
//
// Purpose:     Free the copy of the delayed graphic (if any).
//
//
void WbMainWindow::CLP_FreeDelayedGraphic(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_FreeDelayedGraphic");

    if (m_pDelayedGraphicClip != NULL)
    {
        // free the graphic object
        TRACE_MSG(("Freeing delayed graphic"));

        delete m_pDelayedGraphicClip;
        m_pDelayedGraphicClip = NULL;
    }

    if (m_pDelayedDataClip != NULL)
    {
        // free the associated data
        TRACE_MSG(("Freeing delayed memory %x", m_pDelayedDataClip));

        ::GlobalFree((HGLOBAL)m_pDelayedDataClip);
        m_pDelayedDataClip = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\draw.hpp ===
//
// DRAW.HPP
// Drawing Code
//
// Copyright Microsoft 1998-
//


#ifndef __DRAW_HPP_
#define __DRAW_HPP_


//
// Timer for periodic update of some graphic objects
//
#define TIMER_GRAPHIC_UPDATE  2

#define EqualPoint(pt1, pt2)    (((pt1).x == (pt2).x) && ((pt1).y == (pt2).y))


#define DRAW_WIDTH                      1024
#define DRAW_HEIGHT                     768
#define DRAW_LINEVSCROLL                8				
#define DRAW_LINEHSCROLL                8				
#define DRAW_HANDLESIZE                 6				
#define DRAW_ZOOMFACTOR                 2
#define DRAW_REMOTEPOINTERDELAY         250
#define DRAW_GRAPHICUPDATEDELAY         1000

//
//
// Class:   WbDrawingArea
//
// Purpose: drawing window
//
//
class WbDrawingArea
{

  friend class DCWbGraphic;
  friend class DCWbGraphicLine;
  friend class DCWbGraphicFreehand;
  friend class DCWbGraphicRectangle;
  friend class DCWbGraphicFilledRectangle;
  friend class DCWbGraphicEllipse;
  friend class DCWbGraphicFilledEllipse;
  friend class DCWbGraphicSelectTrackingRectangle;
  friend class DCWbGraphicMarker;
  friend class DCWbGraphicText;
  friend class DCWbGraphicDIB;
  friend class WbTextBox;

public:
    //
    // Constructor
    //
    WbDrawingArea(void);
    ~WbDrawingArea(void);

	void ShutDownDC(void);
  
    //
    // Create the drawing area
    //
    BOOL Create(HWND hwndParent, LPCRECT lprect);

    //
    // Return TRUE if the drawing area is busy and may be actively using
    // graphic objects in the current page.
    //
    BOOL IsBusy(void) { return m_bBusy; }

    //
    // Lock and unlock the drawing area
    //
    BOOL IsLocked (void) { return m_bLocked; }
    void Unlock   (void);
    void Lock     (void);

    //
    // Realize the drawing area's palette
    //
    void RealizePalette( BOOL bBackground );//CHANGED BY RAND

    //
    // Selection functions
    //
    void SelectTool(WbTool* pToolNew);  // Select drawing tool

    //
    // Update the selected object
    //
    void SetSelectionColor (COLORREF clr);         // Change color
    void SetSelectionWidth (UINT uiNewWidth);  // Select pen width
    void SetSelectionFont  (HFONT hFont);       // Select font

    //
    // External update functions
    //
    void PageCleared(void);

    void GraphicAdded   (DCWbGraphic* pAddedGraphic);
    void GraphicDeleted (DCWbGraphic* pDeletedGraphic);

	//CHANGED BY RAND
    void GraphicUpdated (DCWbGraphic* pUpdatedGraphic, BOOL bUpdateMarker, BOOL bErase=TRUE );

    void PointerUpdated (DCWbGraphicPointer* pPointer,
                           BOOL bForcedRemove = FALSE);
    void PointerRemoved (DCWbGraphicPointer* pPointer) { PointerUpdated(pPointer, TRUE); }

	void RemoveGraphicPointer(DCWbGraphicPointer *p)
	{
        POSITION pos = m_allPointers.Lookup(p);
        if (pos != NULL)
        {
            m_allPointers.RemoveAt(pos);
        }
	}

    //
    // Query functions
    //
    // Ask whether an object is currently selected
    BOOL GraphicSelected(void);

    // Return the currently selected graphic
    DCWbGraphic* GetSelection(void);

	// Clear current (multi object) selection
	void ClearSelection( void );

	// is pGraphic selected?
    BOOL IsSelected( DCWbGraphic *pGraphic )
		{return(m_pMarker->HasAMarker( pGraphic ) != NULL );}

	DCWbGraphic *GetHitObject( POINT surfacePos )
		{return( PG_SelectLast(m_hPage, surfacePos) );}


    // Ask whether the drawing area is zoomed
    BOOL Zoomed(void) { return (m_iZoomFactor != 1); }

    // Ask whether the drawing area is zoomed
    int ZoomOption(void) { return (m_iZoomOption); }
    int ZoomFactor(void) { return (m_iZoomFactor); }

    // Ask whether the text editor is active
    BOOL TextEditActive(void) { return m_bTextEditorActive; }

	// text editor clipboard
	void   TextEditCopy( void )	{m_textEditor.Copy();}

	void   TextEditCut( void ) 	{m_textEditor.Cut();}

	void   TextEditPaste( void ) {m_textEditor.Paste();}

	// Resets text editor for window resizing
	void TextEditParentResize( void )
		{m_textEditor.ParentResize();}

	// Redraws editbox
	void RedrawTextEditbox(void)
		{m_textEditor.RedrawEditbox();}

	// Gets editbox bounding rect
	void GetTextEditBoundsRect(LPRECT lprc)
		{ m_textEditor.GetBoundsRect(lprc); }

    // Return the rectangle currently being viewed i.e. that portion of
    // the page surface that is within the window client area.
    void    GetVisibleRect(LPRECT lprc);

    // Ask for the current page
    WB_PAGE_HANDLE Page(void) { return(m_hPage);}

	
	// Select objects inside rectSelect or ALL if rect is NULL
	void SelectMarkerFromRect(LPCRECT lprcSelect);
    DCWbGraphicMarker *GetMarker( void )
		{return( m_pMarker );}

    DCWbGraphic* SelectPreviousGraphicAt(DCWbGraphic* pGraphic, POINT point);

	void SetLClickIgnore( BOOL bIgnore )
		{m_bIgnoreNextLClick = bIgnore;}

    //
    // Delete a graphic
    //
    void DeleteGraphic(DCWbGraphic* pGraphic);

    //
    // Action members
    //
    void  Attach(WB_PAGE_HANDLE hPage);    // Attach a new page to the window
    void  Detach(void) { Attach(NULL); }   // Attach the empty page

    void  DeleteSelection(void);           // Delete selected graphic

    void  BringToTopSelection(void);       // Bring selected graphic to top
    void  SendToBackSelection(void);       // Send selected graphic to back

    void  Clear(void);                     // Clear the workspace

    void  Zoom(void);                      // Zoom the drawing area

    void GotoPosition(int x, int y); // Set scroll position

	// select an object
    void SelectGraphic(DCWbGraphic* pGraphic, 
						 BOOL bEnableForceAdd=FALSE, //CHANGED BY RAND
						 BOOL bForceAdd=FALSE );	 //CHANGED BY RAND

    //
    // A freehand graphic has been updated - redraw it
    //
    void GraphicFreehandUpdated(DCWbGraphic* pGraphic);

    //
    // Convert between surface and client co-ordinates
    //
    void SurfaceToClient(LPPOINT lppt);
    void ClientToSurface(LPPOINT lppt);
    void SurfaceToClient(LPRECT lprc);
    void ClientToSurface(LPRECT lprc);
    void MoveOntoSurface(LPPOINT lppt);
    void GetOrigin(LPPOINT lppt);

    HDC  GetCachedDC  (void) const {return(m_hDCCached); }
    void PrimeFont   (HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics);
    void UnPrimeFont (HDC hDC);

    void DrawMarker   (HDC hDC);
    void PutMarker    (HDC hDC, BOOL bDraw = TRUE );
    void RemoveMarker (HDC hDC);

    //
    // Cancel a drawing operation.
    //
    void CancelDrawingMode(void);


	void SetStartPaintGraphic( WB_GRAPHIC_HANDLE hStartPaintGraphic )
		{m_hStartPaintGraphic = PG_ZGreaterGraphic(m_hPage, m_hStartPaintGraphic, hStartPaintGraphic );}


    friend LRESULT CALLBACK DrawWndProc(HWND, UINT, WPARAM, LPARAM);

    //
    // Windows message handling
    //
    void OnPaint(void);
    void OnMouseMove(UINT flags, int x, int y);
    void OnLButtonDown(UINT flags, int x, int y);
    void OnLButtonUp(UINT flags, int x, int y);
    void OnRButtonDown(UINT flags, int x, int y);
    void OnSize(UINT flags, int cx, int cy);
    void OnHScroll(UINT code, UINT pos);
    void OnVScroll(UINT code, UINT pos);
    LRESULT OnEditColor(HDC hdc);
    void OnSetFocus(void);
    void OnActivate(UINT flags);
    LRESULT OnCursor(HWND hwnd, UINT hitTest, UINT msg);
    void OnTimer(UINT idTimer);
    void OnCancelMode(void);
    void OnContextMenu(int xScreen, int yScreen);

protected:
    //
    // Update the window after an object has changed
    //
    void UpdateRectangles(LPCRECT lprc1, LPCRECT lprc2, BOOL bRepaint);

    //
    // Set the cursor to be used in the drawing area for the current state
    //
    BOOL SetCursorForState(void);

    //
    // Add an object to the end of the recorded list and display it in the
    // window.
    //
    void AddObjectLast(DCWbGraphic* pObject);

    //
    // Invalidate the client area rectangle corresponding to the surface
    // rectangle specified.
    //
    void InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase = TRUE);

    //
    // Setup functions for the various drawing operations
    //
    BOOL RemotePointerSelect (POINT mousePos);
    void BeginSelectMode     (POINT mousePos, 
									BOOL bDontDrag=FALSE );
    void BeginDeleteMode     (POINT mousePos);
    void BeginTextMode       (POINT mousePos);
    void BeginFreehandMode   (POINT mousePos);
    void BeginHighlightMode  (POINT mousePos);
    void BeginLineMode       (POINT mousePos);
    void BeginRectangleMode  (POINT mousePos);
    void BeginEllipseMode    (POINT mousePos);

    //
    // Mouse tracking functions. These are called for each mouse move event
    // (depending on the current drawing mode).
    //
    void TrackSelectMode    (POINT mousePos);
    void TrackDeleteMode    (POINT mousePos);
    void TrackFreehandMode  (POINT mousePos);
    void TrackHighlightMode (POINT mousePos);
    void TrackLineMode      (POINT mousePos);
    void TrackRectangleMode (POINT mousePos);
    void TrackEllipseMode   (POINT mousePos);

    //
    // Completion functions for the various mode drawing operations.
    //
    void CompleteSelectMode();
    void CompleteDeleteMode();
    void CompleteMarkAreaMode();
    void CompleteTextMode();
    void CompleteFreehandMode();
    void CompleteLineMode();
    void CompleteRectangleMode();
    void CompleteFilledRectangleMode();
    void CompleteEllipseMode();
    void CompleteFilledEllipseMode();

    //
    // Complete a text object
    //
    void EndTextEntry(BOOL bAccept);

    //
    // Scroll the workspace to scrollPosition
    //
    void ScrollWorkspace   (void);
    void DoScrollWorkspace (void);
    BOOL   AutoScroll(int xPos, int yPos, BOOL bMoveCursor, int xCaret, int yCaret);

    //
    // Graphic object selection and marker manipulation
    //
    void DeselectGraphic(void);

    //
    // Remote pointer manipulation
    //
    void RemovePointers(HDC hDC, DCWbGraphicPointer* pPointerStart = NULL);
    void RemovePointers(HDC hDC, LPCRECT prcUpdate);
    void RemovePointers(HDC hDC, DCWbGraphicPointer* pPointerStart,
                          LPCRECT prcUpdate);

    //
    // Redraw the pointers in the list specified. The pointers are drawn
    // from the start of the list to the end. If a NULL pointer is
    // specified, the undrawnPointers list is used.
    //
    void PutPointers(HDC hDC, COBLIST* pDrawList = NULL);

    void PrimeDC   (HDC hDC);
    void UnPrimeDC (HDC hDC);

    //
    // List of pointers on the page
    // List of pointers that have been (temporarily undrawn). This list is
    // built by RemovePointers for use by PutPointers.
    //
    COBLIST     m_allPointers;
    COBLIST     m_undrawnPointers;

    //
    // Flag indicating that the drawing area is busy or locked
    //
    BOOL        m_bBusy;
    BOOL        m_bLocked;
	BOOL        m_HourGlass; // we're busy doing something local

    //
    // Saved drawing attributes
    //
    HPEN        m_hOldPen;
    HBRUSH      m_hOldBrush;
    HPALETTE    m_hOldPalette;
    HFONT       m_hOldFont;
    HFONT       m_hCurFont;

    //
    // Current offset of the client region of the window onto the picture
    //
    RECT        m_rcSurface;

public:
    SIZE        m_originOffset;
    HWND        m_hwnd;

    //
    // Saved drawing attributes
    //
    HDC         m_hDCCached;
    HDC         m_hDCWindow;

protected:
    //
    // Scrolling control
    //
    void   SetScrollRange(int cx, int cy);
    void   ValidateScrollPos(void);

    POINT   m_posScroll;
    POINT   m_posZoomScroll;
    BOOL    m_zoomRestoreScroll;

    //
    // Start and end points of most recent drawing operation
    //
    POINT   m_ptStart;
    POINT   m_ptEnd;

    //
    // Current drawing tool
    //
    WbTool * m_pToolCur;

    //
    // Mouse button down flag
    //
    BOOL    m_bLButtonDown;

    //
    // Current page being used
    //
    WB_PAGE_HANDLE  m_hPage;

    //
    // Graphics object pointer used for tracking object
    //
    DCWbGraphic* m_pGraphicTracker;

    //
    // Tick count used to determine when it is time to update the external
    // copy of a graphic.
    //
    DWORD   m_dwTickCount;

    //
    // Marker for selection mode
    //
    DCWbGraphicMarker   *m_pMarker;
    DCWbGraphic* m_pSelectedGraphic;
    BOOL m_bMarkerPresent;
    BOOL m_bNewMarkedGraphic;

	BOOL m_bTrackingSelectRect; 

    //
    // Text editor control
    //
    WbTextEditor m_textEditor;
    BOOL        m_bTextEditorActive;
    DCWbGraphicText* m_pActiveText;

    void ActivateTextEditor( BOOL bPutUpCusor ); 
    void DeactivateTextEditor(void);

    //
    // Text cursor control
    //
    BOOL        m_bGotCaret;

    //
    // Currently marked area
    //
    RECT    m_rcMarkedArea;

    //
    // Zoom variables
    //
    int     m_iZoomFactor;                   // Current zoom factor
    int     m_iZoomOption;                   // Zoom factor to be used


    HCURSOR m_hCursor;                    // handle of last cursor we displayed
                                        // (or null if normal arrow cursor)
	BOOL    m_bIgnoreNextLClick;

	WB_GRAPHIC_HANDLE m_hStartPaintGraphic;
};


#endif // __DRAW_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\grobj.cpp ===
//
// GROBJ.CPP
// Graphic Objects
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"

#define DECIMAL_PRECISION  10000

//
// Local macros
//
#define min4(x1,x2,x3,x4) min((min((x1),(x2))),(min((x3),(x4))))
#define max4(x1,x2,x3,x4) max((max((x1),(x2))),(max((x3),(x4))))



//
// CircleHit()
//
// Checks for overlap between circle at PcxPcy with uRadius and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL CircleHit( LONG Pcx, LONG Pcy, UINT uRadius, LPCRECT lpHitRect,
					BOOL bCheckPt )
{
	RECT hr = *lpHitRect;
	RECT ellipse;
	ellipse.left = Pcx - uRadius;
	ellipse.right= Pcx + uRadius;
	ellipse.bottom = Pcy + uRadius;
	ellipse.top = Pcy - uRadius;


	// check the easy thing first (don't use PtInRect)
	if( bCheckPt &&(lpHitRect->left >= ellipse.left)&&(ellipse.right >= lpHitRect->right)&&
				   (lpHitRect->top >= ellipse.top)&&(ellipse.bottom >= lpHitRect->bottom))
	{
		return( TRUE );
	}

	//
	// The circle is just a boring ellipse
	//
	return EllipseHit(&ellipse, bCheckPt,  uRadius, lpHitRect );
}




//
// EllipseHit()
//
// Checks for overlap between ellipse defined by lpEllipseRect and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth,
					 LPCRECT lpHitRect )
{
	RECT hr = *lpHitRect;

	// Check easy thing first. If lpEllipseRect is inside lpHitRect
	// then we have a hit (no duh...)
	if( (hr.left <= lpEllipseRect->left)&&(hr.right >= lpEllipseRect->right)&&
		(hr.top <= lpEllipseRect->top)&&(hr.bottom >= lpEllipseRect->bottom) )
		return( TRUE );

	// If this is an ellipse....
	//
	//		*  *         ^
	//	 *     | b       | Y
	// *       |    a    +-------> X
	// *-------+--------
	//         |
	//
		
	
	//
	// Look for the ellipse hit. (x/a)^2 + (y/b)^2 = 1
	// If it is > 1 than the point is outside the ellipse
	// If it is < 1 it is inside
	//
	LONG a,b,aOuter, bOuter, x, y, xCenter, yCenter;
	BOOL bInsideOuter = FALSE;
	BOOL bOutsideInner = FALSE;

	//
	// Calculate a and b
	//
	a = (lpEllipseRect->right - lpEllipseRect->left)/2;
	b = (lpEllipseRect->bottom - lpEllipseRect->top)/2;

	//
	// Get the center of the ellipse
	//
	xCenter = lpEllipseRect->left + a;
	yCenter = lpEllipseRect->top + b;

	//
	// a and b generates a inner ellipse
	// aOuter and bOuter generates a outer ellipse
	//
	aOuter = a + uPenWidth + 1;
	bOuter = b + uPenWidth + 1;
	a = a - 1;
	b = b - 1;

	//
	// Make our coordinates relative to the center of the ellipse
	//
	y = abs(hr.bottom - yCenter);
	x = abs(hr.right - xCenter);

	
	//
	// Be carefull not to divide by 0
	//
	if((a && b && aOuter && bOuter) == 0)
	{
		return FALSE;
	}

	//
	// We are using LONG instead of double and we need to have some precision
	// that is why we multiply the equation of the ellipse
	// ((x/a)^2 + (y/b)^2 = 1) by DECIMAL_PRECISION
	// Note that the multiplication has to be done before the division, if we didn't do that
	// we will always get 0 or 1 for x/a
	//
	if(x*x*DECIMAL_PRECISION/(aOuter*aOuter) + y*y*DECIMAL_PRECISION/(bOuter*bOuter) <= DECIMAL_PRECISION)
	{
		bInsideOuter = TRUE;
	}

	if(x*x*DECIMAL_PRECISION/(a*a)+ y*y*DECIMAL_PRECISION/(b*b) >= DECIMAL_PRECISION)
	{
		bOutsideInner = TRUE;
	}
	
	//
	// If we are checking for border hit,
	// we need to be inside the outer ellipse and inside the inner
	//
	if( bBorderHit )
	{
			return( bInsideOuter & bOutsideInner );
	}
	// just need to be inside the outer ellipse
	else
	{
		return( bInsideOuter );
	}

}
//
// LineHit()
//
// Checks for overlap (a "hit") between lpHitRect and the line
// P1P2 accounting for line width. If bCheckP1End or bCheckP2End is
// TRUE then a circle of radius 0.5 * uPenWidth is also checked for
// a hit to account for the rounded ends of wide lines.
//
// If a hit is found TRUE is returned, otherwise FALSE.
//
BOOL LineHit( LONG P1x, LONG P1y, LONG P2x, LONG P2y, UINT uPenWidth,
				  BOOL bCheckP1End, BOOL bCheckP2End,
				  LPCRECT lpHitRect )
{

	LONG uHalfPenWidth = uPenWidth/2;

	LONG a,b,x,y;

	x = lpHitRect->left + (lpHitRect->right - lpHitRect->left)/2;
	y = lpHitRect->bottom + (lpHitRect->top - lpHitRect->bottom)/2;


	if( (P1x == P2x)&&(P1y == P2y) )
	{
		// just check one end point's circle
		return( CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, TRUE ) );
	}

	// check rounded end at P1
	if( bCheckP1End && CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );

	// check rounded end at P2
	if( bCheckP2End && CircleHit( P2x, P2y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );
	
	//
	// The function of a line is Y = a.X + b
	//
	// a = (Y1-Y2)/(X1 -X2)
	// if we found a we get b = y1 -a.X1
	//

	if(P1x == P2x)
	{
		a=0;
		b = DECIMAL_PRECISION*P1x;

	}
	else
	{
		a = (P1y - P2y)*DECIMAL_PRECISION/(P1x - P2x);
		b = DECIMAL_PRECISION*P1y - a*P1x;
	}


	//
	// Paralel to Y
	//
	if(P1x == P2x && ((x >= P1x - uHalfPenWidth) && x <= P1x + uHalfPenWidth))
	{
		return TRUE;
	}

	//
	// Paralel to X
	//
	if(P1y == P2y && ((y >= P1y - uHalfPenWidth) && y <= P1y + uHalfPenWidth))
	{
		return TRUE;
	}

	//
	// General line
	//

	return(( y*DECIMAL_PRECISION <= a*x + b + DECIMAL_PRECISION*uHalfPenWidth) &
			( y*DECIMAL_PRECISION >= a*x + b - DECIMAL_PRECISION*uHalfPenWidth));
}


//
//
// Function:    ConstructGraphic
//
// Purpose:     Construct a graphic from a page and handle
//
//
DCWbGraphic* DCWbGraphic::ConstructGraphic(WB_PAGE_HANDLE hPage,
                                           WB_GRAPHIC_HANDLE hGraphic)
{
    PWB_GRAPHIC  pHeader;
    DCWbGraphic* pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ConstructGraphic(page, handle)");

        // Get a pointer to the external graphic data
        // (Throws an exception if any errors occur)
        pHeader = PG_GetData(hPage, hGraphic);

        // Construct the graphic
        pGraphic = DCWbGraphic::ConstructGraphic(pHeader);

        // If we got the graphic, set its page and handle
        if (pGraphic != NULL)
        {
            pGraphic->m_hPage    = hPage;
            pGraphic->m_hGraphic = hGraphic;
        }

        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pHeader);

    return pGraphic;
}


DCWbGraphic* DCWbGraphic::ConstructGraphic(WB_PAGE_HANDLE hPage,
										   WB_GRAPHIC_HANDLE hGraphic,
										   PWB_GRAPHIC pHeader)
{
    DCWbGraphic* pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ConstructGraphic(page, pHeader)");

        pGraphic = DCWbGraphic::ConstructGraphic(pHeader);

        // If we got the graphic, set its page and handle
        if (pGraphic != NULL)
        {
            pGraphic->m_hPage    = hPage;
            pGraphic->m_hGraphic = hGraphic;
        }
    return pGraphic;
}


DCWbGraphic* DCWbGraphic::ConstructGraphic(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ConstructGraphic(data)");

    TRACE_DEBUG(("Constructing graphic of type %hd", pHeader->type));
    TRACE_DEBUG(("Length of graphic = %ld", pHeader->length));
    TRACE_DEBUG(("Data offset = %hd", pHeader->dataOffset));

    // Construct the internal representation of the graphic
    DCWbGraphic* pGraphic = NULL;

    if (pHeader == NULL)
    {
	    return NULL;
    }

    switch (pHeader->type)
    {
        case TYPE_GRAPHIC_LINE:
            pGraphic = new DCWbGraphicLine(pHeader);
            break;

        case TYPE_GRAPHIC_FREEHAND:
            pGraphic = new DCWbGraphicFreehand(pHeader);
            break;

        case TYPE_GRAPHIC_RECTANGLE:
            pGraphic = new DCWbGraphicRectangle(pHeader);
            break;

        case TYPE_GRAPHIC_FILLED_RECTANGLE:
            pGraphic = new DCWbGraphicFilledRectangle(pHeader);
            break;

        case TYPE_GRAPHIC_ELLIPSE:
            pGraphic = new DCWbGraphicEllipse(pHeader);
            break;

        case TYPE_GRAPHIC_FILLED_ELLIPSE:
            pGraphic = new DCWbGraphicFilledEllipse(pHeader);
            break;

        case TYPE_GRAPHIC_TEXT:
            pGraphic = new DCWbGraphicText(pHeader);
            break;

        case TYPE_GRAPHIC_DIB:
            pGraphic = new DCWbGraphicDIB(pHeader);
            break;

        default:
            // Do nothing, the object pointer is already set to NULL
            break;
    }

    if (!pGraphic)
    {
        ERROR_OUT(("ConstructGraphic failing; can't allocate object of type %d",
            pHeader->type));
    }

    return pGraphic;
}

//
//
// Function:    CopyGraphic
//
// Purpose:     Construct a graphic from a pointer. This function makes a
//              complete internal copy of the graphic data.
//
//
DCWbGraphic* DCWbGraphic::CopyGraphic(PWB_GRAPHIC pHeader)
{
  MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::CopyGraphic(PWB_GRAPHIC)");

  // Construct the graphic
  DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(pHeader);

  // Copy the extra data
  if (pGraphic != NULL)
  {
    pGraphic->CopyExtra(pHeader);
  }

  return pGraphic;
}

//
//
// Function:    DCWbGraphic constructor
//
// Purpose:     Construct a new graphic object.
//
//

DCWbGraphic::DCWbGraphic(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::DCWbGraphic");

    // Do basic initialization
    Initialize();

    // Convert the external data header to the internal member variables
    if (pHeader != NULL)
    {
        ReadHeader(pHeader);

        // Convert the extra data for the specific object
        // (not all objects have extra data).
        ReadExtra(pHeader);
    }
}

DCWbGraphic::DCWbGraphic(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::DCWbGraphic");

    // Do the basic initialization
    Initialize();

    ASSERT(hPage != WB_PAGE_HANDLE_NULL);
    m_hPage = hPage;

    ASSERT(hGraphic != NULL);
    m_hGraphic = hGraphic;

    // Read the header data
    ReadExternal();
}



DCWbGraphic::~DCWbGraphic( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}


//
//
// Function:    DCWbGraphic::ReadExternal
//
// Purpose:     Read the graphic data from an externally stored graphic.
//              The external graphic to be used is specified by the
//              hGraphic member.
//
//
void DCWbGraphic::ReadExternal(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ReadExternal");

    ASSERT(m_hPage != WB_PAGE_HANDLE_NULL);
    ASSERT(m_hGraphic != NULL);

    // Lock the object data in the page
    PWB_GRAPHIC pHeader = PG_GetData(m_hPage, m_hGraphic);

    // Convert the external data header to the internal member variables
    ReadHeader(pHeader);

    // Convert the extra data for the specific object
    // (not all objects have extra data).
    ReadExtra(pHeader);

    // Release the data in the page
    g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, pHeader);

    // Show that we are no longer changed since last read/write
    m_bChanged = FALSE;
}

//
//
// Function:    DCWbGraphic::ReadHeader
//
// Purpose:     Convert the external representation of the graphic's header
//              to the internal format.
//
//
void DCWbGraphic::ReadHeader(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ReadHeader");

    // Get the length of the object
    m_dwExternalLength = pHeader->length;

    // Convert the external data header to the internal member variables
    // Bounding rectangle
    m_boundsRect.left   = pHeader->rectBounds.left;
    m_boundsRect.top    = pHeader->rectBounds.top;
    m_boundsRect.right  = pHeader->rectBounds.right;
    m_boundsRect.bottom = pHeader->rectBounds.bottom;

    // Defining rectangle
    m_rect.left   = pHeader->rect.left;
    m_rect.top    = pHeader->rect.top;
    m_rect.right  = pHeader->rect.right;
    m_rect.bottom = pHeader->rect.bottom;

    // Pen color
    m_clrPenColor = RGB(pHeader->color.red,
                    pHeader->color.green,
                    pHeader->color.blue);
    m_clrPenColor = SET_PALETTERGB( m_clrPenColor ); // make it do color matching

    // Pen width
    m_uiPenWidth = pHeader->penWidth;

    // Pen style
    m_iPenStyle = pHeader->penStyle;

    // Raster operation
    m_iPenROP = pHeader->rasterOp;

    // Get the lock indication
    m_uiLockState = pHeader->locked;

    // Get the drawing tool type
    if (pHeader->toolType == WBTOOL_TEXT)
        m_toolType = TOOLTYPE_TEXT;
    else
        m_toolType = TOOLTYPE_PEN;
}

//
//
// Function:    DCWbGraphic::WriteExternal
//
// Purpose:     Write the graphic's details to a flat WB_GRAPHIC structure
//
//
void DCWbGraphic::WriteExternal(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::WriteExternal");

    // Write the header
    WriteHeader(pHeader);

    // Write the extra data
    WriteExtra(pHeader);
}

//
//
// Function:    DCWbGraphic::WriteHeader
//
// Purpose:     Write the graphic's header details to a flat WB_GRAPHIC
//              structure.
//
//
void DCWbGraphic::WriteHeader(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::WriteHeader");

    // Convert the internal data to the external header format

    // Init struct
    FillMemory(pHeader, sizeof (WB_GRAPHIC), 0 );

    // Calculate the external length
    pHeader->length = CalculateExternalLength();

    // Set the type of graphic
    pHeader->type = (TSHR_UINT16)Type();

    // Assume that there is no extra data
    pHeader->dataOffset = sizeof(WB_GRAPHIC);

    // Bounding rectangle
    pHeader->rectBounds.left   = (short)m_boundsRect.left;	
    pHeader->rectBounds.top    = (short)m_boundsRect.top;	
    pHeader->rectBounds.right  = (short)m_boundsRect.right;	
    pHeader->rectBounds.bottom = (short)m_boundsRect.bottom;

    // Defining rectangle
    pHeader->rect.left   = (short)m_rect.left;	
    pHeader->rect.top    = (short)m_rect.top;	
    pHeader->rect.right  = (short)m_rect.right;	
    pHeader->rect.bottom = (short)m_rect.bottom;

    // Pen color
    pHeader->color.red   = GetRValue(m_clrPenColor);
    pHeader->color.green = GetGValue(m_clrPenColor);
    pHeader->color.blue  = GetBValue(m_clrPenColor);

    // Pen width
    pHeader->penWidth = (TSHR_UINT16)m_uiPenWidth;

    // Pen style
    pHeader->penStyle = (TSHR_UINT16)m_iPenStyle;

    // Raster operation
    pHeader->rasterOp = (TSHR_UINT16)m_iPenROP;

    // Set the lock indicator
    pHeader->locked = (BYTE) m_uiLockState;

    // Set the drawing method
    pHeader->smoothed = FALSE;

    // Set the drawing tool type
    if (m_toolType == TOOLTYPE_TEXT)
        pHeader->toolType = WBTOOL_TEXT;
    else
        pHeader->toolType = WBTOOL_PEN;
}

//
//
// Function:    Initialize
//
// Purpose:     Initialize the member variables
//
//
void DCWbGraphic::Initialize(void)
{
    m_hPage     = WB_PAGE_HANDLE_NULL;
    m_hGraphic  = NULL;

    m_bChanged = TRUE;

    m_uiLockState = WB_GRAPHIC_LOCK_NONE;

    //
    // Set default graphic attributes
    //
    ::SetRectEmpty(&m_boundsRect);
    ::SetRectEmpty(&m_rect);
    m_clrPenColor = RGB(0, 0, 0);           // Black pen color
    m_uiPenWidth = 1;                       // One unit width
    m_iPenROP = R2_COPYPEN;                 // Standard drawing ROP
    m_iPenStyle = PS_INSIDEFRAME;           // Solid pen to be used
    m_toolType = TOOLTYPE_PEN;
}

//
//
// Function:    Copy
//
// Purpose:     Return a copy of the graphic. The graphic returned has all
//              its data read into local memory. The returned graphic has
//              the same page as the copied graphic, but a NULL handle.
//
//
DCWbGraphic* DCWbGraphic::Copy(void) const
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Copy");

    // Get a pointer to the external graphic data
    // (Throws an exception if any errors occur)
    PWB_GRAPHIC  pHeader = PG_GetData(m_hPage, m_hGraphic);

    // Construct the graphic
    DCWbGraphic* pGraphic = DCWbGraphic::CopyGraphic(pHeader);

    // If we got the graphic, set its page and handle
    if (pGraphic != NULL)
    {
        pGraphic->m_hPage       = m_hPage;
        pGraphic->m_hGraphic    = NULL;
    }

    // Release the data
    g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, pHeader);

    return pGraphic;
}

//
//
// Function:    DCWbGraphic::SetBoundsRect
//
// Purpose:     Set the bounding rectangle of the object
//
//
void DCWbGraphic::SetBoundsRect(LPCRECT lprc)
{
    m_boundsRect = *lprc;
}

//
//
// Function:    DCWbGraphic::SetRect
//
// Purpose:     Set the defining rectangle of the object
//
//
void DCWbGraphic::SetRect(LPCRECT lprc)
{
    m_rect = *lprc;

    NormalizeRect(&m_rect);

    // Show that we have been changed
    m_bChanged = TRUE;
}


void DCWbGraphic::SetRectPts(POINT point1, POINT point2)
{
    RECT    rc;

    rc.left = point1.x;
    rc.top  = point1.y;
    rc.right = point2.x;
    rc.bottom = point2.y;

    SetRect(&rc);
}


//
//
// Function:    DCWbGraphic::PointInBounds
//
// Purpose:     Return TRUE if the specified point lies in the bounding
//              rectangle of the graphic object.
//
//
BOOL DCWbGraphic::PointInBounds(POINT point)
{
    return(::PtInRect(&m_boundsRect, point));
}

//
//
// Function:    DCWbGraphic::MoveBy
//
// Purpose:     Translate the object by the offset specified
//
//
void DCWbGraphic::MoveBy(int cx, int cy)
{
    // Move the bounding rectangle
    ::OffsetRect(&m_boundsRect, cx, cy);

    // Show that we have been changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphic::MoveTo
//
// Purpose:     Move the object to an absolute position
//
//
void DCWbGraphic::MoveTo(int x, int y)
{
    // Calculate the offset needed to translate the object from its current
    // position to the required position.
    x -= m_boundsRect.left;
    y -= m_boundsRect.top;

    MoveBy(x, y);
}

//
//
// Function:    DCWbGraphic::GetPosition
//
// Purpose:     Return the top left corner of the object's bounding
//              rectangle
//
//
void DCWbGraphic::GetPosition(LPPOINT lppt)
{
    lppt->x = m_boundsRect.left;
    lppt->y = m_boundsRect.top;
}

//
//
// Function:    DCWbGraphic::NormalizeRect
//
// Purpose:     Normalize a rectangle ensuring that the top left is above
//              and to the left of the bottom right.
//
//
void DCWbGraphic::NormalizeRect(LPRECT lprc)
{
    int tmp;

    if (lprc->right < lprc->left)
    {
        tmp = lprc->left;
        lprc->left = lprc->right;
        lprc->right = tmp;
    }

    if (lprc->bottom < lprc->top)
    {
        tmp = lprc->top;
        lprc->top = lprc->bottom;
        lprc->bottom = tmp;
    }
}

//
//
// Function:    DCWbGraphic::SetColor
//
// Purpose:     Set the object color.
//
//
void DCWbGraphic::SetColor(COLORREF color)
{
    color = SET_PALETTERGB( color ); // make it use color matching

    if (m_clrPenColor != color)
    {
        // Save the new color
        m_clrPenColor = color;

        // Show that we have been changed
        m_bChanged = TRUE;
    }
}

//
//
// Function:    DCWbGraphic::SetROP
//
// Purpose:     Set the object raster operation
//
//
void DCWbGraphic::SetROP(int iPenROP)
{
    // If the new ROP is different
    if (m_iPenROP != iPenROP)
    {
        // Save the new ROP
        m_iPenROP = iPenROP;

        // Show that we have been changed
        m_bChanged = TRUE;
    }
}

//
//
// Function:    DCWbGraphic::SetPenStyle
//
// Purpose:     Set the object pen style
//
//
void DCWbGraphic::SetPenStyle(int iPenStyle)
{
    // If the new style is different
    if (m_iPenStyle != iPenStyle)
    {
        // Save the new pen style
        m_iPenStyle = iPenStyle;

        // Show that the graphic has been changed
        m_bChanged = TRUE;
    }
}


//
//
// Function:    DCWbGraphic::SetPenWidth
//
// Purpose:     Set the pen width for the object.
//
//
void DCWbGraphic::SetPenWidth(UINT uiWidth)
{
    // If the new width is different
    if (m_uiPenWidth != uiWidth)
    {
        // Save the width given
        m_uiPenWidth = uiWidth;

        // Update the bounding rectangle
        CalculateBoundsRect();

        // Show that we have been changed
        m_bChanged = TRUE;
    }
}


//
//
// Function:    IsTopmost
//
// Purpose:     Return TRUE if this graphic is topmost on its page
//
//
BOOL DCWbGraphic::IsTopmost(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::IsTopmost");
    ASSERT(m_hGraphic != NULL);

    return PG_IsTopmost(m_hPage, this);
}

//
//
// Function:    AddToPageLast
//
// Purpose:     Add the graphic to the specified page
//
//
void DCWbGraphic::AddToPageLast(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::AddToPageLast");
    ASSERT(m_hGraphic == NULL);

  // Get the length of the flat representation
  DWORD length = CalculateExternalLength();

  // Allocate memory for the graphic
  PWB_GRAPHIC pHeader = PG_AllocateGraphic(hPage, length);

  if(pHeader == NULL)
  {
	return;
  }

  // Write the graphic details to the memory
  WriteExternal(pHeader);

    // Add the flat representation to the page
    WB_GRAPHIC_HANDLE hGraphic = NULL;
    UINT uiReturn;

    uiReturn = g_pwbCore->WBP_GraphicAddLast(hPage, pHeader, &hGraphic);
    if (uiReturn != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }

    // Show that we have not changed since the last write
    m_bChanged = FALSE;

    // Save the page to which this graphic now belongs
    m_hPage     = hPage;
    m_hGraphic  = hGraphic;
}

//
//
// Function:    ForceReplace
//
// Purpose:     Write the object to external storage, replacing what is
//              already there, even if the object hasn't changed.
//
//
void DCWbGraphic::ForceReplace(void)
	{
	if( Type() != 0 )
		{
		m_bChanged = TRUE;
		this->Replace();
		}
	}

//
//
// Function:    Replace
//
// Purpose:     Write the object to external storage, replacing what is
//              already there.
//
//
void DCWbGraphic::Replace(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Replace");
    ASSERT(m_hGraphic != NULL);

  // Only do the replace if we have been changed
  if (m_bChanged == TRUE)
  {
    TRACE_MSG(("Replacing the graphic in the page"));
    // Get the length of the flat representation
    DWORD length = CalculateExternalLength();

    // Allocate memory for the graphic
    PWB_GRAPHIC pHeader = PG_AllocateGraphic(m_hPage, length);
	
	if(pHeader == NULL)
	{
		return;
	}

    // Write the graphic details to the memory
    WriteExternal(pHeader);

    // Replace the graphic
    PG_GraphicReplace(m_hPage, &m_hGraphic, pHeader);

    // Show that we have not changed since the last update
    m_bChanged = FALSE;
  }
}

//
//
// Function:    ReplaceConfirm
//
// Purpose:     Confirm the replace of the graphic
//
//
void DCWbGraphic::ReplaceConfirm(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ReplaceConfirm");
    ASSERT(m_hGraphic != NULL);

    // Confirm the update
    g_pwbCore->WBP_GraphicReplaceConfirm(m_hPage, m_hGraphic);

    // Read the new details
    ReadExternal();
}




void DCWbGraphic::ForceUpdate(void)
{
	if ((Type() != 0) && m_hGraphic)
	{
		m_bChanged = TRUE;
		this->Update();
	}
}





//
//
// Function:    Update
//
// Purpose:     Write the header of the graphic to external storage
//
//
void DCWbGraphic::Update(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Update");

    ASSERT(m_hGraphic != NULL);

    // Only make the update if the graphic has changed
    if (m_bChanged)
    {
        // Allocate memory for the update graphic
        TRACE_MSG(("Graphic has changed"));
        DWORD length = sizeof(WB_GRAPHIC);
        PWB_GRAPHIC pHeader;

        if( (pHeader = PG_AllocateGraphic(m_hPage, length)) != NULL )
		{
		    // Write the header details to the allocated memory
    		pHeader->type = (TSHR_UINT16)Type();
	    	WriteHeader(pHeader);

		    // Update the header in the page
    		PG_GraphicUpdate(m_hPage, &m_hGraphic, pHeader);
		}

        // Show that we have not changed since the last update
        m_bChanged = FALSE;
    }
}

//
//
// Function:    UpdateConfirm
//
// Purpose:     Confirm the update of the graphic
//
//
void DCWbGraphic::UpdateConfirm(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::UpdateConfirm");
    ASSERT(m_hGraphic != NULL);

    // Confirm the update
    g_pwbCore->WBP_GraphicUpdateConfirm(m_hPage, m_hGraphic);

    // Read the new details
    ReadExternal();
}

//
//
// Function:    Delete
//
// Purpose:     Remove the graphic from its page
//
//
void DCWbGraphic::Delete(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Delete");

    ASSERT(m_hPage != WB_PAGE_HANDLE_NULL);
    ASSERT(m_hGraphic != NULL);

    // Delete the graphic
    PG_GraphicDelete(m_hPage, *this);

    // Reset the handles for this graphic - it is now deleted
    m_hPage     = WB_PAGE_HANDLE_NULL;
    m_hGraphic = NULL;

    // Show that we have changed (an add is required to save the graphic)
    m_bChanged = TRUE;
}

//
//
// Function:    DeleteConfirm
//
// Purpose:     Confirm the delete of the graphic
//
//
void DCWbGraphic::DeleteConfirm(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::DeleteConfirm");
    ASSERT(m_hGraphic != NULL);

    // Confirm the update
    g_pwbCore->WBP_GraphicDeleteConfirm(m_hPage, m_hGraphic);

    // Reset the graphic page and handle (they are no longer useful)
    m_hPage = WB_PAGE_HANDLE_NULL;
    m_hGraphic = NULL;
}

//
//
// Function:    Lock
//
// Purpose:     Lock the graphic
//
//
void DCWbGraphic::Lock(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Lock");

	// If we are not already locked
	if( Type() != 0 )
		{
		if (m_uiLockState == WB_GRAPHIC_LOCK_NONE)
			{
			m_bChanged = TRUE;
			m_uiLockState = WB_GRAPHIC_LOCK_LOCAL;
			}
		}
	}

//
//
// Function:    Unlock
//
// Purpose:     Unlock the graphic
//
//
void DCWbGraphic::Unlock(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Unlock");

	// If we are currently locked
	if( Type() != 0 )
		{
		if (m_uiLockState == WB_GRAPHIC_LOCK_LOCAL)
			{
			// Lock & release
			PWB_GRAPHIC pHeader = PG_GetData(m_hPage, m_hGraphic);
			g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, pHeader);

			m_uiLockState = WB_GRAPHIC_LOCK_NONE;
            g_pwbCore->WBP_GraphicUnlock(m_hPage, m_hGraphic);
			}
		}
	}

//
//
// Function:    DCWbGraphicMarker::DCWbGraphicMarker
//
// Purpose:     Constructors for marker objects
//
//
DCWbGraphicMarker::DCWbGraphicMarker()
{
    HBITMAP hBmpMarker;
    // Set up a checked pattern to draw the marker rect with
    WORD    bits[] = {204, 204, 51, 51, 204, 204, 51, 51};

    // Create the brush to be used to draw the marker rectangle
    hBmpMarker = ::CreateBitmap(8, 8, 1, 1, bits);
    m_hMarkerBrush = ::CreatePatternBrush(hBmpMarker);
    ::DeleteBitmap(hBmpMarker);

    MarkerList.EmptyList();
    ::SetRectEmpty(&m_rect);
    m_bMarkerPresent = FALSE;
}



DCWbGraphicMarker::~DCWbGraphicMarker()
{
    if (m_hMarkerBrush != NULL)
    {
        DeleteBrush(m_hMarkerBrush);
        m_hMarkerBrush = NULL;
    }
}


//
//
// Function:    DCWbGraphicMarker::SetRect
//
// Purpose:     Set the rectangle for the object
//
//
BOOL DCWbGraphicMarker::SetRect(LPCRECT lprc,
							  DCWbGraphic *pGraphic,
							  BOOL bRedraw,
							  BOOL bLockObject )
{
	DCWbGraphic *pMarker;
	BOOL bGraphicAdded = FALSE;
    LPRECT  pmMarker;

	// Save the new rectangle
    m_rect = *lprc;
	NormalizeRect(&m_rect);

	// Calculate the new bounding rectangle of the entire marker
	CalculateBoundsRect();

	// Calculate the marker rectangles
	CalculateMarkerRectangles();

    if( (pMarker = HasAMarker( pGraphic )) != NULL )
        delete pMarker;

    // allow select only if object is not locked - bug 2185
    if( !pGraphic->Locked())
    {
    	// add/replace pGraphic|markerrect pair to list
        pmMarker = new RECT;
        if (!pmMarker)
        {
            ERROR_OUT(("Failed to create RECT object"));
        }
        else
        {
            *pmMarker = m_markerRect;

            MarkerList.SetAt( (void *)pGraphic, pmMarker);

            ASSERT(g_pDraw);
            DrawRect(g_pDraw->GetCachedDC(), pmMarker, FALSE, NULL );
            bGraphicAdded = TRUE;
        }

        if( bLockObject )
        {
		    // lock the object if we don't already have it locked
            // to keep anybody else from selecting it
            if( !pGraphic->GotLock() )
            {
					pGraphic->Lock();
					if( pGraphic->Handle() != NULL )
						pGraphic->ForceUpdate(); // if valid object force lock NOW
			}
		}
	}

	if( bRedraw &&  m_bMarkerPresent )
    {
        ASSERT(g_pDraw);
		::UpdateWindow(g_pDraw->m_hwnd);
    }

	// set m_boundsRect to real bounds
    GetBoundsRect(&m_boundsRect);

	return( bGraphicAdded );
}

//
//
// Function:    DCWbGraphicMarker::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicMarker::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    m_boundsRect = m_rect;
    NormalizeRect(&m_boundsRect);

    ::InflateRect(&m_boundsRect, m_uiPenWidth, m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicMarker::CalculateMarkerRectangles
//
// Purpose:     Calculate the rectangles for the marker handles
//
//
void DCWbGraphicMarker::CalculateMarkerRectangles(void)
{
    m_markerRect = m_boundsRect;
    ::InflateRect(&m_markerRect, 1-m_uiPenWidth, 1-m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicMarker::PointInMarker
//
// Purpose:     Calculate whether the given point is in one of the marker
//              rectangles.
//
//
int DCWbGraphicMarker::PointInMarker(POINT point)
{
    return(NO_HANDLE);
}



void DCWbGraphicMarker::DrawRect
(
    HDC             hDC,
    LPCRECT         pMarkerRect,
    BOOL            bDrawObject,
    DCWbGraphic *   pGraphic
)
{
	int			 nOldROP;
	COLORREF	 crOldTextColor;
	COLORREF	 crOldBkColor;

	nOldROP = ::SetROP2(hDC, R2_COPYPEN);
	crOldTextColor = ::SetTextColor(hDC, RGB(0, 0, 0));

    ASSERT(g_pDraw);
	crOldBkColor = ::SetBkColor(hDC, ::GetSysColor(COLOR_WINDOW));

	if (pMarkerRect != NULL)
    {
		if( bDrawObject )
			pGraphic->Draw(hDC ); // draw object instead of rect
		else
			::FrameRect(hDC, pMarkerRect, m_hMarkerBrush); // draw rect
	}

	::SetROP2(hDC, nOldROP);
	::SetTextColor(hDC, crOldTextColor);
	::SetBkColor(hDC, crOldBkColor);
}


//
//
// Function:    DCWbGraphicMarker::Draw
//
// Purpose:     Draw the marker object
//
//
void DCWbGraphicMarker::Draw(HDC hDC, BOOL bDrawObjects)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
    LPRECT       pMarkerRect;

	// if marker is not up, do nuthin
	if( !m_bMarkerPresent )
		return;

	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
	{
		MarkerList.GetNextAssoc( posNext, (void *&)pGraphic, (void *&)pMarkerRect );
		DrawRect(hDC, pMarkerRect, bDrawObjects, pGraphic );
	}
}


void DCWbGraphicMarker::UndrawRect
(
    HDC     hDC,
    WbDrawingArea * pDrawingArea,
    LPCRECT pMarkerRect
)
{
	int			 nOldROP;
	COLORREF	 crOldTextColor;
	COLORREF	 crOldBkColor;

	if (pMarkerRect != NULL)
	{
		// set up context to erase marker rect
		nOldROP = ::SetROP2(hDC, R2_COPYPEN);

        ASSERT(g_pDraw);
		crOldTextColor = ::SetTextColor(hDC, ::GetSysColor(COLOR_WINDOW));
		crOldBkColor = ::SetBkColor(hDC, ::GetSysColor(COLOR_WINDOW));

		::FrameRect(hDC, pMarkerRect, m_hMarkerBrush);
		UndrawMarker( pMarkerRect ); // invalidate so underlying objects will repair window

		::SetROP2(hDC, nOldROP);
		::SetTextColor(hDC, crOldTextColor);
		::SetBkColor(hDC, crOldBkColor);
	}
}




//
//
// Function:    DCWbGraphicMarker::Undraw
//
// Purpose:     Undraw the marker object
//
//
void DCWbGraphicMarker::Undraw(HDC hDC, WbDrawingArea * pDrawingArea)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
    LPRECT      pMarkerRect;

	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
	{
		MarkerList.GetNextAssoc( posNext, (void *&)pGraphic, (void *&)pMarkerRect );
		UndrawRect(hDC, pDrawingArea, pMarkerRect);
	}
}






void DCWbGraphicMarker::DeleteAllMarkers( DCWbGraphic *pLastSelectedGraphic,
										  BOOL bLockLastSelectedGraphic )
	{
	POSITION	 posFirst;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
	BOOL		 bAddLastBack = FALSE;

	if( MarkerList.IsEmpty() )
		return; // nuthin to do

	// let each object clean itself up
	posFirst = MarkerList.GetHeadPosition();
	while( posFirst != NULL )
		{
		MarkerList.GetNextAssoc( posFirst,
								(void *&)pGraphic, (void *&)pMarkerRect );

		if( pGraphic != NULL )
			{
  			if( pGraphic == pLastSelectedGraphic )
				{
				// have to put this one back since somebody up there needs it
				bAddLastBack = TRUE;

				// delete key but don't delete object
				DeleteMarker( pGraphic );
				}
			else
				{
				// obj will call DeleteMarker()
				delete pGraphic;
				}
			}
		else
			{
			// nobody home, remove key ourselves
			DeleteMarker( pGraphic );
			}
		}

	// put last selected object back if needed
	if( bAddLastBack && (pLastSelectedGraphic != NULL) )
    {
        RECT    rcT;

        pLastSelectedGraphic->GetBoundsRect(&rcT);
		SetRect(&rcT, pLastSelectedGraphic, FALSE, bLockLastSelectedGraphic );
    }


	// if marker is not up, don't redraw immediately
	if( !m_bMarkerPresent )
		return;

    ASSERT(g_pDraw);
	if (g_pDraw->m_hwnd != NULL )
        ::UpdateWindow(g_pDraw->m_hwnd);
}



//
// Deletes DCWbGraphic/LPRECT pair corresponding to pGraphic
//
void DCWbGraphicMarker::DeleteMarker( DCWbGraphic *pGraphic )
{
	LPRECT pMarkerRect;
	
	if( MarkerList.IsEmpty() )
		return;

	if( MarkerList.Lookup( (void *)pGraphic, (void *&)pMarkerRect )  )
	{
		if( pMarkerRect != NULL )
		{
            ASSERT(g_pDraw);
			UndrawRect(g_pDraw->GetCachedDC(), g_pDraw, pMarkerRect );
			delete pMarkerRect;
		}

		MarkerList.RemoveKey( (void *)pGraphic );

		// set m_boundsRect to real bounds
        GetBoundsRect(&m_boundsRect);

		// pGraphic should be locked by us since it was selected
		// but check to be sure since this might be coming from
		// another user that beat us to the lock.
		if( pGraphic->GotLock() )
			{
			pGraphic->Unlock();
			if( pGraphic->Handle() != NULL )
				pGraphic->ForceUpdate();
			}
		}

	// if marker is not up, don't redraw immediately
	if( !m_bMarkerPresent )
		return;
	}


//
// Sees if pGraphic->Handle() is in marker list and returns obj
//
DCWbGraphic *DCWbGraphicMarker::HasAMarker( DCWbGraphic *pGraphic )
{
	POSITION	 posNext;		
	DCWbGraphic *pSearchGraphic;
	LPRECT       pMarkerRect;

	if( MarkerList.IsEmpty()  )
		return( NULL );

	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
		{
		MarkerList.GetNextAssoc( posNext,
								 (void *&)pSearchGraphic, (void *&)pMarkerRect );

		if( (pSearchGraphic != NULL)&&
			(pSearchGraphic->Handle() == pGraphic->Handle()) )
			{
			return( pSearchGraphic );
			}
		}

	return( NULL );

	}



//
// Gets last marker
//
DCWbGraphic *DCWbGraphicMarker::LastMarker( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	pGraphic = NULL;

	if( !MarkerList.IsEmpty()  )
		{
		// this isn't eactly right, just return head of list for now
		posNext = MarkerList.GetHeadPosition();
		if( posNext != NULL )
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );
		}

	return( pGraphic );
	}



void DCWbGraphicMarker::UndrawMarker(LPCRECT pMarkerRect )
{
    RECT    rect;

    ASSERT(g_pDraw);
	if( (pMarkerRect != NULL) && (g_pDraw->m_hwnd != NULL) )
	{
        rect = *pMarkerRect;
		g_pDraw->SurfaceToClient(&rect);

        ::InvalidateRect(g_pDraw->m_hwnd, &rect, FALSE);
	}
}



int	DCWbGraphicMarker::GetNumMarkers( void )
{
	int count  = 0;		
	POSITION pos;
	pos = MarkerList.GetHeadPosition();
	while(pos)
	{
		count ++;
		MarkerList.GetNext(pos);
	}

	return count;
}




void DCWbGraphicMarker::MoveBy(int cx, int cy)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call MoveBy for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				{
				pGraphic->MoveBy(cx, cy);
				}
			}
		}

	DCWbGraphic::MoveBy(cx, cy); // move marker too
}




void DCWbGraphicMarker::Update( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				pGraphic->Update();
			}
		}
	}




BOOL DCWbGraphicMarker::PointInBounds(POINT pt)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
    RECT        rectHit;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
			{
				MAKE_HIT_RECT(rectHit, pt );

				if( pGraphic->PointInBounds(pt)&&
				    pGraphic->CheckReallyHit( &rectHit )
					)
					return( TRUE );
			}
		}
	}

	return( FALSE );
}



//
// Returns a rect that is the union of all the items in the marker
//
void DCWbGraphicMarker::GetBoundsRect(LPRECT lprc)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
    LPRECT       pMarkerRect;
    RECT         rc;

    ::SetRectEmpty(lprc);

	if( !MarkerList.IsEmpty())
    {
        posNext = MarkerList.GetHeadPosition();
        while( posNext != NULL )
        {
            MarkerList.GetNextAssoc( posNext,
							(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
            {
                pGraphic->GetBoundsRect(&rc);
                ::UnionRect(lprc, lprc, &rc);
            }
		}
    }
}





void DCWbGraphicMarker::SetColor(COLORREF color)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				pGraphic->SetColor( color );
			}
		}
	}







void DCWbGraphicMarker::SetPenWidth(UINT uiWidth)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				pGraphic->SetPenWidth(uiWidth);
			}
		}
	}




void DCWbGraphicMarker::SetSelectionFont(HFONT hFont)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( (pGraphic != NULL)&&
				pGraphic->IsGraphicTool() == enumGraphicText)
				{
				// Change the font of the object
				((DCWbGraphicText*)pGraphic)->SetFont(hFont);

				// Replace the object
				pGraphic->Replace();
				}
			}
		}
	}




//
// Deletes each marker obj for all connections
//
void DCWbGraphicMarker::DeleteSelection( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	DCWbGraphic *pGraphicCopy;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				{
				// make a copy for trash can
				pGraphicCopy = pGraphic->Copy();

				// throw in trash
				if( pGraphicCopy != NULL )
                {
					g_pMain->m_LastDeletedGraphic.CollectTrash( pGraphicCopy );
                }

				// delete obj
				g_pDraw->DeleteGraphic( pGraphic );
				}
			}

		DeleteAllMarkers( NULL );
		}
	}



//
// Brings eaach marker obj to top
//
void DCWbGraphicMarker::BringToTopSelection( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				{
				// move obj to top
                UINT uiReturn;

                uiReturn = g_pwbCore->WBP_GraphicMove(g_pDraw->Page(),
                    pGraphic->Handle(), LAST);
                if (uiReturn != 0)
                {
                    DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
				    return;
                }
				}
			}
		}
	}


//
// Sends each marker object to back
//
void DCWbGraphicMarker::SendToBackSelection( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
			{
                UINT uiReturn;

				// move obj to top
                uiReturn = g_pwbCore->WBP_GraphicMove(g_pDraw->Page(),
                    pGraphic->Handle(), FIRST);
                if (uiReturn != 0)
                {
                    DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
				    return;
                }
			}
			}
		}
	}



//
// Copy marker to clipboard using CLIPBOARD_PRIVATE_MULTI_OBJ format:
//      [ RECT		 : marker rect					]
//      [ DWORD		 : number of objects			]
//      [ DWORD		 : byte length of 1st object	]
//      [ WB_GRAPHIC : header data for first object	]
//      [ DWORD		 : byte length of 2nd object	]
//      [ WB_GRAPHIC : header data for 2nd object	]
//          :
//          :
//      [ DWORD		 : byte length of last object	]
//      [ WB_GRAPHIC : header data for last object	]
//      [ DWORD		 : 0 (marks end of object data)	]
//
BOOL DCWbGraphicMarker::RenderPrivateMarkerFormat( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
	DWORD		 nBufSize;
	DWORD		 nObjSize;
	DWORD		 nNumObjs;
	BYTE	    *buf;
	BYTE	    *pbuf;
    HANDLE		 hbuf;
	PWB_GRAPHIC  pHeader;
	WB_GRAPHIC_HANDLE hGraphic;

	if( MarkerList.IsEmpty() )
		return( TRUE ); // nuthin to do

	// Have to make two passes. The first one figures out how much
	// data we have, the second copies the data.

	// figure out how much data we've got
	nBufSize = sizeof (RECT) + sizeof (DWORD); // marker rect and object
											  // count are first
	nNumObjs = 0;
	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
		{
		MarkerList.GetNextAssoc( posNext,
							     (void *&)pGraphic, (void *&)pMarkerRect );

		if( (pGraphic != NULL)&&
			((hGraphic = pGraphic->Handle()) != NULL)&&
			((pHeader = PG_GetData(pGraphic->Page(), hGraphic )) != NULL) )
			{
			nBufSize += (DWORD)(pHeader->length + sizeof(DWORD));
			g_pwbCore->WBP_GraphicRelease(pGraphic->Page(), hGraphic, pHeader);

			// count objects instead of using MarkerList.GetCount()
			// in case we have an error or something (bad object,
			// leaky core, who knows...)
			nNumObjs++;
			}
		}

	// Add one more DWORD at end. This will be set to 0 below
	// to mark the end of the buffer.
	nBufSize += sizeof(DWORD);


	// Make object buffer. Use GlobalDiddle instead of new so we
	// can pass a mem handle to the clipboard later.
    hbuf = ::GlobalAlloc( GHND, nBufSize );
	if( hbuf == NULL )
		return( FALSE ); // couldn't make room

    buf = (BYTE *)::GlobalLock( hbuf );
	if( buf == NULL )
		{
		::GlobalFree( hbuf );
		return( FALSE ); // couldn't find the room
		}

	pbuf = buf;


	// set marker rect
	CopyMemory(pbuf, &m_boundsRect, sizeof(RECT));
	pbuf += sizeof (RECT);


	// set number of objects
	*((DWORD *)pbuf) = nNumObjs;
	pbuf += sizeof (DWORD);


	// copy each obj to buf + a length DWORD
	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
	{
		MarkerList.GetNextAssoc( posNext,
							     (void *&)pGraphic, (void *&)pMarkerRect );

		if( (pGraphic != NULL)&&
			((hGraphic = pGraphic->Handle()) != NULL)&&
			((pHeader = PG_GetData(pGraphic->Page(), hGraphic )) != NULL) )
			{
			// save length of this obj first
			nObjSize = (DWORD)pHeader->length;
			*((DWORD *)pbuf) = nObjSize;
			pbuf += sizeof (DWORD);

			// copy obj to buf
			CopyMemory( pbuf, (CONST VOID *)pHeader, nObjSize );

			// make sure copy isn't "locked" (bug 474)
			((PWB_GRAPHIC)pbuf)->locked = WB_GRAPHIC_LOCK_NONE;

			// set up for next obj
			pbuf += nObjSize;

			g_pwbCore->WBP_GraphicRelease(pGraphic->Page(), hGraphic, pHeader );
			}
		}

	// cork it up
	*((DWORD *)pbuf) = 0;

	// give it to the clipboard
	::GlobalUnlock( hbuf );
	if( ::SetClipboardData(
			g_ClipboardFormats[ CLIPBOARD_PRIVATE_MULTI_OBJ ], hbuf
							)
		== NULL )
		{
		// clipboard choked, clean up mess
        ::GlobalFree( hbuf );
		return( FALSE );
		}

	// zillions of shared clipboards all over the planet are receiving this
	// thing about now...
	return( TRUE );
	}



//
// Decodes CLIPBOARD_PRIVATE_MULTI_OBJ format and pastes objects
// to Whiteboard. See DCWbGraphicMarker::RenderPrivateMarkerFormat
// for details of format.
//
void DCWbGraphicMarker::Paste( HANDLE handle )
{
	BYTE *pbuf;
	DWORD nNumObjs;
	DWORD nObjSize;
	DCWbGraphic *pGraphic;
	DCWbGraphic *pSelectedGraphic;
	SIZE   PasteOffset;
	RECT  rectMarker;

	// blow off current selection
    g_pMain->m_drawingArea.RemoveMarker(NULL);
	DeleteAllMarkers( NULL );
    pSelectedGraphic = NULL;



	// get data
	pbuf = (BYTE *)::GlobalLock( handle );
	if( pbuf == NULL )
		return; // can't get the door open


	// get marker's original coords and figure offset
	CopyMemory( &rectMarker, (CONST VOID *)pbuf, sizeof (RECT) );
	pbuf += sizeof (RECT);

    RECT    rcVis;
    g_pMain->m_drawingArea.GetVisibleRect(&rcVis);
    PasteOffset.cx = rcVis.left - rectMarker.left;
    PasteOffset.cy = rcVis.top - rectMarker.top;

	// get num objects
	nNumObjs = *((DWORD *)pbuf);
	pbuf += sizeof (DWORD);

	// get each object
	while( (nObjSize = *((DWORD *)pbuf)) != 0 )
		{
		pbuf += sizeof (DWORD);

		// Add the object to the page and current selection
		pGraphic = DCWbGraphic::CopyGraphic( (PWB_GRAPHIC)pbuf );
		pbuf += nObjSize;

		if( pGraphic != NULL )
		{
			pGraphic->MoveBy( PasteOffset.cx, PasteOffset.cy );
			pGraphic->AddToPageLast( g_pMain->GetCurrentPage() );
			g_pMain->m_drawingArea.SelectGraphic( pGraphic, TRUE, TRUE );
        }
	}

	::GlobalUnlock( handle );

    GetBoundsRect(&m_boundsRect);
}



DCWbGraphicLine::~DCWbGraphicLine( void )
{
    // Have to make sure marker is cleaned up before we vanish
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	


//
//
// Function:    DCWbGraphicLine::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the line
//
//
void DCWbGraphicLine::CalculateBoundsRect()
{
    // Create the basic bounding rectangle from the start and end points
    m_boundsRect = m_rect;
    NormalizeRect(&m_boundsRect);

    // Expand the rectangle by the pen width used for drawing
    int iInflate = (m_uiPenWidth + 1) / 2;
    ::InflateRect(&m_boundsRect, iInflate, iInflate);
}

//
//
// Function:    DCWbGraphicLine::SetStart
//
// Purpose:     Set the start point of the line
//
//
void DCWbGraphicLine::SetStart(POINT pointFrom)
{
    // Only do anything if the start point has changed
    if (!EqualPoint(*((LPPOINT)&m_rect.left), pointFrom))
    {
        // Save the new start point
        m_rect.left = pointFrom.x;
        m_rect.top = pointFrom.y;

        // Show that the graphic has changed
        m_bChanged = TRUE;
    }

    // Update the bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicLine::SetEnd
//
// Purpose:     Set the start point of the line
//
//
void DCWbGraphicLine::SetEnd(POINT pointTo)
{
    // Only do anything if the end point has changed
    if (!EqualPoint(*((LPPOINT)&m_rect.right), pointTo))
    {
        // Save the new end point
        m_rect.right = pointTo.x;
        m_rect.bottom = pointTo.y;

        // Show that the graphic has changed
        m_bChanged = TRUE;
    }

    // Update the bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicLine::Draw
//
// Purpose:     Draw the line.
//
//
void DCWbGraphicLine::Draw(HDC hDC)
{
    HPEN    hPen;
    HPEN    hOldPen;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicLine::Draw");

    // Select the required pen
    hPen = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    if (hOldPen != NULL)
    {
        // Select the raster operation
        int iOldROP = ::SetROP2(hDC, m_iPenROP);

        // Draw the line
        ::MoveToEx(hDC, m_rect.left, m_rect.top, NULL);
        ::LineTo(hDC, m_rect.right, m_rect.bottom);

        // De-select the pen and ROP
        ::SetROP2(hDC, iOldROP);
        SelectPen(hDC, hOldPen);
    }

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}

//
//
// Function:    DCWbGraphicLine::MoveBy
//
// Purpose:     Move the line.
//
//
void DCWbGraphicLine::MoveBy(int cx, int cy)
{
    // Move the start and end points
    ::OffsetRect(&m_rect, cx, cy);

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}



//
// Checks object for an actual overlap with pRectHit.  Assumes m_boundsRect
// has already been compared.
//
BOOL DCWbGraphicLine::CheckReallyHit(LPCRECT pRectHit)
{
	return(LineHit(m_rect.left, m_rect.top, m_rect.right, m_rect.bottom,
				 m_uiPenWidth, TRUE, TRUE, pRectHit));
}



//
//
// Function:    DCWbGraphicFreehand::DCWbGraphicFreehand
//
// Purpose:     Constructor
//
//
DCWbGraphicFreehand::DCWbGraphicFreehand(void) : DCWbGraphic()
{
}

DCWbGraphicFreehand::DCWbGraphicFreehand(PWB_GRAPHIC pHeader)
                    : DCWbGraphic()

{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::DCWbGraphicFreehand");

  // Note that we do everything in this constructor because of the
  // call to ReadExternal. If we let the DCWbGraphic base constructor
  // do it the wrong version of ReadExtra will be called (the one
  // in DCWbGraphic instead of the one in DCWbGraphicFreehand);

  // Do the basic initialization
  Initialize();

  // Set up the page and graphic handle
  ASSERT(pHeader != NULL);

  // Read the header data
  ReadHeader(pHeader);

  // Read the extra data
  ReadExtra(pHeader);

}

DCWbGraphicFreehand::DCWbGraphicFreehand
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
) : DCWbGraphic()

{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::DCWbGraphicFreehand");

  // Note that we do everything in this constructor because of the
  // call to ReadExternal. If we let the DCWbGraphic base constructor
  // do it the wrong version of ReadExtra will be called (the one
  // in DCWbGraphic instead of the one in DCWbGraphicFreehand);

  // Do the basic initialization
  Initialize();


    ASSERT(hPage != WB_PAGE_HANDLE_NULL);
    m_hPage = hPage;

    ASSERT(hGraphic != NULL);
    m_hGraphic = hGraphic;

    // Read the header data
    ReadExternal();
}



DCWbGraphicFreehand::~DCWbGraphicFreehand( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	


//
//
// Function:    DCWbGraphicFreehand::MoveBy
//
// Purpose:     Move the polyline.
//
//
void DCWbGraphicFreehand::MoveBy(int cx, int cy)
{
    // Move the base point of the freehand object
    m_rect.left += cx;
    m_rect.top += cy;

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}

//
//
// Function:    DCWbGraphicFreehand::Draw
//
// Purpose:     Draw the polyline.
//
//
void DCWbGraphicFreehand::Draw(HDC hDC)
{
    RECT    clipBox;
    int     iOldROP;
    HPEN    hPen;
    HPEN    hOldPen;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand:Draw");

    // NFC, SFR 5922.  Check the return code from GetClipBox.
    // If we fail to get it, just draw everything
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the required pen
    hPen = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    if (hOldPen != NULL)
    {
        // All points are relative to the first point in the list.
        // We update the origin of the DC temporarily to account for this.
        POINT   origin;

        ::GetWindowOrgEx(hDC, &origin);
        ::SetWindowOrgEx(hDC, origin.x - m_rect.left, origin.y - m_rect.top, NULL);

        // Call the appropriate drawing function, according to whether
        // we're smooth or not
        DrawUnsmoothed(hDC);

        // Restore the origin
        ::SetWindowOrgEx(hDC, origin.x, origin.y, NULL);

        ::SetROP2(hDC, iOldROP);
        SelectPen(hDC, hOldPen);
    }

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}


//
//
// Function:    DCWbGraphicFreehand::DrawUnsmoothed
//
// Purpose:     Draw the complete graphic, not using smoothing.
//
//
void DCWbGraphicFreehand::DrawUnsmoothed(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehandDrawUnsmoothed");

    // Set up the count and pointer to the points data. We use the
    // external data if we have a handle, otherwise internal data is used.
	int iCount = points.GetSize();
    if (iCount < 2)
    {
    	POINT point;
    	point.x = points[0]->x;
    	point.y = points[0]->y;
        points.Add(point);

        iCount = points.GetSize();
    }

    RECT  clipBox;

    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }

    // Draw all the line segments stored
    ::MoveToEx(hDC, points[0]->x, points[0]->y, NULL);
    for ( int iIndex = 1; iIndex < iCount; iIndex++)
    {
        // Draw the line
        ::LineTo(hDC, points[iIndex]->x, points[iIndex]->y);
    }
}




//
//
// Function:    DCWbGraphicFreehand::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the line
//
//
void DCWbGraphicFreehand::CalculateBoundsRect(void)
{
    // Reset the bounds rectangle
    ::SetRectEmpty(&m_boundsRect);

    // Add each of the points in the line to the bounding rectangle
    int iCount = points.GetSize();
    for ( int iIndex = 0; iIndex < iCount; iIndex++)
    {
        AddPointToBounds(points[iIndex]->x, points[iIndex]->y);
    }

    //
    // Since the points are inclusive, we need to add one to the top &
    // bottom sides.
    //
    ::InflateRect(&m_boundsRect, 0, 1);
    ::OffsetRect(&m_boundsRect, m_rect.left, m_rect.top);
}

//
//
// Function:    DCWbGraphicFreehand::AddPointToBounds
//
// Purpose:     Add a single point into the bounding rectangle. The point is
//              expected to be in surface co-ordinates.
//
//
void DCWbGraphicFreehand::AddPointToBounds(int x, int y)
{
    // Create a rectangle containing the point just added (expanded
    // by the width of the pen being used).
    RECT  rect;

    int iInflate = (m_uiPenWidth + 1) / 2;
    rect.left   = x - iInflate;
    rect.top    = y - iInflate;
    rect.right  = x + iInflate;
    rect.bottom = y + iInflate;

    ::UnionRect(&m_boundsRect, &m_boundsRect, &rect);
}

//
//
// Function:    DCWbGraphicFreehand::AddPoint
//
// Purpose:     Add a point to the poly line, returning BOOL indicating
//              success.
//
//
BOOL DCWbGraphicFreehand::AddPoint(POINT point)
{
    BOOL bSuccess = TRUE;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::AddPoint");

    // if we've reached the maximum number of points then quit with failure
    if (points.GetSize() >= MAX_FREEHAND_POINTS)
    {
        bSuccess = FALSE;
        TRACE_MSG(("Maximum number of points for freehand object reached."));
        return(bSuccess);
    }

    // If this is the first point - all others are taken relative to it.
    if (points.GetSize() == 0)
    {
        // Save the first point here.
        m_rect.left = point.x;
        m_rect.top = point.y;
    }

    // Add the new point to the array - surround with exception handler
    // to catch memory errors
    POINT newpoint;
    newpoint.x = point.x - m_rect.left;
    newpoint.y = point.y - m_rect.top;

    points.Add((newpoint));

    // Add the new point into the accumulated bounds rectangle.
    AddPointToBounds(point.x, point.y);

    // Show that the graphic has changed
    m_bChanged = TRUE;

    return(bSuccess);
}

//
//
// Function:    DCWbGraphicFreehand::CalculateExternalLength
//
// Purpose:     Return the length of the external representation of the
//              graphic.
//
//
DWORD DCWbGraphicFreehand::CalculateExternalLength(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::CalculateExternalLength");

  // Calculate the total length of the flat representation of the graphic
  return (DWORD) (  sizeof(WB_GRAPHIC_FREEHAND)
                  + (points.GetSize() * sizeof(POINT)));
}

//
//
// Function:    DCWbGraphicFreehand::WriteExtra
//
// Purpose:     Write the extra (non-header) data to the flat representation
//              of the graphic.
//
//
void DCWbGraphicFreehand::WriteExtra(PWB_GRAPHIC pHeader)
{
  // Allocate the memory
  PWB_GRAPHIC_FREEHAND pFreehand = (PWB_GRAPHIC_FREEHAND) pHeader;

  // Copy the extra details into place
  pFreehand->pointCount = (TSHR_UINT16)points.GetSize();
  for ( int iIndex = 0; iIndex < pFreehand->pointCount; iIndex++)
  {
    pFreehand->points[iIndex].x = (short)points[iIndex]->x;
    pFreehand->points[iIndex].y = (short)points[iIndex]->y;
  }
}

//
//
// Function:    DCWbGraphicFreehand::ReadExtra
//
// Purpose:     Read the extra (non-header) data from the flat
//              representation of the graphic.
//
//
void DCWbGraphicFreehand::ReadExtra(PWB_GRAPHIC pHeader)
{
  // Allocate the memory
  PWB_GRAPHIC_FREEHAND pFreehand = (PWB_GRAPHIC_FREEHAND) pHeader;

  // Get the number of points
  int iCount = pFreehand->pointCount;

  // Set the size of the points array
  points.SetSize(iCount);

  // Copy the points from the external memory to internal
  int iPointIndex = 0;
  while (iPointIndex < iCount)
  {
    points[iPointIndex]->x = pFreehand->points[iPointIndex].x;
    points[iPointIndex]->y = pFreehand->points[iPointIndex].y;

    iPointIndex++;
  }
}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicFreehand::CheckReallyHit(LPCRECT pRectHit)
{
	POINT *lpPoints;
	int    iCount;
	int	   i;
	POINT  ptLast;
	UINT   uRadius;
	RECT   rectHit;


	iCount = points.GetSize();
	lpPoints = (POINT *)points.GetBuffer();

	if( iCount == 0 )
		return( FALSE );


	// addjust hit rect to lpPoints coord space.
	rectHit = *pRectHit;
    ::OffsetRect(&rectHit, -m_rect.left, -m_rect.top);

	if( (iCount > 0)&&(iCount < 2) )
		{
		// only one point, just hit check it
		uRadius = m_uiPenWidth >> 1; // m_uiPenWidth/2
		return(
			CircleHit( lpPoints->x, lpPoints->y, uRadius, &rectHit, TRUE )
				);
		}

	// look for a hit on each line segment body
	ptLast = *lpPoints++;
	for( i=1; i<iCount; i++ )
		{
		if( LineHit( ptLast.x, ptLast.y,
					 lpPoints->x, lpPoints->y, m_uiPenWidth,
					 FALSE, FALSE,
					 &rectHit )
			)
			return( TRUE ); // got a hit

		ptLast = *lpPoints++;
		}

	// now, look for a hit on the line endpoints if m_uiPenWidth > 1
	if( m_uiPenWidth > 1 )
		{
		uRadius = m_uiPenWidth >> 1; // m_uiPenWidth/2
		lpPoints = (POINT *)points.GetBuffer();
		for( i=0; i<iCount; i++, lpPoints++ )
			{
			if( CircleHit( lpPoints->x, lpPoints->y, uRadius, &rectHit, FALSE )
				)
				return( TRUE ); // got a hit
			}
		}

	return( FALSE ); // no hits
	}






DCWbGraphicRectangle::~DCWbGraphicRectangle( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	




//
//
// Function:    DCWbGraphicRectangle::SetRect
//
// Purpose:     Set the rectangle size/position
//
//
void DCWbGraphicRectangle::SetRect(LPCRECT lprect)
{
    DCWbGraphic::SetRect(lprect);

    // Generate the new bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicRectangle::MoveBy
//
// Purpose:     Move the rectangle
//
//
void DCWbGraphicRectangle::MoveBy(int cx, int cy)
{
    // Move the rectangle
    ::OffsetRect(&m_rect, cx, cy);

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}

//
//
// Function:    DCWbGraphicRectangle::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicRectangle::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, m_uiPenWidth, m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicRectangle::Draw
//
// Purpose:     Draw the rectangle
//
//
void DCWbGraphicRectangle::Draw(HDC hDC)
{
    int     iOldROP;
    RECT    clipBox;
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hOldBrush;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicRectangle::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);
    hOldBrush = SelectBrush(hDC, ::GetStockObject(NULL_BRUSH));

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Rectangle(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    ::SetROP2(hDC, iOldROP);
    SelectPen(hDC, hOldPen);

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}




//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicRectangle::CheckReallyHit(LPCRECT pRectHit)
{
	RECT rectEdge;
	RECT rectHit;

	// check left edge
    rectEdge.left   = m_rect.left - m_uiPenWidth;
    rectEdge.top    = m_rect.top -  m_uiPenWidth;
    rectEdge.right  = m_rect.left;
    rectEdge.bottom = m_rect.bottom + m_uiPenWidth;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	// check right edge
	rectEdge.left =     m_rect.right;
	rectEdge.right =    m_rect.right + m_uiPenWidth;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check top edge
	rectEdge.left = m_rect.left;
	rectEdge.right = m_rect.right;
	rectEdge.bottom = m_rect.top;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check bottom edge
	rectEdge.top = m_rect.bottom;
	rectEdge.bottom = m_rect.bottom + m_uiPenWidth;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	return( FALSE );
}




DCWbGraphicFilledRectangle::~DCWbGraphicFilledRectangle( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	




//
//
// Function:    DCWbGraphicFilledRectangle::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicFilledRectangle::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    // This is one greater than the rectangle to include the drawing rectangle
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, 1, 1);
}

//
//
// Function:    DCWbGraphicFilledRectangle::Draw
//
// Purpose:     Draw the rectangle
//
//
void DCWbGraphicFilledRectangle::Draw(HDC hDC)
{
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hBrush;
    HBRUSH  hOldBrush;
    int     iOldROP;
    RECT    clipBox;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFilledRectangle::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen    = ::CreatePen(m_iPenStyle, 2, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    hBrush = ::CreateSolidBrush(m_clrPenColor);
    hOldBrush = SelectBrush(hDC, hBrush);

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Rectangle(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    // Restore the ROP mode
    ::SetROP2(hDC, iOldROP);

    SelectBrush(hDC, hOldBrush);
    if (hBrush != NULL)
    {
        ::DeleteBrush(hBrush);
    }

    SelectPen(hDC, hOldPen);
    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicFilledRectangle::CheckReallyHit(LPCRECT pRectHit)
{
	return( TRUE );
}



//
// Draws a tracking rect for every marker obj in marker
// (DCWbGraphicSelectTrackingRectangle is a friend of DCWbGraphicMarker
// and WbDrawingArea)
//
void DCWbGraphicSelectTrackingRectangle::Draw(HDC hDC)
{
	POSITION	posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
    RECT        rectTracker;
	CPtrToPtrList *pMList;

	// don't draw at start point or XOR will get out of sync
	if( (m_Offset.cx == 0)&&(m_Offset.cy == 0) )
		return;

    ASSERT(g_pDraw);
	pMList = &(g_pDraw->m_pMarker->MarkerList);

	if( pMList->IsEmpty() )
		return;

	posNext = pMList->GetHeadPosition();
	while( posNext != NULL )
		{
		pMList->GetNextAssoc( posNext, (void *&)pGraphic, (void *&)pMarkerRect );

		if( pMarkerRect != NULL )
		{
            rectTracker = *pMarkerRect;
            ::OffsetRect(&rectTracker, m_Offset.cx, m_Offset.cy);

			SetRect(&rectTracker);
			DCWbGraphicRectangle::Draw(hDC);
		}
	}
}




void DCWbGraphicSelectTrackingRectangle::MoveBy(int cx, int cy)
{
    m_Offset.cx += cx;
    m_Offset.cy += cy;
}





DCWbGraphicEllipse::~DCWbGraphicEllipse( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	



//
//
// Function:    DCWbGraphicEllipse::SetRect
//
// Purpose:     Set the ellipse size/position
//
//
void DCWbGraphicEllipse::SetRect(LPCRECT lprc)
{
    DCWbGraphic::SetRect(lprc);

    // Generate the new bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicEllipse::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicEllipse::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    // This includes all the line, since we draw inside the bounds
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, m_uiPenWidth, m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicEllipse::MoveBy
//
// Purpose:     Move the ellipse
//
//
void DCWbGraphicEllipse::MoveBy(int cx, int cy)
{
    // Move the ellipse
    ::OffsetRect(&m_rect, cx, cy);

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}

//
//
// Function:    DCWbGraphicEllipse::Draw
//
// Purpose:     Draw the ellipse
//
//
void DCWbGraphicEllipse::Draw(HDC hDC)
{
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hOldBrush;
    int     iOldROP;
    RECT    clipBox;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicEllipse::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen    = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);
    hOldBrush = SelectBrush(hDC, ::GetStockObject(NULL_BRUSH));

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Ellipse(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    ::SetROP2(hDC, iOldROP);

    SelectBrush(hDC, hOldBrush);

    SelectPen(hDC, hOldPen);
    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}




//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//	
BOOL DCWbGraphicEllipse::CheckReallyHit(LPCRECT pRectHit)
{
    return( EllipseHit( &m_rect, TRUE, m_uiPenWidth, pRectHit ) );
}





DCWbGraphicFilledEllipse::~DCWbGraphicFilledEllipse( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	



//
//
// Function:    DCWbGraphicFilledEllipse::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicFilledEllipse::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    // This is one greater than the rectangle to include the drawing rectangle
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, 1, 1);
}

//
//
// Function:    DCWbGraphicFilledEllipse::Draw
//
// Purpose:     Draw the ellipse
//
//
void DCWbGraphicFilledEllipse::Draw(HDC hDC)
{
    RECT    clipBox;
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hBrush;
    HBRUSH  hOldBrush;
    int     iOldROP;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFilledEllipse::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen    = ::CreatePen(m_iPenStyle, 2, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    hBrush = ::CreateSolidBrush(m_clrPenColor);
    hOldBrush = SelectBrush(hDC, hBrush);

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Ellipse(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    ::SetROP2(hDC, iOldROP);

    SelectBrush(hDC, hOldBrush);
    if (hBrush != NULL)
    {
        ::DeleteBrush(hBrush);
    }

    SelectPen(hDC, hOldPen);
    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }

}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicFilledEllipse::CheckReallyHit(LPCRECT pRectHit)
{
    return( EllipseHit( &m_rect, FALSE, 0, pRectHit ) );
}



//
//
// Function:    DCWbGraphicText::DCWbGraphicText
//
// Purpose:     Initialize a new drawn text object.
//
//
DCWbGraphicText::DCWbGraphicText(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::DCWbGraphicText");

    m_hFontThumb = NULL;

	m_hFont = ::CreateFont(0,0,0,0,FW_NORMAL,0,0,0,0,OUT_TT_PRECIS,
				    CLIP_DFA_OVERRIDE,
				    DRAFT_QUALITY,
				    FF_SWISS,NULL);

	// Add an empty line to the text array
	strTextArray.Add(_T(""));

	// Show that the graphic has not changed
	m_bChanged = FALSE;

	m_nKerningOffset = 0; // added for bug 469
}

DCWbGraphicText::DCWbGraphicText(PWB_GRAPHIC pHeader)
                : DCWbGraphic()
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::DCWbGraphicText");

    ASSERT(pHeader != NULL);

    m_hFont = NULL;
    m_hFontThumb = NULL;

    // Note that we do everything in this constructor because of the
    // calls to ReadHeader and ReadExtra. If we let the DCWbGraphic base
    // constructor do it the wrong version of ReadExtra will be called
    // (the one in DCWbGraphic instead of the one in DCWbGraphicText).

    // Add an empty line to the text array
    strTextArray.Add(_T(""));

    // Read the data
    ReadHeader(pHeader);
    ReadExtra(pHeader);

    // Show that the graphic has not changed
    m_bChanged = FALSE;
}

DCWbGraphicText::DCWbGraphicText
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
) : DCWbGraphic()
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::DCWbGraphicText");

    // Note that we do everything in this constructor because of the
    // call to ReadExternal. If we let the DCWbGraphic base constructor
    // do it the wrong version of ReadExtra will be called (the one
    // in DCWbGraphic instead of the one in DCWbGraphicText);

    // Set up the page and graphic handle
    ASSERT(hPage != WB_PAGE_HANDLE_NULL);
    m_hPage =  hPage;

    ASSERT(hGraphic != NULL);
    m_hGraphic = hGraphic;

    m_hFont = NULL;
    m_hFontThumb = NULL;

    // Add an empty line to the text array
    strTextArray.Add(_T(""));

    // Read the data
    ReadExternal();

    // Show that the graphic has not changed
    m_bChanged = FALSE;
}

//
//
// Function:    DCWbGraphicText:: ~DCWbGraphicText
//
// Purpose:     Destruct a text object
//
//
DCWbGraphicText::~DCWbGraphicText()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::~DCWbGraphicText");

	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}

	// Ensure that the DC does not contain our fonts
	if(g_pDraw != NULL)
	{
		g_pDraw->UnPrimeFont(g_pDraw->GetCachedDC());
	}

    if (m_hFontThumb != NULL)
    {
        ::DeleteFont(m_hFontThumb);
        m_hFontThumb = NULL;
    }

    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
}

StrCspn(char * string, char * control)
{
        char *str = string;
        char *ctrl = control;

        unsigned char map[32];
        int count;

        /* Clear out bit map */
        for (count=0; count<32; count++)
                map[count] = 0;

        /* Set bits in control map */
        while (*ctrl)
        {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
                ctrl++;
        }
		count=0;
        map[0] |= 1;    /* null chars not considered */
        while (!(map[*str >> 3] & (1 << (*str & 7))))
        {
                count++;
                str++;
        }
        return(count);
}


//
//
// Function:    DCWbGraphicText::SetText
//
// Purpose:     Set the text of the object
//
//
void DCWbGraphicText::SetText(TCHAR * strText)
{
    // Remove all the current stored text
    strTextArray.RemoveAll();

    // Scan the text for carriage return and new-line characters
    int iNext = 0;
    int iLast = 0;
    int textSize = lstrlen(strText);
    TCHAR savedChar[1];

    //
    // In this case, we don't know how many lines there will be.  So we
    // use Add() from the StrArray class.
    //
    while (iNext < textSize)
    {
        // Find the next carriage return or line feed
        iNext += StrCspn(strText + iNext, "\r\n");

        // Extract the text before the terminator
        // and add it to the current list of text lines.

        savedChar[0] = strText[iNext];
        strText[iNext] = 0;
        strTextArray.Add((strText+iLast));
        strText[iNext] = savedChar[0];


        if (iNext < textSize)
        {
            // Skip the carriage return
            if (strText[iNext] == '\r')
                iNext++;

            // Skip a following new line (if there is one)
            if (strText[iNext] == '\n')
                iNext++;

            // Update the index of the start of the next line
            iLast = iNext;
        }
    }

    // Calculate the bounding rectangle for the new text
    CalculateBoundsRect();

    // Show that the graphic has not changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicText::SetText
//
// Purpose:     Set the text of the object
//
//
void DCWbGraphicText::SetText(const StrArray& _strTextArray)
{
    // Scan the text for carriage return and new-line characters
    int iSize = _strTextArray.GetSize();

    //
    // In this case we know how many lines, so set that # then use SetAt()
    // to stick text there.
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(iSize);

    int iNext = 0;
    for ( ; iNext < iSize; iNext++)
    {
        strTextArray.SetAt(iNext, _strTextArray[iNext]);
    }

    // Calculate the new bounding rectangle
    CalculateBoundsRect();

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicText::SetFont
//
// Purpose:     Set the font to be used for drawing
//
//
void DCWbGraphicText::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::SetFont");

    // Get the font details
    LOGFONT lfont;
    ::GetObject(hFont, sizeof(LOGFONT), &lfont);

    //
    // Pass the logical font into the SetFont() function
    //
    SetFont(&lfont);
}

//
//
// Function:    DCWbGraphicText::SetFont(metrics)
//
// Purpose:     Set the font to be used for drawing
//
//
void DCWbGraphicText::SetFont(LOGFONT *pLogFont, BOOL bReCalc )
{
    HFONT hOldFont;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::SetFont");

    // Ensure that the font can be resized by the zoom function
    // (proof quality prevents font scaling).
    pLogFont->lfQuality = DRAFT_QUALITY;

    //zap FontAssociation mode (bug 3258)
    pLogFont->lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Always work in cell coordinates to get scaling right
    TRACE_MSG(("Setting font height %d, width %d, face %s, family %d, precis %d",
        pLogFont->lfHeight,pLogFont->lfWidth,pLogFont->lfFaceName,
        pLogFont->lfPitchAndFamily, pLogFont->lfOutPrecision));

    hOldFont = m_hFont;

    m_hFont = ::CreateFontIndirect(pLogFont);
    if (!m_hFont)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create font"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
	    return;
    }

    // Calculate the line height for this font
	if(g_pDraw != NULL)
    {
		HDC     hDC = g_pDraw->GetCachedDC();

		g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);
	}


    // We are now guaranteed to be able to delete the old font
    if (hOldFont != NULL)
    {
        ::DeleteFont(hOldFont);
    }

  // Set up the thumbnail font, forcing truetype if not currently TT
  if (!(m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE))
  {
      pLogFont->lfFaceName[0]    = 0;
      pLogFont->lfOutPrecision   = OUT_TT_PRECIS;
      TRACE_MSG(("Non-True type font"));
  }

    if (m_hFontThumb != NULL)
    {
        ::DeleteFont(m_hFontThumb);
    }
    m_hFontThumb = ::CreateFontIndirect(pLogFont);
    if (!m_hFontThumb)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create thumbnail font"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
	    return;
    }

    // Calculate the bounding rectangle, accounting for the new font
    if( bReCalc )
	    CalculateBoundsRect();

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicText::GetTextABC
//
// Purpose:     Calculate the ABC numbers for a string of text
//																			
// COMMENT BY RAND: The abc returned is for the whole string, not just one
//					char. I.e, ABC.abcA is the offset to the first glyph in
//					the string, ABC.abcB is the sum of all of the glyphs and
//					ABC.abcC is the trailing space after the last glyph. 	
//					ABC.abcA + ABC.abcB + ABC.abcC is the total rendered 	
//					length including overhangs.								
//
// Note - we never use the A spacing so it is always 0
//
ABC DCWbGraphicText::GetTextABC( LPCTSTR pText,
                                int iStartX,
                                int iStopX)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::GetTextABC");
	ABC  abcResult;
    HDC  hDC;
	BOOL rc = FALSE;
	ABC  abcFirst;
	ABC  abcLast;
	BOOL zoomed = g_pDraw->Zoomed();
	int  nCharLast;
	int  i;
	LPCTSTR pScanStr;
	
	ZeroMemory( (PVOID)&abcResult, sizeof abcResult );
	ZeroMemory( (PVOID)&abcFirst, sizeof abcFirst );
	ZeroMemory( (PVOID)&abcLast, sizeof abcLast );

	// Get the standard size measure of the text
	LPCTSTR pABC = (pText + iStartX);
	int pABCLength = iStopX - iStartX;
	hDC = g_pDraw->GetCachedDC();
	g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);

	//
	// We must temporarily unzoom if we are currently zoomed since the
	// weird Windows font handling will not give us the same answer for
	// the text extent in zoomed mode for some TrueType fonts
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, 1, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), NULL);
    }

    DWORD size = ::GetTabbedTextExtent(hDC, pABC, pABCLength, 0, NULL);

	// We now have the advance width of the text
	abcResult.abcB = LOWORD(size);
	TRACE_MSG(("Basic text width is %d",abcResult.abcB));

	// Allow for C space (or overhang)
	if (iStopX > iStartX)
		{
		if (m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE)
			{
			if(GetSystemMetrics( SM_DBCSENABLED ))
				{
				// have to handle DBCS on both ends
				if( IsDBCSLeadByte( (BYTE)pABC[0] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					WORD wMultiChar = MAKEWORD( pABC[1], pABC[0] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcFirst);
					}
				else
					{
					// first char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );
					}

				// Check for DBCS as last char. Have to scan whole string to be sure
				pScanStr = pABC;
				nCharLast = 0;
				for( i=0; i<pABCLength; i++, pScanStr++ )
					{
					nCharLast = i;
					if( IsDBCSLeadByte( (BYTE)*pScanStr ) )
						{
						i++;
						pScanStr++;
						}
					}

				if( IsDBCSLeadByte( (BYTE)pABC[nCharLast] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					ASSERT( (nCharLast+1) < pABCLength );
					WORD wMultiChar = MAKEWORD( pABC[nCharLast+1], pABC[nCharLast] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcLast);
					}
				else
					{
					// last char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
					}
				}
			else
				{
				// SBCS, no special fiddling, just call GetCharABCWidths()
				rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );

				nCharLast = pABCLength-1;
				rc = rc && ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
				}

			TRACE_MSG(("abcFirst: rc=%d, a=%d, b=%d, c=%d",
						rc, abcFirst.abcA, abcFirst.abcB, abcFirst.abcC) );
			TRACE_MSG(("abcLast: rc=%d, a=%d, b=%d, c=%d",
						rc, abcLast.abcA, abcLast.abcB, abcLast.abcC) );
			}


		if( rc )
			{
			// The text was trutype and we got good abcwidths
			// Give the C space of the last characters from
			// the string as the C space of the text.
			abcResult.abcA = abcFirst.abcA;
			abcResult.abcC = abcLast.abcC;
			}
		else
			{
			//
			// Mock up C value for a non TT font by taking some of overhang as
			// the negative C value.
			//
			//TRACE_MSG(("Using overhang -%d as C space",m_textMetrics.tmOverhang/2));
			
			// Adjust B by -overhang to make update rect schoot
			// far enough to the left so that the toes of italic cap A's
			// don't get clipped. Ignore comment above.
			abcResult.abcB -= m_textMetrics.tmOverhang;
			}
		}

	//
	// If we temporarily unzoomed then restore it now
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), 1, NULL);
	}

	TRACE_MSG(("Final text width is %d, C space %d",abcResult.abcB,abcResult.abcC));

	return abcResult;
	}



//
//
// Function:    DCWbGraphicText::GetTextRectangle
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void DCWbGraphicText::GetTextRectangle(int iStartY,
                                        int iStartX,
                                        int iStopX,
                                        LPRECT lprc)
{
	// ABC structures for text sizing
	ABC abcText1;
	ABC abcText2;
	int iLeftOffset = 0;
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::GetTextRect");

	// Here we calculate the width of the text glyphs in which we
	// are interested. In case there are tabs involved we must start
	// with position 0 and get two lengths then subtract them

	abcText1 = GetTextABC(strTextArray[iStartY], 0, iStopX);

	if (iStartX > 0)
		{
		
		// The third param used to be iStartX-1 which is WRONG. It
		// has to point to the first char pos past the string
		// we are using.
		abcText2 = GetTextABC(strTextArray[iStartY], 0, iStartX);

		
		// Just use B part for offset. Adding A snd/or C to it moves the update
		// rectangle too far to the right and clips the char
		iLeftOffset = abcText2.abcB;
		}
	else
		{
		
		ZeroMemory( &abcText2, sizeof abcText2 );
		}

	//
	// We need to allow for A and C space in the bounding rectangle.  Use
	// ABS function just to make sure we get a large enough rectangle.
	//
	
	// Move A and C from original offset calc to here for width of update
	// rectangle. Add in tmOverhang (non zero for non-tt fonts) to compensate
	// for the kludge in GetTextABC()....THIS EDITBOX CODE HAS GOT TO GO...
	abcText1.abcB = abcText1.abcB - iLeftOffset +	
					  abs(abcText2.abcA) + abs(abcText2.abcC) +
					  abs(abcText1.abcA) + abs(abcText1.abcC) +
					  m_textMetrics.tmOverhang;

	TRACE_DEBUG(("Left offset %d",iLeftOffset));
	TRACE_DEBUG(("B width now %d",abcText1.abcB));

	// Build the result rectangle.
	// Note that we never return an empty rectangle. This allows for the
	// fact that the Windows rectangle functions will ignore empty
	// rectangles completely. This would cause the bounding rectangle
	// calculation (for instance) to go wrong if the top or bottom lines
	// in a text object were empty.
	int iLineHeight = m_textMetrics.tmHeight + m_textMetrics.tmExternalLeading;

    lprc->left = 0;
    lprc->top = 0;
    lprc->right = max(1, abcText1.abcB);
    lprc->bottom = iLineHeight;
    ::OffsetRect(lprc, iLeftOffset, iLineHeight * iStartY);

	// rect is the correct width at this point but it might need to be schooted to
	// the left a bit to allow for kerning of 1st letter (bug 469)
	if( abcText1.abcA < 0 )
	{
        ::OffsetRect(lprc, abcText1.abcA, 0);
		m_nKerningOffset = -abcText1.abcA;
	}
	else
		m_nKerningOffset = 0;

    POINT   pt;
    GetPosition(&pt);
    ::OffsetRect(lprc, pt.x, pt.y);
}

//
//
// Function:    DCWbGraphicText::CalculateRect
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void DCWbGraphicText::CalculateRect(int iStartX,
                                     int iStartY,
                                     int iStopX,
                                     int iStopY,
                                    LPRECT lprcResult)
{
    RECT    rcResult;
    RECT    rcT;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::CalculateRect");

    //
    // NOTE:
    // We must use an intermediate rectangle, so as not to disturb the
    // contents of the passed-in one until done.  lprcResult may be pointing
    // to the current bounds rect, and we call functions from here that
    // may need its current value.
    //

    // Initialize the result rectangle
    ::SetRectEmpty(&rcResult);

    // Allow for special limit values and ensure that the start and stop
    // character positions are in range.
    if (iStopY == LAST_LINE)
    {
        iStopY = strTextArray.GetSize() - 1;
    }
    iStopY = min(iStopY, strTextArray.GetSize() - 1);
    iStopY = max(iStopY, 0);

    if (iStopX == LAST_CHAR)
    {
        iStopX = lstrlen(strTextArray[iStopY]);
    }
    iStopX = min(iStopX, lstrlen(strTextArray[iStopY]));
    iStopX = max(iStopX, 0);

    // Loop through the text strings, adding each to the rectangle
    for (int iIndex = iStartY; iIndex <= iStopY; iIndex++)
    {
        int iLeftX = ((iIndex == iStartY) ? iStartX : 0);
        int iRightX = ((iIndex == iStopY)
                        ? iStopX : lstrlen(strTextArray[iIndex]));

        GetTextRectangle(iIndex, iLeftX, iRightX, &rcT);
        ::UnionRect(&rcResult, &rcResult, &rcT);
    }

    *lprcResult = rcResult;
}

//
//
// Function:    DCWbGraphicText::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicText::CalculateBoundsRect(void)
{
    // Set the new bounding rectangle
    CalculateRect(0, 0, LAST_CHAR, LAST_LINE, &m_boundsRect);
}

//
//
// Function: DCWbGraphicText::Draw
//
// Purpose : Draw the object onto the specified DC
//
//
void DCWbGraphicText::Draw(HDC hDC, BOOL thumbNail)
{
    RECT        clipBox;
    BOOL        dbcsEnabled = GetSystemMetrics(SM_DBCSENABLED);
    INT		    *tabArray;
    UINT        ch;
    int         i,j;
    BOOL        zoomed    = g_pDraw->Zoomed();
    int		    oldBkMode = 0;
    int         iIndex    = 0;
    POINT       pointPos;
	int		    nLastTab;
	ABC		    abc;
    int		    iLength;
    TCHAR *     strLine;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::Draw");

    //
    // Only draw anything if the bounding rectangle intersects the current
    // clip box.
    //
    if (::GetClipBox(hDC, &clipBox) == ERROR)
	{
        WARNING_OUT(("Failed to get clip box"));
	}
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    //
    // Select the font.
    //
    if (thumbNail)
	{
        TRACE_MSG(("Using thumbnail font"));
        g_pDraw->PrimeFont(hDC, m_hFontThumb, &m_textMetrics);
	}
    else
	{
        TRACE_MSG(("Using standard font"));
        g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);
	}

    //
    // Set the color and mode for drawing.
    //
    ::SetTextColor(hDC, m_clrPenColor);

    //
    // Set the background to be transparent
    //
    oldBkMode = ::SetBkMode(hDC, TRANSPARENT);

    //
    // Calculate the bounding rectangle, accounting for the new font.
    //
    CalculateBoundsRect();

    //
    // Get the start point for the text.
    //
    pointPos.x = m_boundsRect.left + m_nKerningOffset;
    pointPos.y = m_boundsRect.top;

    //
    // Loop through the text strings drawing each as we go.
    //
    for (iIndex = 0; iIndex < strTextArray.GetSize(); iIndex++)
	{
        //
        // Get a reference to the line to be printed for convenience.
        //
        strLine  = (LPTSTR)strTextArray[iIndex];
        iLength  = lstrlen(strLine);

        //
        // Only draw the line if there are any characters in it.
        //
        if (iLength > 0)
	  	{
            if (zoomed)
	  		{
				// if new fails just skip it
				tabArray = new INT[iLength+1];
				if( tabArray == NULL )
                {
                    ERROR_OUT(("Failed to allocate tabArray"));
					continue;
                }

				// We are zoomed. Must calculate char spacings
				// ourselfs so that they end up proportionally
				// in the right places. TabbedTextOut will not
				// do this right so we have to use ExtTextOut with
				// a tab array.

				// figure out tab array
                j = 0;
				nLastTab = 0;
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i]; //Don't worry about DBCS here...
					abc = GetTextABC(strLine, 0, i);

					if( j > 0 )
						tabArray[j-1] = abc.abcB - nLastTab;

					nLastTab = abc.abcB;
					j++;
	  			}

				// Now, strip out any tab chars so they don't interact
				// in an obnoxious manner with the tab array we just
				// made and so they don't make ugly little
				// blocks when they are drawn.
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i];
                    if ((dbcsEnabled) && (IsDBCSLeadByte((BYTE)ch)))
						i++;
					else
                    if(strLine[(int)i] == '\t')
                        strLine[i] = ' '; // blow off tab, tab array
											   // will compensate for this
	  			}

				// do it
                ::ExtTextOut(hDC, pointPos.x,
                                pointPos.y,
                                0,
                                NULL,
                                strLine,
                                iLength,
                                tabArray);

				delete tabArray;
			}
            else
			{
                POINT   ptPos;

                GetPosition(&ptPos);

				// Not zoomed, just do it
				::TabbedTextOut(hDC, pointPos.x,
								 pointPos.y,
								 strLine,
								 iLength,
								 0,
								 NULL,
                                 ptPos.x);
			}
		}

        //
        // Move to the next line.
        //
        pointPos.y += (m_textMetrics.tmHeight);
	}

    //
    // Restore the old background mode.
    //
    ::SetBkMode(hDC, oldBkMode);
    g_pDraw->UnPrimeFont(hDC);
}



//
//
// Function:    DCWbGraphicText::CalculateExternalLength
//
// Purpose:     Return the length of the external representation of the
//              graphic.
//
//
DWORD DCWbGraphicText::CalculateExternalLength(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::CalculateExternalLength");

    // Loop through the text strings, adding the size of each as we go
    DWORD length = sizeof(WB_GRAPHIC_TEXT);
    int iCount = strTextArray.GetSize();
    for (int iIndex = 0; iIndex < iCount; iIndex++)
    {
        // Allow extra bytes per string for NULL term
        length += lstrlen(strTextArray[iIndex]) + 2;
    }

    return length;
}

//
//
// Function:    DCWbGraphicText::WriteExtra
//
// Purpose:     Write the extra (non-header) data to the flat representation
//              of the graphic.
//
//
void DCWbGraphicText::WriteExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::WriteExtra");

    // Allocate the memory
    PWB_GRAPHIC_TEXT pText = (PWB_GRAPHIC_TEXT) pHeader;

    // Get the font face name
    LOGFONT lfont;

    ::GetObject(m_hFont, sizeof(LOGFONT), &lfont);

    // Copy the face name into the flat object representation
    // The other information comes from the logical font details
    TRACE_MSG(("Font details height %d, avwidth %d, family %d, face %s",
                                                  lfont.lfHeight,
                                                  lfont.lfWidth,
                                                  lfont.lfPitchAndFamily,
                                                  lfont.lfFaceName));
  _tcscpy(pText->faceName, lfont.lfFaceName);

  pText->charHeight       = (short)lfont.lfHeight;
  pText->averageCharWidth = (short)lfont.lfWidth;
  pText->strokeWeight     = (short)lfont.lfWeight;
  pText->italic           = lfont.lfItalic;
  pText->underline        = lfont.lfUnderline;
  pText->strikeout        = lfont.lfStrikeOut;
  pText->pitch            = lfont.lfPitchAndFamily;



  //COMMENT BY RAND
  // Original DCL apps ignore WB_GRAPHIC_TEXT::codePage. I am using it here
  // to pass around the fonts script (character set). This might change later.
  // Apps that ignore this have set it to 0 which will be interpreted as an
  // ANSI_CHARSET.
  pText->codePage         = lfont.lfCharSet;

    // Loop through the text strings, adding each as we go
    char* pDest = pText->text;
    int iCount = strTextArray.GetSize();
    for (int iIndex = 0; iIndex < iCount; iIndex++)
    {
        _tcscpy(pDest, strTextArray[iIndex]);
        pDest += lstrlen(strTextArray[iIndex]);

        // Add the null terminator
        *pDest++ = '\0';
    }

    // Save the number of strings
    pText->stringCount = (TSHR_UINT16)iCount;
}

//
//
// Function:    DCWbGraphicText::ReadExtra
//
// Purpose:     Read the extra (non-header) data from the flat
//              representation of the graphic.
//
//
void DCWbGraphicText::ReadExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::ReadExtra");

  // Allocate the memory
  PWB_GRAPHIC_TEXT pText = (PWB_GRAPHIC_TEXT) pHeader;

  // Get the font details
  LOGFONT lfont;

  lfont.lfHeight            = (short)pText->charHeight;
//
  lfont.lfWidth             = pText->averageCharWidth;
  lfont.lfEscapement        = 0;
  lfont.lfOrientation       = 0;
  lfont.lfWeight            = pText->strokeWeight;
  lfont.lfItalic            = pText->italic;
  lfont.lfUnderline         = pText->underline;
  lfont.lfStrikeOut         = pText->strikeout;

  //COMMENT BY RAND
  // Original DCL apps ignore WB_GRAPHIC_TEXT::codePage. I am using it here
  // to pass around the fonts script (character set). This might change later.
  // Apps that ignore this have set it to 0 which will be interpreted as an
  // ANSI_CHARSET.
  lfont.lfCharSet			= (BYTE)pText->codePage;


  lfont.lfOutPrecision      = OUT_DEFAULT_PRECIS;
  lfont.lfClipPrecision     = CLIP_DEFAULT_PRECIS | CLIP_DFA_OVERRIDE;
  lfont.lfQuality           = DRAFT_QUALITY;
  lfont.lfPitchAndFamily    = pText->pitch;
  _tcscpy(lfont.lfFaceName, pText->faceName);
  TRACE_MSG(("Setting height to %d, width %d, pitch %d, face %s",
  pText->charHeight, pText->averageCharWidth, pText->pitch, pText->faceName));

    // Loop through the text strings, retrieving each as we go
    TCHAR* pString = pText->text;			
    int iCount = pText->stringCount;

    // Remove all the current stored text
    strTextArray.RemoveAll();
    strTextArray.SetSize(iCount);

    for (int iIndex = 0; iIndex < iCount; iIndex++)
    {
        strTextArray.SetAt(iIndex, pString);		
        pString += lstrlen(pString);

        // Skip the null terminator
        pString++;
    }

    // Set the current font
    SetFont(&lfont);

}

//
//
// Function:    InvalidateMetrics
//
// Purpose:     Mark the metrics need retrieving again
//
//
void DCWbGraphicText::InvalidateMetrics(void)
{
}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//	
BOOL DCWbGraphicText::CheckReallyHit(LPCRECT pRectHit )
{
    return( TRUE );
}




// version of Position() that compensates for kerning (bug 469)
void DCWbGraphicText::GetPosition(LPPOINT lppt)
{
    lppt->x = m_boundsRect.left + m_nKerningOffset;
    lppt->y = m_boundsRect.top;
}





//
//
// Function:    DCWbGraphicDIB::DCWbGraphicDIB
//
// Purpose:     Initialize a new drawn bitmap object.
//
//
DCWbGraphicDIB::DCWbGraphicDIB(void)
{
    // Show that we have no internal image
    m_lpbiImage = NULL;
}

DCWbGraphicDIB::DCWbGraphicDIB(PWB_GRAPHIC pHeader)
               : DCWbGraphic(pHeader)
{
    // Show that we have no internal image
    m_lpbiImage = NULL;
}

DCWbGraphicDIB::DCWbGraphicDIB
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
) : DCWbGraphic(hPage, hGraphic)
{
    // Show that we have no internal image
    m_lpbiImage = NULL;
}


//
//
// Function:    DCWbGraphicDIB::~DCWbGraphicDIB
//
// Purpose:     Destruct a drawn bitmap object.
//
//
DCWbGraphicDIB::~DCWbGraphicDIB(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::~DCWbGraphicDIB");

	// don't know if we are selected or not so just delete anyway
	if(g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}

	DeleteImage();
}


//
//
// Function:    DCWbGraphicDIB::SetImage
//
// Purpose:     Set the image of the object
//
//
void DCWbGraphicDIB::SetImage(LPBITMAPINFOHEADER lpbi)
{
    // Delete any current bits
    DeleteImage();

    // Save the DIB bits--this is a COPY we now own
    m_lpbiImage = lpbi;

    // Update the bounds rectangle
    CalculateBoundsRect();

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicDIB::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the bitmap
//
//
void DCWbGraphicDIB::CalculateBoundsRect()
{
    // If there is no bitmap set up, the bounding rectangle is empty
    if (m_lpbiImage == NULL)
    {
        ::SetRectEmpty(&m_boundsRect);
    }
    else
    {
        // Calculate the bounding rectangle from the size of the bitmap
        m_boundsRect.right = m_boundsRect.left + m_lpbiImage->biWidth;
        m_boundsRect.bottom = m_boundsRect.top + m_lpbiImage->biHeight;
    }
}

//
//
// Function:    DCWbGraphicDIB::CalculateExternalLength
//
// Purpose:     Return the length of the external representation of the
//              graphic.
//
//
DWORD DCWbGraphicDIB::CalculateExternalLength(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::CalculateExternalLength");

    // Use the internal representation to calculate the external length.
    DWORD dwLength = sizeof(WB_GRAPHIC_DIB);

    if (m_lpbiImage != NULL)
    {
        dwLength += DIB_TotalLength(m_lpbiImage);
    }
    else
    {
        // If we have got an external form already, use its length
        if (m_hGraphic != NULL)
        {
            dwLength = m_dwExternalLength;
        }
    }

    return dwLength;
}

//
//
// Function:    DCWbGraphicDIB::WriteExtra
//
// Purpose:     Write the data above and beyond the header to the pointer
//              passed.
//
//
void DCWbGraphicDIB::WriteExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::WriteExtra");

    // Nothing more to do if we do not have an image
    if (m_lpbiImage != NULL)
    {
        // Copy the data into place
        memcpy(((BYTE *) pHeader) + pHeader->dataOffset, m_lpbiImage,
            DIB_TotalLength(m_lpbiImage));
    }
}


//
//
// Function:    DCWbGraphicDIB::ReadExtra
//
// Purpose:     Read the data above and beyond the header to the pointer
//              passed.
//
//

//
// DCWbGraphicDIB does not have a ReadExtra function.  The Draw function
// uses the external data (if there is any) and the local data if there is
// not.
//

//
//
// Function:    DCWbGraphicDIB::CopyExtra
//
// Purpose:     Copy the data above and beyond the header into this object.
//
//
void DCWbGraphicDIB::CopyExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::CopyExtra");

    // Get a pointer to the DIB data
    LPBITMAPINFOHEADER lpbi;
    lpbi = (LPBITMAPINFOHEADER) (((BYTE *) pHeader) + pHeader->dataOffset);

    // Make a DIB copy
    ASSERT(m_lpbiImage == NULL);
    m_lpbiImage = DIB_Copy(lpbi);

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicDIB::FromScreenArea
//
// Purpose:     Set the content of the object from an area of the screen
//
//
void DCWbGraphicDIB::FromScreenArea(LPCRECT lprcScreen)
{
    LPBITMAPINFOHEADER lpbiNew;

    lpbiNew = DIB_FromScreenArea(lprcScreen);
    if (lpbiNew != NULL)
    {
        // Set this as our current bits
        SetImage(lpbiNew);
	}
	else
	{
        ::Message(NULL, (UINT)IDS_MSG_CAPTION, (UINT)IDS_CANTGETBMP, (UINT)MB_OK );
    }
}


//
//
// Function:    DCWbGraphicDIB::DeleteImage
//
// Purpose:     Delete the internal image
//
//
void DCWbGraphicDIB::DeleteImage(void)
{
    // If we have DIB bits, delete
    if (m_lpbiImage != NULL)
    {
        ::GlobalFree((HGLOBAL)m_lpbiImage);
        m_lpbiImage = NULL;
    }

    // Show our contents have changed
    m_bChanged = TRUE;
}


//
//
// Function:    DCWbGraphicDIB::GetDIBData
//
// Purpose:     Return a pointer to the DIB data
//
//
BOOL DCWbGraphicDIB::GetDIBData(HOLD_DATA& hold)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::GetDIBData");

    // Pointer to image data (set up below depending on whether
    // we have an internal or external image).
    hold.lpbi = NULL;
    hold.pHeader = NULL;

    // Draw depending on whether the DIB data is internal or external
    if (m_hGraphic == NULL)
    {
        // Do nothing if we do not have an image at all
        if (m_lpbiImage != NULL)
        {
            hold.lpbi = m_lpbiImage;
        }
    }
    else
    {
        // Lock the object data in the page
        hold.pHeader = (PWB_GRAPHIC) PG_GetData(m_hPage, m_hGraphic);
        if (hold.pHeader != NULL)
        {
            hold.lpbi = (LPBITMAPINFOHEADER) (((BYTE *) hold.pHeader)
                                              + hold.pHeader->dataOffset);
        }
    }

    return (hold.lpbi != NULL);
}

//
//
// Function:    DCWbGraphicDIB::ReleaseDIBData
//
// Purpose:     Release DIB data previously obtained with GetDIBData
//
//
void DCWbGraphicDIB::ReleaseDIBData(HOLD_DATA& hold)
{
    if ((m_hGraphic != NULL) && (hold.pHeader != NULL))
    {
        // Release external memory
        g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, hold.pHeader);
        hold.pHeader = NULL;
    }

    // Reset the hold bitmap info pointer
    hold.lpbi = NULL;
}

//
//
// Function:    DCWbGraphicDIB::Draw
//
// Purpose:     Draw the object onto the specified DC
//
//
void DCWbGraphicDIB::Draw(HDC hDC)
{
    RECT    clipBox;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Pointer to image data (set up below depending on whether
    // we have an internal or external image.
    HOLD_DATA hold;
    if (GetDIBData(hold))
    {
        // Set the stretch mode to be used so that scan lines are deleted
        // rather than combined. This will tend to preserve color better.
        int iOldStretchMode = ::SetStretchBltMode(hDC, STRETCH_DELETESCANS);

        // Draw the bitmap
        BOOL bResult = ::StretchDIBits(hDC,
                         m_boundsRect.left,
                         m_boundsRect.top,
                         m_boundsRect.right - m_boundsRect.left,
                         m_boundsRect.bottom - m_boundsRect.top,
                         0,
                         0,
                         (UINT) hold.lpbi->biWidth,
                         (UINT) hold.lpbi->biHeight,
                         (VOID FAR *) DIB_Bits(hold.lpbi),
                         (LPBITMAPINFO)hold.lpbi,
                         DIB_RGB_COLORS,
                         SRCCOPY);

        // Restore the stretch mode
        ::SetStretchBltMode(hDC, iOldStretchMode);

        // Release external memory
        ReleaseDIBData(hold);
    }

}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicDIB::CheckReallyHit(LPCRECT pRectHit)
{
    return( TRUE );
}




ObjectTrashCan::~ObjectTrashCan(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::~ObjectTrashCan");

	BurnTrash();
}




BOOL ObjectTrashCan::GotTrash( void )
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::GotTrash");

	return(!Trash.IsEmpty());
}





void ObjectTrashCan::BurnTrash( void )
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::BurnTrash");

	int nObjects;
	int i;

	// zap objects
    POSITION pos = Trash.GetHeadPosition();
    while (pos != NULL)
    {
		delete Trash.GetNext(pos);
    }


	// zap pointers
	EmptyTrash();

	}





void ObjectTrashCan::CollectTrash( DCWbGraphic *pGObj )
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::CollectTrash");

		Trash.AddTail(pGObj); // stuff it in the sack
		m_hPage = pGObj->Page();
}





void
	ObjectTrashCan::EmptyTrash( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::EmptyTrash");

	// zap pointers but leave objects scattered about the room
	Trash.EmptyList();

	}





void ObjectTrashCan::AddToPageLast
(
    WB_PAGE_HANDLE   hPage
)
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::AddToPageLast");

	int nObjects;
	int i;

	POSITION posNext = Trash.GetHeadPosition();
	while( posNext != NULL )
	{
		((DCWbGraphic *)(Trash.GetNext(posNext)))->AddToPageLast(hPage);
	}
}




void
	ObjectTrashCan::SelectTrash( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::SelectTrash");

	int nObjects;
	int i;
	BOOL bForceAdd;
	DCWbGraphic *pGObj;

		// Zap current selection with first object and then add remaining
		// objects to current selection
		bForceAdd = FALSE;
		POSITION posNext = Trash.GetHeadPosition();
		while( posNext != NULL )
		{
			pGObj = (DCWbGraphic *)(Trash.GetNext(posNext));
            g_pMain->m_drawingArea.SelectGraphic( pGObj, TRUE, bForceAdd );

			bForceAdd = TRUE;
		}

	}










CPtrToPtrList::CPtrToPtrList( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::CPtrToPtrList");

	}// CPtrToPtrList::CPtrToPtrList




CPtrToPtrList::~CPtrToPtrList( void )
{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::~CPtrToPtrList");

	RemoveAll();

}// CPtrToPtrList::~CPtrToPtrList



void
	CPtrToPtrList::RemoveAll( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::RemoveAll");

	POSITION   pos;
	stPtrPair *pPp;

	// clean up pairs
	pos = GetHeadPosition();
	while( pos != NULL )
	{
		pPp = (stPtrPair *)GetNext( pos );
		if( pPp != NULL )
			delete pPp;
	}
	COBLIST::EmptyList();
	}// CPtrToPtrList::~CPtrToPtrList










void
	CPtrToPtrList::SetAt( void *key, void *newValue )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::SetAt");

	stPtrPair *pPp;

	// see if key is already there
	pPp = FindMainThingPair( key, NULL );
	if( pPp != NULL )
		{
		// it's there, we're just updating its value
		pPp->pRelatedThing = newValue;
		}
	else
		{
		// this is a new entry
		pPp = new stPtrPair;
		if( pPp != NULL )
	    {
			pPp->pMainThing = key;
			pPp->pRelatedThing = newValue;

			AddTail(pPp);
		}
		else
		{
		    ERROR_OUT( ("CPtrToPtrList: can't alloc stPtrPair") );
		}
	}

	}// CPtrToPtrList::SetAt










BOOL
	CPtrToPtrList::RemoveKey( void *key )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::RemoveKey");

	POSITION pos;
	stPtrPair *pPp;

	pPp = FindMainThingPair( key, &pos );
	if( pPp != NULL )
		{
		RemoveAt( pos );
		delete pPp;
		return( TRUE );
		}
	else
		return( FALSE );

}// CPtrToPtrList::RemoveKey





void
	CPtrToPtrList::GetNextAssoc( POSITION &rNextPosition, void *&rKey, void *&rValue )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::GetNextAssoc");

	stPtrPair *pPp;

	pPp = (stPtrPair *)GetNext( rNextPosition );
	if( pPp != NULL )
		{
		rKey = pPp->pMainThing;
		rValue = pPp->pRelatedThing;
		}
	else
		{
		rKey = NULL;
		rValue = NULL;
		}

	}// CPtrToPtrList::GetNextAssoc










BOOL
	CPtrToPtrList::Lookup( void *key, void *&rValue )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::Lookup");

	stPtrPair *pPp;

	pPp = FindMainThingPair( key, NULL );
	if( pPp != NULL )
		{
		rValue = pPp->pRelatedThing;
		return( TRUE );
		}
	else
		{
		rValue = NULL;
		return( FALSE );
		}

	}// CPtrToPtrList::Lookup










CPtrToPtrList::stPtrPair *
	CPtrToPtrList::FindMainThingPair( void *pMainThing, POSITION *pPos )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::FindMainThingPair");

	POSITION   pos;
	POSITION   lastpos;
	stPtrPair *pPp;

	if( pPos != NULL )
		*pPos = NULL;

	// look for pair containing pMainThing
	pos = GetHeadPosition();
	while( pos != NULL )
		{
		lastpos = pos;
		pPp = (stPtrPair *)GetNext( pos );
		if( pPp->pMainThing == pMainThing )
			{
			if( pPos != NULL )
				*pPos = lastpos;

			return( pPp );
			}
		}

	// didn't find it
	return( NULL );

	}// CPtrToPtrList::FindMainThingPair



#define ARRAY_INCREMENT 0x200

DCDWordArray::DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::DCDWordArray");
	m_Size = 0;
	m_MaxSize = ARRAY_INCREMENT;
	m_pData = new POINT[ARRAY_INCREMENT];
    if (!m_pData)
    {
        ERROR_OUT(("Failed to allocate m_pData POINT array"));
    }
}

DCDWordArray::~DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::~DCDWordArray");

	delete[] m_pData;
}

//
// We need to increase the size of the array
//
BOOL DCDWordArray::ReallocateArray(void)
{
	POINT *pOldArray =  m_pData;
	m_pData = new POINT[m_MaxSize];
	
	if(m_pData)
	{
		TRACE_DEBUG((">>>>>Increasing size of array to hold %d points", m_MaxSize));
	
		// copy new data from old
		memcpy( m_pData, pOldArray, (m_Size) * sizeof(POINT));

		TRACE_DEBUG(("Deleting array of points %x", pOldArray));
		delete[] pOldArray;
		return TRUE;
	}
	else
	{
        ERROR_OUT(("Failed to allocate new POINT array of size %d", m_MaxSize));
		m_pData = pOldArray;
		return FALSE;
	}
}

//
// Add a new point to the array
//
void DCDWordArray::Add(POINT point)
{

	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::Add");
	TRACE_DEBUG(("Adding point(%d,%d) at %d", point.x, point.y, m_Size));
	TRACE_DEBUG(("Adding point at %x", &m_pData[m_Size]));

	if(m_pData == NULL)
	{
		return;
	}
	
	m_pData[m_Size].x = point.x;
	m_pData[m_Size].y = point.y;
	m_Size++;

	//
	// if we want more points, we need to re allocate the array
	//
	if(m_Size == m_MaxSize)
	{
		m_MaxSize +=ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			m_Size--;
		}
	}
}

//
// Return the number of points in the array
//
UINT DCDWordArray::GetSize(void)
{
	return m_Size;
}

//
// Sets the size of the array
//
void DCDWordArray::SetSize(UINT size)
{
	int newSize;
	//
	// if we want more points, we need to re allocate the array
	//
	if (size > m_MaxSize)
	{
		m_MaxSize= ((size/ARRAY_INCREMENT)+1)*ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			return;
		}
	}
	m_Size = size;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\grobj.hpp ===
//
// GROBJ.CPP
// Graphic Object Classes
//
// Copyright Microsoft 1998-
//
#ifndef __GROBJ_HPP_
#define __GROBJ_HPP_


#define HIT_WINDOW	1
#define MAKE_HIT_RECT(r, p )  \
    ::SetRect(&r, p.x-HIT_WINDOW, p.y-HIT_WINDOW, p.x+HIT_WINDOW, p.y+HIT_WINDOW);
	

//
// Marker definitions
//
#define NO_HANDLE    -1
#define TOP_LEFT      0
#define TOP_MIDDLE    1
#define TOP_RIGHT     2
#define RIGHT_MIDDLE  3
#define BOTTOM_RIGHT  4
#define BOTTOM_MIDDLE 5
#define BOTTOM_LEFT   6
#define LEFT_MIDDLE   7

//
// Definitions for text objects
//
#define LAST_LINE -1
#define LAST_CHAR -2

//
// Maximum number of points in a freehand object - determined by the fact
// that pointCount is held in a TSHR_UINT16 in WB_GRAPHIC_FREEHAND (awbdef.h)
//
#define MAX_FREEHAND_POINTS     65535


BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth, LPCRECT lpHitRect );


// Class to simulate CMapPtrToPtr but based on a linked list instead of the order-jumbling
// hashing method. This is the major cause of bug 354. I'm doing this instead of just replacing 
// CMapPtrToPtr because it is used in a zillion places and I want to minimize changes to the
// multi-object select logic so that I don't break it.
class CPtrToPtrList : public COBLIST
{

public:
	CPtrToPtrList( void );
	~CPtrToPtrList(void);
	
	void SetAt( void *key, void *newValue );
	BOOL RemoveKey( void *key );
	void RemoveAll( void );

	void GetNextAssoc( POSITION &rNextPosition, void *&rKey, void *&rValue ) ;
	BOOL Lookup( void *key, void *&rValue );


protected:
struct stPtrPair
		{
		void *pMainThing;
		void *pRelatedThing;
		};

	stPtrPair *FindMainThingPair( void *pMainThing, POSITION *pPos );
};





//
//
// Class:   DCWbGraphic
//
// Purpose: Base graphic object class
//
//
class WbDrawingArea;

enum 
{
	enumGraphicMarker,
	enumGraphicFreeHand,
	enumGraphicFilledRectangle,
	enumGraphicFilledEllipse,
	enumGraphicText,
    enumGraphicDIB,
	enumGraphicPointer,
	enumNoGraphicTool
};



class DCWbGraphic
{
public:
    //
    // Static graphic construction routines - return a pointer to a graphic
    // of the relevant type given a page and graphic handle or a pointer to
    // a flat graphic representation.
    //
    static DCWbGraphic* ConstructGraphic(WB_PAGE_HANDLE hPage,
                                         WB_GRAPHIC_HANDLE hGraphic);

    static DCWbGraphic* ConstructGraphic(PWB_GRAPHIC pHeader);

    static DCWbGraphic* ConstructGraphic(WB_PAGE_HANDLE hPage,
									     WB_GRAPHIC_HANDLE hGraphic,
										 PWB_GRAPHIC pHeader);

    static DCWbGraphic* CopyGraphic(PWB_GRAPHIC pHeader);


    //
    // Constructor.
    //
    DCWbGraphic(PWB_GRAPHIC pHeader = NULL);
    DCWbGraphic(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE _hGraphic);
    virtual ~DCWbGraphic( void );


	virtual UINT IsGraphicTool(void) = 0;

    //
    // Get/set the bounding rectangle of the graphic object (in logical
    // co-ordinates).
    //
    virtual void    GetBoundsRect(LPRECT lprc) { *lprc = m_boundsRect; }
    virtual void    SetBoundsRect(LPCRECT lprc);

    //
    // Get the size of the object
    //
    virtual int   Width(void) { return(m_boundsRect.right - m_boundsRect.left); }
    virtual int   Height(void) { return(m_boundsRect.bottom - m_boundsRect.top); }

    //
    // Get/set the defining rectangle of the graphic - this is only set up
    // for some object types e.g.  rectangles and ellipses.
    //
    virtual LPCRECT GetRect(void) const { return(&m_rect); }
    virtual void   SetRect(LPCRECT lprc);
    virtual void   SetRectPts(POINT ptStart, POINT ptEnd);

    //
    // Get/set the color the object will be drawn in
    //
    virtual void     SetColor(COLORREF clr);
    virtual COLORREF GetColor(void) //CHANGED BY RAND for PALETTERGB
		{ return( SET_PALETTERGB(m_clrPenColor ) ); }

    //
    // Get/set the width of the pen used to draw the object
    //
    virtual void SetPenWidth(UINT uiWidth);
    virtual UINT GetPenWidth(void) { return m_uiPenWidth; }

    //
    // Get/set the raster op to be used to draw the object
    //
    virtual void SetROP(int iPenROP);
    virtual int  GetROP(void) { return m_iPenROP; }

    //
    // Get/set the pen style
    //
    virtual void SetPenStyle(int iPenStyle);
    virtual int  GetPenStyle(void) { return m_iPenStyle; }

    //
    // Translates the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Set the top left corner of the object's bounding rectangle to the
    // point specified as parameter.
    //
    virtual void MoveTo(int x, int y);

    //
    // Return the top left corner of the objects bounding rectangle.
    //
    virtual void GetPosition(LPPOINT lpt);

    //
    // Return TRUE if the specified point is inside the bounding rectangle
    // of the graphic object.
    //
    virtual BOOL PointInBounds(POINT pt);

    //
    // Draw the graphic object into the device context specified.
    //
    virtual void Draw(HDC hDC)
					{return;}
    virtual void Draw(HDC hDC, WbDrawingArea * pDrawingArea)
                    { Draw(hDC); }
    virtual void Draw(HDC hDC, BOOL thumbNail)
                    { Draw(hDC); }

    //
    // Return the page of the graphic object
    //
    virtual WB_PAGE_HANDLE Page(void) const { return m_hPage; }

    //
    // Return the handle of the graphic object
    //
    virtual WB_GRAPHIC_HANDLE Handle(void) const { return m_hGraphic; }
    virtual void ZapHandle(void) {m_hGraphic = NULL;}

    //
    // Return TRUE if the graphic is topmost on its page
    //
    virtual BOOL IsTopmost(void);

    //
    // Update the external version of the graphic
    //
    virtual void ForceReplace(void);
    virtual void Replace(void);
    virtual void ForceUpdate(void); 
    virtual void Update(void);
    virtual void Delete(void);

    //
    // Confirm an update or delete of the graphic
    //
    virtual void ReplaceConfirm(void);
    virtual void UpdateConfirm(void);
    virtual void DeleteConfirm(void);


	
	virtual BOOL CheckReallyHit(LPCRECT pRectHit)
	{
        RECT    rcT;
        return(!IntersectRect(&rcT, &m_boundsRect, pRectHit));
	}


    //
    // Lock and unlock the graphic - the lock or unlock will only take
    // effect the next time the graphic is updated or replaced.
    //
    void Lock(void);
    void Unlock(void);
    BOOL Locked(void) { return (m_uiLockState == WB_GRAPHIC_LOCK_REMOTE); }
    BOOL GotLock(void) { return (m_uiLockState == WB_GRAPHIC_LOCK_LOCAL); }
    void ClearLockFlag(void) {m_uiLockState = WB_GRAPHIC_LOCK_NONE;}

	UINT GetLockState( void )
		{return( m_uiLockState );}

	void SetLockState( UINT uLock )
		{m_uiLockState = uLock;}

    //
    // Add this graphic to the specified page.  This member must only be
    // called if the graphic does not yet belong to a page (i.e.  if
    // hGraphic is NULL).
    //
    virtual void AddToPageLast(WB_PAGE_HANDLE hPage);

    //
    // Return a copy of the graphic - this is a complete copy with all
    // data read into internal memory.
    //
    virtual DCWbGraphic* Copy(void) const;

    //
    // Return TRUE if the graphic has changed since it was last read/written
    // from    external storage.
    //
    virtual BOOL Changed(void) const { return m_bChanged; }

    //
    // Get/set the type of tool which drew the graphic, or at least one
    // which can be used to manipulate it.
    //
    void GraphicTool(int toolType)
                     { m_toolType = toolType; m_bChanged = TRUE; }
    int  GraphicTool(void) { return m_toolType; }

    //
    // Return the length of the external representation of the object
    //
    DWORD ExternalLength(void) 
		{return(m_dwExternalLength );}

protected:
    //
    // Initialize the member variables
    //
    virtual void Initialize(void);

    //
    // Bounding rectangle calculation
    //
    virtual void CalculateBoundsRect(void) { m_boundsRect = m_rect; }

    //
    // Ensure that a rectangle has top left to the left of and above bottom
    // right.
    //
    void NormalizeRect(LPRECT lprc);

    //
    // Type of the graphic (used in the external representation)
    //
    virtual UINT Type(void) const { return 0; }

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void)
                                           { return sizeof(WB_GRAPHIC); }

    //
    // Convert between internal and external representations
    //
    virtual void ReadExternal(void);
    virtual void ReadHeader(PWB_GRAPHIC pHeader);
    virtual void ReadExtra(PWB_GRAPHIC) {}
    virtual void CopyExtra(PWB_GRAPHIC) {}

    virtual void WriteExternal(PWB_GRAPHIC pHeader);
    virtual void WriteHeader(PWB_GRAPHIC pHeader);
    virtual void WriteExtra(PWB_GRAPHIC) {}

    //
    // Page on which this object belongs
    //
    WB_PAGE_HANDLE m_hPage;

    //
    // Whiteboard Core handle for the object
    //
    WB_GRAPHIC_HANDLE m_hGraphic;

    //
    // Flag indicating whether the graphic has changed since it was last
    // read from external storage.
    //
    BOOL m_bChanged;

    //
    // Graphic header details
    //
    DWORD    m_dwExternalLength;  // Length of the object
    RECT     m_boundsRect;      // Bounding
    RECT     m_rect;            // Defining
    COLORREF m_clrPenColor;       // Color of pen as RGB
    UINT     m_uiPenWidth;        // Width in logical units
    int      m_iPenROP;           // Raster operation to be used for drawing
    int      m_iPenStyle;         // Pen style to be used for drawing
    UINT     m_uiLockState;       // Lock indicator
    int      m_toolType;          // Type of tool used to create the graphic
};

//
//
// Class:   DCWbGraphicMarker
//
// Purpose: Class representing an object marker. This is a set of eight
//          handles drawn at intervals round the objects bounding rectangle.
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicMarker : public DCWbGraphic
{

friend class DCWbGraphicSelectTrackingRectangle;

  public:
    //
    // Constructors
    //
    DCWbGraphicMarker(void);
    ~DCWbGraphicMarker(void);

	UINT IsGraphicTool(void) { return enumGraphicMarker;}

	
	// Rect that bounds all objs in RectList
    virtual void GetBoundsRect(LPRECT lprc);

	// Deletes all marker rects in RectList
	void DeleteAllMarkers( DCWbGraphic *pLastSelectedGraphic, 
						   BOOL bLockLastSelectedGraphic = FALSE ); 

	// Deletes one marker
	void DeleteMarker( DCWbGraphic *pGraphic ); 

	// Sees if obj is already in marker
	DCWbGraphic *HasAMarker( DCWbGraphic *pGraphic );

	// Gets last marker
    DCWbGraphic *LastMarker( void );

	// Gets number of markers in marker list
	int	GetNumMarkers( void );

	// Moves all selected objects by offset
    virtual void MoveBy(int cx, int cy);

	// Updates selected remote objects
    void Update( void );

	// Checks for point hitting any marker obj
	BOOL PointInBounds(POINT pt);

	// Changes color for selection
	void SetColor(COLORREF color);

	// Changes width of selection
	void SetPenWidth(UINT uiWidth);

	// Changes font of selection (text objs only)
	void SetSelectionFont(HFONT hFont);

	//Deletes all objs in selection
	void DeleteSelection( void );

	//Brings all objs in selection to top
	void BringToTopSelection( void );

	//Sends all objs to bottom
	void SendToBackSelection( void );

	//Renders marker objects to a multi-obj format and copies to the 
	// clipboard
	BOOL RenderPrivateMarkerFormat( void );

	//Pastes multi-obj clipboard data
	void Paste( HANDLE handle ); 


    //
    // Set the object defining rectangle - this is only set up for some
    // object types e.g. rectangles and ellipses.
    //
    BOOL    SetRect(LPCRECT lprc, DCWbGraphic *pGraphic, BOOL bRedraw,
				BOOL bLockObject = TRUE );

    //
    // Return an indication of which handle the specified point lies in.
    //
    int PointInMarker(POINT pt);

    //
    // Draw the marker
    //
    void Draw(HDC hDC, BOOL bDrawObjects = FALSE );
    void Undraw(HDC hDC, WbDrawingArea * pDrawingArea);

	void DrawRect( HDC hDC, LPCRECT pMarkerRect,
				   BOOL bDrawObject, DCWbGraphic *pGraphic );
	void UndrawRect(HDC hDC, WbDrawingArea * pDrawingArea,
					LPCRECT pMarkerRect );

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	void Present( BOOL bOn )
		{m_bMarkerPresent = bOn;}

  protected:
    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);

    //
    // Marker rectangle calculation
    //
    void CalculateMarkerRectangles(void);

    //
    // Marker rectangle
    //
    RECT    m_markerRect;
	CPtrToPtrList MarkerList; // keys are DCWbGraphic pointers, 
							 // values are LPRECT pointers.
	BOOL m_bMarkerPresent;

	
	void UndrawMarker(LPCRECT pMarkerREct);

    //
    // Brush used to draw the marker rectangle
    //
    HBRUSH  m_hMarkerBrush;
};





//
//
// Class:   DCWbGraphicLine
//
// Purpose: Class representing straight line
//
//
class DCWbGraphicLine : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicLine(void) { }
    DCWbGraphicLine(PWB_GRAPHIC pHeader)
      : DCWbGraphic(pHeader) { }
    DCWbGraphicLine(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphic(hPage, hGraphic) { }

    ~DCWbGraphicLine(void);

    //
    // Set the object start and end points
    //
    void SetStart(POINT ptStart);
    void SetEnd(POINT ptEnd);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_LINE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicTrackingLine
//
// Purpose: Class representing an XORed straight line (for rubber banding)
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicTrackingLine : public DCWbGraphicLine
{

  public:
    //
    // Constructor
    //
    DCWbGraphicTrackingLine(void) { SetROP(R2_NOTXORPEN); };
};

//
//
// Class:   DCWbGraphicFreehand
//
// Purpose: Class representing multiple line segments
//
//


class DCDWordArray
{



  public:
	DCDWordArray(void);
	~DCDWordArray(void);
	
    void Add(POINT point);
	BOOL ReallocateArray(void);
	POINT* GetBuffer(void) { return m_pData; }
    void SetSize(UINT size);
	UINT GetSize(void);

    POINT* operator[](UINT index){return &(m_pData[index]);}
	
  private:

	POINT*  m_pData;
	UINT	m_Size;
	UINT	m_MaxSize;

  
    
};
/////////////

class DCWbGraphicFreehand : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicFreehand(void);
    DCWbGraphicFreehand(PWB_GRAPHIC pHeader);
    DCWbGraphicFreehand(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);

    ~DCWbGraphicFreehand(void);

	UINT IsGraphicTool(void) { return enumGraphicFreeHand;}

    //
    // Add a point to the list, returning success
    //
    BOOL AddPoint(POINT pt);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_FREEHAND; }

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void);

    //
    // Convert between internal and external representations
    //
    void WriteExtra(PWB_GRAPHIC pHeader);
    void ReadExtra(PWB_GRAPHIC pHeader);

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
    void AddPointToBounds(int x, int y);


    //
    // Array holding point information
    //
    DCDWordArray points;   //CHANGED BY RAND

    //
    // Spline curve smoothing drawing functions
    //
    void DrawUnsmoothed(HDC hDC);
};

//
//
// Class:   DCWbGraphicRectangle
//
// Purpose: Class representing a rectangle
//
//
class DCWbGraphicRectangle : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicRectangle(void) { }
    DCWbGraphicRectangle(PWB_GRAPHIC pHeader)
      : DCWbGraphic(pHeader) { }
    DCWbGraphicRectangle(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphic(hPage, hGraphic) { }

    ~DCWbGraphicRectangle(void);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}

    //
    // Set the defining rectangle
    //
    void   SetRect(LPCRECT lprc);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_RECTANGLE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicTrackingRectangle
//
// Purpose: Class representing an XORed rectangle (for rubber banding)
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicTrackingRectangle : public DCWbGraphicRectangle
{

  public:
        //
        // Constructor
        //
        DCWbGraphicTrackingRectangle(void) { SetROP(R2_NOTXORPEN); };
};




class DCWbGraphicSelectTrackingRectangle : public DCWbGraphicRectangle
{

  public:
    //
    // Constructor
    //
    DCWbGraphicSelectTrackingRectangle(void) 
		{SetROP(R2_NOTXORPEN); m_Offset.cx = 0; m_Offset.cy = 0; }

    void Draw( HDC hDC);
	virtual void MoveBy(int cx, int cy);

protected:
	SIZE m_Offset;
};




//
//
// Class:   DCWbGraphicFilledRectangle
//
// Purpose: Class representing a filled rectangle
//
//
class DCWbGraphicFilledRectangle : public DCWbGraphicRectangle
{

  public:
    //
    // Constructors
    //
    DCWbGraphicFilledRectangle(void) { }
    DCWbGraphicFilledRectangle(PWB_GRAPHIC pHeader)
      : DCWbGraphicRectangle(pHeader) { }
    DCWbGraphicFilledRectangle(WB_PAGE_HANDLE hPage,
                               WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphicRectangle(hPage, hGraphic) { }

    ~DCWbGraphicFilledRectangle(void);

	UINT IsGraphicTool(void) { return enumGraphicFilledRectangle;}

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_FILLED_RECTANGLE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicEllipse
//
// Purpose: Class representing an ellipse
//
//
class DCWbGraphicEllipse : public DCWbGraphic
{

  public:
    //
    // Constructor
    //
    DCWbGraphicEllipse(void) { }
    DCWbGraphicEllipse(PWB_GRAPHIC pHeader)
      : DCWbGraphic(pHeader) { }
    DCWbGraphicEllipse(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphic(hPage, hGraphic) { }

    ~DCWbGraphicEllipse(void);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}
	
    //
    // Set the defining rectangle
    //
    void   SetRect(LPCRECT lprc);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit(LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_ELLIPSE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicTrackingEllipse
//
// Purpose: Class representing an XORed ellipse (for rubber banding)
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicTrackingEllipse : public DCWbGraphicEllipse
{

  public:
    //
    // Constructors
    //
    DCWbGraphicTrackingEllipse(void) { SetROP(R2_NOTXORPEN); };
};

//
//
// Class:   DCWbGraphicFilledEllipse
//
// Purpose: Class representing a filled ellipse
//
//
class DCWbGraphicFilledEllipse : public DCWbGraphicEllipse
{

  public:
    //
    // Constructor
    //
    DCWbGraphicFilledEllipse(void) { }
    DCWbGraphicFilledEllipse(PWB_GRAPHIC pHeader)
      : DCWbGraphicEllipse(pHeader) { }
    DCWbGraphicFilledEllipse(WB_PAGE_HANDLE hPage,
                 WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphicEllipse(hPage, hGraphic) { }

    ~DCWbGraphicFilledEllipse(void);

	UINT IsGraphicTool(void) { return enumGraphicFilledEllipse;}

    //
    // Draw the object
    //
    void Draw(HDC hDC);

	
	virtual BOOL CheckReallyHit(LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_FILLED_ELLIPSE; }
    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicText
//
// Purpose: Class representing a text object
//
//
class DCWbGraphicText : public DCWbGraphic
{

  // Friend declaration for text editing
  friend class WbTextEditor;

  // Friend declaration for copying to the clipboard
  friend class WbMainWindow;

  public:
    //
    // Constructors
    //
    DCWbGraphicText(void);
    DCWbGraphicText(PWB_GRAPHIC pHeader);
    DCWbGraphicText(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);

    //
    // Destructor
    //
    ~DCWbGraphicText(void);

	UINT IsGraphicTool(void) { return enumGraphicText;}
    //
    // Set the text of the object
    //
    virtual void SetText(TCHAR * strText);
    virtual void SetText(const StrArray& strTextArray);

    //
    // Get/Set the font for drawing the text
    //
    virtual void SetFont(HFONT hFont);
    virtual void SetFont(LOGFONT *pLogFont, BOOL bReCalc=TRUE );
    virtual HFONT GetFont(void) {return m_hFont;};

    //
    // Draw - draw the object
    //
    void Draw(HDC hDC) { Draw(hDC, FALSE); };
    void Draw(HDC hDC, BOOL thumbNail);

    //
    // InvalidateMetrics - flag metrics need to be reread
    //
    void InvalidateMetrics(void);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
    void SetPenWidth(UINT) { };
    void SetROP(int) { };
    void SetPenStyle(int) { };
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

    virtual void GetPosition(LPPOINT lppt); // added for bug 469

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_TEXT; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void);

    //
    // Convert between internal and external representations
    //
    void WriteExtra(PWB_GRAPHIC pHeader);
    void ReadExtra(PWB_GRAPHIC pHeader);

    //
    // Calculate the rectangle of a portion of a single line of text
    //
    ABC GetTextABC( LPCTSTR strText,
                   int iStartX,
                   int iStopX);
    void GetTextRectangle(int iStartY,
                           int iStartX,
                           int iStopX,
                           LPRECT lprc);
    void CalculateRect(int iStartX,
                        int iStartY,
                        int iStopX,
                        int iStopY,
                        LPRECT lprc);

    //
    // Array for storing text
    //
    StrArray    strTextArray;

    //
    // Font details
    //
    HFONT       m_hFont;
    HFONT       m_hFontThumb;
	BOOL		m_bFirstSetFontCall;
	LONG		m_nKerningOffset; // added for bug 469

  public:
    TEXTMETRIC   m_textMetrics;
};


//
//
// Class:   DCWbGraphicDIB
//
// Purpose: Class representing a drawn DI bitmap object
//
//
typedef struct tagHOLD_DATA
{
  PWB_GRAPHIC        pHeader;
  LPBITMAPINFOHEADER lpbi;
} 
HOLD_DATA;

class DCWbGraphicDIB : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicDIB(void);
    DCWbGraphicDIB(PWB_GRAPHIC pHeader);
    DCWbGraphicDIB(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE _hGraphic);

    UINT IsGraphicTool(void) { return enumGraphicDIB; }

    //
    // Destructor
    //
    ~DCWbGraphicDIB(void);

    //
    // Set the contents of the bitmap
    //
    void SetImage(LPBITMAPINFOHEADER lpbi);

    //
    // Set the contents of the bitmap from the screen
    //
    void FromScreenArea(LPCRECT lprcScreen);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Delete the image currently held internally (if any)
    //
    void DeleteImage(void);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
    void SetPenWidth(UINT) { };
    void SetColor(COLORREF) { };
    void SetROP(int) { };
    void SetPenStyle(int) { };

	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_DIB; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void);

    //
    // Convert between internal and external representations
    //
    void WriteExtra(PWB_GRAPHIC pHeader);
    void CopyExtra(PWB_GRAPHIC pHeader);

    //
    // Get the DIB data
    //
    BOOL GetDIBData(HOLD_DATA& hold);
    void ReleaseDIBData(HOLD_DATA& hold);

    // Pointer to the DIB bits
    LPBITMAPINFOHEADER  m_lpbiImage;
};






class ObjectTrashCan : public DCWbGraphic
	{

public:
    ~ObjectTrashCan(void);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}

	BOOL GotTrash( void );
	void CollectTrash( DCWbGraphic *pGObj );
	void SelectTrash( void );
	void EmptyTrash( void );
	void BurnTrash( void );
    virtual void AddToPageLast(WB_PAGE_HANDLE hPage);

protected:
	COBLIST Trash;

	};


#endif // __GROBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\grptr.hpp ===
//
// GRPTR.HPP
// Graphic Pointer Class
//
// Copyright Microsoft 1998-
//

#ifndef __GRPTR_HPP_
#define __GRPTR_HPP_

typedef struct COLOREDICON
{
	HICON    hIcon;
 	COLORREF color;
} COLORED_ICON;


//
//
// Class:   DCWbGraphicPointer
//
// Purpose: Class representing a remote pointer.
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicPointer : public DCWbGraphic
{
friend class WbUser;

public:
    //
    // Constructors
    //
    DCWbGraphicPointer(WbUser* _pUser);

    //
    // Destructor
    //
    ~DCWbGraphicPointer(void);

	UINT IsGraphicTool(void) { return enumGraphicPointer;}


    //
    // Return the rectangle in which the pointer was last drawn. The
    // rectangle will be empty if the pointer is not currently drawn. Use
    // BoundsRect to get the rectangle which will be occupied by the pointer
    // when it is next drawn.
    //
    void GetDrawnRect(LPRECT lprc);

    //
    // Activate and deactivate the pointer
    //
    BOOL IsActive(void) const { return m_bActive; }
    void SetActive(WB_PAGE_HANDLE hPage, POINT point);
    void SetInactive(void);

    //
    // Set the color of the pointer
    //
    void SetColor(COLORREF newColor);

    //
    // Get and set the current page of the pointer
    //
    WB_PAGE_HANDLE GetPage(void) const;
    void     SetPage(WB_PAGE_HANDLE hNewPage);
    WbUser * GetUser(void) const { return(m_pUser); }

    //
    // Return TRUE if this is the local user's pointer
    //
    BOOL IsLocalPointer(void) const;

    //
    // Draw the pointer
    //
    void Draw(HDC hDC) { Draw(hDC, (WbDrawingArea *)NULL); }
    void Draw(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Draw the pointer after saving the bits under it to memory
    //
    void DrawSave(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Erase the pointer from its old position and redraw it in its current
    // position.
    //
    void Redraw(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Undraw the pointer
    //
    void Undraw(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Update the user information with the pointer position
    //
    virtual void Update(void);

    //
    // Operators
    //
    virtual BOOL operator!=(const DCWbGraphicPointer& pointer) const;
    virtual BOOL operator==(const DCWbGraphicPointer& pointer) const;

  protected:
    //
    // Zoom factor set from WBDRAW
    //
    int m_iZoomSaved;

    //
    // Create the icon of the correct color for this user
    //
    HICON CreateColoredIcon(COLORREF color);

    //
    // Create the bitmap for saving the screen data under the pointer
    //
    void CreateSaveBitmap(WbDrawingArea * pDrawingArea);

    //
    // Draw or undraw the pointer (screen and memory versions)
    //
    BOOL SaveScreen(HDC hDC, WbDrawingArea * pDrawingArea);
    BOOL UndrawScreen(HDC hDC, WbDrawingArea * pDrawingArea);
    BOOL CopyFromScreen(HDC hDC, WbDrawingArea * pDrawingArea);
    BOOL CopyToScreen(HDC hDC, WbDrawingArea * pDrawingArea);

    BOOL DrawMemory(void);
    BOOL UndrawMemory(void);
    BOOL SaveMemory(void);

    //
    // Manipulate the display DC for pointer operations
    //
    void PointerDC(HDC hDC, WbDrawingArea * pDrawingArea,
                   LPRECT lprc, int zoom = 0);
    void SurfaceDC(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // The user associated with this pointer
    //
    WbUser*     m_pUser;

    //
    // Flag indicating whether the pointer is active
    //
    BOOL        m_bActive;

    //
    // Pointer to the bitmap used to save the data under the pointer
    //
    HBITMAP     m_hSaveBitmap;

    //
    // Handle of bitmap originally supplied with memDC
    //
    HBITMAP     m_hOldBitmap;

    //
    // Device context used for drawing and undrawing the pointer
    //
    HDC         m_hMemDC;

    //
    // Handle of icon to be used for drawing
    //
    HICON       m_hIcon;

    //
    // Width and height of the pointer
    //
    UINT        m_uiIconWidth;
    UINT        m_uiIconHeight;

    //
    // Flag indicating whether the pointer is drawn
    //
    BOOL        m_bDrawn;

    //
    // Rectangle in which the pointer was last drawn
    //
    RECT        m_rectLastDrawn;
};


#endif // __GRPTR_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\grptr.cpp ===
//
// GRPTR.CPP
// More Graphic Objects
//
// Copyright Microsoft 1998-
//

//
// The remote pointer is handled by blitting to and from the screen to a
// memory bitmap rather than letting Windows draw it.  This is to get a
// reasonably continuous tracking of the pointer.
//
// In order to do this we create a memory bitmap that is the pointer size
// times 2 by 3. The top left square of the 2*3 array is used to hold the
// screen contents before the pointer is written.  It may be used at any
// time to remove the pointer from the screen.  The lower 2*2 square is
// used to hold the currently displayed pointer plus surrounding screen
// bits.  The pointer may be anywhere within the 2*2 sector, as defined by
// "offset".
//
// ------------------
// |       |        |
// |       |        |
// | saved | unused |
// |       |        |
// |       |        |
// |----------------|
// |                |
// |   --------     |
// |   |      |     |
// |   | rem  |     |
// |   | ptr  |     |
// |   |      |     |
// |   |      |     |
// |   --------     |
// |                |
// ------------------
//
// Operations consist of
//
// If there is no pointer there currently then
//
// 1. Copy lower 2*2 segment from the screen
// 2. Save the remote pointer square to the saved area
// 3. Draw the icon into rem ptr square
// 4. Blit the 2*2 back to the screen
//
// If there is an old rem ptr and the new one lies within the same 2*2 area
// then as above but copy "saved" to "old rem ptr" before step 2 to remove
// it.
//
// If the new pointer lies off the old square then copy "saved" back to the
// display before proceeding as in the no pointer case.
//
//

// PRECOMP
#include "precomp.h"



//
// Runtime class information
//

//
// Local defines
//
#define DRAW   1
#define UNDRAW 2

//
//
// Function:    ~DCWbColorToIconMap
//
// Purpose:     Destructor
//
//
DCWbColorToIconMap::~DCWbColorToIconMap(void)
{
  // Delete all the objects in the user map and release the icon handles
  HICON    hIcon;

  POSITION position = GetHeadPosition();
  COLOREDICON * pColoredIcon;
  while (position)
  {
    pColoredIcon = (COLOREDICON *)GetNext(position);

    // Destroy the icon
    if (pColoredIcon != NULL)
    {
      ::DestroyIcon(pColoredIcon->hIcon);
      delete pColoredIcon;
    }
  }
  EmptyList();
}

//
//
// Function:    DCWbGraphicPointer::DCWbGraphicPointer
//
// Purpose:     Constructor for remote pointer objects
//
//
DCWbGraphicPointer::DCWbGraphicPointer(WbUser* _pUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::DCWbGraphicPointer");

    // We haven't yet created our mem DC
    m_hSaveBitmap = NULL;
    m_hOldBitmap = NULL;

    // Save the user pointer
    ASSERT(_pUser != NULL);
    m_pUser        = _pUser;

    // Set the bounding rectangle of the object
    m_uiIconWidth  = ::GetSystemMetrics(SM_CXICON);
    m_uiIconHeight = ::GetSystemMetrics(SM_CYICON);

    m_boundsRect.left = 0;
    m_boundsRect.top = 0;
    m_boundsRect.right = m_uiIconWidth;
    m_boundsRect.bottom = m_uiIconHeight;

    // Show that the object is not drawn
    m_bDrawn = FALSE;
    ::SetRectEmpty(&m_rectLastDrawn);

    // Show that we do not have an icon for drawing yet
    m_hIcon = NULL;

    // Create a memory DC compatible with the display
    m_hMemDC = ::CreateCompatibleDC(NULL);
}

//
//
// Function:    DCWbGraphicPointer::~DCWbGraphicPointer
//
// Purpose:     Destructor for remote pointer objects
//
//
DCWbGraphicPointer::~DCWbGraphicPointer(void)
{
    // Restore the original bitmap to the memory DC
    if (m_hOldBitmap != NULL)
    {
        SelectBitmap(m_hMemDC, m_hOldBitmap);
        m_hOldBitmap = NULL;
    }

    if (m_hSaveBitmap != NULL)
    {
        DeleteBitmap(m_hSaveBitmap);
        m_hSaveBitmap = NULL;
    }

    if (m_hMemDC != NULL)
    {
        ::DeleteDC(m_hMemDC);
        m_hMemDC = NULL;
    }

	if(g_pMain)
	{
		g_pMain->RemoveGraphicPointer(this);
	}

}

//
//
// Function:    Color
//
// Purpose:     Set the color of the pointer. An icon of the appropriate
//              color is created if necessary.
//
//
void DCWbGraphicPointer::SetColor(COLORREF newColor)
{
    newColor = SET_PALETTERGB( newColor ); // make it use color matching

    // If this is a color change
    if (m_clrPenColor != newColor)
    {

	COLOREDICON* pColoredIcon;
	POSITION position = g_pUsers->GetHeadPosition();
	BOOL found = FALSE;
	while (position && !found)
	{
		pColoredIcon = (COLOREDICON *)g_pIcons->GetNext(position);
	        if (newColor == pColoredIcon->color)
	        {
                	found = TRUE;
	        }
	}

	if(!found)
	{
	        m_hIcon = CreateColoredIcon(newColor);
	}

	// Set the color
	m_clrPenColor = newColor;
    }
}

//
//
// Function:    CreateSaveBitmap
//
// Purpose:     Create a bitmap for saving the bits under the pointer.
//
//
void DCWbGraphicPointer::CreateSaveBitmap(WbDrawingArea * pDrawingArea)
{
    HBITMAP hImage = NULL;
    HBITMAP hOld = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CreateSaveBitmap");

    // If we already have a save bitmap, exit immediately
    if (m_hSaveBitmap != NULL)
    {
        TRACE_MSG(("Already have save bitmap"));
        return;
    }

    // Load the pointer bitmap
    hImage = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERXORDATA));
    if (!hImage)
    {
        ERROR_OUT(("Could not load pointer bitmap"));
        goto CleanupSaveBitmap;
    }

    // Select the pointer bitmap into the memory DC. We do this to
    // allow creation of a compatible bitmap (otherwise we would get
    // a default monochrome format when calling CreateCompatibleBitmap).
    hOld = SelectBitmap(m_hMemDC, hImage);
    if (hOld == NULL)
    {
        ERROR_OUT(("Could not select bitmap into DC"));
        goto CleanupSaveBitmap;
    }

    // Create a bitmap to save the bits under the icon. This bitmap is
    // created with space for building the new screen image before
    // blitting it to the screen.
    m_hSaveBitmap = ::CreateCompatibleBitmap(m_hMemDC,
            2 * m_uiIconWidth  * pDrawingArea->ZoomOption(),
            3 * m_uiIconHeight * pDrawingArea->ZoomOption());
    if (!m_hSaveBitmap)
    {
        ERROR_OUT(("Could not create save bitmap"));
        goto CleanupSaveBitmap;
    }

    // Select in the save bits bitmap
    m_hOldBitmap = hOld;
    hOld = NULL;
    SelectBitmap(m_hMemDC, m_hSaveBitmap);

    // Default zoom factor is 1
    m_iZoomSaved = 1;

CleanupSaveBitmap:
    if (hOld != NULL)
    {
        // Put back the original bitmap--we failed to create the save bmp
        SelectBitmap(m_hMemDC, hOld);
    }

    if (hImage != NULL)
    {
        ::DeleteBitmap(hImage);
    }
}

//
//
// Function:    CreateColoredIcon
//
// Purpose:     Create an icon of the correct color for this pointer. The
//              DCWbGraphicPointer class keeps a static list of icons
//              created previously. These are re-used as necessary.
//
//
HICON DCWbGraphicPointer::CreateColoredIcon(COLORREF color)
{
    HICON       hColoredIcon = NULL;
    HBRUSH      hBrush = NULL;
    HBRUSH      hOldBrush;
    HBITMAP     hImage = NULL;
    HBITMAP     hOldBitmap;
    HBITMAP     hMask = NULL;
    COLOREDICON  *pColoredIcon;
    ICONINFO    ii;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CreateColoredIcon");

    hBrush = ::CreateSolidBrush(color);
    if (!hBrush)
    {
        TRACE_MSG(("Couldn't create color brush"));
        goto CreateIconCleanup;
    }

    // Load the mask bitmap
    hMask = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERANDMASK));
    if (!hMask)
    {
        TRACE_MSG(("Could not load mask bitmap"));
        goto CreateIconCleanup;
    }

    // Load the image bitmap
    hImage = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERXORDATA));
    if (!hImage)
    {
        TRACE_MSG(("Could not load pointer bitmap"));
        goto CreateIconCleanup;
    }

    // Select in the icon color
    hOldBrush = SelectBrush(m_hMemDC, hBrush);

    // Select the image bitmap into the memory DC
    hOldBitmap = SelectBitmap(m_hMemDC, hImage);

    // Fill the image bitmap with color
    ::FloodFill(m_hMemDC, m_uiIconWidth / 2, m_uiIconHeight / 2, RGB(0, 0, 0));

    SelectBitmap(m_hMemDC, hOldBitmap);
    
    SelectBrush(m_hMemDC, hOldBrush);

    //
    // Now use the image and mask bitmaps to create an icon
    //
    ii.fIcon = TRUE;
    ii.xHotspot = 0;
    ii.yHotspot = 0;
    ii.hbmMask = hMask;
    ii.hbmColor = hImage;

    // Create a new icon from the data and mask
    hColoredIcon = ::CreateIconIndirect(&ii);

    // Add the new icon to the static list
    ASSERT(g_pIcons);
	pColoredIcon = new COLOREDICON;
    if (!pColoredIcon)
    {
        ERROR_OUT(("Failed to allocate COLORICON object"));
        DestroyIcon(hColoredIcon);
        hColoredIcon = NULL;
    }
    else
    {
        pColoredIcon->color = color;
        pColoredIcon->hIcon = hColoredIcon;
        g_pIcons->AddTail(pColoredIcon);
    }

CreateIconCleanup:

    // Free the image bitmap
    if (hImage != NULL)
    {
        ::DeleteBitmap(hImage);
    }

    // Free the mask bitmap
    if (hMask != NULL)
    {
        ::DeleteBitmap(hMask);
    }

    if (hBrush != NULL)
    {
        ::DeleteBrush(hBrush);
    }

    return(hColoredIcon);
}

//
//
// Function:    GetPage
//
// Purpose:     Return the page of the pointer. An invalid page is returned
//              if the pointer is not active.
//
//
WB_PAGE_HANDLE DCWbGraphicPointer::GetPage(void) const
{
    // If this pointer is active, return its actual page
    if (m_bActive == TRUE)
        return(m_hPage);
    else
        return(WB_PAGE_HANDLE_NULL);
}


void DCWbGraphicPointer::SetPage(WB_PAGE_HANDLE hNewPage)
{
    m_hPage = hNewPage;
}

//
//
// Function:    DrawnRect
//
// Purpose:     Return the rectangle where the pointer was last drawn
//
//
void DCWbGraphicPointer::GetDrawnRect(LPRECT lprc)
{
    ::SetRectEmpty(lprc);

    if (m_bDrawn)
    {
        *lprc = m_rectLastDrawn;
    }
}

//
//
// Function:    IsLocalPointer
//
// Purpose:     Return TRUE if this is the local user's pointer
//
//
BOOL DCWbGraphicPointer::IsLocalPointer(void) const
{
    ASSERT(m_pUser != NULL);
    return m_pUser->IsLocalUser();
}

//
//
// Function:    operator==
//
// Purpose:     Return TRUE if the specified remote pointer is the same as
//              this one.
//
//
BOOL DCWbGraphicPointer::operator==(const DCWbGraphicPointer& pointer) const
{
    return (m_pUser == pointer.m_pUser);
}

//
//
// Function:    operator!=
//
// Purpose:     Return FALSE if the specified pointer is the same as this
//
//
BOOL DCWbGraphicPointer::operator!=(const DCWbGraphicPointer& pointer) const
{
  return (!((*this) == pointer));
}

//
//
// Function:    DCWbGraphicPointer::Draw
//
// Purpose:     Draw the pointer object without saving the bits under it
//
//
void DCWbGraphicPointer::Draw(HDC hDC, WbDrawingArea * pDrawingArea)
{
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::Draw");

    rcUpdate = m_boundsRect;

    // Check that we have an icon to draw
    if (m_hIcon == NULL)
    {
        WARNING_OUT(("Icon not found"));
        return;
    }

    if (pDrawingArea == NULL)
    {
        ERROR_OUT(("No drawing area passed in"));
        return;
    }

    // Create the save bitmap if necessary
    CreateSaveBitmap(pDrawingArea);

    PointerDC(hDC, pDrawingArea, &rcUpdate, pDrawingArea->ZoomFactor());

    // Draw the icon to the DC passed
    ::DrawIcon(hDC, rcUpdate.left, rcUpdate.top, m_hIcon);

    SurfaceDC(hDC, pDrawingArea);

}

//
//
// Function:    DCWbGraphicPointer::DrawSave
//
// Purpose:     Draw the pointer object after saving the bits under it
//
//
void DCWbGraphicPointer::DrawSave(HDC hDC, WbDrawingArea * pDrawingArea)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::DrawSave");

    // Pretend that we are not drawn
    m_bDrawn = FALSE;

    // Call the redraw member
    Redraw(hDC, pDrawingArea);
}

//
//
// Function:    DCWbGraphicPointer::Redraw
//
// Purpose:     Draw the pointer in its current position after erasing it
//              from the DC using the saved version.
//
//
void DCWbGraphicPointer::Redraw(HDC hDC, WbDrawingArea * pDrawingArea)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::Redraw");

    RECT    clipBox;

    ::GetClipBox(hDC, &clipBox);

    // Create the save bitmap if necessary
    CreateSaveBitmap(pDrawingArea);

    // If we are not yet drawn, we must copy data from the screen
    // to initialize the save bitmaps.
    if (!m_bDrawn)
    {
        TRACE_MSG(("Pointer not yet drawn"));

        // Only do anything if the pointer will be visible
        if (::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
        {
            // Pretend that we were drawn at the same place and copy the screen
            // bits into memory to build the image.
            GetBoundsRect(&m_rectLastDrawn);
            CopyFromScreen(hDC, pDrawingArea);

            // Save the bits under the pointer
            SaveMemory();

            // Draw the pointer
            DrawMemory();

            // Copy the new image to the screen
            CopyToScreen(hDC, pDrawingArea);

            // Show that the pointer is now drawn
            m_bDrawn = TRUE;
        }
    }
    else
    {
        TRACE_MSG(("Pointer already drawn at %d %d",
            m_rectLastDrawn.left, m_rectLastDrawn.top));

        // Calculate the update rectangle
        RECT    rcUpdate;

        GetBoundsRect(&rcUpdate);
        ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);

        // Check whether any of the update is visible
        if (::IntersectRect(&clipBox, &clipBox, &rcUpdate))
        {
            // Check whether we can do better by drawing in memory before
            // going to the screen.
            GetBoundsRect(&rcUpdate);
            if (::IntersectRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn))
            {
                TRACE_MSG(("Drawing in memory first"));

                // The old and new positions of the pointers overlap. We can
                // reduce flicker by building the new image in memory and
                // blitting to the screen.

                // Copy overlap rectangle to memory
                CopyFromScreen(hDC, pDrawingArea);

                // Undraw the pointer from the overlap rectangle
                UndrawMemory();

                // Save the bits under the new pointer position (from memory)
                SaveMemory();

                // Draw the new pointer into memory
                DrawMemory();

                // Copy the new image to the screen
                CopyToScreen(hDC, pDrawingArea);
            }
            else
            {
                TRACE_MSG(("No overlap - remove and redraw"));

                // The old and new pointer positions do not overlap. We can remove
                // the old pointer and draw the new in the usual way.

                // Copy the saved bits under the pointer to the screen
                UndrawScreen(hDC, pDrawingArea);

                // Pretend that we were drawn at the same place and copy the screen
                // bits into memory to build the image.
                GetBoundsRect(&m_rectLastDrawn);
                CopyFromScreen(hDC, pDrawingArea);

                // Save the bits under the pointer
                SaveMemory();

                // Draw the pointer
                DrawMemory();

                // Copy the new image to the screen
                CopyToScreen(hDC, pDrawingArea);
            }

            // Show that the pointer is now drawn
            m_bDrawn = TRUE;
        }
    }

    // If the pointer was drawn, save the rectangle in which it was drawn
    if (m_bDrawn)
    {
        GetBoundsRect(&m_rectLastDrawn);
    }
}

//
//
// Function:    DCWbGraphicPointer::Undraw
//
// Purpose:     Draw the marker object
//
//
void DCWbGraphicPointer::Undraw(HDC hDC, WbDrawingArea * pDrawingArea)
{
    // If we are not drawn, do nothing
    if (m_bDrawn)
    {
        // Create the save bitmap if necessary
        CreateSaveBitmap(pDrawingArea);

        // Copy the saved bits onto the screen
        UndrawScreen(hDC, pDrawingArea);

        // Show that we are no longer drawn
        m_bDrawn = FALSE;
    }
}

//
//
// Function:    CopyFromScreen
//
// Purpose:     Save the bits around the old and new pointer positions
//              to memory.
//
//
BOOL DCWbGraphicPointer::CopyFromScreen(HDC hDC, WbDrawingArea * pDrawingArea)
{
    BOOL bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CopyFromScreen");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);

    PointerDC(hDC, pDrawingArea, &rcUpdate, pDrawingArea->ZoomFactor());

    // Copy the bits
    bResult = ::BitBlt(m_hMemDC, 0,
                        m_uiIconHeight * m_iZoomSaved,
                        rcUpdate.right - rcUpdate.left,
                        rcUpdate.bottom - rcUpdate.top, 
                        hDC, rcUpdate.left, rcUpdate.top, SRCCOPY);
    if (!bResult)
    {
        WARNING_OUT(("CopyFromScreen - Could not copy to bitmap"));
    }

    SurfaceDC(hDC, pDrawingArea);

    return(bResult);
}

//
//
// Function:    CopyToScreen
//
// Purpose:     Copy the saved bits around the old and new pointers back
//              to the screen.
//
//
BOOL DCWbGraphicPointer::CopyToScreen(HDC hDC, WbDrawingArea * pDrawingArea)
{
    BOOL bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CopyToScreen");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);

    PointerDC(hDC, pDrawingArea, &rcUpdate);

    bResult = ::BitBlt(hDC, rcUpdate.left, rcUpdate.top,
        rcUpdate.right - rcUpdate.left, rcUpdate.bottom - rcUpdate.top,
        m_hMemDC, 0, m_uiIconHeight * m_iZoomSaved, SRCCOPY);
    if (!bResult)
    {
        WARNING_OUT(("CopyToScreen - Could not copy from bitmap"));
    }


    SurfaceDC(hDC, pDrawingArea);

    return(bResult);
}

//
//
// Function:    UndrawMemory
//
// Purpose:     Copy the saved bits under the pointer to the memory copy of
//              the screen, thus erasing the pointer from the image.
//
//
BOOL DCWbGraphicPointer::UndrawMemory()
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;
    SIZE    offset;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::UndrawMemory");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);
    offset.cx = m_rectLastDrawn.left - rcUpdate.left;
    offset.cy = m_rectLastDrawn.top - rcUpdate.top;

    bResult = ::BitBlt(m_hMemDC, offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved,
                         m_hMemDC,
                         0,
                         0,
                         SRCCOPY);
  if (bResult == FALSE)
  {
      WARNING_OUT(("UndrawMemory - Could not copy from bitmap"));
  }
  TRACE_MSG(("Copied to memory %d,%d from memory %d,%d size %d,%d",
                         offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         0,
                         0,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved));

  return(bResult);
}

//
//
// Function:    SaveMemory
//
// Purpose:     Copy the area of the memory image that will be under the
//              pointer to the save area.
//
//
BOOL DCWbGraphicPointer::SaveMemory(void)
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;
    SIZE    offset;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SaveMemory");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);
    offset.cx = m_boundsRect.left - rcUpdate.left;
    offset.cy = m_boundsRect.top - rcUpdate.top;

    bResult = ::BitBlt(m_hMemDC, 0,
                         0,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved,
                         m_hMemDC,
                         offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         SRCCOPY);
    if (bResult == FALSE)
    {
        TRACE_MSG(("SaveMemory - Could not copy from bitmap"));
    }
    TRACE_MSG(("Copied to memory %d,%d from memory %d,%d size %d,%d",
                         0,
                         0,
                         offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved));

  return(bResult);
}

//
//
// Function:    DrawMemory
//
// Purpose:     Draw the pointer onto the memory image copy.
//
//
BOOL DCWbGraphicPointer::DrawMemory(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::DrawMemory");

    BOOL bResult = FALSE;

    // Check that we have an icon to draw
    if (m_hIcon == NULL)
    {
        WARNING_OUT(("No icon to draw"));
    }
    else
    {
        RECT    rcUpdate;
        SIZE    offset;

        // Get the update rectangle needed
        GetBoundsRect(&rcUpdate);
        ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);
        offset.cx = m_boundsRect.left - rcUpdate.left;
        offset.cy = m_boundsRect.top - rcUpdate.top;

        // Draw the icon to the DC passed
        bResult = ::DrawIcon(m_hMemDC, offset.cx * m_iZoomSaved,
                             (m_uiIconHeight + offset.cy) * m_iZoomSaved +
                             (m_uiIconHeight * (m_iZoomSaved - 1))/2,
                             m_hIcon);

    if (bResult == FALSE)
    {
      WARNING_OUT(("DrawMemory - Could not draw icon"));
    }
    TRACE_MSG(("Write pointer to memory at %d,%d",
                           offset.cx * m_iZoomSaved,
                           (m_uiIconHeight + offset.cy) * m_iZoomSaved +
                           (m_uiIconHeight * (m_iZoomSaved - 1))/2));
  }

  return(bResult);
}

//
//
// Function:    UndrawScreen
//
// Purpose:     Copy the saved bits under the pointer to the screen.
//
//
BOOL DCWbGraphicPointer::UndrawScreen(HDC hDC, WbDrawingArea * pDrawingArea)
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::UndrawScreen");

    rcUpdate = m_rectLastDrawn;

    PointerDC(hDC, pDrawingArea, &rcUpdate);

    // We are undrawing - copy the saved bits to the DC passed
    bResult = ::BitBlt(hDC, rcUpdate.left, rcUpdate.top,
        rcUpdate.right - rcUpdate.left, rcUpdate.bottom - rcUpdate.top,
        m_hMemDC, 0, 0, SRCCOPY);
    if (!bResult)
    {
        WARNING_OUT(("UndrawScreen - Could not copy from bitmap"));
    }

    SurfaceDC(hDC, pDrawingArea);

    return(bResult);
}

//
//
// Function:    Update
//
// Purpose:     Update the pointer information stored in the user
//              information.
//
//
void DCWbGraphicPointer::Update(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::Update");

    // Only do the update if we have been changed
    if (m_bChanged)
    {
        // Make the update (the pointer information is held in the associated
        // user object)
        ASSERT(m_pUser != NULL);
        m_pUser->Update();

        // Show that we have not changed since the last update
        m_bChanged = FALSE;
    }
}

//
//
// Function:    SetActive
//
// Purpose:     Update the pointer information to show that the pointer
//              is now active.
//
//
void DCWbGraphicPointer::SetActive(WB_PAGE_HANDLE hPage, POINT point)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SetActive");

    // Set the member variables
    MoveTo(point.x, point.y);
    m_hPage  = hPage;
    m_bActive = TRUE;
    m_bChanged = TRUE;

    // Distribute the update
    Update();
}

//
//
// Function:    SetInactive
//
// Purpose:     Update the pointer information to show that the pointer
//              is no longer active.
//
//
void DCWbGraphicPointer::SetInactive(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SetInactive");

  // Set the member variables
  m_bActive = FALSE;
    m_bChanged = TRUE;

  // Distribute the update
  Update();
}

//
//
// Function:    PointerDC
//
// Purpose:     Scale the DC to 1:1, set a zero origin and convert the
//              supplied rectangle into window coordinates.  This is because
//              we have to do the zoom mapping ourselves when we are doing
//              remote pointer blitting, otherwise the system does
//              stretchblits and screws up.  Note that the SurfaceToClient
//              function gives us a client rectangle (ie it is 3 * as big
//              when we are zoomed)
//
//
void DCWbGraphicPointer::PointerDC
(
    HDC         hDC,
    WbDrawingArea * pDrawingArea,
    LPRECT      lprc,
    int         zoom
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::PointerDC");

    // default zoom to be the saved value
    if (zoom == 0)
    {
        zoom = m_iZoomSaved;
    }
    else
    {
        m_iZoomSaved = zoom;
    }

    // If we are currently zoomed then do the scaling
    if (zoom != 1)
    {
        ::ScaleViewportExtEx(hDC, 1, zoom, 1, zoom, NULL);
        TRACE_MSG(("Scaled screen viewport down by %d", zoom));

        pDrawingArea->SurfaceToClient(lprc);
        ::SetWindowOrgEx(hDC, 0, 0, NULL);
    }
}

//
//
// Function:    SurfaceDC
//
// Purpose:     Scale the DC back to the correct zoom factor and reset the
//              origin to the surface offset
//
//
void DCWbGraphicPointer::SurfaceDC(HDC hDC, WbDrawingArea * pDrawingArea)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SurfaceDC");

    if (m_iZoomSaved != 1)
    {
        POINT   pt;

        ::ScaleViewportExtEx(hDC, m_iZoomSaved, 1, m_iZoomSaved, 1, NULL);
        TRACE_MSG(("Scaled screen viewport up by %d", m_iZoomSaved));

        pDrawingArea->GetOrigin(&pt);
        ::SetWindowOrgEx(hDC, pt.x, pt.y, NULL);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\main.cpp ===
//
// MAIN.CPP
// Whiteboard Windows App Code
//
// Copyright Microsoft 1998-
//


// PRECOMP
#include "precomp.h"


WbMainWindow *  g_pMain;
HINSTANCE       g_hInstance;
IWbClient*      g_pwbCore;
UINT            g_uConfShutdown;
WbPrinter *     g_pPrinter;

BOOL            g_bPalettesInitialized;
BOOL            g_bUsePalettes;
HPALETTE        g_hRainbowPaletteDisplay;

HINSTANCE       g_hImmLib;
IGC_PROC        g_fnImmGetContext;
INI_PROC        g_fnImmNotifyIME;

//
// Arrays
//
COLORREF    g_ColorTable[NUM_COLOR_ENTRIES] =
{
    RGB(  0, 255, 255),                   // Cyan
    RGB(255, 255,   0),                   // Yellow
    RGB(255,   0, 255),                   // Magenta
    RGB(  0,   0, 255),                   // Blue
    RGB(192, 192, 192),                   // Grey
    RGB(255,   0,   0),                   // Red
    RGB(  0,   0, 128),                   // Dark blue
    RGB(  0, 128, 128),                   // Dark cyan
    RGB(  0, 255,   0),                   // Green
    RGB(  0, 128,   0),                   // Dark green
    RGB(128,   0,   0),                   // Dark red
    RGB(128,   0, 128),                   // Purple
    RGB(128, 128,   0),                   // Olive
    RGB(128, 128, 128),                   // Grey
    RGB(255, 255, 255),                   // White
    RGB(  0,   0,   0),                   // Black
    RGB(255, 128,   0),                   // Orange
    RGB(128, 255, 255),                   // Turquoise
    RGB(  0, 128, 255),                   // Mid blue
    RGB(  0, 255, 128),                   // Pale green
    RGB(255,   0, 128)                    // Dark pink
};


int g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS] =
{
    0,                   // CLIPBOARD_PRIVATE_SINGLE_OBJ - Reserved for the
					   //	Whiteboard private format
    0,
    CF_DIB,              // Standard formats
    CF_ENHMETAFILE,	   // move metafiles to lower pri than bitmaps (bug NM4db:411)
    CF_TEXT
};



// Default widths for all tools except for highlighters
UINT g_PenWidths[NUM_OF_WIDTHS] = { 2, 4, 8, 16 };

// Default widths for highlight tools
UINT g_HighlightWidths[NUM_OF_WIDTHS] = { 4, 8, 16, 32 };

//
// Objects
//
WbUserList *            g_pUsers;
WbDrawingArea *         g_pDraw;
DCWbColorToIconMap *    g_pIcons;

#ifdef _DEBUG
HDBGZONE    ghZoneWb;

PTCHAR      g_rgZonesWb[] = // CHECK ZONE_WBxxx CONSTANTS IF THESE CHANGE
{
    "OldWB",
    DEFAULT_ZONES
	"DEBUG",
	"MSG",
	"TIMER",
	"EVENT"
};
#endif // _DEBUG

///////////////////////////////////////////////////////////////////////////


/*  D L L  M A I N  */
/*-------------------------------------------------------------------------
    %%Function: DllMain
    
-------------------------------------------------------------------------*/
BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &g_rgZonesWb[0],
            (sizeof(g_rgZonesWb) / sizeof(g_rgZonesWb[0])) - 1);
#endif
	    	g_hInstance = hDllInst;
    		DisableThreadLibraryCalls(g_hInstance);

            DBG_INIT_MEMORY_TRACKING(hDllInst);
		    break;
	    }

    	case DLL_PROCESS_DETACH:
        {
            g_hInstance = NULL;

            DBG_CHECK_MEMORY_TRACKING(hDllInst);
#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif
    		break;
        }

        default:
		    break;
	}

	return TRUE;
}



//
// Whiteboard's init routine
//
BOOL WINAPI InitWB(void)
{
    BOOL    fInited = FALSE;

    ASSERT(!g_pMain);
    ASSERT(!g_hImmLib);
    ASSERT(!g_fnImmGetContext);
    ASSERT(!g_fnImmNotifyIME);

    //
    // Load IMM32 if this is FE
    //
    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        g_hImmLib = LoadLibrary("imm32.dll");
        if (!g_hImmLib)
        {
            ERROR_OUT(("Failed to load imm32.dll"));
        }
        else
        {
            g_fnImmGetContext = (IGC_PROC)GetProcAddress(g_hImmLib, "ImmGetContext");
            if (!g_fnImmGetContext)
            {
                ERROR_OUT(("Failed to get ImmGetContext pointer"));
            }
            g_fnImmNotifyIME = (INI_PROC)GetProcAddress(g_hImmLib, "ImmNotifyIME");
            if (!g_fnImmNotifyIME)
            {
                ERROR_OUT(("Failed to get ImmNotifyIME pointer"));
            }
        }
    }

    g_pMain = new WbMainWindow();
    if (!g_pMain)
    {
        ERROR_OUT(("Can't create WbMainWindow"));
        goto Done;
    }

    //
    // OK, now we're ready to create our HWND
    //
    if (!g_pMain->Open(SW_SHOWDEFAULT))
    {
        ERROR_OUT(("Can't create WB windows"));
        goto Done;
    }

    fInited = TRUE;

Done:
    return(fInited);
}



//
// Whiteboard's term routine
//
void WINAPI TermWB(void)
{
    if (g_pMain != NULL)
    {
        delete g_pMain;
        g_pMain = NULL;
    }

    g_fnImmNotifyIME = NULL;
    g_fnImmGetContext = NULL;

    if (g_hImmLib)
    {
        FreeLibrary(g_hImmLib);
        g_hImmLib = NULL;
    }
}


//
// Whiteboard's thread handler
//
void WINAPI RunWB(void)
{
    ASSERT(g_pMain != NULL);

    //
    // Try to join call
    //
    //
    // Find out if we're in a call and join if so.
    //
    if (!g_pMain->JoinDomain())
    {
        ERROR_OUT(("WB couldn't start up and join call"));
        return;
    }

    //
    // MESSAGE LOOP
    //
    MSG     msg;

    while (::GetMessage(&msg, NULL, NULL, NULL))
    {
        if (!g_pMain->FilterMessage(&msg))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }
}




//
// Mapping of internal return codes to string resources                     
//
typedef struct tagERROR_MAP
{
    UINT uiFEReturnCode;
    UINT uiDCGReturnCode;
    UINT uiCaption;
    UINT uiMessage;
}
ERROR_MAP;


ERROR_MAP g_ErrorStringID[] =
{
  { WBFE_RC_JOIN_CALL_FAILED,           // Registration failed
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_JOIN_CALL_FAILED
  },

  { WBFE_RC_WINDOWS,                    // A windows error has occurred
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_WINDOWS_RESOURCES
  },

  { WBFE_RC_WB,                         // Page limit exceeded
    WB_RC_TOO_MANY_PAGES,
    IDS_MSG_CAPTION,
    IDS_MSG_TOO_MANY_PAGES
  },

  { WBFE_RC_WB,          // Another user has the contents lock
    WB_RC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_LOCKED
  },

  { WBFE_RC_WB,          // Another user has the graphic locked
    WB_RC_GRAPHIC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_GRAPHIC_LOCKED,
  },

  { WBFE_RC_WB,          // The local user does not have the lock
    WB_RC_NOT_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_NOT_LOCKED
  },

  { WBFE_RC_WB,          // File is not in expected format
    WB_RC_BAD_FILE_FORMAT,
    IDS_MSG_CAPTION,
    IDS_MSG_BAD_FILE_FORMAT
  },

  { WBFE_RC_WB,          // Whiteboard busy (exhausted page cache)
    WB_RC_BUSY,
    IDS_MSG_CAPTION,
    IDS_MSG_BUSY
  },

  { WBFE_RC_CM,          // Failed to access call manager
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_CM_ERROR
  },

  { WBFE_RC_AL,          // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_AL_ERROR
  },

  { WBFE_RC_PRINTER,     // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_PRINTER_ERROR
  },

  { 0,                   // Catch-all default
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_DEFAULT
  }
};




//
//                                                                          
// Function:    Message                                                     
//                                                                          
// Purpose:     Display an error message box with string resources specified
//              as parameters, with the WB main window as the modal window. 
//                                                                          
//
int Message
(
    HWND    hwnd,
    UINT    uiCaption,
    UINT    uiMessage,
    UINT    uiStyle
)
{
    TCHAR   message[256];
    TCHAR   caption[256];

	//make sure we're on top
    ASSERT(g_pMain);
    if (!hwnd)
        hwnd = g_pMain->m_hwnd;

    if (hwnd != NULL)
    {
		::SetForegroundWindow(hwnd);
    }

    LoadString(g_hInstance, uiMessage, message, 256);

    LoadString(g_hInstance, uiCaption, caption, 256);

    //
    // BOGUS LAURABU:
    // Make use of MessageBoxEx() and just pass the string IDs along, 
    // rather than doing the LoadString() ourself.
    //

    // Display a message box with the relevant text
	return(::MessageBox(hwnd, message, caption, uiStyle));
}



//
//                                                                          
// Function:    ErrorMessage                                                
//                                                                          
// Purpose:     Display an error based on return codes from Whiteboard      
//              processing.                                                 
//                                                                          
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "::ErrorMessage (codes)");

    TRACE_MSG(("FE return code  = %hd", uiFEReturnCode));
    TRACE_MSG(("DCG return code = %hd", uiDCGReturnCode));

    // check for special OM_RC_OBJECT_DELETED case
    if (uiDCGReturnCode == OM_RC_OBJECT_DELETED)
    {
        // don't complain, just cancel drawing
        g_pMain->m_drawingArea.CancelDrawingMode();
        return;
    }

    // Find the associated string resource IDS
    int iIndex;

    for (iIndex = 0; ; iIndex++)
    {
        // If we have come to the end of the list, stop
        if (g_ErrorStringID[iIndex].uiFEReturnCode == 0)
        {
            break;
        }

        // Check for a match
        if (g_ErrorStringID[iIndex].uiFEReturnCode == uiFEReturnCode)
        {
            if (   (g_ErrorStringID[iIndex].uiDCGReturnCode == uiDCGReturnCode)
                || (g_ErrorStringID[iIndex].uiDCGReturnCode == 0))
            {
                break;
            }
        }
    }

    // Display the message
    Message(NULL, g_ErrorStringID[iIndex].uiCaption, g_ErrorStringID[iIndex].uiMessage);
}



//
//                                                                          
// Function:    DefaultExceptionHandler                                     
//                                                                          
// Purpose:     Default exception processing. This can be called in an      
//              exception handler to get a message relevant to the          
//              exception. The message is generated by posting a message to 
//              the applications main window.                               
//                                                                          
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DefaultExceptionHandler");

    // Post a message to the main window to get the error displayed
    if (g_pMain != NULL)
    {
        // check for special OM_RC_OBJECT_DELETED case
        if (uiDCGReturnCode == OM_RC_OBJECT_DELETED)
        {
            // don't complain, just cancel drawing
            g_pMain->m_drawingArea.CancelDrawingMode();
            return;
        }

        if (g_pMain->m_hwnd)
            ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, uiFEReturnCode, uiDCGReturnCode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\mwnd.cpp ===
//
// MWND.CPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include <dde.h>
#include "version.h"


static const TCHAR s_cszHtmlHelpFile[] = TEXT("nmwhiteb.chm");

// Class name
TCHAR szMainClassName[] = "Wb32MainWindowClass";


//
// Scroll accelerators
//
typedef struct tagSCROLL
{
    UINT uiMenuId;
    UINT uiMessage;
    UINT uiScrollCode;
}
SCROLL;

static const SCROLL s_MenuToScroll[] =
{
  { IDM_PAGEUP,        WM_VSCROLL, SB_PAGEUP },
  { IDM_PAGEDOWN,      WM_VSCROLL, SB_PAGEDOWN },
  { IDM_SHIFTPAGEUP,   WM_HSCROLL, SB_PAGEUP },
  { IDM_SHIFTPAGEDOWN, WM_HSCROLL, SB_PAGEDOWN },
  { IDM_HOME,          WM_HSCROLL, SB_TOP },
  { IDM_HOME,          WM_VSCROLL, SB_TOP },
  { IDM_END,           WM_HSCROLL, SB_BOTTOM },
  { IDM_END,           WM_VSCROLL, SB_BOTTOM },
  { IDM_LINEUP,        WM_VSCROLL, SB_LINEUP },
  { IDM_LINEDOWN,      WM_VSCROLL, SB_LINEDOWN },
  { IDM_SHIFTLINEUP,   WM_HSCROLL, SB_LINEUP },
  { IDM_SHIFTLINEDOWN, WM_HSCROLL, SB_LINEDOWN }
};


// tooltip data
// check codes
#define NA    0   // dont't check checked state
#define TB    1    // check toolbar for checked state
#define BT    2    // check tipped wnd (a button) for checked state

typedef struct
{
    UINT    nID;
    UINT    nCheck;
    UINT    nUpTipID;
    UINT    nDownTipID;
}
TIPIDS;

TIPIDS g_tipIDsArray[]    =
{
{IDM_SELECT,            TB, IDS_HINT_SELECT,        IDS_HINT_SELECT},
{IDM_ERASER,            TB, IDS_HINT_ERASER,        IDS_HINT_ERASER},
{IDM_TEXT,              TB, IDS_HINT_TEXT,          IDS_HINT_TEXT},
{IDM_HIGHLIGHT,         TB, IDS_HINT_HIGHLIGHT,     IDS_HINT_HIGHLIGHT},
{IDM_PEN,               TB, IDS_HINT_PEN,           IDS_HINT_PEN},
{IDM_LINE,              TB, IDS_HINT_LINE,          IDS_HINT_LINE},
{IDM_BOX,               TB, IDS_HINT_BOX,           IDS_HINT_BOX},
{IDM_FILLED_BOX,        TB, IDS_HINT_FBOX,          IDS_HINT_FBOX},
{IDM_ELLIPSE,           TB, IDS_HINT_ELLIPSE,       IDS_HINT_ELLIPSE},
{IDM_FILLED_ELLIPSE,    TB, IDS_HINT_FELLIPSE,      IDS_HINT_FELLIPSE},
{IDM_ZOOM,              TB, IDS_HINT_ZOOM_UP,       IDS_HINT_ZOOM_DOWN},
{IDM_REMOTE,            TB, IDS_HINT_REMOTE_UP,     IDS_HINT_REMOTE_DOWN},
{IDM_LOCK,              TB, IDS_HINT_LOCK_UP,       IDS_HINT_LOCK_DOWN},
{IDM_SYNC,              TB, IDS_HINT_SYNC_UP,       IDS_HINT_SYNC_DOWN},
{IDM_GRAB_AREA,         TB, IDS_HINT_GRAB_AREA,     IDS_HINT_GRAB_AREA},
{IDM_GRAB_WINDOW,       TB, IDS_HINT_GRAB_WINDOW,   IDS_HINT_GRAB_WINDOW},

{IDM_WIDTH_1,           NA, IDS_HINT_WIDTH_1,       IDS_HINT_WIDTH_1},
{IDM_WIDTH_2,           NA, IDS_HINT_WIDTH_2,       IDS_HINT_WIDTH_2},
{IDM_WIDTH_3,           NA, IDS_HINT_WIDTH_3,       IDS_HINT_WIDTH_3},
{IDM_WIDTH_4,           NA, IDS_HINT_WIDTH_4,       IDS_HINT_WIDTH_4},

{IDM_PAGE_FIRST,        BT, IDS_HINT_PAGE_FIRST,    IDS_HINT_PAGE_FIRST},
{IDM_PAGE_PREV,         BT, IDS_HINT_PAGE_PREVIOUS, IDS_HINT_PAGE_PREVIOUS},
{IDM_PAGE_ANY,          NA, IDS_HINT_PAGE_ANY,      IDS_HINT_PAGE_ANY},
{IDM_PAGE_NEXT,         BT, IDS_HINT_PAGE_NEXT,     IDS_HINT_PAGE_NEXT},
{IDM_PAGE_LAST,         BT, IDS_HINT_PAGE_LAST,     IDS_HINT_PAGE_LAST},
{IDM_PAGE_INSERT_AFTER, BT, IDS_HINT_PAGE_INSERT,   IDS_HINT_PAGE_INSERT}
    };
////////////






//
//
// Function:    WbMainWindow constructor
//
// Purpose:     Create the main Whiteboard window. An exception is thrown
//              if an error occurs during construction.
//
//
WbMainWindow::WbMainWindow(void)
{
    OSVERSIONINFO   OsData;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::WbMainWindow");

    //
    // Initialize member vars first!
    //
    m_hwnd = NULL;
    ZeroMemory(m_ToolArray, sizeof(m_ToolArray));

    m_hwndToolTip = NULL;
    ZeroMemory(&m_tiLastHit, sizeof(m_tiLastHit));
    m_nLastHit = -1;

    m_bInitOk = FALSE;
    m_bDisplayingError = FALSE;

    g_pwbCore = NULL;

    m_dwDomain = 0;
    m_bTimerActive = FALSE;
    m_bSyncUpdateNeeded = FALSE;

    m_hPageClip     = WB_PAGE_HANDLE_NULL;
    m_hGraphicClip  = NULL;
    m_pDelayedGraphicClip = NULL;
    m_pDelayedDataClip = NULL;

    m_bToolBarOn    = FALSE;

    // Load the main accelerator table
    m_hAccelTable =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(MAINACCELTABLE));

    m_hwndPageSortDlg = NULL;
    m_hwndQuerySaveDlg = NULL;
    m_hwndWaitForEventDlg = NULL;
    m_hwndWaitForLockDlg = NULL;
    m_hwndInitDlg = NULL;

    m_hwndSB = NULL;
    m_bStatusBarOn = TRUE;

    m_pCurrentTool = NULL;
    m_uiSavedLockType = WB_LOCK_TYPE_NONE;
	ZeroMemory(m_strFileName, sizeof(m_strFileName));

    m_hCurrentPage = WB_PAGE_HANDLE_NULL;

    // Load the alternative accelerator table for the pages edit
    // field and text editor
    m_hAccelPagesGroup =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(PAGESGROUPACCELTABLE));
    m_hAccelTextEdit   =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(TEXTEDITACCELTABLE));

    m_pLocalUser = NULL;
    m_pLockOwner = NULL;

    // Show that we are not yet in a call
    m_uiState = STARTING;
    m_uiSubState = SUBSTATE_IDLE;

    // We are not currently displaying a menu
    m_hContextMenuBar = NULL;
    m_hContextMenu = NULL;
    m_hGrobjContextMenuBar = NULL;
    m_hGrobjContextMenu = NULL;

    m_bPromptingJoinCall = FALSE;
    m_bInSaveDialog = FALSE;
    m_bJoinCallPending = FALSE;
    m_dwPendingDomain = 0;
    m_bPendingCallKeepContents = FALSE;
    m_dwJoinDomain = 0;
    m_bCallActive = FALSE;

    m_hInitMenu = NULL;
    m_numRemoteUsers = 0;
    m_bSelectAllInProgress = FALSE;
    m_bUnlockStateSettled = TRUE;
    m_bQuerySysShutdown = FALSE;

    // figure out if we're on Win95
    m_bIsWin95 = FALSE;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
            m_bIsWin95 = TRUE;
    }

    m_cancelModeSent = FALSE;

    //
    // We only do this once for the lifetime of the DLL.  There is no
    // way really to clean up registered window messages, and each register
    // bumps up a ref count.  If we registered each time WB was started up
    // during one session of CONF, we'd overflow the refcount.
    //
    if (!g_uConfShutdown)
    {
        g_uConfShutdown = ::RegisterWindowMessage( NM_ENDSESSION_MSG_NAME );
    }
}


//
// Open()
// Do Main window initialization (stuff that can fail).  After this,
// the run code will try to join the current domain and do message loop
// stuff.
//
BOOL WbMainWindow::Open(int iCommand)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Open");

    //
    // CREATE OTHER GLOBALS
    //

    // Start the Whiteboard Core
    if (!CreateWBObject(WbMainWindowEventHandler, &g_pwbCore))
    {
        ERROR_OUT(("WBP_Start failed"));
        DefaultExceptionHandler(WBFE_RC_WB, UT_RC_NO_MEM);
        return FALSE;
    }

    if (!InitToolArray())
    {
        ERROR_OUT(("Can't create tools; failing to start up"));
        return(FALSE);
    }

    g_pUsers = new WbUserList;
    if (!g_pUsers)
    {
        ERROR_OUT(("Can't create g_pUsers"));
        return(FALSE);
    }

    g_pIcons = new DCWbColorToIconMap();
    if (!g_pIcons)
    {
        ERROR_OUT(("Can't create g_pIcons"));
        return(FALSE);
    }

    //
    // Init comon controls
    //
    InitCommonControls();

    //
    // CREATE THE MAIN FRAME WINDOW
    //
    ASSERT(!m_hwnd);

    // Get the class info for it, and change the name.
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.style            = CS_DBLCLKS; // CS_HREDRAW | CS_VREDRAW?
    wc.lpfnWndProc      = WbMainWindowProc;
    wc.hInstance        = g_hInstance;
    wc.hIcon            = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APP));
    wc.hCursor          = ::LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(MAINMENU);
    wc.lpszClassName    = szMainClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("Can't register private frame window class"));
        return(FALSE);
    }

    // Create the main drawing window.
    if (!::CreateWindowEx(WS_EX_APPWINDOW | WS_EX_WINDOWEDGE, szMainClassName,
        NULL, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, g_hInstance, this))
    {
        // Could not create the main window
        ERROR_OUT(("Failed to create main window"));
        return(FALSE);
    }

    ASSERT(m_hwnd);

    // Create the pop-up context menu
    if (!CreateContextMenus())
    {
        ERROR_OUT(("Failed to create context menus"));
        return(FALSE);
    }

    // Register the the main window for Drag/Drop messages.
    DragAcceptFiles(m_hwnd, TRUE);


    //
    // CREATE THE CHILD WINDOWS
    //

    // Create the drawing pane
    // (the Create call throws an exception on error)
    RECT    clientRect;
    RECT    drawingAreaRect;

    ::GetClientRect(m_hwnd, &clientRect);
    drawingAreaRect = clientRect;

    // Every control in the main window has a border on it, so increase the
    // client size by 1 to force these borders to be drawn under the inside
    // black line in the window frame.  This prevents a 2 pel wide border
    // being drawn
    ::InflateRect(&clientRect, 1, 1);

    SIZE sizeAG;
    m_AG.GetNaturalSize(&sizeAG);

    //
    // The drawing area is the top part of the client.  The attributes group
    // and status bar are below it.
    //
    drawingAreaRect.bottom -= (STATUSBAR_HEIGHT
                          + GetSystemMetrics(SM_CYBORDER)
                          + sizeAG.cy);
    if (!m_drawingArea.Create(m_hwnd, &drawingAreaRect))
    {
        ERROR_OUT(("Failed to create drawing area"));
        return(FALSE);
    }


    if (!m_TB.Create(m_hwnd))
    {
        ERROR_OUT(("Failed to create tool window"));
        return(FALSE);
    }


    // Lock the drawing area initially. This prevents the user attempting
    // to make changes before we are in a call.
    LockDrawingArea();

    // disable remote pointer while we are initing (bug 4767)
    m_TB.Disable(IDM_REMOTE);


    m_hwndSB = ::CreateWindowEx(0, STATUSCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY |
        CCS_NORESIZE | SBARS_SIZEGRIP,
        clientRect.left, clientRect.bottom - STATUSBAR_HEIGHT,
        (clientRect.right - clientRect.left), STATUSBAR_HEIGHT,
        m_hwnd, 0, g_hInstance, NULL);
    if (!m_hwndSB)
    {
        ERROR_OUT(("Failed to create status bar window"));
        return(FALSE);
    }

    //
    // Create the attributes group
    // The attributes group is on the bottom, underneath the
    // drawing area, above the status bar.
    //
    RECT    rectAG;

    rectAG.left = clientRect.left;
    rectAG.right = clientRect.right;
    rectAG.top = drawingAreaRect.bottom;
    rectAG.bottom = rectAG.top + sizeAG.cy;

    if (!m_AG.Create(m_hwnd, &rectAG))
    {
        ERROR_OUT(("Failed to create attributes group window"));
        return(FALSE);
    }

    //
    // Create the widths group.
    // The widths group is on the left side, underneath the tools group
    //
    SIZE    sizeWG;
    RECT    rectWG;


    // The widths group is on the left side, underneath the toolbar
    m_WG.GetNaturalSize(&sizeWG);
    rectWG.left = 0;
    rectWG.right = rectWG.left + sizeWG.cx;
    rectWG.bottom = rectAG.top;
    rectWG.top  = rectWG.bottom - sizeWG.cy;

    if (!m_WG.Create(m_hwnd, &rectWG))
    {
        ERROR_OUT(("Failed to create widths group window"));
        return(FALSE);
    }

    // The main window is created with the status bar visible. So make sure
    // that the relevant menu item is checked. This is subject to change
    // depending on options in the Open member function.
    CheckMenuItem(IDM_STATUS_BAR_TOGGLE);

    // Initialize the color, width and tool menus
    InitializeMenus();

    m_currentMenuTool       = IDM_SELECT;
    m_pCurrentTool          = m_ToolArray[TOOL_INDEX(IDM_SELECT)];


    m_hwndToolTip = ::CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
        WS_POPUP | TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, m_hwnd, NULL, g_hInstance, NULL);
    if (!m_hwndToolTip)
    {
        ERROR_OUT(("Unable to create tooltip window"));
        return(FALSE);
    }

    // Add a dead-area tooltip
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd = m_hwnd;
    ti.uId = (UINT_PTR)m_hwnd;
    ::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

    // Ensure the page buttons are disabled while starting
    UpdatePageButtons();

    // If this is the first time we have created a clipboard object,
    // register the private Whiteboard formats.
    if (g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ] == 0)
    {
        g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ] =
            (int) ::RegisterClipboardFormat("DCGWbClipFormat");
    }

    if (g_ClipboardFormats[CLIPBOARD_PRIVATE_MULTI_OBJ] == 0)
    {
        g_ClipboardFormats[CLIPBOARD_PRIVATE_MULTI_OBJ] =
            (int) ::RegisterClipboardFormat("DCGWbMultiObjClipFormat");
    }

    // There is no deleted graphic yet
    m_LastDeletedGraphic.BurnTrash();

    m_bInitOk = TRUE;

    BOOL bSuccess = TRUE;    // indicates whether window opened successfully

    // Get the position of the window from options
    RECT    rectWindow;
    RECT    rectDefault;

    ::SetRectEmpty(&rectDefault);

    OPT_GetWindowRectOption(OPT_MAIN_MAINWINDOWRECT, &rectWindow, &rectDefault);

    if (!::IsRectEmpty(&rectWindow))
    {
        ::MoveWindow(m_hwnd, rectWindow.left, rectWindow.top,
            rectWindow.right - rectWindow.left,
            rectWindow.bottom - rectWindow.top, FALSE );
    }


    // Check whether the help bar is to be visible
    if (!OPT_GetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, DFLT_MAIN_STATUSBARVISIBLE))
    {
        // Update the window to turn the help bar off
        OnStatusBarToggle();
    }

    //
    // Position the toolbar
    //

    // Hide the tool bar before moving it (otherwise we get some
    // problems redrawing it).
    ::ShowWindow(m_TB.m_hwnd, SW_HIDE);

    // Resize the window panes to allow room for the tools
    if (m_bToolBarOn)
    {
        ResizePanes();
        ::ShowWindow(m_TB.m_hwnd, SW_SHOW);
    }

    // Move the focus back from the tool window to the main window
    ::SetFocus(m_hwnd);

    // Check whether the tool window is to be visible
    if (OPT_GetBooleanOption(OPT_MAIN_TOOLBARVISIBLE, DFLT_MAIN_TOOLBARVISIBLE))
    {
        // Display the tool window, and check the associated menu item
        OnToolBarToggle();
    }

    // Set up the variable saving the maximized/minimized state of
    // the window and the extra style necessary for displaying the
    // window correctly initially.
    if (OPT_GetBooleanOption(OPT_MAIN_MAXIMIZED, DFLT_MAIN_MAXIMIZED))
    {
        m_uiWindowSize = SIZEFULLSCREEN;
        iCommand = SW_SHOWMAXIMIZED;
    }
    else if (OPT_GetBooleanOption(OPT_MAIN_MINIMIZED, DFLT_MAIN_MINIMIZED))
    {
        m_uiWindowSize = SIZEICONIC;
        iCommand = SW_SHOWMINIMIZED;
    }
    else
    {
        // Default
        m_uiWindowSize = SIZENORMAL;
        iCommand = SW_SHOWNORMAL;
    }

    UpdateWindowTitle();
    ::ShowWindow(m_hwnd, iCommand);
    ::UpdateWindow(m_hwnd);

    // Update the tool window
    ::UpdateWindow(m_TB.m_hwnd);

    // Select the tool
    m_currentMenuTool           = IDM_SELECT;
    m_pCurrentTool              = m_ToolArray[TOOL_INDEX(IDM_SELECT)];
    ::PostMessage(m_hwnd, WM_COMMAND, m_currentMenuTool, 0L);

    // Return value indicating success or failure
    return(bSuccess);
}


//
//
// Function:    WbMainWindow destructor
//
// Purpose:     Tidy up main window on destruction.
//
//
WbMainWindow::~WbMainWindow()
{
    //
    // Destroy the tooltip window
    //
    if (m_hwndToolTip)
    {
        ::DestroyWindow(m_hwndToolTip);
        m_hwndToolTip = NULL;
    }

    // Make sure the clipboard discards its saved graphic
    // before the drawingArea gets deleted.
    CLP_FreeDelayedGraphic();

    if (m_hGrobjContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hGrobjContextMenuBar);
        m_hGrobjContextMenuBar = NULL;
    }
    m_hGrobjContextMenu = NULL;

    if (m_hContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hContextMenuBar);
        m_hContextMenuBar = NULL;
    }
    m_hContextMenu = NULL;

	POSITION position = m_pageToPosition.GetHeadPosition();

	PAGE_POSITION * pPoint;

	while (position)
	{
		pPoint = (PAGE_POSITION*)m_pageToPosition.GetNext(position);
		delete pPoint;
	}

	m_pageToPosition.EmptyList();

    if (g_pwbCore)
    {
        //
        //We must call an explicit stop function, rather than 'delete'
        // because we need to pass in the event proc
        //
        g_pwbCore->WBP_Stop(WbMainWindowEventHandler);
        g_pwbCore = NULL;
    }

    DestroyToolArray();

    // Destroy our window
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    // Deregister our class
    ::UnregisterClass(szMainClassName, g_hInstance);

    //
    // Free the palette
    //
    if (g_hRainbowPaletteDisplay)
    {
        DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    g_bUsePalettes = FALSE;


    if (g_pIcons)
    {
        delete g_pIcons;
        g_pIcons = NULL;
    }

    if (g_pUsers)
    {
        delete g_pUsers;
        g_pUsers = NULL;
    }
}



//
// JoinDomain()
// Attach to the empty domain or current call
//
BOOL WbMainWindow::JoinDomain(void)
{
    BOOL bSuccess;

    CM_STATUS cmStatus;

    // If there is a call available - join it.
    if (CMS_GetStatus(&cmStatus))
    {
        m_bCallActive = TRUE;

        // Get the domain ID of the call
        m_dwJoinDomain = (DWORD) cmStatus.callID;

        // Join the call
        bSuccess = JoinCall(FALSE);
    }
    else
    {
        // No call available so join the local domain

        // Set the domain ID to "no call"
        m_dwJoinDomain = (DWORD) OM_NO_CALL;

        // Join the call
        bSuccess = JoinCall(FALSE);
    }

    // Wait for the call to be joined, if not abandoned
    if (bSuccess)
    {
        bSuccess = WaitForJoinCallComplete();
    }

    // take down init dlg
    KillInitDlg();

    return(bSuccess);
}




//
// KillInitDlg()
// Take down the init dialog
//
void WbMainWindow::KillInitDlg(void)
{
    if (m_hwndInitDlg != NULL )
    {
        ::DestroyWindow(m_hwndInitDlg);
        m_hwndInitDlg = NULL;

        ::EnableWindow(m_hwnd, TRUE);
    }

}



//
// OnToolHitTest()
// This handles tooltips for child windows.
//
int WbMainWindow::OnToolHitTest(POINT pt, TOOLINFO* pTI) const
{
    HWND    hwnd;
    int     status;
    int     nHit;

    ASSERT(!IsBadWritePtr(pTI, sizeof(TOOLINFO)));

    hwnd = ::ChildWindowFromPointEx(m_hwnd, pt, CWP_SKIPINVISIBLE);
    if (hwnd == m_AG.m_hwnd)
    {
        ::MapWindowPoints(m_hwnd, m_AG.m_hwnd, &pt, 1);
        hwnd = ::ChildWindowFromPointEx(m_AG.m_hwnd, pt, CWP_SKIPINVISIBLE);

        if (hwnd != NULL)
        {
            nHit = ::GetDlgCtrlID(hwnd);

            pTI->hwnd = m_hwnd;
            pTI->uId = (UINT_PTR)hwnd;
            pTI->uFlags |= TTF_IDISHWND;
            pTI->lpszText = LPSTR_TEXTCALLBACK;

            return(nHit);
        }
    }
    else if (hwnd == m_WG.m_hwnd)
    {
        int iItem;

        ::MapWindowPoints(m_hwnd, m_WG.m_hwnd, &pt, 1);

        iItem = m_WG.ItemFromPoint(pt.x, pt.y);

        pTI->hwnd = m_WG.m_hwnd;
        pTI->uId  = iItem;

        // Since the area isn't a window, we must fill in the rect ourself
        m_WG.GetItemRect(iItem, &pTI->rect);
        pTI->lpszText = LPSTR_TEXTCALLBACK;

        return(iItem);
    }
    else if (hwnd == m_TB.m_hwnd)
    {
        RECT        rect;
        TBBUTTON    button;
        int         i;

        for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
        {
            if (::SendMessage(m_TB.m_hwnd, TB_GETITEMRECT, i, (LPARAM)&rect) &&
                ::PtInRect(&rect, pt) &&
                ::SendMessage(m_TB.m_hwnd, TB_GETBUTTON, i, (LPARAM)&button) &&
                !(button.fsStyle & TBSTYLE_SEP))
            {
                int nHit = button.idCommand;

                pTI->hwnd = m_TB.m_hwnd;
                pTI->uId = nHit;
                pTI->rect = rect;
                pTI->lpszText = LPSTR_TEXTCALLBACK;

                // found matching rect, return the ID of the button
                return(nHit);
            }
        }
    }

    return(-1);
}


//
// WbMainWindowProc()
// Frame window message handler
//
LRESULT WbMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbMainWindow * pMain;

    pMain = (WbMainWindow *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pMain = (WbMainWindow *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ASSERT(pMain);

            pMain->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pMain);
            goto DefWndProc;
            break;

        case WM_DESTROY:
            ShutDownHelp();
            break;

        case WM_NCDESTROY:
            pMain->m_hwnd = NULL;
            break;

        case WM_MOVE:
            pMain->OnMove();
            break;

        case WM_SIZE:
            pMain->OnSize((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_ACTIVATE:
            if (GET_WM_ACTIVATE_STATE(wParam, lParam) == WA_INACTIVE)
            {
                // Cancel the tooltip if it's around
                if (pMain->m_hwndToolTip)
                    ::SendMessage(pMain->m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
            }
            goto DefWndProc;
            break;

        case WM_SETFOCUS:
            pMain->OnSetFocus();
            break;

        case WM_CANCELMODE:
            pMain->OnCancelMode();
            break;

        case WM_TIMER:
            pMain->OnTimer(wParam);
            break;

        case WM_INITMENUPOPUP:
            pMain->OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MENUSELECT:
            pMain->OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam),
                GET_WM_MENUSELECT_FLAGS(wParam, lParam),
                GET_WM_MENUSELECT_HMENU(wParam, lParam));
            break;

        case WM_MEASUREITEM:
            pMain->OnMeasureItem((int)wParam, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            pMain->OnDrawItem((int)wParam, (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_QUERYNEWPALETTE:
            lResult = pMain->OnQueryNewPalette();
            break;

        case WM_PALETTECHANGED:
            pMain->OnPaletteChanged((HWND)wParam);
            break;

        case WM_HELP:
            pMain->OnCommand(IDM_HELP, 0, NULL);
            break;

        case WM_CLOSE:
            pMain->OnClose();
            break;

        case WM_QUERYENDSESSION:
            lResult = pMain->OnQueryEndSession();
            break;

        case WM_ENDSESSION:
            pMain->OnEndSession((BOOL)wParam);
            break;

        case WM_SYSCOLORCHANGE:
            pMain->OnSysColorChange();
            break;

        case WM_USER_PRIVATE_PARENTNOTIFY:
            pMain->OnParentNotify(GET_WM_PARENTNOTIFY_MSG(wParam, lParam));
            break;

        case WM_GETMINMAXINFO:
            if (pMain)
                pMain->OnGetMinMaxInfo((LPMINMAXINFO)lParam);
            break;

        case WM_RENDERALLFORMATS:
            pMain->OnRenderAllFormats();
            break;

        case WM_RENDERFORMAT:
            pMain->CLP_RenderFormat((int)wParam);
            break;

        case WM_COMMAND:
            pMain->OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            pMain->OnNotify((UINT)wParam, (NMHDR *)lParam);
            break;

        case WM_DROPFILES:
            pMain->OnDropFiles((HDROP)wParam);
            break;

        case WM_USER_GOTO_USER_POSITION:
            pMain->OnGotoUserPosition(lParam);
            break;

        case WM_USER_GOTO_USER_POINTER:
            pMain->OnGotoUserPointer(lParam);
            break;

        case WM_USER_JOIN_CALL:
            pMain->OnJoinCall((BOOL)wParam, lParam);
            break;

        case WM_USER_DISPLAY_ERROR:
            pMain->OnDisplayError(wParam, lParam);
            break;

        case WM_USER_UPDATE_ATTRIBUTES:
            pMain->m_AG.DisplayTool(pMain->m_pCurrentTool);
            break;

        case WM_USER_JOIN_PENDING_CALL:
            pMain->OnJoinPendingCall();
            break;

        default:
            if (message == g_uConfShutdown)
            {
                lResult = pMain->OnConfShutdown(wParam, lParam);
            }
            else
            {
DefWndProc:
                lResult = DefWindowProc(hwnd, message, wParam, lParam);
            }
            break;
    }

    return(lResult);
}


//
// OnCommand()
// Command dispatcher for the main window
//
void WbMainWindow::OnCommand(UINT cmd, UINT code, HWND hwndCtl)
{
    switch (cmd)
    {
        //
        // FILE MENU
        //
        case IDM_NEW:
            OnNew();
            break;

        case IDM_OPEN:
            OnOpen();
            break;

        case IDM_SAVE:
            OnSave(FALSE);
            break;

        case IDM_SAVE_AS:
            OnSave(TRUE);
            break;

        case IDM_PRINT:
            OnPrint();
            break;

        case IDM_EXIT:
            ::PostMessage(m_hwnd, WM_CLOSE, 0, 0);
            break;

        //
        // EDIT MENU
        //
        case IDM_DELETE:
            OnDelete();
            break;

        case IDM_UNDELETE:
            OnUndelete();
            break;

        case IDM_CUT:
            OnCut();
            break;

        case IDM_COPY:
            OnCopy();
            break;

        case IDM_PASTE:
            OnPaste();
            break;

        case IDM_SELECTALL:
            OnSelectAll();
            break;

        case IDM_BRING_TO_TOP:
            m_drawingArea.BringToTopSelection();
            break;

        case IDM_SEND_TO_BACK:
            m_drawingArea.SendToBackSelection();
            break;

        case IDM_CLEAR_PAGE:
            OnClearPage();
            break;

        case IDM_DELETE_PAGE:
            OnDeletePage();
            break;

        case IDM_PAGE_INSERT_BEFORE:
            OnInsertPageBefore();
            break;

        case IDM_PAGE_INSERT_AFTER:
            OnInsertPageAfter();
            break;

        case IDM_PAGE_SORTER:
            OnPageSorter();
            break;

        //
        // VIEW MENU
        //
        case IDM_TOOL_BAR_TOGGLE:
            OnToolBarToggle();
            break;

        case IDM_STATUS_BAR_TOGGLE:
            OnStatusBarToggle();
            break;

        case IDM_ZOOM:
            OnZoom();
            break;

        //
        // TOOLS MENU
        //
        case IDM_SELECT:
        case IDM_PEN:
        case IDM_HIGHLIGHT:
        case IDM_TEXT:
        case IDM_ERASER:
        case IDM_LINE:
        case IDM_BOX:
        case IDM_FILLED_BOX:
        case IDM_ELLIPSE:
        case IDM_FILLED_ELLIPSE:
            OnSelectTool(cmd);
            break;

        case IDM_REMOTE:
            OnRemotePointer();
            break;

        case IDM_GRAB_AREA:
            OnGrabArea();
            break;

        case IDM_GRAB_WINDOW:
            OnGrabWindow();
            break;

        case IDM_SYNC:
            OnSync();
            break;

        case IDM_LOCK:
            OnLock();
            break;

        //
        // OPTIONS MENU
        //
        case IDM_COLOR:
            OnSelectColor();
            break;

        case IDM_EDITCOLOR:
            m_AG.OnEditColors();
            break;

        case IDM_FONT:
            OnChooseFont();
            break;

        case IDM_WIDTH_1:
        case IDM_WIDTH_2:
        case IDM_WIDTH_3:
        case IDM_WIDTH_4:
            OnSelectWidth(cmd);
            break;

        //
        // HELP MENU
        //
        case IDM_ABOUT:
            OnAbout();
            break;

        case IDM_HELP:
            ShowHelp();
            break;

        //
        // PAGE BAR
        //
        case IDM_PAGE_FIRST:
            OnFirstPage();
            break;

        case IDM_PAGE_PREV:
            OnPrevPage();
            break;

        case IDM_PAGE_GOTO:
            OnGotoPage();
            break;

        case IDM_PAGE_NEXT:
            OnNextPage();
            break;

        case IDM_PAGE_LAST:
            OnLastPage();
            break;

        //
        // SCROLLING
        //
        case IDM_PAGEUP:
        case IDM_PAGEDOWN:
        case IDM_SHIFTPAGEUP:
        case IDM_SHIFTPAGEDOWN:
        case IDM_HOME:
        case IDM_END:
        case IDM_LINEUP:
        case IDM_LINEDOWN:
        case IDM_SHIFTLINEUP:
        case IDM_SHIFTLINEDOWN:
            OnScrollAccelerator(cmd);
            break;
    }
}


//
// WinHelp() wrapper
//
void WbMainWindow::ShowHelp(void)
{
    HWND hwndCapture;

    // Get the main window out of any mode
    ::SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);

    // Cancel any other tracking
    if (hwndCapture = ::GetCapture())
        ::SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);

	// finally, run the Windows Help engine
    ShowNmHelp(s_cszHtmlHelpFile);
}

//
//
// Function:    OnJoinCall
//
// Purpose:     Join a call - displaying a dialog informing the user of
//              progress.
//
//
void WbMainWindow::OnJoinCall(BOOL bKeep, LPARAM lParam)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnJoinCall");

    // cancel the load if there's one in progress
    if (   (m_uiState == IN_CALL)
        && (m_uiSubState == SUBSTATE_LOADING))
    {
        CancelLoad();
    }

    // Get the parameters for JoinCall
    m_dwJoinDomain = (DWORD) lParam;

    // Start the process of joining the call
    BOOL bSuccess = JoinCall(bKeep);

    // Wait for the join call to complete, if not abandoned
    if (bSuccess)
    {
        bSuccess = WaitForJoinCallComplete();

        if (bSuccess)
        {
            TRACE_MSG(("Joined call OK"));
        }
        else
        {
            // WaitForJoinCallComplete displays appropriate error message
            TRACE_MSG(("Failed to join call"));

            // get into a good state
            Recover();
        }
    }

    // take down init dlg
    KillInitDlg();
}

//
//
// Function:    JoinCall
//
// Purpose:     Join a call - displaying a dialog informing the user of
//              progress.
//
//
BOOL WbMainWindow::JoinCall(BOOL bKeep)
{
    BOOL    bSuccess = TRUE;
    UINT    uiReturn;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::JoinCall");

    // We must not already be in a real call when we get here
    if ((m_uiState == IN_CALL) && (m_dwDomain != OM_NO_CALL))
    {
        ERROR_OUT(("In a call already"));
    }

    //
    // Prompt the user to save the current contents unless we are in
    // application start-up (when there can be no contents to save) or we
    // are keeping the contents (when there is no need to save).
    //
    if ((m_uiState != STARTING) && !bKeep)
    {
        //
        // Close the page sorter dialog if it's up.
        //
        if (m_hwndPageSortDlg != NULL)
        {
            ::SendMessage(m_hwndPageSortDlg, WM_COMMAND,
                MAKELONG(IDOK, BN_CLICKED), 0);
            ASSERT(m_hwndPageSortDlg == NULL);
        }

        TRACE_MSG(("Not in STARTING state - check whether save wanted"));

        if (m_hwndQuerySaveDlg != NULL)
        {
            ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
                MAKELONG(IDCANCEL, BN_CLICKED), 0);
            ASSERT(m_hwndQuerySaveDlg == NULL);
        }

        // flag that we are joining a call
        m_bPromptingJoinCall = TRUE;

        // ask the user whether to save changes (if required)
        int iDoNew = QuerySaveRequired(FALSE);

        // remove any save as dialog that is already up.
        if (m_bInSaveDialog)
        {
            m_bPromptingJoinCall = FALSE;
            CancelSaveDialog();
            m_bPromptingJoinCall = TRUE;
        }

        if (iDoNew == IDYES)
        {
            TRACE_MSG(("User has elected to save the changes"));

            // Save the changes
            iDoNew = OnSave(FALSE);
        }

        if (!m_bPromptingJoinCall)      // received end call notification
                                        // (during save-as or query-save)
        {
            TRACE_MSG(("Call ended - abandon JoinCall"));
            return(FALSE);
        }

        // flag we're no longer in a state where the join call can be
        // cancelled
        m_bPromptingJoinCall = FALSE;

        //
        // Reset the file name to Untitled, since we are receiving new
        // contents
        //
        ZeroMemory(m_strFileName, sizeof(m_strFileName));
		UpdateWindowTitle();
		
        // if we have the lock then release it
        if (WB_GotLock())
        {
             // Release the lock
             g_pwbCore->WBP_Unlock();

             // Set the locked check mark
             UncheckMenuItem(IDM_LOCK);

             // Pop up the lock button
             m_TB.PopUp(IDM_LOCK);
        }

        if(m_pLocalUser != NULL)
        {
            // if the remote pointer is active then turn it off
            DCWbGraphicPointer* pPointer = m_pLocalUser->GetPointer();
            if (pPointer->IsActive())
            {
                OnRemotePointer();
            }
        }

        // if sync is turned on then turn it off
        Unsync();

        // If we are not keeping the contents then the only valid current
        // page is the first page.
        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &m_hCurrentPage);
    }

    //PUTBACK BY RAND - the progress timer meter is kinda the heart beat
    //                    of this thing which I ripped out when I removed the
    //                    progress meter. I put it back to fix 1476.
    if (m_bTimerActive)
    {
        ::KillTimer(m_hwnd, TIMERID_PROGRESS_METER);
        m_bTimerActive = FALSE;
    }

    //
    // lock the drawing area until the joining of the call has succeeded
    //
    TRACE_MSG(("Locking drawing area"));
    LockDrawingArea();

    //
    // Give the drawing area a null page during the joining process.  This
    // prevents the drawing area attempting to draw the objects in the page
    // during the process of joining the call.
    //
    TRACE_MSG(("Detaching drawing area"));
    m_drawingArea.Detach();

    // Show that we are no longer in a call, but joining a new one
    TRACE_MSG(("m_uiState %d", m_uiState));
    if (m_uiState != STARTING)
    {
        m_uiState = JOINING;
        UpdatePageButtons();
    }

    // put up init dlg
    if (m_bCallActive)
    {
        ::UpdateWindow(m_hwnd);

        //
        // Our init dialog doesn't have a proc, since it has no UI to
        // interact with.  We destroy it when we are done.  So, do the
        // init stuff here.
        //
        m_hwndInitDlg = ::CreateDialogParam(g_hInstance,
            MAKEINTRESOURCE(IM_INITIALIZING), m_hwnd, NULL, 0);

        if (!m_hwndInitDlg)
        {
            ERROR_OUT(("Couldn't create startup screen for WB"));
        }
        else
        {
            RECT    rcMovie;
            HWND    hwndMovieParent;
            HWND    hwndMovie;

            // Get the rectangle to create the animation control in
            hwndMovieParent = ::GetDlgItem(m_hwndInitDlg, IDC_INITIALIZING_ANIMATION);
            ::GetClientRect(hwndMovieParent, &rcMovie);

            hwndMovie = ::CreateWindowEx(0, ANIMATE_CLASS, NULL,
                WS_CHILD | WS_VISIBLE | ACS_TRANSPARENT | ACS_CENTER,
                rcMovie.left, rcMovie.top,
                rcMovie.right - rcMovie.left, rcMovie.bottom - rcMovie.top,
                hwndMovieParent, (HMENU)IDC_INITIALIZING_ANIMATION,
                g_hInstance, NULL);

            if (hwndMovie != NULL)
            {
                ::SendMessage(hwndMovie, ACM_OPEN, 0, (LPARAM)
                    MAKEINTRESOURCE(WBMOVIE));
            }

            // Disable the main window while the dialog is up.
            ::EnableWindow(m_hwnd, FALSE);

            ::ShowWindow(m_hwndInitDlg, SW_SHOW);
            ::UpdateWindow(m_hwndInitDlg);

            if (hwndMovie != NULL)
            {
                ::SendMessage(hwndMovie, ACM_PLAY, 0xFFFF,
                    MAKELPARAM(0, 0xFFFF));
            }
        }
    }

    //
    // Start joining the call.  Throws an exception on error.
    //
    ASSERT(g_pUsers);
    g_pUsers->Clear();

    uiReturn = g_pwbCore->WBP_JoinCall(bKeep, m_dwJoinDomain);
    if (uiReturn != 0)
    {
        bSuccess = FALSE;
    }

    return(bSuccess);
}




//
//
// Function:    WaitForJoinCallComplete
//
// Purpose:     Join a call - displaying a dialog informing the user of
//              progress.
//
//
BOOL WbMainWindow::WaitForJoinCallComplete(void)
{
    BOOL    bResult = FALSE;
    TMDLG   tmdlg;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::WaitForJoinCallComplete");

    //
    // Bring up a dialog to wait for call joining to complete.  This turns
    // the asynchronous registration process into a synchronous process as
    // far as this routine is concerned.
    //

    //
    // Set the window title to show we're no longer registering/joining a
    // call.
    //
	UpdateWindowTitle();

    ASSERT(m_hwndWaitForEventDlg == NULL);

    //
    // This is the data we use in the timed dialog
    //
    ZeroMemory(&tmdlg, sizeof(tmdlg));
    tmdlg.bVisible = FALSE;
    tmdlg.bLockNotEvent = FALSE;
    tmdlg.uiMaxDisplay = MAIN_REGISTRATION_TIMEOUT;

    ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(INVISIBLEDIALOG),
        m_hwnd, TimedDlgProc, (LPARAM)&tmdlg);

    ASSERT(m_hwndWaitForEventDlg == NULL);

    //
    // Set the window title to show we're no longer registering/joining a
    // call.
    //
	UpdateWindowTitle();
	
    if (m_uiState != IN_CALL)
    {
        //
        // We failed to join the call
        //
        WARNING_OUT(("User cancelled or joincall failed, m_uiState %d", m_uiState));

        //
        // We must display an error inline here because we will close
        // shortly
        //
        OnDisplayError(WBFE_RC_JOIN_CALL_FAILED, 0);
    }
    else
    {
        bResult = TRUE;
    }

    return(bResult);
}


//
// TimedDlgProc()
// This puts up a visible or invisible dialog which only goes away when
// an event occurs or a certain amount of time has passed.  We store the
// DialogBoxParam parameter, a TMDLG pointer, in our user data.  That is
// from the stack of the DialogBoxParam() caller, so it is valid until that
// function returns, which won't be until a bit after the dialog has been
// destroyed.
//
INT_PTR CALLBACK TimedDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL        fHandled = FALSE;
    TMDLG *     ptm;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ptm = (TMDLG *)lParam;
            ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptm);

            //
            // Set the WbMainWindow hwnd
            //
            if (ptm->bLockNotEvent)
            {
                g_pMain->m_hwndWaitForLockDlg = hwnd;
            }
            else
            {
                g_pMain->m_hwndWaitForEventDlg = hwnd;
            }

            //
            // Set max timer
            //
            ::SetTimer(hwnd, TIMERID_MAXDISPLAY, ptm->uiMaxDisplay, NULL);

            //
            // Change the cursor if invisible
            //
            if (!ptm->bVisible)
                ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

            fHandled = TRUE;
            break;

        case WM_TIMER:
            ASSERT(wParam == TIMERID_MAXDISPLAY);

            // End the dialog--since we timed out, it acts like cancel
            ::SendMessage(hwnd, WM_COMMAND, MAKELONG(IDCANCEL, BN_CLICKED), 0);

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        ptm = (TMDLG *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
                        ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));

                        // Clear out the HWND variable
                        if (ptm->bLockNotEvent)
                        {
                            g_pMain->m_hwndWaitForLockDlg = NULL;
                        }
                        else
                        {
                            g_pMain->m_hwndWaitForEventDlg = NULL;
                        }

                        // Restore the cursor
                        if (!ptm->bVisible)
                            ::SetCursor(::LoadCursor(NULL, IDC_ARROW));

                        ::KillTimer(hwnd, TIMERID_MAXDISPLAY);

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                    }
                    break;
            }

            fHandled = TRUE;
            break;

        //
        // Don't let these dialogs be killed by any other means than our
        // getting an event or timing out.
        //
        case WM_CLOSE:
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}

//
// FilterMessage()
//
// This does tooltip message filtering, then translates accelerators.
//
BOOL WbMainWindow::FilterMessage(MSG* pMsg)
{
    BOOL   bResult = FALSE;

   	if ((pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST) ||
    	(pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_LBUTTONDBLCLK) ||
	    (pMsg->message == WM_RBUTTONDOWN || pMsg->message == WM_RBUTTONDBLCLK) ||
	    (pMsg->message == WM_MBUTTONDOWN || pMsg->message == WM_MBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCLBUTTONDOWN || pMsg->message == WM_NCLBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCRBUTTONDOWN || pMsg->message == WM_NCRBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCMBUTTONDOWN || pMsg->message == WM_NCMBUTTONDBLCLK))
   	{
        // Cancel any tooltip up
        ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
   	}

	// handle tooltip messages (some messages cancel, some may cause it to popup)
	if ((pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE ||
		 pMsg->message == WM_LBUTTONUP || pMsg->message == WM_RBUTTONUP ||
		 pMsg->message == WM_MBUTTONUP) &&
		(GetKeyState(VK_LBUTTON) >= 0 && GetKeyState(VK_RBUTTON) >= 0 &&
		 GetKeyState(VK_MBUTTON) >= 0))
	{
#if 0
        //
        // If this mouse move isn't for a descendant of the main window, skip
        // it.  For example, when the tooltip is shown, it gets a mousemove
        // to itself, which if we didn't check for it, would cause us to
        // immediately dismiss this!
        //
        HWND    hwndTmp = pMsg->hwnd;

        while (hwndTmp && (::GetWindowLong(hwndTmp, GWL_STYLE) & WS_CHILD))
        {
            hwndTmp = ::GetParent(hwndTmp);
        }

        if (hwndTmp != m_hwnd)
        {
            // This is not for us, it's for another top level window in
            // our app.
            goto DoneToolTipFiltering;
        }
#endif

		// determine which tool was hit
        POINT   pt;

        pt = pMsg->pt;
		::ScreenToClient(m_hwnd, &pt);

		TOOLINFO tiHit;

        ZeroMemory(&tiHit, sizeof(tiHit));
		tiHit.cbSize = sizeof(TOOLINFO);

		int nHit = OnToolHitTest(pt, &tiHit);

		if (m_nLastHit != nHit)
		{
			if (nHit != -1)
			{
				// add new tool and activate the tip
                if (!::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&tiHit))
                {
                    ERROR_OUT(("TTM_ADDTOOL failed"));
                }

				if (::GetActiveWindow() == m_hwnd)
				{
					// allow the tooltip to popup when it should
                    ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, TRUE, 0);

					// bring the tooltip window above other popup windows
					::SetWindowPos(m_hwndToolTip, HWND_TOP, 0, 0, 0, 0,
						SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE);
				}
			}

			// relay mouse event before deleting old tool
            ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);

			// now safe to delete the old tool
            if (m_tiLastHit.cbSize != 0)
                ::SendMessage(m_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&m_tiLastHit);

            m_nLastHit = nHit;
            m_tiLastHit = tiHit;
		}
		else
		{
			// relay mouse events through the tooltip
			if (nHit != -1)
                ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);
		}
	}

#if 0
DoneToolTipFiltering:
#endif
    // Assume we will use the main accelerator table
    HACCEL hAccelTable = m_hAccelTable;

    // If this window has focus, just continue
    HWND hwndFocus = ::GetFocus();
    if (hwndFocus && (hwndFocus != m_hwnd))
    {
        // Check whether an edit field in the pages group has the focus
        if (m_AG.IsChildEditField(hwndFocus))
        {
            hAccelTable = m_hAccelPagesGroup;
        }
        // Check whether text editor has the focus and is active
        else if (   (hwndFocus == m_drawingArea.m_hwnd)
                 && (m_drawingArea.TextEditActive()))
        {
            // Let editbox do its own acceleration.
            hAccelTable = NULL;
        }
    }

    return (   (hAccelTable != NULL)
          && ::TranslateAccelerator(m_hwnd, hAccelTable, pMsg));
}




//
//
// Function:    OnDisplayError
//
// Purpose:     Display an error message
//
//
void WbMainWindow::OnDisplayError(WPARAM uiFEReturnCode, LPARAM uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDisplayError");

    // Only continue if we are not currently displaying an error
    if (!m_bDisplayingError)
    {
        // Show that we are currently displaying an error message
        m_bDisplayingError = TRUE;

        // Display the error
        ::ErrorMessage((UINT)uiFEReturnCode, (UINT)uiDCGReturnCode);

        // Show that we are no longer displaying an error
        m_bDisplayingError = FALSE;
    }
}


//
//
// Function:    OnTimer
//
// Purpose:     Process a timer event. These are used to update the progress
//              meter and the sync position.
//
//
void WbMainWindow::OnTimer(UINT_PTR idTimer)
{
    TRACE_TIMER(("WbMainWindow::OnTimer"));

    //
    // Only do anything if the timer has not been switched off (this may be an
    // old timer message left in the queue when we stopped the timer).
    //
    if (m_bTimerActive)
    {
        //
        // Check for sync position update needed
        //

        // Check whether an update is flagged
        if (m_bSyncUpdateNeeded)
        {
            TRACE_TIMER(("Updating sync position"));

            // Check whether the local user is still synced
            if ((m_uiState == IN_CALL) &&
                (m_pLocalUser != NULL) &&
                (m_pLocalUser->IsSynced()) &&
                (!WB_ContentsLocked()))
            {
                RECT    rcVis;

                // Update the local user's position information
                m_drawingArea.GetVisibleRect(&rcVis);

                m_pLocalUser->SetVisibleRect(&rcVis);

                // Write the sync position from the local user's current position
                m_pLocalUser->PutSyncPosition();
            }

            // Show that the update has been done
            m_bSyncUpdateNeeded = FALSE;
        }
    }
}


//
//
// Function:    OnPaletteChanged
//
// Purpose:     The palette has changed.
//
//
void WbMainWindow::OnPaletteChanged(HWND hwndPalette)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaletteChanged");

    if ((hwndPalette != m_hwnd) &&
        (hwndPalette != m_drawingArea.m_hwnd))
    {
        // Tell the drawing area to realize its palette
        m_drawingArea.RealizePalette( TRUE );
    }
}



//
//
// Function:    OnQueryNewPalette
//
// Purpose:     We are getting focus and must realize our palette
//
//
LRESULT WbMainWindow::OnQueryNewPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnQueryNewPalette");

    // Tell the drawing area to realize its palette
    m_drawingArea.RealizePalette( FALSE );

    return TRUE;
}



//
//
// Function:    WbMainWindowEventHandler
//
// Purpose:     Event handler for WbMainWindow objects. This is a class
//              wide function. The client data passed to it is a pointer
//              to the instance of WbMainWindow for which the event is
//              intended.
//
//
BOOL CALLBACK WbMainWindowEventHandler
(
    LPVOID  utHandle,
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    if (g_pMain->m_hwnd != NULL)
    {
        return(g_pMain->EventHandler(event, param1, param2));
    }
    else
    {
        return(FALSE);
    }
}


//
//
// Function:    EventHandler
//
// Purpose:     Handler for DC-Groupware events for this object
//
//
BOOL WbMainWindow::EventHandler(UINT Event, UINT_PTR param1, UINT_PTR param2)
{
    BOOL    processed;

    switch (Event)
    {
        case CMS_NEW_CALL:
        case CMS_END_CALL:

        case ALS_LOCAL_LOAD:
        case ALS_REMOTE_LOAD_RESULT:

        case WBP_EVENT_JOIN_CALL_OK:
        case WBP_EVENT_JOIN_CALL_FAILED:
        case WBP_EVENT_NETWORK_LOST:
        case WBP_EVENT_ERROR:
        case WBP_EVENT_PAGE_CLEAR_IND:
        case WBP_EVENT_PAGE_ORDER_UPDATED:
        case WBP_EVENT_PAGE_DELETE_IND:
        case WBP_EVENT_CONTENTS_LOCKED:
        case WBP_EVENT_PAGE_ORDER_LOCKED:
        case WBP_EVENT_UNLOCKED:
        case WBP_EVENT_LOCK_FAILED:
        case WBP_EVENT_GRAPHIC_ADDED:
        case WBP_EVENT_GRAPHIC_MOVED:
        case WBP_EVENT_GRAPHIC_UPDATE_IND:
        case WBP_EVENT_GRAPHIC_REPLACE_IND:
        case WBP_EVENT_GRAPHIC_DELETE_IND:
        case WBP_EVENT_PERSON_JOINED:
        case WBP_EVENT_PERSON_LEFT:
        case WBP_EVENT_PERSON_UPDATE:
        case WBP_EVENT_PERSON_REPLACE:
        case WBP_EVENT_SYNC_POSITION_UPDATED:
        case WBP_EVENT_LOAD_COMPLETE:
        case WBP_EVENT_LOAD_FAILED:
            // Process the Event
            ProcessEvents(Event, param1, param2);
            processed = TRUE;
            break;

        default:
            processed = FALSE;
            break;
    }

    return(processed);
}


//
//
// Function:    PopupContextMenu
//
// Purpose:     Popup the context menu for the drawing area. This is called
//              by the drawing area window on a right mouse click.
//
//
void WbMainWindow::PopupContextMenu(int x, int y)
{
    POINT   surfacePos;
    RECT    clientRect;
    DCWbGraphic * pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::PopupContextMenu");

    surfacePos.x = x;
    surfacePos.y = y;

    // figure out which popup menu to use (bug 426)
    if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
    {
        m_drawingArea.ClientToSurface(&surfacePos);
        if( (pGraphic = m_drawingArea.GetHitObject( surfacePos )) != NULL )
        {
            // we clicked over an object, see if its already selected
            if( !m_drawingArea.IsSelected( pGraphic ) )
            {
                // object is not already selected, zap current selection and then select it
                m_drawingArea.ClearSelection();
                m_drawingArea.SelectGraphic( pGraphic );
            }
            else
            {
                // plug leak by deleteing pGraphic
                delete pGraphic;
            }
        }

        if( m_drawingArea.GraphicSelected() )
        {
            // selector tool is active, and one or more objects are selected
            m_hInitMenu = m_hGrobjContextMenu;
        }
        else
        {
            // no current selection, show drawing menu
            m_hInitMenu = m_hContextMenu;
        }
    }
    else
    {
        // no objects selected, use drawing menu
        m_hInitMenu = m_hContextMenu;
    }

    // set up current menu state
    SetMenuStates(m_hInitMenu);

    // pop it up
    ::GetClientRect(m_drawingArea.m_hwnd, &clientRect);
    ::MapWindowPoints(m_drawingArea.m_hwnd, NULL, (LPPOINT)&clientRect.left, 2);

    ::TrackPopupMenu(m_hInitMenu, TPM_RIGHTALIGN | TPM_RIGHTBUTTON,
                                 x + clientRect.left,
                                 y + clientRect.top,
                                 0,
                                 m_hwnd,
                                 NULL);

    // reset m_hInitMenu to indicate the popup menu isn't being shown anymore
    m_hInitMenu = NULL;
}




//
//
// Function: ProcessEvents
//
// Purpose: Process events that have been queued internally
//
//
void WbMainWindow::ProcessEvents(UINT Event, UINT_PTR param1, UINT_PTR param2)
{
    HWND hwndLastPopup;

    TRACE_EVENT(("WbMainWindow::ProcessEvents"));

    //
    // If we are closing, ignore it.
    //
    if (m_uiState == CLOSING)
    {
        TRACE_EVENT(("ProcessEvents: ignored because WB is closing"));
        return;
    }

    //
    // If we are busy drawing,  we postpone it until later when we can
    // handle it.
    //
    // If the page sorter dialog is up, it gets notified by the appropriate
    // event handler after the fact.
    //
    if (m_drawingArea.IsBusy())
    {
        TRACE_EVENT(("Reposting event %x, param1 %d param2 %d", Event, param1, param2));
        g_pwbCore->WBP_PostEvent(200, Event, param1, param2);
        return;
    }

    TRACE_EVENT(("Event %x, m_uiState %d", Event, m_uiState));

    //
    // Process according to the event type.
    //
    switch (Event)
    {
        case CMS_NEW_CALL:
            OnCMSNewCall((BOOL)param1, (DWORD)param2);
            break;

        case CMS_END_CALL:
            OnCMSEndCall();
            break;

        case ALS_LOCAL_LOAD:
            switch (m_uiState)
            {
                case IN_CALL:
                case ERROR_STATE:
                    // show the main window normal/minimized as necessary
                    hwndLastPopup = ::GetLastActivePopup(m_hwnd);

                    if (::IsIconic(m_hwnd))
                        ::ShowWindow(m_hwnd, SW_RESTORE);
                    else
                        ::ShowWindow(m_hwnd, SW_SHOW);

                    ::SetForegroundWindow(hwndLastPopup);

                    if (param2)
                    {
                        if (m_uiState == IN_CALL)
                            LoadCmdLine((LPCSTR)param2);
                        ::GlobalFree((HGLOBAL)param2);
                    }
                    break;

                default:
                    TRACE_MSG(("Joining a call so try load later",
                            (LPCTSTR)param2));
                    g_pwbCore->WBP_PostEvent(400, Event, param1, param2);
                    break;
            }
            break;

        case ALS_REMOTE_LOAD_RESULT:
            OnALSLoadResult((UINT)param1);
            break;

        case WBP_EVENT_JOIN_CALL_OK:
            OnWBPJoinCallOK();
            break;

        case WBP_EVENT_JOIN_CALL_FAILED:
            OnWBPJoinCallFailed();
            break;

        case WBP_EVENT_NETWORK_LOST:
            OnWBPNetworkLost();
            break;

        case WBP_EVENT_ERROR:
            OnWBPError();
            break;

        case WBP_EVENT_PAGE_CLEAR_IND:
            OnWBPPageClearInd((WB_PAGE_HANDLE) param1);
            break;

        case WBP_EVENT_PAGE_ORDER_UPDATED:
            OnWBPPageOrderUpdated();
            break;

        case WBP_EVENT_PAGE_DELETE_IND:
            OnWBPPageDeleteInd((WB_PAGE_HANDLE) param1);
            break;

        case WBP_EVENT_CONTENTS_LOCKED:
            OnWBPContentsLocked((POM_OBJECT) param2);
            break;

        case WBP_EVENT_PAGE_ORDER_LOCKED:
            OnWBPPageOrderLocked((POM_OBJECT) param2);
            break;

        case WBP_EVENT_UNLOCKED:
            OnWBPUnlocked((POM_OBJECT) param2);
            break;

        case WBP_EVENT_LOCK_FAILED:
            OnWBPLockFailed();
            break;

        case WBP_EVENT_GRAPHIC_ADDED:
            OnWBPGraphicAdded((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_MOVED:
            OnWBPGraphicMoved((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_UPDATE_IND:
            OnWBPGraphicUpdateInd((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_REPLACE_IND:
            OnWBPGraphicReplaceInd((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_DELETE_IND:
            OnWBPGraphicDeleteInd((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_PERSON_JOINED:
            OnWBPUserJoined((POM_OBJECT) param2);
            break;

        case WBP_EVENT_PERSON_LEFT:
            OnWBPUserLeftInd((POM_OBJECT) param2);
            break;

        case WBP_EVENT_PERSON_UPDATE:
            OnWBPUserUpdateInd((POM_OBJECT) param2, FALSE);
            break;

        case WBP_EVENT_PERSON_REPLACE:
            OnWBPUserUpdateInd((POM_OBJECT) param2, TRUE);
            break;

        case WBP_EVENT_SYNC_POSITION_UPDATED:
            OnWBPSyncPositionUpdated();
            break;

        case WBP_EVENT_LOAD_COMPLETE:
            OnWBPLoadComplete();
            break;

        case WBP_EVENT_LOAD_FAILED:
            OnWBPLoadFailed();
            break;

        default:
            WARNING_OUT(("Unrecognized event %x", Event));
            break;
    }
}


//
//
// Function:    OnCMSNewCall
//
// Purpose:     Handler for CMS_NEW_CALL
//
//
void WbMainWindow::OnCMSNewCall(BOOL fTopProvider, DWORD _m_dwDomain)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCMSNewCall");

    //
    // If we created the call
    //
    if (fTopProvider)
    {
        // Join the call, keep existing contents
        if (m_uiState == IN_CALL)
        {
            //
            // Join the call but keep any existing messages.
            //
            ::PostMessage(m_hwnd, WM_USER_JOIN_CALL, 1, (LONG) _m_dwDomain);
        }
        else
        {
            m_bJoinCallPending = TRUE;
            m_dwPendingDomain = _m_dwDomain;
            m_bPendingCallKeepContents = TRUE;
        }
    }
    else
    {
        CM_STATUS status;

        CMS_GetStatus(&status);

        if (!(status.attendeePermissions & NM_PERMIT_USEOLDWBATALL))
        {
            WARNING_OUT(("OLD WB: not joining call, not permitted"));
            return;
        }

        if (m_uiState == IN_CALL)
        {
            //
            // Join the call, throwing away our current contents (after
            // prompting the user to save them first).
            //
            ::PostMessage(m_hwnd, WM_USER_JOIN_CALL, 0, (LONG) _m_dwDomain);
        }
        else
        {
            m_bJoinCallPending = TRUE;
            m_dwPendingDomain = _m_dwDomain;
            m_bPendingCallKeepContents = FALSE;
        }
    }

    //
    // Get the call status correct.
    //
    m_bCallActive = TRUE;
	UpdateWindowTitle();
}

//
//
// Function:    OnJoinPendingCall
//
// Purpose:     Handler for WM_USER_JOIN_PENDING_CALL
//
//
void WbMainWindow::OnJoinPendingCall(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnJoinPendingCall");

    //
    // If there's still a pending call (haven't received an end-call message
    // between posting the WM_USER_JOIN_PENDING_CALL and getting here).
    //
    if (m_bJoinCallPending)
    {
        //
        // Post a message to join the call
        //
        ::PostMessage(m_hwnd, WM_USER_JOIN_CALL,
                  m_bPendingCallKeepContents,
                  (LONG) m_dwPendingDomain);

        // cancel call-pending status
        m_bJoinCallPending = FALSE;
    }
}


//
//
// Function:    OnCMSEndCall
//
// Purpose:     Handler for CMS_END_CALL
//
//
void WbMainWindow::OnCMSEndCall(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCMSEndCall");

    //
    // Flag to cancel any current join-call processing, and destroy any
    // associated dialogs.
    //
    if (m_bPromptingJoinCall)
    {
        m_bPromptingJoinCall = FALSE;
        if (m_hwndQuerySaveDlg != NULL)
        {
            ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
                MAKELONG(IDCANCEL, BN_CLICKED), 0);
            ASSERT(m_hwndQuerySaveDlg == NULL);
        }
    }

    //
    // Show that we are no longer in a call
    //
    m_dwDomain = OM_NO_CALL;

    //
    // If currently in the process of joining a call, then set the domain
    // we're joining to NO_CALL and join the local (singleton) domain.
    // Get the call status correct.
    //
    m_bCallActive = FALSE;
    TRACE_MSG(("m_uiState %d", m_uiState));
    m_dwDomain = OM_NO_CALL;

    //
    // Show there is no call pending
    //
    m_bJoinCallPending = FALSE;

    //
    // Update the window title with "not in call"
    //
	UpdateWindowTitle();
}

//
//
// Function:    OnWBPJoinCallOK
//
// Purpose:     Handler for WBP_EVENT_JOIN_CALL_OK
//
//
void WbMainWindow::OnWBPJoinCallOK(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPJoinCallOK");

    //
    // Record that we have joined the call, but the drawing area is not yet
    // ready for input (because we have not yet attached to a page).
    //
    m_uiState = JOINED;

    //
    // Get the local user
    //
    m_pLocalUser = WB_LocalUser();
    if (!m_pLocalUser)
    {
        ERROR_OUT(("Can't join call; can't create local user object, m_pLocalUser!"));
        m_uiState = ERROR_STATE;
    }
    else
    {
        //
        // Get the first user in the call
        //
        WbUser* pUser = WB_GetFirstUser();

        //
        // Loop through all available users
        //
        while (pUser != NULL)
        {
            //
            // Make updates necessary for a user joining
            //
            UserJoined(pUser);

            //
            // Get the next user
            //
            pUser = WB_GetNextUser(pUser);
        }

        //
        // If the registration dialog is up - cancel it
        //
        m_uiState = IN_CALL; // have to set m_uiState before zapping
                                      // m_hwndWaitForEventDlg or it will
                                      // think the call failed now (the
                                      // delay has been removed from
                                      // EndDialogDelayed() (bug 3881)
    }

    if (m_hwndWaitForEventDlg != NULL)
    {
        TRACE_MSG(("Joined call OK - end dialog"));
        ::SendMessage(m_hwndWaitForEventDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForEventDlg == NULL);
    }

    if (!m_pLocalUser)
    {
        //
        // BAIL out, we can't join the call
        return;
    }

    //
    // Now complete the join call processing
    //
    TRACE_MSG(("Successfully joined the call"));
    m_dwDomain = m_dwJoinDomain;

    //
    // If we have never attached to a page before (ie at start up), attach
    // to the first available page in the drawing area.  If we are joining
    // a call then we reattach to the current page
    //
    if (m_hCurrentPage == WB_PAGE_HANDLE_NULL)
    {
        TRACE_MSG(("Attach to first page"));
        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &m_hCurrentPage);
    }
    else
    {
        TRACE_DEBUG(("Just joined new call, reattach to the current page."));
    }
    m_drawingArea.Attach(m_hCurrentPage);

    // Display the initial status
    UpdateStatus();


    ::SetTimer(m_hwnd, TIMERID_PROGRESS_METER, MAIN_PROGRESS_TIMER, NULL);
    m_bTimerActive = TRUE;

    //
    // Unlock the drawing area, allowing user updates (unless its already
    // locked by someone else)
    //
    if (!WB_ContentsLocked())
    {
        UnlockDrawingArea();
    }

    // Set the substate (also updates page buttons)
    SetSubstate(SUBSTATE_IDLE);

    //
    // If we aren't synced, then sync now.
    // Set the window title to show we're no longer registering/joining a
    // call
    //
    Sync();
	UpdateWindowTitle();

    //
    // If we were joining the local domain, and a join call message arrived
    // in the meantime, then join that call now.
    //
    if ((m_bJoinCallPending) && (m_dwJoinDomain == OM_NO_CALL))
    {
        ::PostMessage(m_hwnd, WM_USER_JOIN_PENDING_CALL, 0, 0L);
    }
}


//
//
// Function:    OnWBPJoinCallFailed
//
// Purpose:     Handler for WBP_EVENT_JOIN_CALL_FAILED
//
//
void WbMainWindow::OnWBPJoinCallFailed(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPJoinCallFailed");

    //
    // If we have just failed to join a new call (not a single domain) it
    // may be because the call ended before we had time to join it
    // completely - try joining the single domain.
    //
    if ((m_uiState == STARTING) && (m_dwJoinDomain != OM_NO_CALL))
    {
        WARNING_OUT(("Failed to join call on startup, try local domain"));
        m_dwJoinDomain = OM_NO_CALL;
        m_bCallActive  = FALSE;
        JoinCall(FALSE);
    }
    else
    {
        //
        // Tell the registration dialog to finish
        //
        if (m_hwndWaitForEventDlg != NULL)
        {
            WARNING_OUT(("Failed to join call - end dialog"));
            ::SendMessage(m_hwndWaitForEventDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
            ASSERT(m_hwndWaitForEventDlg == NULL);
        }

        m_uiState = ERROR_STATE;
    }
}


//
//
// Function:    OnWBPNetworkLost
//
// Purpose:     Handler for WBP_EVENT_NETWORK_LOST
//
//
void WbMainWindow::OnWBPNetworkLost(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPNetworkLost");

    //
    // We have lost contact with the other people in the call.
    // Treat as if we got an end call (we should get an end call too, but
    // other intervening events might occur (such as trying to join a
    // call).
    //
    OnCMSEndCall();
}

//
//
// Function:    OnWBPError
//
// Purpose:     Handler for WBP_EVENT_ERROR
//
//
void WbMainWindow::OnWBPError(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPError");

    // Inform the user of the error.
    ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, 0);
}

//
//
// Function:    OnWBPPageClearInd
//
// Purpose:     Handler for WBP_EVENT_PAGE_CLEAR_IND
//
//
void WbMainWindow::OnWBPPageClearInd(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageClearInd");

    // Confirm the clearing of the page. This is OK even if the page being
    // cleared is the current page because we already know that the drawing
    // area is not busy (otherwise we would not be here).

    // If there's an object on the page which has been copied to the
    // clipboard with delayed rendering, then save it
    if (CLP_LastCopiedPage() == hPage)
    {
        CLP_SaveDelayedGraphic();
    }

    // If it is the current page being cleared
    if (m_hCurrentPage == hPage)
        {
        m_drawingArea.PageCleared();
        }

    // If there is a last deleted graphic
    // and it belongs to the page being cleared.
    if ((m_LastDeletedGraphic.GotTrash()) &&
        (m_LastDeletedGraphic.Page() == hPage))
    {
        // Free the last deleted graphic
        m_LastDeletedGraphic.BurnTrash();
    }

    g_pwbCore->WBP_PageClearConfirm(hPage);

    //
    // Notify the page sorter AFTER the page has been cleared
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_PAGECLEARIND, (WPARAM)hPage, 0);
    }
}


//
//
// Function:    OnWBPPageOrderUpdated
//
// Purpose:     Handler for WBP_EVENT_PAGE_ORDER_UPDATED
//
//
void WbMainWindow::OnWBPPageOrderUpdated(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageOrderUpdated");

    m_drawingArea.CancelDrawingMode();

    // The page order has changed, we just need to update the number of the
    // current page in the pages group.
    UpdateStatus();

    //
    // Notify the page sorter AFTER the page order has been updated
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_PAGEORDERUPD, 0, 0);
    }
}

//
//
// Function:    OnWBPPageDeleteInd
//
// Purpose:     Handler for WBP_EVENT_PAGE_DELETE_IND
//
//
void WbMainWindow::OnWBPPageDeleteInd(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageDeleteInd");

    //
    // Notify the page sorter BEFORE the page is deleted
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_PAGEDELIND, (WPARAM)hPage, 0);
    }

    m_drawingArea.CancelDrawingMode();

    // Remove it from the page-position map
    PAGE_POSITION *mapob;
    POSITION savedPos;
	POSITION position = m_pageToPosition.GetHeadPosition();
	BOOL bFound = FALSE;
	while (position && !bFound)
	{
		savedPos = position;
		mapob = (PAGE_POSITION *)m_pageToPosition.GetNext(position);
		if ( mapob->hPage == hPage)
		{
			bFound = TRUE;
		}
	}

	if(bFound)
	{
        m_pageToPosition.RemoveAt(savedPos);
        delete mapob;
    }

    // A page has been deleted.  If it is the current page we must attach
    // a different page to the drawing area. In any case we should confirm
    // the delete.

    // If there's an object on the page which has been copied to the
    // clipboard with delayed rendering, then save it
    if (CLP_LastCopiedPage() == hPage)
    {
        CLP_SaveDelayedGraphic();
    }

    if (hPage == m_hCurrentPage)
    {
        // Check whether we are deleting the last page
        WB_PAGE_HANDLE hNewPage;

        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_LAST, &hNewPage);
        if (hNewPage == hPage)
        {
            // We are deleting the last page, so go back one
            hNewPage = PG_GetPreviousPage(hPage);
        }
        else
        {
            // We are not deleting the last page, so go forward one
            hNewPage = PG_GetNextPage(hPage);
        }

        // Check that we got a different page to the one being deleted
        ASSERT(hNewPage != hPage);

        // Lock the drawing area - this ensures we are no longer editing
        // any text etc.
        LockDrawingArea();

        // Move to the new page
        GotoPage(hNewPage);

        // Unlock the drawing area (unless we're doing a new, in which case we
        // leave it locked - it will become unlocked when the new completes)
        if (   (!WB_ContentsLocked())
            && (m_uiState == IN_CALL)
            && (m_uiSubState != SUBSTATE_NEW_IN_PROGRESS))
        {
            UnlockDrawingArea();
        }
    }

    // If there is a last deleted graphic
    if ((m_LastDeletedGraphic.GotTrash()) &&
        (m_LastDeletedGraphic.Page() == hPage))
    {
        // Free the last deleted graphic
        m_LastDeletedGraphic.BurnTrash();
    }

    // if the remote pointer is on the deleted page then turn it off
    ASSERT(m_pLocalUser);
    DCWbGraphicPointer* pPointer = m_pLocalUser->GetPointer();
    if (   (pPointer->IsActive())
        && (pPointer->Page() == hPage))
        {
        OnRemotePointer();
        }

    // Let the core delete the page
    g_pwbCore->WBP_PageDeleteConfirm(hPage);

    // if this is last page to be deleted, then the file/new is complete
    if ((m_uiSubState == SUBSTATE_NEW_IN_PROGRESS)
        && (g_pwbCore->WBP_ContentsCountPages() == 1))
        {
        SetSubstate(SUBSTATE_IDLE);

        ReleasePageOrderLock();

        if (!WB_ContentsLocked())
            {
            UnlockDrawingArea();
            }
        }

    // Update the status (there is a new number of pages)
    UpdateStatus();
}

//
//
// Function:    OnWBPContentsLocked
//
// Purpose:     Handler for WBP_EVENT_CONTENTS_LOCKED
//
//
void WbMainWindow::OnWBPContentsLocked(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPContentsLocked");

    //
    // Notify page sorter dialog that the lock status has changed
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_LOCKCHANGE, 0, 0);
    }

    if (m_uiState != IN_CALL)
    {
        TRACE_MSG(("Lock indication received out of call - ignored"));
    }
    else
    {
        ASSERT(m_pLocalUser);

        if (m_pLocalUser->Handle() == hUser)
        {
            // We have acquired the lock

            // Set the locked check mark
            CheckMenuItem(IDM_LOCK);

            // Tell the tool bar of the new selection
            m_TB.PushDown(IDM_LOCK);
        }
        else
        {
            //
            // A remote user has acquired the lock:
            // If we're not synced, then sync now.
            //
            Sync();

            // Tell the drawing area it is now locked
            LockDrawingArea();

            // ensure the page button enable/disable state is correct
            UpdatePageButtons();
        }
    }

    //
    // If the lock dialog is up - cancel it.
    //
    if (m_hwndWaitForLockDlg != NULL)
    {
        ::SendMessage(m_hwndWaitForLockDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForLockDlg == NULL);
    }
}

//
//
// Function:    OnWBPPageOrderLocked
//
// Purpose:     Handler for WBP_EVENT_PAGE_ORDER_LOCKED
//
//
void WbMainWindow::OnWBPPageOrderLocked(POM_OBJECT)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageOrderLocked");

    // If the lock dialog is up - cancel it
    if (m_hwndWaitForLockDlg != NULL)
    {
        ::SendMessage(m_hwndWaitForLockDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForLockDlg == NULL);
    }

    // Update the page sorter
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_LOCKCHANGE, 0, 0);
    }

    if (!WB_GotLock())
    {
        EnableToolbar( FALSE );
        UpdatePageButtons();
    }
}

//
//
// Function:    OnWBPUnlocked
//
// Purpose:     Handler for WBP_EVENT_UNLOCKED
//
//
void WbMainWindow::OnWBPUnlocked(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUnlocked");

    // Update the page sorter if it's around
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_LOCKCHANGE, 0, 0);
    }

    // Uncheck the lock menu item
    UncheckMenuItem(IDM_LOCK);

    // Tell the tool bar of the change
    m_TB.PopUp(IDM_LOCK);

    // If a remote user is releasing the lock, and we're in a state where
    // it's safe to unlock the drawing area...
    if ((m_pLocalUser != NULL) &&
        (m_pLocalUser->Handle() != hUser) &&
        (m_uiState == IN_CALL))
    {
        // Tell the drawing area it is no longer locked
        UnlockDrawingArea();
    }

    // ensure the page button enable/disable state is correct
    UpdatePageButtons();
    m_bUnlockStateSettled = TRUE; //Allow page operations now
}

//
//
// Function:    OnWBPLockFailed
//
// Purpose:     Handler for WBP_EVENT_LOCK_FAILED
//
//
void WbMainWindow::OnWBPLockFailed(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPLockFailed");

    // If the lock dialog is up - kill it
    if (m_hwndWaitForLockDlg != NULL)
    {
        ::SendMessage(m_hwndWaitForLockDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForLockDlg == NULL);
    }
}

//
//
// Function:    OnWBPGraphicAdded
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_ADDED
//
//
void WbMainWindow::OnWBPGraphicAdded
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicAdded");

    // We only need to take action if the page to which the graphic has
    // been added is the current page.
    if (hPage == m_hCurrentPage && (!(hGraphic->flags & DELETED)))
    {
        // Retrieve the graphic that has been added
        DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

        // Tell the drawing area of the new graphic
        m_drawingArea.GraphicAdded(pGraphic);

        // Free the graphic
        delete pGraphic;
    }
}

//
//
// Function:    OnWBPGraphicMoved
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_MOVED
//
//
void WbMainWindow::OnWBPGraphicMoved
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicMoved");

    // We only need to take action if the graphic belongs to the current page
    if (hPage == m_hCurrentPage  && (!(hGraphic->flags & DELETED)))
    {
        // Retrieve the graphic that has been moved
        DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

        // Tell the drawing area of the new graphic
        m_drawingArea.GraphicUpdated(pGraphic, TRUE, FALSE);

        // set paint to draw only objects above this object inclusive
        if (pGraphic->IsGraphicTool() == enumGraphicText)
        {
            m_drawingArea.SetStartPaintGraphic( NULL );
                // this optimization screws up text
                // so short it out if this is text
                // (text draws transparently and background
                //  isn't repainted properly if this is active)
        }
        else
        {
            m_drawingArea.SetStartPaintGraphic( hGraphic );
            // not text so optimize by drawing only this
            // object and everthing above it
        }

        // Free the graphic
        delete pGraphic;
    }
}

//
//
// Function:    OnWBPGraphicUpdateInd
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_UPDATE_IND
//
//
void WbMainWindow::OnWBPGraphicUpdateInd
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicUpdateInd");

	if(hGraphic->flags & DELETED)
	{
		return;
	}

    PWB_GRAPHIC  pOldHeader;
    PWB_GRAPHIC  pOldHeaderCopy;
    DCWbGraphic* pOldGraphic;

    PWB_GRAPHIC  pNewHeader;
    DCWbGraphic* pNewGraphic;

    if (hPage != m_hCurrentPage)
    {
        // nothing visual has changed, confirm and we're done
        g_pwbCore->WBP_GraphicUpdateConfirm(hPage, hGraphic);
        return;
    }


    // Retrieve the original graphic and make a copy
    // Get the page of the update
    pOldHeader = PG_GetData(hPage, hGraphic);
    pOldHeaderCopy = (PWB_GRAPHIC) new BYTE[ pOldHeader->length ];

    if( pOldHeaderCopy == NULL )
    {
        ERROR_OUT( ("Can't copy pOldHeader, can't update drawing") );

        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pOldHeader );
        g_pwbCore->WBP_GraphicUpdateConfirm(hPage, hGraphic);
        return;
    }

    CopyMemory( (PVOID)pOldHeaderCopy, (CONST VOID *)pOldHeader, pOldHeader->length );

    // confirm and get the new one
    g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pOldHeader );
    g_pwbCore->WBP_GraphicUpdateConfirm(hPage, hGraphic);

    pNewHeader = PG_GetData(hPage, hGraphic);

    // This update might affect painting. See if old and new are visually different
    if( HasGraphicChanged( pOldHeaderCopy, (const PWB_GRAPHIC)pNewHeader ) )
    {
        // they're different, invalidate/erase old graphic's bounding rect
        pOldGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic, pOldHeaderCopy );
        m_drawingArea.GraphicUpdated( pOldGraphic, FALSE, TRUE );

        // draw new graphic (don't need to erase)
        pNewGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic, pNewHeader );
        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pNewHeader );
        m_drawingArea.GraphicUpdated( pNewGraphic, TRUE, FALSE );

        // If the graphic is selected, ensure the attributes bar is up to date
        if (m_drawingArea.GraphicSelected())
            {
            DCWbGraphic* pSelectedGraphic = m_drawingArea.GetSelection();
            if ((pSelectedGraphic != NULL) &&
                (pSelectedGraphic->Handle() == hGraphic))
                {
                m_pCurrentTool->SelectGraphic(pNewGraphic);
                OnUpdateAttributes();
                }
            }

        delete pOldGraphic;
        delete pNewGraphic;
    }
    else
    {
        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pNewHeader);
    }

    delete pOldHeaderCopy;
}



//
//
// Function:    OnWBPGraphicReplaceInd
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_REPLACE_IND
//
//
void WbMainWindow::OnWBPGraphicReplaceInd
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicReplaceInd");

	if(hGraphic->flags & DELETED)
	{
		return;
	}

    // Retrieve the graphic that has been replaced
    DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

    if (pGraphic->IsGraphicTool() == enumGraphicFreeHand)
    {
        // Confirm the replace - the graphic reads its new details
        pGraphic->ReplaceConfirm();

        // Only redraw the graphic if it is on the current page
        if (hPage == m_hCurrentPage)
        {
            // Redraw the graphic
            m_drawingArea.GraphicFreehandUpdated(pGraphic);
        }
    }
    else
    {
        // We make two updates to the drawing area - one with the graphic in its
        // current state and one after the update is confirmed. The first one
        // invalidates the rectangle that the graphic now occupies. The second one
        // invalidates the new rectangle. This ensures that the graphic is
        // correctly redrawn.

        // If the graphic is on the current page...
        if (hPage == m_hCurrentPage)
        {
            // Update the drawing area for the old version of the graphic
            m_drawingArea.GraphicUpdated(pGraphic, FALSE);
        }

        // Confirm the replace - the graphic reads its new details
        pGraphic->ReplaceConfirm();

        // If the graphic is on the current page...
        if (hPage == m_hCurrentPage)
        {
            // Update the drawing area for the new version of the graphic
            m_drawingArea.GraphicUpdated(pGraphic, TRUE);
        }
    }

    // If the graphic is selected, ensure the attributes bar is up to date
    if (m_drawingArea.GraphicSelected())
    {
        DCWbGraphic* pSelectedGraphic = m_drawingArea.GetSelection();
        if ((pSelectedGraphic != NULL) &&
            (pSelectedGraphic->Handle() == hGraphic))
        {
            m_pCurrentTool->SelectGraphic(pGraphic);
            OnUpdateAttributes();
        }
    }

    // Free the graphic
    delete pGraphic;
}

//
//
// Function:    OnWBPGraphicDeleteInd
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_DELETE_IND
//
//
void WbMainWindow::OnWBPGraphicDeleteInd
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicDeleteInd");

    // if the graphic was copied into the clipboard and was delayed,
    // then save it in case we are asked to render it later
    if (   (CLP_LastCopiedPage() == hPage)
        && (CLP_LastCopiedGraphic() == hGraphic))
    {
        CLP_SaveDelayedGraphic();
    }

    // Retrieve the graphic that is to be deleted
    DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

    // If the graphic is on the current page...
    if (hPage == m_hCurrentPage)
    {
        // Update the drawing area
        m_drawingArea.GraphicDeleted(pGraphic);
    }

    // Confirm the delete
    g_pwbCore->WBP_GraphicDeleteConfirm(hPage, hGraphic);

    // Free the graphic
    delete pGraphic;
}

//
//
// Function:    UserJoined
//
// Purpose:     Make updates necessary for a new user joining the call
//
//
void WbMainWindow::UserJoined(WbUser* pUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::UserJoined");

    // Get the user's remote pointer
    ASSERT(pUser);
    DCWbGraphicPointer* pPointer = pUser->GetPointer();

    // If the pointer is active and on the current page...
    ASSERT(pPointer);

    if (   (pPointer->IsActive())
        && (pPointer->Page() == m_hCurrentPage))
    {
        // Update the drawing area
        m_drawingArea.PointerUpdated(pPointer);
    }
}

//
//
// Function:  OnWBPUserJoined
//
// Purpose:   Handler for WBP_EVENT_PERSON_JOINED
//
//
void WbMainWindow::OnWBPUserJoined(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUserJoined");

    // Create a user object from the handle
    WbUser* pUser = WB_GetUser(hUser);
    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnWBPUserJoined; can't create user object for 0x%08x", hUser));
    }
    else
    {
        // Make the necessary updates
        UserJoined(pUser);
    }

    // Update the title bar to reflect the number of users.  Do this here,
    // rather than in UserJoined because we go through this function for
    // remote users only, but through UserJoined for the local user too.

	UpdateWindowTitle();
}

//
//
// Function:    OnWBPUserLeftInd
//
// Purpose:     Handler for WBP_EVENT_PERSON_LEFT
//
//
void WbMainWindow::OnWBPUserLeftInd(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUserLeft");

    // Create a user object from the handle
    WbUser* pUser = WB_GetUser(hUser);

    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnWBPUserLeftInd; can't get user object for 0x%08x", hUser));
    }
    else
    {
        // Get the user's remote pointer
        DCWbGraphicPointer* pPointer = pUser->GetPointer();
        ASSERT(pPointer);

        // If the pointer is on the current page...
        if (pPointer->Page() == m_hCurrentPage)
        {
            // Update the drawing area
            m_drawingArea.PointerRemoved(pPointer);
        }
    }

    // Confirm the update.
    g_pwbCore->WBP_PersonLeftConfirm(hUser);

    //
    // Get this dude out of our list
    //
    if (pUser != NULL)
    {
        ASSERT(g_pUsers);

        POSITION position = g_pUsers->GetHeadPosition();

        WbUser * pRemovedUser;

        while (position)
        {
            POSITION savedPosition = position;
            pRemovedUser = (WbUser*)g_pUsers->GetNext(position);
            if (pRemovedUser == pUser)
            {
                g_pUsers->RemoveAt(savedPosition);
                position = NULL;
            }
        }

        delete pUser;
    }

    // Update the title bar to reflect the number of users
	UpdateWindowTitle();
}

//
//
// Function:    OnWBPUserUpdateInd
//
// Purpose:     Handler for WBP_EVENT_PERSON_UPDATE
//
//
void WbMainWindow::OnWBPUserUpdateInd(POM_OBJECT hUser, BOOL bReplace)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUserUpdateInd");
    BOOL     bActiveOld, bActiveNew;
    WB_PAGE_HANDLE  hPointerPageOld, hPointerPageNew;
    POINT    pointOld, pointNew;
    WB_PAGE_HANDLE  hUserPageOld, hUserPageNew;
    BOOL     syncOld, syncNew;
    DCWbGraphicPointer * pPointer = NULL;

    // Get the user object associated with the handle, and the remote pointer
    WbUser* pUser = WB_GetUser(hUser);

    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnWBPUserUpdatedInd; can't get user object for 0x%08x", hUser));
    }
    else
    {
        pPointer = pUser->GetPointer();
        ASSERT(pPointer);

        //
        // Save the interesting bits of the user's state before the change.
        //
        bActiveOld     = pPointer->IsActive();
        hPointerPageOld = pPointer->Page();
        pPointer->GetPosition(&pointOld);
        hUserPageOld    = pUser->Page();
        syncOld        = pUser->IsSynced();
    }

    //
    // Confirm the change
    //
    if (bReplace)
    {
        g_pwbCore->WBP_PersonReplaceConfirm(hUser);
    }
    else
    {
        g_pwbCore->WBP_PersonUpdateConfirm(hUser);
    }

    if (pUser != NULL)
    {
        pUser->Refresh();

        //
        // We do nothing for the local user; since we made the updates locally,
        // we should have already accounted for them.
        //
        if (pUser == m_pLocalUser)
        {
            return;
        }

        //
        // Get the state after the change.
        //
        pPointer       = pUser->GetPointer();
        ASSERT(pPointer);

        bActiveNew     = pPointer->IsActive();
        hPointerPageNew = pPointer->Page();
        pPointer->GetPosition(&pointNew);
        hUserPageNew    = pUser->Page();
        syncNew        = pUser->IsSynced();


        // Check whether anything in the pointer has changed
        if (   (bActiveNew != bActiveOld)
            || (hPointerPageNew    != hPointerPageOld)
            || (!EqualPoint(pointNew, pointOld)))
        {
            // Check that at least one of the pages is the current page
            if (   (hPointerPageNew == m_hCurrentPage)
                || (hPointerPageOld == m_hCurrentPage))
            {
                m_drawingArea.PointerUpdated(pPointer);
            }
        }

        if (syncOld != syncNew)
        {
            // ensure the page button enable/disable state is correct
            UpdatePageButtons();
        }
    }
}

//
//
// Function:    OnWBPSyncPositionUpdated
//
// Purpose:     Handler for WBP_EVENT_SYNC_POSITION_UPDATED
//
//
void WbMainWindow::OnWBPSyncPositionUpdated(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPSyncPositionUpdated");

  //
  // Dont do anythig if we don't have a local user.
  //
  if (m_pLocalUser == NULL)
  {
      ERROR_OUT(("Got a WBP_EVENT_SYNC_POSITION_UPDATED event and pLocaUser is NULL "));
      return;
  }

    // If the local user is synced, change the current page/position
    if (m_pLocalUser->IsSynced())
    {
        GotoSyncPosition();
    }
}

//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbMainWindow::OnSize(UINT nType, int cx, int cy )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSize");


    // Only process this message if the window is not minimized
    if (nType != SIZE_MINIMIZED)
    {
        // Hide the statusbar to avoid drawing problems
	if (m_bStatusBarOn)
	{
            ::ShowWindow(m_hwndSB, SW_HIDE);
        }
	
        // Resize the subpanes of the window
        ResizePanes();

        // Show it again
        if (m_bStatusBarOn)
        {
            ::ShowWindow(m_hwndSB, SW_SHOW);
        }
    }

    // The user's view has changed
    PositionUpdated();

    // If the status has changed, set the option
    if (m_uiWindowSize != nType)
    {
        m_uiWindowSize = nType;

        // Write the new option values to file
        OPT_SetBooleanOption(OPT_MAIN_MAXIMIZED,
                             (m_uiWindowSize == SIZE_MAXIMIZED));
        OPT_SetBooleanOption(OPT_MAIN_MINIMIZED,
                             (m_uiWindowSize == SIZE_MINIMIZED));
    }

    // If this is setting the window to a new normal size,
    // save the new position.
    if (nType == SIZE_RESTORED)
    {
        SaveWindowPosition();
    }
}

//
//
// Function:    SaveWindowPosition
//
// Purpose:     Save the current window position to the options file.
//
//
void WbMainWindow::SaveWindowPosition(void)
{
    RECT    rectWindow;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SaveWindowPosition");

    // Get the new window rectangle
    ::GetWindowRect(m_hwnd, &rectWindow);

    // Write the new option values to file
    OPT_SetWindowRectOption(OPT_MAIN_MAINWINDOWRECT, &rectWindow);
}

//
//
// Function:    OnMove
//
// Purpose:     The window has been moved.
//
//
void WbMainWindow::OnMove(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnMove");

    // If we are not maximized
    if (!::IsZoomed(m_hwnd) && !::IsIconic(m_hwnd))
    {
        // Save the new position of the window
        SaveWindowPosition();
    }
}

//
//
// Function:    ResizePanes
//
// Purpose:     Resize the subpanes of the main window.
//
//
void WbMainWindow::ResizePanes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ResizePanes");

    //
    //
    // The client area is organized as follows:
    //
    //  -------------------------------------
    //  |   |                               |
    //  | T |                               |
    //  | o |   Drawing Area                |
    //  | o |                               |
    //  | l |                               |
    //  | s |                               |
    //  |---|                               |
    //  | W |                               |
    //  | i |                               |
    //  | d |                               |
    //  | t |                               |
    //  | h |                               |
    //  | s |                               |
    //  |-----------------------------------|
    //  | Attributes (colors)   | Pages     |
    //  |-----------------------------------|
    //  |       Status                      |
    //  -------------------------------------
    //
    //

    RECT clientRect;
    RECT rectStatusBar;
    RECT rectToolBar;
    RECT rectWG;
    RECT rectAG;
    RECT rectDraw;
    SIZE size;
    SIZE sizeAG;

    // Get the client rectangle
    ::GetClientRect(m_hwnd, &clientRect);
    rectStatusBar = clientRect;

    // Resize the help bar and progress meter
    if (m_bStatusBarOn)
    {
        rectStatusBar.top = rectStatusBar.bottom - STATUSBAR_HEIGHT;

        ::MoveWindow(m_hwndSB, rectStatusBar.left, rectStatusBar.top,
            rectStatusBar.right - rectStatusBar.left,
            rectStatusBar.bottom - rectStatusBar.top, TRUE);
    }
    else
    {
        // Status bar is off - set it's height to zero
        rectStatusBar.top = rectStatusBar.bottom;
    }

    // Resize the tool and width windows
    m_TB.GetNaturalSize(&size);
    rectToolBar.left  = 0;
    rectToolBar.right = rectToolBar.left + size.cx;
    rectToolBar.top =  0;
    rectToolBar.bottom = rectToolBar.top + size.cy;

    m_WG.GetNaturalSize(&size);
    rectWG.left = rectToolBar.left;
    rectWG.top = rectToolBar.bottom;
    rectWG.bottom = rectWG.top + size.cy;

    if (!m_bToolBarOn)
    {
        // Toolbar is either off or floating - set its width to zero
        rectToolBar.right = rectToolBar.left;
    }
    rectWG.right = rectToolBar.right;

    // Position attribute group
    m_AG.GetNaturalSize(&sizeAG);

    ::MoveWindow(m_AG.m_hwnd, rectToolBar.left, rectStatusBar.top - sizeAG.cy,
        clientRect.right - rectToolBar.left, sizeAG.cy, TRUE);

    // finish fiddling with tools and widths bars
    if (m_bToolBarOn)
    {
        //
        // We make the toolbar, which includes the width bar, extend all
        // down the left side.
        //
        rectToolBar.bottom = rectStatusBar.top - sizeAG.cy;
        rectWG.left += TOOLBAR_MARGINX;
        rectWG.right -= 2*TOOLBAR_MARGINX;

        ::MoveWindow(m_TB.m_hwnd, rectToolBar.left,
            rectToolBar.top, rectToolBar.right - rectToolBar.left,
            rectToolBar.bottom - rectToolBar.top, TRUE);

        ::MoveWindow(m_WG.m_hwnd, rectWG.left, rectWG.top,
            rectWG.right - rectWG.left, rectWG.bottom - rectWG.top, TRUE);

        ::BringWindowToTop(m_WG.m_hwnd);
    }

    // Resize the drawing pane
    rectDraw = clientRect;
    rectDraw.bottom = rectStatusBar.top - sizeAG.cy;
    rectDraw.left   = rectToolBar.right;
    ::MoveWindow(m_drawingArea.m_hwnd, rectDraw.left, rectDraw.top,
        rectDraw.right - rectDraw.left, rectDraw.bottom - rectDraw.top, TRUE);

    // Check to see if Width group is overlapping Attributes group. This can happen if
    // the menu bar has wrapped because the window isn't wide enough (bug 424)
    RECT crWidthWnd;
    RECT crAttrWnd;

    ::GetWindowRect(m_WG.m_hwnd, &crWidthWnd);
    ::GetWindowRect(m_AG.m_hwnd, &crAttrWnd);

    if (crAttrWnd.top < crWidthWnd.bottom)
    {
        // the menu bar has wrapped and our height placements are wrong. Adjust window
        // by difference and try again
        RECT crMainWnd;

        ::GetWindowRect(m_hwnd, &crMainWnd);
        crMainWnd.bottom += (crWidthWnd.bottom - crAttrWnd.top + ::GetSystemMetrics(SM_CYFIXEDFRAME));

        ::MoveWindow(m_hwnd, crMainWnd.left, crMainWnd.top,
            crMainWnd.right - crMainWnd.left, crMainWnd.bottom - crMainWnd.top,
            FALSE);

        // this is going to recurse but the adjustment will happen only once.....
    }
}


//
//
// Function:    WbMainWindow::OnGetMinMaxInfo
//
// Purpose:     Set the minimum and maximum tracking sizes of the window
//
//
void WbMainWindow::OnGetMinMaxInfo(LPMINMAXINFO lpmmi)
{
    if (m_TB.m_hwnd == NULL)
        return; // not ready to do this yet

    SIZE    csFrame;
    SIZE    csSeparator;
    SIZE    csAG;
    SIZE    csToolBar;
    SIZE    csWidthBar;
    SIZE    csStatusBar;
    RECT    rectStatusBar;
    SIZE    csMaxSize;
    SIZE    csScrollBars;

    csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
    csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

    csSeparator.cx = ::GetSystemMetrics(SM_CXEDGE);
    csSeparator.cy = ::GetSystemMetrics(SM_CYEDGE);

    csScrollBars.cx = ::GetSystemMetrics(SM_CXVSCROLL);
    csScrollBars.cy = ::GetSystemMetrics(SM_CYHSCROLL);

    m_AG.GetNaturalSize(&csAG);

    m_TB.GetNaturalSize(&csToolBar);
    m_WG.GetNaturalSize(&csWidthBar);

    csStatusBar.cx = 0;
    if (m_bStatusBarOn)
    {
        csStatusBar.cy = STATUSBAR_HEIGHT;
    }
    else
    {
        csStatusBar.cy = 0;
    }

    // Set the minimum width and height of the window
    lpmmi->ptMinTrackSize.x =
      csFrame.cx + csAG.cx + csFrame.cx;

    lpmmi->ptMinTrackSize.y =
      csFrame.cy +
      GetSystemMetrics( SM_CYCAPTION ) +
      GetSystemMetrics( SM_CYMENU ) +
      csToolBar.cy +
      csWidthBar.cy +
      csSeparator.cy +
      csAG.cy +
      csSeparator.cy +
      csStatusBar.cy +
      csFrame.cy ;

    //
    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //
    RECT rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );
    csMaxSize.cx = rcWorkArea.right - rcWorkArea.left;
    csMaxSize.cy = rcWorkArea.bottom - rcWorkArea.top;

    lpmmi->ptMaxPosition.x  = 0;
    lpmmi->ptMaxPosition.y  = 0;
    lpmmi->ptMaxSize.x      = csMaxSize.cx;
    lpmmi->ptMaxSize.y      = csMaxSize.cy;
    lpmmi->ptMaxTrackSize.x = csMaxSize.cx;
    lpmmi->ptMaxTrackSize.y = csMaxSize.cy;
}


//
//
// Function:    WbMainWindow::CreateContextMenus
//
// Purpose:     Create the pop-up context menus: used within the application
//              drawing area.
//
//
BOOL WbMainWindow::CreateContextMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CreateContextMenus");

    m_hContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(CONTEXTMENU));
    if (!m_hContextMenuBar)
    {
        ERROR_OUT(("Failed to create context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hContextMenu = ::GetSubMenu(m_hContextMenuBar, 0);

    m_hGrobjContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(GROBJMENU));
    if (!m_hGrobjContextMenuBar)
    {
        ERROR_OUT(("Failed to create grobj context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hGrobjContextMenu = ::GetSubMenu(m_hGrobjContextMenuBar, 0);

    // make parts of m_hGrobjContextMenu be owner draw
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_1, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_1, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_2, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_2, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_3, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_3, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_4, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_4, NULL);

    return TRUE;
}




//
//
// Function:    WbMainWindow::InitializeMenus
//
// Purpose:     Initialise the menus: set up owner-drawn menu items and
//              those read from options file.
//
//
void WbMainWindow::InitializeMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::InitializeMenus");

    // Make the width menu ownerdraw
    HMENU hMenu = GetMenuWithItem(::GetMenu(m_hwnd), IDM_WIDTH_1);
    if (hMenu != NULL)
    {
        // Change each entry to be ownerdraw (loop until failure)
        int iIndex;
        UINT uiId;
        int iCount = ::GetMenuItemCount(hMenu);

        for (iIndex = 0; iIndex < iCount; iIndex++)
        {
            uiId = ::GetMenuItemID(hMenu, iIndex);
            ::ModifyMenu(hMenu, iIndex,
                        MF_BYPOSITION
                      | MF_ENABLED
                      | MF_OWNERDRAW,
                      uiId,
                      NULL);
        }
    }
}




//
//
// Function:    WbMainWindow::OnMeasureItem
//
// Purpose:     Return the size of an item in the widths menu
//
//
void WbMainWindow::OnMeasureItem
(
    int                 nIDCtl,
    LPMEASUREITEMSTRUCT measureStruct
)
{
    // Check that this is for a color menu item
    if (    (measureStruct->itemID >= IDM_WIDTHS_START)
         && (measureStruct->itemID < IDM_WIDTHS_END))
    {
        measureStruct->itemWidth  = ::GetSystemMetrics(SM_CXMENUCHECK) +
            (2 * CHECKMARK_BORDER_X) + COLOR_MENU_WIDTH;
        measureStruct->itemHeight = ::GetSystemMetrics(SM_CYMENUCHECK) +
            (2 * CHECKMARK_BORDER_Y);
    }
}

//
//
// Function:    WbMainWindow::OnDrawItem
//
// Purpose:     Draw an item in the color menu
//
//
void WbMainWindow::OnDrawItem
(
    int     nIDCtl,
    LPDRAWITEMSTRUCT drawStruct
)
{
    COLORREF crMenuBackground;
    COLORREF crMenuText;
    HPEN     hOldPen;
    HBRUSH      hOldBrush;
    COLORREF crOldBkgnd;
    COLORREF crOldText;
    int         nOldBkMode;
    HBITMAP hbmp = NULL;
    BITMAP  bitmap;
    UINT    uiCheckWidth;
    UINT    uiCheckHeight;
    RECT    rect;
    RECT    rectCheck;
    RECT    rectLine;
    HDC     hMemDC;
    UINT    uiWidthIndex;
    UINT    uiWidth;
    HPEN    hPenMenu;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDrawItem");

    // Check that this is a width menu item
    if( (drawStruct->itemID < IDM_WIDTHS_START) ||
        (drawStruct->itemID >= IDM_WIDTHS_END) )
    {
        return;
    }

    // get menu item colors
    if( (drawStruct->itemState & ODS_SELECTED) ||
        ((drawStruct->itemState & (ODS_SELECTED |ODS_CHECKED)) ==
            (ODS_SELECTED |ODS_CHECKED))
        )
    {
        crMenuBackground = COLOR_HIGHLIGHT;
        crMenuText = COLOR_HIGHLIGHTTEXT;
    }
    else if( drawStruct->itemState & ODS_GRAYED)
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_GRAYTEXT;
    }
    else
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_MENUTEXT;
    }

    hPenMenu = ::CreatePen(PS_SOLID, 0, ::GetSysColor(crMenuBackground));
    if (!hPenMenu)
    {
        TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    rect = drawStruct->rcItem;

    // Fill the whole box with current menu background color
    hOldPen     = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush   = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuBackground));

    ::Rectangle(drawStruct->hDC, rect.left, rect.top, rect.right, rect.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    if( (hbmp = (HBITMAP)LoadImage( NULL, MAKEINTRESOURCE( OBM_CHECK ), IMAGE_BITMAP,
                0,0, 0 ))
        == NULL )
    {
        TRACE_MSG(("Failed to create check image"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    // Get the width and height of the bitmap (allowing some border)
    ::GetObject(hbmp, sizeof(BITMAP), &bitmap);
    uiCheckWidth  = bitmap.bmWidth  + (2 * CHECKMARK_BORDER_X);
    uiCheckHeight = bitmap.bmHeight;

    // Draw in a checkmark (if needed)
    if (drawStruct->itemState & ODS_CHECKED)
    {
        hMemDC = ::CreateCompatibleDC(drawStruct->hDC);
        if (!hMemDC)
        {
            ERROR_OUT(("Failed to create memDC"));
            ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
            goto bail_out;
        }

        crOldBkgnd = ::SetBkColor(drawStruct->hDC, GetSysColor( crMenuBackground ) );
        crOldText = ::SetTextColor(drawStruct->hDC, GetSysColor( crMenuText ) );
        nOldBkMode = ::SetBkMode(drawStruct->hDC, OPAQUE );

        HBITMAP hOld = SelectBitmap(hMemDC, hbmp);

        if (hOld != NULL)
        {
            rectCheck = rect;
            rectCheck.top += ((rectCheck.bottom - rectCheck.top)/2 - uiCheckHeight/2);
            rectCheck.right  = rectCheck.left + uiCheckWidth;
            rectCheck.bottom = rectCheck.top + uiCheckHeight;

            ::BitBlt(drawStruct->hDC, rectCheck.left,
                        rectCheck.top,
                        rectCheck.right - rectCheck.left,
                        rectCheck.bottom - rectCheck.top,
                        hMemDC,
                        0,
                        0,
                        SRCCOPY);

            SelectBitmap(hMemDC, hOld);
        }

        ::SetBkMode(drawStruct->hDC, nOldBkMode);
        ::SetTextColor(drawStruct->hDC, crOldText);
        ::SetBkColor(drawStruct->hDC, crOldBkgnd);

        ::DeleteDC(hMemDC);
    }

    DeleteBitmap(hbmp);

    // Allow room for the checkmark to the left of the color
    rect.left += uiCheckWidth;

    uiWidthIndex = drawStruct->itemID - IDM_WIDTHS_START;
    uiWidth = g_PenWidths[uiWidthIndex];

    // If pens are very wide they can be larger than the allowed rectangle.
    // So we reduce the clipping rectangle here. We save the DC so that we
    // can restore it - getting the clip region back.
    if (::SaveDC(drawStruct->hDC) == 0)
    {
        ERROR_OUT(("Failed to save DC"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    if (::IntersectClipRect(drawStruct->hDC, rect.left, rect.top,
        rect.right, rect.bottom) == ERROR)
    {
        ERROR_OUT(("Failed to set clip rect"));

        ::RestoreDC(drawStruct->hDC, -1);
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    hOldPen   = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuText));

    rectLine.left = rect.left;
    rectLine.top    = rect.top + ((rect.bottom - rect.top) / 2) - uiWidth/2;
    rectLine.right= rect.right - ((rect.right - rect.left) / 6);
    rectLine.bottom = rectLine.top + uiWidth + 2;

    ::Rectangle(drawStruct->hDC, rectLine.left, rectLine.top,
        rectLine.right, rectLine.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    ::RestoreDC(drawStruct->hDC, -1);

bail_out:
    if (hPenMenu != NULL)
    {
        ::DeletePen(hPenMenu);
    }
}



//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbMainWindow::OnSetFocus(void)
{
    // We pass the focus on to the main drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    UpdateStatus
//
// Purpose:     Set the text in the status bar
//
//
void WbMainWindow::UpdateStatus()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::UpdateStatus");

    //
    // Update the current and last page numbers
    //
    m_AG.SetCurrentPageNumber(g_pwbCore->WBP_PageNumberFromHandle(m_hCurrentPage));
    m_AG.SetLastPageNumber(g_pwbCore->WBP_ContentsCountPages());

    //
    // Update the user information with the page.
    //
    if (m_pLocalUser != NULL)
    {
        m_pLocalUser->SetPage(m_hCurrentPage);
    }
}



//
//
// Function:    SetMenuState
//
// Purpose:     Sets menu contents to their correct enabled/disabled state
//
//
void WbMainWindow::SetMenuStates(HMENU hInitMenu)
{
    BOOL  bLocked;
    BOOL  bPageOrderLocked;
    BOOL  bPresentationMode;
    UINT  uiEnable;
    UINT  uiCountPages;
    BOOL  bIdle;
    BOOL  bSelected;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetMenuStates");

    //
    // Check menu exists
    //
    if (hInitMenu == NULL)
    {
        WARNING_OUT(("Menu doesn't exist"));
        return;
    }

    HMENU hMainMenu = ::GetMenu(m_hwnd);

    // Get the window's main menu and check that the menu
    // now being popped up is one on the top-level. (We do not
    // seem to be able to associate the index number passed with
    // sub-menus easily.)
    if ((hInitMenu != m_hContextMenu) && (hInitMenu != m_hGrobjContextMenu))
    {
        BOOL bTopLevel = FALSE;

        int nCount = ::GetMenuItemCount(hMainMenu);

        for (int nNext = 0; nNext < nCount; nNext++)
        {
            HMENU hNextMenu = ::GetSubMenu(hMainMenu, nNext);
            if (hNextMenu != NULL)
            {
                if (hNextMenu == hInitMenu)
                {
                    bTopLevel = TRUE;
                    break;
                }
            }
        }

        // not a top level, so leave the function now
        if (!bTopLevel)
        {
            TRACE_DEBUG(("Not top-level menu"));
            return;
        }
    }

    // Get the lock and selection states:
    // If we are joining a call, we cannot assume that the contents
    // and user/client details have been created yet, so just set the
    // locked state to true.
    bIdle     = IsIdle();
    bSelected = m_drawingArea.GraphicSelected();
    TRACE_DEBUG(("m_uiState %d", m_uiState));
    if ((m_uiState == STARTING) || (m_uiState == JOINING))
    {
        TRACE_DEBUG(("Not initilalised yet"));
        bLocked           = TRUE;
        bPageOrderLocked  = TRUE;
        bPresentationMode = TRUE;
        uiCountPages      = 1;
    }
    else
    {
        //
        // Note that bLocked and bPageOrderLocked are always true when
        // we're not in idle state.
        //
        uiCountPages      = g_pwbCore->WBP_ContentsCountPages();
        bLocked           = (WB_Locked() || !bIdle);
        bPageOrderLocked  = (WB_Locked() || !bIdle);
        bPresentationMode = (((m_uiState == IN_CALL) &&
                              (WB_PresentationMode()))
                            || (!bIdle));
    }

    //
    // Functions which are disabled when contents is locked
    //
    uiEnable = MF_BYCOMMAND | (bLocked ? MF_GRAYED : MF_ENABLED);

    ::EnableMenuItem(hInitMenu, IDM_OPEN,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SAVE,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SAVE_AS, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PRINT,   uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_AREA, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_WINDOW, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SELECTALL, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_SELECT,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PEN, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_HIGHLIGHT, uiEnable);

    // Don't allow editing in zoom mode
    if( m_drawingArea.Zoomed() )
        ::EnableMenuItem(hInitMenu, IDM_TEXT, MF_GRAYED);
    else
        ::EnableMenuItem(hInitMenu, IDM_TEXT, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_CLEAR_PAGE, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_ERASER, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_LINE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ELLIPSE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_ELLIPSE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ZOOM, uiEnable);


    // So toolbar will follow menu (MFC-auto-update is broken for this)
    EnableToolbar( !bLocked );


    //
    // File/New is disabled if page order is locked, or not in a call,
    // or a new is already in progress.
    //
    ::EnableMenuItem(hInitMenu, IDM_NEW, MF_BYCOMMAND |
      (bPageOrderLocked ? MF_GRAYED : MF_ENABLED));

    //
    // Paste enabled only if not locked, and there's something in the
    // clipboard
    //
    uiEnable = MF_BYCOMMAND | MF_ENABLED;
    if (   (CLP_AcceptableClipboardFormat() == NULL)
        || (bLocked))
    {
        // No acceptable format available, or the contents
        // are locked by another user - gray the Paste command.
        uiEnable = MF_BYCOMMAND | MF_GRAYED;
    }
    ::EnableMenuItem(hInitMenu, IDM_PASTE, uiEnable);

    //
    // Functions which require a graphic to be selected
    //
    uiEnable = MF_BYCOMMAND | MF_ENABLED;
    if( !m_drawingArea.TextEditActive() )
    {
        if (!bSelected || bLocked)
        {
            // No acceptable format available - gray the menu item
            uiEnable = MF_BYCOMMAND | MF_GRAYED;
        }
    }

    ::EnableMenuItem(hInitMenu, IDM_CUT, uiEnable);

    // don't do textedit delete for now
    if( m_drawingArea.TextEditActive() )
        ::EnableMenuItem(hInitMenu, IDM_DELETE, MF_BYCOMMAND | MF_GRAYED);
    else
        ::EnableMenuItem(hInitMenu, IDM_DELETE, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_BRING_TO_TOP, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SEND_TO_BACK, uiEnable);

    //
    // Can copy even if contents are locked
    //
    //COMMENT BY RAND - To fix 556 I changed !bIdle to bIdle like the current
    //                    16bit code does.
    ::EnableMenuItem(hInitMenu, IDM_COPY, MF_BYCOMMAND |
      (m_drawingArea.TextEditActive()||(bSelected && bIdle)
        ? MF_ENABLED : MF_GRAYED));    //CHANGED BY RAND for 556

    //
    // Object to undelete?
    //
    ::EnableMenuItem(hInitMenu, IDM_UNDELETE, MF_BYCOMMAND |
      ((m_LastDeletedGraphic.GotTrash() &&
        (m_LastDeletedGraphic.Page() == m_hCurrentPage) &&
        (!bLocked)) ? MF_ENABLED : MF_GRAYED));

    //
    // Page functions depend on number of pages
    //
    ::EnableMenuItem(hInitMenu, IDM_DELETE_PAGE, MF_BYCOMMAND |
      ((bPageOrderLocked ||
       (uiCountPages == 1)||
       (!m_bUnlockStateSettled))
        ? MF_GRAYED : MF_ENABLED));

    uiEnable = MF_BYCOMMAND | MF_ENABLED;
    if ((bPageOrderLocked) ||
       (uiCountPages == WB_MAX_PAGES)||
       (!m_bUnlockStateSettled))
    {
        uiEnable = MF_BYCOMMAND | MF_GRAYED;
    }
    ::EnableMenuItem(hInitMenu, IDM_PAGE_INSERT_BEFORE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PAGE_INSERT_AFTER, uiEnable);

    //
    // Can't bring up page sorter if locked
    //
    ::EnableMenuItem(hInitMenu, IDM_PAGE_SORTER, MF_BYCOMMAND |
      (bPresentationMode ? MF_GRAYED : MF_ENABLED));

    // Enable page controls
    m_AG.EnablePageCtrls(!bPresentationMode);

    //
    // Lock enabled only if not already locked
    //
    ::EnableMenuItem(hInitMenu, IDM_LOCK, MF_BYCOMMAND |
      (bPageOrderLocked ? MF_GRAYED : MF_ENABLED));

    //
    // Enable sync if not in "presentation" mode
    //
    ::EnableMenuItem(hInitMenu, IDM_SYNC, MF_BYCOMMAND |
      (((!bPresentationMode) && bIdle) ? MF_ENABLED : MF_GRAYED));

    //
    // Gray font/color/widths if inappropriate for current tool.
    //
    ::EnableMenuItem(hInitMenu, IDM_FONT, MF_BYCOMMAND |
        (!bLocked && m_pCurrentTool->HasFont() ? MF_ENABLED : MF_GRAYED));

    ::EnableMenuItem(hInitMenu, IDM_EDITCOLOR, MF_BYCOMMAND |
        (!bLocked && m_pCurrentTool->HasColor() ? MF_ENABLED : MF_GRAYED));


    // enable width menu (bug 433)
    HMENU hOptionsMenu = ::GetSubMenu(hMainMenu, MENUPOS_OPTIONS);
    uiEnable = (!bLocked && m_pCurrentTool->HasWidth())?MF_ENABLED:MF_GRAYED;

    if (hOptionsMenu == hInitMenu )
        ::EnableMenuItem(hOptionsMenu, OPTIONSPOS_WIDTH, MF_BYPOSITION | uiEnable );

    UINT i;
    UINT uIdmCurWidth = 0;
    if( uiEnable == MF_ENABLED )
        uIdmCurWidth = m_pCurrentTool->GetWidthIndex() + IDM_WIDTH_1;

    // set width state(bug 426)
    for( i=IDM_WIDTH_1; i<=IDM_WIDTH_4; i++ )
    {
        ::EnableMenuItem(hInitMenu,  i, uiEnable );

        if( uiEnable == MF_ENABLED )
        {
            if( uIdmCurWidth == i )
                ::CheckMenuItem(hInitMenu, i, MF_CHECKED );
            else
                ::CheckMenuItem(hInitMenu, i, MF_UNCHECKED );
        }
    }
}


//
//
// Function:    OnInitMenuPopup
//
// Purpose:     Process a WM_INITMENUPOPUP event
//
//
void WbMainWindow::OnInitMenuPopup
(
    HMENU   hMenu,
    UINT    uiIndex,
    BOOL    bSystemMenu
)
{

    // 1/2 of fix for strange MFC4.2 build bug that clogs up DCL's message pipe.
    // The other 1/2 and a better comment are in LoadFile().
    if( m_bIsWin95 )
    {
        if( GetSubState() == SUBSTATE_LOADING )
        {
            ::SetFocus(m_drawingArea.m_hwnd);
            return;
        }
   }


    // Ignore the event if it relates to the system menu
    if (!bSystemMenu)
    {
        if (hMenu)
        {
            SetMenuStates(hMenu);
            m_hInitMenu = hMenu;
        }
        else
        {
            m_hInitMenu = NULL;
        }

        // Save the last menu we handled, so that we can alter its state
        // if necessary whilst it is still visible
    }
}


//
//
// Function : OnMenuSelect
//
// Purpose  : Update the text in the help bar
//
//
void WbMainWindow::OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu)
{
    UINT   firstMenuId;
    UINT   statusId;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnMenuSelect");

    //
    // Work out the help ID for the menu item.  We have to store this now
    // because when the user presses F1 from a menu item, we can't tell
    // which item it was.
    //
    if (uiFlags == (UINT)-1)
    {
        //
        // The menu has been dismissed
        //
        m_hInitMenu = NULL;
        statusId   = IDS_DEFAULT;

        if( hSysMenu == 0 )
            {
            // Menu was dismissed, check cursor loc.
            DCWbGraphic *pGraphic;

            POINT surfacePos;
            ::GetCursorPos( &surfacePos );
            ::ScreenToClient(m_drawingArea.m_hwnd, &surfacePos);
            m_drawingArea.ClientToSurface(&surfacePos );

            if( (pGraphic = m_drawingArea.GetHitObject( surfacePos )) == NULL )
                {
                // we clicked dead air, don't lose current selection (bug 426)
                m_drawingArea.SetLClickIgnore( TRUE );
                }
            else
                delete pGraphic; // plug leak
            }
    }
    else if ((uiFlags & MF_POPUP) && (uiFlags & MF_SYSMENU))
    {
        //
        // System menu selected
        //
        statusId   = IDS_MENU_SYSTEM;
    }
    else if (uiFlags & MF_POPUP)
    {
        // get popup menu handle and first item (bug NM4db:463)
        HMENU hPopup = ::GetSubMenu( hSysMenu, uiItemID );
        firstMenuId = ::GetMenuItemID( hPopup, 0 );

        // figure out which popup it is so we can display the right help text
        switch (firstMenuId)
        {
            case IDM_NEW:
                statusId   = IDS_MENU_FILE;
                break;

            case IDM_DELETE:
                statusId   = IDS_MENU_EDIT;
                break;

            case IDM_TOOL_BAR_TOGGLE:
                statusId   = IDS_MENU_VIEW;
                break;

            case IDM_EDITCOLOR:
                // The first item in the options menu is the color popup
                // menu - popup menus have Id -1
                statusId   = IDS_MENU_OPTIONS;
                break;

            case IDM_TOOLS_START:
                statusId   = IDS_MENU_TOOLS;
                break;

            case IDM_HELP:
                statusId = IDS_MENU_HELP;
                break;

            case IDM_WIDTH_1: // (added for bug NM4db:463)
                statusId   = IDS_MENU_WIDTH;
                break;

            default:
                statusId   = IDS_DEFAULT;
                break;
        }
    }
    else
    {
        //
        // A normal menu item has been selected
        //
        statusId   = uiItemID;
    }

    // Set the new help text
    TCHAR   szStatus[256];

    if (::LoadString(g_hInstance, statusId, szStatus, 256))
    {
        ::SetWindowText(m_hwndSB, szStatus);
    }
}


//
//
// Function:    OnParentNotfiy
//
// Purpose:     Process a message coming from a child window
//
//
void WbMainWindow::OnParentNotify(UINT uiMessage)
{
    switch (uiMessage)
    {
        // Scroll message from the drawing area. These are sent when the user
        // scrolls the area using the scroll bars. We queue an update of the
        // current sync position.
        case WM_HSCROLL:
        case WM_VSCROLL:
            // The user's view has changed
            PositionUpdated();
            break;
    }
}


//
//
// Function:    QuerySaveRequired
//
// Purpose:     Check whether the drawing pane contents are to be saved
//              before a destructive function is performed.
//
//
int WbMainWindow::QuerySaveRequired(BOOL bCancelBtn)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::QuerySaveRequired");

    // Default the response to "no save required"
    int  iResult = IDNO;

    //
    // If we are already displaying a "Save As" dialog, dismiss it.
    //
    if (m_hwndQuerySaveDlg != NULL)
    {
        ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
            MAKELONG(IDCANCEL, BN_CLICKED), 0);
        ASSERT(m_hwndQuerySaveDlg == NULL);
    }

    // If any of the pages has changed - ask the user if they want to
    // save the contents of the Whiteboard.
    if (g_pwbCore->WBP_ContentsChanged())
    {
        ::SetForegroundWindow(m_hwnd); //bring us to the top first

        // SetForegroundWindow() does not work properly in Memphis when its called during a
        // SendMessage handler, specifically, when conf calls me to shutdown. The window activation
        // state is messed up or something and my window does not pop to the top. So I have to
        // force my window to the top using SetWindowPos. But even after that the titlebar is not
        // highlighted properly. I tried combinations of SetActiveWindow, SetFocus, etc but to no
        // avail. But, at least the dialog is visible so you can clear it thus fixing the
        // bug (NM4db:2103). SetForegroundWindow() works ok for Win95 and NT here without
        // having to use SetWindowPos (it doesn't hurt anyting to do it anyway so I didn't
        // do a platform check).
        ::SetWindowPos(m_hwnd, HWND_TOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );       // force to top
        ::SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );  // let go of topmost

        //
        // Display a dialog box with the relevant question
        //      LOWORD of user data is "cancel command is allowed"
        //      HIWORD of user data is "disable cancel button"
        //
        iResult = (int)DialogBoxParam(g_hInstance,
            bCancelBtn ? MAKEINTRESOURCE(QUERYSAVEDIALOGCANCEL)
                       : MAKEINTRESOURCE(QUERYSAVEDIALOG),
            m_hwnd,
            QuerySaveDlgProc,
            MAKELONG(bCancelBtn, FALSE));
    }

    return iResult;
}



//
// QuerySaveDlgProc()
// Handler for query save dialogs.  We save some flags in GWL_USER
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            //
            // Save away our HWND so this dialog can be cancelled if necessary
            //
            g_pMain->m_hwndQuerySaveDlg = hwnd;

            // Remember the flags we passed
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            // Should the cancel button be disabled?
            if (HIWORD(lParam))
                ::EnableWindow(::GetDlgItem(hwnd, IDCANCEL), FALSE);

            // Bring us to the front
            ::SetForegroundWindow(hwnd);

            fHandled = TRUE;
            break;

        case WM_CLOSE:
            // Even if the cancel button is disabled, kill the dialog
            ::PostMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDCANCEL:
                    //
                    // If a dialog doesn't have a cancel button or it's
                    // disabled and the user pressed the close btn, we can
                    // get here.
                    //
                    if (!LOWORD(::GetWindowLongPtr(hwnd, GWLP_USERDATA)))
                        wParam = MAKELONG(IDNO, HIWORD(wParam));
                    // FALL THRU

                case IDYES:
                case IDNO:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        g_pMain->m_hwndQuerySaveDlg = NULL;

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                        break;
                    }
                    break;
            }
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


//
//
// Function:    OnNew
//
// Purpose:     Clear the workspace and associated filenames
//
//
void WbMainWindow::OnNew(void)
{
    int iDoNew;

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return;


    // check state before proceeding - if we're already doing a new, then abort
    if (   (m_uiState != IN_CALL)
        || (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS))
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        goto OnNewCleanup;
    }
    // if we're currently loading, then cancel the load and proceed (don't
    // prompt to save).
    else if (m_uiSubState == SUBSTATE_LOADING)
    {
        // cancel load, not releasing the page order lock, because
        // we need it immediately afterwards
        CancelLoad(FALSE);
        iDoNew = IDNO;
    }
    // otherwise prompt to save if necessary
    else
    {
        // Get confirmation for the new
        iDoNew = QuerySaveRequired(TRUE);
    }

    if (iDoNew == IDYES)
    {
        // Save the changes
        iDoNew = OnSave(FALSE);
    }

  // If the user did not cancel the operation, clear the drawing area
  if (iDoNew != IDCANCEL)
  {
      // Go to the first page, as this won't be deleted - stops flashing
      // with locking contents for each page delete
      OnFirstPage();
      GotoPosition(0, 0);

      // lock the drawing area
      LockDrawingArea();

      // Save the current lock status
      SaveLock();

      // Get the Page Order Lock (with an invisible dialog)
      BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
      if (!bGotLock)
      {
        RestoreLock();
      }
      else
      {
            UINT    uiReturn;

            // Remove all the pages
            uiReturn = g_pwbCore->WBP_ContentsDelete();
            if (uiReturn != 0)
            {
                DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
                return;
            }

        // if there is only one page, the new is implemented just as a page-
        // clear, so we don't need to go into NEW_IN_PROGRESS substate.
        if (g_pwbCore->WBP_ContentsCountPages() > 1)
        {
          // set substate to show we're doing a new
          SetSubstate(SUBSTATE_NEW_IN_PROGRESS);
        }
        else
        {
          // Restore the lock status
          RestoreLock();
        }

        // Clear the associated file name
        ZeroMemory(m_strFileName, sizeof(m_strFileName));

        // Update the window title with no file name
		UpdateWindowTitle();
      }
  }

OnNewCleanup:

  // unlock the drawing area if the new is not asynchronous
  if (   (m_uiSubState != SUBSTATE_NEW_IN_PROGRESS)
      && (!WB_ContentsLocked()))
  {
    UnlockDrawingArea();
  }

  return;
}

//
//
// Function:    OnNextPage
//
// Purpose:     Move to the next worksheet in the pages list
//
//
void WbMainWindow::OnNextPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the next page
        GotoPage(PG_GetNextPage(m_hCurrentPage));
    }
}

//
//
// Function:    OnPrevPage
//
// Purpose:     Move to the previous worksheet in the pages list
//
//
void WbMainWindow::OnPrevPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the previous page
        GotoPage(PG_GetPreviousPage(m_hCurrentPage));
    }
}

//
//
// Function:    OnFirstPage
//
// Purpose:     Move to the first worksheet in the pages list
//
//
void WbMainWindow::OnFirstPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the first page
        WB_PAGE_HANDLE   hPage;

        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &hPage);
        GotoPage(hPage);
    }
}

//
//
// Function:    OnLastPage
//
// Purpose:     Move to the last worksheet in the pages list
//
//
void WbMainWindow::OnLastPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the last page
        WB_PAGE_HANDLE hPage;

        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_LAST, &hPage);
        GotoPage(hPage);
    }
}

//
//
// Function:    OnGotoPage
//
// Purpose:     Move to the specified page (if it exists)
//
//
void WbMainWindow::OnGotoPage(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoPage");

    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Get the requested page number from the pages group
        UINT uiPageNumber = m_AG.GetCurrentPageNumber();

        // Goto the page
        GotoPageNumber(uiPageNumber);
    }
}

//
//
// Function:    GotoPage
//
// Purpose:     Move to the specified page
//
//
void WbMainWindow::GotoPage(WB_PAGE_HANDLE hPageNew)
{
    BOOL inEditField;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPage");

    inEditField = m_AG.IsChildEditField(::GetFocus());

    // If we are changing page
    if (hPageNew != m_hCurrentPage)
    {
        m_drawingArea.CancelDrawingMode();

        // Attach the new page to the drawing area
        m_hCurrentPage = hPageNew;
        m_drawingArea.Attach(m_hCurrentPage);

        // Update the local user information with the new page
        if (m_pLocalUser != NULL)
            m_pLocalUser->SetPage(m_hCurrentPage);

        // Show that we need to update the sync position
        m_bSyncUpdateNeeded = TRUE;

	    PAGE_POSITION *mapob;
		POSITION position = m_pageToPosition.GetHeadPosition();
		BOOL bFound = FALSE;
		while (position && !bFound)
		{
			mapob = (PAGE_POSITION *)m_pageToPosition.GetNext(position);
			if ( mapob->hPage == hPageNew)
			{
				bFound = TRUE;
			}
		}

        if (!bFound)
        {
            // page not in map, so go to the top-left
            //CHANGED BY RAND - to fix memory leak
            GotoPosition( 0, 0);
        }
        else
            GotoPosition(mapob->position.x, mapob->position.y);
    }

    // Update the status display
    UpdateStatus();

    // set the focus back to the drawing area
    if (!inEditField)
    {
        ::SetFocus(m_drawingArea.m_hwnd);
    }
}

//
//
// Function:    GotoPageNumber
//
// Purpose:     Move to the specified page
//
//
void WbMainWindow::GotoPageNumber(UINT uiPageNumber)
{
    GotoPage(PG_GetPageNumber(uiPageNumber));
}


//
//
// Function:    GotoPosition
//
// Purpose:     Move to the specified position within the page
//
//
void WbMainWindow::GotoPosition(int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPosition");

    // Move the drawing area to the new position
    m_drawingArea.GotoPosition(x, y);

    // The user's view has changed
    PositionUpdated();
}

//
//
// Function:    GotoSyncPosition
//
// Purpose:     Move to the the current sync position
//
//
void WbMainWindow::GotoSyncPosition(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoSyncPosition");

    //
    // Get the local user to determine the new position.
    //
    if (!m_pLocalUser)
    {
        ERROR_OUT(("Skipping GotoSyncPosition; no local user object"));
        return;
    }

    m_pLocalUser->GetSyncPosition();

    //
    // If the page is different to where we are currently, get the number
    // of the page and select the current page
    //
    if (m_pLocalUser->Page() != m_hCurrentPage)
    {
        GotoPageNumber(g_pwbCore->WBP_PageNumberFromHandle(m_pLocalUser->Page()));
    }

    // Get the requested position from the user
    RECT rectVisibleUser;
    m_pLocalUser->GetVisibleRect(&rectVisibleUser);

    // Scroll to the required position
    GotoPosition(rectVisibleUser.left, rectVisibleUser.top);

    // Make sure we are zoomed / not zoomed as appropriate
    if ((m_pLocalUser->GetZoom()) != m_drawingArea.Zoomed())
    {
        OnZoom();
    }

    //
    // Reset the sync position update flag that will have been turned on by
    // the calls above.  We do not want to change the current sync position
    // when we are merely changing our position to match that set by
    // another user in the call.
    //
    m_bSyncUpdateNeeded = FALSE;

    // Inform the other users that we have changed position
    m_pLocalUser->Update();
}

//
//
// Function:    OnGotoUserPosition
//
// Purpose:     Move to the the current position of the specified user
//
//
void WbMainWindow::OnGotoUserPosition(LPARAM lParam)
{
    UINT            uiPageNumber = 1;
    WB_PAGE_HANDLE  hPage;
    WbUser  *     pUser;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoUserPosition");

    //
    // If the drawing area is busy, ignore this command.  This is unlikely
    // since this command is generated by selecting a menu entry on a user
    // icon.  The user should not therefore be drawing on the page by the
    // time we get the message.
    //
    if (m_drawingArea.IsBusy())
    {
        TRACE_DEBUG(("drawing area is busy just now.."));
        return;
    }

    //
    // Get a user object (throws an exception if the handle specified is no
    // longer valid).
    //
    pUser = WB_GetUser((POM_OBJECT) lParam);
    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnGotoUserPosition; can't get user object for 0x%08x", lParam));
        return;
    }

    //
    // Get the requested page from the user.
    //
    hPage = pUser->Page();

    //
    // Quit if the requested page is not valid locally.
    //
    if (hPage == WB_PAGE_HANDLE_NULL)
    {
        TRACE_DEBUG(("Page is not valid locally"));
        return;
    }

    //
    // Don't go to user's position if it's on another page and we're in
    // presentation mode (this shouldn't normally happen, since we should
    // all be on the same page, but there is a window at the start-up of
    // presentation mode.
    //
    if ( (hPage == m_hCurrentPage) ||
         (!WB_PresentationMode()) )
    {
        //
        // If the page is different to where we are currently, get the
        // number of the page and select the current page.
        //
        if (hPage != m_hCurrentPage)
        {
            uiPageNumber = g_pwbCore->WBP_PageNumberFromHandle(hPage);
            GotoPageNumber(uiPageNumber);
        }

        //
        // Get the requested position from the user and scroll to it.
        //
        RECT rectVisibleUser;
        pUser->GetVisibleRect(&rectVisibleUser);
        GotoPosition(rectVisibleUser.left, rectVisibleUser.top);

        //
        // Zoom/unzoom if the sync zoom state is different to our current
        // zoom state.
        //
        if ( (m_pLocalUser->GetZoom()) != (m_drawingArea.Zoomed()) )
        {
            TRACE_DEBUG(("Change zoom state"));
            OnZoom();
        }
    }
}

//
//
// Function:    OnGotoUserPointer
//
// Purpose:     Move to the pointer position of the specified user
//
//
void WbMainWindow::OnGotoUserPointer(LPARAM lParam)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoUserPointer");

    // If the drawing area is busy, ignore this command.
    // This is unlikely since this command is generated by selecting
    // a menu entry on a user icon. The user should not therefore be
    // drawing on the page by the time we get the message.
    if (!m_drawingArea.IsBusy())
    {
        // Get a user object (throws an exception if the
        // handle specified is no longer valid).
        WbUser* pUser = WB_GetUser((POM_OBJECT) lParam);

        if (!pUser)
        {
            WARNING_OUT(("Can't handle OnGotoUserPointer; can't get user object for 0x%08x", lParam));
            return;
        }

        DCWbGraphicPointer* pPointer = pUser->GetPointer();
        ASSERT(pPointer != NULL);

        // Continue only if the user is using the pointer
        if (pPointer->IsActive())
        {
            // Get the requested page from the user
            WB_PAGE_HANDLE hPage = pPointer->Page();

            // Check that the requested page is valid locally
            if (hPage != WB_PAGE_HANDLE_NULL)
            {
                // If the pointer is on a different page, change to the
                // correct page.
                if (hPage != m_hCurrentPage)
                {
                    GotoPageNumber(g_pwbCore->WBP_PageNumberFromHandle(hPage));
                }

                // Move within the page if the pointer is not wholly visible
                // in the drawing area window.
                RECT rectPointer;
                RECT rcVis;
                RECT rcT;

                pPointer->GetBoundsRect(&rectPointer);
                m_drawingArea.GetVisibleRect(&rcVis);

                ::IntersectRect(&rcT, &rcVis, &rectPointer);
                if (!::EqualRect(&rcT, &rectPointer))
                {
                    // Adjust the position so that the pointer is shown
                    // in the centre of the window.
                    POINT   position;
                    SIZE    size;

                    position.x = rectPointer.left;
                    position.y = rectPointer.top;

                    size.cx = (rcVis.right - rcVis.left) - (rectPointer.right - rectPointer.left);
                    size.cy = (rcVis.bottom - rcVis.top) - (rectPointer.bottom - rectPointer.top);

                    position.x += -size.cx / 2;
                    position.y += -size.cy / 2;

                    // Scroll to the required position
                    GotoPosition(position.x, position.y);
                }
            }
        }
    }
}


//
//
// Function:    LoadFile
//
// Purpose:     Load a metafile into the application. Errors are reported
//              to the caller by the return code.
//
//
void WbMainWindow::LoadFile
(
    LPCSTR szLoadFileName
)
{
    UINT    uRes;

    // Check we're in idle state
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        goto UserPointerCleanup;
    }

    if (*szLoadFileName)
    {
        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

       // Save the current lock
       SaveLock();

       // Get the Page Order Lock (with an invisible dialog)
       BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);

       if (!bGotLock)
       {
           RestoreLock();
           goto UserPointerCleanup;
       }

       // Load the file
       uRes = g_pwbCore->WBP_ContentsLoad(szLoadFileName);
       if (uRes != 0)
       {
           DefaultExceptionHandler(WBFE_RC_WB, uRes);
           return;
       }

        // Set the window title to the new file name
        lstrcpy(m_strFileName, szLoadFileName);

        // Update the window title with the new file name
		UpdateWindowTitle();

        // Set the state to say that we are loading a file
        SetSubstate(SUBSTATE_LOADING);
    }

UserPointerCleanup:

    // Restore the cursor
    ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
}




//
//
// Function:    OnDropFiles
//
// Purpose:     Files have been dropped onto the Whiteboard window
//
//
void WbMainWindow::OnDropFiles(HDROP hDropInfo)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDropFiles");

    UINT  uiFilesDropped = 0;
    UINT  eachfile;

    // Get the total number of files dropped
    uiFilesDropped = ::DragQueryFile(hDropInfo, (UINT) -1, NULL, (UINT) 0);

    // release mouse capture in case we report any errors (message boxes
    // won't repsond to mouse clicks if we don't)
    ReleaseCapture();

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        goto bail_out;

    // Don't prompt to save file if we're already loading
    int iOnSave;
    if( m_uiSubState != SUBSTATE_LOADING )
        {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
        }
    else
        {
        goto bail_out;
        }

    if( iOnSave == IDYES )
        {
        // User wants to save the drawing area contents
        int iResult = OnSave(TRUE);

        if( iResult == IDOK )
            {
            // Update the window title with the new file name
			UpdateWindowTitle();
            }
        else
            {
            // cancelled out of save, so cancel the open operation
            goto bail_out;
            }
        }

    // see if user canceled the whole drop
    if( iOnSave == IDCANCEL )
        goto bail_out;

    for (eachfile = 0; eachfile < uiFilesDropped; eachfile++)
    {
        // Retrieve each file name
        char  szDropFileName[256];

        ::DragQueryFile(hDropInfo, eachfile,
            szDropFileName, 256);

        TRACE_MSG(("Loading file: %s", szDropFileName));

        // Load the file
        // If this is a valid whiteboard file, the action is simply to load it
        if (g_pwbCore->WBP_ValidateFile(szDropFileName, NULL) == 0)
        {
            LoadFile(szDropFileName);
        }
        else
        {
            ::Message(NULL, IDS_MSG_CAPTION,IDS_MSG_BAD_FILE_FORMAT);
        }
    }

bail_out:
    ::DragFinish(hDropInfo);
}



//
//
// Function:    OnOpen
//
// Purpose:     Load a metafile into the application.
//
//
void WbMainWindow::OnOpen(void)
{
    int iOnSave;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnOpen");

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return;

    // Check we're in idle state
    if ( (m_uiState != IN_CALL) || (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS))
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
      }

    // Don't prompt to save file if we're already loading
    if (m_uiSubState != SUBSTATE_LOADING)
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
    }
    else
    {
        iOnSave = IDNO;
    }

    if (iOnSave == IDYES)
    {
        // User wants to save the drawing area contents
        int iResult = OnSave(TRUE);

        if (iResult == IDOK)
        {
		    UpdateWindowTitle();
        }
        else
        {
            // cancelled out of Save As, so cancel the open operation
            iOnSave = IDCANCEL;
        }
    }

    // Only continue if the user has not cancelled the operation
    if (iOnSave != IDCANCEL)
    {
        OPENFILENAME    ofn;
        TCHAR           szFileName[_MAX_PATH];
        TCHAR           szFileTitle[64];
        TCHAR           strLoadFilter[2*_MAX_PATH];
        TCHAR           strDefaultExt[_MAX_PATH];
        TCHAR           strDefaultPath[2*_MAX_PATH];
        TCHAR *         pStr;
  	    UINT            strSize = 0;
      	UINT            totalSize;

        // Build the filter for loadable files
        pStr = strLoadFilter;
        totalSize = 2*_MAX_PATH;

        // These must be NULL separated, with a double NULL at the end
        strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        *pStr = 0;

        //
        // Setup the OPENFILENAME struct
        //
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = m_hwnd;

        // No file name supplied to begin with
        szFileName[0] = 0;
        ofn.lpstrFile = szFileName;
        ofn.nMaxFile = _MAX_PATH;

        // Default Extension:  .WHT
        ::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
        ofn.lpstrDefExt = strDefaultExt;

        // Default file title is empty
        szFileTitle[0] = 0;
        ofn.lpstrFileTitle = szFileTitle;
        ofn.nMaxFileTitle = 64;

        // Open flags
        ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;
        ofn.hInstance = g_hInstance;

        // Filter
        ofn.lpstrFilter = strLoadFilter;

        // Default path
        if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
            ofn.lpstrInitialDir = strDefaultPath;

        // Get user input, continue only if the user selects the OK button
        if (::GetOpenFileName(&ofn))
        {
            // Change the cursor to "wait"
            ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

            // if we're currently loading a file, cancel it, not releasing
            // the page order lock, because we need it immediately afterwards
            if (m_uiSubState == SUBSTATE_LOADING)
            {
                CancelLoad(FALSE);
            }

            // Load the file
            LoadFile(ofn.lpstrFile);
        }
    }
}




//
//
// Function:    GetFileName
//
// Purpose:     Get a file name for saving the contents
//
//
int WbMainWindow::GetFileName(void)
{
    OPENFILENAME    ofn;
    int             iResult;
    TCHAR           szFileTitle[64];
    TCHAR           strSaveFilter[2*_MAX_PATH];
    TCHAR           strDefaultExt[_MAX_PATH];
    TCHAR           strDefaultPath[2 * _MAX_PATH];
    TCHAR           szFileName[2*_MAX_PATH];
    TCHAR *         pStr;
    UINT            strSize = 0;
    UINT            totalSize;

    //
    // If we are already displaying a "Save As" dialog, dismiss it and create
    // a new one.  This can happen if Win95 shuts down whilst WB is
    // displaying the "Save As" dialog and the use selects "Yes" when asked
    // whether they want to save the contents - a second "Save As dialog
    // appears on top of the first.
    //
    if (m_bInSaveDialog)
    {
        CancelSaveDialog();
    }

    // Build the filter for save files
    pStr = strSaveFilter;
    totalSize = 2*_MAX_PATH;

    // These must be NULL separated, with a double NULL at the end
    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    *pStr = 0;

    //
    // Setup the OPENFILENAME struct
    //
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hwnd;

    lstrcpy(szFileName, m_strFileName);
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = _MAX_PATH;

    // Build the default extension string
    ::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
    ofn.lpstrDefExt = strDefaultExt;

    szFileTitle[0] = 0;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = 64;

    // Save flags
    ofn.Flags = OFN_HIDEREADONLY | OFN_NOREADONLYRETURN |
        OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    ofn.hInstance = g_hInstance;

    // Filter
    ofn.lpstrFilter = strSaveFilter;

    // Default path
    if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
        ofn.lpstrInitialDir = strDefaultPath;

    m_bInSaveDialog = TRUE;

    if (::GetSaveFileName(&ofn))
    {
        // The user selected OK
        iResult = IDOK;
        lstrcpy(m_strFileName, szFileName);
    }
    else
    {
        iResult = IDCANCEL;
    }

    m_bInSaveDialog = FALSE;

    return iResult;
}

//
//
// Function:    OnSave
//
// Purpose:     Save the contents of the Whiteboard using the current file
//              name (or prompting for a new name if there is no current).
//
//
int WbMainWindow::OnSave(BOOL bPrompt)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSave");

    int iResult = IDOK;

    // save the old file name in case there's an error
    TCHAR *strOldName;
    UINT fileNameSize = lstrlen(m_strFileName);
    strOldName = new TCHAR[fileNameSize+1];

    if (!strOldName)
    {
        ERROR_OUT(("OnSave: failed to allocate strOldName TCHAR array, fail"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return(iResult);
    }
    else
    {
        lstrcpy(strOldName, m_strFileName);
    }

    BOOL bNewName = FALSE;

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return(iResult);
    }

    // Check whether there is a filename available for use
    if (!fileNameSize || bPrompt)
    {
        // Get user input, continue only if the user selects the OK button
        iResult = GetFileName();

        if (iResult == IDOK)
        {
            // entering a blank file name is treated as cancelling the save
            if (!lstrlen(m_strFileName))
            {
                lstrcpy(m_strFileName, strOldName);
                iResult = IDCANCEL;
            }
            else
            {
                // flag that we've changed the contents file name
                bNewName = TRUE;
            }
        }
    }

    // Now save the file
    if ((iResult == IDOK) && lstrlen(m_strFileName))
    {
        WIN32_FIND_DATA findFileData;
        HANDLE          hFind;

        // Get attributes
        hFind = ::FindFirstFile(m_strFileName, &findFileData);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            ::FindClose(hFind);

            // This is a read-only file; we can't change its contents
            if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                WARNING_OUT(("Dest file %s is read only", m_strFileName));
                ::Message(NULL, IDS_SAVE, IDS_SAVE_READ_ONLY);

                // If the file name was changed for this save then undo
                // the change
                if (bNewName)
                {
                    lstrcpy(m_strFileName, strOldName);
                    bNewName = FALSE;
                }

                // Change the return code to indicate no save was made
                iResult = IDCANCEL;
                return(iResult);
            }
        }

        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL,IDC_WAIT));

        // Write the file
        if (g_pwbCore->WBP_ContentsSave(m_strFileName) != 0)
        {
            // Show that an error occurred saving the file.
            WARNING_OUT(("Error saving file"));
            ::Message(NULL, IDS_SAVE, IDS_SAVE_ERROR);

            // If the file name was changed for this save then undo
            // the change
            if (bNewName)
            {
                lstrcpy(m_strFileName, strOldName);
                bNewName = FALSE;
            }

            // Change the return code to indicate no save was made
            iResult = IDCANCEL;
        }

        // Restore the cursor
        ::SetCursor(::LoadCursor(NULL,IDC_ARROW));
    }

    // if the contents file name has changed as a result of the save then
    // update the window title
    if (bNewName)
    {
		UpdateWindowTitle();
    }

	delete strOldName;
    return(iResult);
}



//
// CancelSaveDialog()
// This cancels the save as dialog if up and we need to kill it to continue.
// We walk back up the owner chain in case the save dialog puts up help or
// other owned windows.
//
void WbMainWindow::CancelSaveDialog(void)
{
    WBFINDDIALOG        wbf;

    ASSERT(m_bInSaveDialog);

    wbf.hwndOwner = m_hwnd;
    wbf.hwndDialog = NULL;
    EnumThreadWindows(::GetCurrentThreadId(), WbFindCurrentDialog, (LPARAM)&wbf);

    if (wbf.hwndDialog)
    {
        // Found it!
        ::SendMessage(wbf.hwndDialog, WM_COMMAND, IDCANCEL, 0);
    }

    m_bInSaveDialog = FALSE;
}



BOOL CALLBACK WbFindCurrentDialog(HWND hwndNext, LPARAM lParam)
{
    WBFINDDIALOG * pwbf = (WBFINDDIALOG *)lParam;

    // Is this a dialog, owned by the main window?
    if ((::GetClassLong(hwndNext, GCW_ATOM) == 0x8002) &&
        (::GetWindow(hwndNext, GW_OWNER) == pwbf->hwndOwner))
    {
        pwbf->hwndDialog = hwndNext;
        return(FALSE);
    }

    return(TRUE);
}



//
//
// Function:    OnClose
//
// Purpose:     Close the Whiteboard
//
//
void WbMainWindow::OnClose()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClose");

    int iOnSave = IDOK;

    KillInitDlg();

    m_drawingArea.CancelDrawingMode();
    m_drawingArea.RemoveMarker(NULL);
    m_drawingArea.GetMarker()->DeleteAllMarkers( NULL );

    m_AG.SaveSettings();

    // If we got here, by way of OnDestroy from the DCL cores or
    // by system shutdown, then assume that user responded already to the
    // save-changes dialog that would have poped up during conf's global shutdown
    // message. We don't need to ask 'em again. What tangled webs......
    if ((!m_bQuerySysShutdown) && (IsIdle()))
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            iOnSave = OnSave(TRUE);
        }
    }

    // If the exit was not cancelled, close the application
    if (iOnSave != IDCANCEL)
    {
        // Mark state as closing - stops any queued events being processed
        m_uiState = CLOSING;

        //PUTBACK BY RAND - the progress timer meter is kinda the heart beat
        //                    of this thing which I ripped out when I removed the
        //                    progress meter. I put it back to fix 1476.
        if (m_bTimerActive)
        {
            ::KillTimer(m_hwnd, TIMERID_PROGRESS_METER);
            m_bTimerActive = FALSE;
        }

        m_drawingArea.ShutDownDC();

        // Close the application
        ::PostQuitMessage(0);
    }

}


//
//
// Function:    OnClearPage
//
// Purpose:     Clear the Whiteboard drawing area. The user is prompted to
//              choose clearing of foreground, background or both.
//
//
void WbMainWindow::OnClearPage(void)
{
    int iResult;
    BOOL bWasPosted;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClearPage");

    if( UsersMightLoseData( &bWasPosted, NULL ) ) // bug NM4db:418
        return;

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(NULL, IDS_CLEAR_CAPTION, IDS_CLEAR_MESSAGE, MB_YESNO | MB_ICONQUESTION);


    if (iResult == IDYES)
    {
        TRACE_MSG(("User requested clear of page"));

        // lock the drawing area
        LockDrawingArea();

        // Save the current lock status
        SaveLock();

        // Get the Page Order Lock (with an invisible dialog)
        BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);

        if( bGotLock  )
        {
            // clear only if we got the page lock (NM4db:470)
            m_drawingArea.Clear();
            GotoPosition(0, 0);
        }

        RestoreLock();
        UnlockDrawingArea();
    }
}




//
//
// Function:    OnDelete
//
// Purpose:     Delete the current selection
//
//
void WbMainWindow::OnDelete()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDelete");

    DCWbGraphic* pGraphicCopy = NULL;

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // If the user currently has a graphic selected
    if (m_drawingArea.GraphicSelected())
    {
      m_LastDeletedGraphic.BurnTrash();

      // Delete the currently selected graphic and add to m_LastDeletedGraphic
      m_drawingArea.DeleteSelection();
    }
}

//
//
// Function:    OnUndelete
//
// Purpose:     Undo the last delete operation
//
//
void WbMainWindow::OnUndelete()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnUndelete");

    // If there is a deleted graphic to restore
    if ( m_LastDeletedGraphic.GotTrash() )
    {
        // If the deleted graphic belongs to the current page
        if (m_LastDeletedGraphic.Page() == m_hCurrentPage)
        {
            // Add the graphic back into the current page
            m_LastDeletedGraphic.AddToPageLast(m_hCurrentPage);

            // if the current tool is a select tool then select the new
            // graphic, otherwise forget it.
            if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
            {
                m_LastDeletedGraphic.SelectTrash();
                m_LastDeletedGraphic.EmptyTrash();
            }
            else
            {
                // Free the local copy
                m_LastDeletedGraphic.BurnTrash();
            }
        }
    }
}



void WbMainWindow::OnSelectAll( void )
{
    // turn off any selections
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // inhibit normal select-tool action
    m_bSelectAllInProgress = TRUE;

    //put us in select-tool mode first
    OnSelectTool(IDM_SELECT);

    // back to normal
    m_bSelectAllInProgress = FALSE;

    // now, select everything
    m_drawingArea.SelectMarkerFromRect( NULL );
}



//
//
// Function:    DoCopy
//
// Purpose:     Copy the current selection to the clipboard
//
//
BOOL WbMainWindow::DoCopy(BOOL bRenderNow)
{
    BOOL bResult = FALSE;
    DCWbGraphicMarker *pMarker;

    DCWbGraphic* pGraphic = m_drawingArea.GetSelection();
    if (pGraphic != NULL)
        {
        pMarker = m_drawingArea.GetMarker();
        if( pMarker->GetNumMarkers() > 1 )
            {
            // more objs than just pGraphic, do a multi-object-to-clipboard
            // operation.
            pGraphic = pMarker;
            }
        //else if == 1 then pMarker contains just pGraphic already
        //    so we do a single-object-to-clipboard operation.

        // Copy the graphic (or multiple marker objects) to the clipboard
        bResult = CLP_Copy(pGraphic, bRenderNow);

        // If an error occurred during the copy, report it now
        if (!bResult)
            {
            ::Message(NULL, IDS_COPY, IDS_COPY_ERROR);
            }
        }

    return bResult;
    }

//
//
// Function:    OnCut
//
// Purpose:     Cut the current selection
//
//
void WbMainWindow::OnCut()
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    if (m_drawingArea.TextEditActive())
    {
        m_drawingArea.TextEditCut();
        return;
    }

    if (DoCopy(TRUE))
    {
        // Graphic copied to the clipboard OK - delete it
        m_drawingArea.DeleteSelection();
    }
}


//
// OnCopy()
// Purpose:     Copy the current selection to the clipboard
//
//
void WbMainWindow::OnCopy(void)
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    if( m_drawingArea.TextEditActive() )
    {
        m_drawingArea.TextEditCopy();
        return;
    }

    DoCopy(TRUE);
}


//
//
// Function:    OnPaste
//
// Purpose:     Paste the contents of the clipboard into the drawing pane
//
//
void WbMainWindow::OnPaste()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaste");

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    if (m_drawingArea.TextEditActive())
    {
        m_drawingArea.TextEditPaste();
        return;
    }

    // Get the data from the clipboard
    DCWbGraphic* pGraphic = CLP_Paste();
    if (pGraphic != NULL)
            {
            TRACE_MSG(("Got graphic object from clipboard OK"));

            //CHANGED BY RAND - have to handle marker sperately,
            //                    marker objects are already added to
            //                    m_hCurrentPage and positioned
            if( pGraphic->IsGraphicTool() == enumGraphicMarker)
            {
                ((DCWbGraphicMarker *)pGraphic)->Update();
                if( m_pCurrentTool->ToolType() == TOOLTYPE_SELECT )
                    {
                    // marker is already setup, just draw it
                    m_drawingArea.PutMarker(NULL);
                    }
                else
                    {
                    // don't select anything, dump marker
                    m_drawingArea.RemoveMarker(NULL);
                    }
                }
            else // not a marker, deal with single object
                {
                    RECT    rcVis;

                    // Position the graphic at the top left of the visible area of the
                    // drawing area
                    m_drawingArea.GetVisibleRect(&rcVis);
                pGraphic->MoveTo(rcVis.left, rcVis.top);

                // Add the graphic to the page
                pGraphic->AddToPageLast(m_hCurrentPage);

                // if the current tool is a select tool then select the new
                // object, otherwise forget it.
                if( m_pCurrentTool->ToolType() == TOOLTYPE_SELECT )
                    m_drawingArea.SelectGraphic(pGraphic);
                else
                    {
                    // Free the graphic
                    delete pGraphic;
                    }
                }
            }
        else
            {
            TRACE_MSG(("Could not get graphic from clipboard"));
            // display error message instead of throwing exception
            ::Message(NULL, IDS_PASTE, IDS_PASTE_ERROR);
            }

    }


//
//
// Function:    OnRenderAllFormats
//
// Purpose:     Render all formats of the graphic last copied to the
//              CLP_
//
//
void WbMainWindow::OnRenderAllFormats(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnRenderAllFormats");
  //
  // only render something if we have not done it already
  //
    if (CLP_LastCopiedPage() != WB_PAGE_HANDLE_NULL)
    {
        if (!CLP_RenderAllFormats())
        {
            // An error occurred rendering the formats
            ERROR_OUT(("Error rendering all formats"));
        }
    }
}

//
//
// Function:    CheckMenuItem
//
// Purpose:     Check an item on the application menus (main and context
//              menu.)
//
//
void WbMainWindow::CheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED); // bug 426
}

//
//
// Function:    UncheckMenuItem
//
// Purpose:     Uncheck an item on the application menus (main and context
//              menus.)
//
//
void WbMainWindow::UncheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED); // bug 426
}

//
//
// Function:    CheckMenuItemRecursive
//
// Purpose:     Check or uncheck an item on the any of the Whiteboard menus.
//              This function recursively searches through the menus until
//              it finds the specified item. The menu item Ids must be
//              unique for this function to work.
//
//
BOOL WbMainWindow::CheckMenuItemRecursive(HMENU hMenu,
                                            UINT uiId,
                                            BOOL bCheck)
{
    UINT uiNumItems = ::GetMenuItemCount(hMenu);

    // Attempt to check the menu item
    UINT uiCheck = MF_BYCOMMAND | (bCheck ? MF_CHECKED : MF_UNCHECKED);

    // A return code of -1 from CheckMenuItem implies that
    // the menu item was not found
    BOOL bChecked = ((::CheckMenuItem(hMenu, uiId, uiCheck) == -1) ? FALSE : TRUE);
    if (bChecked)
    {
        //
        // If this item is on the active menu, ensure it's redrawn now
        //
        if (hMenu == m_hInitMenu)
        {
            InvalidateActiveMenu();
        }
    }
    else
    {
        UINT   uiPos;
        HMENU hSubMenu;

        // Recurse through the submenus of the specified menu
        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Assume that the next item is a submenu
            // and try to get a pointer to it
            hSubMenu = ::GetSubMenu(hMenu, (int)uiPos);

            // NULL return implies the item is a not submenu
            if (hSubMenu != NULL)
            {
                // Item is a submenu, make recursive call to search it
                bChecked = CheckMenuItemRecursive(hSubMenu, uiId, bCheck);
                if (bChecked)
                {
                    // We have found the item
                    break;
                }
            }
        }
    }

    return bChecked;
}

//
//
// Function:    GetMenuWithItem
//
// Purpose:     Return the menu which contains the specified item.
//
//
HMENU WbMainWindow::GetMenuWithItem(HMENU hMenu, UINT uiID)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetMenuWithItem");

    ASSERT(hMenu != NULL);

    HMENU hMenuResult = NULL;

    // Get the number ofitems in the menu
    UINT uiNumItems = ::GetMenuItemCount(hMenu);
    UINT   uiPos;
    UINT   uiNextID;

    // Look for the item through the menu
    for (uiPos = 0; uiPos < uiNumItems; uiPos++)
    {
        // Get the ID of the item at this position
        uiNextID = ::GetMenuItemID(hMenu, uiPos);

        if (uiNextID == uiID)
        {
            // We have found the item
            hMenuResult = hMenu;
            break;
        }
    }

    // If we have not yet found the item
    if (hMenuResult == NULL)
    {
        // Look through each of the submenus of the current menu
        HMENU hSubMenu;

        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Get the ID of the item at this position
            uiNextID = ::GetMenuItemID(hMenu, uiPos);

            // If the item is a submenu
            if (uiNextID == -1)
            {
                // Get the submenu
                hSubMenu = ::GetSubMenu(hMenu, (int) uiPos);

                // Search the submenu
                hMenuResult = GetMenuWithItem(hSubMenu, uiID);
                if (hMenuResult != NULL)
                {
                    // We have found the menu with the requested item
                    break;
                }
            }
        }
    }

    return hMenuResult;
}

//
//
// Function:    OnScrollAccelerator
//
// Purpose:     Called when a scroll accelerator is used
//
//
void WbMainWindow::OnScrollAccelerator(UINT uiMenuId)
{
    int     iScroll;

    // Locate the scroll messages to be sent in the conversion table
    for (iScroll = 0; iScroll < ARRAYSIZE(s_MenuToScroll); iScroll++)
    {
        if (s_MenuToScroll[iScroll].uiMenuId == uiMenuId)
        {
            // Found it;
            break;
        }
    }

    // Send the messages
    if (iScroll < ARRAYSIZE(s_MenuToScroll))
    {
        while ((s_MenuToScroll[iScroll].uiMenuId == uiMenuId) && (iScroll < ARRAYSIZE(s_MenuToScroll)))
        {
            // Tell the drawing pane to scroll
            ::PostMessage(m_drawingArea.m_hwnd, s_MenuToScroll[iScroll].uiMessage,
                s_MenuToScroll[iScroll].uiScrollCode, 0);

            iScroll++;
        }

        // Indicate that scrolling has completed (in both directions)
        ::PostMessage(m_drawingArea.m_hwnd, WM_HSCROLL, SB_ENDSCROLL, 0L);
        ::PostMessage(m_drawingArea.m_hwnd, WM_VSCROLL, SB_ENDSCROLL, 0L);
    }
}



//
//
// Function:    OnZoom
//
// Purpose:     Zoom or unzoom the drawing area
//
//
void WbMainWindow::OnZoom()
{
    // If the drawing area is currently zoomed
    if (m_drawingArea.Zoomed())
    {
        // Remove the zoomed check mark
        UncheckMenuItem(IDM_ZOOM);

        // Tell the tool bar of the new selection
        m_TB.PopUp(IDM_ZOOM);

        // Inform the local user of the zoom state
        if (m_pLocalUser != NULL)
            m_pLocalUser->Unzoom();
    }
    else
    {
        // Set the zoomed check mark
        CheckMenuItem(IDM_ZOOM);

        // Tell the tool bar of the new selection
        m_TB.PushDown(IDM_ZOOM);

        // Inform the local user of the zoom state
        if (m_pLocalUser != NULL)
            m_pLocalUser->Zoom();
    }

    // Zoom/unzoom the drawing area
    m_drawingArea.Zoom();

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSelectTool
//
// Purpose:     Select the current tool
//
//
void WbMainWindow::OnSelectTool(UINT uiMenuId)
{
    UINT uiIndex;

    UncheckMenuItem(m_currentMenuTool);
    CheckMenuItem( uiMenuId);

    // Save the new menu Id
    m_currentMenuTool = uiMenuId;

    // Tell the tool bar of the new selection
    m_TB.PushDown(m_currentMenuTool);

    // Get the new tool
    m_pCurrentTool = m_ToolArray[TOOL_INDEX(m_currentMenuTool)];

    // Set the current attributes
    if( !m_bSelectAllInProgress )
    {
        m_AG.SetChoiceColor(m_pCurrentTool->GetColor() );

        ::SendMessage(m_hwnd, WM_COMMAND, IDM_COLOR, 0L);
        ::SendMessage(m_hwnd, WM_COMMAND, IDM_WIDTHS_START + m_pCurrentTool->GetWidthIndex(), 0L);//CHANGED BY RAND
    }

    // Report the change of tool to the attributes group
    m_AG.DisplayTool(m_pCurrentTool);

    // Select the new tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSelectColor
//
// Purpose:     Set the current color
//
//
void WbMainWindow::OnSelectColor(void)
{
    // Tell the attributes group of the new selection and get the
    // new color value selected ino the current tool.
    m_AG.SelectColor(m_pCurrentTool);

    // Select the changed tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // If we are using a select tool, change the color of the selected object
    if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
    {
        // If there is an object marked for changing
        if (m_drawingArea.GraphicSelected())
        {
            // Update the object
            m_drawingArea.SetSelectionColor(m_pCurrentTool->GetColor());
        }
    }

    // if currently editing a text object then change its color
    if (   (m_pCurrentTool->ToolType() == TOOLTYPE_TEXT)
        && (m_drawingArea.TextEditActive()))
    {
        m_drawingArea.SetSelectionColor(m_pCurrentTool->GetColor());
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSelectWidth
//
// Purpose:     Set the current nib width
//
//
void WbMainWindow::OnSelectWidth(UINT uiMenuId)
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // Move the check mark on the menu
    UncheckMenuItem(m_currentMenuWidth);
    CheckMenuItem(uiMenuId);

    // Save the new pen width
    m_currentMenuWidth = uiMenuId;

    // Tell the attributes display of the new selection
    m_WG.PushDown(uiMenuId - IDM_WIDTHS_START);

    if (m_pCurrentTool != NULL)
    {
        m_pCurrentTool->SetWidthIndex(uiMenuId - IDM_WIDTHS_START);
    }

    // Tell the drawing pane of the new selection
    m_drawingArea.SelectTool(m_pCurrentTool);

    // If we are using a select tool, change the color of the selected object
    if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
    {
        // If there is an object marked for changing
        if (m_drawingArea.GraphicSelected())
        {
            // Update the object
            m_drawingArea.SetSelectionWidth(m_pCurrentTool->GetWidth());
        }
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    OnChooseFont
//
// Purpose:     Let the user select a font
//
//
void WbMainWindow::OnChooseFont(void)
{
    HDC hdc;
    LOGFONT lfont;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnChooseFont");

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // It is only really sensible to be here when a text tool is selected.
    // This is achieved by graying the Font selection menu entry when
    // anything other than a text tool is in use.

    // Get the font details from the current tool
    ::GetObject(m_pCurrentTool->GetFont(), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    //
    // The Font dialog is passed a LOGFONT structure which it uses to
    // initialize all of its fields (face name, weight etc).
    //
    // The face name passed in the LOGFONT structure is checked by the dialog
    // against the facenames of all available fonts.  If the name does not
    // match one of the available fonts, no name is displayed.
    //
    // WB stores the LOGFONT structure specifying the font used for a text
    // object in the object.  This LOGFONT is selected into a DC where the
    // GDIs font mapper decides which physical font most closely matches the
    // required logical font.  On boxes where the original font is not
    // supported the font is substituted for the closest matching font
    // available.
    //
    // So, if we pass the LOGFONT structure for a font which is not supported
    // into the Font dialog, no facename is displayed.  To bypass this we
    //
    // - select the logical font into a DC
    //
    // - determine the textmetrics and get the face name of the physical font
    //   chosen by the Font Mapper
    //
    // - use these textmetrics to create a LOGFONT structure which matches
    //   the substituted font!
    //
    // The resulting LOGFONT will have the correct weight, dimensions and
    // facename for the substituted font.
    //
    hdc = ::CreateCompatibleDC(NULL);
    if (hdc != NULL)
    {
        TEXTMETRIC  tm;
        HFONT       hFont;
        HFONT       hOldFont;

        hFont = ::CreateFontIndirect(&lfont);

        //
        // Get the face name and text metrics of the selected font.
        //
        hOldFont = SelectFont(hdc, hFont);
        if (hOldFont == NULL)
        {
            WARNING_OUT(("Failed to select font into DC"));
        }
        else
        {
            ::GetTextMetrics(hdc, &tm);
            ::GetTextFace(hdc, LF_FACESIZE, lfont.lfFaceName);

            //
            // Restore the old font back into the DC.
            //
            SelectFont(hdc, hOldFont);

            //
            // Create a LOGFONT structure which matches the Text metrics
            // of the font used by the DC so that the font dialog manages
            // to initialise all of its fields properly, even for
            // substituted fonts...
            //
            lfont.lfHeight    =  tm.tmHeight;
            lfont.lfWidth     =  tm.tmAveCharWidth;
            lfont.lfWeight    =  tm.tmWeight;
            lfont.lfItalic    =  tm.tmItalic;
            lfont.lfUnderline =  tm.tmUnderlined;
            lfont.lfStrikeOut =  tm.tmStruckOut;
            lfont.lfCharSet   =  tm.tmCharSet;

            //ADDED BY RAND - to make lfHeight be a char height. This makes
            //                the font dlg show the same pt size that is
            //                displayed in the sample font toolbar
            if( lfont.lfHeight > 0 )
            {
                lfont.lfHeight = -(lfont.lfHeight - tm.tmInternalLeading);
            }
        }

        ::DeleteDC(hdc);

        if (hFont != NULL)
        {
            ::DeleteFont(hFont);
        }
    }
    else
    {
        WARNING_OUT(("Failed to get DC to select font into"));
    }

    CHOOSEFONT  cf;
    TCHAR       szStyleName[64];

    ZeroMemory(&cf, sizeof(cf));
    ZeroMemory(szStyleName, sizeof(szStyleName));

    cf.lStructSize = sizeof(cf);
    cf.lpszStyle = szStyleName;
    cf.rgbColors = m_pCurrentTool->GetColor() & 0x00ffffff; // blow off palette bits (NM4db:2304)
    cf.Flags = CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS |
        CF_NOVERTFONTS;
    cf.lpLogFont = &lfont;
    cf.hwndOwner = m_hwnd;

    // Call up the ChooseFont dialog from COM DLG
    if (::ChooseFont(&cf))
    {
        lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

        //ADDED BY RAND - set color selected in dialog.
        m_pCurrentTool->SetColor(cf.rgbColors);
        m_AG.DisplayTool( m_pCurrentTool );

        ::SendMessage(m_hwnd, WM_COMMAND,
                (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                (LPARAM)0 );

        // Inform the drawing pane of the new selection
        HFONT   hNewFont;

        hNewFont = ::CreateFontIndirect(&lfont);
        if (!hNewFont)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return;
        }

        //
        // We need to set the text editor font after inserting it in the DC
        // and querying the metrics, otherwise we may get a font with different
        // metrics in zoomed mode
        //
        HFONT   hNewFont2;
        HDC hDC = m_drawingArea.GetCachedDC();
        TEXTMETRIC textMetrics;

        m_drawingArea.PrimeFont(hDC, hNewFont, &textMetrics);
        lfont.lfHeight            = textMetrics.tmHeight;
        lfont.lfWidth             = textMetrics.tmAveCharWidth;
        lfont.lfPitchAndFamily    = textMetrics.tmPitchAndFamily;
        ::GetTextFace(hDC, sizeof(lfont.lfFaceName),
                     lfont.lfFaceName);
        TRACE_MSG(("Font face name %s", lfont.lfFaceName));

        // Inform the drawing pane of the new selection
        hNewFont2 = ::CreateFontIndirect(&lfont);
        if (!hNewFont2)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return;
        }


		m_drawingArea.SetSelectionColor(cf.rgbColors);
		
        m_drawingArea.SetSelectionFont(hNewFont2);

        if (m_pCurrentTool != NULL)
        {
            m_pCurrentTool->SetFont(hNewFont2);
        }
        m_drawingArea.SelectTool(m_pCurrentTool);

        //
        // discard the new font
        //
        m_drawingArea.UnPrimeFont( hDC );

        // Delete the fonts we created--everybody above makes copies
        ::DeleteFont(hNewFont2);
        ::DeleteFont(hNewFont);
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    OnToolBarToggle
//
// Purpose:     Let the user toggle the tool bar on/off
//
//
void WbMainWindow::OnToolBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bToolBarOn = !m_bToolBarOn;

    // Make the necessary updates
    if (m_bToolBarOn)
    {
        // The tool bar was hidden, so show it
        ::ShowWindow(m_TB.m_hwnd, SW_SHOW);

        // The tool window is fixed so we must resize the other panes in
        // the window to make room for it
        ResizePanes();

        // Check the associated menu item
        CheckMenuItem(IDM_TOOL_BAR_TOGGLE);
    }
    else
    {
        // The tool bar was visible, so hide it
        ::ShowWindow(m_TB.m_hwnd, SW_HIDE);

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_TOOL_BAR_TOGGLE);

        ResizePanes();
    }

    // Make sure things reflect current tool
    m_AG.DisplayTool(m_pCurrentTool);

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_TOOLBARVISIBLE,
                           m_bToolBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top,
        rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
}

//
//
// Function:    OnStatusBarToggle
//
// Purpose:     Let the user toggle the help bar on/off
//
//
void WbMainWindow::OnStatusBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bStatusBarOn = !m_bStatusBarOn;

    // Make the necessary updates
    if (m_bStatusBarOn)
    {
        // Resize the panes to give room for the help bar
        ResizePanes();

        // The help bar was hidden, so show it
        ::ShowWindow(m_hwndSB, SW_SHOW);

        // Check the associated menu item
        CheckMenuItem(IDM_STATUS_BAR_TOGGLE);
    }
    else
    {
        // The help bar was visible, so hide it
        ::ShowWindow(m_hwndSB, SW_HIDE);

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_STATUS_BAR_TOGGLE);

        // Resize the panes to take up the help bar space
        ResizePanes();
    }

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, m_bStatusBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top,
        rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
}



//
//
// Function:    OnAbout
//
// Purpose:     Show the about box for the Whiteboard application. This
//              method is called whenever a WM_COMMAND with IDM_ABOUT
//              is issued by Windows.
//
//
void WbMainWindow::OnAbout()
{
    ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(ABOUTBOX), m_hwnd,
        AboutDlgProc, 0);
}


INT_PTR AboutDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            TCHAR   szFormat[256];
            TCHAR   szVersion[512];

            ::GetDlgItemText(hwnd, IDC_ABOUTVERSION, szFormat, 256);
            wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hwnd, IDC_ABOUTVERSION, szVersion);

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}





//
//
// Function:    SelectWindow
//
// Purpose:     Let the user select a window for grabbing
//
//
HWND WbMainWindow::SelectWindow(void)
{
    POINT   mousePos;            // Mouse position
    HWND    hwndSelected = NULL; // Window clicked on
    MSG     msg;                 // Current message

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( GRABCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode state
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Trap all mouse messages until a WM_LBUTTONUP is received
    for ( ; ; )
    {
        // Wait for the next message
        ::WaitMessage();


        // Cancel if we have been sent a WM_CANCELMODE message
        if (CancelModeSent())
        {
            break;
        }

        // If it is a mouse message, process it
        if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
        {
            if (msg.message == WM_LBUTTONUP)
            {
                // Get mouse position
                mousePos.x = (short)LOWORD(msg.lParam);
                mousePos.y = (short)HIWORD(msg.lParam);

                // Convert to screen coordinates
                ::ClientToScreen(m_hwnd, &mousePos);

                // Get the window under the mouse
                hwndSelected = ::WindowFromPoint(mousePos);

                // Leave the loop
                break;
            }
        }

        // Cancel if ESCAPE is pressed.
        // or if another window receives the focus
        else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
        {
            if (msg.wParam == VK_ESCAPE)
            {
                break;
            }
        }
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    return(hwndSelected);
}

//
//
// Function:    OnGrabWindow
//
// Purpose:     Allows the user to grab a bitmap of a window
//
//
void WbMainWindow::OnGrabWindow(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabWindow");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTWINDOW),
        m_hwnd, WarnSelectWindowDlgProc, 0) != IDOK)
    {
        // User cancelled; bail out
        return;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);

    // Get window selection from the user
    HWND hwndSelected = SelectWindow();

    if (hwndSelected != NULL)
    {
        // Walk back to the find the 'real' window ancestor
        HWND    hwndParent;

        // The following piece of code attempts to find the frame window
        // enclosing the selected window. This allows us to bring the
        // enclosing window to the top, bringing the child window with it.
        DWORD dwStyle;

        while ((hwndParent = ::GetParent(hwndSelected)) != NULL)
        {
            // If we have reached a stand-alone window, stop the search
            dwStyle = ::GetWindowLong(hwndSelected, GWL_STYLE);

            if (   ((dwStyle & WS_POPUP) == WS_POPUP)
                || ((dwStyle & WS_THICKFRAME) == WS_THICKFRAME)
                || ((dwStyle & WS_DLGFRAME) == WS_DLGFRAME))
            {
                break;
            }

            // Move up to the parent window
            hwndSelected = hwndParent;
        }

        // Bring the selected window to the top
        ::BringWindowToTop(hwndSelected);
        ::UpdateWindow(hwndSelected);

        // Get an image copy of the window
        RECT areaRect;

        ::GetWindowRect(hwndSelected, &areaRect);

        DCWbGraphicDIB dib;
        dib.FromScreenArea(&areaRect);

        // Add the new grabbed bitmap
        AddCapturedImage(dib);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Show the windows again
    ::ShowWindow(m_hwnd, SW_SHOW);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
// WarnSelectWindowDlgProc()
// This puts up the warning/explanation dialog.  We use the default settings
// or whatever the user chose last time this dialog was up.
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            if (OPT_GetBooleanOption( OPT_MAIN_SELECTWINDOW_NOTAGAIN,
                            DFLT_MAIN_SELECTWINDOW_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SWWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTWINDOW_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:    ShowAllWindows
//
// Purpose:     Show or hide the main window and associated windows
//
//
void WbMainWindow::ShowAllWindows(int iShow)
{
    // Show/hide the main window
    ::ShowWindow(m_hwnd, iShow);

    // Show/hide the tool window
    if (m_bToolBarOn)
    {
        ::ShowWindow(m_TB.m_hwnd, iShow);
    }
}

//
//
// Function:    OnGrabArea
//
// Purpose:     Allows the user to grab a bitmap of an area of the screen
//
//
void WbMainWindow::OnGrabArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabArea");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTAREA),
        m_hwnd, WarnSelectAreaDlgProc, 0) != IDOK)
    {
        // User cancelled, so bail out
        return;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode status
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Let the user select the area to be grabbed
    RECT rect;
    int  tmp;

    GetGrabArea(&rect);

    // Normalize coords
    if (rect.right < rect.left)
    {
        tmp = rect.left;
        rect.left = rect.right;
        rect.right = tmp;
    }

    if (rect.bottom < rect.top)
    {
        tmp = rect.top;
        rect.top = rect.bottom;
        rect.bottom = tmp;
    }

    DCWbGraphicDIB dib;
    if (!::IsRectEmpty(&rect))
    {
        // Get a bitmap copy of the screen area
        dib.FromScreenArea(&rect);
    }

    // Show the windows again now - if we do it later we get the bitmap to
    // be added re-drawn twice (once on the window show and once when the
    // graphic added indication arrives).
    ::ShowWindow(m_hwnd, SW_SHOW);
    ::UpdateWindow(m_hwnd);

    if (!::IsRectEmpty(&rect))
    {
        // Add the bitmap
        AddCapturedImage(dib);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}



//
// WarnSelectArea dialog handler
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            if (OPT_GetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN,
                    DFLT_MAIN_SELECTAREA_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SAWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:    GetGrabArea
//
// Purpose:     Allows the user to grab a bitmap of an area of the screen
//
//
void WbMainWindow::GetGrabArea(LPRECT lprect)
{
    POINT  mousePos;            // Mouse position
    MSG    msg;                 // Current message
    BOOL   tracking = FALSE;    // Flag indicating mouse button is down
    HDC    hDC = NULL;
    POINT  grabStartPoint;      // Start point (when mouse button is pressed)
    POINT  grabEndPoint;        // End point (when mouse button is released)
    POINT  grabCurrPoint;       // Current mouse position

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetGrabArea");

    // Set the result to an empty rectangle
    ::SetRectEmpty(lprect);

    // Create the rectangle to be used for tracking
    DCWbGraphicTrackingRectangle rectangle;
    rectangle.SetColor(RGB(0, 0, 0));
    rectangle.SetPenWidth(1);
    rectangle.SetPenStyle(PS_DOT);

    // Get the DC for tracking
    HWND hDesktopWnd = ::GetDesktopWindow();
    hDC = ::GetWindowDC(hDesktopWnd);
    if (hDC == NULL)
    {
        WARNING_OUT(("NULL desktop DC"));
        goto GrabAreaCleanup;
    }

    // Trap all mouse messages until a WM_LBUTTONUP is received
    for ( ; ; )
    {
        // Wait for the next message
        ::WaitMessage();

        // Cancel if we have been sent a WM_CANCELMODE message
        if (CancelModeSent())
        {
            TRACE_MSG(("canceling grab"));

            // Erase the last tracking rectangle
            if (!EqualPoint(grabStartPoint, grabEndPoint))
            {
                rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                rectangle.Draw(hDC);
            }

            break;
        }

        // If it is a mouse message, process it
        if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
        {
            // Get mouse position
            TRACE_MSG( ("msg = %x, lParam = %0x", msg.message, msg.lParam) );
            mousePos.x = (short)LOWORD(msg.lParam);
            mousePos.y = (short)HIWORD(msg.lParam);

            TRACE_MSG( ("mousePos = %d,%d", mousePos.x, mousePos.y) );

            // Convert to screen coordinates
            ::ClientToScreen(m_hwnd, &mousePos);
            grabCurrPoint = mousePos;

            switch (msg.message)
            {
                // Starting the grab
                case  WM_LBUTTONDOWN:
                    // Save the starting position
                    TRACE_MSG(("grabbing start position"));
                    grabStartPoint = mousePos;
                    grabEndPoint   = mousePos;
                    tracking       = TRUE;
                    break;

                // Completing the rectangle
                case WM_LBUTTONUP:
                {
                    tracking       = FALSE;
                    // Check that there is an area to capture
                    TRACE_MSG(("grabbing end position"));
                    if (EqualPoint(grabStartPoint, grabCurrPoint))
                    {
                        TRACE_MSG(("start == end, skipping grab"));
                        goto GrabAreaCleanup;
                    }

                    // Erase the last tracking rectangle
                    if (!EqualPoint(grabStartPoint, grabEndPoint))
                    {
                        rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                        rectangle.Draw(hDC);
                    }

                    // Update the rectangle object
                    rectangle.SetRectPts(grabStartPoint, grabCurrPoint);
                    *lprect = *rectangle.GetRect();

                    // We are done
                    goto GrabAreaCleanup;
                }
                break;

                // Continuing the rectangle
                case WM_MOUSEMOVE:
                    if (tracking)
                    {
                        TRACE_MSG(("tracking grab"));

                        // Erase the last tracking rectangle
                        if (!EqualPoint(grabStartPoint, grabEndPoint))
                        {
                            rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                            rectangle.Draw(hDC);
                        }

                        // Draw the new rectangle
                        if (!EqualPoint(grabStartPoint, grabCurrPoint))
                        {
                            // Save the new box end point
                            grabEndPoint = grabCurrPoint;

                            // Draw the rectangle
                            TRACE_MSG( ("grabStartPoint = %d,%d",
                                grabStartPoint.x, grabStartPoint.y) );
                            TRACE_MSG( ("grabEndPoint = %d,%d",
                                grabEndPoint.x, grabEndPoint.y) );

                            rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                            rectangle.Draw(hDC);
                        }
                    }
                    break;
            }
        }
        // Cancel if ESCAPE is pressed.
        else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
        {
            if( ((msg.message == WM_KEYUP)||(msg.message == WM_SYSKEYUP))&&
                (msg.wParam == VK_ESCAPE) )
            {
                TRACE_MSG(("grab cancelled by ESC"));

                // Erase the last tracking rectangle
                if (!EqualPoint(grabStartPoint, grabEndPoint))
                {
                    rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                    rectangle.Draw(hDC);
                }
                break;
            }
        }
    }

GrabAreaCleanup:

    // Release the device context (if we have it)
    if (hDC != NULL)
    {
        ::ReleaseDC(hDesktopWnd, hDC);
    }
}



//
//
// Function:    AddCapturedImage
//
// Purpose:     Add a bitmap to the contents (adding a new page for it
//              if necessary).
//
//
void WbMainWindow::AddCapturedImage(DCWbGraphicDIB& dib)
{
    // Position the grabbed object at the top left of the currently visible
    // area.
    RECT    rcVis;
    m_drawingArea.GetVisibleRect(&rcVis);
    dib.MoveTo(rcVis.left, rcVis.top);

    // Add the new grabbed bitmap
    dib.AddToPageLast(m_hCurrentPage);
}

//
//
// Function:    OnPrint
//
// Purpose:     Print the contents of the drawing pane
//
//
void WbMainWindow::OnPrint()
{
    BOOL        bPrintError = FALSE;
    PRINTDLG    pd;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPrint");

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    //
    // Initialize the PRINTDLG structure
    //
    ZeroMemory(&pd, sizeof(pd));
    pd.lStructSize      = sizeof(pd);
    pd.hInstance        = g_hInstance;
    pd.hwndOwner        = m_hwnd;
    pd.Flags            = PD_ALLPAGES | PD_RETURNDC | PD_PAGENUMS |
        PD_HIDEPRINTTOFILE | PD_NOSELECTION;

    pd.nMinPage         = 1;
    pd.nMaxPage         = (WORD)g_pwbCore->WBP_ContentsCountPages();
    pd.nFromPage        = pd.nMinPage;
    pd.nToPage          = pd.nMaxPage;

    // Put up the COMMDLG print dialog
    if (::PrintDlg(&pd))
    {
        int nStartPage, nEndPage;

        // Get the start and end page numbers to be printed
        if (pd.Flags & PD_PAGENUMS)
        {
            nStartPage  = pd.nFromPage;
            nEndPage    = pd.nToPage;
        }
        else
        {
            nStartPage  = pd.nMinPage;
            nEndPage    = pd.nMaxPage;
        }

        // Check whether any pages are to be printed
        if (nStartPage <= pd.nMaxPage)
        {
            // Ensure that the start and end pages lie within range.
            nStartPage = max(nStartPage, pd.nMinPage);
            nEndPage = min(nEndPage, pd.nMaxPage);

            // Get the printer and output port names.
            // These are written to the dialog for the user to see
            // in the OnInitDialog member.
            TCHAR szDeviceName[2*_MAX_PATH];
            LPDEVNAMES lpDev;

            // Device name
            if (pd.hDevNames == NULL)
            {
                szDeviceName[0] = 0;
            }
            else
            {
                lpDev = (LPDEVNAMES)::GlobalLock(pd.hDevNames);

                wsprintf(szDeviceName, "%s %s",
                    (LPCTSTR)lpDev + lpDev->wDeviceOffset,
                    (LPCTSTR)lpDev + lpDev->wOutputOffset);

                ::GlobalUnlock(pd.hDevNames);
            }

            //
            // Tell the printer we are starting the print.
            // Note that the printer object handles the cancellation dialog.
            WbPrinter printer(szDeviceName);

            TCHAR szJobName[_MAX_PATH];
            ::LoadString(g_hInstance, IDS_PRINT_NAME, szJobName, _MAX_PATH);

            int nPrintResult = printer.StartDoc(pd.hDC, szJobName, nStartPage);
            if (nPrintResult < 0)
            {
                WARNING_OUT(("Print result %d", nPrintResult));
                bPrintError = TRUE;
            }
            else
            {
                // Find out how many copies to print
                int copyNum;

                copyNum = 0;
                while ((copyNum < pd.nCopies) && !bPrintError)
                {
                    // Loop through all pages
                    int nPrintPage;
                    WB_PAGE_HANDLE hPage;

                    for (nPrintPage = nStartPage; nPrintPage <= nEndPage; nPrintPage++)
                    {
                        // Get the first page
                        hPage = PG_GetPageNumber((WORD) nPrintPage);

                        // Only print the page if there are some objects on it
                        if (g_pwbCore->WBP_PageCountGraphics(hPage) > 0)
                        {
                            // Tell the printer we are starting a new page
                            printer.StartPage(pd.hDC, nPrintPage);
                            if (!printer.Error())
                            {
                                RECT    rectArea;

                                rectArea.left = 0;
                                rectArea.top = 0;
                                rectArea.right = DRAW_WIDTH;
                                rectArea.bottom = DRAW_HEIGHT;

                                // Print the page
                                PG_Print(hPage, pd.hDC, &rectArea);

                                // Inform the printer that the page is complete
                                printer.EndPage(pd.hDC);
                            }
                            else
                            {
                                bPrintError = TRUE;
                                break;
                            }
                        }
                    }

                    copyNum++;
                }

                // The print has completed
                nPrintResult = printer.EndDoc(pd.hDC);
                if (nPrintResult < 0)
                {
                    WARNING_OUT(("Print result %d", nPrintResult));
                    bPrintError = TRUE;
                }

                // reset the error if the user cancelled the print
                if (printer.Aborted())
                {
                    WARNING_OUT(("User cancelled print"));
                    bPrintError = FALSE;
                }
            }
        }
    }

    // Inform the user if an error occurred
    if (bPrintError)
    {
        // display a message informing the user the job terminated
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_PRINTER, 0);
    }

    //
    // Cleanup the hDevMode, hDevNames, and hdc blocks if allocated
    //
    if (pd.hDevMode != NULL)
    {
        ::GlobalFree(pd.hDevMode);
        pd.hDevMode = NULL;
    }

    if (pd.hDevNames != NULL)
    {
        ::GlobalFree(pd.hDevNames);
        pd.hDevNames = NULL;
    }

    if (pd.hDC != NULL)
    {
        ::DeleteDC(pd.hDC);
        pd.hDC = NULL;
    }

}


//
//
// Function:    OnPageSorter
//
// Purpose:     Re-order the pages
//
//
void WbMainWindow::OnPageSorter()
{
    // don't call up page sorter if another user is presenting (has the contents
    // locked and sync on)
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        PAGESORT    ps;

        m_drawingArea.CancelDrawingMode();

        // Save the lock state (in case the Page Sorter gets it)
        SaveLock();

        //
        // Fill in the initial values
        //
        ZeroMemory(&ps, sizeof(ps));
        ps.hCurPage = m_hCurrentPage;
        ps.fPageOpsAllowed = (m_uiSubState == SUBSTATE_IDLE);

        //
        // Put up the dialog
        //
        ASSERT(m_hwndPageSortDlg == NULL);

        ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(PAGESORTERDIALOG),
            m_hwnd, PageSortDlgProc, (LPARAM)&ps);

        ASSERT(m_hwndPageSortDlg == NULL);

        // Restore the lock state
        RestoreLock();

        // Set up the new current page pointer
        if ((ps.hCurPage != m_hCurrentPage) || ps.fChanged)
        {
            GotoPage((WB_PAGE_HANDLE)ps.hCurPage);
        }

        // Update the page number display,
        // the number of the current page may have changed.
        UpdateStatus();
    }
}

//
//
// Function:    OnInsertPageBefore
//
// Purpose:     Insert a new page before the current page
//
//
void WbMainWindow::OnInsertPageBefore()
{
    if (!m_bUnlockStateSettled)
    {
        // Disable insert button code so crazed users can't insert again before
        // the conference wide page-lock status has settled. If we ask for the
        // page-lock again before the last unlock has finished then something
        // happens to the lock-event from the cores and we hang waiting for it
        // (until our wait-timeout runs out). This arguably could be called a
        // DCL core bug but I couldn't generate any convincing proof of that
        // so I just fixed it on Whiteboard's end by preventing asking for the
        // lock too soon.
        //
        // RestoreLock() will eventually set m_bUnlockStateSettled to TRUE (in
        // OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
        MessageBeep( 0xffffffff );
        return;
    }

    // check state before allowing action
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    // Save the current lock status
    SaveLock();

    // Catch exceptions so that we can restore the lock state
        // Get the Page Order Lock (with an invisible dialog)
        BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
        if (bGotLock)
        {
            UINT uiRet;
        WB_PAGE_HANDLE hPage;

        // Set flag to prevent any more inserts until
        // we have completely released the page-lock
        m_bUnlockStateSettled = FALSE;

        // Add the new page to the list (throws an exception on failure)
        uiRet = g_pwbCore->WBP_PageAddBefore(m_hCurrentPage, &hPage);
        if (uiRet != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiRet);
            return;
        }

        // Go to the inserted page
        GotoPage(hPage);
    }

  //CHANGED BY RAND
  // Restore the lock status. This will eventually set m_bUnlockStateSettled
  // to TRUE (in OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
  // and enable this function after the conference wide lock-status
  // has settled.
  RestoreLock();

}

//
//
// Function:    InsertPageAfter
//
// Purpose:     Insert a new page after the specified page.
//
//
void WbMainWindow::InsertPageAfter(WB_PAGE_HANDLE hPageAfter)
{
    if (!m_bUnlockStateSettled)
    {
        // Disable insert button code so crazed users can't insert again before
        // the conference wide page-lock status has settled. If we ask for the
        // page-lock again before the last unlock has finished then something
        // happens to the lock-event from the cores and we hang waiting for it
        // (until our wait-timeout runs out). This arguably could be called a
        // DCL core bug but I couldn't generate any convincing proof of that
        // so I just fixed it on Whiteboard's end by preventing asking for the
        // lock too soon.
        //
        // RestoreLock() will eventually set m_bUnlockStateSettled to TRUE (in
        // OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
        MessageBeep( 0xffffffff );
        return;
    }


    // check state before allowing action
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    // Save the current lock status
    SaveLock();

  // Catch exceptions so that we can restore the lock state
    BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
    if (bGotLock)
    {
        UINT    uiRet;
        WB_PAGE_HANDLE  hPage;

        // Set flag to prevent any more inserts until
        // we have completely released the page-lock
        m_bUnlockStateSettled = FALSE;

        uiRet = g_pwbCore->WBP_PageAddAfter(hPageAfter, &hPage);
        if (uiRet != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiRet);
            return;
        }

        // Move to the added page
        GotoPage(hPage);

    }

  //CHANGED BY RAND
  // Restore the lock status. This will eventually set m_bUnlockStateSettled
  // to TRUE (in OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
  // and enable this function after the conference wide lock-status
  // has settled.
  RestoreLock();

}

//
//
// Function:    OnInsertPageAfter
//
// Purpose:     Insert a new page after the current page
//
//
void WbMainWindow::OnInsertPageAfter()
{
    // Insert the new page
    InsertPageAfter(m_hCurrentPage);
}

//
//
// Function:    OnDeletePage
//
// Purpose:     Delete the current page
//
//
void WbMainWindow::OnDeletePage()
{
    int iResult;
    BOOL bWasPosted;

    if (!m_bUnlockStateSettled)
    {
        // Disable delete button code so crazed users can't delete again before
        // the conference wide page-lock status has settled. If we ask for the
        // page-lock again before the last unlock has finished then something
        // happens to the lock-event from the cores and we hang waiting for it
        // (until our wait-timeout runs out). This arguably could be called a
        // DCL core bug but I couldn't generate any convincing proof of that
        // so I just fixed it on Whiteboard's end by preventing asking for the
        // lock too soon.
        //
        // RestoreLock() will eventually set m_bUnlockStateSettled to TRUE (in
        // OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
        MessageBeep( 0xffffffff );
        return;
    }

    // check state
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    // Display a message box with the relevant question
    if( UsersMightLoseData( &bWasPosted, NULL ) ) // bug NM4db:418
        return;

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(NULL, IDS_DELETE_PAGE, IDS_DELETE_PAGE_MESSAGE, MB_YESNO | MB_ICONQUESTION);


    // If the user wants to continue with the delete
    if (iResult == IDYES)
        {
        // If this is the only page
        if (g_pwbCore->WBP_ContentsCountPages() == 1)
            {
            // Just clear it. The core does handle this
            // case but it is better not to get the lock unnecessarily, the
            // lock is required to call the core delete page function.
            m_drawingArea.Clear();
            }
        else
            {
            // Lock the drawing area - this ensures we cannot draw to a bad page
            // It will normally be unlocked when we get the corresponding page
            // delete indication
            // - moved until after we have got the page order lock
            //LockDrawingArea();

            // Save the current lock status
            SaveLock();

            // Catch exceptions so that we can restore the lock state
                // Get the Page Order Lock (with an invisible dialog)
                BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
                if (bGotLock)
                {
                    UINT    uiRet;

                    // Set flag to prevent any more inserts until
                    // we have completely released the page-lock
                    m_bUnlockStateSettled = FALSE;

                    // Lock the drawing area - this ensures we cannot draw to a bad page
                    // It will normally be unlocked when we get the corresponding page
                    // delete indication
                    LockDrawingArea();

                    // Delete the page. The page is not deleted immediately but a
                    // WBP_EVENT_PAGE_DELETED event is generated.
                    uiRet = g_pwbCore->WBP_PageDelete(m_hCurrentPage);
                    if (uiRet != 0)
                    {
                        DefaultExceptionHandler(WBFE_RC_WB, uiRet);
                        return;
                    }
                    }

            //CHANGED BY RAND
            // Restore the lock status. This will eventually set m_bUnlockStateSettled
            // to TRUE (in OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
            // and enable this function after the conference wide lock-status
            // has settled.
            RestoreLock();
            }
        }

    }

//
//
// Function:    OnRemotePointer
//
// Purpose:     Create a remote pointer
//
//
void WbMainWindow::OnRemotePointer(void)
{
    if (!m_pLocalUser)
        return;

    DCWbGraphicPointer* pPointer = m_pLocalUser->GetPointer();

    // This function toggles the presence of the user's remote pointer
    ASSERT(pPointer != NULL);
    if (pPointer->IsActive())
    {
        // Turn off the pointer in the user information
        pPointer->SetInactive();

        // Tell the drawing area of the change
        m_drawingArea.PointerUpdated(pPointer);

        // Set the check mark on the menu item
        UncheckMenuItem(IDM_REMOTE);

        // Pop up the sync button
        m_TB.PopUp(IDM_REMOTE);
    }
    else
    {
        // Calculate a position at which to drop the pointer. The centre of the
        // remote pointer is placed in the centre of the currently visible
        // area of the surface (the centre of the drawing area window).
        RECT rectVisible;
        RECT rectPointer;
        POINT ptCenter;

        m_drawingArea.GetVisibleRect(&rectVisible);
        pPointer->GetBoundsRect(&rectPointer);

        ptCenter.x = (rectVisible.left + rectVisible.right)  / 2;
        ptCenter.x -= ((rectPointer.right - rectPointer.left) / 2);
        ptCenter.y = (rectVisible.top  + rectVisible.bottom) / 2;
        ptCenter.y -= ((rectPointer.bottom - rectPointer.top) / 2);

        // Turn on the pointer in the user information
        pPointer->SetActive(m_hCurrentPage, ptCenter);

        // Tell the drawing area of the change
        m_drawingArea.PointerUpdated(pPointer);

        // Set the synced check mark
        CheckMenuItem(IDM_REMOTE);

        // Pop up the sync button
        m_TB.PushDown(IDM_REMOTE);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSync
//
// Purpose:     Sync or unsync the Whiteboard with other users
//
//
void WbMainWindow::OnSync(void)
{
    // disabled if in presentation mode (another user has lock & sync on)
    if (!WB_PresentationMode())
    {
        if (m_pLocalUser != NULL)
        {
            // Determine whether we are currently synced
            if (m_pLocalUser->IsSynced())
            {
                // currently synced, so unsync
                Unsync();
            }
            else
            {
                // currently unsynced, so sync
                Sync();
            }
        }
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    Sync
//
// Purpose:     Sync the Whiteboard with other users
//
//
void WbMainWindow::Sync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Sync");

    //
    // Dont do anything if the local user is already synced.
    //
    if (!m_pLocalUser || m_pLocalUser->IsSynced())
    {
        TRACE_DEBUG(("User already synced"));
        return;
    }

    //
    // Update the local user's position information, to make sure it's up
    // to date.
    //
    RECT rcVisDraw;
    RECT rcVisUser;

    m_drawingArea.GetVisibleRect(&rcVisDraw);

    m_pLocalUser->SetVisibleRect(&rcVisDraw);

    //
    // We are not currently synced - sync now (if we have the contents
    // lock, or are the first to sync, it will put our sync position).
    //
    m_pLocalUser->Sync();

    //
    // Set the synced check mark and pop up the sync button.
    //
    CheckMenuItem(IDM_SYNC);
    m_TB.PushDown(IDM_SYNC);

    //
    // If the sync position (or zoom state) chosen was not where we are
    // now, move to the current sync position (we are joining a set of
    // synced users).
    //
    m_drawingArea.GetVisibleRect(&rcVisDraw);

    m_pLocalUser->GetVisibleRect(&rcVisUser);

    if ( (m_pLocalUser->Page()        != m_hCurrentPage)               ||
         (!::EqualRect(&rcVisUser, &rcVisDraw)) ||
         (m_pLocalUser->GetZoom()     != m_drawingArea.Zoomed())  )    //CHANGED BY RAND
    {
        TRACE_DEBUG(("Move to new sync pos/state"));
        ::PostMessage(m_hwnd, WM_USER_GOTO_USER_POSITION, 0, (LPARAM)m_pLocalUser->Handle());
    }
} // Sync



//
//
// Function:    Unsync
//
// Purpose:     Unsync the Whiteboard with other users
//
//
void WbMainWindow::Unsync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Unsync");

    //
    // Dont do anythig if we are already unsynced.
    //
    if (!m_pLocalUser || !m_pLocalUser->IsSynced())
    {
        TRACE_DEBUG(("Already unsynced"));
        return;
    }

    //
    // Unsync.
    // Set the synced check mark and pop up the sync button.
    //
    m_pLocalUser->Unsync();
    UncheckMenuItem(IDM_SYNC);
    m_TB.PopUp(IDM_SYNC);

}  // Unsync

//
//
// Function:    SaveLock
//
// Purpose:     Save the current lock type
//
//
void WbMainWindow::SaveLock(void)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SaveLock");

  m_uiSavedLockType = WB_LOCK_TYPE_NONE;

  // If we have the contents lock
  if (WB_GotContentsLock())
  {
    TRACE_MSG(("Saved contents lock"));
    m_uiSavedLockType = WB_LOCK_TYPE_CONTENTS;
  }
  else
  {
    // If we have the page order lock
    if (WB_GotLock())
    {
      TRACE_MSG(("Saved page order lock"));
      m_uiSavedLockType = WB_LOCK_TYPE_PAGE_ORDER;
    }
  }
}

//
//
// Function:    RestoreLock
//
// Purpose:     Restore the current lock type (SaveLock must have been
//              called previously.
//
//
void WbMainWindow::RestoreLock(void)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::RestoreLock");

  switch(m_uiSavedLockType)
  {
    case WB_LOCK_TYPE_CONTENTS:

      // If we do not have the contents lock
      if (!WB_GotContentsLock())
      {
        // Get the contents lock (with invisible dialog)
        TRACE_MSG(("Restoring contents lock"));
        GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE);

      }

      // we really own the lock, clear settled flag so page buttons don't hang
      m_bUnlockStateSettled = TRUE;

    break;


    case WB_LOCK_TYPE_PAGE_ORDER:

      if (!WB_GotLock() || WB_GotContentsLock())
      {
        // Get the page order lock (with invisible dialog)
        TRACE_MSG(("Restoring page order lock"));
        GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);

      }

      //ADDED BY RAND- we really own the lock, clear settled flag
      //                 so page buttons don't hang
      m_bUnlockStateSettled = TRUE;

    break;


    case WB_LOCK_TYPE_NONE:

      // If we have the lock
      if (WB_GotLock())
      {
        // Release the lock
        TRACE_MSG(("Restoring no lock"));

        // Let WBP_EVENT_LOCKED handle m_bUnlockStateSettled flag
        g_pwbCore->WBP_Unlock();
      }

    break;

    default:
      // We have saved an invalid lock type
      ERROR_OUT(("Bad saved lock type"));

      //ADDED BY RAND- somethings broken, clear settled flag
      //                 so page buttons don't hang
      m_bUnlockStateSettled = TRUE;
    break;
  }
}

//
//
// Function:    GetLock
//
// Purpose:     Get the Page Order Lock (synchronously)
//
//
BOOL WbMainWindow::GetLock(UINT uiLockType, UINT uiHide)
{
    BOOL    bGotRequiredLock = FALSE;
    BOOL    bCancelled       = FALSE;
    UINT  uiDialogReturn   = 0;
    UINT  lDialogDelay     = 1;
    UINT  lTimeout         = 0;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetLock");

    switch(uiLockType)
    {
        case WB_LOCK_TYPE_PAGE_ORDER:

            TRACE_DEBUG(("WB_LOCK_TYPE_PAGE_ORDER"));
            if (WB_GotLock())
            {
                TRACE_DEBUG(("Already got it"));
                bGotRequiredLock = TRUE;
                goto RestoreLockCleanup;
            }
            break;

        case WB_LOCK_TYPE_CONTENTS:

            TRACE_DEBUG(("WB_LOCK_TYPE_CONTENTS"));
            if (WB_GotContentsLock())
            {
                TRACE_DEBUG(("Already got it"));
                bGotRequiredLock = TRUE;
                goto RestoreLockCleanup;
            }
            break;

        default:
            ERROR_OUT(("Invalid lock type requested"));
            break;
    }

    if (WB_Locked())
    {
        TRACE_DEBUG(("Contents already locked"));
        goto RestoreLockCleanup;
    }


    // check for any object locks
    BOOL bAnObjectIsLocked;
    WB_PAGE_HANDLE hPage;
    DCWbGraphic* pGraphic;

    bAnObjectIsLocked = FALSE;
    hPage = m_drawingArea.Page();
    if (hPage != WB_PAGE_HANDLE_NULL)
    {
        WB_GRAPHIC_HANDLE hStart;

        pGraphic = PG_First(hPage, &hStart);
        while (pGraphic != NULL)
        {
            // get object lock
            bAnObjectIsLocked = pGraphic->Locked();

            // Release the current graphic
            delete pGraphic;

            // check object lock
            if( bAnObjectIsLocked )
                break;

            // Get the next one
            pGraphic = PG_Next(hPage, &hStart, NULL);
        }
    }

    if( bAnObjectIsLocked )
    {
        Message(NULL, IDS_LOCK, IDS_OBJECTSARELOCKED);
        return( FALSE );
    }

    //
    // If we get this far then we need to get the lock.
    //
    if (uiLockType == WB_LOCK_TYPE_PAGE_ORDER)
    {
        g_pwbCore->WBP_PageOrderLock();
    }
    else
    {
        g_pwbCore->WBP_ContentsLock();
    }

    //
    // Bring up a dialog to wait for the response.  This dialog is
    // cancelled by the event handler code when the lock response event is
    // received.
    //
    ASSERT(m_hwndWaitForLockDlg == NULL);

    TMDLG   tmdlg;

    ZeroMemory(&tmdlg, sizeof(tmdlg));
    tmdlg.bLockNotEvent = TRUE;
    tmdlg.uiMaxDisplay = MAIN_LOCK_TIMEOUT;

    if (uiHide == SW_SHOW)
    {
        tmdlg.bVisible = TRUE;

        uiDialogReturn = (UINT)::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(LOCKDIALOG),
            m_hwnd, TimedDlgProc, (LPARAM)&tmdlg);
    }
    else
    {
        tmdlg.bVisible = FALSE;

        uiDialogReturn = (UINT)::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(INVISIBLEDIALOG),
            m_hwnd, TimedDlgProc, (LPARAM)&tmdlg);
    }

    ASSERT(m_hwndWaitForLockDlg == NULL);

    if (uiDialogReturn == IDCANCEL)
    {
        // The user cancelled the lock request or it timed out
        TRACE_MSG(("User cancelled lock request"));
        bCancelled = TRUE;
        //
        // If we havent already got the lock then unlock here.
        //
        if (!WB_GotLock())
        {
            TRACE_DEBUG(("Havent got lock confirmation yet - cancel it"));
            g_pwbCore->WBP_Unlock();
        }

        goto RestoreLockCleanup;
    }

    switch(uiLockType)
    {
        case WB_LOCK_TYPE_PAGE_ORDER:

            if (WB_GotLock())
            {
                bGotRequiredLock = TRUE;
            }
            break;

        case WB_LOCK_TYPE_CONTENTS:

            if (WB_GotContentsLock())
            {
                bGotRequiredLock = TRUE;
            }
            break;

        default:
            // can't get here - trapped at top.
            ERROR_OUT(("Invalid lock type - internal error"));
        break;
    }

RestoreLockCleanup:

    if (!bGotRequiredLock)
    {
        if( !bCancelled )
        {
            // post error only if user didn't cancel (bug NM4db:429)
            TRACE_MSG(("Failed to get the lock"));
            // post an error message indicating the failure to get the lock
            ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_LOCKED);
        }
    }

    return(bGotRequiredLock);
}

//
//
// Function:    OnLock
//
// Purpose:     Lock or unlock the Whiteboard
//
//
void WbMainWindow::OnLock(void)
{
    // If we have the lock, this is an unlock request
    if (WB_GotContentsLock())
    {
        // if currently loading or doing a new, then restore page order lock
        if (!IsIdle())
        {
            GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
        }
        else
        {
            // Release the lock
            g_pwbCore->WBP_Unlock();
        }

        // Set the locked check mark
        UncheckMenuItem(IDM_LOCK);

        // Pop up the lock button
        m_TB.PopUp(IDM_LOCK);
    }
    else
    {
        // If another user has the lock.
        // We should not usually get here if another user has the lock because
        // the Lock menu entry (and button) will be grayed.
        if (WB_ContentsLocked())
        {
            // Display a message
            Message(NULL, IDS_LOCK, IDS_LOCK_ERROR);
        }
        else
        {
            // Save the current lock state (in case the user cancels the request)
            SaveLock();

            // Catch exceptions raised during the lock request
        // Request the lock
        BOOL bGotLock = GetLock(WB_LOCK_TYPE_CONTENTS, SW_SHOW);
        if (!bGotLock)
        {
          RestoreLock();
        }
        else
        {
          // Turn sync on and write our sync position
          Sync();
          m_pLocalUser->PutSyncPosition();
        }
      }
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function : OnWBPLoadComplete
//
// Purpose  : Finished loading a file
//
//
void WbMainWindow::OnWBPLoadComplete(void)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPLoadComplete");
  if (m_uiSubState == SUBSTATE_LOADING)
  {
    TRACE_MSG(("Load has completed OK"));
    SetSubstate(SUBSTATE_IDLE);
    if (WB_GotLock())
    {
    }
    ReleasePageOrderLock();
  }
  else
  {
    TRACE_MSG(("Unexpected WBP_EVENT_LOAD_COMPLETE event ignored"));
  }
}

//
//
// Function : OnWBPLoadFailed
//
// Purpose  : Finished loading a file
//
//
void WbMainWindow::OnWBPLoadFailed(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPLoadFailed");

    if (m_uiSubState == SUBSTATE_LOADING)
    {
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BAD_FILE_FORMAT);

        TRACE_MSG(("Load has failed - tell the user about it..."));
        SetSubstate(SUBSTATE_IDLE);
        ReleasePageOrderLock();
    }
    else
    {
        TRACE_MSG(("Unexpected WBP_EVENT_LOAD_FAILED event ignored"));
    }
}

//
//
// Function:    GetWindowTitle
//
// Purpose:     Return a string for the window title
//
//
TCHAR * WbMainWindow::GetWindowTitle()
{

	// Calculate the size we will need
	int strSize=0;
    if( m_pLockOwner != NULL )
    {
        strSize = lstrlen(m_pLockOwner->Name());
    }

	// This is the worst scenario, the total size would be less than 2*_MAX_FNAME
	// but we give a lot of space for localization.
	int totalSize = 2*(_MAX_FNAME)
					+ strSize + 1
					+3*(_MAX_FNAME);	// account for the following strings, the total is probably < 200
										// IDS_UNTITLED
										// IDS_TITLE_SEPARATOR
										// IDS_DEFAULT
										// IDS_IN_CALL
										// IDS_IN_CALL_OTHERS
										// IDS_JOINING
										// IDS_INITIALIZING
										// IDS_NOT_IN_CALL
										// IDS_LOCKEDTITLE


	TCHAR *pTitle = new TCHAR[totalSize];
    if (!pTitle)
    {
        ERROR_OUT(("GetWindowTitle: failed to allocate TCHAR array"));
        return(NULL);
    }
	TCHAR inUseBy[_MAX_PATH];

    TCHAR *pStartTitle = pTitle;

    // Set title to either the "Untitled" string, or the loaded file name
    if( (!lstrlen(m_strFileName))||
        (GetFileTitle( m_strFileName, pTitle, 2*_MAX_FNAME ) != 0) )
    {
        strSize = ::LoadString(g_hInstance, IDS_UNTITLED, pTitle, totalSize );
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
		totalSize -=strSize;
    }
    else
    {
		strSize = lstrlen(pTitle);
	    pTitle +=strSize;;
		ASSERT(totalSize>strSize);
	    totalSize -=strSize;
    }

    // Get the separator from resources
    strSize = ::LoadString(g_hInstance, IDS_TITLE_SEPARATOR, pTitle, totalSize);
    pTitle+=strSize;;
	ASSERT(totalSize>strSize);
    totalSize -=strSize;

    // Get the application title from options
    strSize = ::LoadString(g_hInstance, IDS_DEFAULT, pTitle, totalSize );
    pTitle+=strSize;
	ASSERT(totalSize>strSize);
    totalSize -=strSize;

    // Add either "In Call" or "Not in Call", or "Initialising" or
    // "Joining a call"
    strSize = ::LoadString(g_hInstance, IDS_TITLE_SEPARATOR, pTitle, totalSize);
    pTitle+=strSize;
	ASSERT(totalSize>strSize);
    totalSize -=strSize;

    if ((m_uiState == IN_CALL) && m_bCallActive)
    {
        UINT        count;

        count = g_pwbCore->WBP_PersonCountInCall();

		strSize = ::LoadString(g_hInstance, IDS_IN_CALL, inUseBy, totalSize);

		strSize=wsprintf(pTitle, inUseBy, (count-1));
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
		totalSize -=strSize;

    }
    else  if ((m_uiState == JOINING) ||
        ((m_uiState == JOINED) && !m_bCallActive) ||
        ((m_uiState == IN_CALL) && (m_dwDomain != OM_NO_CALL) && !m_bCallActive))
    {
		strSize = ::LoadString(g_hInstance, IDS_JOINING, pTitle, totalSize );
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
		totalSize -=strSize;
    }
    else if (m_uiState == STARTING)
    {
        strSize = ::LoadString(g_hInstance, IDS_INITIALIZING, pTitle, totalSize);
    	pTitle+=strSize;
		ASSERT(totalSize>strSize);
    	totalSize -=strSize;
    }
    else
    {
		strSize = ::LoadString(g_hInstance, IDS_NOT_IN_CALL, pTitle, totalSize);
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
    	totalSize -=strSize;
    }
	

    // add lock info
    if( m_pLockOwner != NULL )
    {
	    strSize = ::LoadString(g_hInstance, IDS_LOCKEDTITLE, pTitle, totalSize);
        ASSERT(totalSize>strSize);
		pTitle+=strSize;
        lstrcpy(pTitle, m_pLockOwner->Name());
    }

    // Return the complete title string
    return pStartTitle;
}





LRESULT WbMainWindow::OnConfShutdown( WPARAM, LPARAM )
{
    if (OnQueryEndSession())
    {
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0); // do close immediately
        //    :
        // DON'T DO ANYTHING else at this point except for exit.
        return( 0 );// tell conf ok to shutdown
    }
    else
        return( (LRESULT)g_cuEndSessionAbort ); // don't shutdown
}


//
//
// Function:    OnQueryEndSession
//
// Purpose:     Ensure user is prompted to save changes when windows is
//              ended.
//
//
LRESULT WbMainWindow::OnQueryEndSession(void)
{
    HWND hwndPopup;

    if ((hwndPopup = ::GetLastActivePopup(m_hwnd)) != m_hwnd)
    {
        Message(NULL,  IDS_DEFAULT, IDS_CANTCLOSE );
        ::BringWindowToTop(hwndPopup);
        return( FALSE );
    }

    // If changes are required then prompt the user to save
    int iDoNew = IDOK;

    if (IsIdle())
    {
        iDoNew = QuerySaveRequired(TRUE);
        if (iDoNew == IDYES)
        {
            // Save the changes
            iDoNew = OnSave(FALSE);
        }
    }

    // remember what we did so OnClose can act appropriately
    m_bQuerySysShutdown = (iDoNew != IDCANCEL);

    // If the user did not cancel, let windows exit
    return( m_bQuerySysShutdown );
}


//
//
// Function:    Recover
//
// Purpose:     Ensure the whiteboard is not left partly registered.
//
//
//
void WbMainWindow::Recover()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Recover");

    // If the error occurred during start-up, then quit immediately
    if (m_uiState == STARTING)
    {
        TRACE_MSG(("error during startup - exiting"));
        ::PostMessage(m_hwnd, WM_CLOSE, FALSE, 0L);
    }
    else
    {
        // ensure the drawing area is locked while we are in a bad state
        LockDrawingArea();

        // disable remote pointer while we are handling this join failure (bug 4767)
        m_TB.Disable(IDM_REMOTE);

        // set state to starting - ensures we don't get in an infinite loop,
        // because if an error occurs then we will quit if we try to recover
        m_uiState = STARTING;
        TRACE_MSG(("Attempting to recover after join call failure - state set to STARTING"));

        // state changed: update page buttons
        UpdatePageButtons();

        // see if there is a call active
        CM_STATUS cmStatus;

        // if there's a call available, try to join it
        if (!CMS_GetStatus(&cmStatus))
            cmStatus.callID = OM_NO_CALL;

        ::PostMessage(m_hwnd, WM_USER_JOIN_CALL, FALSE, (LONG)cmStatus.callID);
    }
}

//
//
// Function:    UnlockDrawingArea
//
// Purpose:     Unlock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::UnlockDrawingArea()
{
    m_drawingArea.Unlock();

    // Enable tool-bar buttons that can now be used
    if (WB_Locked() || !IsIdle())
    {
        EnableToolbar( FALSE );
    }
    else
    {
        EnableToolbar( TRUE );
    }

    //
    // Show the tool attributes group.
    //
    m_AG.DisplayTool(m_pCurrentTool);
}



//
//
// Function:    LockDrawingArea
//
// Purpose:     Lock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::LockDrawingArea()
{
    m_drawingArea.Lock();

    // Disable tool-bar buttons that cannot be used while locked
    if (WB_Locked() || !IsIdle())
    {
        EnableToolbar( FALSE );
    }
    else
    {
        EnableToolbar( TRUE );
    }

    //
    // Hide the tool attributes
    //
    if (m_WG.m_hwnd != NULL)
    {
        ::ShowWindow(m_WG.m_hwnd, SW_HIDE);
    }
    m_AG.Hide();
}


void WbMainWindow::EnableToolbar( BOOL bEnable )
{
    if (bEnable)
    {
        m_TB.Enable(IDM_SELECT);

        // don't allow text editing in zoom mode
        if( m_drawingArea.Zoomed() )
            m_TB.Disable(IDM_TEXT);
        else
            m_TB.Enable(IDM_TEXT);

        m_TB.Enable(IDM_PEN);
        m_TB.Enable(IDM_HIGHLIGHT);

        m_TB.Enable(IDM_LINE);
        m_TB.Enable(IDM_ZOOM);
        m_TB.Enable(IDM_BOX);
        m_TB.Enable(IDM_FILLED_BOX);
        m_TB.Enable(IDM_ELLIPSE);
        m_TB.Enable(IDM_FILLED_ELLIPSE);
        m_TB.Enable(IDM_ERASER);

        m_TB.Enable(IDM_GRAB_AREA);
        m_TB.Enable(IDM_GRAB_WINDOW);
        m_TB.Enable(IDM_LOCK);
        m_TB.Enable(IDM_SYNC);

        // enable remote pointer incase it was disabled handling
        // join failures (bug 4767)
        m_TB.Enable(IDM_REMOTE);
    }
    else
    {
        m_TB.Disable(IDM_SELECT);
        m_TB.Disable(IDM_PEN);
        m_TB.Disable(IDM_HIGHLIGHT);
        m_TB.Disable(IDM_TEXT);
        m_TB.Disable(IDM_LINE);
        m_TB.Disable(IDM_ZOOM);
        m_TB.Disable(IDM_BOX);
        m_TB.Disable(IDM_FILLED_BOX);
        m_TB.Disable(IDM_ELLIPSE);
        m_TB.Disable(IDM_FILLED_ELLIPSE);
        m_TB.Disable(IDM_ERASER);

        m_TB.Disable(IDM_GRAB_AREA);
        m_TB.Disable(IDM_GRAB_WINDOW);
        m_TB.Disable(IDM_LOCK);
        m_TB.Disable(IDM_SYNC);
    }
}




//
//
// Function:    UpdatePageButtons
//
// Purpose:     Enable or disable the page buttons, according to the current
//              state.
//
//
//
void WbMainWindow::UpdatePageButtons()
{
    // Disable page buttons if not in a call, or doing a new, or another user
    // has the lock and is synced.
    if ( (m_uiState != IN_CALL) ||
       (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS) ||
       (WB_PresentationMode()))
    {
        m_AG.EnablePageCtrls(FALSE);

        // when the page buttons are disabled, we do not allow the page sorter
        // dialog to be displayed
        if (m_hwndPageSortDlg != NULL)
        {
            ::SendMessage(m_hwndPageSortDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED),
                0);
            ASSERT(m_hwndPageSortDlg == NULL);
        }
    }
    else
    {
        m_AG.EnablePageCtrls(TRUE);
    }

    if (WB_Locked() || !IsIdle() )
    {
        EnableToolbar( FALSE );
    }
    else
    {
        EnableToolbar( TRUE );
    }


    //
    // If the page sorter is up, inform it of the state change
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_ENABLEPAGEOPS,
            (m_uiSubState == SUBSTATE_IDLE), 0);
    }

    //
    // Enable the insert-page button if the page order's not locked
    //
    m_AG.EnableInsert( ((m_uiState == IN_CALL) &&
      (m_uiSubState == SUBSTATE_IDLE) &&
      (g_pwbCore->WBP_ContentsCountPages() < WB_MAX_PAGES) &&
      (!WB_Locked())));

    //
    // Ensure the currently active menu (if any) is correctly enabled
    //
    InvalidateActiveMenu();
}

//
//
//  Function:  InvalidateActiveMenu
//
//  Purpose:   If a menu is currently active, gray items according to
//             the current state, and force it to redraw.
//
//
void WbMainWindow::InvalidateActiveMenu()
{
  if (m_hInitMenu != NULL)
  {
      // A menu is displayed, so set the state appropriately and force a
      // repaint to show the new state
      SetMenuStates(m_hInitMenu);

      ::RedrawWindow(::GetTopWindow(::GetDesktopWindow()),
                     NULL, NULL,
                     RDW_FRAME | RDW_INVALIDATE | RDW_ERASE |
                                   RDW_ERASENOW | RDW_ALLCHILDREN);
  }
}

//
//
// Function:    CancelLoad
//
// Purpose:     Cancel any load in progress
//
//
void WbMainWindow::CancelLoad(BOOL bReleaseLock)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CancelLoad");

    // Cancel the load
    g_pwbCore->WBP_CancelLoad();

    // reset file name to untitled
    ZeroMemory(m_strFileName, sizeof(m_strFileName));

	UpdateWindowTitle();

    // reset the whiteboard substate
    SetSubstate(SUBSTATE_IDLE);

    if (bReleaseLock)
    {
        ReleasePageOrderLock();
    }
}

//
//
// Function:    ReleasePageOrderLock
//
// Purpose:     Releases the page order lock, unless the user has got the
//              contents locked, in which case it has no effect. Called
//              after asynchronous functions requiring the page order lock
//              (file/new, file/open) have completed.
//
//
void WbMainWindow::ReleasePageOrderLock()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ReleasePageOrderLock");

    //
    // Only release the page order lock if:
    //     - the contents are not also locked (if they are then releasing
    //       the page order lock has no effect).
    //     - we actually have the page order locked in the first place.
    //
    if ( (!WB_GotContentsLock()) &&
         (WB_GotLock())   )
    {
        g_pwbCore->WBP_Unlock();
    }
}

//
//
// Function:    IsIdle
//
// Purpose:     Returns true if the main window is idle (in a call and not
//              loading a file/performing a new)
//
//
BOOL WbMainWindow::IsIdle()
{

    return((m_uiState == IN_CALL) && (m_uiSubState == SUBSTATE_IDLE));
}

//
//
// Function:    SetSubstate
//
// Purpose:     Sets the substate, informing the page sorter dialog of the
//              change, if necessary.
//
//
void WbMainWindow::SetSubstate(UINT newSubState)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetSubstate");

  // substate only valid if in a call
  if (   (m_uiState != IN_CALL)
      || (newSubState != m_uiSubState))
  {
    m_uiSubState = newSubState;

    // Trace the substate change
    switch (m_uiSubState)
    {
      case SUBSTATE_IDLE:
        TRACE_DEBUG(("set substate to IDLE"));
        break;

      case SUBSTATE_LOADING:
        TRACE_DEBUG(("set substate to LOADING"));
        break;

      case SUBSTATE_NEW_IN_PROGRESS:
        TRACE_DEBUG(("set substate to NEW_IN_PROGRESS"));
        break;

      default:
        ERROR_OUT(("Unknown substate %hd",m_uiSubState));
        break;
    }

    // update the page buttons (may have become enabled/disabled)
    UpdatePageButtons();
  }

}

//
//
// Function:    PositionUpdated
//
// Purpose:     Called when the drawing area position has changed.
//              change, if necessary.
//
//
void WbMainWindow::PositionUpdated()
{
    RECT rectDraw;

    m_drawingArea.GetVisibleRect(&rectDraw);

    if (m_pLocalUser != NULL)
    {
        // Set the new position from the drawing area
        m_pLocalUser->SetVisibleRect(&rectDraw);

        // Show that an update of the sync position is pending
        m_bSyncUpdateNeeded = TRUE;
    }

    // If the current page is a valid one then store the user's position on
    // that page.
    if (m_hCurrentPage != WB_PAGE_HANDLE_NULL)
    {
        // Store position of this page
        WORD   pageIndex = (WORD)m_hCurrentPage;


	    PAGE_POSITION *mapob;
	    POSITION position = m_pageToPosition.GetHeadPosition();
		BOOL bFound = FALSE;
		while (position && !bFound)
		{
			mapob = (PAGE_POSITION *)m_pageToPosition.GetNext(position);
			if ( mapob->hPage == pageIndex)
			{
				bFound = TRUE;
			}
		}

        // If we're replacing an existing entry, then free the old entry.
        if (bFound)
        {
			mapob->position.x = rectDraw.left;
			mapob->position.y = rectDraw.top;
        }
        else
        {
			mapob = new PAGE_POSITION;

            if (!mapob)
            {
                ERROR_OUT(("PositionUpdated failing; couldn't allocate PAGE_POSITION object"));
            }
            else
            {
    			mapob->hPage = pageIndex;
	    		mapob->position.x = rectDraw.left;
		    	mapob->position.y = rectDraw.top;
			    m_pageToPosition.AddTail(mapob);
            }
        }
    }
}

//
//
// Function : OnALSLoadResult
//
// Purpose  : Deal with an ALS_LOAD_RESULT event
//
//
void WbMainWindow::OnALSLoadResult(UINT reason)
{

    int             errorMsg = 0;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnALSLoadResult");

    switch (reason)
    {
        case AL_LOAD_FAIL_NO_FP:
            WARNING_OUT(("Remote WB load failed - no FP"));
            errorMsg = IDS_MSG_LOAD_FAIL_NO_FP;
            break;

        case AL_LOAD_FAIL_NO_EXE:
            WARNING_OUT(("Remote WB load failed - no exe"));
            errorMsg = IDS_MSG_LOAD_FAIL_NO_EXE;
            break;

        case AL_LOAD_FAIL_BAD_EXE:
            WARNING_OUT(("Remote WB load failed - bad exe"));
            errorMsg = IDS_MSG_LOAD_FAIL_BAD_EXE;
            break;

        case AL_LOAD_FAIL_LOW_MEM:
            WARNING_OUT(("Remote WB load failed - low mem"));
            errorMsg = IDS_MSG_LOAD_FAIL_LOW_MEM;
            break;

        default:
            WARNING_OUT(("Bad ALSLoadResult reason %d", reason));
            break;
    }


    if (errorMsg)
    {
        //
        // Put up an error message
        //
        Message(NULL, IDS_MSG_CAPTION, errorMsg);
    }
}

//
//
// Function : OnEndSession
//
// Purpose  : Called when Windows is exiting
//
//
void WbMainWindow::OnEndSession(BOOL bEnding)
{
    if (bEnding)
    {
        ::PostQuitMessage(0);
    }
    else
    {
        m_bQuerySysShutdown = FALSE; // never mind, cancel OnClose special handling
    }
}


//
// Function: OnCancelMode()
//
// Purpose:  Called whenever a WM_CANCELMODE message is sent to the frame
//           window.
//           WM_CANCELMODE is sent when another app or dialog receives the
//           input focus.  The frame simply records that a WM_CANCELMODE
//           message has been sent.  This fact is used by the SelectWindow
//           code to determine if it should cancel the selecting of a
//           window
//
//
void WbMainWindow::OnCancelMode()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCancelMode");

    m_cancelModeSent = TRUE;

    //
    // Note: Not passed to the default handler as the default action on
    //       WM_CANCELMODE is to release mouse capture - we shall do this
    //       explicitly.
    //


    // blow off any dragging that might be in progress (bug 573)
    POINT   pt;
    ::GetCursorPos( &pt );
    ::ScreenToClient(m_drawingArea.m_hwnd, &pt);
    ::SendMessage(m_drawingArea.m_hwnd, WM_LBUTTONUP, 0, MAKELONG( pt.x, pt.y ) );

}



void WbMainWindow::LoadCmdLine(LPCSTR szFilename)
{
    int iOnSave;

    if (szFilename && *szFilename)
    {
        if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
            return;

        // Don't prompt to save file if we're already loading
        if (m_uiSubState != SUBSTATE_LOADING )
        {
            // Check whether there are changes to be saved
            iOnSave = QuerySaveRequired(TRUE);
        }
        else
        {
            return;
        }

        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            int iResult = OnSave(TRUE);

            if( iResult == IDOK )
            {
				UpdateWindowTitle();
            }
            else
            {
                // cancelled out of save, so cancel the open operation
                return;
            }
        }

        // load filename
        if( iOnSave != IDCANCEL )
            LoadFile(szFilename);
    }
}



//
// OnNotify()
// Handles TTN_NEEDTEXTA and TTN_NEEDTEXTW
//
void WbMainWindow::OnNotify(UINT id, NMHDR * pNM)
{
    UINT    nID;
    HWND    hwnd = NULL;
    POINT ptCurPos;
    UINT  nTipStringID;

    if (!pNM)
        return;

    if (pNM->code == TTN_NEEDTEXTA)
    {
        TOOLTIPTEXTA *pTA = (TOOLTIPTEXTA *)pNM;

        // get id and hwnd
        if( pTA->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID);
        if (nTipStringID == 0)
            return;

        // give it to em
        pTA->lpszText = MAKEINTRESOURCE( nTipStringID );
        pTA->hinst = g_hInstance;
    }
    else if (pNM->code == TTN_NEEDTEXTW)
    {
        TOOLTIPTEXTW *pTW = (TOOLTIPTEXTW *)pNM;

        // get id and hwnd
        if( pTW->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID );
        if (nTipStringID == 0)
            return;

        // give it to em
        pTW->lpszText = (LPWSTR) MAKEINTRESOURCE( nTipStringID );
        pTW->hinst = g_hInstance;
    }
}




//
// GetTipId()
// Finds the tooltip for a control in Whiteboard
//
UINT WbMainWindow::GetTipId(HWND hwndTip, UINT nID)
{
    WbTool *  pTool;
    BOOL      bCheckedState;
    int       nTipID;
    int       nTipStringID;
    int       i;

    // find tip stuff relevant for nID
    nTipID = -1;
    for( i=0; i<((sizeof g_tipIDsArray)/(sizeof (TIPIDS) )); i++ )
    {
        if( g_tipIDsArray[i].nID == nID )
        {
            nTipID = i;
            break;
        }
    }

    // valid?
    if( nTipID < 0 )
        return( 0 );

    // get checked state
    switch( g_tipIDsArray[ nTipID ].nCheck )
    {
        case TB:
            bCheckedState =
                (::SendMessage(m_TB.m_hwnd, TB_ISBUTTONCHECKED, nID, 0) != 0);
            break;

        case BT:
            if (hwndTip != NULL)
            {
                bCheckedState =
                    (::SendMessage(hwndTip, BM_GETSTATE, 0, 0) & 0x0003) == 1;
            }
            else
                bCheckedState = FALSE;

            break;

        case NA:
        default:
            bCheckedState = FALSE;
            break;
    }

    // get tip string id
    if( bCheckedState )
        nTipStringID = g_tipIDsArray[ nTipID ].nDownTipID;
    else
        nTipStringID = g_tipIDsArray[ nTipID ].nUpTipID;

    // done
    return( nTipStringID );
}



// gets default path if no saves or opens have been done yet
// Returns FALSE if last default should be reused
BOOL WbMainWindow::GetDefaultPath(LPTSTR csDefaultPath , UINT size)
{
    DWORD dwType;
    DWORD dwBufLen = size;
    HKEY  hDefaultKey = NULL;

    if( !lstrlen(m_strFileName) )
    {
        // a name has not been picked yet in this session, use path
        // to "My Documents"
        if( (RegOpenKeyEx( HKEY_CURRENT_USER,
							"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
							0,
							KEY_READ,
							&hDefaultKey )
							!= ERROR_SUCCESS) ||
							(RegQueryValueEx( hDefaultKey,
                             "Personal",
                             NULL,
                             &dwType,
                             (BYTE *)csDefaultPath,
                             &dwBufLen )
							!= ERROR_SUCCESS))
		{
            // reg failed, use desktop
            GetWindowsDirectory( csDefaultPath, 2*_MAX_PATH );
            lstrcpy(csDefaultPath,"\\Desktop");
        }

        if( hDefaultKey != NULL )
            RegCloseKey( hDefaultKey );

        return( TRUE );
    }
    else
    {
        return( FALSE );
    }
}





void WbMainWindow::OnSysColorChange( void )
{
    if (m_drawingArea.Page() != WB_PAGE_HANDLE_NULL)
    {
        PG_ReinitPalettes();

        ::InvalidateRect(m_hwnd, NULL, TRUE );
        ::UpdateWindow(m_hwnd);
    }

    m_TB.RecolorButtonImages();
    m_AG.RecolorButtonImages();
}



//
// posts a do-you-wana-do-that message if other users are in the conference
//
BOOL WbMainWindow::UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd )
{
    if ( (m_uiState == IN_CALL) && m_bCallActive )
    {
        UINT    count;

        count = g_pwbCore->WBP_PersonCountInCall();

        if (count > 1)
        {
            if( pbWasPosted != NULL )
                *pbWasPosted = TRUE;

            return( ::Message(hwnd,  IDS_DEFAULT, IDS_MSG_USERSMIGHTLOSE, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES );
        }
    }

    if( pbWasPosted != NULL )
        *pbWasPosted = FALSE;

    return( FALSE );
}



BOOL WbMainWindow::HasGraphicChanged( PWB_GRAPHIC pOldHeaderCopy, const PWB_GRAPHIC pNewHeader )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::HasGraphicChanged");


    // If nothing is different but the lock state and some misc in a WBP_EVENT_GRAPHIC_UPDATE_IND then
    // the graphics are visually the same.
    //
    // NOTE: This does not check ZORDER. ZORDER changes are handled by WBP_EVENT_GRAPHIC_MOVED

    // if objects aren't the same length, they are different
    if( pOldHeaderCopy->length != pNewHeader->length )
        return( TRUE );

    // temporarialy set pOldHeaderCopy's locked state + misc to same as pNewHeader so we can do an
    // object compare.
    UINT uOldLocked = pOldHeaderCopy->locked;
    pOldHeaderCopy->locked = pNewHeader->locked;

    OM_OBJECT_ID oldlockPersonID = pOldHeaderCopy->lockPersonID;
    pOldHeaderCopy->lockPersonID = pNewHeader->lockPersonID;

    UINT  oldloadedFromFile = pOldHeaderCopy->loadedFromFile;
    pOldHeaderCopy->loadedFromFile = pNewHeader->loadedFromFile;

    NET_UID   oldloadingClientID = pOldHeaderCopy->loadingClientID;
    pOldHeaderCopy->loadingClientID = pNewHeader->loadingClientID;

    // compare objects
    BOOL bChanged = FALSE;
    if( memcmp( pOldHeaderCopy, pNewHeader, pOldHeaderCopy->length ) != 0 )
        bChanged = TRUE;


    // restore lock state + misc
    pOldHeaderCopy->locked = (TSHR_UINT8)uOldLocked;
    pOldHeaderCopy->lockPersonID = oldlockPersonID;
    pOldHeaderCopy->loadedFromFile = (TSHR_UINT16)oldloadedFromFile;
    pOldHeaderCopy->loadingClientID = oldloadingClientID;

    return( bChanged );
}



void WbMainWindow::UpdateWindowTitle(void)
{
    TCHAR *pTitle = GetWindowTitle();
    if (pTitle != NULL)
    {
        ::SetWindowText(m_hwnd, pTitle);
        delete pTitle;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\page.hpp ===
//
// PAGE.HPP
// Page Class
//
// Copyright Microsoft 1998-
//
#ifndef __PAGE_HPP_
#define __PAGE_HPP_



//
// Purpose: Handler for page of graphic objects
//

class DCWbGraphic;
class DCWbGraphicPointer;

//
// Retrieving object data
//
PWB_GRAPHIC PG_GetData(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);

//
// Allocating space for new objects
//
PWB_GRAPHIC PG_AllocateGraphic(WB_PAGE_HANDLE hPage, DWORD length);

DCWbGraphic* PG_First(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE * phGraphic, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);
DCWbGraphic* PG_Next(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE * phGraphic, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);

DCWbGraphic* PG_After(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic);
DCWbGraphic* PG_Before(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic);

//
// Retrieving remote pointer objects
//
DCWbGraphicPointer* PG_FirstPointer(WB_PAGE_HANDLE hPage, POM_OBJECT * ppUserNext);
DCWbGraphicPointer* PG_NextPointer(WB_PAGE_HANDLE hPage, POM_OBJECT * ppUserNext);
DCWbGraphicPointer* PG_NextPointer(WB_PAGE_HANDLE hPage, const DCWbGraphicPointer* pPointer);
DCWbGraphicPointer* PG_LocalPointer(WB_PAGE_HANDLE);

//
// Deleting all objects
//
void PG_Clear(WB_PAGE_HANDLE hPage);


//
// Selecting objects
//
DCWbGraphic* PG_SelectLast(WB_PAGE_HANDLE hPage, POINT pt);
DCWbGraphic* PG_SelectPrevious(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic,
                POINT pt);

//
// Return TRUE if the specified object is topmost in the page
//
BOOL PG_IsTopmost(WB_PAGE_HANDLE hPage, const DCWbGraphic* pGraphic);

//
// Update an existing object
//
void PG_GraphicUpdate(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE *phGraphic,
   PWB_GRAPHIC pHeader);
void PG_GraphicReplace(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE *phGraphic,
    PWB_GRAPHIC pHeader);
void PG_GraphicDelete(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic);

//
// Return the bounding rectangle of all the graphics on the page
//
void PG_GetAreaInUse(WB_PAGE_HANDLE hPage, LPRECT lprcArea);

//
// Draw the entire contents of the page into the device context
// specified.
//
void PG_Draw(WB_PAGE_HANDLE hPage, HDC hdc, BOOL thumbNail = FALSE);

//
// Print an area of the page to the specified DC
//
void PG_Print(WB_PAGE_HANDLE hPage, HDC hdcPrinter, LPCRECT lprcArea);

//
// Return the palette to be used for displaying the page
//
HPALETTE    PG_GetPalette(void);
void        PG_InitializePalettes(void);
void        PG_ReinitPalettes(void);

//
// Return the intersection of the given graphic's bounding rectangle
// and any objects which are obscuring it
//
void    PG_GetObscuringRect(WB_PAGE_HANDLE hPage, DCWbGraphic* pGraphic, LPRECT lprcObscuring);


WB_GRAPHIC_HANDLE PG_ZGreaterGraphic(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hLastGraphic, 
										WB_GRAPHIC_HANDLE hTestGraphic );

//
// Search for the next active pointer on this page
//
DCWbGraphicPointer* PG_LookForPointer(WB_PAGE_HANDLE hPage, POM_OBJECT hUser);


//
// Retrieving pages
//
WB_PAGE_HANDLE PG_GetNextPage(WB_PAGE_HANDLE hPage);
WB_PAGE_HANDLE PG_GetPreviousPage(WB_PAGE_HANDLE hPage);

//
// Getting the index of a page
//
WB_PAGE_HANDLE PG_GetPageNumber(UINT uiPageNo);



#endif // __PAGE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\mwnd.hpp ===
//
// MWND.HPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

#ifndef __MWND_HPP_
#define __MWND_HPP_



#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

//
// The progress timer meter is kinda the heart beat of this thing
//
#define MAIN_PROGRESS_TIMER         1000


// Milliseconds
#define MAIN_DIALOG_DELAY           1500
#define MAIN_REGISTRATION_TIMEOUT   300000   // These are long, for modems
#define MAIN_LOCK_TIMEOUT           120000

//
// Timer IDs
//
#define TIMERID_PROGRESS_METER      4
#define TIMERID_MAXDISPLAY          10


//
// Timed dialog information
//
typedef struct tagTMDLG
{
    BOOL    bLockNotEvent;
    BOOL    bVisible;
    UINT    uiMaxDisplay;
}
TMDLG;


//				  This constant must only be defined in FAR EAST sdk
//				  since it is not in US version. In Sook Choi (Korea) says
//				  it is 40h so thats what I will use. Bug 3258.
#ifndef	CLIP_DFA_OVERRIDE
#define CLIP_DFA_OVERRIDE (0x40)
#endif


// Constants for width menu commands (bug 433)
#define MENUPOS_OPTIONS   4
#define OPTIONSPOS_WIDTH  2



//
// Main state
//  STARTING      = Whiteboard just started, not ready for user input.
//                  In this state until registration dialog is cleared.
//  IN_CALL       = Whiteboard ready for input
//  ERROR_STATE   = a serious error has occurred, Whiteboard must be closed
//  JOINING       = joining a call (join call dialog is up)
//  JOINED        = Received join call indication, waiting for 'join call'
//                  dialog to be dismissed.
//  CLOSING       = Whiteboard is shutting down. Ignore all messages.
//
//
enum
{
    STARTING    = 0,
    IN_CALL,
    ERROR_STATE,
    JOINING,
    JOINED,
    CLOSING
};


//
// Substate - valid only when in call
//  IDLE            = Normal state - user can do anything permitted by
//                    current lock status.
//  LOADING         = Currently loading a file
//  NEW_IN_PROGRESS = Currently deleting contents
//
//
#define SUBSTATE_IDLE             0
#define SUBSTATE_LOADING          1
#define SUBSTATE_NEW_IN_PROGRESS  2

//
// Capture options
//
#define CAPTURE_TO_SAME   0
#define CAPTURE_TO_NEW    1

//
// Border to be left around the checkmark in the color and width menus and
// width of items in these menus.
//
#define CHECKMARK_BORDER_X 3
#define CHECKMARK_BORDER_Y 5
#define COLOR_MENU_WIDTH   40


typedef struct tagWBFINDDIALOG
{
    HWND    hwndDialog;
    HWND    hwndOwner;
} WBFINDDIALOG;



#define MAX_FONT_SIZE       20
#define STATUSBAR_HEIGHT    (MAX_FONT_SIZE + 2*::GetSystemMetrics(SM_CYEDGE))

//
//
// Class:   WbMainWindow
//
// Purpose: Main Whiteboard window
//
//
class WbMainWindow
{

    //
    // Event handler friend used for redirecting events to specific main
    // window objects.
    //
    friend BOOL CALLBACK WbMainWindowEventHandler(LPVOID utHandle,
                                                  UINT  event,
                                                  UINT_PTR param1,
                                                  UINT_PTR param2);
    friend LRESULT CALLBACK WbMainWindowProc(HWND, UINT, WPARAM, LPARAM);

    friend BOOL CALLBACK WbFindCurrentDialog(HWND hwnd, LPARAM);

    friend DCWbGraphicMarker; // needs to get at LastDeletedGraphic
    friend ObjectTrashCan; // needs to get at drawingArea

public:
    //
    // Construction and destruction
    //
    WbMainWindow(void);
    ~WbMainWindow(void);

    //
    // Initialization - display the window and its children
    //
    BOOL Open(int iCommand);
    BOOL JoinDomain(void);

    //
    // Popup context menu for drawing area
    //
    void PopupContextMenu(int x, int y);

    //
    // Check whether the application is idle (not opening or doing a new)
    //
    BOOL IsIdle(void);

	// widthbar needs access to the current tool to get the current widths
    WbTool *GetCurrentTool( void )
		{return( m_pCurrentTool );}


	BOOL IsToolBarOn( void )
		{return( m_bToolBarOn );}

	WB_PAGE_HANDLE GetCurrentPage(void) {return(m_hCurrentPage);}

	BOOL UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd );


	BOOL HasGraphicChanged( PWB_GRAPHIC pOldHeaderCopy, const PWB_GRAPHIC pNewHeader );

	void UpdateWindowTitle(void);

    //
    // Handles tool tips and accelerators
    //
    BOOL    FilterMessage(MSG* pMsg);

    //
    // Global data
    //
    HWND        m_hwnd;
    WbTool *    m_ToolArray[TOOL_COUNT];

    // Dropping files onto the window
    void	OnDropFiles(HDROP hDropInfo);

protected:

    //
    // Tooltips
    //
    HWND        m_hwndToolTip;
    TOOLINFO    m_tiLastHit;
    int         m_nLastHit;

    int     OnToolHitTest(POINT pt, TOOLINFO* pTI) const;

    // WindowProc handlers
    int     OnCreate(LPCREATESTRUCT lpcs);
    void    OnDestroy();
    void    OnClose(void);
    void    OnSize(UINT, int, int);
    void    OnMove(void);
    void    OnSetFocus(void);
    void    OnInitMenuPopup(HMENU hMenu, UINT uiIndex, BOOL bSystem);
    void    OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu);
    void    OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT measureStruct);
    void    OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT drawStruct);
    void    OnGetMinMaxInfo(MINMAXINFO FAR* lpmmi);
    void    OnRenderAllFormats(void);
    void    OnPaletteChanged(HWND hwndPalette);
    LRESULT OnQueryNewPalette(void);
    void    OnTimer(UINT_PTR uiTimerId);
    LRESULT OnQueryEndSession(void);
    LRESULT OnConfShutdown( WPARAM, LPARAM );
    void    OnEndSession(BOOL bEnding);
    void    OnParentNotify(UINT msg);
    LRESULT OnToolTipText(UINT, NMHDR*);

    //
    // HELP
    //
	void    ShowHelp(void);

    // Command handlers
    void    OnCommand(UINT id, UINT code, HWND hwndCtl);
    void    OnAbout(void);
    void    OnNew(void);
    void    OnOpen(void);
    void    OnClearPage(void);
    void    OnDelete(void);
    void    OnUndelete(void);
    void    OnCut(void);
    void    OnCopy(void);
    void    OnPaste(void);
    void    OnSelectAll( void );
    void    OnChooseFont(void);
    void	OnToolBarToggle(void);
    void	OnStatusBarToggle(void);
    void	OnGrabWindow(void);
    void	OnZoom(void);
    int     OnSave(BOOL bPrompt);
    void	OnPrint(void);
    void	OnPageSorter(void);
    void	OnInsertPageBefore(void);
    void	OnInsertPageAfter(void);
    void	OnDeletePage(void);
    void	OnGrabArea(void);
    void	OnLButtonDown(void);
    void	OnLButtonUp(void);
    void	OnMouseMove(void);
    void	OnRemotePointer(void);
    void	OnSync(void);
    void	OnLock(void);

    void    OnSelectTool(UINT id);          // Select the current tool
    void    OnSelectColor(void);            // Color changed in palette
    void    OnSelectWidth(UINT id);         // Select pen width

    // Scrolling control (accessed via accelerators)
    void	OnScrollAccelerator(UINT id);

    // Moving through the pages
    void	OnFirstPage(void);
    void	OnPrevPage(void);
    void	OnNextPage(void);
    void	OnLastPage(void);
    void	OnGotoPage(void);

    void    OnGotoUserPosition(LPARAM lParam);
    void    OnGotoUserPointer(LPARAM lParam);
    void    OnJoinCall(BOOL bKeepContents, LPARAM lParam);
    void    OnDisplayError(WPARAM wParam, LPARAM lParam);
    void    OnJoinPendingCall(void);

    void    LoadCmdLine(LPCSTR szFileName);

    // CancelMode processing
    void	OnCancelMode();
    void    OnNotify(UINT id, NMHDR* pNM);
	void	OnSysColorChange( void );

	BOOL    m_bInitOk;

    //
    // Flag indicating that we are currently displaying a serious error
    // message.
    //
    BOOL    m_bDisplayingError;

    //
    // Domain ID of the call we are currently in
    //
    DWORD       m_dwDomain;

    //
    // Start registration with the necessary cores and join a call initially
    //
    BOOL JoinCall(BOOL bLocal);
    BOOL WaitForJoinCallComplete(void);

    //
    // Move to a given position in the page
    //
    void GotoPosition(int x, int y);

    //
    // Go to a specific page
    //
    void GotoPage(WB_PAGE_HANDLE hPage);
    void GotoPageNumber(UINT uiPageNumber);

    //
    // Go to a specified position
    //
    void GotoSyncPosition(void);

    //
    // Flag used to prevent processing of WM_TIMER messages. Even if the
    // timer is stopped there may be old messages in the queue. This flag
    // prevents these messages being processed.
    //
    BOOL        m_bTimerActive;

    //
    // Flag indicating whether an update to the sync position is needed. The
    // update is performed from the OnTimer member when it is next entered.
    //
    BOOL        m_bSyncUpdateNeeded;

    //
    // Event handler for DC-Groupware events
    //
    BOOL EventHandler(UINT Event, UINT_PTR param1, UINT_PTR param2);
    void ProcessEvents(UINT Event, UINT_PTR param1, UINT_PTR param2);

    //
    // Individual DC-Groupware event handlers
    //
    void OnCMSNewCall(BOOL fTopProvider, DWORD _dwDomain);
    void OnCMSEndCall(void);

    void OnALSLoadResult(UINT reason);

    void OnWBPJoinCallOK(void);
    void OnWBPJoinCallFailed(void);
    void OnWBPNetworkLost(void);
    void OnWBPError(void);
    void OnWBPPageClearInd(WB_PAGE_HANDLE hPage);
    void OnWBPPageOrderUpdated(void);
    void OnWBPPageDeleteInd(WB_PAGE_HANDLE hPage);
    void OnWBPContentsLocked(POM_OBJECT hUser);
    void OnWBPPageOrderLocked(POM_OBJECT hUser);
    void OnWBPUnlocked(POM_OBJECT hUser);
    void OnWBPLockFailed(void);
    void OnWBPGraphicAdded(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicMoved(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicUpdateInd(WB_PAGE_HANDLE hPage,
                               WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicReplaceInd(WB_PAGE_HANDLE hPage,
                                WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicDeleteInd(WB_PAGE_HANDLE hPage,
                               WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPUserJoined(POM_OBJECT hUser);
    void OnWBPUserLeftInd(POM_OBJECT hUser);
    void OnWBPUserUpdateInd(POM_OBJECT hUser, BOOL bReplace);
    void OnWBPSyncPositionUpdated(void);
    void OnWBPLoadComplete(void);
    void OnWBPLoadFailed(void);

    //
    // Clipboard access
    //
    BOOL            DoCopy(BOOL bRenderNow);  // Copy selection to the clipboard

    // Clipboard vars
    WB_PAGE_HANDLE      m_hPageClip;
    WB_GRAPHIC_HANDLE   m_hGraphicClip;
    DCWbGraphic *       m_pDelayedGraphicClip;
    PWB_GRAPHIC         m_pDelayedDataClip;

    // Clipboard routines
    WB_PAGE_HANDLE      CLP_LastCopiedPage(void) const;
    WB_GRAPHIC_HANDLE   CLP_LastCopiedGraphic(void) const;

    int                 CLP_AcceptableClipboardFormat(void);
    DCWbGraphic *       CLP_Paste(void);
    BOOL                CLP_Copy(DCWbGraphic * pGraphic, BOOL bRenderNow = FALSE);
    void                CLP_SaveDelayedGraphic(void);
    void                CLP_FreeDelayedGraphic(void);

    BOOL                CLP_RenderFormat(int iFormat);
    BOOL                CLP_RenderAllFormats(void);
    BOOL                CLP_RenderAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_DelayAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_RenderPrivateFormat(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderPrivateSingleFormat(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsImage(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsText(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsBitmap(DCWbGraphic* pGraphic);

#ifdef RENDER_AS_MF
    BOOL                CLP_RenderMetafileFormat(DCWbGraphic* pGraphic);
#endif

    //
    // Access functions for saved delayed graphic
    //
    PWB_GRAPHIC         CLP_GetGraphicData(void);
    DCWbGraphic*        CLP_GetGraphic(void);
    void                CLP_ReleaseGraphicData(PWB_GRAPHIC pHeader);


    //
    // Tool bar window
    //
    WbToolBar       m_TB;
    BOOL            m_bToolBarOn;

    //
    // Make updates based on a new user joining the call
    //
    void UserJoined(WbUser* pUser);

    //
    // Insert a new page after the specified page
    //
    void InsertPageAfter(WB_PAGE_HANDLE hPageAfter);

public:
    //
    // Drawing pane window
    //
    WbDrawingArea m_drawingArea;

	void RemoveGraphicPointer(DCWbGraphicPointer *p) { m_drawingArea.RemoveGraphicPointer(p); }

    UINT GetSubState( void )
		{return(m_uiSubState );}

    //
    // Get a lock on the Whiteboard contents.  The first parameter
    // determines the type of lock, the second whether a visible or
    // invisible dialog is to be used (use SW_SHOW or SW_HIDE).
    //
    BOOL GetLock(UINT uiLockType, UINT uiHide = SW_SHOW);

	void SetLockOwner( const WbUser *pLockOwner )
		{m_pLockOwner = pLockOwner;}

	const WbUser * GetLockOwner( void )
		{return(m_pLockOwner );}

    //
    // FRAME WINDOW VARS
    //
    HACCEL              m_hAccelTable;

    //
    // Get the window title
    //
    TCHAR * GetWindowTitle(void);

    WbWidthsGroup       m_WG;              // Pen Widths

	void EnableToolbar( BOOL bEnable );

    //
    // Page sorter dialog
    //
    HWND        m_hwndPageSortDlg;

    //
    // Dialog that asks whether to save changes.
    //
    HWND        m_hwndQuerySaveDlg;

    //
    // Timed dialogs that are running while the main window is waiting
    // for a specific event.
    //
    HWND        m_hwndWaitForEventDlg;
    HWND        m_hwndWaitForLockDlg;

protected:
	
	HWND                m_hwndInitDlg;
    void                KillInitDlg(void);


	
	UINT GetTipId(HWND hTipWnd, UINT nID);

    //
    // Color palette, font, page controls
    //
    WbAttributesGroup   m_AG;

    //
    // Status bar
    //
    HWND                m_hwndSB;
    BOOL                m_bStatusBarOn;
    void                UpdateStatus(void);

    //
    // Initialize the menus (color and width menu items are all ownerdraw)
    //
    void InitializeMenus(void);

    //
    // Resize function for subpanes - called when the window is resized by
    // the user.
    //
    void ResizePanes(void);

    //
    // Current window size - normal, maximized or minimized
    //
    UINT                m_uiWindowSize;

    //
    // Save the current window position to the options file
    //
    void SaveWindowPosition(void);


    //
    // Menu selection functions
    //
    UINT m_currentMenuTool;                   // Current tool menu Id
    UINT m_currentMenuWidth;                  // Current width menu Id

    //
    // Current drawing tool
    //
    WbTool*           m_pCurrentTool;

    //
    // Menu update functions
    //
    void CheckMenuItem(UINT uiId);
    void UncheckMenuItem(UINT uiId);
    BOOL CheckMenuItemRecursive(HMENU hMenu, UINT uiId, BOOL bCheck);

    HMENU GetMenuWithItem(HMENU hMenu, UINT uiId);

    //
    // Select a window for grabbing
    //
    HWND SelectWindow(void);

    //
    // Add a captured bitmap to the contents
    //
    void AddCapturedImage(DCWbGraphicDIB& dib);

    //
    // Get confirmation for destructive functions (new, clear)
    //
    int QuerySaveRequired(BOOL bCancelBtn);

    //
    // Load a file
    //
    void LoadFile(LPCSTR strLoadFileName);

    //
    // Perform a save
    //

    //
    // Get a file name for saving
    //
    int GetFileName();

    //
    // Members saving and restoring the lock state.  These can be used to
    // save the lock state before obtaining a temporary lock (e.g.  for
    // adding a new page). They cannot be nested.
    //
    void SaveLock(void);
    void RestoreLock(void);
    WB_LOCK_TYPE        m_uiSavedLockType;

    //
    // Release page order lock - this should be called after an asynchronous
    // function which requires the page order lock until it has completed.
    //
    void ReleasePageOrderLock(void);

    //
    // Display a message box for an error
    //
    void DisplayError(UINT uiCaption, UINT uiMessage);

    //
    // Current file name for saving image
    //
    TCHAR     m_strFileName[2*_MAX_PATH];

    //
    // Grab an area of the screen into a bitmap
    //
    void GetGrabArea(LPRECT lprect);

    //
    // Hide/show the main window and its associated popups
    //
    void ShowAllWindows(int iShow);
    void ShowAllWindows(void) { ShowAllWindows(SW_RESTORE); }	
    void HideAllWindows(void) { ShowAllWindows(SW_MINIMIZE); }	

    //
    // Current page of graphics
    //
    WB_PAGE_HANDLE  m_hCurrentPage;

    //
    // Handle of alternative accelerator table for page and text edit fields
    //
    HACCEL      m_hAccelPagesGroup;
    HACCEL      m_hAccelTextEdit;

    //
    // Local user
    //
    WbUser*             m_pLocalUser;

	// current lock owner
	const WbUser*       m_pLockOwner;

    //
    // Registration state variables
    //
    UINT        m_uiState;
    UINT        m_uiSubState;

    //
    // Pointer to last deleted graphic(s)
    //
    ObjectTrashCan m_LastDeletedGraphic;

    //
    // Context menu for drawing area
    //
    HMENU           m_hContextMenuBar;
    HMENU           m_hContextMenu;
    HMENU           m_hGrobjContextMenuBar;
    HMENU           m_hGrobjContextMenu;

    //
    // Member function to create pop-up context menu for the drawing area
    //
    BOOL CreateContextMenus(void);

    //
    // Flag to indicate that we are currently prompting the user to save
    // changes before joining a call
    //
    BOOL            m_bPromptingJoinCall;

    // We remember if we're in a save dialog so we can canel it on certain events
    BOOL            m_bInSaveDialog;
    void            CancelSaveDialog(void);

    //
    // Recover the whiteboard into a good state
    //
    void Recover(void);

    //
    // Lock/unlock the drawing area
    //
    void LockDrawingArea(void);
    void UnlockDrawingArea(void);

    //
    // Update the page buttons disable/enable status
    //
    void UpdatePageButtons(void);

    //
    // Sync/unsync with other users.
    //
    void Sync(void);
    void Unsync(void);

    //
    // Cancel a load in progress
    //
    void CancelLoad(BOOL bReleaseLock = TRUE);

    //
    // Set the application substate
    //
    void SetSubstate(UINT newSubState);

    //
    // Ensure the attributes window is up to date
    //
    void OnUpdateAttributes(void)
                 { m_AG.DisplayTool(m_pCurrentTool); }

    //
    // Map of page handles to positions
    //
	typedef struct PAGEPOSITION
	{
		WORD    hPage;
	 	POINT   position;
	} PAGE_POSITION;

    COBLIST    m_pageToPosition;
    void PositionUpdated(void);

    //
    // Pending call status
    //
    BOOL            m_bJoinCallPending;             // Join-call pending?
    DWORD           m_dwPendingDomain;              // domain of pending join-call
    BOOL            m_bPendingCallKeepContents;     // keep contents on pending call

    UINT            m_dwJoinDomain;              // domain that is currently being
                                        // joined
    BOOL            m_bCallActive;                // Is there a call up ?

    //
    // Menu state.
    // - SetMenuStates grays items on the specified menu
    // - InvalidateActiveMenu calls SetMenuStates and forces a re-draw of
    //   the currently active menu (if any)
    // - m_pInitMenu stores a pointer to the currently active menu.
    //
public:
    void SetMenuStates(HMENU hInitMenu);

protected:
    void InvalidateActiveMenu();

    HMENU   m_hInitMenu;

    //
    // Number of remote users
    //
    UINT m_numRemoteUsers;

	BOOL m_bSelectAllInProgress;

	BOOL GetDefaultPath( LPTSTR csDefaultPath, UINT size );

	
	BOOL m_bUnlockStateSettled;

	BOOL m_bQuerySysShutdown;

	
	BOOL m_bIsWin95;

    //
    // Interface for determining if a WM_CANCELMODE message has been sent
    //
protected:
    BOOL m_cancelModeSent;

public:
    void ResetCancelMode() { m_cancelModeSent = FALSE; };
    BOOL CancelModeSent()  { return m_cancelModeSent;  };
};


//
// Timed dialog proc
//
INT_PTR CALLBACK TimedDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// QuerySave dialog proc
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectWindow dialog proc
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectArea dialog proc
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// About Box dialog proc
//
INT_PTR CALLBACK AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // __MWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\precomp.h ===
//
// Precompiled header stuff
//

#define OEMRESOURCE
#define STRICT 1

#include <windows.h>
//
// CRT headers
//
#include <ctype.h>
#include <mbctype.h>
#include <string.h>
#include <math.h>
#include <memory.h>

#include <commdlg.h>
#include <shellapi.h>                   // Includes drag drop interface
#include <imm.h>

//
// NM headers
//
#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>
#include <confreg.h>
#include <oprahcom.h>
#include <indeopal.h>
#include <help_ids.h>
#include <endsesn.h>
#include <nmhelp.h>

// macro for setting "match to palette colors" bits in a COLORREF
#define SET_PALETTERGB( c )  (0x02000000 | (0x00ffffff & c))

//
// AS headers
//
#include <acpi.h>


#ifdef _DEBUG
extern HDBGZONE ghZoneWb;

// UPDATE g_rgZonesWb IF THESE CHANGE
enum
{
    ZONE_WB_DEBUG = BASE_ZONE_INDEX,
    ZONE_WB_MSG,
    ZONE_WB_TIMER,
    ZONE_WB_EVENT,
    ZONE_WB_MAX
};
		
#define TRACE_DEBUG( s )	MLZ_TraceZoneEnabled(ZONE_WB_DEBUG) ? (MLZ_TraceOut s) : 0
#define TRACE_MSG( s )		MLZ_TraceZoneEnabled(ZONE_WB_MSG) ? (MLZ_TraceOut s) : 0
#define TRACE_TIMER( s )	MLZ_TraceZoneEnabled(ZONE_WB_TIMER) ? (MLZ_TraceOut s) : 0
#define TRACE_EVENT( s )	MLZ_TraceZoneEnabled(ZONE_WB_EVENT) ? (MLZ_TraceOut s) : 0

#else

#define MLZ_EntryOut(zone, func)

#define TRACE_DEBUG( a )
#define TRACE_MSG( a )
#define TRACE_TIMER( a )
#define TRACE_EVENT( a )

#endif


#include "resource.h"
#include <oblist.h>
#include "wboblist.hpp"

#include "ccl32.hpp"

#include "page.hpp"
#include "user.hpp"

#include "cgrp.hpp"
#include "wgrp.hpp"
#include "agrp.hpp"

#include "psdlg.hpp"

#include "tool.hpp"
#include "grobj.hpp"
#include "twnd.hpp"
#include "txted.hpp"
#include "draw.hpp"
#include "grptr.hpp"
#include "mwnd.hpp"


#include "globals.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\page.cpp ===
//
// PAGE.CPP
// WB Page Handling
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
//
// Function:    GetData
//
// Purpose:     Get a pointer to the external representation of a graphic
//
//
PWB_GRAPHIC PG_GetData
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetData");

    // Get the pointer from the core
    PWB_GRAPHIC  pHeader = NULL;

    UINT uiReturn = g_pwbCore->WBP_GraphicGet(hPage, hGraphic, &pHeader);
    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
    }

    return pHeader;
}


//
//
// Function:    AllocateGraphic
//
// Purpose:     Allocate memory for a graphic
//
//
PWB_GRAPHIC PG_AllocateGraphic
(
    WB_PAGE_HANDLE      hPage,
    DWORD               length
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_AllocateGraphic");

    // Release the object (function never fails)
    PWB_GRAPHIC pHeader = NULL;

    UINT uiReturn = g_pwbCore->WBP_GraphicAllocate(hPage, length, &pHeader);
    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
    }

    return pHeader;
}


//
//
// Function:    First (crect)
//
// Purpose:     Return the first object in the page (bottommost Z-order)
//              that intersects the bounding rectangle
//
//
//CHANGED BY RAND - for object hit check
DCWbGraphic* PG_First
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    LPCRECT             pRectUpdate,
    BOOL                bCheckReallyHit
)
{
    UINT                uiReturn = 0;
    BOOL         empty = TRUE;
    PWB_GRAPHIC  pHeader = NULL;
    DCWbGraphic* pGraphic = NULL;
    RECT         rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_First");

    uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, NULL, FIRST, phGraphic);
    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(pGraphic);
    }

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return NULL;
    }

    if (pRectUpdate == NULL)
    {
        // Read the graphic
        // We have got what we want
        TRACE_MSG(("Got the object we want"));
        pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);
    }
    else
    {
        pHeader = PG_GetData(hPage, *phGraphic);
		if(pHeader == NULL)
		{
			return NULL;
		}

        rc.left   = pHeader->rectBounds.left;
        rc.top    = pHeader->rectBounds.top;
        rc.right  = pHeader->rectBounds.right;
        rc.bottom = pHeader->rectBounds.bottom;
        empty = !::IntersectRect(&rc, &rc, pRectUpdate);

        g_pwbCore->WBP_GraphicRelease(hPage, *phGraphic, pHeader);

        if (empty)
        {
            TRACE_MSG(("First object not needed - go to next"));
            pGraphic = PG_Next(hPage, phGraphic, pRectUpdate, bCheckReallyHit);
        }
        else
        {
            pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);

            if( bCheckReallyHit && (pGraphic != NULL) )
            {
                // do a real object hit test since we
                // know its bounding rect has hit
                if( !pGraphic->CheckReallyHit( pRectUpdate ) )
                {
                    delete pGraphic;
                    pGraphic = PG_Next(hPage, phGraphic, pRectUpdate, TRUE); // look again
                }
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    Next
//
// Purpose:     Return the next graphic in the page (going up through the
//              Z-order).  GetFirst must have been called before this
//              member.
//
DCWbGraphic* PG_Next
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    LPCRECT     pRectUpdate,
    BOOL        bCheckReallyHit
)
{
    UINT        uiReturn = 0;
    BOOL         empty = TRUE;
    PWB_GRAPHIC  pHeader = NULL;
    DCWbGraphic* pGraphic = NULL;
    RECT        rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_Next");

    while (uiReturn == 0)
    {
        uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, *phGraphic,
                AFTER, phGraphic);
        if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
        {
            return(pGraphic);
        }
        else if (uiReturn != 0)
        {
            // Throw an exception
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
		    return NULL;
        }

        if (pRectUpdate == NULL)
        {
            // Read the graphic
            // We have got what we want
            TRACE_MSG(("Got the object we want"));
            pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);
            break;
        }
        else
        {
            pHeader = PG_GetData(hPage, *phGraphic);

            rc.left   = pHeader->rectBounds.left;
            rc.top    = pHeader->rectBounds.top;
            rc.right  = pHeader->rectBounds.right;
            rc.bottom = pHeader->rectBounds.bottom;
            empty = !::IntersectRect(&rc, &rc, pRectUpdate);

            g_pwbCore->WBP_GraphicRelease(hPage, *phGraphic, pHeader);
            if (!empty)
            {
                TRACE_MSG(("Found the one we want - breaking out"));
                pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);

                if( bCheckReallyHit && (pGraphic != NULL) )
                {
                    // do a real object hit test since we
                    // know its bounding rect has hit
                    if( pGraphic->CheckReallyHit( pRectUpdate ) )
                        break;
                    else
                    {
                        delete pGraphic; // look again
                        pGraphic = NULL;
                    }
                }
                else
                    break; // found it
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    After
//
// Purpose:     Return the graphic after the specified graphic (going up
//              through the Z-order).
//
//
DCWbGraphic* PG_After
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_After");

    WB_GRAPHIC_HANDLE hGraphic;
    UINT uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, graphic.Handle(),
            AFTER, &hGraphic);

    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(NULL);
    }

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
		return NULL;
    }

    // Read the graphic
    return(DCWbGraphic::ConstructGraphic(hPage, hGraphic));
}

//
//
// Function:    Before
//
// Purpose:     Return the graphic before the specified graphic (going down
//              through the Z-order).
//
//
DCWbGraphic* PG_Before
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_Before");

    WB_GRAPHIC_HANDLE hGraphic;
    UINT uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, graphic.Handle(),
            BEFORE, &hGraphic);

    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(NULL);
    }

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return NULL;
    }

    // Read the graphic
    return(DCWbGraphic::ConstructGraphic(hPage, hGraphic));
}



//
//
// Function:    FirstPointer
//
// Purpose:     Return the first remote pointer object that is currently
//              active on this page.
//
//
DCWbGraphicPointer* PG_FirstPointer
(
    WB_PAGE_HANDLE  hPage,
    POM_OBJECT * ppUserNext
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_FirstPointer");

    // Get the handle of the first user
    g_pwbCore->WBP_PersonHandleFirst(ppUserNext);

    // Return the next pointer that is active on this page
    return PG_LookForPointer(hPage, *ppUserNext);
}

//
//
// Function:    LocalPointer
//
// Purpose:     Return the local user's pointer, if it is active on this
//              page.
//
//
DCWbGraphicPointer* PG_LocalPointer
(
    WB_PAGE_HANDLE  hPage
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_LocalPointer");

    DCWbGraphicPointer* pResult = NULL;

    // Get the local user
    POM_OBJECT    hUser;
    g_pwbCore->WBP_PersonHandleLocal(&hUser);
    WbUser* pUser = WB_GetUser(hUser);

    // Check whether the pointer is active, and is on this page
    if ((pUser != NULL)             &&
        (pUser->IsUsingPointer())   &&
        (pUser->PointerPage() == hPage))
    {
        pResult = pUser->GetPointer();
    }

    // Return the next pointer that is active on this page
    return pResult;
}

//
//
// Function:    NextPointer
//
// Purpose:     Return the next pointer in use.
//              FirstPointer must have been called before this member.
//
//
DCWbGraphicPointer* PG_NextPointer
(
    WB_PAGE_HANDLE  hPage,
    POM_OBJECT *    ppUserNext
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_NextPointer");

    DCWbGraphicPointer* pPointer;

    // Go forward one from the current user
    UINT uiReturn = g_pwbCore->WBP_PersonHandleNext(*ppUserNext, ppUserNext);
    if (uiReturn == 0)
    {
        pPointer = PG_LookForPointer(hPage, *ppUserNext);
    }
    else
    {
        if (uiReturn != WB_RC_NO_SUCH_PERSON)
        {
            ERROR_OUT(("Error getting next user handle"));
        }

        pPointer = NULL;
    }

    return(pPointer);
}

//
//
// Function:    NextPointer
//
// Purpose:     Return the next pointer in use.
//
//
DCWbGraphicPointer* PG_NextPointer
(
    WB_PAGE_HANDLE              hPage,
    const DCWbGraphicPointer*   pStartPointer
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_NextPointer");

    DCWbGraphicPointer* pPointer;

    // Go forward one from passed pointer
    POM_OBJECT hUser;
    UINT uiReturn = g_pwbCore->WBP_PersonHandleNext((pStartPointer->GetUser())->Handle(),
                                           &hUser);

    if (uiReturn == 0)
    {
        pPointer = PG_LookForPointer(hPage, hUser);
    }
    else
    {
        if (uiReturn != WB_RC_NO_SUCH_PERSON)
        {
            ERROR_OUT(("Error from WBP_PersonHandleNext"));
        }

        pPointer = NULL;
    }

    return(pPointer);
}


//
//
// Function:    LookForPointer
//
// Purpose:     Look for the first pointer active on this page, starting
//              the serach with the user whose handle is passed in.
//
//
DCWbGraphicPointer* PG_LookForPointer
(
    WB_PAGE_HANDLE  hPage,
    POM_OBJECT      hUser
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_LookForPointer");

    DCWbGraphicPointer* pPointer = NULL;
    WbUser*             pUser;
    UINT                result = 0;

    // Scan the users (starting with the one passed in)
    for (;;)
    {
        // Check if the user has an active pointer on this page
        pUser = WB_GetUser(hUser);

        if ((pUser != NULL) &&
            (pUser->IsUsingPointer()) &&
            (pUser->PointerPage() == hPage))
        {
            pPointer = pUser->GetPointer();
            break;
        }

        // Get the next user
        result = g_pwbCore->WBP_PersonHandleNext(hUser, &hUser);
        if (result != 0)
        {
            if (result != WB_RC_NO_SUCH_PERSON)
            {
                ERROR_OUT(("Error from WBP_PersonHandleNext"));
            }
            break;
        }
    }

    return(pPointer);
}




//
//
// Function:    GraphicUpdate
//
// Purpose:     Update an existing graphic
//
//
void PG_GraphicUpdate
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    PWB_GRAPHIC         pHeader
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GraphicUpdate");

    UINT uiReturn = g_pwbCore->WBP_GraphicUpdateRequest(hPage,
            *phGraphic, pHeader);

    if (uiReturn != 0)
    {
        if( uiReturn == OM_RC_OBJECT_DELETED )
        {
            // somebody nuked our object, try to put it back (bug 4416)
            g_pwbCore->WBP_GraphicAddLast(hPage, pHeader, phGraphic);
        }

        // Throw exception - exception code will special case 
        // OM_RC_OBJECT_DELETED and cancel drawing
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    GraphicReplace
//
// Purpose:     Replace an existing graphic
//
//
void PG_GraphicReplace
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    PWB_GRAPHIC         pHeader
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GraphicReplace");

    UINT uiReturn = g_pwbCore->WBP_GraphicReplaceRequest(hPage,
        *phGraphic, pHeader);

    if (uiReturn != 0)
    {
        if (uiReturn == OM_RC_OBJECT_DELETED)
        {
            // somebody nuked our object, try to put it back (bug 4416)
            g_pwbCore->WBP_GraphicAddLast(hPage, pHeader, phGraphic);
        }

        // Throw exception - exception code will special case 
        // OM_RC_OBJECT_DELETED and cancel drawing
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    Clear
//
// Purpose:     Delete all graphics on the page
//
//
void PG_Clear
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT uiReturn = g_pwbCore->WBP_PageClear(hPage);

    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    Delete
//
// Purpose:     Delete the specified graphic
//
//
void PG_GraphicDelete
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GraphicDelete");

    UINT uiReturn = g_pwbCore->WBP_GraphicDeleteRequest(hPage, graphic.Handle());
    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    SelectLast
//
// Purpose:     Select the last object whose bounding rectangle contains
//              the point specified.
//
//
DCWbGraphic* PG_SelectLast
(
    WB_PAGE_HANDLE  hPage,
    POINT           point
)
{
    RECT            rectHit;
    DCWbGraphic*    pGraphic = NULL;
    DCWbGraphic*    pGraphicPrev = NULL;
    WB_GRAPHIC_HANDLE hGraphic;

    UINT uiReturn = g_pwbCore->WBP_GraphicSelect(hPage, point, NULL, LAST,
                                              &hGraphic);
    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(pGraphic);
    }

    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return NULL;
    }

    // Get the graphic
    pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

    // Check to see if its really hit
    if (pGraphic != NULL)
    {
        MAKE_HIT_RECT(rectHit, point);
        if (!pGraphic->CheckReallyHit( &rectHit ))
        {
            // have to look some more
            pGraphicPrev = PG_SelectPrevious(hPage, *pGraphic, point );
            if( pGraphic != pGraphicPrev )
            {
                delete pGraphic;
                pGraphic = pGraphicPrev;
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    SelectPrevious
//
// Purpose:     Select the previous object whose bounding rectangle contains
//              the point specified.
//
//
DCWbGraphic* PG_SelectPrevious
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic,
    POINT               point
)
{
    RECT        rectHit;
    DCWbGraphic* pGraphic = NULL;
    WB_GRAPHIC_HANDLE hGraphic;
    WB_GRAPHIC_HANDLE hGraphicPrev;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_SelectPrevious");

    MAKE_HIT_RECT(rectHit, point );

    hGraphic = graphic.Handle();
    while ( (g_pwbCore->WBP_GraphicSelect(hPage, point,
                                       hGraphic, BEFORE, &hGraphicPrev ))
            != WB_RC_NO_SUCH_GRAPHIC )
    {
        // Get the graphic
        pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphicPrev);

        if( pGraphic == NULL )
            break;

        if( pGraphic->CheckReallyHit( &rectHit ) )
            break;

        hGraphic = hGraphicPrev;

        delete pGraphic;
        pGraphic = NULL;
    }


    return(pGraphic);
}



//
//
// Function:    IsTopmost
//
// Purpose:     Return TRUE if the specified graphic is topmost on the page
//
//
BOOL PG_IsTopmost
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic*  pGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_IsTopmost");

    WB_GRAPHIC_HANDLE hGraphic;
    UINT uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, NULL, LAST, &hGraphic);

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return FALSE;
    }

    return (pGraphic->Handle() == hGraphic);
}

//
//
// Function:    Draw
//
// Purpose:     Draw the contents of the page into the specified device
//              context.
//
//
void PG_Draw
(
    WB_PAGE_HANDLE  hPage,
    HDC             hDC,
    BOOL            thumbNail
)
{
    WB_GRAPHIC_HANDLE   hStart;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_Draw");

    //
    // Draw the graphic objects
    //
    DCWbGraphic* pGraphic = PG_First(hPage, &hStart);
    while (pGraphic != NULL)
    {
        pGraphic->Draw(hDC, thumbNail);

        // Release the current graphic
        delete pGraphic;

        // Get the next one
        pGraphic = PG_Next(hPage, &hStart);
    }
}

//CHANGED BY RAND
#define WB_MIN_PRINT_MARGIN_SIZE     (30)

//
//
// Function:    Print
//
// Purpose:     Print the contents of the page to the specified printer. The
//              contents are scaled to "best fit" on the page. i.e. the
//              largest scaling factor that preserves the aspect ratio of
//              the page is used.
//
//
void PG_Print
(
    WB_PAGE_HANDLE  hPage,
    HDC             hdc,
    LPCRECT         lprcPrint
)
{
    int pageWidth;
    int pageHeight;
    int areaHeight;
    int areaWidth;
    int areaAspectRatio;
    int pageAspectRatio;
    int nPhysOffsetX;
    int nPhysOffsetY;
    int nPhysWidth;
    int nPhysHeight;
    int nVOffsetX;
    int nVOffsetY;

    // get physical printer params
    nPhysOffsetX = GetDeviceCaps(hdc, PHYSICALOFFSETX );
    nPhysOffsetY = GetDeviceCaps(hdc, PHYSICALOFFSETY );
    nPhysWidth   = GetDeviceCaps(hdc, PHYSICALWIDTH );
    nPhysHeight  = GetDeviceCaps(hdc, PHYSICALHEIGHT );

    // calc correct printer area (allow for bugs in some drivers...)
    if( nPhysOffsetX <= 0 )
    {
        nPhysOffsetX = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetX = nPhysOffsetX;
    }
    else
        nVOffsetX = 0;

    if( nPhysOffsetY <= 0 )
    {
        nPhysOffsetY = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetY = nPhysOffsetY;
    }
    else
        nVOffsetY = 0;


    // get and adjust printer page area
    pageWidth  = GetDeviceCaps(hdc, HORZRES );
    pageHeight = GetDeviceCaps(hdc, VERTRES );

    if( pageWidth >= (nPhysWidth - nPhysOffsetX) )
    {
        // HORZRES is lying to us, compensate
        pageWidth = nPhysWidth - 2*nPhysOffsetX;
    }

    if( pageHeight >= (nPhysHeight - nPhysOffsetY) )
    {
        // VERTRES is lying to us, compensate
        pageHeight = nPhysHeight - 2*nPhysOffsetY;
    }


    // adjust printer area to get max fit for Whiteboard page
    areaWidth  = lprcPrint->right - lprcPrint->left;
    areaHeight = lprcPrint->bottom - lprcPrint->top;
    areaAspectRatio = ((100 * areaHeight + (areaWidth/2))/(areaWidth));
    pageAspectRatio = ((100 * pageHeight + (pageWidth/2))/(pageWidth));

    if (areaAspectRatio < pageAspectRatio)
        pageHeight  = ((pageWidth * areaHeight + (areaWidth/2))/areaWidth);
    else 
    if (areaAspectRatio > pageAspectRatio)
        pageWidth = ((pageHeight * areaWidth + (areaHeight/2))/areaHeight);

    // set up xforms

   	::SetMapMode(hdc, MM_ANISOTROPIC );
    ::SetWindowExtEx(hdc, areaWidth, areaHeight,NULL );
    ::SetWindowOrgEx(hdc, 0,0, NULL );
    ::SetViewportExtEx(hdc, pageWidth, pageHeight, NULL );
    ::SetViewportOrgEx(hdc, nVOffsetX, nVOffsetY, NULL );
    
    // draw the page
    PG_Draw(hPage, hdc);
}



//
//
// Function:    AreaInUse
//
// Purpose:     Return the bounding rectangle of all graphics on the page
//
//
void PG_GetAreaInUse
(
    WB_PAGE_HANDLE      hPage,
    LPRECT              lprcArea
)
{
    WB_GRAPHIC_HANDLE   hStart;
    RECT                rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_AreaInUse");

    ::SetRectEmpty(lprcArea);

    // Union together the rects of all the graphics
    DCWbGraphic* pGraphic = PG_First(hPage, &hStart);
    while (pGraphic != NULL)
    {
        pGraphic->GetBoundsRect(&rcBounds);
        ::UnionRect(lprcArea, lprcArea, &rcBounds);

        // Release the current graphic
        delete pGraphic;

        // Get the next one
        pGraphic = PG_Next(hPage, &hStart);
    }
}

//
//
// Function:    PG_InitializePalettes
//
// Purpose:     Create palettes for display and print (if necessary)
//
//
void PG_InitializePalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_InitializePalettes");

    // If the palettes are not yet initialized - initialize them now
    if (!g_bPalettesInitialized)
    {
        ASSERT(!g_hRainbowPaletteDisplay);

        // Get the number of colors supported by the screen
        // We only need an info DC for this, not a full DC
        HDC     hdc;

        hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
        if (!hdc)
        {
            return;
        }

        // Determine whether the device supports palettes
        int iBitsPixel = ::GetDeviceCaps(hdc, BITSPIXEL);
        int iPlanes    = ::GetDeviceCaps(hdc, PLANES);
        int iNumColors = iBitsPixel * iPlanes;

        ::DeleteDC(hdc);

        // If we need the palette, create it.
        // We only need the palette on a 8bpp machine. Anything less (4bpp)
        // and there will be no palette, anything more is a pure color display.
        if ((iNumColors == 8) &&
            (g_hRainbowPaletteDisplay = CreateColorPalette()))
        {
            // Show that we want to use the palette
            g_bUsePalettes = TRUE;

        }
        else
        {
            g_bUsePalettes = FALSE;
        }

        // Show that we have now initialized the palette information
        g_bPalettesInitialized = TRUE;
    }
}

//
//
// Function:    PG_GetPalette
//
// Purpose:     Return the palette for use with this page.
//              This object is temporary and should not be stored.
//
//
HPALETTE PG_GetPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPalette");

    // If the palettes are not yet initialized - initialize them now
    PG_InitializePalettes();

    if (g_bUsePalettes)
    {
        // If we are using a non-default palette, set the return value
        return(g_hRainbowPaletteDisplay);
    }
    else
    {
        return(NULL);
    }
}


void PG_ReinitPalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_ReinitPalettes");

    if (g_hRainbowPaletteDisplay)
    {
        if (g_pDraw->m_hDCCached)
        {
            // Select out the rainbow palette so we can delete it
            ::SelectPalette(g_pDraw->m_hDCCached, (HPALETTE)::GetStockObject(DEFAULT_PALETTE), TRUE);
        }
        ::DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    PG_InitializePalettes();
}



//
//
// Function : PG_GetObscuringRect
//
// Purpose  : Return the intersection of a graphic and any objects which
//            obscure it
//
//
void PG_GetObscuringRect
(
    WB_PAGE_HANDLE  hPage,
    DCWbGraphic*    pGraphic,
    LPRECT          lprcObscuring
)
{
    DCWbGraphic* pNextGraphic;
    RECT         rc;
    RECT         rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetObscuringRect");

    ::SetRectEmpty(lprcObscuring);
    pGraphic->GetBoundsRect(&rcBounds);

    // Loop through all the objects which are above the given one in the
    // Z-order, checking to see if they overlap the given object

    pNextGraphic = pGraphic;
    while (pNextGraphic = PG_After(hPage, *pNextGraphic))
    {
        // Get the bounding rectangle of the next object
        pNextGraphic->GetBoundsRect(&rc);

        // Check the intersection of the rectangles
        ::IntersectRect(&rc, &rc, &rcBounds);

        // Add the intersection to the obscuring rectangle
        ::UnionRect(lprcObscuring, lprcObscuring, &rc);
    }

    // check text editbox if its up - bug 2185
    if (g_pMain->m_drawingArea.TextEditActive())
    {
        g_pMain->m_drawingArea.GetTextEditBoundsRect(&rc);
        ::IntersectRect(&rc, &rc, &rcBounds);
        ::UnionRect(lprcObscuring, lprcObscuring, &rc);
    }
}



//
// ZGreaterGraphic()
//
// Determines which handle, hLastGraphic or hTestGraphic, is first in the 
// ZOrder (greater and consequently "underneath" the other graphic). If 
// hTestGraphic is NULL then the first graphic is returned.
//
WB_GRAPHIC_HANDLE PG_ZGreaterGraphic
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hLastGraphic, 
    WB_GRAPHIC_HANDLE   hTestGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_ZGreaterGraphic");

    WB_GRAPHIC_HANDLE hGraphic;
    WB_GRAPHIC_HANDLE hCurrentGraphic;

    if (g_pwbCore->WBP_GraphicHandle(hPage, NULL, FIRST, &hGraphic) != 0)
        return(NULL);

    if (hTestGraphic == NULL)
        return(hGraphic);

    if (hLastGraphic == NULL)
        return(hTestGraphic);

    // search for which one is deeper
    while (hGraphic != NULL)
    {
        if ((hGraphic == hLastGraphic) ||
            (hGraphic == hTestGraphic))
            return( hGraphic );

        hCurrentGraphic = hGraphic;
        if (g_pwbCore->WBP_GraphicHandle(hPage, hCurrentGraphic, AFTER, &hGraphic) != 0)
            return( NULL );
    }

    // didn't find either one
    return( NULL );
}



//
//
// Function:    GetNextPage
//
// Purpose:     Return the next page of graphic objects
//
//
WB_PAGE_HANDLE PG_GetNextPage
(
    WB_PAGE_HANDLE  hPage
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetNextPage");

    // Get the handle of the next page
    WB_PAGE_HANDLE hNextPage = NULL;
    UINT uiReturn = g_pwbCore->WBP_PageHandle(hPage, PAGE_AFTER, &hNextPage);

    switch (uiReturn)
    {
        case 0:
            // Got the previous page OK, return it
            break;

        case WB_RC_NO_SUCH_PAGE:
            // There is no previous page, return this page
            hNextPage = hPage;
            break;

        default:
            // Throw an exception recording the return code
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            break;
    }

    return(hNextPage);
}

//
//
// Function:    GetPreviousPage
//
// Purpose:     Return the previous page of graphic objects
//
//
WB_PAGE_HANDLE PG_GetPreviousPage
(
    WB_PAGE_HANDLE  hPage
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPreviousPage");

    // Get the handle of the previous page
    WB_PAGE_HANDLE hPreviousPage;
    UINT uiReturn = g_pwbCore->WBP_PageHandle(hPage, PAGE_BEFORE,
                                             &hPreviousPage);

    switch (uiReturn)
    {
        case 0:
            // Got the next page OK, return it
            break;

        case WB_RC_NO_SUCH_PAGE:
            // There is no next page, return this page
            hPreviousPage = hPage;
            break;

        default:
            // Throw an exception recording the return code
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            break;
    }

    return(hPreviousPage);
}

//
//
// Function:    GetPageNumber
//
// Purpose:     Return the page with the given page number
//
//
WB_PAGE_HANDLE PG_GetPageNumber(UINT uiPageNo)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPageNumber");

    // Ensure that the requested page number is within range
    uiPageNo = min(uiPageNo, g_pwbCore->WBP_ContentsCountPages());
    uiPageNo = max(1, uiPageNo);

    // Get the handle of the page with the specified page number
    WB_PAGE_HANDLE hPage;
    UINT uiReturn = g_pwbCore->WBP_PageHandleFromNumber(uiPageNo, &hPage);

    // Since we have been careful to ensure that the page number was
    // in bounds we should always get a good return code from the core.
    ASSERT(uiReturn == 0);

    // Return a page object created from the returned handle
    return(hPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\psdlg.hpp ===
//
// PSDLG.HPP
// Page Sorter Dialog
//
// Copyright Microsoft 1998-
//

#ifndef __PSDLG_HPP_
#define __PSDLG_HPP_



#define INSERT_BEFORE 1
#define INSERT_AFTER  2

#define WM_LBTRACKPOINT     0x0131

#define RENDERED_WIDTH      (DRAW_WIDTH / 16)
#define RENDERED_HEIGHT     (DRAW_HEIGHT / 16)

//
// Data we store in the GWL_USERDATA of the dialog.  Some is passed in
// by the DialogBox caller.  Some is used just by the dialog.  Some is
// returned back to the DialogBox caller.
//
typedef struct tagPAGESORT
{
    UINT        hCurPage;
    BOOL        fPageOpsAllowed;
    BOOL        fChanged;
    BOOL        fDragging;
    HWND        hwnd;
    int         iCurPageNo;
    int         iPageDragging;
    HCURSOR     hCursorCurrent;
    HCURSOR     hCursorDrag;
    HCURSOR     hCursorNoDrop;
    HCURSOR     hCursorNormal;
}
PAGESORT;


//
// Messages the caller can send to the page sort dialog
//
enum
{
    WM_PS_GETCURRENTPAGE    = WM_APP,
    WM_PS_HASCHANGED,
    WM_PS_ENABLEPAGEOPS,    // wParam == TRUE or FALSE
    WM_PS_LOCKCHANGE,
    WM_PS_PAGECLEARIND,     // wParam == hPage
    WM_PS_PAGEDELIND,       // wParam == hPage
    WM_PS_PAGEORDERUPD
};

//
// The page sorter dialog uses a horizontal listbox to display the
// thumbnail views of pages.  Each item holds a bitmap of data for the
// page.  We render this bitmap the first time the item is painted.  The
// listbox takes care of scrolling and keyboard navigation for us.
//

INT_PTR CALLBACK PageSortDlgProc(HWND, UINT, WPARAM, LPARAM);

void    OnInitDialog(HWND hwndPS, PAGESORT * pps);
void    OnMeasureItem(HWND hwndPS, UINT id, LPMEASUREITEMSTRUCT lpmi);
void    OnDeleteItem(HWND hwndPS, UINT id, LPDELETEITEMSTRUCT lpdi);
void    OnDrawItem(HWND hwndPS, UINT id, LPDRAWITEMSTRUCT lpdi);
void    OnCommand(PAGESORT * pps, UINT id, UINT code, HWND hwndCtl);
BOOL    OnSetCursor(PAGESORT * pps, HWND hwnd, UINT ht, UINT msg);
void    OnDelete(PAGESORT * pps);
void    InsertPage(PAGESORT * pps, UINT uiBeforeAfter);

void    OnPageClearInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageDeleteInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageOrderUpdated(PAGESORT * pps);

void    OnStartDragDrop(PAGESORT * pps, UINT iItem, int x, int y);
void    WhileDragging(PAGESORT * pps, int x, int y);
void    OnEndDragDrop(PAGESORT * pps, BOOL fComplete, int x, int y);

void    EnableButtons(PAGESORT * pps);
void    MovePage(PAGESORT * pps, int iOldPageNo, int iNewPageNo);


#endif // __PSDLG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\resource.h ===
#define IDI_APP                           1
#define WARNSELECTWINDOW                103
#define WARNSELECTAREA                  104
#define IDR_TOOLS                       118

#define ABOUTBOX                        130
#define PRINTCANCEL                     131
#define PAGESORTERDIALOG                132
#define LOCKDIALOG                      133
#define INVISIBLEDIALOG                 134
#define QUERYSAVEDIALOG                 135
#define QUERYSAVEDIALOGCANCEL           136

#define MAINMENU                        137
#define CONTEXTMENU                     138
#define GROBJMENU                       139

#define MAINACCELTABLE                  140
#define TEXTEDITACCELTABLE              141
#define PAGESGROUPACCELTABLE            142

#define REMOTEPOINTERANDMASK            143
#define REMOTEPOINTERXORDATA            144
#define LOCKCURSOR                      145
#define TEXTCURSOR                      146
#define PENCURSOR                       147
#define PENFREEHANDCURSOR               148
#define HIGHLIGHTFREEHANDCURSOR         149
#define GRABCURSOR                      150
#define DRAGPAGECURSOR                  151
#define DELETECURSOR                    152

#define IM_INITIALIZING                 161
#define WBMOVIE                         162
#define IDS_OBJECTSARELOCKED            716
#define IDS_CANTCLOSE                   875
#define IDS_CANTGETBMP                  876
#define IDS_LOCKEDTITLE                 884
#define IDS_MSG_USERSMIGHTLOSE          885

#define IDC_SWWARN_NOTAGAIN             1001
#define IDC_SAWARN_NOTAGAIN             1002
#define IDC_TOOLBAR                     1003
#define IDS_FONTOPTIONS                 1004

//
// Page sorter dialog
//
#define IDC_PS_GOTO                     300
#define IDC_PS_DELETE                   301
#define IDC_PS_INSERT_BEFORE            302
#define IDC_PS_INSERT_AFTER             303
#define IDC_PS_THUMBNAILS               304


#define IDC_ABOUTVERSION                1041
#define IDC_INITIALIZING_ANIMATION      1042

#define IDM_EDITCOLOR                   40024
#define IDM_SELECTALL                   40025


//
// Accelerators
//
#define IDVK_HELP                       50

#define IDD_PRINT_PAGE                  101
#define IDD_DEVICE_NAME                 102

#define IDM_ABOUT                       0x3000
#define IDM_HELP                        0x3001



//
// Tools menu ids
//
#define IDM_TOOLS_START                 0x3100
#define IDM_SELECT                      IDM_TOOLS_START
#define IDM_ERASER                      0x3101
#define IDM_TEXT                        0x3102
#define IDM_HIGHLIGHT                   0x3103
#define IDM_PEN                         0x3104
#define IDM_LINE                        0x3105
#define IDM_BOX                         0x3106
#define IDM_FILLED_BOX                  0x3107
#define IDM_ELLIPSE                     0x3108
#define IDM_FILLED_ELLIPSE              0x3109
#define IDM_TOOLS_MAX                   0x310A

#define IDM_COLOR                       0x3300

#define IDM_WIDTH                      0x3400
#define IDM_WIDTH_1                    0x3401
#define IDM_WIDTHS_START               IDM_WIDTH_1
#define IDM_WIDTH_2                    0x3402
#define IDM_WIDTH_3                    0x3403
#define IDM_WIDTH_4                    0x3404
#define IDM_WIDTHS_END                 0x3405

#define IDM_PAGE_FIRST                  0x3500
#define IDM_PAGE_PREV                   0x3501
#define IDM_PAGE_ANY                    0x3502
#define IDM_PAGE_NEXT                   0x3503
#define IDM_PAGE_LAST                   0x3504
#define IDM_PAGE_GOTO                   0x3505

#define IDM_EXIT                       0x3600
#define IDM_CLEAR_PAGE                 0x3601
#define IDM_FONT                       0x3602
#define IDM_SAVE                       0x3604
#define IDM_SAVE_AS                    0x3605
#define IDM_TOOL_BAR_TOGGLE            0x3606
#define IDM_STATUS_BAR_TOGGLE          0x3608
#define IDM_OPEN                       0x360b
#define IDM_CUT                        0x360c
#define IDM_COPY                       0x360d
#define IDM_PASTE                      0x360e
#define IDM_NEW                        0x360f
#define IDM_GRAB_AREA                  0x3610
#define IDM_GRAB_WINDOW                0x3611
#define IDM_PRINT                      0x3613
#define IDM_BRING_TO_TOP               0x3614
#define IDM_SEND_TO_BACK               0x3615
#define IDM_PAGE_SORTER                0x3616
#define IDM_DELETE                     0x3617
#define IDM_UNDELETE                   0x3618
#define IDM_PAGE_INSERT_BEFORE         0x361b
#define IDM_PAGE_INSERT_AFTER          0x361c
#define IDM_DELETE_PAGE                0x361d
#define IDM_REMOTE                     0x361e
#define IDM_SYNC                       0x361f
#define IDM_LOCK                       0x3620
#define IDM_WIDTHS                     0x3622
#define IDM_PAGES                      0x3623
#define IDM_GOTO_USER_POSITION         0x3624
#define IDM_GOTO_USER_POINTER          0x3625
#define IDM_ZOOM                       0x3626

//
// Scroll accelerators
//
#define IDM_PAGEUP                     0x3700
#define IDM_PAGEDOWN                   0x3701
#define IDM_SHIFTPAGEUP                0x3702
#define IDM_SHIFTPAGEDOWN              0x3703
#define IDM_LINEUP                     0x3704
#define IDM_HOME                       0x3705
#define IDM_END                        0x3706
#define IDM_LINEDOWN                   0x3707
#define IDM_SHIFTLINEUP                0x3708
#define IDM_SHIFTLINEDOWN              0x3709
#define IDM_SCROLL_END                 0x370a
#define IDM_NEXT_SHEET                 0x370b
#define IDM_PREV_SHEET                 0x370c

//
// Text Edit accelerators
//
#define IDM_DELETECHAR                 0x3800

//
// String table entry IDs
//
#define MAKE_STRING_ID(N)              (700 + N)

#define IDS_DEFAULT                    MAKE_STRING_ID(  1)

#define IDS_MENU_SYSTEM                MAKE_STRING_ID(  2)
#define IDS_MENU_FILE                  MAKE_STRING_ID(  3)
#define IDS_MENU_EDIT                  MAKE_STRING_ID(  4)
#define IDS_MENU_VIEW                  MAKE_STRING_ID(  5)
#define IDS_MENU_TOOLS                 MAKE_STRING_ID(  6)
#define IDS_MENU_OPTIONS               MAKE_STRING_ID(  7)
#define IDS_MENU_HELP                  MAKE_STRING_ID(  8)
#define IDS_MENU_WIDTH                 MAKE_STRING_ID(  9)

#define IDS_CLEAR_CAPTION              MAKE_STRING_ID( 13)
#define IDS_CLEAR_MESSAGE              MAKE_STRING_ID( 14)
#define IDS_ERROR_CAPTION              MAKE_STRING_ID( 15)
#define IDS_WINDOW_CLOSED              MAKE_STRING_ID( 16)
#define IDS_PRINT_NAME                 MAKE_STRING_ID( 17)

#define IDS_UNTITLED                   MAKE_STRING_ID( 21)
#define IDS_IN_CALL                    MAKE_STRING_ID( 22)
#define IDS_NOT_IN_CALL                MAKE_STRING_ID( 23)
#define IDS_TITLE_SEPARATOR            MAKE_STRING_ID( 24)
#define IDS_PASTE                      MAKE_STRING_ID( 29)
#define IDS_PASTE_ERROR                MAKE_STRING_ID( 30)
#define IDS_SAVE                       MAKE_STRING_ID( 31)
#define IDS_SAVE_ERROR                 MAKE_STRING_ID( 32)
#define IDS_LOCK                       MAKE_STRING_ID( 33)
#define IDS_LOCK_ERROR                 MAKE_STRING_ID( 34)
#define IDS_DELETE_PAGE                MAKE_STRING_ID( 35)
#define IDS_DELETE_PAGE_MESSAGE        MAKE_STRING_ID( 36)

#define IDS_FONT_SAMPLE                MAKE_STRING_ID( 42)
#define IDS_COPY                       MAKE_STRING_ID( 48)
#define IDS_COPY_ERROR                 MAKE_STRING_ID( 49)
#define IDS_SAVE_READ_ONLY             MAKE_STRING_ID( 50)
#define IDS_JOINING                    MAKE_STRING_ID( 51)
#define IDS_INITIALIZING               MAKE_STRING_ID( 52)

//
// File extension filters
//
#define IDS_FILTER_ALL              MAKE_STRING_ID(100)
#define IDS_FILTER_ALL_SPEC         MAKE_STRING_ID(101)
#define IDS_FILTER_WHT              MAKE_STRING_ID(102)
#define IDS_FILTER_WHT_SPEC         MAKE_STRING_ID(103)
#define IDS_EXT_WHT                 MAKE_STRING_ID(104)


//
// Error and information messages
//
#define IDS_MSG_TOO_MANY_PAGES         MAKE_STRING_ID(150)
#define IDS_MSG_CAPTION                MAKE_STRING_ID(151)
#define IDS_MSG_DEFAULT                MAKE_STRING_ID(152)
#define IDS_MSG_JOIN_CALL_FAILED       MAKE_STRING_ID(154)
#define IDS_MSG_WINDOWS_RESOURCES      MAKE_STRING_ID(158)
#define IDS_MSG_LOCKED                 MAKE_STRING_ID(159)
#define IDS_MSG_GRAPHIC_LOCKED         MAKE_STRING_ID(160)
#define IDS_MSG_NOT_LOCKED             MAKE_STRING_ID(161)
#define IDS_MSG_BAD_FILE_FORMAT        MAKE_STRING_ID(163)
#define IDS_MSG_BUSY                   MAKE_STRING_ID(165)
#define IDS_MSG_CM_ERROR               MAKE_STRING_ID(166)
#define IDS_MSG_AL_ERROR               MAKE_STRING_ID(167)
#define IDS_MSG_PRINTER_ERROR          MAKE_STRING_ID(169)
#define IDS_MSG_LOAD_FAIL_NO_FP        MAKE_STRING_ID(171)
#define IDS_MSG_LOAD_FAIL_NO_EXE       MAKE_STRING_ID(172)
#define IDS_MSG_LOAD_FAIL_BAD_EXE      MAKE_STRING_ID(173)
#define IDS_MSG_LOAD_FAIL_LOW_MEM      MAKE_STRING_ID(174)

//
// String IDs for hint windows associated with buttons
//

// TOOLBAR
#define IDS_HINT_SELECT                 MAKE_STRING_ID(200)
#define IDS_HINT_ERASER                 MAKE_STRING_ID(201)
#define IDS_HINT_TEXT                   MAKE_STRING_ID(202)
#define IDS_HINT_HIGHLIGHT              MAKE_STRING_ID(203)
#define IDS_HINT_PEN                    MAKE_STRING_ID(204)
#define IDS_HINT_LINE                   MAKE_STRING_ID(205)
#define IDS_HINT_BOX                    MAKE_STRING_ID(206)
#define IDS_HINT_FBOX                   MAKE_STRING_ID(207)
#define IDS_HINT_ELLIPSE                MAKE_STRING_ID(208)
#define IDS_HINT_FELLIPSE               MAKE_STRING_ID(209)
#define IDS_HINT_ZOOM_UP                MAKE_STRING_ID(210)
#define IDS_HINT_ZOOM_DOWN              MAKE_STRING_ID(211)
#define IDS_HINT_REMOTE_UP              MAKE_STRING_ID(212)
#define IDS_HINT_REMOTE_DOWN            MAKE_STRING_ID(213)
#define IDS_HINT_LOCK_UP                MAKE_STRING_ID(214)
#define IDS_HINT_LOCK_DOWN              MAKE_STRING_ID(215)
#define IDS_HINT_SYNC_UP                MAKE_STRING_ID(216)
#define IDS_HINT_SYNC_DOWN              MAKE_STRING_ID(217)
#define IDS_HINT_GRAB_AREA              MAKE_STRING_ID(218)
#define IDS_HINT_GRAB_WINDOW            MAKE_STRING_ID(219)

// WIDTHBAR
#define IDS_HINT_WIDTH_1                MAKE_STRING_ID(230)
#define IDS_HINT_WIDTH_2                MAKE_STRING_ID(231)
#define IDS_HINT_WIDTH_3                MAKE_STRING_ID(232)
#define IDS_HINT_WIDTH_4                MAKE_STRING_ID(233)

// PAGEBAR
#define IDS_HINT_PAGE_FIRST             MAKE_STRING_ID(240)
#define IDS_HINT_PAGE_PREVIOUS          MAKE_STRING_ID(241)
#define IDS_HINT_PAGE_ANY               MAKE_STRING_ID(242)
#define IDS_HINT_PAGE_NEXT              MAKE_STRING_ID(243)
#define IDS_HINT_PAGE_LAST              MAKE_STRING_ID(244)
#define IDS_HINT_PAGE_INSERT            MAKE_STRING_ID(245)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\tool.hpp ===
//
// TOOL.HPP
// Tool Classes
//
// Copyright Microsoft 1998-
//
#ifndef __TOOL_HPP_
#define __TOOL_HPP_


class DCWbGraphic;


//
// Tool types
//
#define TOOLTYPE_FIRST  0
enum
{
    TOOLTYPE_SELECT = TOOLTYPE_FIRST,
    TOOLTYPE_ERASER,
    TOOLTYPE_TEXT,
    TOOLTYPE_HIGHLIGHT,
    TOOLTYPE_PEN,
    TOOLTYPE_LINE,
    TOOLTYPE_BOX,
    TOOLTYPE_FILLEDBOX,
    TOOLTYPE_ELLIPSE,
    TOOLTYPE_FILLEDELLIPSE,

    // This must come last
    TOOLTYPE_MAX
}; 


#define TOOL_CMD(index)     ((index) + IDM_TOOLS_START)
#define TOOL_INDEX(cmd)     ((cmd) - IDM_TOOLS_START)
#define TOOL_COUNT          TOOL_INDEX(IDM_TOOLS_MAX)


#define DEF_PENCOLOR        RGB(0, 0, 0)
#define DEF_HIGHLIGHTCOLOR  RGB(255, 255, 0)

#define NUM_OF_WIDTHS       4



BOOL InitToolArray(void);
void DestroyToolArray(void);


//
//
// Class:   WbTool
//
// Purpose: Base Tool class
//
//
class WbTool
{
public:
    //
    // Constructors
    //
    WbTool(int toolType);
    ~WbTool();

    //
    // Return the type of the tool
    //
    virtual int ToolType(void) const { return m_toolType; }

    //
    // Return whether the tool supports various attributes
    //
    virtual BOOL HasColor(void) const;        // Tool supports colors
    virtual BOOL HasWidth(void) const;        // Tool supports widths
    virtual BOOL HasFont(void) const;         // Tool supports font

    //
    // Return the handle of the cursor for the tool
    //
    virtual HCURSOR GetCursorForTool(void) const;

    //
    // Get/set the tool attributes
    //
    UINT GetWidthAtIndex(UINT uiIndex) const
                               { return m_uiWidths[uiIndex]; }
    VOID SetWidthAtIndex(UINT uiIndex, UINT uiWidth)
                               { m_uiWidths[uiIndex] = uiWidth; }
    void SetWidthIndex(UINT uiWidthIndex)
                   { m_uiWidthIndexCur = uiWidthIndex; }

    void SetFont(HFONT hFont);
    void DeselectGraphic(void) { m_selectedTool = TOOLTYPE_MAX; }
    void SelectGraphic(DCWbGraphic* pGraphic);

    //
    // Return the pen attributes
    //
    COLORREF GetColor(void) const { return m_clrCur; }
    void     SetColor(COLORREF clr) { m_clrCur = clr; }
    UINT     GetWidth(void) const { return m_uiWidths[m_uiWidthIndexCur]; }
    UINT     GetWidthIndex(void) const { return m_uiWidthIndexCur; }
    int      GetROP(void) const;
    HFONT    GetFont(void) { return(m_hFont); }


protected:
    //
    // Tool type
    //
    int         m_toolType;
    int         m_selectedTool;

    //
    // Tool attributes
    //
    COLORREF    m_clrCur;
    UINT        m_uiWidths[NUM_OF_WIDTHS];
    UINT        m_uiWidthIndexCur;
    HFONT       m_hFont;
};


#endif // __TOOL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\psdlg.cpp ===
//
// PSDLG.CPP
// Page Sorter Dialog
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"



static const DWORD s_helpIds[] =
    {
    IDC_PS_THUMBNAILS,        IDH_CONF_PAGESORT_MAIN,
    IDC_PS_GOTO,            IDH_CONF_PAGESORT_GOTO,
    IDC_PS_DELETE,            IDH_CONF_PAGESORT_DEL,
    IDC_PS_INSERT_BEFORE,    IDH_CONF_PAGESORT_BEFORE,
    IDC_PS_INSERT_AFTER,    IDH_CONF_PAGESORT_AFTER,
    0,0
    };



//
// PageSortDlgProc()
// Dialog message handler for the page sort dialog.  We have to set the
// real LRESULT return value in some cases.
//
INT_PTR PageSortDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL        fHandled = FALSE;
    PAGESORT *  pps = (PAGESORT *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_DROPFILES:
            g_pMain->OnDropFiles((HDROP)wParam);
            fHandled = TRUE;
            break;

        case WM_INITDIALOG:
            OnInitDialog(hwnd, (PAGESORT *)lParam);
            fHandled = TRUE;
            break;

        case WM_MEASUREITEM:
            OnMeasureItem(hwnd, (UINT)wParam, (LPMEASUREITEMSTRUCT)lParam);
            fHandled = TRUE;
            break;

        case WM_DRAWITEM:
            OnDrawItem(hwnd, (UINT)wParam, (LPDRAWITEMSTRUCT)lParam);
            fHandled = TRUE;
            break;

        case WM_DELETEITEM:
            OnDeleteItem(hwnd, (UINT)wParam, (LPDELETEITEMSTRUCT)lParam);
            fHandled = TRUE;
            break;

        case WM_LBTRACKPOINT:
            // This gets sent to us from the listbox; see if the user is dragging
            OnStartDragDrop(pps, (UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            fHandled = TRUE;
            break;

        case WM_MOUSEMOVE:
            WhileDragging(pps, LOWORD(lParam), HIWORD(lParam));
            fHandled = TRUE;
            break;

        case WM_LBUTTONUP:
        case WM_CAPTURECHANGED:
            // If we're dragging, complete the drag/drop
            OnEndDragDrop(pps, (message == WM_LBUTTONUP),
                (short)LOWORD(lParam), (short)HIWORD(lParam));
            fHandled = TRUE;
            break;

        case WM_PALETTECHANGED:
            // Repaint the thumbnail list
            ::InvalidateRect(::GetDlgItem(hwnd, IDC_PS_THUMBNAILS), NULL, TRUE);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            OnCommand(pps, GET_WM_COMMAND_ID(wParam, lParam),
                    GET_WM_COMMAND_CMD(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam));
            fHandled = TRUE;
            break;

        case WM_SETCURSOR:
            fHandled = OnSetCursor(pps, (HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CONTEXTMENU:
            DoHelpWhatsThis(wParam, s_helpIds);
            fHandled = TRUE;
            break;

        case WM_HELP:
            DoHelp(lParam, s_helpIds);
            fHandled = TRUE;
            break;

        //
        // Private PageSortDlg messages
        //
        case WM_PS_ENABLEPAGEOPS:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));

            pps->fPageOpsAllowed = (wParam != 0);
            EnableButtons(pps);

            fHandled = TRUE;
            break;

        case WM_PS_LOCKCHANGE:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            EnableButtons(pps);
            fHandled = TRUE;
            break;

        case WM_PS_PAGECLEARIND:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            OnPageClearInd(pps, (WB_PAGE_HANDLE)wParam);
            fHandled = TRUE;
            break;

        case WM_PS_PAGEDELIND:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            OnPageDeleteInd(pps, (WB_PAGE_HANDLE)wParam);
            fHandled = TRUE;
            break;

        case WM_PS_PAGEORDERUPD:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            OnPageOrderUpdated(pps);
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
// OnInitDialog()
// WM_INITDIALOG handler
//
void OnInitDialog(HWND hwnd, PAGESORT * pps)
{
    int     nCount;
    RECT    rc;
    RECT    rcWindow;
    HWND    hwndList;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnInitDialog");

    ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));

    // Save this away
    ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pps);

    // Get our listbox
    pps->hwnd = hwnd;

    // Also put our HWND in WbMainWindow
    ASSERT(g_pMain);
    g_pMain->m_hwndPageSortDlg = hwnd;

    //
    // Get the drag/drop cursors we use
    //
    pps->hCursorDrag = ::LoadCursor(g_hInstance, MAKEINTRESOURCE(DRAGPAGECURSOR));
    pps->hCursorNoDrop = ::LoadCursor(NULL, IDC_NO);
    pps->hCursorNormal = ::LoadCursor(NULL, IDC_ARROW);
    pps->hCursorCurrent = pps->hCursorNormal;


    // Convert the cur page to a page number
    pps->iCurPageNo = (int) g_pwbCore->WBP_PageNumberFromHandle((WB_PAGE_HANDLE)pps->hCurPage);

    //
    // Insert items, with empty data (we render thumbnail bitmap the first
    // time we draw ite).
    //
    hwndList = ::GetDlgItem(hwnd, IDC_PS_THUMBNAILS);

    nCount = g_pwbCore->WBP_ContentsCountPages();

    // LB_SETCOUNT doesn't work on NT 4.0; must use add string
    while (nCount > 0)
    {
        ::SendMessage(hwndList, LB_ADDSTRING, 0, 0);
        nCount--;
    }

    ASSERT(::SendMessage(hwndList, LB_GETCOUNT, 0, 0) == (LRESULT)g_pwbCore->WBP_ContentsCountPages());

    // Select the current page
    ::SendMessage(hwndList, LB_SETCURSEL, pps->iCurPageNo - 1, 0);

    //
    // Set the original button page op state
    //
    EnableButtons(pps);

    //
    // We can receive dropped files
    //
    DragAcceptFiles(hwnd, TRUE);
}




//
// OnMeasureItem()
//
void OnMeasureItem(HWND hwnd, UINT id, LPMEASUREITEMSTRUCT lpmis)
{
    RECT    rcClient;

    ASSERT(id == IDC_PS_THUMBNAILS);
    ASSERT(!IsBadReadPtr(lpmis, sizeof(MEASUREITEMSTRUCT)));

    //
    // We want the slots to be square, although the page is wider than it
    // is high.
    //
    ::GetClientRect(::GetDlgItem(hwnd, id), &rcClient);
    rcClient.bottom -= rcClient.top;

    lpmis->itemWidth = rcClient.bottom;
    lpmis->itemHeight = rcClient.bottom;
}



//
// OnDeleteItem()
// We need to delete the bitmap for the item, if there is one
//
void OnDeleteItem(HWND hwnd, UINT id, LPDELETEITEMSTRUCT lpdis)
{
    HBITMAP hbmp;

    ASSERT(id == IDC_PS_THUMBNAILS);
    ASSERT(!IsBadReadPtr(lpdis, sizeof(DELETEITEMSTRUCT)));

    hbmp = (HBITMAP)lpdis->itemData;
    if (hbmp != NULL)
    {
        ASSERT(GetObjectType(hbmp) == OBJ_BITMAP);
        ::DeleteBitmap(hbmp);
    }
}



//
// OnDrawItem()
// Draws the thumbnail.  If there isn't a cached bitmap, we create one for
// the page.  The page number is the same as the item index + 1.
//
void OnDrawItem(HWND hwnd, UINT id, LPDRAWITEMSTRUCT lpdi)
{
    HWND            hwndList;
    WB_PAGE_HANDLE  hPage;
    HPALETTE        hPalette;
    HPALETTE        hOldPalette1 = NULL;
    HPALETTE        hOldPalette2 = NULL;
    HBITMAP         hBitmap = NULL;
    HBITMAP         hOldBitmap = NULL;
    HDC             hdcMem = NULL;
    HBRUSH          hbr;
    HPEN            hpen;
    TCHAR           szPageNum[8];
    COLORREF        clrOld;
    int             nMode;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnDrawItem");

    ASSERT(id == IDC_PS_THUMBNAILS);
    ASSERT(!IsBadReadPtr(lpdi, sizeof(DRAWITEMSTRUCT)));

    hwndList = ::GetDlgItem(hwnd, id);

    //
    // Is this within the proper range?
    //
    if (lpdi->itemID == -1)
    {
        WARNING_OUT(("OnDrawItem:  bogus item id"));
        goto Done;
    }

    if (g_pwbCore->WBP_PageHandleFromNumber(lpdi->itemID+1, &hPage) != 0)
    {
        ERROR_OUT(("OnDrawItem:  can't get page handle"));
        goto Done;
    }

    //
    // Account for the horizontal scroll bar; to get around whacky listbox
    // sizing bugs, we needed to fake the height out by including the scroll
    // bar in the item height.
    //
    lpdi->rcItem.bottom -= ::GetSystemMetrics(SM_CYHSCROLL);

    hdcMem = ::CreateCompatibleDC(lpdi->hDC);
    if (!hdcMem)
    {
        ERROR_OUT(("OnDrawItem:  can't create compatible dc"));
        goto Done;
    }

    //
    // Realize our palette into the DC
    //
    hPalette = PG_GetPalette();
    if (hPalette != NULL)
    {
        hOldPalette1 = ::SelectPalette(lpdi->hDC, hPalette, FALSE);
        ::RealizePalette(lpdi->hDC);

        hOldPalette2 = ::SelectPalette(hdcMem, hPalette, FALSE);
    }

    //
    // Do we have the image for this page created yet?  If not, create it
    // now.
    //
    hBitmap = (HBITMAP)lpdi->itemData;
    if (hBitmap == NULL)
    {
        hBitmap = ::CreateCompatibleBitmap(lpdi->hDC,
            RENDERED_WIDTH+2, RENDERED_HEIGHT+2);
        if (!hBitmap)
        {
            ERROR_OUT(("OnDrawItem:  can't create compatible bitmap"));
            goto Done;
        }
    }

    hOldBitmap = SelectBitmap(hdcMem, hBitmap);

    if ((HBITMAP)lpdi->itemData == NULL)
    {
        //
        // Fill the bitmap with the background color, framed so it looks
        // like a page.
        //
        hbr = SelectBrush(hdcMem, ::GetSysColorBrush(COLOR_WINDOW));
        ::Rectangle(hdcMem, 0, 0, RENDERED_WIDTH+2, RENDERED_HEIGHT+2);
        SelectBrush(hdcMem, hbr);

        //
        // Render the page
        //
        ::SaveDC(hdcMem);


        // Set the attributes to compress the whole page into a
        // thumbnail at the relevant position for the cache index.
        ::SetMapMode(hdcMem, MM_ANISOTROPIC);
        ::SetWindowExtEx(hdcMem, DRAW_WIDTH, DRAW_HEIGHT, NULL);
        ::SetViewportOrgEx(hdcMem, 1, 1, NULL);
        ::SetViewportExtEx(hdcMem, RENDERED_WIDTH, RENDERED_HEIGHT, NULL);

        // Draw the page into the cache bitmap
        ::SetStretchBltMode(hdcMem, STRETCH_DELETESCANS);
        PG_Draw(hPage, hdcMem, TRUE);

        // Restore the DC atrributes
        ::RestoreDC(hdcMem, -1);

        // Set the item data
        ::SendMessage(hwndList, LB_SETITEMDATA, lpdi->itemID, (LPARAM)hBitmap);
    }

    //
    // Fill the background with the selection or window color depending
    // on the state.
    //
    if (lpdi->itemState & ODS_SELECTED)
        ::FillRect(lpdi->hDC, &lpdi->rcItem, ::GetSysColorBrush(COLOR_HIGHLIGHT));
    else
        ::FillRect(lpdi->hDC, &lpdi->rcItem, ::GetSysColorBrush(COLOR_WINDOW));

    if (lpdi->itemState & ODS_FOCUS)
        ::DrawFocusRect(lpdi->hDC, &lpdi->rcItem);

    //
    // Blt the page bitmap to the listbox item, centering it horizontally
    // and vertically.
    //
    ::BitBlt(lpdi->hDC,
        (lpdi->rcItem.left + lpdi->rcItem.right - (RENDERED_WIDTH + 2)) / 2,
        (lpdi->rcItem.top + lpdi->rcItem.bottom - (RENDERED_HEIGHT + 2)) / 2,
        RENDERED_WIDTH + 2, RENDERED_HEIGHT + 2,
        hdcMem, 0, 0, SRCCOPY);

    //
    // Draw number of page centered
    //
    wsprintf(szPageNum, "%d", lpdi->itemID+1);
    clrOld = ::SetTextColor(lpdi->hDC, ::GetSysColor(COLOR_GRAYTEXT));
    nMode = ::SetBkMode(lpdi->hDC, TRANSPARENT);
    ::DrawText(lpdi->hDC, szPageNum, lstrlen(szPageNum), &lpdi->rcItem,
        DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    ::SetBkMode(lpdi->hDC, nMode);
    ::SetTextColor(lpdi->hDC, clrOld);


Done:
    if (hOldBitmap)
    {
        SelectBitmap(hdcMem, hOldBitmap);
    }

    if (hOldPalette2)
    {
        ::SelectPalette(hdcMem, hOldPalette2, FALSE);
    }

    if (hOldPalette1)
    {
        ::SelectPalette(lpdi->hDC, hOldPalette1, FALSE);
    }

    if (hdcMem)
    {
        ::DeleteDC(hdcMem);
    }
}



//
// OnSetCursor
// If the set is for us, handles the WM_SETCURSOR message and returns TRUE
// that we handled it, and TRUE via the window LRESULT.
//
BOOL OnSetCursor(PAGESORT * pps, HWND hwnd, UINT uiHit, UINT msg)
{
    // Check that this message is for the main window
    if (hwnd == pps->hwnd)
    {
        // If the cursor is now in the client area, set the cursor
        if (uiHit == HTCLIENT)
        {
            ::SetCursor(pps->hCursorCurrent);
        }
        else
        {
            // Restore the cursor to the standard arrow
            ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
        }

        ::SetWindowLongPtr(pps->hwnd, DWLP_MSGRESULT, TRUE);

        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


//
// OnCommand()
//
void OnCommand(PAGESORT * pps, UINT id, UINT cmd, HWND hwndCtl)
{
    switch (id)
    {
        case IDC_PS_INSERT_BEFORE:
            if (cmd == BN_CLICKED)
            {
                InsertPage(pps, INSERT_BEFORE);
            }
            break;

        case IDC_PS_INSERT_AFTER:
            if (cmd == BN_CLICKED)
            {
                InsertPage(pps, INSERT_AFTER);
            }
            break;

        case IDC_PS_GOTO:
            if (cmd == BN_CLICKED)
            {
                pps->iCurPageNo = (int)::SendDlgItemMessage(pps->hwnd,
                    IDC_PS_THUMBNAILS, LB_GETCURSEL, 0, 0) + 1;
                OnCommand(pps, IDOK, BN_CLICKED, NULL);
            }
            break;

        case IDC_PS_DELETE:
            if (cmd == BN_CLICKED)
            {
                OnDelete(pps);
            }
            break;

        case IDC_PS_THUMBNAILS:
            switch (cmd)
            {
                case LBN_DBLCLK:
                    OnCommand(pps, IDC_PS_GOTO, BN_CLICKED, NULL);
                    break;
            }
            break;

        case IDOK:
        case IDCANCEL:
            if (cmd == BN_CLICKED)
            {
                // Clear out WbMainWindow
                ASSERT(g_pMain);
                g_pMain->m_hwndPageSortDlg = NULL;

                // Get the current page
                pps->hCurPage = PG_GetPageNumber(pps->iCurPageNo);
                ::EndDialog(pps->hwnd, id);
            }
            break;
    }
}




//
// EnableButtons
// Enable (or disable) the dialog buttons appropriately
//
//
void EnableButtons(PAGESORT * pps)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::EnableButtons");

    ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));

    // If another user currently has a lock on the contents, disable the
    // delete and insert buttons.
    BOOL bLocked = WB_Locked();
    UINT uiCountPages = (UINT)::SendDlgItemMessage(pps->hwnd, IDC_PS_THUMBNAILS,
        LB_GETCOUNT, 0, 0);

    ::EnableWindow(::GetDlgItem(pps->hwnd, IDC_PS_DELETE), (!bLocked &&
                          (uiCountPages > 1) &&
                          pps->fPageOpsAllowed));

    ::EnableWindow(::GetDlgItem(pps->hwnd, IDC_PS_INSERT_BEFORE), (!bLocked &&
                          (uiCountPages < WB_MAX_PAGES) &&
                          pps->fPageOpsAllowed));

    ::EnableWindow(::GetDlgItem(pps->hwnd, IDC_PS_INSERT_AFTER), (!bLocked &&
                         (uiCountPages < WB_MAX_PAGES) &&
                         pps->fPageOpsAllowed));
}




//
// OnDelete
// The user has clicked the Delete button
//
//
void OnDelete(PAGESORT * pps)
{
    int iResult;
    BOOL bWasPosted;
    HWND hwndList;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnDelete");

    if (!pps->fPageOpsAllowed)
        return;

    // Display a message box with the relevant question
    if (g_pMain->UsersMightLoseData( &bWasPosted, pps->hwnd ) ) // bug NM4db:418
        return;

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(pps->hwnd, IDS_DELETE_PAGE, IDS_DELETE_PAGE_MESSAGE, MB_YESNO | MB_ICONQUESTION );

    // If the user wants to continue with the delete
    if (iResult == IDYES)
    {
        UINT    uiRet;
        int iSel = (int)::SendMessage(hwndList, LB_GETCURSEL, 0, 0);

        // Get a pointer to the current page
        WB_PAGE_HANDLE hPage = PG_GetPageNumber(iSel + 1);

        ASSERT(::SendMessage(hwndList, LB_GETCOUNT, 0, 0) > 1);

        // Ensure that we have the Page Order lock.
        if (!g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
        {
            DefaultExceptionHandler(WBFE_RC_WB, WB_RC_LOCKED);
            return;
        }

        // Delete the page. We do not update the thumbnails yet - this
        // is done when the page deleted event is received.
        uiRet = g_pwbCore->WBP_PageDelete(hPage);
        if (uiRet != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiRet);
            return;
        }

        // Show that the pages have been manipulated
        pps->fChanged = TRUE;
    }
}


//
//
// InsertPage
// Insert a new (blank) page into the Whiteboard
//
//
void InsertPage(PAGESORT * pps, UINT uiBeforeAfter)
{
    int iSel;

    MLZ_EntryOut(ZONE_FUNCTION, "InsertPage");

    if (!pps->fPageOpsAllowed)
        return;

    // Ensure that we have the Page Order lock.
    if (!g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
        return;

    iSel = (int)::SendDlgItemMessage(pps->hwnd, IDC_PS_THUMBNAILS, LB_GETCURSEL, 0, 0);

    // Add the new page to the list (throws an exception on failure)
    WB_PAGE_HANDLE hRefPage = PG_GetPageNumber(iSel + 1);
    UINT uiRet;
    WB_PAGE_HANDLE hPage;

    if (uiBeforeAfter == INSERT_BEFORE)
    {
       uiRet = g_pwbCore->WBP_PageAddBefore(hRefPage, &hPage);
    }
    else
    {
        uiRet = g_pwbCore->WBP_PageAddAfter(hRefPage, &hPage);
    }

    if (uiRet != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiRet);
        return;
    }

    // Show that the contents have been changed by the dialog
    pps->fChanged = TRUE;

    // We'll get notified in a bit when the page order has changed.
}



//
// OnPageClearInd()
// Notification passed on AFTER page has been cleared
//
void OnPageClearInd(PAGESORT * pps, WB_PAGE_HANDLE hPage)
{
    HWND    hwndList;
    int     iPageNo;
    RECT    rcItem;
    HBITMAP hbmp;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnPageClearInd");

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

    iPageNo = g_pwbCore->WBP_PageNumberFromHandle(hPage) - 1;

    // Is it in the right range?
    if ((iPageNo < 0) || (iPageNo >= ::SendMessage(hwndList, LB_GETCOUNT,
            0, 0)))
    {
        ERROR_OUT(("Bogus page number %d", iPageNo));
        return;
    }

    // Clear the item's data
    hbmp = (HBITMAP)::SendMessage(hwndList, LB_SETITEMDATA, iPageNo, 0);
    if (hbmp)
        ::DeleteBitmap(hbmp);

    // Repaint the rect
    if (::SendMessage(hwndList, LB_GETITEMRECT, iPageNo, (LPARAM)&rcItem))
    {
        ::InvalidateRect(hwndList, &rcItem, TRUE);
        ::UpdateWindow(hwndList);
    }
}


//
// OnPageDeleteInd()
// Notification passed on BEFORE page has been deleted
//
void OnPageDeleteInd(PAGESORT * pps, WB_PAGE_HANDLE hPage)
{
    HWND    hwndList;
    int     iPageNo;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnPageDeleteInd");

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);
    iPageNo = g_pwbCore->WBP_PageNumberFromHandle(hPage) - 1;

    //
    // If this isn't in the range we know about, we don't care
    //
    if ((iPageNo < 0) || (iPageNo >= ::SendMessage(hwndList, LB_GETCOUNT, 0, 0)))
    {
        ERROR_OUT(("Bogus page number %d", iPageNo));
        return;
    }

    //
    // Delete this item from the list
    //
    ::SendMessage(hwndList, LB_DELETESTRING, iPageNo, 0);

    EnableButtons(pps);
}


//
// OnPageOrderUpdated()
//
void OnPageOrderUpdated(PAGESORT * pps)
{
    HWND    hwndList;
    int     nCount;
    int     iCurSel;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnPageOrderUpdated");

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

    // Remember the old selection
    iCurSel = (int)::SendMessage(hwndList, LB_GETCURSEL, 0, 0);

    // This is too complicated.  We're just going to wipe out all the items
    // and their bitmaps
    ::SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);

    ::SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
    nCount = g_pwbCore->WBP_ContentsCountPages();

    //
    // Adjust the current, and selected indeces
    //
    if (pps->iCurPageNo > nCount)
    {
        pps->iCurPageNo = nCount;
    }

    // Put back the same selected item
    if (iCurSel >= nCount)
    {
        iCurSel = nCount - 1;
    }

    // LB_SETCOUNT doesn't work on NT 4.0; must use add string
    while (nCount > 0)
    {
        ::SendMessage(hwndList, LB_ADDSTRING, 0, 0);
        nCount--;
    }

    ASSERT(::SendMessage(hwndList, LB_GETCOUNT, 0, 0) == (LRESULT)g_pwbCore->WBP_ContentsCountPages());

    ::SendMessage(hwndList, LB_SETCURSEL, iCurSel, 0);

    ::SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
    ::InvalidateRect(hwndList, NULL, TRUE);
    ::UpdateWindow(hwndList);

    EnableButtons(pps);
}



//
// OnStartDragDrop()
// This checks if the user is trying to drag & drop pages around to
// change the order via direct manipulation. We get a WM_LBTRACKPOINT
// message when someone clicks in the listbox.  We then see if they are
// dragging; if so, we tell the listbox to ignore the mouse click, and we
// ourselves capture the mouse moves.
//
void OnStartDragDrop(PAGESORT * pps, UINT iItem, int x, int y)
{
    POINT   pt;

    //
    // If no page order stuff is currently allowed, return
    //
    if (!pps->fPageOpsAllowed || WB_Locked())
    {
        WARNING_OUT(("No direct manipulation of page order allowed"));
        return;
    }

    pt.x = x;
    pt.y = y;

    if (!DragDetect(pps->hwnd, pt))
    {
        // If the mouse is no longer down, fake a button up to the listbox
        // because DragDetect() just swallowed it
        if (::GetKeyState(VK_LBUTTON) >= 0)
        {
            ::PostMessage(::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS),
                WM_LBUTTONUP, MK_LBUTTON, MAKELONG(x, y));
        }
        return;
    }

    // We are dragging
    pps->fDragging = TRUE;
    pps->iPageDragging = iItem + 1;

    pps->hCursorCurrent = pps->hCursorDrag;
    ::SetCursor(pps->hCursorCurrent);
    ::SetCapture(pps->hwnd);

    // Tell the listbox to ignore the mouse-we're handling it
    // and blow off a double-click.
    ::SetWindowLongPtr(pps->hwnd, DWLP_MSGRESULT, 2);
}



//
// WhileDragging()
//
void WhileDragging(PAGESORT * pps, int x, int y)
{
    POINT   pt;
    RECT    rc;

    if (!pps->fDragging)
        return;

    pps->hCursorCurrent = pps->hCursorNoDrop;

    if (pps->fPageOpsAllowed && !WB_Locked())
    {
        //
        // Is this over the listbox client?
        //
        ::GetClientRect(::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS), &rc);
        ::MapWindowPoints(::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS),
            pps->hwnd, (LPPOINT)&rc, 2);

        pt.x = x;
        pt.y = y;

        if (::PtInRect(&rc, pt))
        {
            pps->hCursorCurrent = pps->hCursorDrag;
        }
    }

    ::SetCursor(pps->hCursorCurrent);
}


//
// OnEndDragDrop
//
void OnEndDragDrop(PAGESORT * pps, BOOL fComplete, int x, int y)
{
    POINT   pt;
    RECT    rc;
    int     iItem;

    if (!pps->fDragging)
        return;

    //
    // Do this first; releasing capture will send a WM_CAPTURECHANGED
    // message.
    //
    pps->fDragging = FALSE;
    pps->hCursorCurrent = pps->hCursorNormal;
    ::SetCursor(pps->hCursorCurrent);

    // Release capture
    if (::GetCapture() == pps->hwnd)
    {
        ::ReleaseCapture();
    }

    if (fComplete && pps->fPageOpsAllowed && !WB_Locked())
    {
        HWND    hwndList;
        POINT   pt;

        //
        // Is this over the listbox client?
        //
        hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

        ::GetClientRect(hwndList, &rc);
        ::MapWindowPoints(hwndList, pps->hwnd, (LPPOINT)&rc, 2);

        pt.x = x;
        pt.y = y;

        if (::PtInRect(&rc, pt))
        {
            //
            // If there is no item at this point, use the last one
            //
            ::MapWindowPoints(pps->hwnd, hwndList, &pt, 1);

            iItem = (int)::SendMessage(hwndList, LB_ITEMFROMPOINT, 0,
                MAKELONG(pt.x, pt.y));
            if (iItem == -1)
                iItem = (int)::SendMessage(hwndList, LB_GETCOUNT, 0, 0) - 1;

            if (g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
            {
                // Move the page
                MovePage(pps, pps->iPageDragging, iItem+1);
            }
        }

    }

    pps->iPageDragging = 0;
}



//
//
// Function:    MovePage
//
// Purpose:     Move a page in the core
//
//
void MovePage(PAGESORT * pps, int iOldPageNo, int iNewPageNo)
{
    int iCountPages;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::MovePage");

    ASSERT(iNewPageNo > 0);
    ASSERT(iOldPageNo > 0);

    if (!pps->fPageOpsAllowed)
        return;

    // If the new page number is bigger than the number of pages, assume
    // that the last page is meant.
    iCountPages = (int)::SendDlgItemMessage(pps->hwnd, IDC_PS_THUMBNAILS, LB_GETCOUNT, 0, 0);
    if (iNewPageNo > iCountPages)
    {
        iNewPageNo = iCountPages;
    }

    // If no change will result, do nothing
    if (   (iNewPageNo != iOldPageNo)
        && (iNewPageNo != (iOldPageNo + 1)))
    {
        // If we are moving a page up the list we use move after to allow
        // the moving of a page to be the last page. If we are moving a page
        // down the list we use move before so that we can move a page to
        // be the first page.
        // it down. We check here which is meant.

        // Assume that we want to move the page up the list
        BOOL bMoveAfter = FALSE;
        if (iOldPageNo < iNewPageNo)
        {
            bMoveAfter = TRUE;
            iNewPageNo -= 1;
        }

        // Only do the move if we have requested to move the page to a new place
        if (iOldPageNo != iNewPageNo)
        {
            // get lock
            if (!g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
                return;

            UINT uiRet;

            WB_PAGE_HANDLE hOldPage = PG_GetPageNumber((UINT) iOldPageNo);
            WB_PAGE_HANDLE hNewPage = PG_GetPageNumber((UINT) iNewPageNo);

            // Move the page
            if (bMoveAfter)
            {
                uiRet = g_pwbCore->WBP_PageMove(hNewPage, hOldPage, PAGE_AFTER);
            }
            else
            {
                uiRet = g_pwbCore->WBP_PageMove(hNewPage, hOldPage, PAGE_BEFORE);
            }

            if (uiRet != 0)
            {
                DefaultExceptionHandler(WBFE_RC_WB, uiRet);
                return;
            }

            // Show that the pages have been manipulated
            pps->fChanged = TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\tool.cpp ===
//
// TOOL.CPP
// Drawing Tools
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"




//
//
// Function:    WbTool
//
// Purpose:     Constructors for tools
//
//
WbTool::WbTool(int toolType)
{
    COLORREF    defColor;
    UINT        defWidth;
    int         iIndex;

    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::WbTool");


    // Save the tool type
    m_toolType = toolType;
    m_selectedTool = TOOLTYPE_MAX;

    m_uiWidthIndexCur = 0;

    // Read the colors of the pen
    if (toolType == TOOLTYPE_HIGHLIGHT)
        defColor = DEF_HIGHLIGHTCOLOR;
    else
        defColor = DEF_PENCOLOR;
    m_clrCur = defColor;

    for (iIndex = 0; iIndex < NUM_OF_WIDTHS; iIndex++)
    {
        defWidth = (toolType == TOOLTYPE_HIGHLIGHT) ?
            g_HighlightWidths[iIndex] :
            g_PenWidths[iIndex];

        m_uiWidths[iIndex] = defWidth;
    }

    // Read the font details
    LOGFONT lfont;

    ::GetObject(::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;
    lfont.lfCharSet = DEFAULT_CHARSET;
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
// WbTool::~WbTool
// Destructor
//
WbTool::~WbTool()
{
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
}



//
//
// Function:    HasColor
//
// Purpose:     Return TRUE if the tool supports colors
//
//
BOOL WbTool::HasColor(void) const
{
    BOOL bResult = TRUE;

    switch (m_toolType)
    {
        case TOOLTYPE_ERASER:
            bResult = FALSE;
            break;
    }

    return bResult;
}


//
//
// Function:    HasWidth
//
// Purpose:     Return TRUE if the tool supports widths
//
//
BOOL WbTool::HasWidth(void) const
{
    BOOL bResult = FALSE;

    switch (m_toolType)
    {
        case TOOLTYPE_PEN:
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_ELLIPSE:
            bResult = TRUE;
            break;

        // For the selector tool, it depends on the selected object type
        case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
                case TOOLTYPE_PEN:
                {
                    DCWbGraphic * pGraphic;

                    ASSERT(g_pDraw);
                    pGraphic = g_pDraw->GetSelection();
                    if ((pGraphic != NULL) &&
                        !(pGraphic->IsGraphicTool() == enumGraphicFilledRectangle) &&
                        !(pGraphic->IsGraphicTool() == enumGraphicFilledEllipse))
                    {
                        bResult = TRUE;
                    }
                    break;
                }
            }
            break;

        default:
            // The rest don't support widths, including filled tools
            break;
    }

    return bResult;
}


//
//
// Function:    HasFont
//
// Purpose:     Return TRUE if the tool supports fonts
//
//
BOOL WbTool::HasFont(void) const
{
    BOOL bResult = FALSE;

    switch (m_toolType)
    {
        case TOOLTYPE_TEXT:
            bResult = TRUE;
            break;

        // For the selector tool, it depends on the selected object type
        case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
                case TOOLTYPE_TEXT:
                    bResult = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            // The other tools do not support fonts
            break;
    }

    return bResult;
}

//
//
// Function:    GetROP
//
// Purpose:     Return the ROP for this tool
//
//
int WbTool::GetROP(void) const
{
    // If this is a highlight tool we use MASKPEN, else we use the standard
    if (m_toolType == TOOLTYPE_HIGHLIGHT)
        return(R2_MASKPEN);
    else
        return(R2_COPYPEN);
}


//
//
// Function:    GetCursorForTool
//
// Purpose:     Return the handle to the cursor for the tool
//
//
HCURSOR WbTool::GetCursorForTool(void) const
{
    int   nName = -1;

    switch(m_toolType)
    {
        case TOOLTYPE_SELECT:
            break; // use default arrow for select cursor (bug 439)

        case TOOLTYPE_PEN:
            nName = PENFREEHANDCURSOR;
            break;

        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            nName = PENCURSOR;
            break;

        case TOOLTYPE_HIGHLIGHT:
            nName = HIGHLIGHTFREEHANDCURSOR;
            break;

        case TOOLTYPE_TEXT:
            nName = TEXTCURSOR;
            break;
    
        case TOOLTYPE_ERASER:
            nName = DELETECURSOR;
            break;

        default:
            // Do nothing - the name pointer is NULL
            break;
    }

    HCURSOR hcursorResult = NULL;

    if (nName == -1)
    {
        // Return the standard arrow cursor as a default
        hcursorResult = ::LoadCursor(NULL, IDC_ARROW);
    }
    else
    {
        // Return the cursor for the tool
        hcursorResult = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( nName ) );
    }

    return hcursorResult;
}

//
//
// Function:    SetFont
//
// Purpose:     Set the current font of the tool
//
//
void WbTool::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::SetFont");

    // Get the font details
    LOGFONT lfont;

    ::GetObject(hFont, sizeof(LOGFONT), &lfont);
    //zap FontAssociation mode (bug 3258)
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Set the local font
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
    }
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
//
// Function:    SelectGraphic
//
// Purpose:     Set the current selected graphic type, and copy the colors,
//              widths and font into this tool's attributes.
//
//
void WbTool::SelectGraphic(DCWbGraphic* pGraphic)
{
    UINT uiIndex;

    // Save the selected tool type
    m_selectedTool = pGraphic->GraphicTool();

    // Get the tool object for the selected tool type
    WbTool* pTool = g_pMain->m_ToolArray[m_selectedTool];

    if (HasColor())
    {
        m_clrCur = pGraphic->GetColor();
    }

    if (HasWidth())
    {
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            SetWidthAtIndex(uiIndex, pTool->GetWidthAtIndex(uiIndex));
        }

        // See if the object's width matches any of the available colors
        // for this tool type
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            if (pGraphic->GetPenWidth() == m_uiWidths[uiIndex])
            {
                break;
            }
        }

        SetWidthIndex(uiIndex);
    }

    if (HasFont())
    {
        // only text objects have a font, so cast to a DCWbGraphicText
        if (pGraphic->IsGraphicTool() == enumGraphicText)
        {
            SetFont((((DCWbGraphicText*)pGraphic)->GetFont()));
        }
    }
}



//
// InitToolArray
// Create the array of WB tools
//
//
BOOL InitToolArray(void)
{
    int tool;
    WbTool * pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        // Add the new tool to the array
        pTool = new WbTool(tool);
        if (!pTool)
        {
            ERROR_OUT(("Can't create tool %d", tool));
            return(FALSE);
        }

        g_pMain->m_ToolArray[tool] = pTool;

    }

    return(TRUE);
}


//
// DestroyToolAray()
//
// Free the array of WB tools
//
void DestroyToolArray(void)
{
    int         tool;
    WbTool *    pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        pTool = g_pMain->m_ToolArray[tool];
        if (pTool != NULL)
        {
            g_pMain->m_ToolArray[tool] = NULL;
            delete pTool;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\twnd.cpp ===
//
// TWND.CPP
// ToolBar handler
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
// This is the button layout for the toolbar
//
static UINT g_uToolBar[TOOLBAR_MAXBUTTON] =
{
    IDM_SELECT,
    IDM_ERASER,
    IDM_TEXT,
    IDM_HIGHLIGHT,
    IDM_PEN,
    IDM_LINE,
    IDM_BOX,
    IDM_FILLED_BOX,
    IDM_ELLIPSE,
    IDM_FILLED_ELLIPSE,
    0,
    IDM_ZOOM,
    IDM_REMOTE,
    IDM_LOCK,
    IDM_SYNC,
    0,
    IDM_GRAB_AREA,
    IDM_GRAB_WINDOW
};



//
//
// Function:    WbToolBar constructor
//
// Purpose:     Create the tool window
//
//
WbToolBar::WbToolBar()
{
    m_hwnd = NULL;
    m_hbmImages = NULL;
}


WbToolBar::~WbToolBar()
{
    if (m_hbmImages != NULL)
    {
        ::DeleteBitmap(m_hbmImages);
        m_hbmImages = NULL;
    }
}



//
//
// Function:    Create
//
// Purpose:     Create the tool window
//
//
BOOL WbToolBar::Create(HWND hwndParent)
{
    TBBUTTON    tb;
    int         iImage, i;

    //
    // Create the tool window
    //
    m_hwnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | TBSTYLE_WRAPABLE |
        CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NOMOVEY | CCS_NORESIZE,
        0, 0, 0, 0,
        hwndParent, (HMENU)IDC_TOOLBAR, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbToolBar::Create create of window failed"));
        return(FALSE);
    }

    //
    // Tell COMCTL32 the structure size for the buttons
    //
    ::SendMessage(m_hwnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    //
    // And the margin for the buttons
    //
    ::SendMessage(m_hwnd, TB_SETINDENT, TOOLBAR_MARGINX, 0);


    //
    // Add the buttons into the toolbar
    //

    ZeroMemory(&tb, sizeof(tb));
    iImage = 0;

    for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
    {
        tb.fsState = TBSTATE_ENABLED;
        tb.idCommand = g_uToolBar[i];

        if (!tb.idCommand)
        {
            tb.fsStyle = TBSTYLE_SEP;
            tb.iBitmap = TOOLBAR_SEPARATORY;
        }
        else
        {
            tb.fsStyle = TBSTYLE_BUTTON;
            tb.iBitmap = iImage++;
        }

        if (!::SendMessage(m_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tb))
        {
            ERROR_OUT(("Failed to add button %d to toolbar", i));
            return(FALSE);
        }
    }

    //
    // Tell the toolbar the image and button sizes
    //
    ::SendMessage(m_hwnd, TB_SETBITMAPSIZE, 0,
        MAKELONG(TOOLBAR_IMAGEWIDTH, TOOLBAR_IMAGEHEIGHT));
    ::SendMessage(m_hwnd, TB_SETBUTTONSIZE, 0,
        MAKELONG(TOOLBAR_BTNWIDTH, TOOLBAR_BTNHEIGHT));

    //
    // Load the bitmap resource -- use sys color change handler
    //
    RecolorButtonImages();

    // set up rows
    ::SendMessage(m_hwnd, TB_SETROWS, MAKELPARAM(TOOLBAR_NUMROWS +
        TOOLBAR_NUMSEPARATORS, TRUE), 0);

    ::InvalidateRect(m_hwnd, NULL, TRUE);

    return(TRUE);
}



//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the tool client area
//
//
void WbToolBar::GetNaturalSize(LPSIZE lpsize)
{
    RECT rectButton;
    RECT rectButton2;

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_FIRSTBUTTON,
        (LPARAM)&rectButton))
    {
        ::SetRectEmpty(&rectButton);
    }

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_LASTBUTTON,
        (LPARAM)&rectButton2))
    {
        ::SetRectEmpty(&rectButton2);
    }

    lpsize->cx = TOOLBAR_WIDTH;
    lpsize->cy = rectButton2.bottom - rectButton.top +
        // Vertical margin
        (rectButton2.bottom - rectButton2.top);
}


//
//
// Function:    WidthFromHeight
//
// Purpose:     Calculate the width of the toolbar, given the height for
//              the fixed mode.
//
//
UINT WbToolBar::WidthFromHeight(UINT uiHeight)
{
    SIZE    size;

    GetNaturalSize(&size);
    return(size.cx);
}


//
//
// Function:    PushDown
//
// Purpose:     Push down a button in the tool window
//
//
BOOL WbToolBar::PushDown(UINT uiId)
{
    UINT butId;
    BOOL bDown;

    // If this isn't an exclusive checkable group, it's easy.
    if ((uiId < IDM_TOOLS_START) || (uiId >= IDM_TOOLS_MAX))
    {
        return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(TRUE, 0)));
    }

    // Push this one down and pop up all the others
    for (butId = IDM_TOOLS_START; butId < IDM_TOOLS_MAX; butId++)
    {
        bDown = (butId == uiId);
        ::SendMessage(m_hwnd, TB_CHECKBUTTON, butId, MAKELPARAM(bDown, 0));
    }

    return( TRUE );
}


//
//
// Function:    PopUp
//
// Purpose:     Pop up a button in the tool window
//
//
BOOL WbToolBar::PopUp(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}

//
//
// Function:    Enable
//
// Purpose:     Enable a button in the tool window
//
//
BOOL WbToolBar::Enable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(TRUE, 0)));
}

//
//
// Function:    Disable
//
// Purpose:     Disable a button in the tool window
//
//
BOOL WbToolBar::Disable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}




void WbToolBar::RecolorButtonImages(void)
{
    // re-color bitmap for toolbar
    HBITMAP hbmNew;

    hbmNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(IDR_TOOLS),
        IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);

    if (hbmNew == NULL)
    {
        ERROR_OUT(("OnSysColorChange:  failed to load toolbar bitmap"));
    }
    else
    {
        BITMAP  bmp;

        ::GetObject(hbmNew, sizeof(bmp), &bmp);

        if (m_hbmImages == NULL)
        {
            TBADDBITMAP addBitmap;

            // First time
            addBitmap.hInst = NULL;
            addBitmap.nID   = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_ADDBITMAP,
                (bmp.bmWidth / TOOLBAR_IMAGEWIDTH), (LPARAM)&addBitmap);
        }
        else
        {
            TBREPLACEBITMAP replaceBitmap;

            replaceBitmap.hInstOld = NULL;
            replaceBitmap.nIDOld = (UINT_PTR)m_hbmImages;
            replaceBitmap.hInstNew = NULL;
            replaceBitmap.nIDNew = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_REPLACEBITMAP, 0, (LPARAM)&replaceBitmap);
        }

        if (m_hbmImages)
        {
            ::DeleteBitmap(m_hbmImages);
        }

        m_hbmImages = hbmNew;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\twnd.hpp ===
//
// TWND.HPP
// Tool Window Class
//
// Copyright Microsoft 1998-
//
#ifndef __TWND_HPP_
#define __TWND_HPP_


//
// Our toolbar has three sections:
//      5 rows of exclusive tools 
//      SEPARATOR
//      2 rows of options
//      SEPARATOR
//      1 row of other commands (screen grabbing)
//      


#define TOOLBAR_NUMROWS			8
#define TOOLBAR_NUMSEPARATORS	2
#define TOOLBAR_NUMCOLS			2

#define TOOLBAR_FIRSTBUTTON     0
#define TOOLBAR_MAXBUTTON       18
#define TOOLBAR_LASTBUTTON      (TOOLBAR_MAXBUTTON - 1)


#define TOOLBAR_IMAGEWIDTH      16
#define TOOLBAR_IMAGEHEIGHT     15    
#define TOOLBAR_BTNEXTRA        7
#define TOOLBAR_BTNWIDTH        (TOOLBAR_IMAGEWIDTH + TOOLBAR_BTNEXTRA)
#define TOOLBAR_BTNHEIGHT       (TOOLBAR_IMAGEHEIGHT + TOOLBAR_BTNEXTRA)
#define TOOLBAR_MARGINX         (::GetSystemMetrics(SM_CXEDGE))
#define TOOLBAR_SEPARATORY      8
#define TOOLBAR_WIDTH           (2 * TOOLBAR_BTNWIDTH + 3 * TOOLBAR_MARGINX)


//
//
// Class:   WbToolBar
//
// Purpose: Define Whiteboard tool-bar window
//
//
class WbToolBar
{
public:
    //
    // Construction
    //
    WbToolBar();
    ~WbToolBar();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent);

    //
    // Button manipulation
    //
    BOOL PushDown(UINT uiId);
    BOOL PopUp(UINT uiId);

    BOOL Enable(UINT uiId);
    BOOL Disable(UINT uiId);

    //
    // Resizing functions
    //
    void    GetNaturalSize(LPSIZE lpsize);
    UINT    WidthFromHeight(UINT height);

    void    RecolorButtonImages(void);

    HWND    m_hwnd;

protected:
    HBITMAP m_hbmImages;
};


#endif // __TWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\txted.cpp ===
//
// TXTED.CPP
// Editor for Text Objects
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


/////////////////////////////////////////////////////////////////////////////
// WbTextBox


//
// This is a subclassed edit field
//

WbTextBox::WbTextBox(WbTextEditor * pEditor)
{
    OSVERSIONINFO OsData;

    m_hwnd = NULL;
    m_pfnEditPrev = NULL;

    m_MaxRect.left = 0;
    m_MaxRect.top = 0;
    m_MaxRect.right = INT_MAX;
    m_MaxRect.bottom = INT_MAX;

    ::SetRectEmpty(&m_rectErase);

    m_bInIME = FALSE;
    m_bDontEscapeThisTime = FALSE;

    // see if we need to make adjustments for NT.
    m_ptNTBooger.x = 0;
    m_ptNTBooger.y = 0;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // NT editboxes are offset from Win95 editboxes. We
            // have to de-booger them
            m_ptNTBooger.x = 3;
        }
    }

    m_pEditor = pEditor;
}


//
// ~WbTextBox()
//
WbTextBox::~WbTextBox()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }
}



//
// Create()
// Creates an edit field then subclasses it with our window procedure
//
BOOL WbTextBox::Create(HWND hwndParent)
{
    ASSERT(!m_hwnd);

    m_hwnd = ::CreateWindowEx(0, _T("EDIT"), NULL,
        WS_CHILD | WS_BORDER | ES_MULTILINE | ES_WANTRETURN |
        ES_AUTOHSCROLL | ES_AUTOVSCROLL,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
        hwndParent, NULL, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbTextBox::Create failed to create edit window"));
        return(FALSE);
    }

    // Init the data
    ::SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LPARAM)this);

    // Subclass the window
    m_pfnEditPrev = (WNDPROC)::SetWindowLongPtr(m_hwnd, GWLP_WNDPROC,
        (LONG_PTR)TextWndProc);

    return(TRUE);

}



//
// TextWndProc()
// Message subclass handler for edit field
//
LRESULT CALLBACK TextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    WbTextBox * ptb;

    ptb = (WbTextBox *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(ptb != NULL);
    ASSERT(ptb->m_pfnEditPrev != NULL);

    lResult = 0;

    switch( message )
    {
        case WM_CLEAR:
        case WM_CUT:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnClearCut();
            break;

        case WM_UNDO:
        case WM_PASTE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnUndoPaste();
            break;

        case WM_IME_STARTCOMPOSITION:
        {
            ptb->m_bInIME = TRUE;
            ptb->m_bDontEscapeThisTime = TRUE;

            // let editbox take it from here
            goto DefEditProc;
            break;
        }


        case WM_IME_CHAR:
        {
            ptb->m_bDontEscapeThisTime = FALSE;
            goto DefEditProc;
            break;
        }


        case WM_IME_ENDCOMPOSITION:
        {
            ptb->m_bInIME = FALSE;
            goto DefEditProc;
            break;
        }

        case WM_KILLFOCUS:
        {
            if (ptb->m_bInIME && g_fnImmGetContext)
            {
                HIMC hImc = g_fnImmGetContext(hwnd);
                if ((hImc != NULL) && g_fnImmNotifyIME)
                {
                    // we're loosing control, tell IME to wrap it up (bug 130)
                    g_fnImmNotifyIME( hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0 );
                }
            }
            // goto DefEditProc;
            break;
        }

        case WM_CHAR:
            ptb->OnChar((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_KEYUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnKeyUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SYSKEYDOWN:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnSysKeyDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_TIMER:
            ptb->OnTimer(wParam);
            break;

        case WM_MOUSEMOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMouseMove((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnLButtonUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMove(LOWORD(lParam), HIWORD(lParam));
            break;

        default:
DefEditProc:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
// OnClearCut()
//
void WbTextBox::OnClearCut()
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
    m_pEditor->m_bChanged = TRUE;

}


//
// OnUndoPaste()
//
void WbTextBox::OnUndoPaste(void)
{
    FitBox();
    AutoCaretScroll();

    m_pEditor->m_bChanged = TRUE;
}


//
// OnChar()
//
void  WbTextBox::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    int    nFirst;
    int    nLast;
    int    nPrevNumLines;
    int    nPrevNumChars;
    LRESULT dwPosChar;
    POINT  ptTop;

    // clear ignore next escape (NM4db:456)
    m_bDontEscapeThisTime = FALSE;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    dwPosChar = ::SendMessage(m_hwnd, EM_POSFROMCHAR, nFirst, 0);
    ptTop.x = (short)LOWORD(dwPosChar);
    ptTop.y = (short)HIWORD(dwPosChar);

    nPrevNumLines = (int)::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0);
    nPrevNumChars = (int)::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0);

    ::CallWindowProc(m_pfnEditPrev, m_hwnd, WM_CHAR, nChar, MAKELONG(nRepCnt, nFlags));

    SetupBackgroundRepaint( ptTop,
         (nPrevNumLines != ::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0))||
         (nPrevNumChars > ::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0)));

    FitBox();

    m_pEditor->m_bChanged = TRUE;
}




void WbTextBox::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    POINT   ptCaret;
    POINT   ptPos;

    AutoCaretScroll();

    switch( nChar )
    {
        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            break;


        case VK_DELETE:
            SelectAtLeastOne();
            ::SendMessage(m_hwnd, WM_CLEAR, 0, 0);
            break;


        case VK_ESCAPE:
            if( !m_bInIME )
            {
                if( m_bDontEscapeThisTime )
                    m_bDontEscapeThisTime = FALSE;
                else
                {
                    // End the text entry abandoning the changes
                    g_pDraw->EndTextEntry(FALSE);
                    return; // we don't exist anymore, bail out
                }
            }
            break;


        default:
            break;
    }

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}





void WbTextBox::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch( nChar )
    {
        case VK_MENU:
            // ignore next escape (NM4db:456)
            m_bDontEscapeThisTime = TRUE;
            break;

        default:
            break;
    }
}




BOOL WbTextBox::FitBox( void )
{
    RECT rectErase;
    RECT crEditRect;
    RECT crEditBox;
    RECT crEditWnd;
    RECT crDrawWnd;
    int   nDeltaWidth, nDeltaHeight;
    HDC     hDC = NULL;
    HDC     hDrawDC = NULL;
    TCHAR *szBoxText;
    BOOL bNoChanges;
    POINT   ptDrawLoc;
    HFONT   hSaveFont;
    POINT  ptBitmapTopLeft;
    LPTSTR pszText;
    int    nTextLen;
    int textSize;

    bNoChanges = TRUE;

    hDC = ::GetDC(m_hwnd);
    if (hDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hDrawDC = g_pDraw->GetCachedDC();
    if (hDrawDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hSaveFont = SelectFont(hDC, m_pEditor->GetFont());

    textSize = ::GetWindowTextLength(m_hwnd);
    if (!textSize)
    {
        // Use a " " for a string, which is two characters.
        szBoxText = new TCHAR[2];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for empty text"));
            goto bail_out;
        }
        else
        {
            lstrcpy(szBoxText, _T(" "));
        }
    }
    else
    {
        szBoxText = new TCHAR[textSize+1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
            goto bail_out;
        }
        else
        {
            ::GetWindowText(m_hwnd, (LPTSTR)szBoxText, textSize+1);
        }
    }

    // Have to check string length for NT. crEditRect comes back from
    // DrawText    giant-positive (i.e., still equal to m_MaxRect) if szBoxText
    // is empty. This causes crEditRect to overflow to giant negative later
    // resulting in very bizare painting problems. Win95 doesn't care because
    // it returns 16bit results that look like -1 instead of giant positive.

    ::GetClientRect(g_pDraw->m_hwnd, &crDrawWnd );

    // BUG 464 -DrawText doesn't calc widths involving tabs the same way a
    //            standard edit control does so replace it with DrawTextEx
    //            using the DT_EDITCONTROL format
    crEditRect = m_MaxRect;
    pszText = szBoxText;
    nTextLen = lstrlen(szBoxText);
    ::DrawTextEx( hDC,
                  pszText, nTextLen,
                  &crEditRect,
                  DT_CALCRECT | DT_EXPANDTABS | DT_NOPREFIX | DT_EDITCONTROL,
                  NULL );

    // BUG 464 (continued) -DrawTextEx doesn't include blank-last-lines in its height
    //                        calc like DrawText does so have to add an extra line
    //                        height for blank lines to have same behavior as DrawText
    if ((nTextLen >= 2) && !IsDBCSLeadByte(pszText[nTextLen-2]) && (pszText[nTextLen-1] == _T('\n')) )
        crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    // NT sanity check if this still fails
    if ( ((crEditRect.right - crEditRect.left) == (m_MaxRect.right - m_MaxRect.left)) ||
         ((crEditRect.right - crEditRect.left) <= 0) )
    {
        crEditRect.right = crEditRect.left + crDrawWnd.right - crDrawWnd.left;
    }

    if ( ((crEditRect.bottom - crEditRect.top) == (m_MaxRect.bottom - m_MaxRect.top)) ||
         ((crEditRect.bottom - crEditRect.top) <= 0) )
    {
        crEditRect.bottom = crEditRect.top + crDrawWnd.bottom - crDrawWnd.top;
    }

    ::GetClientRect(m_hwnd, &crEditBox);
    ::GetWindowRect(m_hwnd, &crEditWnd);
    ::MapWindowPoints(NULL, g_pDraw->m_hwnd, (LPPOINT)&crEditWnd, 2);

    // do min size check for IME's.
    int nMinWidth;
    nMinWidth = MIN_FITBOX_CHARS*m_pEditor->m_textMetrics.tmMaxCharWidth;
    if ((crEditRect.right - crEditRect.left) < nMinWidth )
        crEditRect.right = crEditRect.left + nMinWidth;

    // must add some slop to prevent autoscroll from kicking in
    crEditRect.right += 2*m_pEditor->m_textMetrics.tmMaxCharWidth;
    crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    //pretend we had a right or bottom scroll
    ::OffsetRect(&crEditRect, -1, -1);

    nDeltaWidth = (crEditRect.right - crEditRect.left) - (crEditBox.right - crEditBox.left);
    if (nDeltaWidth > 0)
    {
        bNoChanges = FALSE;
        if ( crEditRect.left < 0 )
        {
            // right scroll, adjust right edge
            crEditWnd.right += nDeltaWidth;
        }
        else
        {
            // left scroll, adjust left edge
            crEditWnd.left -= nDeltaWidth;
        }
    }

    nDeltaHeight = (crEditRect.bottom - crEditRect.top) - (crEditBox.bottom - crEditBox.top);
    if (nDeltaHeight > 0)
    {
        bNoChanges = FALSE;
        if( crEditRect.left < 0 )
        {
            // bottom scroll, adjust bottom edge
            crEditWnd.bottom += nDeltaHeight;
        }
        else
        {
            // top scroll, adjust top edge
            crEditWnd.top -= nDeltaHeight;
        }
    }

    if( bNoChanges )
        goto bail_out;


    // resize
    ::MoveWindow(m_hwnd, crEditWnd.left, crEditWnd.top,
        crEditWnd.right - crEditWnd.left, crEditWnd.bottom - crEditWnd.top, TRUE );

    // update bounding box
    ::GetClientRect(m_hwnd, &crEditBox);
    ::MapWindowPoints(m_hwnd, g_pDraw->m_hwnd, (LPPOINT)&crEditBox, 2);

    ::OffsetRect(&crEditBox, g_pDraw->m_originOffset.cx+1 + m_ptNTBooger.x,
        g_pDraw->m_originOffset.cy + m_ptNTBooger.y );//+1 );
    m_pEditor->m_boundsRect = crEditBox;

bail_out:

    if (hDC != NULL )
    {
        SelectFont(hDC, hSaveFont);
        ::ReleaseDC(m_hwnd, hDC );
    }

    delete szBoxText;
    return( !bNoChanges );
}




void WbTextBox::OnTimer(UINT_PTR nIDEvent)
{
    TRACE_TIMER(("WbTextBox::OnTimer"));

    // If the text object has not been added to the page before...
    if (m_pEditor->Handle() == NULL)
    {
        // Add it now
        m_pEditor->AddToPageLast(g_pDraw->Page());
    }
    else
    {
        // Otherwise, replace the external copy
        m_pEditor->Replace();
    }
}



//
// WbTextBox::OnLButtonUp()
//
void  WbTextBox::OnLButtonUp(UINT nFlags, int x, int y)
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}




//
// WbTextBox::OnMouseMove()
//
void  WbTextBox::OnMouseMove(UINT nFlags, int x, int y)
{
    if (nFlags & MK_LBUTTON )
    {
        // we're dragging
        ::HideCaret(m_hwnd);
        AutoCaretScroll();
        ::ShowCaret(m_hwnd);
    }
}



void  WbTextBox::AutoCaretScroll( void )
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    ptCaret.x += ptPos.x;
    ptCaret.y += ptPos.y;

    g_pDraw->AutoScroll(ptCaret.x, ptCaret.y, FALSE, m_pEditor->m_cursorXYPos.x,
        m_pEditor->m_cursorXYPos.y);
    m_pEditor->m_cursorXYPos = ptCaret;
}



void WbTextBox::SetupBackgroundRepaint
(
    POINT   ptTopPaint,
    BOOL    bNumLinesChanged
)
{
    RECT    rectBox;

    ::GetClientRect(m_hwnd, &rectBox);

    if (ptTopPaint.y == -1)
    {
        ::GetCaretPos(&ptTopPaint);
    }

    rectBox.top = ptTopPaint.y;
    if( !bNumLinesChanged )
        rectBox.bottom = rectBox.top + m_pEditor->m_textMetrics.tmHeight;

    ::InvalidateRect(m_hwnd, &rectBox, TRUE );
}



//
// Selects at least one (DBCS) char if there is not a selection already.
//
void WbTextBox::SelectAtLeastOne( void )
{
    int nFirst, nLast;
    TCHAR * szBoxText;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    if( nFirst == nLast )
    {
        int textSize = ::GetWindowTextLength(m_hwnd);
        szBoxText = new TCHAR[textSize + 1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
        }
        else
        {
            ::GetWindowText( m_hwnd, szBoxText, textSize+1);

            if (nFirst < textSize)
            {
                nLast++;

                if( IsDBCSLeadByte( (BYTE) szBoxText[ nFirst ] )||
                    (szBoxText[ nFirst ] == _T('\r'))
                    )
                    nLast++;

                ::SendMessage(m_hwnd, EM_SETSEL, nFirst, nLast);
            }

            delete szBoxText;
        }
    }
}



void WbTextBox::OnMove(int x, int y)
{
    if (m_pEditor->m_nLastShow == SW_SHOW)
    {
        FitBox();
        ::ShowCaret(m_hwnd);
    }
}


int WbTextBox::GetMaxCharHeight( void )
{
    return( m_pEditor->m_textMetrics.tmHeight );
}




int WbTextBox::GetMaxCharWidth( void )
{
    return( m_pEditor->m_textMetrics.tmMaxCharWidth );
}




//
// Aborts and shuts down text editor without hitting the cores.  Call this
// to shutdown editing during a lock condition (that we don't own)
//
void WbTextBox::AbortEditGently( void )
{
    RECT           boundsRect;

    // have to be carefull how we bail out of this so we
    // don't fall into an infinte exception loop (bugs 3550, 3556)
    if (g_pDraw->m_pActiveText != NULL)
    {
        delete g_pDraw->m_pActiveText;    // zap in memory original
        g_pDraw->m_pActiveText = NULL;  //  text object, loose any current
                                    //  edits
    }

    //
    //  NOTE:
    //      Can't reread the text object from cores to update
    //      boundsrect because the code that does that
    //      (DCWbGraphic::ReadExternal()) tries to lock
    //      the object and off we go into another exception
    //      loop. SO, the boundsrect we use below might
    //      not be the right size and the text might
    //      appear to be clipped when we redraw it. This
    //      will correct itself as soon as another graphic
    //      update notice comes in from DCL (the lock owner
    //      types another char). I think we have to live
    //      with that.
    //

    m_pEditor->GetBoundsRect(&boundsRect);

    // let go of core text object (see above)
    // don't unlock if handle is NULL or we will blow up the cores (bug 4621)
    if (g_pDraw->m_textEditor.Handle() != NULL )
    {
        if (g_pDraw->m_textEditor.GotLock() )
        {
            g_pDraw->m_textEditor.Unlock();
            g_pDraw->m_textEditor.ForceUpdate();
        }
    }

    g_pDraw->m_textEditor.ZapHandle();

    // shut down rejecting all edits
    g_pDraw->EndTextEntry(FALSE);

    // Redraw any altered parts of the screen
    g_pDraw->InvalidateSurfaceRect(&boundsRect);
}



//
//
// Function:    WbTextEditor
//
// Purpose:     Constructor
//
//
WbTextEditor::WbTextEditor(void)
{
    // Initialize the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // set parent for editbox
    m_pEditBox = NULL;

    m_cursorXYPos.x = 0;
    m_cursorXYPos.y = 0;

    m_bFirstSetFontCall = TRUE;
    m_nLastShow = -1;
}


WbTextEditor::~WbTextEditor(void)
{
    if (m_pEditBox != NULL)
    {
        delete m_pEditBox;
        m_pEditBox = NULL;
    }
}


//
//
// Function:    SetCursorPosFromPoint
//
// Purpose:     Return the character position most closely matching a
//              given co-ordinate position in the text object.
//
//
void WbTextEditor::SetCursorPosFromPoint(POINT pointXY)
{
    int    nCharPos;

    if (::PtInRect(&m_boundsRect, pointXY))
    {
        // make point relative to editbox
        pointXY.x -= g_pDraw->m_originOffset.cx;
        pointXY.y -= g_pDraw->m_originOffset.cy;

        ::MapWindowPoints(g_pDraw->m_hwnd, m_pEditBox->m_hwnd,
            &pointXY, 1);

        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONDOWN, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );
        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONUP, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );


        // get char index in editbox
        nCharPos = (int)::SendMessage(m_pEditBox->m_hwnd, EM_CHARFROMPOS, 0,
            MAKELPARAM(pointXY.x, pointXY.y));
        if( nCharPos < 0 )
            return;

        // Set the new cursor char co-ordinates
        m_cursorCharPos.x = (short)LOWORD(nCharPos);
        m_cursorCharPos.y = (short)HIWORD(nCharPos);

        // Move the cursor to the new position
        GetXYPosition(m_cursorCharPos, &m_cursorXYPos);
    }
}

//
//
// Function:    GetCursorSize
//
// Purpose:     Return the cursor size for the current font
//
//
void WbTextEditor::GetCursorSize(LPSIZE lpsize)
{
    lpsize->cx = ::GetSystemMetrics(SM_CXBORDER);
    lpsize->cy = m_textMetrics.tmHeight;
}

//
//
// Function:    XYPosition
//
// Purpose:     Calculate the X,Y co-ordinates of a character position
//
//
void WbTextEditor::GetXYPosition(POINT pointChar, LPPOINT lpptXY)
{
    int     nCharIndex;
    LRESULT dwCharPos;

    nCharIndex = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, pointChar.y, 0)
        + pointChar.x;

    GetPosition(lpptXY);

    dwCharPos = ::SendMessage(m_pEditBox->m_hwnd, EM_POSFROMCHAR, nCharIndex, 0);

    lpptXY->x += (short)LOWORD(dwCharPos);
    lpptXY->y += (short)HIWORD(dwCharPos);
}



//
//
// Function:    Clear
//
// Purpose:     Clear the text editor
//
//
void WbTextEditor::Clear(void)
{
    RECT cEWndRect;

    // Remove all the current stored text
    strTextArray.RemoveAll();
    strTextArray.Add(_TEXT(""));

    // Reset the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // clear editbox
    ::SetWindowText(m_pEditBox->m_hwnd, _TEXT(""));

    // Show that the text has not been changed
    m_bChanged = FALSE;

    // init editbox size
    m_boundsRect.right = m_boundsRect.left + 2*m_pEditBox->GetMaxCharWidth();
    m_boundsRect.bottom = m_boundsRect.top + 2*m_pEditBox->GetMaxCharHeight();

    cEWndRect = m_boundsRect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}

//
//
// Function:    New
//
// Purpose:     Clear the text editor and reset the graphic handle
//
//
BOOL WbTextEditor::New(void)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    // Clear the object
    Clear();

    // Show that the text has not been changed
    m_bChanged = FALSE;

    // Reset the graphic and page handles
    m_hGraphic = NULL;
    m_hPage = WB_PAGE_HANDLE_NULL;

    return(TRUE);
}


//
//
// Function:    SetTextObject
//
// Purpose:     Attach a text object to the editor
//
//
BOOL WbTextEditor::SetTextObject(DCWbGraphicText* ptext)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }


    // Clear and place the object
    Clear();

    // setup font
    DCWbGraphicText::SetFont( ptext->m_hFont );

    // Copy the text object's attributes to the editor
    SetText(ptext->strTextArray );
    ptext->GetBoundsRect(&m_boundsRect);

    SetColor(ptext->m_clrPenColor );

    MoveTo(m_boundsRect.left, m_boundsRect.top); // avoid kerning offset correction in Position()(bug 469)

    // Copy the page and handle of the graphic text object
    m_hPage    = ptext->m_hPage;
    m_hGraphic = ptext->m_hGraphic;

    // copy the text to the editbox
    GetText();

    // Say the text has changed so that all nodes will notice this thing
    // is locked - bug 2185
    m_bChanged = TRUE;

    return(TRUE);
}


//
//
// Function:    IsEmpty
//
// Purpose:     Return TRUE if there is no text in the object
//
//
BOOL WbTextEditor::IsEmpty(void)
{
    return(::GetWindowTextLength(m_pEditBox->m_hwnd) <= 0 );
}



void WbTextEditor::PutText(void)
{
    int nNumLines;
    int i;
    int nMaxLineLen, nLineLen;
    int nLine;
    TCHAR *cbuf;
    WbTextEditor *pThis;

    pThis = (WbTextEditor *)this; // overide const declaration

	if(m_pEditBox == NULL)
	{
		return;
	}

    nNumLines = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINECOUNT, 0, 0);

    // figure out buf size
    nMaxLineLen = 0;
    for (i = 0; i < nNumLines; i++)
    {
        nLine = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, i, 0);
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINELENGTH, nLine, 0);

        if (nMaxLineLen < nLineLen)
            nMaxLineLen = nLineLen;
    }

    // make buf
    nMaxLineLen += sizeof(WORD);
    cbuf = new TCHAR[nMaxLineLen];
    if( cbuf == NULL )
    {
        ERROR_OUT(("PutText failing; couldn't allocate TCHAR array"));
        return;
    }

    //
    // copy editbox innards to textbox string
    // Again, we know in advance how many lines; use SetSize/SetAt()
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(nNumLines);

    for(i = 0; i < nNumLines; i++)
    {
        *(LPWORD)cbuf = (WORD)nMaxLineLen;
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINE, i, (LPARAM)cbuf);
        cbuf[nLineLen] = _T('\0');
        strTextArray.SetAt(i, cbuf );
    }

    // clean up
    delete cbuf;
}




void WbTextEditor::GetText(void)
{
    int nNumLines;
    int textSize = 0;
    int i;
    TCHAR * pText = NULL;
    TCHAR * pStartText;

    nNumLines = strTextArray.GetSize();

    //
    // Calculate the buffer size we need
    //
    for (i = 0; i < nNumLines; i++ )
    {
        textSize += lstrlen(strTextArray[i]);

        if ((i + 1) < nNumLines)
            textSize += lstrlen(_T("\r\n"));
    }

    //
    // Get the lines, with \r\n separating them
    //
    pText = new TCHAR[textSize + 1];
    if (!pText)
    {
        ERROR_OUT(("GetText failing; couldn't allocate TCHAR array"));
    }
    else
    {
        // Null this out in casae textSize is 0.
        pStartText = pText;
        pStartText[0] = 0;

        for (i = 0; i < nNumLines; i++)
        {
            lstrcpy(pStartText, strTextArray[i]);
            pStartText += lstrlen(strTextArray[i]);

            if ((i + 1) < nNumLines)
            {
                lstrcpy(pStartText, _T("\r\n"));
                pStartText += lstrlen(_T("\r\n"));
            }
        }

        ::SetWindowText(m_pEditBox->m_hwnd, pText);
        delete pText;
    }
}




DWORD WbTextEditor::CalculateExternalLength( void )
{

    // stick text in underlying text object
    if( m_bChanged )
        PutText();

    // fix bounds to get rid off editbox slop
    ((WbTextEditor *)this)->DCWbGraphicText::CalculateBoundsRect();

    // tell textbox to use it in length calculation
    return( DCWbGraphicText::CalculateExternalLength() );
}




void WbTextEditor::CalculateBoundsRect( void )
{
    RECT    cEWndRect;

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);
    ::MapWindowPoints(m_pEditBox->m_hwnd, g_pDraw->m_hwnd,
        (LPPOINT)&cEWndRect, 2);

    m_boundsRect = cEWndRect;
    ::OffsetRect(&m_boundsRect, g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x,
                           g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y);//+1 );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
}




// set editbox visibility
void WbTextEditor::ShowBox( int nShow )
{
    if (m_nLastShow == nShow)
    {
        if( nShow == SW_SHOW)
            ::SetFocus(m_pEditBox->m_hwnd);

        return;
    }

    m_nLastShow = nShow;

    if (nShow == SW_SHOW)
    {
        // show it
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_SHOW);
            ::BringWindowToTop(m_pEditBox->m_hwnd);
            ::SetFocus(m_pEditBox->m_hwnd);

            ::HideCaret(m_pEditBox->m_hwnd);
            m_pEditBox->FitBox();
            ::ShowCaret(m_pEditBox->m_hwnd);
        }
    }
    else
    {
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_HIDE);
            m_bFirstSetFontCall = TRUE;

            delete m_pEditBox;
            m_pEditBox = NULL;
        }
    }
}



//
// Create()
//
// Creates the edit box window
//
BOOL WbTextEditor::Create( void )
{
    if (m_pEditBox == NULL)
    {
        m_pEditBox = new WbTextBox(this);
        if (m_pEditBox == NULL)
        {
            ERROR_OUT(("Couldn't create edit text box"));
            return(FALSE);
        }

        if (!m_pEditBox->Create(g_pDraw->m_hwnd))
        {
            ERROR_OUT(("WbTextEditor::Create failed; can't create edit field"));
            return(FALSE);
        }
    }

    return(TRUE);
}




void WbTextEditor::MoveBy(int cx, int cy)
{
    RECT cEWndRect;

    DCWbGraphicText::MoveBy(cx, cy);

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);

    if ((m_boundsRect.right - m_boundsRect.left) < (cEWndRect.right - cEWndRect.left))
        m_boundsRect.right = m_boundsRect.left + (cEWndRect.right - cEWndRect.left);

    if ((m_boundsRect.bottom - m_boundsRect.top) < (cEWndRect.bottom - cEWndRect.top))
        m_boundsRect.bottom = m_boundsRect.top + (cEWndRect.bottom - cEWndRect.top);

    cEWndRect = m_boundsRect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );//+1) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}




void WbTextEditor::SetFont( LOGFONT *pLogFont, BOOL bDummy )
{
    // Ignore bDummy. Had to add that so polymorph will work correctly
    // for DCWbGraphicText::SetFont()

    // Have to delay recalc of bounding rect because editbox will have a
    // bogus (bad) font until SetFont is called. Can't call SetFont
    // before this because new font hasn't been made yet.
    DCWbGraphicText::SetFont( pLogFont, FALSE );

    ::SendMessage(m_pEditBox->m_hwnd, WM_SETFONT, (WPARAM)m_hFont, TRUE);

    // now do bounding rect
    CalculateBoundsRect();

    if( m_bFirstSetFontCall )
        m_bFirstSetFontCall = FALSE;
    else
    {
        ::HideCaret(m_pEditBox->m_hwnd);

        m_pEditBox->FitBox();
        m_pEditBox->AutoCaretScroll();

        ::ShowCaret(m_pEditBox->m_hwnd);
    }
}



void WbTextEditor::WriteExtra( PWB_GRAPHIC pHeader )
{
    PutText();

    DCWbGraphicText::WriteExtra( pHeader );
}




void WbTextEditor::SetTimer( UINT nElapse )
{
    ::SetTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE, nElapse, NULL);
}



void WbTextEditor::KillTimer( void )
{
    ::KillTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE);
}




// Resets editbox painting for a resized drawing window
void WbTextEditor::ParentResize( void )
{
    ::HideCaret(m_pEditBox->m_hwnd);
    m_pEditBox->FitBox();
    ::ShowCaret(m_pEditBox->m_hwnd);
}




void WbTextEditor::RedrawEditbox(void)
{
    ::InvalidateRect(m_pEditBox->m_hwnd, NULL, TRUE);
    m_pEditBox->FitBox();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\wboblist.hpp ===
//
// CWBOBLIST.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __CWBOBLIST_HPP_
#define __CWBOBLIST_HPP_

class CWBOBLIST : public COBLIST
{
public:
	POSITION AddHead(VOID* pItem);
};

#endif  __CWBOBLIST_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\txted.hpp ===
//
// TXTED.HPP
// Text Object Editor
//
// Copyright Microsoft 1998-
//
#ifndef __TXTED_HPP_
#define __TXTED_HPP_



#define MIN_IME_WINDOW    30

#define MIN_FITBOX_CHARS 6

class WbTextEditor;

/////////////////////////////////////////////////////////////////////////////
// WbTextBox window

class WbTextBox
{
public:
	WbTextBox(WbTextEditor * pEditor);
    ~WbTextBox();

    BOOL Create(HWND hwndParent);

	BOOL FitBox( void );

	void AutoCaretScroll( void );

	int	GetMaxCharHeight( void );

	int	GetMaxCharWidth( void );

	void AbortEditGently( void );

    HWND    m_hwnd;
	POINT   m_ptNTBooger;

    friend LRESULT CALLBACK TextWndProc(HWND, UINT, WPARAM, LPARAM);

    WNDPROC m_pfnEditPrev;

protected:
    RECT    m_MaxRect;
	WbTextEditor *m_pEditor;
	RECT     m_rectErase;
	BOOL	 m_bInIME;
	BOOL	 m_bDontEscapeThisTime;

	void SetupBackgroundRepaint( POINT ptTopPaint, BOOL bNumLinesChanged=TRUE );
	void SelectAtLeastOne( void );

    void    OnClearCut(void);
    void    OnUndoPaste(void);
	void    OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnTimer(UINT_PTR nIDEvent);
	void    OnLButtonUp(UINT nFlags, int x, int y);
	void    OnMouseMove(UINT nFlags, int x, int y);
    void    OnMove(int x, int y);
	void    OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
};

/////////////////////////////////////////////////////////////////////////////


//
//
// Class:   WbTextEditor
//
// Purpose: Allow editing of the text in a DCWbGraphicText object
//
//
class WbTextEditor : public DCWbGraphicText
{
	friend class WbTextBox;
    friend class WbDrawingArea;
	
	public:
    //
    // Constructor
    //
    WbTextEditor(void);
   ~WbTextEditor(void);

    // writes text to underlying text object before relaying to text object
    DWORD CalculateExternalLength(void);

	// calcs bounds rect and sets editbox to new size
    void CalculateBoundsRect(void);

    void WriteExtra( PWB_GRAPHIC pHeader );

	void SetTimer( UINT nElapse );
	void KillTimer( void );

	// set editbox visibility
	void ShowBox( int nShow );

	BOOL Create( void );

	// Moves underlying text object and then moves editbox rect
    void MoveBy(int cx, int cy);

	void RedrawEditbox(void);

	// resets editbox for parent resizing
	void ParentResize( void );

	// clipboard
	void Copy( void )
		{ ::SendMessage(m_pEditBox->m_hwnd, WM_COPY, 0, 0); }

	void Cut( void )
        { ::SendMessage(m_pEditBox->m_hwnd, WM_CUT, 0, 0); }

	void Paste( void )
        { ::SendMessage(m_pEditBox->m_hwnd, WM_PASTE, 0, 0); }

    virtual void SetFont( LOGFONT *pLogFont, BOOL bDummy=TRUE );
    virtual void SetFont(HFONT hFont) { DCWbGraphicText::SetFont(hFont); }

    //
    // Attach a text object to the editor.  This function copies the
    // contents of the specified text object into the text editor.  The
    // editor will not alter the contents of the object passed and does not
    // keep a copy of the pointer parameter.
    //
    BOOL SetTextObject(DCWbGraphicText * ptext);

    //
    // Return the width and height for the cursor in pixels as a size
    //
    void GetCursorSize(LPSIZE lpsize);

    //
    // Set the current edit cursor position from a point specified in
    // logical co-ordinates.  This function does nothing if the point
    // specified is outside the bounding rectangle of the object being
    // edited.  If the point specified is within the bounding rectangle the
    // current edit cursor position is updated to a point as close as
    // possible to that passed as parameter.
    //
    void SetCursorPosFromPoint(POINT pointXY);

    void Clear(void);                // Delete all text
    BOOL New(void);                  // Delete text and reset handles

    //
    // Return TRUE if there is not text in the object
    //
    BOOL IsEmpty(void);

	void AbortEditGently( void )
		{m_pEditBox->AbortEditGently();}


protected:
    //
    // Pixel position from a character position
    //
    void GetXYPosition(POINT pointChar, LPPOINT lpptGet);

    //
    // Current cursor position.  Note that cursorCharPos.x gives the BYTE
    // position of the cursor rather than the character position.  On SBCS
    // systems the character and byte positions will always be the same,
    // but on DBCS systems the number of bytes in a string can be greater
    // than the number of characters.
    //
    // cursorCharPos.x should NEVER be set to a byte count which is in the
    // middle of a double byte character.
    //
    POINT   m_cursorCharPos;
    POINT   m_cursorXYPos;

	WbTextBox *m_pEditBox;
	int	 m_nLastShow;
	void PutText(void);
	void GetText(void);
};


#endif // __TXTED_HPP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\wgrp.hpp ===
//
// WGRP.HPP
// Widths Group
//
// Copyright Microsoft 1998-
//

#ifndef __WGRP_HPP
#define __WGRP_HPP


#define WIDTHBAR_WIDTH	TOOLBAR_WIDTH
#define WIDTHBAR_HEIGHT	50




class WbWidthsGroup
{
public:
	WbWidthsGroup();
    ~WbWidthsGroup();

	BOOL    Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

    void    PushDown(UINT uiIndex);
    int     ItemFromPoint(int x, int y) const;
    void    GetItemRect(int iItem, LPRECT lprc) const;

    HWND    m_hwnd;

    friend LRESULT CALLBACK  WGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void    OnPaint(void);
    void    OnLButtonDown(int x, int y);

	UINT    m_uLast;
    UINT    m_cyItem;
};

#endif // __WGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\wgrp.cpp ===
//
// WGRP.CPP
// Widths Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szWGClassName[] = "WB_WGRP";


WbWidthsGroup::WbWidthsGroup()
{
    int     i;

    m_hwnd  = NULL;
    m_uLast = 0;

    //
    // Calculate the height of each item in the list--it's the max of the
    // pen widths + slop space
    //
    m_cyItem = 0;
    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        m_cyItem = max(m_cyItem, g_PenWidths[i]);
    }
    m_cyItem += 2 * ::GetSystemMetrics(SM_CYEDGE);
}


WbWidthsGroup::~WbWidthsGroup()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szWGClassName, g_hInstance);
}



BOOL WbWidthsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX      wc;

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = WGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szWGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbWidthsGroup::Create register class failed"));
        return(FALSE);
    }

    ASSERT(!m_hwnd);

    if (!::CreateWindowEx(WS_EX_STATICEDGE, szWGClassName, NULL,
        WS_CHILD | WS_CLIPSIBLINGS, lprect->left, lprect->top,
        lprect->right - lprect->left, lprect->bottom - lprect->top,
        hwndParent, (HMENU)IDM_WIDTH, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbWidthsGroup"));
        return(FALSE);
    }

    return(TRUE);
}



//
// WGWndProc()
// Message handler for width window
//
LRESULT CALLBACK WGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbWidthsGroup * pwg = (WbWidthsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pwg = (WbWidthsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pwg);

            pwg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pwg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pwg);
            pwg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pwg);
            pwg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pwg);
            pwg->OnLButtonDown((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_NOTIFY:
            // Pass up to main window
            lResult = ::SendMessage(g_pMain->m_hwnd, message, wParam, lParam);
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbWidthsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cy = ::GetSystemMetrics(SM_CYEDGE) +
        (NUM_OF_WIDTHS * m_cyItem);

    if (m_hwnd != NULL)
    {
        RECT    rect;

        ::GetWindowRect(m_hwnd, &rect);
        rect.right -= rect.left;
        lpsize->cx = max(WIDTHBAR_WIDTH, rect.right);
    }
    else
    {
        lpsize->cx = WIDTHBAR_WIDTH;
    }
}



void WbWidthsGroup::PushDown(UINT uiIndex)
{
    if( (uiIndex < NUM_OF_WIDTHS))
    {
        //
        // We really should just invalidate the last selected item, if one,
        // and the new selected item, if one.  But heck, there are only 4
        // items, no big deal to paint.
        //
        m_uLast = uiIndex;
        ::InvalidateRect(m_hwnd, NULL, TRUE);
    }
}




void WbWidthsGroup::OnPaint(void) 
{
    PAINTSTRUCT ps;
    int         i;                   
    RECT        rect;
    int         cx, cy;
    int         nPenWidth;
    HBRUSH      hOldBrush;

    ::BeginPaint(m_hwnd, &ps);

    ::GetClientRect(m_hwnd, &rect);
    cx = ::GetSystemMetrics(SM_CXEDGE);
    cy = m_cyItem / 2;

    // First, fill the background of the selected item
    hOldBrush = SelectBrush(ps.hdc, ::GetSysColorBrush(COLOR_3DHILIGHT));

    ::PatBlt(ps.hdc, rect.left, m_uLast * m_cyItem,
        rect.right - rect.left, m_cyItem, PATCOPY);

    rect.right -= rect.left + 2*cx;

    // Now, use the black brush
    SelectBrush(ps.hdc, ::GetStockObject(BLACK_BRUSH));

    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        nPenWidth = g_PenWidths[i];

        ::PatBlt(ps.hdc, cx, rect.top + (m_cyItem - nPenWidth) / 2,
            rect.right, nPenWidth, PATCOPY);

        rect.top += m_cyItem;
    }

    SelectBrush(ps.hdc, hOldBrush);

    // Finish painting
    ::EndPaint(m_hwnd, &ps);
}



//
// ItemFromPoint()
// Returns which item, in the client, is under the point.
//
int WbWidthsGroup::ItemFromPoint(int x, int y) const
{
    int iItem;

    iItem = y / m_cyItem;

    // If it's in the border above the first item, pin it.
    if (iItem < 0)
        iItem = 0;

    // If it's in the border below the last item, pin it.
    if (iItem >= (IDM_WIDTHS_END - IDM_WIDTHS_START))
        iItem = (IDM_WIDTHS_END - IDM_WIDTHS_START - 1);

    return(iItem + IDM_WIDTHS_START);
}


//
// GetItemRect()
// Gets the client-relative rectangle of an item
//
void WbWidthsGroup::GetItemRect(int iItem, LPRECT lprc) const
{
    ::GetClientRect(m_hwnd, lprc);
    
    lprc->top = (iItem - IDM_WIDTHS_START) * m_cyItem;
    lprc->bottom = lprc->top + m_cyItem;
}


//
// OnLButtonDown()
//
void WbWidthsGroup::OnLButtonDown(int x, int y)
{
    int iItem;

    iItem = ItemFromPoint(x, y);
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND, 
                    (WPARAM)MAKELONG(iItem, BN_CLICKED),
                    (LPARAM)m_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\wboblist.cpp ===
// PRECOMP
#include "precomp.h"


POSITION CWBOBLIST::AddHead(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pHead)
	{
		if (posRet = new COBNODE)
		{
			posRet->pNext = m_pHead;
			posRet->pItem = pItem;
			m_pHead = posRet;
		}
	}
	else
	{
		ASSERT(!m_pTail);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pHead->pItem = pItem;
			m_pHead->pNext = NULL;
		}
	}

	return m_pHead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\chatldr.cpp ===
#include "precomp.h"

CHATLoader  *g_pCHATLoader = NULL;
CChatObj	*g_pChatObj = NULL;
DWORD 		g_dwWorkThreadID = 0;
CNmChatCtl	*g_pChatWindow = NULL;
HANDLE      g_hWorkThread = NULL;
BOOL        g_fShutdownByT120 = FALSE;

DWORD __stdcall CHATWorkThreadProc(LPVOID lpv);


T120Error CALLBACK CreateAppletLoaderInterface
(
    IAppletLoader     **ppOutIntf
)
{
    if (NULL != ppOutIntf)
    {
        if (NULL == g_pCHATLoader)
        {
			DBG_SAVE_FILE_LINE
            *ppOutIntf = (IAppletLoader *) new CHATLoader();
            return ((NULL != *ppOutIntf) ? T120_NO_ERROR : T120_ALLOCATION_FAILURE);
        }
        return T120_ALREADY_INITIALIZED;
    }
    return T120_INVALID_PARAMETER;
}



//
// Chat Applet Loader
//

CHATLoader::CHATLoader(void)
:
    CRefCount(MAKE_STAMP_ID('C','H','L','D'))
{
	ASSERT(NULL == g_pCHATLoader);

	g_pCHATLoader = this;

}


CHATLoader::~CHATLoader(void)
{
    g_pCHATLoader = NULL;
}


//
// Create the work thread and wait for its being started.
//
APPLDR_RESULT CHATLoader::AppletStartup
(
    BOOL            fNoUI
)
{
    APPLDR_RESULT eRet = APPLDR_FAIL;
    if (0 == g_dwWorkThreadID)
    {
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            g_hWorkThread = ::CreateThread(NULL, 0, CHATWorkThreadProc, hSync, 0, &g_dwWorkThreadID);
            if (NULL != g_hWorkThread)
            {
                ::WaitForSingleObject(hSync, 5000); // 5 seconds
	             eRet = APPLDR_NO_ERROR;
            }
            ::CloseHandle(hSync);
        }
    }

	return  eRet;

}

//
APPLDR_RESULT CHATLoader::AppletCleanup
(
    DWORD           dwTimeout
)
{

	if(g_pChatWindow)
	{
		//
		// Last change to save
		//
		int rc = g_pChatWindow->QueryEndSession();
		if(rc == IDCANCEL)
		{
			return APPLDR_CANCEL_EXIT;
		}
	}

    g_fShutdownByT120 = TRUE;

    ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_CLOSING);

    // notify the work thread to exit
    if(g_pChatWindow)
    {
	    ::PostMessage(g_pChatWindow->GetHandle(), WM_CLOSE, 1, 0);
	}

    // wait for the worker thread's going down
    ::WaitForSingleObject(g_hWorkThread, dwTimeout);

    return APPLDR_NO_ERROR;
}


APPLDR_RESULT CHATLoader::AppletQuery(APPLET_QUERY_ID eQueryId)
{
    // Do nothing here
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CHATLoader::OnNM2xNodeJoin(void)
{
    // Invoke CHAT on NM2.x nodes
    if (NULL != g_pChatObj)
    {
        g_pChatObj->InvokeApplet();
    }
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CHATLoader::AppletInvoke
(
    BOOL            fRemote,
    T120ConfID      nConfID,
    LPSTR           pszCmdLine
)
{

	if(g_pChatWindow)
	{
		PostMessage(g_pChatWindow->GetHandle(), WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);
	}

    return APPLDR_NO_ERROR;
}


void CHATLoader::ReleaseInterface(void)
{
    Release();
}


DWORD __stdcall CHATWorkThreadProc(LPVOID lpv)
{
	HRESULT hr = S_OK;

	DBG_SAVE_FILE_LINE
	g_pChatObj = new CChatObj();
	if (!g_pChatObj)
	{
		ERROR_OUT(("Can't create g_pChatObj"));
		return S_FALSE;
	}

	DBG_SAVE_FILE_LINE
	g_pChatWindow = new CNmChatCtl();
	if (!g_pChatWindow)
	{
		ERROR_OUT(("Can't create CNmChatCtl"));
		return S_FALSE;
	}

	::SetEvent((HANDLE) lpv);

	::T120_AppletStatus(APPLET_ID_CHAT, APPLET_WORK_THREAD_STARTED);

	PostMessage(g_pChatWindow->GetHandle(), WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);

	//
	// MESSAGE LOOP
	//
	if (S_OK == hr)
	{
		MSG	 msg;
		
		while (::GetMessage(&msg, NULL, NULL, NULL))
		{
			if(!g_pChatWindow->FilterMessage(&msg))
			{
		
				::TranslateMessage(&msg);
				::DispatchMessage(&msg);
			}
		}
	}


	if(g_pChatWindow)
	{
        CGenWindow::DeleteStandardPalette();
		delete g_pChatWindow;
		g_pChatWindow = NULL;
	}

	if(g_pChatObj)
	{
		delete  g_pChatObj;
		g_pChatObj = NULL;
	}


	::T120_AppletStatus(APPLET_ID_CHAT, APPLET_WORK_THREAD_EXITED);

	g_dwWorkThreadID = 0;

    if (! g_fShutdownByT120)
    {
        ::FreeLibraryAndExitThread(g_hInstance, 0);
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\user.cpp ===
//
// USER.CPP
// User Class Members
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
// Local macros
//
#define ASSERT_LOCAL_USER() ASSERT(IsLocalUser() == TRUE);


//
// Init()
// This could fail...
//
BOOL WbUser::Init(POM_OBJECT hUser)
{
    ASSERT(hUser != NULL);

    m_hPageCurrent      = WB_PAGE_HANDLE_NULL;
    m_zoomed            = FALSE;
    m_hUser             = hUser;

    m_pRemotePointer = new DCWbGraphicPointer(this);
    if (!m_pRemotePointer)
    {
        ERROR_OUT(("WbUser::Init - failed to create m_pRemotePointer"));
        return(FALSE);
    }

    Refresh();
    return(TRUE);
}


//
//
// Function:    ~WbUser
//
// Purpose:     Destructor
//
//
WbUser::~WbUser(void)
{
        // don't leave any loose ends
        if ((g_pMain != NULL) && (g_pMain->GetLockOwner() == this))
        {
                g_pMain->SetLockOwner(NULL);
        g_pMain->UpdateWindowTitle();
        }

        // Free the remote pointer
        if (m_pRemotePointer != NULL)
        {
                delete m_pRemotePointer;
        m_pRemotePointer = NULL;
        }
}



//
//
// Function:    Refresh
//
// Purpose:     Read the user details and copy them to member variables.
//
//
void WbUser::Refresh(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Refresh");

    ASSERT(m_pRemotePointer);

    // Set the flag indicating whether this is the local user
    POM_OBJECT hLocalUser;
    g_pwbCore->WBP_PersonHandleLocal(&hLocalUser);
    m_bLocalUser = (m_hUser == hLocalUser);

    // Read the external data
    WB_PERSON userDetails;
    UINT uiReturn = g_pwbCore->WBP_GetPersonData(m_hUser, &userDetails);
    if (uiReturn != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }

    // Get the user name
    lstrcpy(m_strName, userDetails.personName);

    // Get the sync flag
    m_bSynced  = (userDetails.synced != FALSE);

    // Get the current page
    m_hPageCurrent = userDetails.currentPage;

    // Get the current position in the page
    m_rectVisible.left   = userDetails.visibleRect.left;
    m_rectVisible.right  = userDetails.visibleRect.right;
    m_rectVisible.top    = userDetails.visibleRect.top;
    m_rectVisible.bottom = userDetails.visibleRect.bottom;

    // Get the pointer active flag. We go directly to the member variable
    // here since the SetActive member of the pointer class would re-write
    // the user information.
    m_pRemotePointer->m_bActive = (userDetails.pointerActive != 0);

    // Get the pointer page
    m_pRemotePointer->SetPage(userDetails.pointerPage);

    // Get the pointer position
    m_pRemotePointer->MoveTo(userDetails.pointerPos.x, userDetails.pointerPos.y);

    // Get the color
    m_color = g_ColorTable[userDetails.colorId % NUM_COLOR_ENTRIES];

    // Set the pointer color
    m_pRemotePointer->SetColor(m_color);
}



//
// Function:    Update
//
// Purpose:     Update the external copy of the user information
//
void WbUser::Update()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Update");

    // Can only update if we are the local user
    ASSERT_LOCAL_USER();

    ASSERT(m_pRemotePointer);

    // Get the local user details
    WB_PERSON userDetails;
    UINT uiReturn;

    uiReturn = g_pwbCore->WBP_GetPersonData(m_hUser, &userDetails);
    if (uiReturn != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }

    // Don't update the name

    // Set the sync flag
    userDetails.synced = (m_bSynced != FALSE);

    // Set the pointer active flag
    userDetails.pointerActive = (m_pRemotePointer->IsActive() != FALSE);

    // Set the page handle for the current page
    userDetails.currentPage = m_hPageCurrent;

    // Set the current position in the page
    userDetails.visibleRect.left   = (short)m_rectVisible.left;
    userDetails.visibleRect.right  = (short)m_rectVisible.right;
    userDetails.visibleRect.top    = (short)m_rectVisible.top;
    userDetails.visibleRect.bottom = (short)m_rectVisible.bottom;

    // Set the pointer page
    userDetails.pointerPage = m_pRemotePointer->Page();

    // Set the pointer position within the page
    POINT   pointerPos;

    m_pRemotePointer->GetPosition(&pointerPos);
    userDetails.pointerPos.x = (short)pointerPos.x;
    userDetails.pointerPos.y = (short)pointerPos.y;

    // Don't update the color

    // Write the user details back to the core
    uiReturn = g_pwbCore->WBP_SetLocalPersonData(&userDetails);
    if (uiReturn != 0)
    {
        // Throw exception
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
        return;
    }
}


//
//
// Function:    PutSyncPosition
//
// Purpose:     Write the sync position from the current position of this
//              user.
//
//
void WbUser::PutSyncPosition(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::PutSyncPosition");

    // Set up a sync object
    WB_SYNC sync;

    sync.length = sizeof(WB_SYNC);

    sync.currentPage        = m_hPageCurrent;
    sync.visibleRect.top    = (short)m_rectVisible.top;         
    sync.visibleRect.left   = (short)m_rectVisible.left;        
    sync.visibleRect.bottom = (short)m_rectVisible.bottom;      
    sync.visibleRect.right  = (short)m_rectVisible.right;       
    sync.zoomed             = (TSHR_UINT16)m_zoomed;

    sync.dataOffset = (TSHR_UINT16)((BYTE *)&(sync.currentPage) - (BYTE *)&sync);

    UINT uiReturn = g_pwbCore->WBP_SyncPositionUpdate(&sync);
    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }
}

//
//
// Function:    GetSyncPosition
//
// Purpose:     Get the position at which this user should be to
//              account for the current sync information. This function
//              assumes that there is a valid sync position available.
//
//
void WbUser::GetSyncPosition(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::GetSyncPosition");

    // Get the current sync position
    WB_SYNC sync;
    UINT uiReturn = g_pwbCore->WBP_SyncPositionGet(&sync);

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }

    TRACE_DEBUG(("Sync page handle = %d", sync.currentPage));

    // If the sync page is not valid, do nothing
    if (sync.currentPage != WB_PAGE_HANDLE_NULL)
    {
        // Get the current sync position
        m_hPageCurrent = sync.currentPage;

        // Now calculate the new visible rectangle
        RECT rectSyncUser;
        rectSyncUser.left   = sync.visibleRect.left;
        rectSyncUser.top    = sync.visibleRect.top;
        rectSyncUser.right  = sync.visibleRect.right;
        rectSyncUser.bottom = sync.visibleRect.bottom;

        // Check the y position of the visible rectangles
        if ((rectSyncUser.bottom - rectSyncUser.top) <= (m_rectVisible.bottom - m_rectVisible.top))
        {
            // The sync rectangle's height is smaller than our visible rectangle's
            if (rectSyncUser.top < m_rectVisible.top)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.top - m_rectVisible.top);
            }
            else if (rectSyncUser.bottom > m_rectVisible.bottom)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.bottom - m_rectVisible.bottom);
            }
        }
        else
        {
            // The sync rectangle is bigger than ours
            if (rectSyncUser.top > m_rectVisible.top)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.top - m_rectVisible.top);
            }
            else if (rectSyncUser.bottom < m_rectVisible.bottom)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.bottom - m_rectVisible.bottom);
            }
        }

        if ((rectSyncUser.right - rectSyncUser.left) <= (m_rectVisible.right - m_rectVisible.left))
        {
            // The sync rectangle's width is smaller than our visible rectangle's
            if (rectSyncUser.left < m_rectVisible.left)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.left - m_rectVisible.left, 0);
            }
            else if (rectSyncUser.right > m_rectVisible.right)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.right - m_rectVisible.right, 0);
            }
        }
        else
        {
            // The sync rectangle is bigger than ours
            if (rectSyncUser.left > m_rectVisible.left)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.left - m_rectVisible.left, 0);
            }
            else if (rectSyncUser.right < m_rectVisible.right)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.right - m_rectVisible.right, 0);
            }
        }

        m_zoomed = sync.zoomed;
    }
}

//
//
// Function:    Sync
//
// Purpose:     Sync the local user. The page and point passed as parameters
//              are used as the current sync position only if there is no
//              current sync position determined by another user.
//
//
void WbUser::Sync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Sync");

    ASSERT_LOCAL_USER();
    ASSERT(m_pRemotePointer);

    // Determine whether any other users are currently synced
    WbUser* pUser = WB_GetFirstUser();
    while (pUser != NULL)
    {
        // If this user is synced, we are done
        if (pUser->IsSynced())
        {
            break;
        }

        // Try the next user
        pUser = WB_GetNextUser(pUser);
    }

    // If we found a synced user, and we don't have the contents lock
    if (   (pUser != NULL)
        && (!WB_GotContentsLock()))
    {
        // Get the sync position from the core
        GetSyncPosition();
    }
    else
    {
        // Set the sync position from our own position
        PutSyncPosition();
    }

    // Update the synced member flag
    m_bSynced = TRUE;

    // Write the user details back to the core
    Update();
}

//
//
// Function:    Unsync
//
// Purpose:     Unsynchronize the users page from other synced users
//
//
void WbUser::Unsync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Unsync");

    ASSERT_LOCAL_USER();

    // Update the local member
    m_bSynced = FALSE;

    // Update the external details
    Update();
}


//
//
// Function:    PutPointer
//
// Purpose:     Turn on the user's remote pointer
//
//
void WbUser::PutPointer(WB_PAGE_HANDLE hPage, POINT point)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::PutPointer");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    ASSERT(m_pRemotePointer);
    m_pRemotePointer->SetActive(hPage, point);
}

//
//
// Function:    RemovePointer
//
// Purpose:     Turn off the user's remote pointer
//
//
void WbUser::RemovePointer(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::RemovePointer");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    // Update the remote pointer members
    ASSERT(m_pRemotePointer);
    m_pRemotePointer->m_bActive = FALSE;
    m_pRemotePointer->m_hPage = WB_PAGE_HANDLE_NULL;

    // Update the external user information
    Update();
}


//
// Function:    IsUsingPointer()
//
BOOL WbUser::IsUsingPointer(void) const
{
    ASSERT(m_pRemotePointer);
    return(m_pRemotePointer->IsActive());
}



//
// Function:    PointerPage()
//
WB_PAGE_HANDLE WbUser::PointerPage(void) const
{
    ASSERT(m_pRemotePointer);
    return(m_pRemotePointer->Page());
}



//
// Function:    GetPointerPosition()
//
void WbUser::GetPointerPosition(LPPOINT lpptPos)
{
    ASSERT(m_pRemotePointer);
    m_pRemotePointer->GetPosition(lpptPos);
}

//
//
// Function:    SetPage
//
// Purpose:     Set the user's current page
//
//
void WbUser::SetPage(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Page");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    // Only make the update if it is a change
    if (m_hPageCurrent != hPage)
    {
        // Update the local member
        m_hPageCurrent = hPage;

        // Update the external information
        Update();
    }
}


//
//
// Function:    CurrentPosition
//
// Purpose:     Set the user's current position
//
//
void WbUser::SetVisibleRect(LPCRECT lprcVisible)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::SetVisibleRect");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    // Only make the update if it is a change
    if (!::EqualRect(&m_rectVisible, lprcVisible))
    {
        // Update the local member
        m_rectVisible = *lprcVisible;

        // Update the external information
        Update();
    }
}


//
//
// Function:    operator==
//
// Purpose:     Return TRUE if the specified user is the same as this user
//
//
BOOL WbUser::operator==(const WbUser& user) const
{
    return (m_hUser == user.m_hUser);
}

//
//
// Function:    operator!=
//
// Purpose:     Return FALSE if the specified user is the same as this user
//
//
BOOL WbUser::operator!=(const WbUser& user) const
{
  return (!((*this) == user));
}

//
//
// Function:    operator=
//
// Purpose:     Copy the specified user to this one
//
//
WbUser& WbUser::operator=(const WbUser& user)
{
    // Save the new handles
    m_hUser   = user.m_hUser;

    // Read the details
    Refresh();

    return (*this);
}

//
//
// Function:    HasContentsLock
//
// Purpose:     Check whether this user has the whiteboard contents lock
//
//
BOOL WbUser::HasContentsLock(void) const
{
    // call the core to find out if we have the lock
    return (WB_LockUser() == this);
}



//
//
// Function:    WbUserList::Clear
//
// Purpose:     Clear the user handle map, removing all user objects
//
//
void WbUserList::Clear(void)
{
    // Delete all the user objects in the user map
    WbUser* pUser;
    POM_OBJECT hUser;

    ASSERT(g_pUsers);
        POSITION position = g_pUsers->GetHeadPosition();

        while (position)
        {
                POSITION posSav = position;
                pUser = (WbUser*)g_pUsers->GetNext(position);
                
                if (pUser != NULL)
                {
                delete pUser;
                }

                g_pUsers->RemoveAt(posSav);
        }

    // Remove all the map entries
    EmptyList();
}


//
//
// Function:    ~WbUserList
//
// Purpose:     Destructor
//
//
WbUserList::~WbUserList(void)
{
    // Delete all the user objects in the user map
    Clear();
}



//
//
// Function:    LockUser
//
// Purpose:     Return a user object showing who has the lock
//
//
WbUser* WB_LockUser(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_LockUser");

    // Get the lock status from the core (cannot fail)
    POM_OBJECT    hLockUser;
    WB_LOCK_TYPE   lockType;

    lockType = g_pwbCore->WBP_LockStatus(&hLockUser);

    // Build a result
    WbUser* pUserResult = NULL;
    if (lockType != WB_LOCK_TYPE_NONE)
    {
        pUserResult = WB_GetUser(hLockUser);
    }

    return pUserResult;
}


//
//
// Function:    Locked
//
// Purpose:     Return TRUE if another user has a lock (contents or page).
//              NOTE that the page order lock implies the contents are
//              locked.
//
//
BOOL WB_Locked(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) != WB_LOCK_TYPE_NONE)
          && (WB_LocalUser() != WB_LockUser()));
}

//
//
// Function:    ContentsLocked
//
// Purpose:     Return TRUE if another user has the contents lock
//
//
BOOL WB_ContentsLocked(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) == WB_LOCK_TYPE_CONTENTS)
          && (WB_LocalUser() != WB_LockUser()));
}


//
//
// Function:    GotLock
//
// Purpose:     Return TRUE if the local user has a lock
//
//
BOOL WB_GotLock(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) != WB_LOCK_TYPE_NONE)
          && (WB_LocalUser() == WB_LockUser()));
}

//
//
// Function:    GotContentsLock
//
// Purpose:     Return TRUE if the local user has the contents lock
//
//
BOOL WB_GotContentsLock(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) == WB_LOCK_TYPE_CONTENTS)
          && (WB_LocalUser() == WB_LockUser()));
}



//
//
// Function:    PresentationMode
//
// Purpose:     Return TRUE if the whiteboard is in presentation mode, i.e.
//              another user has the contents lock, and is synced.
//
//
BOOL WB_PresentationMode(void)
{
    return (   (WB_ContentsLocked())
          && (WB_LockUser() != NULL)
          && (WB_LockUser()->IsSynced()));
}



//
//
// Function:    GetUser
//
// Purpose:     Return a pointer to a user object from a user handle
//
//
WbUser* WB_GetUser(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_GetFirstUser");

    // Set up a return value
    WbUser* pUserResult = NULL;

    // if the user handle is null, we return a null object pointer
    if (hUser != NULL)
    {
        // Look the user up in the internal map
        ASSERT(g_pUsers);
                POSITION position = g_pUsers->GetHeadPosition();

                BOOL bFound = FALSE;
                while (position)
                {
                        pUserResult = (WbUser*)g_pUsers->GetNext(position);
                        if (hUser == pUserResult->Handle())
                        {
                                return pUserResult;
                        }
                }

        // The user is not yet in our map
        pUserResult = new WbUser();
        if (!pUserResult)
        {
            ERROR_OUT(("Couldn't allocate user object for 0x%08x", hUser));
        }
        else
        {
            if (!pUserResult->Init(hUser))
            {
                ERROR_OUT(("Couldn't init user object for 0x%08x", hUser));
                delete pUserResult;
                pUserResult = NULL;
            }
            else
            {
                // Add the new user to the internal map
                g_pUsers->AddTail(pUserResult);
            }
        }
    }

    return pUserResult;
}

//
//
// Function:    GetFirstUser
//
// Purpose:     Return the first user in the call
//
//
WbUser* WB_GetFirstUser(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_GetFirstUser");

    // Get the handle of the first user (cannot fail)
    POM_OBJECT hUser;
    g_pwbCore->WBP_PersonHandleFirst(&hUser);

    // Get a pointer to the user object for this handle
    WbUser* pUser = WB_GetUser(hUser);

    return pUser;
}

//
//
// Function:    GetNextUser
//
// Purpose:     Return the next user in the call
//
//
WbUser* WB_GetNextUser(const WbUser* pUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_GetNextUser");
    ASSERT(pUser != NULL);

    // Get the handle of the next user
    POM_OBJECT hNextUser;
    UINT uiReturn = g_pwbCore->WBP_PersonHandleNext(pUser->Handle(),
                                           &hNextUser);

    WbUser* pUserResult = NULL;
    if (uiReturn == 0)
    {
        pUserResult = WB_GetUser(hNextUser);
    }

    return pUserResult;
}

//
//
// Function:    LocalUser
//
// Purpose:     Return an object representing the local user
//
//
WbUser* WB_LocalUser(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_LocalUser");

    // Get the local user handle (cannot fail)
    POM_OBJECT hUser;
    g_pwbCore->WBP_PersonHandleLocal(&hUser);

    return WB_GetUser(hUser);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\msconfwb\user.hpp ===
//
// USER.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __USER_HPP_
#define __USER_HPP_


//
//
// Class:   WbUser
//
// Purpose: User object recorder
//
//
class DCWbGraphicPointer;

class WbUser
{
public:
    //
    // Destructor
    //
    ~WbUser(void);

    //
    // Initialize
    //
    BOOL Init(POM_OBJECT hUser);

    //
    // Return the user handle
    //
    POM_OBJECT Handle(void) const { return(m_hUser);}

    //
    // Refresh the user details
    //
    void Refresh(void);

    //
    // Update the external copy of the user information
    //
    void Update(void);

    //
    // Return the user name
    //
    LPCSTR Name(void) const { return(m_strName); }

    //
    // Synchronize the users page with other synced users
    //
    void Sync(void);
    void Unsync(void);

    //
    // Update the user's position from the sync position. This does not
    // change the sync position.
    //
    void GetSyncPosition(void);

    //
    // Update the sync position from the user's current position
    //
    void PutSyncPosition(void);

    //
    // Return a remote pointer object for this user
    //
    DCWbGraphicPointer* GetPointer(void) { return(m_pRemotePointer); }

    //
    // Put the user's remote pointer at the position specified
    //
    void PutPointer(WB_PAGE_HANDLE hPage, POINT point);

    //
    // Remove the user's remote pointer
    //
    void RemovePointer(void);

    //
    // Return TRUE if the user is synced
    //
    BOOL IsSynced(void) const { return m_bSynced; }

    //
    // Return TRUE if the user has the contents lock
    //
    BOOL HasContentsLock(void) const;

    //
    // Return TRUE if the user has their remote pointer active
    //
    BOOL IsUsingPointer(void) const;

    //
    // Return the current page of the user
    //
    WB_PAGE_HANDLE Page(void) const {return m_hPageCurrent; }
    void SetPage(WB_PAGE_HANDLE hPage);

    //
    // Return the current position within the page of the user
    //
    void  GetVisibleRect(LPRECT lprc) { *lprc = m_rectVisible; }
    void  SetVisibleRect(LPCRECT lprc);

    //
    // Return the page of the user's pointer
    //
    WB_PAGE_HANDLE PointerPage(void) const;

    //
    // Return the position of the user's pointer
    //
    void GetPointerPosition(LPPOINT lpptPos);

    //
    // Return the user's color
    //
    COLORREF Color(void) const { return(m_color); }

    //
    // Return TRUE if this is the local user
    //
    BOOL IsLocalUser(void) const { return(m_bLocalUser); }

    //
    // Operators
    //
    virtual WbUser& operator=(const WbUser& user);
    virtual BOOL operator!=(const WbUser& user) const;
    virtual BOOL operator==(const WbUser& user) const;

    //
    // Set zoom/unzoom state
    //
    void Zoom(void) { m_zoomed = TRUE; }
    void Unzoom(void) { m_zoomed = FALSE; }
    BOOL GetZoom(void) const { return(m_zoomed); }

protected:
    //
    // Core access handle
    //
    POM_OBJECT  m_hUser;

    //
    // Flag indicating Whether this is the local user
    //
    BOOL        m_bLocalUser;

    BOOL        m_zoomed;

    //
    // Local copies of the user information
    //
    char        m_strName[TSHR_MAX_PERSON_NAME_LEN];
    BOOL        m_bSynced;
    WB_PAGE_HANDLE  m_hPageCurrent;
    RECT        m_rectVisible;
    COLORREF    m_color;

    //
    // Graphic pointer associated with this user
    //
    DCWbGraphicPointer* m_pRemotePointer;
};


//
//
// Class:   WbUserList
//
// Purpose: Map from user handles to user object pointers
//
//
class WbUserList : public COBLIST
{
public:

    //
    // Destructor
    //
    ~WbUserList(void);

    //
    // Clear all entries from the map, deleting the associated object
    //
    void Clear(void);
};



//
// Return lock status
//
BOOL WB_Locked(void);
BOOL WB_ContentsLocked(void);
BOOL WB_GotLock(void);
BOOL WB_GotContentsLock(void);
BOOL WB_PresentationMode(void);



//
// Return an object representing the local user
//
WbUser* WB_LocalUser(void);

//
// Retrieving users
//
WbUser* WB_GetUser(POM_OBJECT hUser);
WbUser* WB_GetFirstUser(void);
WbUser* WB_GetNextUser(const WbUser* pUser);

//
// Return an object representing the user who has the lock
//
WbUser* WB_LockUser(void);




#endif // __USER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\chatldr.h ===
#ifndef _Chat_Loader_H_
#define _Chat_Loader_H_

#include <iappldr.h>


class CHATLoader : public CRefCount, public IAppletLoader
{
public:

    CHATLoader(void);
    ~CHATLoader(void);
    
    // IAppletLoader methods
    STDMETHOD_(void,  ReleaseInterface)(void);
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(BOOL fNoUI);
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(DWORD dwTimeout);
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(BOOL fRemote, T120ConfID nConfID, LPSTR pszCmdLine);
    STDMETHOD_(APPLDR_RESULT,  AppletQuery)(APPLET_QUERY_ID eQueryId);
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(void);
};


#endif // _Chat_Loader_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\comboboxex.cpp ===
#include "precomp.h"
#include "ComboBoxEx.h"

int ComboBoxEx_FindMember( HWND hwnd, int iStart, MEMBER_CHANNEL_ID *pMemberID)
{
	int iSize = ComboBoxEx_GetCount( hwnd );

	COMBOBOXEXITEM cbexFind;

	if( iStart < 0 )
	{
		iStart = 0;
	}

	for( int i = iStart; i < iSize; i++ )
	{
		ClearStruct(&cbexFind);
		cbexFind.iItem = i;
		cbexFind.mask = CBEIF_LPARAM;

		if( ComboBoxEx_GetItem( hwnd, &cbexFind ) )
		{
			MEMBER_CHANNEL_ID *_pMemberID;
			_pMemberID = (MEMBER_CHANNEL_ID*)cbexFind.lParam;
			if( _pMemberID != pMemberID ) continue;
		}
		else
		{
			return -1;
		}

		return i;
	}

	return -1;
}


T120NodeID ComboBoxEx_GetNodeIDFromSendID( HWND hwnd, T120UserID userID )
{
	int iSize = ComboBoxEx_GetCount( hwnd );

	COMBOBOXEXITEM cbexFind;

	int	iStart = 0;

	for( int i = iStart; i < iSize; i++ )
	{
		ClearStruct(&cbexFind);
		cbexFind.iItem = i;
		cbexFind.mask = CBEIF_LPARAM;

		if( ComboBoxEx_GetItem( hwnd, &cbexFind ) )
		{
			T120UserID _userID;
			_userID = (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nSendId : 0;
			if( userID != _userID ) continue;
		}
		else
		{
			return 0;
		}

		return (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nNodeId : 0;
	}

	return 0;
}


T120NodeID ComboBoxEx_GetNodeIDFromPrivateSendID( HWND hwnd, T120UserID userID )
{
	int iSize = ComboBoxEx_GetCount( hwnd );

	COMBOBOXEXITEM cbexFind;

	int	iStart = 0;

	for( int i = iStart; i < iSize; i++ )
	{
		ClearStruct(&cbexFind);
		cbexFind.iItem = i;
		cbexFind.mask = CBEIF_LPARAM;

		if( ComboBoxEx_GetItem( hwnd, &cbexFind ) )
		{
			T120UserID _userID;
			_userID = (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nPrivateSendId : 0;
			if( userID != _userID ) continue;
		}
		else
		{
			return 0;
		}

		return (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nNodeId : 0;
	}

	return 0;
}



void ComboBoxEx_SetHeight( HWND hwnd, int iHeight )
{
	HWND hwndCombo = (HWND)SNDMSG( hwnd, CBEM_GETCOMBOCONTROL, 0, 0 );
	::SetWindowPos( hwndCombo, NULL, 0, 0, 0, iHeight, SWP_NOMOVE | SWP_NOACTIVATE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\comboboxex.h ===
#ifndef _ComboBoxEx_h_
#define _ComboBoxEx_h_

//#include <windowsx.h>

struct MEMBER_CHANNEL_ID;

#define ComboBoxEx_GetCount(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCOUNT, 0L, 0L))
#define ComboBoxEx_GetCurSel(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCURSEL, 0L, 0L))
#define ComboBoxEx_SetCurSel(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))
#define ComboBoxEx_GetComboControl( hHWND ) (HWND)SNDMSG( hHWND, CBEM_GETCOMBOCONTROL, 0, 0 )
#define ComboBoxEx_SetImageList( hHWND, iIMAGELIST ) SNDMSG(hHWND,CBEM_SETIMAGELIST,0,(LPARAM)iIMAGELIST)
#define ComboBoxEx_InsertItem( hHWND, lpcCBItem ) (int)SNDMSG( hHWND, CBEM_INSERTITEM, 0, (LPARAM)(const COMBOBOXEXITEM FAR *) lpcCBItem )
#define ComboBoxEx_GetItem( hHWND, lpcCBItem ) (int)SNDMSG( hHWND, CBEM_GETITEM, 0, (LPARAM) lpcCBItem )
#define ComboBoxEx_DeleteItem( hHWND, iIndex ) (int)SNDMSG( hHWND, CBEM_DELETEITEM, (WPARAM)(int) iIndex, 0 )
#define ComboBoxEx_GetItemHeight( hHWND, iIndex ) (int)SNDMSG( hHWND, CB_GETITEMHEIGHT, (WPARAM)(int)iIndex, 0 )

#define CBEIF_ALL (CBEIF_IMAGE | CBEIF_INDENT | CBEIF_LPARAM | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE | CBEIF_TEXT )

T120NodeID ComboBoxEx_GetNodeIDFromSendID( HWND hwnd, T120UserID userID );
T120NodeID ComboBoxEx_GetNodeIDFromPrivateSendID( HWND hwnd, T120UserID userID);
int ComboBoxEx_FindMember( HWND hwnd, int iStart, MEMBER_CHANNEL_ID *pMemberID );
void ComboBoxEx_SetHeight( HWND hwnd, int iHeight );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\compwnd.h ===
#ifndef __CompWnd_h__
#define __CompWnd_h__

// This is included to get INmApplet and IComponentWnd
#include "NmCtl1.h"

// This is to get the defs for CProxyIComponentWndEvent
#include "CPCompWndEvent.h"

class ATL_NO_VTABLE CComponentWnd : 
	public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CComponentWnd, &CLSID_NmAppletFrame>, 
    public IConnectionPointContainerImpl<CComponentWnd>,
    public CProxyIComponentWndEvent<CComponentWnd>,
    public CWindowImpl<CComponentWnd>,
	public IOleClientSite,
	public IOleInPlaceSite,
    public IComponentWnd,
    public IOleInPlaceFrame,
    public INmAppletClientSite
{

// Some Constants

    CONSTANT( WND_DEFAULT_WIDTH = 500 );
    CONSTANT( WND_DEFAULT_HEIGHT = 300 );
    CONSTANT( TOOLBAR_MASK_COLOR = (RGB(255,   0, 255)) );
    
    enum eWndID { 
                  StatusWndID   = 1,
#if CompWnd_HasFileMenuAndToolbar
                  ReBarWndID,
                  ToolBarWndID 
#endif // CompWnd_HasFileMenuAndToolbar
                };


#if CompWnd_HasFileMenuAndToolbar
    enum eIconIDs {
                    II_FILE_OPEN    = 1,
                    II_FILE_SAVE    = 2,
                    II_EDIT_CUT     = 3,
                    II_EDIT_COPY    = 4,
                    II_EDIT_PASTE   = 5,
                    II_FILE_PRINT   = 6
                  };
#endif // #if CompWnd_HasFileMenuAndToolbar

public:
// Gconstruction / destruction
    CComponentWnd( void );
    ~CComponentWnd( void );
    //static HRESULT CreateInstance( IComponentWnd** ppNewWnd, REFIID riid, bool bCreate );

protected:

BEGIN_COM_MAP(CComponentWnd)
	COM_INTERFACE_ENTRY(IOleClientSite)
    COM_INTERFACE_ENTRY(IOleInPlaceFrame)
	COM_INTERFACE_ENTRY(IOleInPlaceSite)
	COM_INTERFACE_ENTRY2(IOleWindow,IOleInPlaceFrame)
    COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
    COM_INTERFACE_ENTRY(IComponentWnd)
    COM_INTERFACE_ENTRY(INmAppletClientSite)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CComponentWnd)
    CONNECTION_POINT_ENTRY(IID_IComponentWndEvent)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CComponentWnd)
    MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate);
    MESSAGE_HANDLER(WM_COMMAND, OnCommand);
    MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMax);

#if CompWnd_HasFileMenuAndToolbar
    COMMAND_ID_HANDLER(ID_FILE_OPEN, cmdFileOpen ) 
    COMMAND_ID_HANDLER(ID_FILE_SAVE, cmdFileSave )
    COMMAND_ID_HANDLER(ID_FILE_SAVEAS, cmdFileSaveAs )
    COMMAND_ID_HANDLER(ID_FILE_PRINT, cmdFilePrint ) 
    COMMAND_ID_HANDLER(ID_VIEW_TOOLBAR, cmdViewToolBar ) 
#endif //CompWnd_HasFileMenuAndToolbar

    NOTIFY_CODE_HANDLER(TTN_NEEDTEXT, OnNotifyCode_TTN_NEEDTEXT)

ALT_MSG_MAP(StatusWndID)
    MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)

#if CompWnd_HasFileMenuAndToolbar
    ALT_MSG_MAP(ReBarWndID)
        MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)

    ALT_MSG_MAP(ToolBarWndID)
        MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
#endif // CompWnd_HasFileMenuAndToolbar
 
END_MSG_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_COMPWND)


private:

// Message handlers
    LRESULT OnNcDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSize(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnClose(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnCreate(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnActivate(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
	LRESULT OnCommand(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
	LRESULT OnGetMinMax(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
	
    

// Command handlers
#if CompWnd_HasFileMenuAndToolbar
    LRESULT cmdFileOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdFileSave(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdFileSaveAs(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdFilePrint(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
#endif // CompWnd_HasFileMenuAndToolbar

    LRESULT cmdViewStatusBar(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdViewToolBar(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdHelpHelpTopics(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
// Notification handlers
    LRESULT OnNotifyCode_TTN_NEEDTEXT(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IComponentWnd
public:
    STDMETHOD(put_CLSID)(/*[in]*/ REFIID riid );
    STDMETHOD(get_ControlUnknown)(/*[out]*/ LPUNKNOWN* ppUnk );
	STDMETHOD(Create)();
	STDMETHOD(Show)(/*[in]*/ BOOL bShow );
    STDMETHOD(SetFocus)();
    STDMETHOD(Destroy)();
	STDMETHOD(SetWindowPos)(LPCRECT pcRect, UINT nFlags );
	STDMETHOD(GetWindowRect)(LPRECT pRect);
	STDMETHOD(IsChildWindow)(IN HWND hWnd );
	STDMETHOD(ShiftFocus)(IN HWND hWndCur, IN BOOL bForward );


// IOleClientSite
public:
    STDMETHOD(SaveObject)(void);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHOD(GetContainer)(IOleContainer **ppContainer);
    STDMETHOD(ShowObject)(void);
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)(void);

// INmAppletClientSite
public:
    STDMETHOD(SetStatusBarVisible)(BOOL fShow);
	STDMETHOD(SetIcons)(/*[in]*/HICON hIconSmall, /*[in]*/HICON hIconBig );
	STDMETHOD(SetWindowText)(/*[in]*/LPCTSTR lpszCaption );

// IOleInPlaceSite
public:
    STDMETHOD(CanInPlaceActivate)(void);
    STDMETHOD(OnInPlaceActivate)(void);
    STDMETHOD(OnUIActivate)(void);
    STDMETHOD(GetWindowContext)(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc,
		LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD(Scroll)(SIZE scrollExtant);
    STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD(OnInPlaceDeactivate)( void);
    STDMETHOD(DiscardUndoState)( void);
    STDMETHOD(DeactivateAndUndo)( void);
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);


// IOleWindow
public:
    STDMETHOD (GetWindow) (HWND * phwnd);
    STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);

// IOleInPlaceUIWindow
public:
    STDMETHOD (GetBorder)(LPRECT lprectBorder);
    STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                LPCOLESTR lpszObjName);

//IOleInPlaceFrame 
public:
    STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD (RemoveMenus)(HMENU hmenuShared);
    STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
    STDMETHOD (EnableModeless)(BOOL fEnable);
    STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);


private:
    // Helper Fns
    HRESULT _CreateStatusBar( void );
#if CompWnd_HasFileMenuAndToolbar
    HRESULT _CreateReBar( void );
    HRESULT _CreateToolBar( void );
#endif // CompWnd_HasFileMenuAndToolbar
    HIMAGELIST _SetTbImageList( int ImListID, int WndMsg );
    HIMAGELIST _SetTbImageListSpecialCaseFor_TB_SETDISABLEDIMAGELIST( int ImListID );
    HRESULT _GetControlRect( LPRECT prc );
    void _InitMenuAndToolbar( void );
    bool _IsStatusBarVisibleFlagSet( void );
#if CompWnd_HasFileMenuAndToolbar
    bool _IsToolBarVisibleFlagSet( void );
    bool _IsReBarVisibleFlagSet( void );
#endif// CompWnd_HasFileMenuAndToolbar
    HRESULT _SetMenuItemCheck( UINT idItem, bool bChecked = true  );

protected:
// Data members    
    IOleInPlaceActiveObject*    m_pCtlInPlaceActiveObject;
    bool                        m_bSharedMenuActive;
    HOLEMENU                    m_holemenu;
	IOleObject*                 m_pOleObject;
    CComPtr<INmApplet>          m_spNmApplet;
	bool                        m_bInPlaceActive;
    CLSID                       m_ControlCLSID;
    bool                        m_bCLSIDSet;
    CContainedWindow            m_hWndStatusBar;
#if CompWnd_HasFileMenuAndToolbar
    CContainedWindow            m_hWndReBar;
    CContainedWindow            m_hWndToolBar;
#endif // CompWnd_HasFileMenuAndToolbar

    HIMAGELIST                  m_himlTbButtonNormal;
	HIMAGELIST                  m_himlTbButtonHot;
	HIMAGELIST                  m_himlTbButtonDisabled;
	
    int                         m_cxToolBarButton;
    int                         m_cyToolBarButton;
    int                         m_cxToolBarButtonBitmap;
    int                         m_cyToolBarButtonBitmap;
    int                         m_IDToolbarBitmap;
    int                         m_IDToolbarBitmapHot;

    RECT                        m_rcComponentToolbarSpace;
};


inline HRESULT MoveMenuToSharedMenu( HMENU hMenu, HMENU hMenuShared, int MenuBarIndex, int InsertionIndex )
{
    DBGENTRY(MoveMenuToSharedMenu);
    HRESULT hr = S_OK;

    if( IsMenu( hMenu ) && IsMenu( hMenuShared ) )
    {
        TCHAR szMenuItem[ MAX_PATH ] = TEXT("");
        int cbMenuItem = 0;
    
        MENUITEMINFO mii;
        ClearStruct( &mii );
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_DATA | MIIM_SUBMENU | MIIM_TYPE;
        mii.fType = MFT_STRING;

        cbMenuItem = GetMenuString( hMenu, MenuBarIndex, szMenuItem, MAX_PATH, MF_BYPOSITION );
        if( 0 != cbMenuItem )
        {
            mii.cch = 1 + cbMenuItem;
            mii.dwTypeData = szMenuItem;
            mii.hSubMenu = GetSubMenu( hMenu, MenuBarIndex );
                
            RemoveMenu( hMenu, MenuBarIndex, MF_BYPOSITION );

            if( 0 == InsertMenuItem( hMenuShared, InsertionIndex, TRUE, &mii ) )
            {
                ERROR_OUT(("InsertMenuItem failed"));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            ERROR_OUT(("GetMenuString failed"));
            hr = E_FAIL;
        }
    }
    else
    {
        ERROR_OUT(("Passed a bad menu handle"));
        hr = E_HANDLE;
    }

    DBGEXIT_HR( MoveMenuToSharedMenu, hr );
    return hr;
}


#endif // __CompWnd_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\contain.h ===
//////////////////////////////////////////////////////////////////////////
//
//  container.h
//
//      This file contains the complete class specification of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _CONTAINER_H_
#define _CONTAINER_H_

#include <ocidl.h>
#include <docobj.h>
#include <atlbase.h>

class CContainer : public IOleClientSite, 
                  public IOleInPlaceSite,
                  public IOleInPlaceFrame,
                  public IOleControlSite,
                  public IDispatch, 
                  public IOleCommandTarget
{
    private:
        ULONG       m_cRefs;        // ref count
        HWND        m_hwnd;         // window handle of the container
        HWND        m_hwndStatus;   // status window handle
        IUnknown    *m_punk;        // IUnknown of contained object
        RECT        m_rect;         // size of control

    public:
        CContainer();
        ~CContainer();

    public:
        // *** IUnknown Methods ***
        STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppvObject);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // *** IOleClientSite Methods ***
        STDMETHOD (SaveObject)();
        STDMETHOD (GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppMk);
        STDMETHOD (GetContainer)(LPOLECONTAINER *ppContainer);
        STDMETHOD (ShowObject)();
        STDMETHOD (OnShowWindow)(BOOL fShow);
        STDMETHOD (RequestNewObjectLayout)();

        // *** IOleWindow Methods ***
        STDMETHOD (GetWindow) (HWND * phwnd);
        STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);

        // *** IOleInPlaceSite Methods ***
        STDMETHOD (CanInPlaceActivate) (void);
        STDMETHOD (OnInPlaceActivate) (void);
        STDMETHOD (OnUIActivate) (void);
        STDMETHOD (GetWindowContext) (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
        STDMETHOD (Scroll) (SIZE scrollExtent);
        STDMETHOD (OnUIDeactivate) (BOOL fUndoable);
        STDMETHOD (OnInPlaceDeactivate) (void);
        STDMETHOD (DiscardUndoState) (void);
        STDMETHOD (DeactivateAndUndo) (void);
        STDMETHOD (OnPosRectChange) (LPCRECT lprcPosRect);

        // *** IOleInPlaceUIWindow Methods ***
        STDMETHOD (GetBorder)(LPRECT lprectBorder);
        STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                    LPCOLESTR lpszObjName);

        // *** IOleInPlaceFrame Methods ***
        STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
        STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
        STDMETHOD (RemoveMenus)(HMENU hmenuShared);
        STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
        STDMETHOD (EnableModeless)(BOOL fEnable);
        STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);

        // *** IOleControlSite Methods ***
        STDMETHOD (OnControlInfoChanged)(void);
        STDMETHOD (LockInPlaceActive)(BOOL fLock);
        STDMETHOD (GetExtendedControl)(IDispatch **ppDisp);
        STDMETHOD (TransformCoords)(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags);
        STDMETHOD (TranslateAccelerator)(LPMSG pMsg, DWORD grfModifiers);
        STDMETHOD (OnFocus)(BOOL fGotFocus);
        STDMETHOD (ShowPropertyFrame)(void);

        // *** IDispatch Methods ***
        STDMETHOD (GetIDsOfNames)(REFIID riid, OLECHAR FAR* FAR* rgszNames,	unsigned int cNames, LCID lcid,	DISPID FAR* rgdispid);
        STDMETHOD (GetTypeInfo)(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
        STDMETHOD (GetTypeInfoCount)(unsigned int FAR * pctinfo);
        STDMETHOD (Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr);

        // *** IOleCommandTarget Methods ***
        STDMETHOD (QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD  prgCmds[  ], OLECMDTEXT *pCmdText);
        STDMETHOD (Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);


    public:
        HRESULT add(BSTR clsid);
        void remove();
        void setParent(HWND hwndParent);
        void setLocation(int x, int y, int width, int height);
        void setVisible(BOOL fVisible);
        void setFocus(BOOL fFocus);
        void setStatusWindow(HWND hwndStatus);
        HRESULT translateKey(MSG *pmsg);
        IDispatch *getDispatch();
        IUnknown * getUnknown();

        HRESULT InPlaceActivate( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\contain.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  container.cpp
//
//      This file contains the complete implementation of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include <shlguid.h>

#include "contain.h"

/**
 *  This method is the constructor for the CContainer object. 
 */
CContainer::CContainer()
{
    m_cRefs     = 1;
    m_hwnd      = NULL;
    m_punk      = NULL;

    memset(&m_rect, 0, sizeof(m_rect));
}

/** 
 *  This method is the destructor for the CContainer object.
 */
CContainer::~CContainer()
{
    if (m_punk)
    {
        m_punk->Release();
        m_punk=NULL;
    }
}

/**
 *  This method is called when the caller wants an interface pointer.
 *
 *  @param      riid        The interface being requested.
 *  @param      ppvObject   The resultant object pointer.
 *
 *  @return     HRESULT     S_OK, E_POINTER, E_NOINTERFACE
 */
STDMETHODIMP CContainer::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (!ppvObject)
        return E_POINTER;

//~    if (IsEqualIID(riid, IID_IOleClientSite))
//~        *ppvObject = (IOleClientSite *)this;
//~    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
    if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *ppvObject = (IOleInPlaceSite *)this;
//~    else if (IsEqualIID(riid, IID_IOleInPlaceFrame))
//~        *ppvObject = (IOleInPlaceFrame *)this;
//~    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
//~        *ppvObject = (IOleInPlaceUIWindow *)this;
//~    else if (IsEqualIID(riid, IID_IOleControlSite))
//~        *ppvObject = (IOleControlSite *)this;
    else if (IsEqualIID(riid, IID_IOleWindow))
        *ppvObject = (IOleWindow *)(IOleInPlaceFrame *)this;
//~    else if (IsEqualIID(riid, IID_IDispatch))
//~        *ppvObject = (IDispatch *)this;
    else if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = this;
//~    else if (IsEqualIID(riid, IID_IOleCommandTarget))
//~        *ppvObject = (IOleCommandTarget *)this;
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/**
 *  This method increments the current object count.
 *
 *  @return     ULONG       The new reference count.
 */
ULONG CContainer::AddRef(void)
{
    return ++m_cRefs;
}

/**
 *  This method decrements the object count and deletes if necessary.
 *
 *  @return     ULONG       Remaining ref count.
 */
ULONG CContainer::Release(void)
{
    if (--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

// ***********************************************************************
//  IOleClientSite
// ***********************************************************************

HRESULT CContainer::SaveObject()
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppMk)
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetContainer(LPOLECONTAINER * ppContainer)
{
    return E_NOINTERFACE;
}

HRESULT CContainer::ShowObject()
{
    return S_OK;
}

HRESULT CContainer::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

HRESULT CContainer::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleWindow
// ***********************************************************************

HRESULT CContainer::GetWindow(HWND * lphwnd)
{
    if (!IsWindow(m_hwnd))
        return S_FALSE;

    *lphwnd = m_hwnd;
    return S_OK;
}

HRESULT CContainer::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceSite
// ***********************************************************************

HRESULT CContainer::CanInPlaceActivate(void)
{
    return S_OK;
}

HRESULT CContainer::OnInPlaceActivate(void)
{
    return S_OK;
}

HRESULT CContainer::OnUIActivate(void)
{
    return S_OK;
}

HRESULT CContainer::GetWindowContext (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppIIPUIWin,
                                  LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
//~    *ppFrame = (IOleInPlaceFrame *)this;
    *ppFrame = NULL;
    *ppIIPUIWin = NULL;

    RECT rect;
    GetClientRect(m_hwnd, &rect);
    lprcPosRect->left       = 0;
    lprcPosRect->top        = 0;
    lprcPosRect->right      = rect.right;
    lprcPosRect->bottom     = rect.bottom;

    CopyRect(lprcClipRect, lprcPosRect);

    lpFrameInfo->cb             = sizeof(OLEINPLACEFRAMEINFO);
    lpFrameInfo->fMDIApp        = FALSE;
    lpFrameInfo->hwndFrame      = m_hwnd;
    lpFrameInfo->haccel         = 0;
    lpFrameInfo->cAccelEntries  = 0;

//~    (*ppFrame)->AddRef();
    return S_OK;
}

HRESULT CContainer::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;
}

HRESULT CContainer::OnUIDeactivate(BOOL fUndoable)
{
    return E_NOTIMPL;
}

HRESULT CContainer::OnInPlaceDeactivate(void)
{
    return S_OK;
}

HRESULT CContainer::DiscardUndoState(void)
{
    return E_NOTIMPL;
}

HRESULT CContainer::DeactivateAndUndo(void)
{
    return E_NOTIMPL;
}

HRESULT CContainer::OnPosRectChange(LPCRECT lprcPosRect)
{
    return S_OK;
}

// ***********************************************************************
//  IOleInPlaceUIWindow
// ***********************************************************************

HRESULT CContainer::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT CContainer::RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceFrame
// ***********************************************************************

HRESULT CContainer::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return E_NOTIMPL;
}

HRESULT CContainer::RemoveMenus(HMENU hmenuShared)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetStatusText(LPCOLESTR pszStatusText)
{
    char status[MAX_PATH];              // ansi version of status text

    if (NULL == pszStatusText)
        return E_POINTER;

    WideCharToMultiByte(CP_ACP, 0, pszStatusText, -1, status, MAX_PATH, NULL, NULL);

    if (IsWindow(m_hwndStatus))
        SendMessage(m_hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)status);

    return (S_OK);
}

HRESULT CContainer::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

HRESULT CContainer::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    return S_FALSE;
}

// ***********************************************************************
//  IOleControlSite
// ***********************************************************************

HRESULT CContainer::OnControlInfoChanged()
{
    return E_NOTIMPL;
}

HRESULT CContainer::LockInPlaceActive(BOOL fLock)
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetExtendedControl(IDispatch **ppDisp)
{
    if (ppDisp == NULL)
        return E_INVALIDARG;

    *ppDisp = (IDispatch *)this;
    (*ppDisp)->AddRef();

    return S_OK;
}

HRESULT CContainer::TransformCoords(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags)
{
    return E_NOTIMPL;
}

HRESULT CContainer::TranslateAccelerator(LPMSG pMsg, DWORD grfModifiers)
{
    return S_FALSE;
}

HRESULT CContainer::OnFocus(BOOL fGotFocus)
{
    return E_NOTIMPL;
}

HRESULT CContainer::ShowPropertyFrame(void)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IDispatch
// ***********************************************************************

HRESULT CContainer::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)
{
    *rgdispid = DISPID_UNKNOWN;
    return DISP_E_UNKNOWNNAME;
}

HRESULT CContainer::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetTypeInfoCount(unsigned int FAR * pctinfo)
{
    return E_NOTIMPL;
}

HRESULT CContainer::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr)
{
    return DISP_E_MEMBERNOTFOUND;
}

// ***********************************************************************
//  IOleCommandTarget
// ***********************************************************************

HRESULT CContainer::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD  rgCmds[  ], OLECMDTEXT *pCmdText)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    const int SBCMDID_ADDTOFAVORITES = 8;

#if 0
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            switch (rgCmds[i].cmdID)
            {            
            case SBCMDID_ADDTOFAVORITES:
                rgCmds[i].cmdf = OLECMDF_ENABLED | OLECMDF_SUPPORTED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
        hres = S_OK;
    }
#endif
    return hres;
}

HRESULT CContainer::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    const int SBCMDID_ADDTOFAVORITES = 8;

#if 0
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SBCMDID_ADDTOFAVORITES:
            TCHAR szURL[2048];
            TCHAR szTitle[MAX_PATH];
            WideCharToMultiByte(CP_ACP, 0, pvaIn->bstrVal, -1, szURL, sizeof(szURL), NULL, NULL);
            WideCharToMultiByte(CP_ACP, 0, pvaOut->bstrVal, -1, szTitle, sizeof(szTitle), NULL, NULL);
            MessageBox(m_hwnd, 
                szURL,
                szTitle,
                MB_OK);
            hres = S_OK;
            break;
        }
    }
#endif
    return hres;
}

// ***********************************************************************
//  Public (non-interface) Methods
// ***********************************************************************

/**
 *  This method will add an ActiveX control to the container. Note, for
 *  now, this CContainer can only have one control.
 *
 *  @param  bstrClsid   The CLSID or PROGID of the control.
 *
 *  @return     HRESULT     S_OK, E_POINTER, E_NOINTERFACE
 */
HRESULT CContainer::add(BSTR bstrClsid)
{
    CLSID   clsid;          // CLSID of the control object
    HRESULT hr;             // return code

    hr = CLSIDFromString(bstrClsid, &clsid);
	if (FAILED(hr))
		return hr;

    hr = CoCreateInstance(clsid, 
                     NULL, 
                     CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                     IID_IUnknown,
                     (PVOID *)&m_punk);
    if (FAILED(hr))
		return hr;
	
	ASSERT(NULL != m_punk);

    IOleObject *pioo;
    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return hr;

    pioo->SetClientSite(this);
    pioo->Release();

    IPersistStreamInit  *ppsi;
    hr = m_punk->QueryInterface(IID_IPersistStreamInit, (PVOID *)&ppsi);
    if (SUCCEEDED(hr))
    {
        ppsi->InitNew();
        ppsi->Release();
    }

	return hr;
}

/**
 *  This method will remove the control from the container.
 *
 *  @return             No return value.
 */
void CContainer::remove()
{
    if (!m_punk)
        return;

    HRESULT             hr;
    IOleObject          *pioo;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (SUCCEEDED(hr))
    {
        pioo->Close(OLECLOSE_NOSAVE);
        pioo->SetClientSite(NULL);
        pioo->Release();
    }

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (SUCCEEDED(hr))
    {
        pipo->UIDeactivate();
        pipo->InPlaceDeactivate();
        pipo->Release();
    }

    m_punk->Release();
    m_punk = NULL;
}

/**
 *  This method sets the parent window. This is used by the container
 *  so the control can parent itself.
 *
 *  @param  hwndParent  The parent window handle.
 *
 *  @return             No return value.
 */
void CContainer::setParent(HWND hwndParent)
{
    m_hwnd = hwndParent;
}

/**
 *  This method will set the location of the control.
 *  
 *  @param      x       The top left.
 *  @param      y       The top right.
 *  @param      width   The width of the control.
 *  @param      height  The height of the control.
 */
void CContainer::setLocation(int x, int y, int width, int height)
{
    m_rect.left     = x;
    m_rect.top      = y;
    m_rect.right    = x + width;
    m_rect.bottom   = y + height;

    if (!m_punk)
        return;

    HRESULT             hr;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (FAILED(hr))
        return;

    pipo->SetObjectRects(&m_rect, &m_rect);
    pipo->Release();
}



HRESULT CContainer::InPlaceActivate( void )
{

    HRESULT hr = E_FAIL;

    if( m_punk )
    {

        CComQIPtr< IOleObject, &IID_IOleObject > spioo( m_punk );

        if( spioo != NULL )
        {
            spioo->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
            spioo->DoVerb(OLEIVERB_HIDE, NULL, this, 0, m_hwnd, &m_rect);
            
        }
    }

    return hr;
    
}


/**
 *  Sets the visible state of the control.
 *
 *  @param  fVisible    TRUE=visible, FALSE=hidden
 *  @return             No return value.
 */
void CContainer::setVisible(BOOL fVisible)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return;
    
    if (fVisible)
    {
        pioo->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->DoVerb(OLEIVERB_SHOW, NULL, this, 0, m_hwnd, &m_rect);

		IOleInPlaceObject   *pipo;
		HRESULT hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
		if (SUCCEEDED(hr))
		{
			pipo->SetObjectRects(&m_rect, &m_rect);
			pipo->Release();
		}
    }
    else
        pioo->DoVerb(OLEIVERB_HIDE, NULL, this, 0, m_hwnd, NULL);

    pioo->Release();
}

/**
 *  This sets the focus to the control (a.k.a. UIActivate)
 *
 *  @param  fFocus      TRUE=set, FALSE=remove
 *
 *  @return             No return value.
 */
void CContainer::setFocus(BOOL fFocus)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    if (fFocus)
    {
        hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
        if (FAILED(hr))
            return;

        pioo->DoVerb(OLEIVERB_UIACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->Release();
    }
}

/**
 *  If the container has an HWND for the status window (must be
 *  common control), then this method is used to tell the container.
 *
 *  @param  hwndStatus  Window handle of the status bar.
 *
 *  @return             No return value.
 */
void CContainer::setStatusWindow(HWND hwndStatus)
{
    m_hwndStatus = hwndStatus;
}

/**
 *  This method gives the control the opportunity to translate and use
 *  key strokes.
 *
 *  @param      msg     Key message.
 *
 *  @return             No return value.
 */
HRESULT CContainer::translateKey(MSG *pmsg)
{
    if (!m_punk)
        return E_FAIL;

    HRESULT                 hr;
    IOleInPlaceActiveObject *pao;

    hr = m_punk->QueryInterface(IID_IOleInPlaceActiveObject, (PVOID *)&pao);
    if (FAILED(hr))
        return hr;

    hr = pao->TranslateAccelerator(pmsg);
    pao->Release();
    return hr;
}

/**
 *  Returns the IDispatch pointer of the contained control. Note, the
 *  caller is responsible for calling IDispatch::Release().
 *
 *  @return             Controls dispatch interface.
 */
IDispatch * CContainer::getDispatch()
{
    if (!m_punk)
        return NULL;

    HRESULT     hr;
    IDispatch   *pdisp;

    hr = m_punk->QueryInterface(IID_IDispatch, (PVOID *)&pdisp);
    return pdisp;
}

/**
 *  Returns the IUnknown interface pointer for the containd control. Note,
 *  the caller is responsible for calling IUnknown::Release().
 *
 *  @return             Controls unknown interface.
 */
IUnknown * CContainer::getUnknown()
{
    if (!m_punk)
        return NULL;

    m_punk->AddRef();
    return m_punk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\containercontrol.h ===
// VidWndCtrl.h : Declaration of the CContainerControl

#ifndef __CONTAINERCONTROL_H_
#define __CONTAINERCONTROL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CContainerControl
class ATL_NO_VTABLE CContainerControl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IContainerControl, &IID_IContainerControl, &LIBID_NmCtl1Lib>,
	public CComControl<CContainerControl>,
	public IPersistStreamInitImpl<CContainerControl>,
	public IPersistPropertyBagImpl<CContainerControl>,
	public IOleControlImpl<CContainerControl>,
	public IOleObjectImpl<CContainerControl>,
	public IOleInPlaceActiveObjectImpl<CContainerControl>,
	public IViewObjectExImpl<CContainerControl>,
	public IOleInPlaceObjectWindowlessImpl<CContainerControl>,
	public ISupportErrorInfo,
	public CComCoClass<CContainerControl, &CLSID_ContainerControl>,
	public IObjectSafetyImpl<CContainerControl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
private:

	CComBSTR m_strProgIDOfControl;
	bool	 m_bInitialized;


public:
	CContainerControl()
	{
		m_bInitialized = false;
		m_bWindowOnly = TRUE;
	}

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

DECLARE_REGISTRY_RESOURCEID(IDR_CONTAINERCONTROL)
DECLARE_NOT_AGGREGATABLE(CContainerControl)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CContainerControl)
	COM_INTERFACE_ENTRY(IContainerControl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_PROP_MAP(CContainerControl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CContainerControl)
	//CHAIN_MSG_MAP(CComControl<CContainerControl>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&IID_IContainerControl,
		};
		for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
		{
			if (InlineIsEqualGUID(*arr[i], riid))
				return S_OK;
		}
		return S_FALSE;
	}

// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// IPersistPropertyBag
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);

// IContainerControl
	STDMETHOD(put_ProgIDOfControl)(IN BSTR strProgIDOfControl );
	STDMETHOD(get_ControlDispatch)(OUT LPDISPATCH* ppDisp );

};

#endif //__CONTAINERCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\cpappletnotify.h ===
#ifndef __CPAppletNotify_h__
#define __CPAppletNotify_h__

#include "CPnmctl1.h"


#endif // __CPAppletNotify_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\cpnmagendaitemnotify.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxyINmAgendaItemNotify
template <class T>
class CProxyINmAgendaItemNotify : public IConnectionPointImpl<T, &DIID_INmAgendaItemNotify, CComDynamicUnkArray>
{
public:
//methods:
//INmAgendaItemNotify : IDispatch
public:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\cpcompwndevent.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxyIComponentWndEvent
template <class T>
class CProxyIComponentWndEvent : public IConnectionPointImpl<T, &IID_IComponentWndEvent, CComDynamicUnkArray>
{
public:

//IComponentWndEvent : IDispatch
public:
	HRESULT Fire_OnClose()
	{
		T* pT = (T*)this;
		pT->Lock();
		HRESULT ret;
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				IComponentWndEvent* pIComponentWndEvent = reinterpret_cast<IComponentWndEvent*>(*pp);
				ret = pIComponentWndEvent->OnClose();
			}
			pp++;
		}
		pT->Unlock();
		return ret;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\makefile.inc ===
#That forces BUILD.EXE to rebuild the rc file when the .