), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
	}
	UNLOCKOBJECT();
}


// For use by this class and derived classes destructors.
void CTopicShop::CTopicBuildQueue::ShutDown()
{
	LOCKOBJECT();
	if (m_bShuttingDown)
	{
		// We have already shut down the topic builder thread, simply exit.
		UNLOCKOBJECT();
		return;
	}

	m_bShuttingDown = true;
	if (m_hThread)
	{
		DWORD RetVal;

		::SetEvent(m_hevBuildRequested);
		UNLOCKOBJECT();

		// Wait for a set period, if failure then log error msg and wait infinite.
		RetVal= WAIT_INFINITE(	m_hevThreadIsShut );
	}
	else 
		UNLOCKOBJECT();
}

// For general use (not part of TopicBuilderTask thread) code.
// Ask for a topic to be built (or rebuilt).  
// INPUT strTopic - name of topic OR HTI TEMPLATE
// INPUT bPriority -  If bPriority is true, move it ahead of any topics/templates 
//	for which this has not been called with bPriority true.  At a gien priority level,
//	toics always come before templates.
// INPUT eCat - indicates whether strTopic is a topic or an HTI template
// This is an asynchronous request that will eventually be fulfilled by TopicBuilderTask thread
void CTopicShop::CTopicBuildQueue::RequestBuild(const CString &strTopic, bool bPriority,
												CatalogCategory eCat )
{
	// Verify that this is a valid category.
	if (eCat != eTopic && eCat != eTemplate)
		return;

	// Make a lower-case version of the topic name.
	CString strTopicLC = strTopic;
	strTopicLC.MakeLower();

	vector<CString> & Priority = (eCat == eTopic) ? 
										m_PriorityBuild : 
										m_PriorityBuildTemplates;
	vector<CString> & NonPriority = (eCat == eTopic) ? 
										m_NonPriorityBuild :
										m_NonPriorityBuildTemplates;

	LOCKOBJECT();

	if ((strTopicLC != m_CurrentlyBuilding) || (eCat != m_eCurrentlyBuilding))
	{
		vector<CString>::iterator it = find(Priority.begin(), Priority.end(), strTopicLC);
		if (it == Priority.end())
		{
			try
			{
				it = find(NonPriority.begin(), NonPriority.end(), strTopicLC);
				if (bPriority)
				{
					if (it != NonPriority.end())
					{
						// it's in the non-priority list.  Get it out of there.
						NonPriority.erase(it);
					}
					// Add it to the priority list
					Priority.push_back(strTopicLC);
				}
				else if (it == NonPriority.end())
				{
					// Add it to the non-priority list
					NonPriority.push_back(strTopicLC);
				}
				// else it's already listed
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str), 
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}
		// else it's already a priority, we can't do more
	}
	// else it's already building, we can't do more
	::SetEvent(m_hevBuildRequested);
	UNLOCKOBJECT();
}

// For use by the TopicBuilderTask thread.  Should only be called when nothing is 
//	currently building.  Caller is responsible to build only one at a time.
// OUTPUT strTopic - name of topic OR HTI TEMPLATE
// OUTPUT eCat - indicates whether strTopic is a topic or an HTI template
// false return indicates invalid request.  
//		non-empty string output strTopic indicates what is currently building
//		empty string output should never happen
// true return indicates valid request:  
//		non-empty string output strTopic indicates what to build
//		empty string output strTopic indicates nothing more to build
// Note that this function has the side effect of changing the _thread_ priority.
bool CTopicShop::CTopicBuildQueue::GetNextToBuild( CString &strTopic, CatalogCategory &eCat )
{
	vector<CString>::iterator it;

	LOCKOBJECT();
	bool bOK = m_CurrentlyBuilding.IsEmpty();
	if (bOK)
	{
		if (!m_PriorityBuild.empty())
		{
			// We have priority topics to build.
			it = m_PriorityBuild.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTopic;
			m_PriorityBuild.erase(it);

			// If there are more priority builds waiting behind this, boost priority
			//	above normal so we get to them ASAP.  Otherwise, normal priority.
			::SetThreadPriority(GetCurrentThread(),
				m_PriorityBuild.empty() ? THREAD_PRIORITY_NORMAL : THREAD_PRIORITY_ABOVE_NORMAL);
		}
		else if (!m_PriorityBuildTemplates.empty())
		{
			// We have priority alternate templates to build.
			it = m_PriorityBuildTemplates.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTemplate;
			m_PriorityBuildTemplates.erase(it);

			// If there are more priority builds waiting behind this, boost priority
			//	above normal so we get to them ASAP.  Otherwise, normal priority.
			::SetThreadPriority(GetCurrentThread(),
				m_PriorityBuildTemplates.empty() ? THREAD_PRIORITY_NORMAL : THREAD_PRIORITY_ABOVE_NORMAL);
		}
		else if (!m_NonPriorityBuild.empty())
		{
			// We have non-priority topics to build.
			it = m_NonPriorityBuild.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTopic;
			m_NonPriorityBuild.erase(it);

			// This is initialization, no one is in a hurry for it, 
			//	let's not burden the system unduly.
			::SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL);
		}
		else if (!m_NonPriorityBuildTemplates.empty())
		{
			// We have non-priority alternate templates to build.
			it = m_NonPriorityBuildTemplates.begin();
			m_CurrentlyBuilding = *it;
			m_eCurrentlyBuilding= eTemplate;
			m_NonPriorityBuildTemplates.erase(it);

			// This is initialization, no one is in a hurry for it, 
			//	let's not burden the system unduly.
			::SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL);
		}
		else 
			::SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);
	}
	strTopic = m_CurrentlyBuilding;
	eCat= m_eCurrentlyBuilding;
	UNLOCKOBJECT();
	return bOK;
}

// Acknowledge that we have finished building the topic previously obtained with GetNextToBuild
// This should be called before GetNextToBuild is called again.
void CTopicShop::CTopicBuildQueue::BuildComplete()
{
	LOCKOBJECT();
	m_CurrentlyBuilding = _T("");
	m_eCurrentlyBuilding= eUnknown;
	UNLOCKOBJECT();
}

// For use by the TopicBuilderTask thread.
// Must be called on TopicBuilderTask thread.  Handles all work of building & publishing 
//	topics driven by the queue contents
void CTopicShop::CTopicBuildQueue::Build()
{
	CString strTopic;
	CatalogCategory eCat;

	while (true)
	{
		LOCKOBJECT();
		SetThreadStatus(eRun);
		if (m_bShuttingDown)
		{
			UNLOCKOBJECT();
			break;
		}
		GetNextToBuild( strTopic, eCat );
		if (strTopic.IsEmpty())
		{
			::ResetEvent(m_hevBuildRequested);
			UNLOCKOBJECT();
			SetThreadStatus(eWait);
			::WaitForSingleObject(m_hevBuildRequested, INFINITE);
			continue;
		}
		else 
			UNLOCKOBJECT();

		if (eCat == eTopic)
		{
			// at this point we have a topic name.  Get access to topic info.
			CTopicCatalog::const_iterator it = m_TopicCatalog.find(strTopic);
			if (it == m_TopicCatalog.end())
			{
				// Asked to initialize a topic that	doesn't have a catalog entry.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T("Asked to build"), 
										strTopic, 
										EV_GTS_UNRECOGNIZED_TOPIC ); 
			}
			else
			{
				CTopicInCatalog & TopicInCatalog = *(it->second);
				const CTopicInfo topicinfo (TopicInCatalog.GetTopicInfo());

				try
				{
					// must create this with new so we can manage it under a reference count regime
					CTopic *ptopic = new CTopic (topicinfo.GetDscFilePath()
												,topicinfo.GetHtiFilePath()
												,topicinfo.GetBesFilePath()
												,topicinfo.GetTscFilePath() );
					if (ptopic->Read())
						TopicInCatalog.Init(ptopic);
					else
					{
						// Release memory.
						delete ptopic;
						TopicInCatalog.Init(NULL);
					}

					TopicInCatalog.TopicInfoIsCurrent();
				}
				catch (bad_alloc&)
				{
					// Note memory failure in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
				}
			}
		}
		else if (eCat == eTemplate)
		{
			// Determine whether the passed in template is in the catalog.
			CTemplateCatalog::const_iterator it = m_TemplateCatalog.find(strTopic);
			if (it == m_TemplateCatalog.end())
			{
				// Asked to initialize a template that doesn't have a catalog entry.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T("Asked to build"), 
										strTopic, 
										EV_GTS_UNRECOGNIZED_TEMPLATE ); 
			}
			else
			{
				CTemplateInCatalog & TemplateInCatalog = *(it->second);
				const CString & strTemplateName = TemplateInCatalog.GetTemplateInfo();

				try
				{
					// must create this with new so we can manage it under a reference count regime
					CAPGTSHTIReader *pTemplate;

					pTemplate= new CAPGTSHTIReader( CPhysicalFileReader::makeReader( strTemplateName ) );
					if (pTemplate->Read())
						TemplateInCatalog.Init( pTemplate );
					else
					{
						// Release memory.
						delete pTemplate;
						TemplateInCatalog.Init( NULL );
					}
				}
				catch (bad_alloc&)
				{
					// Note memory failure in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
				}
			}
		}
		BuildComplete();
	}
	SetThreadStatus(eExiting);
}

// For use by the TopicBuilderTask thread.
void CTopicShop::CTopicBuildQueue::AckShutDown()
{
	LOCKOBJECT();
	::SetEvent(m_hevThreadIsShut);
	UNLOCKOBJECT();
}

//  Main routine of a thread responsible for building and publishing CTopic objects.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CTopicShop::CTopicBuildQueue::TopicBuilderTask(LPVOID lpParams)
{
	reinterpret_cast<CTopicBuildQueue*>(lpParams)->Build();
	reinterpret_cast<CTopicBuildQueue*>(lpParams)->AckShutDown();
	return 0;
}

//////////////////////////////////////////////////////////////////////
// CTopicShop::ThreadStatus
//////////////////////////////////////////////////////////////////////
/* static */ CString CTopicShop::ThreadStatusText(ThreadStatus ts)
{
	switch(ts)
	{
		case eBeforeInit:	return _T("Before Init");
		case eFail:			return _T("Fail");
		case eWait:			return _T("Wait");
		case eRun:			return _T("Run");
		case eExiting:		return _T("Exiting");
		default:			return _T("");
	}
}

//////////////////////////////////////////////////////////////////////
// CTopicShop
// The only functions which need to lock this class are those which modify TopicCatalog.
// TopicBuildQueue has its own protection.
//////////////////////////////////////////////////////////////////////

CTopicShop::CTopicShop() :
	m_TopicBuildQueue( m_TopicCatalog, m_TemplateCatalog ),
	m_hevShopIsOpen(NULL)
{
	m_hevShopIsOpen = ::CreateEvent( 
			NULL, 
			TRUE,  // any number of (working) threads may be released on signal
			FALSE, // initially non-signalled
			NULL);

	if (! m_hevShopIsOpen)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_EVENT );
		
		// Simulate a bad alloc exception in this case.
		// This constructor is only called within the ctor of CDBLoadConfiguration
		// and the allocation of that object is wrapped within a try...catch() block.
		throw bad_alloc();
	}
}

CTopicShop::~CTopicShop()
{
	// Terminate the topic builder thread prior to cleaning up the topics.
	m_TopicBuildQueue.ShutDown();

	if (m_hevShopIsOpen)
		::CloseHandle(m_hevShopIsOpen);

	// Clean up the topics.
	for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
	{
		delete it->second;
	}

	// Clean up the templates.
	for (CTemplateCatalog::const_iterator itu = m_TemplateCatalog.begin(); itu != m_TemplateCatalog.end(); ++itu)
	{
		delete itu->second;
	}
}

// Add a topic to the catalog.  It must eventually be built by TopicBuilderTask thread.
// If topic is already in list identically, no effect.
void CTopicShop::AddTopic(const CTopicInfo & topicinfo)
{
	// our keys into the catalog should be all lower case.  This code is fine, because
	// CTopicInfo::GetNetworkName() is guaranteed to return lower case.
	CString strNetworkName = topicinfo.GetNetworkName();

	LOCKOBJECT();
	CTopicCatalog::const_iterator it = m_TopicCatalog.find(strNetworkName);

	if (it == m_TopicCatalog.end())
	{
		try
		{
			m_TopicCatalog[strNetworkName] = new CTopicInCatalog(topicinfo);
		}
		catch (bad_alloc&)
		{
			// Note memory failure in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		}
	}
	else if (! (topicinfo == it->second->GetTopicInfo()))
	{
		it->second->SetTopicInfo(topicinfo);
		m_TopicBuildQueue.RequestBuild(strNetworkName, false, CTopicBuildQueue::eTopic);

	}
	UNLOCKOBJECT();
}

// Add a template to the catalog.  It must eventually be built by TopicBuilderTask thread.
// If template is already in list, no effect.
void CTopicShop::AddTemplate( const CString & strTemplateName )
{
	LOCKOBJECT();
	if (m_TemplateCatalog.find( strTemplateName ) == m_TemplateCatalog.end())
	{
		try
		{
			m_TemplateCatalog[ strTemplateName ] = new CTemplateInCatalog( strTemplateName );
		}
		catch (bad_alloc&)
		{
			// Note memory failure in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		}
	}
	UNLOCKOBJECT();
}

// if shop is not already open, open it.
void CTopicShop::OpenShop()
{
	::SetEvent(m_hevShopIsOpen);
}


// Request that a topic be built (or rebuilt)
// Typically called in response to either the system detecting a change to the topic 
//	files or from an operator saying "act as if a change has been detected".
// INPUT strTopic names the topic to build.
// if pbAlreadyInCatalog is input non-null, then *pbAlreadyInCatalog returns whether
//	the topic was already known to the system.
void CTopicShop::BuildTopic(const CString & strTopic, bool *pbAlreadyInCatalog /*= NULL*/)
{
	if (pbAlreadyInCatalog)
		*pbAlreadyInCatalog = false;	// initialize

	CTopicInCatalog * pTopic = GetCatalogEntryPtr(strTopic);
	if (pTopic)
	{
		pTopic->CountChange();
		if (pbAlreadyInCatalog)
			*pbAlreadyInCatalog = true;
	}
	m_TopicBuildQueue.RequestBuild( strTopic, false, CTopicBuildQueue::eTopic );
}

// Request that a template be built (or rebuilt)
// Typically called in response to the system detecting a change to the template files.
void CTopicShop::BuildTemplate( const CString & strTemplate )
{
	CTemplateInCatalog * pTemplate = GetTemplateCatalogEntryPtr( strTemplate );
	if (pTemplate)
		pTemplate->CountChange();
	m_TopicBuildQueue.RequestBuild( strTemplate, false, CTopicBuildQueue::eTemplate );
}


CTopicInCatalog * CTopicShop::GetCatalogEntryPtr(const CString & strTopic) const
{
	// Wait for a set period, if failure then log error msg and wait infinite.
	WAIT_INFINITE( m_hevShopIsOpen );
	CTopicCatalog::const_iterator it= m_TopicCatalog.find(strTopic);
	if (it == m_TopicCatalog.end())
		return NULL;
	else
		return it->second;
}

CTemplateInCatalog * CTopicShop::GetTemplateCatalogEntryPtr(const CString & strTemplate ) const
{
	// Wait for a set period, if failure then log error msg and wait infinite.
	WAIT_INFINITE( m_hevShopIsOpen );
	CTemplateCatalog::const_iterator it= m_TemplateCatalog.find( strTemplate );
	if (it == m_TemplateCatalog.end())
		return NULL;
	else
		return it->second;
}


// Call this function to obtain a CP_TOPIC as a pointer to the topic (identified by 
//	strTopic) that you want to operate on.  As long as the CP_TOPIC remains undeleted, 
//	the associated CTopic is guaranteed to remain undeleted.
// this function must not lock CTopicShop, because it can wait a long time.
CP_TOPIC & CTopicShop::GetTopic(const CString & strTopic, CP_TOPIC &cpTopic, bool bNewCookie)
{
	CTopicInCatalog *pTopicInCatalog = GetCatalogEntryPtr(strTopic);
	if (! pTopicInCatalog)
		cpTopic = NULL;
	else
	{
		pTopicInCatalog->CountHit(bNewCookie);
		pTopicInCatalog->GetTopicNoWait(cpTopic);
		if (cpTopic.IsNull())
		{
			m_TopicBuildQueue.RequestBuild( strTopic, true, CTopicBuildQueue::eTopic );
			pTopicInCatalog->GetTopic(cpTopic);
		}
	}

	return cpTopic;
}

// Call this function to obtain a CP_TEMPLATE as a pointer to the template (identified by 
//	strTemplate) that you want to operate on.  As long as the CP_TEMPLATE remains undeleted, 
//	the associated CAPGTSHTIReader is guaranteed to remain undeleted.
// this function must not lock CTopicShop, because it can wait a long time.
CP_TEMPLATE & CTopicShop::GetTemplate(const CString & strTemplate, CP_TEMPLATE &cpTemplate, bool bNewCookie)
{
	CTemplateInCatalog *pTemplateInCatalog = GetTemplateCatalogEntryPtr(strTemplate);
	if (! pTemplateInCatalog)
		cpTemplate = NULL;
	else
	{
		pTemplateInCatalog->CountHit(bNewCookie);
		pTemplateInCatalog->GetTemplateNoWait( cpTemplate );
		if (cpTemplate.IsNull())
		{
			m_TopicBuildQueue.RequestBuild( strTemplate, true, CTopicBuildQueue::eTemplate );
			pTemplateInCatalog->GetTemplate( cpTemplate );
		}
	}

	return cpTemplate;
}


void CTopicShop::GetListOfTopicNames(vector<CString>&arrstrTopic) const
{
	arrstrTopic.clear();

	LOCKOBJECT();

	try
	{
		for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
		{
			arrstrTopic.push_back(it->second->GetTopicInfo().GetNetworkName());
		}	
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	UNLOCKOBJECT();
}

// Rebuild all topics from source files
void CTopicShop::RebuildAll()
{
	
	LOCKOBJECT();
	for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
	{
		BuildTopic(it->second->GetTopicInfo().GetNetworkName());
	}	
	for (CTemplateCatalog::const_iterator itu = m_TemplateCatalog.begin(); itu != m_TemplateCatalog.end(); ++itu)
	{
		BuildTemplate( itu->first );
	}	
	UNLOCKOBJECT();
}

// Get status information on the topic builder thread
DWORD CTopicShop::GetThreadStatus(ThreadStatus &ts, DWORD & seconds) const
{
	return m_TopicBuildQueue.GetStatus(ts, seconds);
}

// see CTopicShop::CTopicBuildQueue::GetTopicsStatus for documentation.
void CTopicShop::GetTopicsStatus(
	DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const
{
	m_TopicBuildQueue.GetTopicsStatus(Total, NoInit, Fail, parrstrFail);
}

// see CTopicShop::CTopicBuildQueue::GetTemplatesStatus for documentation.
void CTopicShop::GetTemplatesStatus( vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const
{
	m_TopicBuildQueue.GetTemplatesStatus( parrstrFail, parrcntFail);
}

CTopicInCatalog* CTopicShop::GetCatalogEntry(const CString& strTopic) const
{
	CTopicInCatalog* ret = NULL;
	LOCKOBJECT();
	CTopicCatalog::const_iterator it = m_TopicCatalog.find(strTopic);
	if (it != m_TopicCatalog.end())
		ret = it->second;
	UNLOCKOBJECT();
	return ret;
}

bool CTopicShop::RetTemplateInCatalogStatus( const CString& strTemplate, bool& bValid ) const
{
	bool bIsPresent= false;

	bValid= false;
	LOCKOBJECT();
	CTemplateCatalog::const_iterator it = m_TemplateCatalog.find( strTemplate );
	if (it != m_TemplateCatalog.end())
	{
		CTemplateInCatalog* pTmp;

		bIsPresent= true;
		pTmp= it->second;
		switch (pTmp->GetTemplateStatus()) 
		{
			case CTemplateInCatalog::eOK:
					bValid= true;
					break;
			case CTemplateInCatalog::eFail:
					// Template has failed to load so we will not try to reload it,
					// but we need to increment the attempted load counter.
					pTmp->CountFailed();
					break;
			default: ;
		}
	}
	UNLOCKOBJECT();
	return( bIsPresent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\topicshop.h ===
//
// MODULE: TOPICSHOP.H
//
// PURPOSE: Provide a means of "publishing" troubleshooter topics.  This is where a 
//	working thread goes to obtain a CTopic to use
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-10-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-10-98	JM
//

#if !defined(AFX_TOPICSHOP_H__0CEED643_48C2_11D2_95F3_00C04FC22ADD__INCLUDED_)
#define AFX_TOPICSHOP_H__0CEED643_48C2_11D2_95F3_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtslstread.h"
#include "apgtsHTIread.h"
#include "Pointer.h"
#include "Topic.h"
#include "counter.h"
#include <map>

#pragma warning(disable:4786)

#define LSTFILENAME			_T("apgts.lst")


typedef counting_ptr<CTopic> CP_TOPIC;
class CTopicInCatalog
{
public:
	enum TopicStatus {eNotInited, eFail, eOK};
private:
	CTopicInfo	m_topicinfo;	// symbolic name of topic, associated file names 
	bool m_bTopicInfoMayNotBeCurrent;	// set when we change topic info & haven't yet built.
	mutable CRITICAL_SECTION m_csTopicinfo;	// must lock to access m_topicinfo or 
								//	m_bTopicInfoMayNotBeCurrent (outside the constructor)
	bool		m_bInited;		// true if we have attempted to build m_cpTopic.
								//	Mainly, this is here so that if we have tried to build
								//	the relevant CTopic and failed, we don't waste our time
								//	trying to build it again.  If this is true and 
								//	m_cpTopic.IsNull(), then we are unable to build this
								//	troubleshooting topic.
	CP_TOPIC	m_cpTopic;		// smart (counting) pointer.  If non-null, points to a 
								//	"published" topic, which is guaranteed to persist as 
								//	long as this points to it, or as long as a CP_TOPIC
								//	copied from this pointer points to it.
	HANDLE		m_hev;			// event to trigger when this topic is (successfully or 
								//	unsuccessfully) loaded.
	CHourlyDailyCounter m_countLoad;	// track attempted loads of this topic
	CHourlyDailyCounter m_countLoadOK;	// track successful loads of this topic
	CHourlyDailyCounter m_countEvent;	// track: initial placement in catalog, file change,
								//	or operator request for change. More interesting for
								//	first & last times than total number.
	CHourlyDailyCounter m_countHit;	// track user requests for this topic...
	// ... and break them down to hits which are the first on a new cookie 
	// & those which are not
	CHourlyDailyCounter m_countHitNewCookie;
	CHourlyDailyCounter m_countHitOldCookie;

public:
	CTopicInCatalog(const CTopicInfo & topicinfo);
	~CTopicInCatalog();
	CTopicInfo GetTopicInfo() const;
	void SetTopicInfo(const CTopicInfo &topicinfo);
	void CountHit(bool bNewCookie);
	CP_TOPIC & GetTopicNoWait(CP_TOPIC& cpTopic) const;
	CP_TOPIC & GetTopic(CP_TOPIC& cpTopic) const;
	void Init(const CTopic* pTopic);
	void CountChange();
	TopicStatus GetTopicStatus() const;
	bool GetTopicInfoMayNotBeCurrent() const;
	void TopicInfoIsCurrent();
};	// EOF of class CTopicInCatalog.


// This class was created utilizing CTopicInCatalog as a model.  We might in the
// future revisit these two classes and abstract the common functionality into a 
// base class.  RAB-981030.
typedef counting_ptr<CAPGTSHTIReader> CP_TEMPLATE;
class CTemplateInCatalog
{
public:
	enum TemplateStatus {eNotInited, eFail, eOK};
private:
	CString		m_strTemplate;	// name to the template 
	bool		m_bInited;		// true if we have attempted to build m_cpTemplate.
								//	Mainly, this is here so that if we have tried to build
								//	the relevant CAPGTSHTIReader and failed, we don't waste our
								//	time trying to build it again.  If this is true and 
								//	m_cpTemplate.IsNull(), then we are unable to build this
								//	troubleshooting template.
	CP_TEMPLATE	m_cpTemplate;	// smart (counting) pointer.  If non-null, points to a 
								//	"published" template, which is guaranteed to persist as 
								//	long as this points to it, or as long as a CP_TEMPLATE
								//	copied from this pointer points to it.
	HANDLE		m_hev;			// event to trigger when this template is (successfully or 
								//	unsuccessfully) loaded.
	CHourlyDailyCounter m_countLoad;	// track attempted loads of this template
	CHourlyDailyCounter m_countLoadOK;	// track successful loads of this template
	CHourlyDailyCounter m_countEvent;	// track: initial placement in catalog, file change,
								//	or operator request for change. More interesting for
								//	first & last times than total number.
	CHourlyDailyCounter m_countHit;	// track user requests for this template...

public:
	CTemplateInCatalog( const CString & strTemplate );
	~CTemplateInCatalog();
	const CString & GetTemplateInfo() const;
	void CountHit( bool bNewCookie );
	CP_TEMPLATE & GetTemplateNoWait( CP_TEMPLATE& cpTemplate ) const;
	CP_TEMPLATE & GetTemplate( CP_TEMPLATE& cpTemplate ) const;
	void Init( const CAPGTSHTIReader* pTemplate );
	void CountChange();
	void CountFailed();
	TemplateStatus GetTemplateStatus() const;
	DWORD CountOfFailedLoads() const;
};	// EOF of class CTemplateInCatalog.


// The only functions which need to lock class CTopicShop itself are those which modify TopicCatalog.
// TopicBuildQueue has its own protection.
class CTopicShop : public CStateless
{
public:
	// although this status pertains to CTopicBuildQueue, it must be declared public at 
	//	this level, so that we can pass thread status up out of CTopicShop.
	enum ThreadStatus{eBeforeInit, eFail, eWait, eRun, eExiting};
	static CString ThreadStatusText(ThreadStatus ts);
private:
	typedef map<CString, CTopicInCatalog*> CTopicCatalog;
	typedef map<CString, CTemplateInCatalog*> CTemplateCatalog;

	// Queue of topics to build
	class CTopicBuildQueue : public CStateless
	{
	protected:
		enum CatalogCategory {eUnknown, eTopic, eTemplate};
	private:
		CTopicCatalog & m_TopicCatalog;
		CTemplateCatalog & m_TemplateCatalog;
		CString m_CurrentlyBuilding;		// topic currently being built. Strictly lowercase.
											//	it is assumed/enforced that only one topic at 
											//	a time will be built.
		CatalogCategory	m_eCurrentlyBuilding;// Category type currently being built.
		
		// All strings in the next 4 vectors are strictly lowercase.
		vector<CString>m_PriorityBuild;		// build these first.  Someone's waiting for them. 
		vector<CString>m_NonPriorityBuild;
		vector<CString>m_PriorityBuildTemplates;
		vector<CString>m_NonPriorityBuildTemplates;
		
		HANDLE m_hThread;
		HANDLE m_hevBuildRequested;			// event to wake up TopicBuilderTask.
		HANDLE m_hevThreadIsShut;			// event just to indicate exit of TopicBuilderTask thread 
		bool m_bShuttingDown;				// lets topic builder thread know we're shutting down
		DWORD m_dwErr;						// status from starting the thread
		ThreadStatus m_ThreadStatus;
		time_t m_time;						// time last changed ThreadStatus.  Initialized

	public:
		CTopicBuildQueue( CTopicCatalog & TopicCatalog, CTemplateCatalog & TemplateCatalog );
		~CTopicBuildQueue();
		void RequestBuild(const CString &strTopic, bool bPriority, CatalogCategory eCat );
		DWORD GetStatus(ThreadStatus &ts, DWORD & seconds) const;
		void GetTopicsStatus(DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const;
		void GetTemplatesStatus( vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const;
		
		// Used to shutdown the topic building thread.
		void ShutDown();

	private:
		CTopicBuildQueue();  // do not instantiate
		void SetThreadStatus(ThreadStatus ts);

		// functions for use by the TopicBuilderTask thread.
		void Build();
		bool GetNextToBuild( CString &strTopic, CatalogCategory &eCat );
		void BuildComplete();
		void AckShutDown();

		// main function of the TopicBuilderTask thread.
		static UINT WINAPI TopicBuilderTask(LPVOID lpParams);
	};	// EOF of class CTopicBuildQueue.

/* class CTopicShop */
private:
	CTopicCatalog		m_TopicCatalog;
	CTemplateCatalog	m_TemplateCatalog;
	CTopicBuildQueue	m_TopicBuildQueue;
	HANDLE				m_hevShopIsOpen;	// so that threads wait till we know our list of topics

public:
	CTopicShop();
	virtual ~CTopicShop();

	void AddTopic(const CTopicInfo & topicinfo);
	void AddTemplate( const CString & strTemplateName );

	void OpenShop();

	void BuildTopic(const CString & strTopic, bool *pbAlreadyInCatalog = NULL);
	void BuildTemplate(const CString & strTemplate);
	
	CP_TOPIC & GetTopic(const CString & strTopic, CP_TOPIC & cpTopic, bool bNewCookie);
	CP_TEMPLATE & GetTemplate( const CString & strTemplate, CP_TEMPLATE & cpTemplate, bool bNewCookie);

	void GetListOfTopicNames(vector<CString>&arrstrTopic) const;
	void RebuildAll();
	DWORD GetThreadStatus(ThreadStatus &ts, DWORD & seconds) const;
	void GetTopicsStatus(DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const;
	void GetTemplatesStatus( vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const;
	CTopicInCatalog* GetCatalogEntry(const CString& strTopic) const;
	bool RetTemplateInCatalogStatus( const CString& strTemplate, bool& bValid ) const;

private:
	CTopicInCatalog * GetCatalogEntryPtr(const CString & strTopic) const;
	CTemplateInCatalog * GetTemplateCatalogEntryPtr(const CString & strTemplate) const;
};	// EOF of class CTopicShop.


#endif // !defined(AFX_TOPICSHOP_H__0CEED643_48C2_11D2_95F3_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\tshootctrl.h ===
//
// MODULE: TSHOOTCtrl.h
//
// PURPOSE: Interface for the component
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12.23.98
//
// NOTES: 
// Declaration of CTSHOOTCtrl
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		12/23/98	OK	    Windows related functionality is disabled;
//								IObjectSafetyImpl is added

#ifndef __TSHOOTCTRL_H_
#define __TSHOOTCTRL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "CPTSHOOT.h"
#include "apgtsstr.h"
#include "TSNameValueMgr.h"
#include "SniffConnector.h"
#include "RenderConnector.h"
#include <new.h>


class CDBLoadConfiguration;
class CThreadPool;
class COnlineECB;
class CPoolQueue;
class CHTMLLog;
class CLocalECB;
class CVariantBuilder;

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl
class ATL_NO_VTABLE CTSHOOTCtrl : 
	//public CComObjectRootEx<CComMultiThreadModel>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ITSHOOTCtrl, &IID_ITSHOOTCtrl, &LIBID_TSHOOTLib>,
	public CComControl<CTSHOOTCtrl>,
	public IPersistStreamInitImpl<CTSHOOTCtrl>,
	public IOleControlImpl<CTSHOOTCtrl>,
	public IOleObjectImpl<CTSHOOTCtrl>,
	public IOleInPlaceActiveObjectImpl<CTSHOOTCtrl>,
	public IViewObjectExImpl<CTSHOOTCtrl>,
	public IOleInPlaceObjectWindowlessImpl<CTSHOOTCtrl>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CTSHOOTCtrl>,
	public IPersistStorageImpl<CTSHOOTCtrl>,
	public ISpecifyPropertyPagesImpl<CTSHOOTCtrl>,
	public IQuickActivateImpl<CTSHOOTCtrl>,
	public IDataObjectImpl<CTSHOOTCtrl>,
	public IProvideClassInfo2Impl<&CLSID_TSHOOTCtrl, &DIID__ITSHOOTCtrlEvents, &LIBID_TSHOOTLib>,
	public IPropertyNotifySinkCP<CTSHOOTCtrl>,
	public CComCoClass<CTSHOOTCtrl, &CLSID_TSHOOTCtrl>,
	public CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >,
	public IObjectSafetyImpl<CTSHOOTCtrl, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public CSniffConnector,
	public CRenderConnector
{
	friend class CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >;

public:
	CTSHOOTCtrl();
	virtual ~CTSHOOTCtrl();

DECLARE_REGISTRY_RESOURCEID(IDR_TSHOOTCTRL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSHOOTCtrl)
	COM_INTERFACE_ENTRY(ITSHOOTCtrl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CTSHOOTCtrl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CTSHOOTCtrl)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
	CONNECTION_POINT_ENTRY(DIID__ITSHOOTCtrlEvents)
END_CONNECTION_POINT_MAP()

/* >>> I have commented anything related to Windows messaging
	in order to relieve the Control. Oleg. 12.23.98
BEGIN_MSG_MAP(CTSHOOTCtrl)
	CHAIN_MSG_MAP(CComControl<CTSHOOTCtrl>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
*/
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&IID_ITSHOOTCtrl,
		};
		for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
		{
			if (InlineIsEqualGUID(*arr[i], riid))
				return S_OK;
		}
		return S_FALSE;
	}

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ITSHOOTCtrl
public:
	STDMETHOD(NotifyNothingChecked)(/*[in]*/ BSTR bstrMessage);
	STDMETHOD(ProblemPage)(/*[out, retval]*/ BSTR * pbstrFirstPage);
	STDMETHOD(RunQuery2)(/*[in]*/ BSTR, /*[in]*/ BSTR, /*[in]*/ BSTR, /*[out, retval]*/ BSTR * pbstrPage);
	STDMETHOD(SetPair)(/*[in]*/ BSTR bstrCmd, /*[in]*/ BSTR bstrVal);
	STDMETHOD(Restart)(/*[out, retval]*/ BSTR * pbstrPage);
	STDMETHOD(PreLoadURL)(/*[in]*/ BSTR bstrRoot, /*[out, retval]*/ BSTR * pbstrPage);
	STDMETHOD(SetSniffResult)(/*[in]*/ VARIANT varNodeName, /*[in]*/ VARIANT varState, /*[out, retval]*/ BOOL * bResult);
	STDMETHOD(RunQuery)(/*[in]*/ VARIANT varCmds, /*[in]*/ VARIANT varVals, /*[in]*/ short size, /*[out, retval]*/ BSTR * pbstrPage);

/* >>> I have commented anything related to Windows messaging
	in order to relieve the Control. Oleg. 12.23.98
	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 3.0 : TSHOOTCtrl");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		return S_OK;
	}
*/

protected:
	static bool SendSimpleHtmlPage(CLocalECB *pLocalECB,
								   LPCTSTR pszStatus,
								   const CString& str);
	static bool SendError(CDBLoadConfiguration *pConf, 
						  CLocalECB *pLocalECB, 
						  LPCTSTR pszStatus, 
						  const CString& strMessage);

public:
	STDMETHOD(IsLocked)(/*[out, retval]*/ BOOL * pbResult);
	STDMETHOD(setLocale2)(/*[in]*/ BSTR bstrNewLocale);
	static bool RemoveStartOverButton(CString& strWriteClient);
	static bool RemoveBackButton(CString& strWriteClient);

	//static DWORD WINAPI Worker(LPVOID pParameter);

protected:
	bool Init(HMODULE hModule);
	void Destroy();

	// Launcher integration
	bool ExtractLauncherData(CString& error);
	//
	
	DWORD HttpExtensionProc(CLocalECB* pECB);
	DWORD StartRequest(CLocalECB *pLocalECB, HANDLE hImpersonationToken);
	bool SendError(CLocalECB *pLocalECB,
				   LPCTSTR pszStatus,
				   const CString & strMessage) const;
	bool ReadStaticPageFile(const CString& strTopicName, CString& strContent);

	void RegisterGlobal();

protected:
	virtual long PerformSniffingInternal(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs);
	virtual void RenderInternal(CString strPage);

protected:
	_PNH	m_SetNewHandlerPtr;	//	Used to store the initial _set_new_handler pointer.
	int		m_SetNewMode;		//	Used to store the initial _set_new_mode value which
								//	is then restored in the destructor. 

protected:	
	bool m_bInitialized;
	bool m_bFirstCall;

	CThreadPool* m_pThreadPool;		// thread management
	CPoolQueue*  m_poolctl;			// Keeps track of user requests queued up to be serviced 
									//	by working threads (a.k.a. "pool threads")
	CDBLoadConfiguration* m_pConf;	// manages loading support files
	CHTMLLog* m_pLog;				// manages user logging: what was requested by end user
	DWORD m_dwErr;					// general error status. 0 - OK.  Once set, never gets 
	bool m_bShutdown;				// Set true to say we're shutting down & can't handle 
									//  new requests.
	DWORD m_dwRollover;				// We increment this each time we make a WORK_QUEUE_ITEM so
									// we can use it there as a unique ID (unique as long as
									// this DLL stays loaded).
	CString m_strFirstPage;			// First page, saved when RunQuery is invoked 
									//  for the first time
	bool m_bStartedFromLauncher;    // true if started from the Launcher,
									//  false (from static page) by default
	CString m_strTopicName;			// topic name - only one topic for Local TS

	CArrNameValue m_arrNameValueFromLauncher; // array of name - value pairs, extracted from Launcher

	// passed from Launcher
	//  and can be used for sniffing
	CString m_strMachineID;
	CString m_strPNPDeviceID;
	CString m_strDeviceInstanceID;
	CString m_strGuidClass;

	CVariantBuilder * m_pVariantBuilder;

	CString m_strRequestedLocale;	// Used to hold the requested locale string.
									// Could be null, hence the bool variable
									// m_bRequestToSetLocale.
	bool	m_bRequestToSetLocale;	// Set to true when a request to set the locale
									// is made, set to false after the LocalECB 
									// object has been created.  Initially set to false.

	vector<DWORD> m_vecCookies;
	IGlobalInterfaceTable* m_pGIT;
	bool m_bCanRegisterGlobal;
};

#endif //__TSHOOTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\tsnamevaluemgr.cpp ===
// TSNameValueMgr.cpp: implementation of the CTSNameValueMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TSNameValueMgr.h"
#include "apgtsassert.h"
#include "functions.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTSNameValueMgr::CTSNameValueMgr(const VARIANT& name, const VARIANT& value, int count)
			   : m_bIsValid(true),
				 m_pvarNames(NULL),
				 m_pvarValues(NULL),
				 m_nCount(count)
{
	try {
		Initialize(name, value, count);
		FormDataFromArray();
	}
	catch (exception& /*x*/)
	{
		// catch custom exception (our custon exceptions are normally inherited from STL exception class
		m_bIsValid = false;
		/* 
		CString str;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION );
		*/
	}
}

CTSNameValueMgr::CTSNameValueMgr(const CArrNameValue& arr)
			   : m_bIsValid(true),
				 m_pvarNames(NULL),
				 m_pvarValues(NULL),
				 m_nCount(arr.size()),
				 m_arrNameValue(arr)
{
	FormDataFromArray();
}

CTSNameValueMgr::CTSNameValueMgr()
			   : m_bIsValid(true),
				 m_pvarNames(NULL),
				 m_pvarValues(NULL),
				 m_nCount(0)
{
}

CTSNameValueMgr::~CTSNameValueMgr()
{
}

void CTSNameValueMgr::Initialize(const VARIANT& varCmds, const VARIANT& varVals, int size)
{
	USES_CONVERSION;

	const VARIANT* pVarCmds;
	const VARIANT* pVarVals;

	if (VT_BYREF  == (VT_BYREF & varCmds.vt) && // ???
		VT_VARIANT == (VT_VARIANT & varCmds.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varCmds.vt))
			pVarCmds = &varCmds;
		else
			pVarCmds = varCmds.pvarVal;
	}
	else
	{
		pVarCmds = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}
	
	if (VT_BYREF  == (VT_BYREF & varVals.vt) && // ???
		VT_VARIANT == (VT_VARIANT & varVals.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varVals.vt))
			pVarVals = &varVals;
		else
			pVarVals = varVals.pvarVal;
	}
	else
	{
		pVarVals = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	if (VT_BYREF  != (VT_BYREF & pVarCmds->vt) ||
		VT_ARRAY != (VT_ARRAY & pVarCmds->vt) ||
		VT_VARIANT != (0xFFF & pVarCmds->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	if (VT_BYREF  != (VT_BYREF & pVarVals->vt) ||
		VT_ARRAY != (VT_ARRAY & pVarVals->vt) ||
		VT_VARIANT != (0xFFF & pVarVals->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	SAFEARRAY *pArrCmds = *(pVarCmds->pparray);
	SAFEARRAY *pArrVals = *(pVarVals->pparray);

	if (0 != pArrCmds->rgsabound[0].lLbound || 0 != pArrVals->rgsabound[0].lLbound)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Lower bounds are wrong.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}
	if (pArrCmds->rgsabound[0].cElements != pArrVals->rgsabound[0].cElements)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Cmds upperbound != Vals upperbound.");
		ASSERT(FALSE);
		throw exception((const char*)str);
	}

	m_nCount = size;
	m_pvarNames  = (VARIANT *) pArrCmds->pvData;
	m_pvarValues = (VARIANT *) pArrVals->pvData;

	if (0 != m_nCount)
	{
		if (m_pvarNames->vt != VT_BSTR || m_pvarValues->vt != VT_BSTR)
		{
			CString str;
			str.Format(_T("Wrong Cmd parameters passed from VB.  Array of unexpected type.\n\n")
				_T("Cmd Type: %s\nVal Type: %s"),
				(LPCTSTR) DecodeVariantTypes(m_pvarNames->vt),
				(LPCTSTR) DecodeVariantTypes(m_pvarValues->vt));
			ASSERT(FALSE);
			throw exception((const char*)str);
		}
	}	

	m_arrNameValue.clear();
	m_strData = _T("");
	
	// Extract the last name in order to check and remove any previous references to that name.
	// If there is only one name, there is no need to extract the name.
	CString strLastName;
	if (m_nCount > 1)
		strLastName= W2T( m_pvarNames[ m_nCount - 1 ].bstrVal );

	for (int i = 0; i < m_nCount; i++)
	{
		CString name  = W2T(m_pvarNames[i].bstrVal);
		CString value = W2T(m_pvarValues[i].bstrVal);

		if (0 == _tcsicmp(name, _T("TShootProblem")))
			name = _T("ProblemAsk");

		if (i == 0) // "value" contains network name
			value.MakeLower(); // for compatibility with Online TS, where network name 
							   //  is forced lower case

		// Check if we need to remove any previous reference to the last name.
		if ((i == (m_nCount - 1)) || (strLastName != name))
		{
			CNameValue name_value;
			name_value.strName  = name;
			name_value.strValue = value;
			m_arrNameValue.push_back(name_value);
		}
	}
}

bool CTSNameValueMgr::IsValid() const
{
	return m_bIsValid;
}

const CString& CTSNameValueMgr::GetData() const
{
	return m_strData;
}

int	CTSNameValueMgr::GetCount() const
{
	return m_nCount;
}

CNameValue CTSNameValueMgr::GetNameValue(int i) const
{
	if (i < 0 || i >= m_arrNameValue.size())
		return CNameValue();
	return m_arrNameValue[i];
}

void CTSNameValueMgr::FormDataFromArray()
{
	m_strData = _T("");

	for (CArrNameValue::iterator i = m_arrNameValue.begin(); i != m_arrNameValue.end(); i++)
	{
		m_strData += (*i).strName;
		m_strData += _T("=");
		m_strData += (*i).strValue;
		if (i != m_arrNameValue.end() - 1/*??? or decrement???*/) // it is not last pass through the loop
			m_strData += _T("&");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\tshootctrl.cpp ===
//
// MODULE: TSHOOTCtrl.cpp
//
// PURPOSE: Implementation of CTSHOOTCtrl: Interface for the component
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12.23.98
//
// NOTES: 
// 
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		12/23/98	OK	    

#include "stdafx.h"
#include "TSHOOT.h"
#include "TSHOOTCtrl.h"
#include "LocalECB.h"
#include "apgts.h"
#include "apgtsinf.h"

#define APGTS_COUNTER_OWNER 1
#include "ApgtsCounters.h"

#include "apgtsinf.h"
#include "apgtspl.h"
#include "apgtscfg.h"
#include "apgtslog.h"
#include "event.h"
#include "apgtsinf.h"
#include "apgtscls.h"
#include "apgtsevt.h"
#include "VariantBuilder.h"

// Launcher integration
#include "LaunchServ.h"
#include "LaunchServ_i.c"
#include "CHMFileReader.h"

bool g_nLaunched = false;

extern HANDLE ghModule;

// Error codes for end user.  Previously we gave verbose error messages.  Microsoft
// decided 8/98 that they do not want to tell the end user about presumably internal problems.
// Hence these codes.

DWORD k_ServErrDuringInit = 1000;		// Error(s) During Initialization: m_dwErr number follows
DWORD k_ServErrLimitedRequests = 1001;	// The server has limited the number of requests
DWORD k_ServErrThreadTokenFail = 1002;	// Failed to open thread token (impersonation token)
DWORD k_ServErrShuttingDown = 1003;		// Server Shutting Down
DWORD k_ServErrOutOfMemory = 1005;		// Out of memory (probably never will occur)


// Since VC++ v5.0 does not throw exceptions upon memory failure, we force the behavior.
_PNH APGST_New_Handler( size_t )
{
	throw std::bad_alloc();
	return( 0 );
}

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl
CTSHOOTCtrl::CTSHOOTCtrl()

		   : m_bInitialized(false),
			 m_bFirstCall(true),
			 m_pThreadPool(NULL),
			 m_poolctl(NULL),
			 m_pConf(NULL),
			 m_pLog(NULL),
			 m_dwErr(0),
			 m_bShutdown(false),
			 m_dwRollover(0),
			 m_bStartedFromLauncher(false),
			 m_pVariantBuilder(NULL),
			 m_bRequestToSetLocale(false),
			 m_bCanRegisterGlobal(true)
{
	// Set a new handler that throws bad_alloc exceptions (unlike VC++ v5.0).
	m_SetNewHandlerPtr= _set_new_handler( (_PNH)APGST_New_Handler );
	// Have malloc call the _set_new_handler upon failure to allocate memory.
	m_SetNewMode= _set_new_mode( 1 );

	if (RUNNING_APARTMENT_THREADED())
	{
		CoCreateInstance(CLSID_StdGlobalInterfaceTable,
						 NULL,
						 CLSCTX_INPROC_SERVER,
						 IID_IGlobalInterfaceTable,
						 reinterpret_cast<void**>(&m_pGIT));
	}
}

CTSHOOTCtrl::~CTSHOOTCtrl()
{
	if (RUNNING_APARTMENT_THREADED())
	{
		for(vector<DWORD>::iterator it = m_vecCookies.begin(); it != m_vecCookies.end(); it++)
			m_pGIT->RevokeInterfaceFromGlobal(*it);
		m_pGIT->Release();
	}

	Destroy();
	// Restore the initial set_new_handler and set_new_mode.
	_set_new_handler( m_SetNewHandlerPtr );
	// Restore the malloc handling as it was previously.
	_set_new_mode( m_SetNewMode );
}

bool CTSHOOTCtrl::Init(HMODULE hModule)
{
	try
	{
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool after
		// all new operations in this function.

		m_poolctl= new CPoolQueue();		
		if(!m_poolctl)
			throw bad_alloc();
		if ((m_dwErr = m_poolctl->GetStatus()) != 0)
			return false;

		m_pThreadPool = new CThreadPool(m_poolctl, dynamic_cast<CSniffConnector*>(this));	
		if(!m_pThreadPool)
			throw bad_alloc();
		if ((m_dwErr = m_pThreadPool->GetStatus()) != 0)
			return false;

		// open log
		m_pLog = new CHTMLLog( DEF_LOGFILEDIRECTORY );
		if(!m_pLog)
			throw bad_alloc();
		if ((m_dwErr = m_pLog->GetStatus()) != 0)
			return false;

		m_pConf= new CDBLoadConfiguration(hModule, m_pThreadPool, m_strTopicName, m_pLog );
		if(!m_pConf)
			throw bad_alloc();
	}
	catch (bad_alloc&)
	{
		m_dwErr= EV_GTS_CANT_ALLOC;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), m_dwErr ); 
		return false;
	}

	return true;
}

void CTSHOOTCtrl::Destroy()
{
	if (m_pThreadPool)
	{
		// >>>(ignore for V3.0) The following is not great encapsulation, but as of 9/22/98 we 
		//	don't see a way	around it. StartRequest falls naturally in APGTSExtension, so 
		//	APGTSExtension ends up with responsibility to tell the pool threads to exit.
		bool bAllSuccess = true;
		// signal all working threads to quit
		DWORD dwWorkingThreadCount = m_pThreadPool->GetWorkingThreadCount();
		for (DWORD i = 0; i < dwWorkingThreadCount; i++) 
			if (StartRequest(NULL, NULL) != HSE_STATUS_PENDING)
				bAllSuccess = false;

		if (bAllSuccess == false) 
		{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""),
										_T(""),
										EV_GTS_USER_BAD_THRD_REQ ); 
		}
	}
	
	if (m_pConf)
		delete m_pConf;

	if (m_pThreadPool)
		delete m_pThreadPool;

	if (m_poolctl)
	{
		// [BC-022701] - Removed Unlock call here. Not matched with preceeding Lock() call.
		// This never caused a problem until run on Debug build of WindowsXP. In this environment
		// this Unlock call causes crash.		
		//m_poolctl->Unlock();
		
		delete m_poolctl;
	}

	if (m_pLog)
		delete m_pLog;
}

// coded on analogy with Online troubleshooter
DWORD CTSHOOTCtrl::HttpExtensionProc(CLocalECB* pECB)
{
	bool              fRet = false, bChange = false;
    DWORD			  dwRet = HSE_STATUS_PENDING;
    //HANDLE            hImpersonationToken;
	CString strTemp;

	CLocalECB *pLocalECB = pECB;

	if (m_dwErr) 
	{
		strTemp.Format(_T("<P>Error %d:%d"), k_ServErrDuringInit, m_dwErr);
        fRet = SendError( pLocalECB,
                          _T("500 Try again later"),	// 500 is from HTTP spec
                          strTemp);
		
        pLocalECB->SetHttpStatusCode(500);
		
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
	}

    //  Is the request queue (items requested by this fn to be serviced by working threads)
	//		too long?  If so, tell the user to come back later
    //
    if ( m_poolctl->GetTotalQueueItems() + 1 > m_pConf->GetMaxWQItems() )
    {
        //
        //  Send a message back to client indicating we're too busy, they
        //  should try again later.
        //
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_SERVER_BUSY ); 

        strTemp.Format(_T("<P>Error %d"), k_ServErrLimitedRequests);
		fRet = SendError( pLocalECB,
                          _T("503 Try again later"),
                          strTemp );
		
        pLocalECB->SetHttpStatusCode(503);
		
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
	}

    //
    //  Capture the current impersonation token (IIS Security) so we can impersonate this
    //  user in the other thread.  Limit permissions.
    //
    
	/*
	if ( !::OpenThreadToken(::GetCurrentThread(),
							TOKEN_QUERY | TOKEN_IMPERSONATE,
							false,            // Open in unimpersonated context
							&hImpersonationToken ))
    {
		DWORD err = ::GetLastError();

		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );

		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_THREAD_TOKEN ); 

        strTemp.Format(_T("<P>Error %d"), k_ServErrThreadTokenFail);
		fRet = SendError( pLocalECB,
                          _T("500 Try again later"),
                          strTemp );
		
        pLocalECB->SetHttpStatusCode(500);
		
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
    }
	*/

	dwRet = StartRequest(pLocalECB, NULL/*hImpersonationToken*/);

	return (dwRet);
}

// Thread-safe.
// NOTE TWO ROLES depending on INPUT pLocalECB.
// INPUT  pLocalECB - NULL if shutting down
//		Otherwise, EXTENSION_CONTROL_BLOCK is ISAPI's way of passing in the sort of
//		stuff you'd get from CGI.  We've abstracted from that.
// INPUT hImpersonationToken obtained via prior call to OpenThreadToken
//		Not relevant if pLocalECB == NULL
// RETURNS HSE_STATUS_SUCCESS, HSE_STATUS_ERROR, HSE_STATUS_PENDING
//	(or HSE_REQ_DONE_WITH_SESSION in single-threaded debugging version)
DWORD CTSHOOTCtrl::StartRequest(CLocalECB *pLocalECB, HANDLE hImpersonationToken)
{
    WORK_QUEUE_ITEM * pwqi;
	bool              fRet = false;
	CString strTemp;
	
    //
    //  Take the queue lock, get a queue item and put it on the queue
    //

	if (pLocalECB && m_bShutdown) 
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_CANT_PROC_REQ_SS ); 

		strTemp.Format(_T("<P>Error %d"), k_ServErrShuttingDown);
		fRet = SendError( pLocalECB,
				          _T("500 Try again later"),
				          strTemp );
			
		pLocalECB->SetHttpStatusCode(500);

		::CloseHandle( hImpersonationToken );
        
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
	}
	
    m_poolctl->Lock();

	// 9/23/98 JM got rid of a constraint here which was too tight a constraint
	//	on size of queue
	try
	{
		// bundle up pointers the worker thread will need
		pwqi = new WORK_QUEUE_ITEM (
			hImpersonationToken,
			pLocalECB,			// may be null as a signal
			m_pConf,
			m_pLog);
	}
	catch (bad_alloc&)
    {
		m_poolctl->Unlock();

		if (pLocalECB) 
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""),
									_T(""),
									EV_GTS_ERROR_WORK_ITEM ); 
			
			strTemp.Format(_T("<P>Error %d"), k_ServErrOutOfMemory);
			fRet = SendError( pLocalECB,
				              _T("500 Not enough memory"),
				              strTemp);
			
			pLocalECB->SetHttpStatusCode(500);
			::CloseHandle( hImpersonationToken );
		}
        
		return fRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
    }

	if (!pLocalECB)
		m_bShutdown = true;

	// Some data passed to thread just for statistical purposes
	// Thread can pass this info back over web; we can't.
	pwqi->GTSStat.dwRollover = m_dwRollover++;

	// put it at the tail of the queue & signal the pool threads there is work to be done
	m_poolctl->PushBack(pwqi);

    m_poolctl->Unlock();

    return HSE_STATUS_PENDING;
}

// Build an HTTP response in the case of an error.
//	INPUT *pszStatus short status (e.g. "503 Server too busy").
//	INPUT str - entire content of the page.
//	RETURNS true on success
// NOTE that this actually uses no member variables.
/*static*/ bool CTSHOOTCtrl::SendSimpleHtmlPage(	CLocalECB *pLocalECB,
													LPCTSTR pszStatus,
													const CString & str)
{
    BOOL fRet;
    DWORD cb;

	TCHAR pszTemp[200];		// safely large to copy pszStatus.  pLocalECB->ServerSupportFunction
							// doesn't want pszStatus in a const array

	_tcscpy(pszTemp, pszStatus);
	
    //  Send the headers
    //
    fRet = pLocalECB->ServerSupportFunction( HSE_REQ_SEND_RESPONSE_HEADER,
											 pszTemp,
											 NULL,
											 (LPDWORD) _T("Content-Type: text/html\r\n\r\n") );
    //
    //  If that succeeded, send the message
    //
    if ( fRet ) 
	{
        cb = str.GetLength();
		// (LPCTSTR) cast gives us the underlying text bytes.
		//	>>> $UNICODE Actually, this would screw up under Unicode compile, because for HTML, 
		//	this must be SBCS.  Should really be a conversion to LPCSTR, which is non-trivial
		//	in a Unicode compile. JM 1/7/99
		fRet = pLocalECB->WriteClient((LPCTSTR)str, &cb);
    }
    return fRet ? true : false;
}

// Build an HTTP response in the case of an error.
// INPUT  pLocalECB - EXTENSION_CONTROL_BLOCK is ISAPI's way of passing in the sort of
//	stuff you'd get from CGI.  We've abstracted from that.  pLocalECB should never be null.  
//	INPUT *pszStatus short status (e.g. "503 Try again later").
//	INPUT *pszMessage - typically just an error number, e.g. "1004" or
//		"1000:123"
//	RETURNS true on success
/*static*/ bool CTSHOOTCtrl::SendError( CDBLoadConfiguration *pConf, 
										CLocalECB *pLocalECB, 
										LPCTSTR pszStatus, 
										const CString & strMessage)
{
	CString str;

	pConf->CreateErrorPage(strMessage, str);

	return SendSimpleHtmlPage( pLocalECB, pszStatus, str);
}

/*static*/ bool CTSHOOTCtrl::RemoveStartOverButton(CString& strWriteClient)
{
	int left = 0, right = 0;

	if (-1 != (left = strWriteClient.Find(SZ_INPUT_TAG_STARTOVER)))
	{
		right = left;
		while (strWriteClient[++right] && strWriteClient[right] != _T('>'))
			;
		if (strWriteClient[right])
			strWriteClient = strWriteClient.Left(left) + strWriteClient.Right(strWriteClient.GetLength() - right - 1);
		else
			return false;
		return true;
	}
	return false;
}

/*static*/ bool CTSHOOTCtrl::RemoveBackButton(CString& strWriteClient)
{
	int left = 0, right = 0;

	if (-1 != (left = strWriteClient.Find(SZ_INPUT_TAG_BACK)))
	{
		right = left;
		while (strWriteClient[++right] && strWriteClient[right] != _T('>'))
			;
		if (strWriteClient[right])
			strWriteClient = strWriteClient.Left(left) + strWriteClient.Right(strWriteClient.GetLength() - right - 1);
		else
			return false;
		return true;
	}
	return false;
}

bool CTSHOOTCtrl::SendError(CLocalECB *pLocalECB,
							LPCTSTR pszStatus,
							const CString & strMessage) const
{
	return SendError(m_pConf, pLocalECB, pszStatus, strMessage);
}

bool CTSHOOTCtrl::ReadStaticPageFile(const CString& strTopicName, CString& strContent)
{
	CString strPath;

	if (!m_pConf->GetRegistryMonitor().GetStringInfo(CAPGTSRegConnector::eResourcePath, strPath))
		return false;

	CString strFullPath = strPath + strTopicName + LOCALTS_SUFFIX_RESULT + LOCALTS_EXTENSION_HTM;
	
	CFileReader fileResult(	CPhysicalFileReader::makeReader( strFullPath ) );

	if (!fileResult.Read())
		return false;
	
	strContent = _T("");
	fileResult.GetContent(strContent);
	
	return true;
}

bool CTSHOOTCtrl::ExtractLauncherData(CString& error)
{
	HRESULT hRes = S_OK;
	DWORD	dwResult = 0;
	OLECHAR *poleShooter = NULL;
	OLECHAR *poleProblem = NULL;
	OLECHAR *poleNode = NULL;
	OLECHAR *poleState = NULL;
	OLECHAR *poleMachine = NULL;
	OLECHAR *polePNPDevice = NULL;
	OLECHAR *poleGuidClass = NULL;
	OLECHAR *poleDeviceInstance = NULL;
	short i = 0;
	CNameValue name_value;
	ILaunchTS *pILaunchTS = NULL;
	CLSID clsidLaunchTS = CLSID_LaunchTS;
	IID iidLaunchTS = IID_ILaunchTS;

	// Get an interface on the launch server
	hRes = ::CoCreateInstance(clsidLaunchTS, NULL, 
			                  CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER | CLSCTX_INPROC_SERVER,
			                  iidLaunchTS, (void **) &pILaunchTS);
	if (FAILED(hRes))
	{
		error = _T("LaunchServ interface not found.");
		return false;
	}

	// Get all of the query values.
	hRes = pILaunchTS->GetShooterStates(&dwResult);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error.Format(_T("GetShooterStates Failed. %ld"), dwResult);
		pILaunchTS->Release();			
		return false;
	}

	// clear container
	m_arrNameValueFromLauncher.clear();
	
	// get tshooter name
	hRes = pILaunchTS->GetTroubleShooter(&poleShooter);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetTroubleShooter Failed.");
		pILaunchTS->Release();
		return false;
	}
	name_value.strName = C_TOPIC;
	name_value.strValue = poleShooter;
	m_arrNameValueFromLauncher.push_back(name_value);
	SysFreeString(poleShooter);

	// get problem
	hRes = pILaunchTS->GetProblem(&poleProblem);
	if (S_FALSE != hRes && !FAILED(hRes))
	{
		name_value.strName = NODE_PROBLEM_ASK;
		name_value.strValue = poleProblem;
		m_arrNameValueFromLauncher.push_back(name_value);
		SysFreeString(poleProblem);

		// get name - value pairs for nodes set by the user
		do	
		{
			hRes = pILaunchTS->GetNode(i, &poleNode);
			if (FAILED(hRes) || S_FALSE == hRes)
				break;
			name_value.strName = poleNode;
			SysFreeString(poleNode);

			hRes = pILaunchTS->GetState(i, &poleState);
			if (FAILED(hRes) || S_FALSE == hRes)
				break;
			name_value.strValue = poleState;
			SysFreeString(poleState);
			
			m_arrNameValueFromLauncher.push_back(name_value);
			i++;
		} 	
		while (true);
	}

	///////////////////////////////////////////////////////////
	// obtaining Machine, PNPDevice, GuidClass, DeviceInstance
	hRes = pILaunchTS->GetMachine(&poleMachine);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetMachine Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strMachineID = poleMachine;
	::SysFreeString(poleMachine);
	
	hRes = pILaunchTS->GetPNPDevice(&polePNPDevice);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetPNPDevice Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strPNPDeviceID = polePNPDevice;
	::SysFreeString(polePNPDevice);

	hRes = pILaunchTS->GetGuidClass(&poleGuidClass);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetGuidClass Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strGuidClass = poleGuidClass;
	::SysFreeString(poleGuidClass);
	
	hRes = pILaunchTS->GetDeviceInstance(&poleDeviceInstance);
	if (S_FALSE == hRes || FAILED(hRes))
	{
		error = _T("GetDeviceInstance Failed.");
		pILaunchTS->Release();
		return false;
	}
	m_strDeviceInstanceID = poleDeviceInstance;
	::SysFreeString(poleDeviceInstance);
	////////////////////////////////////////////////////////////

	pILaunchTS->Release();
	return true;
}

//
STDMETHODIMP CTSHOOTCtrl::RunQuery(VARIANT varCmds, VARIANT varVals, short size, BSTR *pbstrPage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	if (RUNNING_APARTMENT_THREADED())
	{
		if (m_bCanRegisterGlobal) 
		{
			RegisterGlobal();
			m_bCanRegisterGlobal = false;
		}
	}
	
	//!!!!!!!!!!!!! Check for size < 1 !!!!!!!!!!!!!!!!!!!!!
	if (size < 1)
	{
		*pbstrPage = T2BSTR("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> Error in RunQuery parameter: size is less one. </H4> </BODY> </HTML>");
		return S_OK;
	}

	//!!!!!!!!!! detect the way we were stated !!!!!!!!!!!!!!
	{   
		CString strStub;
		CLocalECB ECB(varCmds, varVals, 1, NULL, &strStub, NULL,														
						m_bRequestToSetLocale, m_strRequestedLocale );
		CString strFirstName = ECB.GetNameValue(0).strName;

		if (strFirstName == NODE_LIBRARY_ASK)
		{
			if (g_nLaunched)
			{
				*pbstrPage = T2BSTR("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> Error in RunQuery: launched for the second time. </H4> </BODY> </HTML>");
				return S_OK;
			}

			CString strError;
			
			m_bStartedFromLauncher = true;
			g_nLaunched = true;
			if (!ExtractLauncherData(strError))
			{
				CString strOut;
				strOut.Format(_T("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> %s. </H4> </BODY> </HTML>"), strError);
				*pbstrPage = T2BSTR(strOut);
				m_bStartedFromLauncher = false;
				return S_OK;
			}
		}
	}
	
	/////////////////////////////////////////////////////////
	// automatic variable declaration
	HANDLE event = ::CreateEvent(NULL, false, false, NULL);
	CString strWriteClient;
	CLocalECB* pECB;

	if (RUNNING_APARTMENT_THREADED())
		pECB = !m_bStartedFromLauncher ? new CLocalECB(varCmds, varVals, size, NULL, 
														&strWriteClient, 
														dynamic_cast<CRenderConnector*>(this),
														m_bRequestToSetLocale,
														m_strRequestedLocale)
									   : new CLocalECB(m_arrNameValueFromLauncher, 
														NULL, &strWriteClient, 
														dynamic_cast<CRenderConnector*>(this),
														m_bRequestToSetLocale,
														m_strRequestedLocale);

	if (RUNNING_FREE_THREADED())
		pECB = !m_bStartedFromLauncher ? new CLocalECB(varCmds, varVals, size, 
														event, &strWriteClient, NULL,
														m_bRequestToSetLocale,
														m_strRequestedLocale)
									   : new CLocalECB(m_arrNameValueFromLauncher, event, 
														&strWriteClient, NULL,
														m_bRequestToSetLocale,
														m_strRequestedLocale);

	m_bRequestToSetLocale= false;	// Deactivate locale setting after it has been passed into the ECB.
	SetLocked(true);
	
	bool bSaveFirstPage = false;
	
	/////////////////////////////////////////////////////////
	// initialize
	if (!m_bInitialized)
	{
		// extract topic name first
		if (!m_bStartedFromLauncher)
		{
			CString strStub;
			CLocalECB ECB(varCmds, varVals, 1, NULL, &strStub, NULL,
							m_bRequestToSetLocale, m_strRequestedLocale );
			m_strTopicName = ECB.GetNameValue(0).strValue;
		}
		else
			m_strTopicName = (*m_arrNameValueFromLauncher.begin()).strValue;

		if (Init((HINSTANCE)::ghModule))
		{
			m_bInitialized = true;
		}
		else
		{
			*pbstrPage = T2BSTR(_T("<HTML> <HEAD> <TITLE>Troubleshooter</TITLE> </HEAD> <BODY> <H4> Error of initialization in RunQuery. </H4> </BODY> </HTML>"));
			m_bStartedFromLauncher = false;
			return S_OK;
		}
	}

	//////////////////////////////////////////////////////////
	// save first page when started from static page
	if (m_strFirstPage.IsEmpty() &&	!m_bStartedFromLauncher) 
	{	
		CString strStaticPage;

		if (size == 2 && 
			// RunQuery was started from static (since !m_bStartedFromLauncher) Problem Page(since size == 2)
			ReadStaticPageFile(m_strTopicName, strStaticPage)
		   )
		{
			m_strFirstPage = strStaticPage;
		}
		else
		{
			bSaveFirstPage = true;
		}
	}
	
	HttpExtensionProc(pECB);

	if (RUNNING_FREE_THREADED())
		::WaitForSingleObject(event, INFINITE);

	::CloseHandle(event);

	if (bSaveFirstPage)
		m_strFirstPage = strWriteClient;
	
	/////////////////////////////////////////////////////////
	// first RunQuery when started from Launcher
	if (m_bStartedFromLauncher && m_bFirstCall)
	{
		RemoveStartOverButton(strWriteClient);
		RemoveBackButton(strWriteClient);
	}
	/////////////////////////////////////////////////////////
	// save first page when started from Launcher
	if (m_strFirstPage.IsEmpty() && m_bStartedFromLauncher) 
		m_strFirstPage = strWriteClient;

	*pbstrPage = T2BSTR(strWriteClient);
	/*
	//////////////////////////////////////////////////////////////////////////
	// >>> $TEST
	HANDLE hFile = ::CreateFile(_T("D:\\TShooter Projects\\Troubleshooter\\Local\\http\\Test\\first_step.htm"), 
								GENERIC_WRITE, 
								0,
								NULL,			// no security attributes 
								CREATE_ALWAYS, 
								FILE_FLAG_RANDOM_ACCESS, 
								NULL			// handle to template file
  							   );
	if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD read = 0;
		::WriteFile(hFile, (LPCTSTR)strWriteClient, strWriteClient.GetLength(), &read, NULL);
	}
	///////////////////////////////////////////////////////////////////////////
	*/
	m_bStartedFromLauncher = false;
	m_bFirstCall = false;
	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::SetSniffResult(VARIANT varNodeName, VARIANT varState, BOOL *bResult)
{
	// >>> No sniffing is used. Oleg 03.26.99
	*bResult = 1;

	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::PreLoadURL(BSTR bstrRoot, BSTR *pbstrPage)
{
	USES_CONVERSION;

	// >>> This feature is not used. Oleg. 03.26.99
	*pbstrPage = A2BSTR("PreLoadURL results");

	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::Restart(BSTR *pbstrPage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	*pbstrPage = T2BSTR(m_strFirstPage);

	return S_OK;
}

// The same as Restart(...).
// Implemented for compatibility with Win98's JScript
STDMETHODIMP CTSHOOTCtrl::ProblemPage(BSTR *pbstrFirstPage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	*pbstrFirstPage = T2BSTR(m_strFirstPage);

	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::SetPair(BSTR bstrCmd, BSTR bstrVal)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;
	
	if (!m_pVariantBuilder)
		m_pVariantBuilder = new CVariantBuilder;

	// check if we've started new sequence, but
	//  array of name - value pairs is not empty
	CString type = W2T(bstrCmd);
	if (type == C_TYPE || type == C_PRELOAD || type == C_TOPIC)
	{
		if (m_pVariantBuilder->GetSize())
		{
			delete m_pVariantBuilder;
			m_pVariantBuilder = new CVariantBuilder;
		}
	}

	m_pVariantBuilder->SetPair(bstrCmd, bstrVal);
	return S_OK;
}

// The arguments are ignored.  They are just for backward compatibility to V1.0.1.2121 & its
//	successors
STDMETHODIMP CTSHOOTCtrl::RunQuery2(BSTR, BSTR, BSTR, BSTR *pbstrPage)
{
	if (GetLocked())
		return S_OK;
	
	if (m_pVariantBuilder)
	{
		RunQuery(m_pVariantBuilder->GetCommands(),
				 m_pVariantBuilder->GetValues(),
				 m_pVariantBuilder->GetSize(),
				 pbstrPage);
		delete m_pVariantBuilder;
		m_pVariantBuilder = NULL;
	}
	return S_OK;
}

STDMETHODIMP CTSHOOTCtrl::NotifyNothingChecked(BSTR bstrMessage)
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	CString message = W2T(bstrMessage);
	
	::MessageBox(::GetForegroundWindow(), 
				 message != _T("") ? message : _T("Please choose a button and then press Next"),
				 _T("Error"), 
				 MB_OK);

	return S_OK;
}

long CTSHOOTCtrl::PerformSniffingInternal(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs)
{
	USES_CONVERSION;
	return Fire_Sniffing(T2BSTR((LPCTSTR)strNodeName), T2BSTR((LPCTSTR)strLaunchBasis), T2BSTR((LPCTSTR)strAdditionalArgs));
}

void CTSHOOTCtrl::RenderInternal(CString strPage)
{
	USES_CONVERSION;
	Fire_Render(T2BSTR((LPCTSTR)strPage));
}

void CTSHOOTCtrl::RegisterGlobal()
{
	int nConnections = CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >::m_vec.GetSize();

	for (int nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
	{					                                                                                                                                                                                                                                                                                                                                                                                                    
		Lock();
		CComPtr<IUnknown> sp = CProxy_ITSHOOTCtrlEvents< CTSHOOTCtrl >::m_vec.GetAt(nConnectionIndex);
		Unlock();
		IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
		if (pDispatch != NULL)
		{
			DWORD dwCookie;
			m_pGIT->RegisterInterfaceInGlobal(pDispatch, IID_IDispatch, &dwCookie);
			m_vecCookies.push_back(dwCookie);
		}
	}
}

STDMETHODIMP CTSHOOTCtrl::IsLocked(BOOL *pbResult)
{
	*pbResult = GetLocked() ? TRUE : FALSE;

	return S_OK;
}


// Set the locale.
// Parameter bstrNewLocale should be of the form:
//		"lang[_country[.code_page]]"
//	    | ".code_page"
//	    | ""
//	    | NULL
STDMETHODIMP CTSHOOTCtrl::setLocale2( BSTR bstrNewLocale )
{
	USES_CONVERSION;

	if (GetLocked())
		return S_OK;

	m_strRequestedLocale= W2T( bstrNewLocale );
	m_bRequestToSetLocale= true;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\versioninfo.cpp ===
//
// MODULE: VersionInfo.CPP

// PURPOSE This module reads version info from the resource file.

// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 
//
// NOTES: 
// 1. Took it from Argon Project.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0				    OK
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "VersionInfo.h"

//								
LPCWSTR FindStr(LPCWSTR wszString, LPCWSTR wszCharSet, const DWORD dwStringLen)
{
	LPCWSTR wszRetStr = NULL;
	int x;
	int SetLen;
	DWORD dwCheck = 0;
	DWORD dwCur = 0;	
	if (NULL != wszCharSet && NULL != wszString)
	{
		SetLen = wcslen(wszCharSet);
		do
		{
			for (x = 0; x < SetLen; x++)
			{
				if (wszString[dwCheck] != wszCharSet[x])									
					break;				
				dwCheck++;
			}
			if (x == SetLen)
			{
				wszRetStr = &wszString[dwCur];
				break;			
			}
			else
			{
				dwCur++;
				dwCheck = dwCur;
			}
		} while (dwCur < dwStringLen);
	}
	return wszRetStr;
}

LPCWSTR GetVersionInfo(HINSTANCE hInst, LPWSTR wszStrName)
{
	LPCWSTR pwszFileVersion;
	LPCWSTR pwszStrInfo = NULL;
	LPWSTR pwszVerInfo = NULL;
	DWORD dwDataLen = 0;
	LPCTSTR lpName = (LPTSTR)	VS_VERSION_INFO;
	HRSRC hVerInfo = FindResource(hInst, lpName, RT_VERSION);
	if (NULL != hVerInfo)
	{
		HGLOBAL hVer = LoadResource(hInst, hVerInfo);
		if (NULL != hVer)
		{
			pwszVerInfo = (LPWSTR) LockResource(hVer);
			if (NULL != pwszVerInfo)
			{
				dwDataLen = SizeofResource(hInst, hVerInfo);
				if (NULL != (pwszFileVersion = FindStr(pwszVerInfo, wszStrName, dwDataLen / sizeof(WCHAR))))
				{
					pwszStrInfo = pwszFileVersion + wcslen(pwszFileVersion);
					while (NULL == *pwszStrInfo)
						pwszStrInfo++;
				}					
			}
		}
	}
	return pwszStrInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\variantbuilder.cpp ===
//
// MODULE: VariantBuilder.cpp
//
// PURPOSE: implementation of the CVariantBuilder class.  Allows us to construct
//	a pair of arrays for the name-value pairs to be passed to RunQuery.  This lets
//	JScript sanely use a system that was mostly designed for VB Script.
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 02.01.99
//
// NOTES: 
// Implementation of CTSHOOTCtrl
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		02.01.99	JM	    


#include "stdafx.h"
#include "VariantBuilder.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVariantBuilder::CVariantBuilder()
{
	VariantInit(&m_varCommands);
	VariantInit(&m_varValues);
	VariantInit(&m_varCommandsWrap);
	VariantInit(&m_varValuesWrap);

	V_VT(&m_varCommands) = VT_ARRAY | VT_BYREF | VT_VARIANT; 
	V_VT(&m_varValues) = VT_ARRAY | VT_BYREF | VT_VARIANT; 
	V_ARRAYREF(&m_varCommands) = &m_psafearrayCmds; 
	V_ARRAYREF(&m_varValues) = &m_psafearrayVals; 

	V_VT(&m_varCommandsWrap) = VT_BYREF | VT_VARIANT; 
	V_VT(&m_varValuesWrap) = VT_BYREF | VT_VARIANT; 

	V_VARIANTREF(&m_varCommandsWrap) = &m_varCommands;
	V_VARIANTREF(&m_varValuesWrap) = &m_varValues;

	SAFEARRAYBOUND sabCmd;
	sabCmd.cElements = k_cMaxElements;
	sabCmd.lLbound = 0;
	SAFEARRAYBOUND sabVal = sabCmd;

	// create two vectors of VARIANTs to wrap BSTRs
	m_psafearrayCmds = SafeArrayCreate( VT_VARIANT, 1, &sabCmd);
	m_psafearrayVals = SafeArrayCreate( VT_VARIANT, 1, &sabVal);

	m_cElements = 0;
}

CVariantBuilder::~CVariantBuilder()
{
	SafeArrayDestroy(m_psafearrayCmds);
	SafeArrayDestroy(m_psafearrayVals);

	VariantClear(&m_varCommands);
	VariantClear(&m_varValues);
	VariantClear(&m_varCommandsWrap);
	VariantClear(&m_varValuesWrap);
}

// effectively, add a name-value pair to the arrays.
// If the array is full (which should never happen in the real world) silently fails.
void CVariantBuilder::SetPair(BSTR bstrCmd, BSTR bstrVal)
{
	if (m_cElements < k_cMaxElements)
	{
		VariantInit(&m_pvarCmd[m_cElements]);
		VariantInit(&m_pvarVal[m_cElements]);
		V_VT(&m_pvarCmd[m_cElements]) = VT_BSTR;
		V_VT(&m_pvarVal[m_cElements]) = VT_BSTR;
		m_pvarCmd[m_cElements].bstrVal=bstrCmd;
		m_pvarVal[m_cElements].bstrVal=bstrVal;
		
		SafeArrayPutElement(m_psafearrayCmds, &m_cElements, &m_pvarCmd[m_cElements]);
		SafeArrayPutElement(m_psafearrayVals, &m_cElements, &m_pvarVal[m_cElements]);

		++m_cElements;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\tsnamevaluemgr.h ===
// TSNameValueMgr.h: interface for the CTSNameValueMgr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TSNAMEVALUEMGR_H__0AB724C3_AA78_11D2_8C82_00C04F949D33__INCLUDED_)
#define AFX_TSNAMEVALUEMGR_H__0AB724C3_AA78_11D2_8C82_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vector>
#include "apgtsstr.h"

using namespace std;

struct CNameValue;
typedef vector<CNameValue> CArrNameValue;

struct CNameValue
{
	CString strName;
	CString strValue;
};

class CTSNameValueMgr  
{
private:
	VARIANT* m_pvarNames;
	VARIANT* m_pvarValues;
	int		 m_nCount;

	bool	 m_bIsValid;
	CString	 m_strData;
	CArrNameValue m_arrNameValue;

public:
	CTSNameValueMgr(const VARIANT& name, const VARIANT& value, int count);
	CTSNameValueMgr(const CArrNameValue& arr);
	CTSNameValueMgr();
	virtual ~CTSNameValueMgr();

protected:
	void Initialize(const VARIANT& name, const VARIANT& value, int count);

public:
	bool		IsValid()  const;
	const CString& GetData() const;
	int			GetCount() const;
	CNameValue 	GetNameValue(int) const;

protected:
	void FormDataFromArray();
};

#endif // !defined(AFX_TSNAMEVALUEMGR_H__0AB724C3_AA78_11D2_8C82_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\variantbuilder.h ===
//
// MODULE: VariantBuilder.h
//
// PURPOSE: interface for the CVariantBuilder class.  Allows us to construct
//	a pair of arrays for the name-value pairs to be passed to RunQuery.  This lets
//	JScript sanely use a system that was mostly designed for VB Script.
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 02.01.99
//
// NOTES: 
// Implementation of CTSHOOTCtrl
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		02.01.99	JM	    

#if !defined(AFX_VARIANTBUILDER_H__901D987E_BA1C_11D2_9663_00C04FC22ADD__INCLUDED_)
#define AFX_VARIANTBUILDER_H__901D987E_BA1C_11D2_9663_00C04FC22ADD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CVariantBuilder  
{
private:
	VARIANT m_varCommands;
	VARIANT m_varValues;
	VARIANT m_varCommandsWrap;
	VARIANT m_varValuesWrap;
	SAFEARRAY *m_psafearrayCmds;
	SAFEARRAY *m_psafearrayVals;
	long m_cElements;
	enum {k_cMaxElements = 100};// safely large: allows this many calls to CVariantBuilder::SetPair()
	VARIANT m_pvarCmd[k_cMaxElements];
	VARIANT m_pvarVal[k_cMaxElements];

public:
	CVariantBuilder();
	~CVariantBuilder();
	void SetPair(BSTR bstrCmd, BSTR bstrVal);

	const VARIANT& GetCommands() const {return m_varCommandsWrap;}
	const VARIANT& GetValues() const {return m_varValuesWrap;}
	long GetSize() const {return m_cElements;}

};

#endif // !defined(AFX_VARIANTBUILDER_H__901D987E_BA1C_11D2_9663_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\versioninfo.h ===
//
// MODULE: VersionInfo.h

// PURPOSE This module reads version info from the resource file.

// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 
//
// NOTES: 
// 1. Took it from Argon Project.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0				    OK

#include<windows.h>
#include "apgtsstr.h"

// FindStr: Does a strstr but works on files that have embedded null characters.
LPCWSTR FindStr(LPCWSTR wszString, LPCWSTR wszCharSet, const DWORD dwStringLen);

// GetVersionInfo:  Reads the version info.
// Input:  hInst -	The handle returned from AfxGetResourceHandle() 
//					or the handle that was passed to DllMain.
//			wszStrName - The name of the resource that is desired.
// GetVersionInfo(g_hInst, L"FileVersion")		Returns the FileVersion.
// NULL will be returned if the function fails.
LPCWSTR GetVersionInfo(HINSTANCE hInst, LPWSTR wszStrName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\vccomsupport\comraise.cpp ===
//
// Throw a com_error object.  In a separate file so users can easily define
// their own to replace this one.
//

#include <comdef.h>

#pragma hdrstop

#pragma warning(disable:4290)

void __stdcall
_com_raise_error(HRESULT hr, IErrorInfo* perrinfo) throw(_com_error)
{
	throw _com_error(hr, perrinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\vccomsupport\comsupp.cpp ===
#include <comdef.h>

#pragma hdrstop

#include <stdarg.h>
#include <malloc.h>

#pragma intrinsic(memset)

#pragma warning(disable:4290)

/////////////////////////////////////////////////////////////////////////////

void __stdcall
_com_issue_error(HRESULT hr) throw(_com_error)
{
	_com_raise_error(hr, NULL);
}

void __stdcall
_com_issue_errorex(HRESULT hr, IUnknown* punk, REFIID riid) throw(_com_error)
{
	IErrorInfo* perrinfo = NULL;
	if (punk == NULL) {
		goto exeunt;
	}
	ISupportErrorInfo* psei;
	if (FAILED(punk->QueryInterface(__uuidof(ISupportErrorInfo),
			   (void**)&psei))) {
		goto exeunt;
	}
	HRESULT hrSupportsErrorInfo;
	hrSupportsErrorInfo = psei->InterfaceSupportsErrorInfo(riid);
	psei->Release();
	if (hrSupportsErrorInfo != S_OK) {
		goto exeunt;
	}
	if (GetErrorInfo(0, &perrinfo) != S_OK) {
		perrinfo = NULL;
	}
exeunt:
	_com_raise_error(hr, perrinfo);
}

/////////////////////////////////////////////////////////////////////////////

#define VT_OPTIONAL	0x0800

struct FLOAT_ARG  { BYTE floatBits[sizeof(float)]; };
struct DOUBLE_ARG { BYTE doubleBits[sizeof(double)]; };

/////////////////////////////////////////////////////////////////////////////

static HRESULT
_com_invoke_helper(IDispatch* pDispatch,
				   DISPID dwDispID,
				   WORD wFlags,
				   VARTYPE vtRet,
				   void* pvRet,
				   const wchar_t* pwParamInfo,
				   va_list argList,
				   IErrorInfo** pperrinfo) throw()
{
	*pperrinfo = NULL;

	if (pDispatch == NULL) {
		return E_POINTER;
	}

	DISPPARAMS dispparams;
	VARIANT* rgvarg;
	rgvarg = NULL;
	memset(&dispparams, 0, sizeof dispparams);

	// determine number of arguments
	if (pwParamInfo != NULL) {
		dispparams.cArgs = lstrlenW(pwParamInfo);
	}

	DISPID dispidNamed;
	dispidNamed = DISPID_PROPERTYPUT;
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) {
		if (dispparams.cArgs <= 0) {
			return E_INVALIDARG;
		}
		dispparams.cNamedArgs = 1;
		dispparams.rgdispidNamedArgs = &dispidNamed;
	}

	if (dispparams.cArgs != 0) {
		// allocate memory for all VARIANT parameters
		rgvarg = (VARIANT*)_alloca(dispparams.cArgs * sizeof(VARIANT));
		memset(rgvarg, 0, sizeof(VARIANT) * dispparams.cArgs);
		dispparams.rgvarg = rgvarg;

		// get ready to walk vararg list
		const wchar_t* pw = pwParamInfo;
		VARIANT* pArg;
		pArg = rgvarg + dispparams.cArgs - 1;   // params go in opposite order

		while (*pw != 0) {
			pArg->vt = *pw & ~VT_OPTIONAL; // set the variant type
			switch (pArg->vt) {
			case VT_I2:
#ifdef _MAC
				pArg->iVal = (short)va_arg(argList, int);
#else
				pArg->iVal = va_arg(argList, short);
#endif
				break;
			case VT_I4:
				pArg->lVal = va_arg(argList, long);
				break;
			case VT_R4:
				// Note: All float arguments to vararg functions are passed
				//  as doubles instead.  That's why they are passed as VT_R8
				//  instead of VT_R4.
				pArg->vt = VT_R8;
				*(DOUBLE_ARG*)&pArg->dblVal = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_R8:
				*(DOUBLE_ARG*)&pArg->dblVal = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_DATE:
				*(DOUBLE_ARG*)&pArg->date = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_CY:
				pArg->cyVal = *va_arg(argList, CY*);
				break;
			case VT_BSTR:
				pArg->bstrVal = va_arg(argList, BSTR);
				break;
			case VT_DISPATCH:
				pArg->pdispVal = va_arg(argList, LPDISPATCH);
				break;
			case VT_ERROR:
				pArg->scode = va_arg(argList, SCODE);
				break;
			case VT_BOOL:
#ifdef _MAC
				V_BOOL(pArg) = (VARIANT_BOOL)va_arg(argList, int)
									? VARIANT_TRUE : VARIANT_FALSE;
#else
				V_BOOL(pArg) = va_arg(argList, VARIANT_BOOL)
									? VARIANT_TRUE : VARIANT_FALSE;
#endif
				break;
			case VT_VARIANT:
				*pArg = *va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN:
				pArg->punkVal = va_arg(argList, LPUNKNOWN);
				break;
			case VT_DECIMAL:
				pArg->decVal = *va_arg(argList, DECIMAL*);
				pArg->vt = VT_DECIMAL;
				break;
			case VT_UI1:
#ifdef _MAC
				pArg->bVal = (BYTE)va_arg(argList, int);
#else
				pArg->bVal = va_arg(argList, BYTE);
#endif
				break;

			case VT_I2|VT_BYREF:
				pArg->piVal = va_arg(argList, short*);
				break;
			case VT_I4|VT_BYREF:
				pArg->plVal = va_arg(argList, long*);
				break;
			case VT_R4|VT_BYREF:
				pArg->pfltVal = va_arg(argList, float*);
				break;
			case VT_R8|VT_BYREF:
				pArg->pdblVal = va_arg(argList, double*);
				break;
			case VT_DATE|VT_BYREF:
				pArg->pdate = va_arg(argList, DATE*);
				break;
			case VT_CY|VT_BYREF:
				pArg->pcyVal = va_arg(argList, CY*);
				break;
			case VT_BSTR|VT_BYREF:
				pArg->pbstrVal = va_arg(argList, BSTR*);
				break;
			case VT_DISPATCH|VT_BYREF:
				pArg->ppdispVal = va_arg(argList, LPDISPATCH*);
				break;
			case VT_ERROR|VT_BYREF:
				pArg->pscode = va_arg(argList, SCODE*);
				break;
			case VT_BOOL|VT_BYREF:
				pArg->pboolVal = va_arg(argList, VARIANT_BOOL*);
				break;
			case VT_VARIANT|VT_BYREF:
				pArg->pvarVal = va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN|VT_BYREF:
				pArg->ppunkVal = va_arg(argList, LPUNKNOWN*);
				break;
			case VT_DECIMAL|VT_BYREF:
				pArg->pdecVal = va_arg(argList, DECIMAL*);
				break;
			case VT_UI1|VT_BYREF:
				pArg->pbVal = va_arg(argList, BYTE*);
				break;

			default:
				// M00REVIEW - For safearrays, should be able to type-check
				// against the base VT_* type.(?)
				if (pArg->vt & VT_ARRAY) {
					if (pArg->vt & VT_BYREF) {
						pArg->pparray = va_arg(argList, LPSAFEARRAY*);
					} else {
						pArg->parray = va_arg(argList, LPSAFEARRAY);
					}
					break;
				}
				// unknown type!
				return E_INVALIDARG;
			}

			--pArg; // get ready to fill next argument
			++pw;
		}

		// Check for missing optional unnamed args at the end of the arglist,
		// and remove them from the DISPPARAMS.  This permits calling servers
		// which modify their action depending on the actual number of args.
		// E.g. Excel95 Application.Workbooks returns a Workbooks* if called
		// with no args, a Workbook* if called with one arg - this shouldn't
		// be necessary, but Excel95 doesn't appear to check for missing
		// args indicated by VT_ERROR/DISP_E_PARAMNOTFOUND.
		pArg = rgvarg + dispparams.cNamedArgs;
		pw = pwParamInfo + dispparams.cArgs - dispparams.cNamedArgs - 1;
		unsigned int cMissingArgs = 0;

		// Count the number of missing arguments
		while (pw >= pwParamInfo) {
			// Optional args must be VARIANT or VARIANT*
			if ((*pw & ~VT_BYREF) != (VT_VARIANT|VT_OPTIONAL)) {
				break;
			}

			VARIANT* pVar;
			pVar = (*pw & VT_BYREF) ? pArg->pvarVal : pArg;
			if (V_VT(pVar) != VT_ERROR ||
				V_ERROR(pVar) != DISP_E_PARAMNOTFOUND)
			{
				break;
			}

			++cMissingArgs;
			++pArg;
			--pw;
		}

		// Move the named args up next to the remaining unnamed args and
		// adjust the DISPPARAMS struct.
		if (cMissingArgs > 0) {
			for (unsigned int c = 0; c < dispparams.cNamedArgs; ++c) {
				rgvarg[c + cMissingArgs] = rgvarg[c];
			}
			dispparams.cArgs -= cMissingArgs;
			dispparams.rgvarg += cMissingArgs;
		}
	}

	// initialize return value
	VARIANT* pvarResult;
	VARIANT vaResult;
	VariantInit(&vaResult);
	pvarResult = (vtRet != VT_EMPTY) ? &vaResult : NULL;

	// initialize EXCEPINFO struct
	EXCEPINFO excepInfo;
	memset(&excepInfo, 0, sizeof excepInfo);

	UINT nArgErr;
	nArgErr = (UINT)-1;  // initialize to invalid arg

	// make the call
	HRESULT hr = pDispatch->Invoke(dwDispID, __uuidof(NULL), 0, wFlags,
								   &dispparams, pvarResult, &excepInfo,
								   &nArgErr);

	// throw exception on failure
	if (FAILED(hr)) {
		VariantClear(&vaResult);
		if (hr != DISP_E_EXCEPTION) {
			// non-exception error code
			// M00REVIEW - Is this all?  What about looking for IErrorInfo?
			//			 - Only if IID is passed in, I'd think
			return hr;
		}

		// make sure excepInfo is filled in
		if (excepInfo.pfnDeferredFillIn != NULL) {
			excepInfo.pfnDeferredFillIn(&excepInfo);
		}

		// allocate new error info, and fill it
		ICreateErrorInfo *pcerrinfo = NULL;
		if (SUCCEEDED(CreateErrorInfo(&pcerrinfo))) {
			// Set up ErrInfo object
			// M00REVIEW - Use IID if decide to pass that in
			pcerrinfo->SetGUID(__uuidof(IDispatch));
			pcerrinfo->SetDescription(excepInfo.bstrDescription);
			pcerrinfo->SetHelpContext(excepInfo.dwHelpContext);
			pcerrinfo->SetHelpFile(excepInfo.bstrHelpFile);
			pcerrinfo->SetSource(excepInfo.bstrSource);

			if (FAILED(pcerrinfo->QueryInterface(__uuidof(IErrorInfo),
												 (void**)pperrinfo))) {
				*pperrinfo = NULL;
			}
		}

		if (excepInfo.wCode != 0) {
            hr = _com_error::WCodeToHRESULT(excepInfo.wCode);
		} else {
			hr = excepInfo.scode;
		}
		return hr;
	}

	if (vtRet != VT_EMPTY) {
		// convert return value unless already correct
		if (vtRet != VT_VARIANT && vtRet != vaResult.vt) {
			hr = VariantChangeType(&vaResult, &vaResult, 0, vtRet);
			if (FAILED(hr)) {
				VariantClear(&vaResult);
				return hr;
			}
		}

		// copy return value into return spot!
		switch (vtRet) {
		case VT_I2:
			*(short*)pvRet = vaResult.iVal;
			break;
		case VT_I4:
			*(long*)pvRet = vaResult.lVal;
			break;
		case VT_R4:
			*(FLOAT_ARG*)pvRet = *(FLOAT_ARG*)&vaResult.fltVal;
			break;
		case VT_R8:
			*(DOUBLE_ARG*)pvRet = *(DOUBLE_ARG*)&vaResult.dblVal;
			break;
		case VT_DATE:
			*(DOUBLE_ARG*)pvRet = *(DOUBLE_ARG*)&vaResult.date;
			break;
		case VT_CY:
			*(CY*)pvRet = vaResult.cyVal;
			break;
		case VT_BSTR:
			*(BSTR*)pvRet = vaResult.bstrVal;
			break;
		case VT_DISPATCH:
			*(LPDISPATCH*)pvRet = vaResult.pdispVal;
			break;
		case VT_ERROR:
			*(SCODE*)pvRet = vaResult.scode;
			break;
		case VT_BOOL:
			*(VARIANT_BOOL*)pvRet = V_BOOL(&vaResult);
			break;
		case VT_VARIANT:
			*(VARIANT*)pvRet = vaResult;
			break;
		case VT_UNKNOWN:
			*(LPUNKNOWN*)pvRet = vaResult.punkVal;
			break;
		case VT_DECIMAL:
			*(DECIMAL*)pvRet = vaResult.decVal;
			break;
		case VT_UI1:
			*(BYTE*)pvRet = vaResult.bVal;
			break;

		default:
			if ((vtRet & (VT_ARRAY|VT_BYREF)) == VT_ARRAY) {
				// M00REVIEW - type-check against the base VT_* type?
				*(LPSAFEARRAY*)pvRet = vaResult.parray;
				break;
			}
			// invalid return type!
			VariantClear(&vaResult);
			return E_INVALIDARG;
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT __cdecl
_com_dispatch_raw_method(IDispatch* pDispatch,
						 DISPID dwDispID,
						 WORD wFlags,
						 VARTYPE vtRet,
						 void* pvRet,
						 const wchar_t* pwParamInfo,
						 ...) throw()
{
	va_list argList;
	va_start(argList, pwParamInfo);

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									vtRet,
									pvRet,
									pwParamInfo,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		SetErrorInfo(0, perrinfo);
	}

	va_end(argList);
	return hr;
}

HRESULT __cdecl
_com_dispatch_method(IDispatch* pDispatch,
					 DISPID dwDispID,
					 WORD wFlags,
					 VARTYPE vtRet,
					 void* pvRet,
					 const wchar_t* pwParamInfo,
					 ...) throw(_com_error)
{
	va_list argList;
	va_start(argList, pwParamInfo);

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									vtRet,
									pvRet,
									pwParamInfo,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		_com_raise_error(hr, perrinfo);
	}

	va_end(argList);
	return hr;
}

HRESULT __stdcall
_com_dispatch_raw_propget(IDispatch* pDispatch,
						  DISPID dwDispID,
						  VARTYPE vtProp,
						  void* pvProp) throw()
{
	return _com_dispatch_raw_method(pDispatch,
									dwDispID,
									DISPATCH_PROPERTYGET,
									vtProp,
									pvProp,
									NULL);
}

HRESULT __stdcall
_com_dispatch_propget(IDispatch* pDispatch,
					  DISPID dwDispID,
					  VARTYPE vtProp,
					  void* pvProp) throw(_com_error)
{
	return _com_dispatch_method(pDispatch,
								dwDispID,
								DISPATCH_PROPERTYGET,
								vtProp,
								pvProp,
								NULL);
}

HRESULT __cdecl
_com_dispatch_raw_propput(IDispatch* pDispatch,
						  DISPID dwDispID,
						  VARTYPE vtProp,
						  ...) throw()
{
	va_list argList;
	va_start(argList, vtProp);
#ifdef _MAC
	argList -= 2;
#endif

	wchar_t rgwParams[2];
	rgwParams[0] = vtProp;
	rgwParams[1] = 0;

	WORD wFlags = (vtProp == VT_DISPATCH || vtProp == VT_UNKNOWN)
					? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT;

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									VT_EMPTY,
									NULL,
									rgwParams,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		SetErrorInfo(0, perrinfo);
	}

	va_end(argList);
	return hr;
}

HRESULT __cdecl
_com_dispatch_propput(IDispatch* pDispatch,
					  DISPID dwDispID,
					  VARTYPE vtProp,
					  ...) throw(_com_error)
{
	va_list argList;
	va_start(argList, vtProp);
#ifdef _MAC
	argList -= 2;
#endif

	wchar_t rgwParams[2];
	rgwParams[0] = vtProp;
	rgwParams[1] = 0;

	WORD wFlags = (vtProp == VT_DISPATCH || vtProp == VT_UNKNOWN)
					? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT;

	IErrorInfo* perrinfo;
	HRESULT hr = _com_invoke_helper(pDispatch,
									dwDispID,
									wFlags,
									VT_EMPTY,
									NULL,
									rgwParams,
									argList,
									&perrinfo);
	if (FAILED(hr)) {
		_com_raise_error(hr, perrinfo);
	}

	va_end(argList);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\vccomsupport\comutil.cpp ===
//
// The definitions of functions and data declared in comutil.h
//

#include <comdef.h>

#pragma hdrstop

#include <malloc.h>

#pragma warning(disable:4290)

_variant_t vtMissing(DISP_E_PARAMNOTFOUND, VT_ERROR);

namespace _com_util {
	//
	// Convert char * to BSTR
	//
	BSTR __stdcall ConvertStringToBSTR(const char* pSrc) throw(_com_error)
	{
		if (pSrc == NULL) {
			return NULL;
		}
		else {
			int size = lstrlenA(pSrc) + 1;
			BSTR pDest = static_cast<BSTR>(::_alloca(size * sizeof(wchar_t)));

			pDest[0] = '\0';

			if (::MultiByteToWideChar(CP_ACP, 0, pSrc, -1, pDest, size) == 0) {
				_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
			}

			return ::SysAllocString(pDest);
		}
	}

	// Convert BSTR to char *
	//
	char* __stdcall ConvertBSTRToString(BSTR pSrc) throw(_com_error)
	{
		if (pSrc == NULL) {
			return NULL;
		}
		else {
			int size = (wcslen(pSrc) + 1) * sizeof(wchar_t);
			char* pDest = ::new char[size];

			if (pDest == NULL) {
				_com_issue_error(E_OUTOFMEMORY);
			}

			pDest[0] = '\0';

			if (::WideCharToMultiByte(CP_ACP, 0, pSrc, -1, pDest, size, NULL, NULL) == 0) {
				_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
			}

			return pDest;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\vccomsupport\comip.h ===
/***
* comip.h - Native C++ compiler COM support - COM interface pointers header
*
*	Copyright (C) 1996-1999 Microsoft Corporation
*	All rights reserved.
*
****/

#if !defined(_INC_COMIP)
#define _INC_COMIP

#if _MSC_VER > 1000
#pragma once
#endif

#include <ole2.h>
#include <malloc.h>

#include <comutil.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4290)

class _com_error;

void __stdcall _com_issue_error(HRESULT);
struct __declspec(uuid("00000000-0000-0000-c000-000000000046")) IUnknown;

// Provide Interface to IID association
//
template<typename _Interface, const IID* _IID /*= &__uuidof(_Interface)*/> class _com_IIID {
public:
	typedef _Interface Interface;

	static _Interface* GetInterfacePtr() throw()
	{
		return NULL;
	}

	static _Interface& GetInterface() throw()
	{
		return *GetInterfacePtr();
	}

	static const IID& GetIID() throw()
	{
		return *_IID;
	}
};

template<typename _IIID> class _com_ptr_t {
public:
	// Declare interface type so that the type may be available outside
	// the scope of this template.
	//
	typedef _IIID ThisIIID;
	typedef typename _IIID::Interface Interface;

	// When the compiler supports references in template parameters,
	// _CLSID will be changed to a reference.  To avoid conversion
	// difficulties this function should be used to obtain the
	// CLSID.
	//
	static const IID& GetIID() throw()
	{
		return ThisIIID::GetIID();
	}

	// Constructs a smart-pointer from any interface pointer.
	//
	template<typename _InterfacePtr> _com_ptr_t(const _InterfacePtr& p) throw(_com_error)
		: m_pInterface(NULL)
	{
		if (p) {
			HRESULT hr = _QueryInterface(p);

			if (FAILED(hr) && (hr != E_NOINTERFACE)) {
				_com_issue_error(hr);
			}
		}
	}

	// Disable conversion using _com_ptr_t* specialization of
	// template<typename _InterfacePtr> _com_ptr_t(const _InterfacePtr& p)
	template<> explicit _com_ptr_t(_com_ptr_t* const & p) throw(_com_error)
	{
		if (p != NULL) {
			_com_issue_error(E_POINTER);
		}
		else {
			m_pInterface = p->m_pInterface;
			AddRef();
		}
	}

	// Default constructor.
	//
	_com_ptr_t() throw()
		: m_pInterface(NULL)
	{
	}

	// This constructor is provided to allow NULL assignment. It will issue
	// an error if any value other than null is assigned to the object.
	//
	_com_ptr_t(int null) throw(_com_error)
		: m_pInterface(NULL)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}
	}

	// Copy the pointer and AddRef().
	//
	template<> _com_ptr_t(const _com_ptr_t& cp) throw()
		: m_pInterface(cp.m_pInterface)
	{
		_AddRef();
	}

	// Saves the interface.
	//
	_com_ptr_t(Interface* pInterface) throw()
		: m_pInterface(pInterface)
	{
		_AddRef();
	}

	// Copies the pointer. If fAddRef is TRUE, the interface will
	// be AddRef()ed.
	//
	_com_ptr_t(Interface* pInterface, bool fAddRef) throw()
		: m_pInterface(pInterface)
	{
		if (fAddRef) {
			_AddRef();
		}
	}

	// Construct a pointer for a _variant_t object.
	//
	template<> _com_ptr_t(const _variant_t& varSrc) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = QueryStdInterfaces(varSrc);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Calls CoCreateClass with the provided CLSID.
	//
	explicit _com_ptr_t(const CLSID& clsid, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = CreateInstance(clsid, pOuter, dwClsContext);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	//
	explicit _com_ptr_t(LPOLESTR str, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = CreateInstance(str, pOuter, dwClsContext);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Calls CoCreateClass with the provided SBCS CLSID retrieved from
	// the string.
	//
	explicit _com_ptr_t(LPCSTR str, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw(_com_error)
		: m_pInterface(NULL)
	{
		HRESULT hr = CreateInstance(str, pOuter, dwClsContext);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}
	}

	// Queries for interface.
	//
	template<typename _InterfacePtr> _com_ptr_t& operator=(const _InterfacePtr& p) throw(_com_error)
	{
		HRESULT hr = _QueryInterface(p);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}

		return *this;
	}

	// Saves the interface.
	//
	_com_ptr_t& operator=(Interface* pInterface) throw()
	{
		if (m_pInterface != pInterface) {
			Interface* pOldInterface = m_pInterface;

			m_pInterface = pInterface;

			_AddRef();

			if (pOldInterface != NULL) {
				pOldInterface->Release();
			}
		}

		return *this;
	}

	// Copies and AddRef()'s the interface.
	//
	template<> _com_ptr_t& operator=(const _com_ptr_t& cp) throw()
	{
		return operator=(cp.m_pInterface);
	}

	// This operator is provided to permit the assignment of NULL to the class.
	// It will issue an error if any value other than NULL is assigned to it.
	//
	_com_ptr_t& operator=(int null) throw(_com_error)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}

		return operator=(reinterpret_cast<Interface*>(NULL));
	}

	// Construct a pointer for a _variant_t object.
	//
	template<> _com_ptr_t& operator=(const _variant_t& varSrc) throw(_com_error)
	{
		HRESULT hr = QueryStdInterfaces(varSrc);

		if (FAILED(hr) && (hr != E_NOINTERFACE)) {
			_com_issue_error(hr);
		}

		return *this;
	}

	// If we still have an interface then Release() it. The interface
	// may be NULL if Detach() has previously been called, or if it was
	// never set.
	//
	~_com_ptr_t() throw()
	{
		_Release();
	}

	// Saves/sets the interface without AddRef()ing. This call
	// will release any previously acquired interface.
	//
	void Attach(Interface* pInterface) throw()
	{
		_Release();
		m_pInterface = pInterface;
	}

	// Saves/sets the interface only AddRef()ing if fAddRef is TRUE.
	// This call will release any previously acquired interface.
	//
	void Attach(Interface* pInterface, bool fAddRef) throw()
	{
		_Release();
		m_pInterface = pInterface;

		if (fAddRef) {
			if (pInterface != NULL) {
				pInterface->AddRef();
			}
		}
	}

	// Simply NULL the interface pointer so that it isn't Released()'ed.
	//
	Interface* Detach() throw()
	{
		Interface* const old=m_pInterface;
		m_pInterface = NULL;
		return old;
	}

	// Return the interface. This value may be NULL.
	//
	operator Interface*() const throw()
	{
		return m_pInterface;
	}

	// Queries for the unknown and return it
	// Provides minimal level error checking before use.
	//
	operator Interface&() const throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return *m_pInterface;
	}

	// Allows an instance of this class to act as though it were the
	// actual interface. Also provides minimal error checking.
	//
	Interface& operator*() const throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return *m_pInterface;
	}

	// Returns the address of the interface pointer contained in this
	// class. This is useful when using the COM/OLE interfaces to create
	// this interface.
	//
	Interface** operator&() throw()
	{
		_Release();
		m_pInterface = NULL;
		return &m_pInterface;
	}

	// Allows this class to be used as the interface itself.
	// Also provides simple error checking.
	//
	Interface* operator->() const throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return m_pInterface;
	}

	// This operator is provided so that simple boolean expressions will
	// work.  For example: "if (p) ...".
	// Returns TRUE if the pointer is not NULL.
	//
	operator bool() const throw()
	{
		return m_pInterface != NULL;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator==(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) == 0;
	}

	// Compare with other interface
	//
	template<> bool operator==(Interface* p) throw(_com_error)
	{
		return (m_pInterface == p) ? true : _CompareUnknown(p) == 0;
	}

	// Compares 2 _com_ptr_t's
	//
	template<> bool operator==(_com_ptr_t& p) throw()
	{
		return operator==(p.m_pInterface);
	}

	// For comparison to NULL
	//
	template<> bool operator==(int null) throw(_com_error)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}

		return m_pInterface == NULL;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator!=(_InterfacePtr p) throw(_com_error)
	{
		return !(operator==(p));
	}

	// Compare with other interface
	//
	template<> bool operator!=(Interface* p) throw(_com_error)
	{
		return !(operator==(p));
	}

	// Compares 2 _com_ptr_t's
	//
	template<> bool operator!=(_com_ptr_t& p) throw(_com_error)
	{
		return !(operator==(p));
	}

	// For comparison to NULL
	//
	template<> bool operator!=(int null) throw(_com_error)
	{
		return !(operator==(null));
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator<(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) < 0;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator>(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) > 0;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator<=(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) <= 0;
	}

	// Compare two pointers
	//
	template<typename _InterfacePtr> bool operator>=(_InterfacePtr p) throw(_com_error)
	{
		return _CompareUnknown(p) >= 0;
	}

	// Provides error-checking Release()ing of this interface.
	//
	void Release() throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		m_pInterface->Release();
		m_pInterface = NULL;
	}

	// Provides error-checking AddRef()ing of this interface.
	//
	void AddRef() throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		m_pInterface->AddRef();
	}

	// Another way to get the interface pointer without casting.
	//
	Interface* GetInterfacePtr() const throw()
	{
		return m_pInterface;
	}

	// Loads an interface for the provided CLSID.
	// Returns an HRESULT.  Any previous interface is released.
	//
	HRESULT CreateInstance(const CLSID& rclsid, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		HRESULT hr;

		_Release();

		if (dwClsContext & (CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)) {
			IUnknown* pIUnknown;

			hr = CoCreateInstance(rclsid, pOuter, dwClsContext, __uuidof(IUnknown), reinterpret_cast<void**>(&pIUnknown));

			if (FAILED(hr)) {
				return hr;
			}

			hr = OleRun(pIUnknown);

			if (SUCCEEDED(hr)) {
				hr = pIUnknown->QueryInterface(GetIID(), reinterpret_cast<void**>(&m_pInterface));
			}

			pIUnknown->Release();
		}
		else {
			hr = CoCreateInstance(rclsid, pOuter, dwClsContext, GetIID(), reinterpret_cast<void**>(&m_pInterface));
		}

		return hr;
	}

	// Creates the class specified by clsidString.  clsidString may
	// contain a class id, or a prog id string.
	//
	HRESULT CreateInstance(LPOLESTR clsidString, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		if (clsidString == NULL) {
			return E_INVALIDARG;
		}

		CLSID clsid;
		HRESULT hr;

		if (clsidString[0] == '{') {
			hr = CLSIDFromString(clsidString, &clsid);
		}
		else {
			hr = CLSIDFromProgID(clsidString, &clsid);
		}

		if (FAILED(hr)) {
			return hr;
		}

		return CreateInstance(clsid, pOuter, dwClsContext);
	}

	// Creates the class specified by SBCS clsidString.  clsidString may
	// contain a class id, or a prog id string.
	//
	HRESULT CreateInstance(LPCSTR clsidStringA, IUnknown* pOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		if (clsidStringA == NULL) {
			return E_INVALIDARG;
		}

		int size = lstrlenA(clsidStringA) + 1;
		LPOLESTR clsidStringW = static_cast<LPOLESTR>(_alloca(size * 2));

		clsidStringW[0] = '\0';

		if (MultiByteToWideChar(CP_ACP, 0, clsidStringA, -1, clsidStringW, size) == 0) {
			return HRESULT_FROM_WIN32(GetLastError());
		}

		return CreateInstance(clsidStringW, pOuter, dwClsContext);
	}

	// Attach to the active object specified by rclsid.
	// Any previous interface is released.
	//
	HRESULT GetActiveObject(const CLSID& rclsid) throw()
	{
		_Release();

		IUnknown* pIUnknown;

		HRESULT hr = ::GetActiveObject(rclsid, NULL, &pIUnknown);

		if (FAILED(hr)) {
			return hr;
		}

		hr = pIUnknown->QueryInterface(GetIID(), reinterpret_cast<void**>(&m_pInterface));

		if (FAILED(hr)) {
			return hr;
		}

		pIUnknown->Release();

		return hr;
	}

	// Attach to the active object specified by clsidString.
	// First convert the LPOLESTR to a CLSID.
	//
	HRESULT GetActiveObject(LPOLESTR clsidString) throw()
	{
		if (clsidString == NULL) {
			return E_INVALIDARG;
		}

		CLSID clsid;
		HRESULT hr;

		if (clsidString[0] == '{') {
			hr = CLSIDFromString(clsidString, &clsid);
		}
		else {
			hr = CLSIDFromProgID(clsidString, &clsid);
		}

		if (FAILED(hr)) {
			return hr;
		}

		return GetActiveObject(clsid);
	}

	// Attach to the active object specified by clsidStringA.
	// First convert the LPCSTR to a LPOLESTR.
	//
	HRESULT GetActiveObject(LPCSTR clsidStringA) throw()
	{
		if (clsidStringA == NULL) {
			return E_INVALIDARG;
		}

		int size = lstrlenA(clsidStringA) + 1;
		LPOLESTR clsidStringW = static_cast<LPOLESTR>(_alloca(size * 2));

		clsidStringW[0] = '\0';

		if (MultiByteToWideChar(CP_ACP, 0, clsidStringA, -1, clsidStringW, size) == 0) {
			return HRESULT_FROM_WIN32(GetLastError());
		}

		return GetActiveObject(clsidStringW);
	}

	// Performs the QI for the specified IID and returns it in p.
	// As with all QIs, the interface will be AddRef'd.
	//
	template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType*& p) throw ()
	{
		if (m_pInterface != NULL) {
			return m_pInterface->QueryInterface(iid, reinterpret_cast<void**>(&p));
		}

		return E_POINTER;
	}

	// Performs the QI for the specified IID and returns it in p.
	// As with all QIs, the interface will be AddRef'd.
	//
	template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType** p) throw()
	{
		return QueryInterface(iid, *p);
	}

private:
	// The Interface.
	//
	Interface* m_pInterface;

	// Releases only if the interface is not null.
	// The interface is not set to NULL.
	//
	void _Release() throw()
	{
		if (m_pInterface != NULL) {
			m_pInterface->Release();
		}
	}

	// AddRefs only if the interface is not NULL
	//
	void _AddRef() throw()
	{
		if (m_pInterface != NULL) {
			m_pInterface->AddRef();
		}
	}

	// Performs a QI on pUnknown for the interface type returned
	// for this class.  The interface is stored.  If pUnknown is
	// NULL, or the QI fails, E_NOINTERFACE is returned and
	// _pInterface is set to NULL.
	//
	template<typename _InterfacePtr> HRESULT _QueryInterface(const _InterfacePtr& p) throw()
	{
		HRESULT hr;

		// Can't QI NULL
		//
		if (p) {
			// Query for this interface
			//
			Interface* pInterface;
			hr = p->QueryInterface(GetIID(), reinterpret_cast<void**>(&pInterface));

			if (FAILED(hr)) {
				// If failed initialize interface to NULL and return HRESULT.
				//
				Attach(NULL);
				return hr;
			}

			// Save the interface without AddRef()ing.
			//
			Attach(pInterface);
		}
		else {
			operator=(static_cast<Interface*>(NULL));
			hr = E_NOINTERFACE;
		}

		return hr;
	}

	// Compares the provided pointer with this by obtaining IUnknown interfaces
	// for each pointer and then returning the difference.
	//
	template<typename _InterfacePtr> int _CompareUnknown(_InterfacePtr p) throw(_com_error)
	{
		IUnknown* pu1, *pu2;

		if (m_pInterface != NULL) {
			HRESULT hr = m_pInterface->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void**>(&pu1));

			if (FAILED(hr)) {
				_com_issue_error(hr);
			}

			pu1->Release();
		}
		else {
			pu1 = NULL;
		}

		if (p) {
			HRESULT hr = p->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void**>(&pu2));

			if (FAILED(hr)) {
				_com_issue_error(hr);
			}

			pu2->Release();
		}
		else {
			pu2 = NULL;
		}

		return pu1 - pu2;
	}

	// Try to extract either IDispatch* or an IUnknown* from
	// the VARIANT
	//
	HRESULT QueryStdInterfaces(const _variant_t& varSrc) throw()
	{
		if (V_VT(&varSrc) == VT_DISPATCH) {
			return _QueryInterface(V_DISPATCH(&varSrc));
		}

		if (V_VT(&varSrc) == VT_UNKNOWN) {
			return _QueryInterface(V_UNKNOWN(&varSrc));
		}

		// We have something other than an IUnknown or an IDispatch.
		// Can we convert it to either one of these?
		// Try IDispatch first
		//
		VARIANT varDest;
		VariantInit(&varDest);

		HRESULT hr = VariantChangeType(&varDest, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc)), 0, VT_DISPATCH);
		if (SUCCEEDED(hr)) {
			hr = _QueryInterface(V_DISPATCH(&varSrc));
		}

		if (FAILED(hr) && (hr == E_NOINTERFACE)) {
			// That failed ... so try IUnknown
			//
			VariantInit(&varDest);
			hr = VariantChangeType(&varDest, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc)), 0, VT_UNKNOWN);
			if (SUCCEEDED(hr)) {
				hr = _QueryInterface(V_UNKNOWN(&varSrc));
			}
		}

		VariantClear(&varDest);
		return hr;
	}
};

// Reverse comparison operators for _com_ptr_t
//
template<typename _InterfaceType> bool operator==(int null, _com_ptr_t<_InterfaceType>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p == NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator==(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p == i;
}

template<typename _Interface> bool operator!=(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p != NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator!=(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p != i;
}

template<typename _Interface> bool operator<(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p > NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator<(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p > i;
}

template<typename _Interface> bool operator>(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p < NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator>(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p < i;
}

template<typename _Interface> bool operator<=(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p >= NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator<=(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p >= i;
}

template<typename _Interface> bool operator>=(int null, _com_ptr_t<_Interface>& p) throw(_com_error)
{
	if (null != 0) {
		_com_issue_error(E_POINTER);
	}

	return p <= NULL;
}

template<typename _Interface, typename _InterfacePtr> bool operator>=(_Interface* i, _com_ptr_t<_InterfacePtr>& p) throw(_com_error)
{
	return p <= i;
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif // _INC_COMIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\vccomsupport\comdef.h ===
/***
* comdef.h - Native C++ compiler COM support - main definitions header
*
*       Copyright (C) 1996-1999 Microsoft Corporation
*       All rights reserved.
*
****/

#if !defined(_INC_COMDEF)
#define _INC_COMDEF

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef  __cplusplus
#error Native Compiler support only available in C++ compiler
#endif

#include <ole2.h>
#include <olectl.h>

#include <comutil.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4244)
#pragma warning(disable: 4290)

#pragma comment(lib, "comsupp.lib")

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")

class _com_error;

void __stdcall
        _com_raise_error(HRESULT hr, IErrorInfo* perrinfo = 0) throw(_com_error);

void __stdcall
        _com_issue_error(HRESULT) throw(_com_error);
void __stdcall
        _com_issue_errorex(HRESULT, IUnknown*, REFIID) throw(_com_error);

HRESULT __stdcall
        _com_dispatch_propget(IDispatch*, DISPID, VARTYPE, void*) throw(_com_error);
HRESULT __cdecl
        _com_dispatch_propput(IDispatch*, DISPID, VARTYPE, ...) throw(_com_error);
HRESULT __cdecl
        _com_dispatch_method(IDispatch*, DISPID, WORD, VARTYPE, void*,
                                                 const wchar_t*, ...) throw(_com_error);

HRESULT __stdcall
        _com_dispatch_raw_propget(IDispatch*, DISPID, VARTYPE, void*) throw();
HRESULT __cdecl
        _com_dispatch_raw_propput(IDispatch*, DISPID, VARTYPE, ...) throw();
HRESULT __cdecl
        _com_dispatch_raw_method(IDispatch*, DISPID, WORD, VARTYPE, void*,
                                                         const wchar_t*, ...) throw();

class _com_error {
public:
        // Constructors
        //
        _com_error(HRESULT hr,
               IErrorInfo* perrinfo = NULL,
               bool fAddRef = false) throw();
        _com_error(const _com_error& that) throw();

        // Destructor
        //
        virtual ~_com_error() throw();

        // Assignment operator
        //
        _com_error& operator=(const _com_error& that) throw();

        // Accessors
        //
        HRESULT Error() const throw();
        WORD WCode() const throw();
        IErrorInfo * ErrorInfo() const throw();

        // IErrorInfo method accessors
        //
        _bstr_t Description() const throw(_com_error);
        DWORD HelpContext() const throw();
        _bstr_t HelpFile() const throw(_com_error);
        _bstr_t Source() const throw(_com_error);
        GUID GUID() const throw();

        // FormatMessage accessors
        const TCHAR * ErrorMessage() const throw();

        // EXCEPINFO.wCode <-> HRESULT mappers
        static HRESULT WCodeToHRESULT(WORD wCode) throw();
        static WORD HRESULTToWCode(HRESULT hr) throw();

private:
        enum {
                WCODE_HRESULT_FIRST = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x200),
                WCODE_HRESULT_LAST = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF+1, 0) - 1
        };
        const HRESULT                   m_hresult;
        IErrorInfo *                    m_perrinfo;
        mutable TCHAR *                 m_pszMsg;
};

inline _com_error::_com_error(HRESULT hr,
                              IErrorInfo* perrinfo,
                              bool fAddRef) throw()
        : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)
{
        if (m_perrinfo != NULL && fAddRef) {
                m_perrinfo->AddRef();
        }
}

inline _com_error::_com_error(const _com_error& that) throw()
        : m_hresult(that.m_hresult), m_perrinfo(that.m_perrinfo), m_pszMsg(NULL)
{
        if (m_perrinfo != NULL) {
                m_perrinfo->AddRef();
        }
}

inline _com_error::~_com_error() throw()
{
        if (m_perrinfo != NULL) {
                m_perrinfo->Release();
        }
        if (m_pszMsg != NULL) {
                LocalFree((HLOCAL)m_pszMsg);
        }
}

inline _com_error& _com_error::operator=(const _com_error& that) throw()
{
        if (this != &that) {
                this->_com_error::~_com_error();
                this->_com_error::_com_error(that);
        }
        return *this;
}

inline HRESULT _com_error::Error() const throw()
{
        return m_hresult;
}

inline WORD _com_error::WCode() const throw()
{
        return HRESULTToWCode(m_hresult);
}

inline IErrorInfo * _com_error::ErrorInfo() const throw()
{
        if (m_perrinfo != NULL) {
                m_perrinfo->AddRef();
        }
        return m_perrinfo;
}

inline _bstr_t _com_error::Description() const throw(_com_error)
{
        BSTR bstr = NULL;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetDescription(&bstr);
        }
        return _bstr_t(bstr, false);
}

inline DWORD _com_error::HelpContext() const throw()
{
        DWORD dwHelpContext = 0;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetHelpContext(&dwHelpContext);
        }
        return dwHelpContext;
}

inline _bstr_t _com_error::HelpFile() const throw(_com_error)
{
        BSTR bstr = NULL;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetHelpFile(&bstr);
        }
        return _bstr_t(bstr, false);
}

inline _bstr_t _com_error::Source() const throw(_com_error)
{
        BSTR bstr = NULL;
        if (m_perrinfo != NULL) {
                m_perrinfo->GetSource(&bstr);
        }
        return _bstr_t(bstr, false);
}

inline _GUID _com_error::GUID() const throw()
{
        _GUID guid;
        memcpy(&guid, &__uuidof(NULL), sizeof(_GUID));
        if (m_perrinfo != NULL) {
                m_perrinfo->GetGUID(&guid);
        }
        return guid;
}

inline const TCHAR * _com_error::ErrorMessage() const throw()
{
        if (m_pszMsg == NULL) {
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
                                          NULL,
                                          m_hresult,
                                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                          (LPTSTR)&m_pszMsg,
                                          0,
                                          NULL );
                if (m_pszMsg != NULL) {
                        int nLen = lstrlen(m_pszMsg);
                        if (nLen > 1 && m_pszMsg[nLen - 1] == '\n') {
                                m_pszMsg[nLen - 1] = 0;
                                if (m_pszMsg[nLen - 2] == '\r') {
                                        m_pszMsg[nLen - 2] = 0;
                                }
                        }
                } else {
                        m_pszMsg = (LPTSTR)LocalAlloc(0, 32 * sizeof(TCHAR));
                        if (m_pszMsg != NULL) {
                                WORD wCode = WCode();
                                if (wCode != 0) {
                                        wsprintf(m_pszMsg, TEXT("IDispatch error #%d"), wCode);
                                } else {
                                        wsprintf(m_pszMsg, TEXT("Unknown error 0x%0lX"), m_hresult);
                                }
                        }
                }
        }
        return m_pszMsg;
}

inline HRESULT _com_error::WCodeToHRESULT(WORD wCode) throw()
{
        return wCode >= 0xFE00 ? WCODE_HRESULT_LAST : WCODE_HRESULT_FIRST + wCode;
}

inline WORD _com_error::HRESULTToWCode(HRESULT hr) throw()
{
        return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)
                ? WORD(hr - WCODE_HRESULT_FIRST)
                : 0;
}

#if !defined(_COM_SMARTPTR)
 #if !defined(_INC_COMIP)
  #include <comip.h>
 #endif
 #define _COM_SMARTPTR        _com_ptr_t
 #define _COM_SMARTPTR_LEVEL2 _com_IIID
#endif
#if defined(_COM_SMARTPTR)
 #if !defined(_COM_SMARTPTR_TYPEDEF)
  #if defined(_COM_SMARTPTR_LEVEL2
   #define _COM_SMARTPTR_TYPEDEF(Interface, IID) \
    typedef _COM_SMARTPTR<_COM_SMARTPTR_LEVEL2<Interface, &IID> > \
            Interface ## Ptr
  #else
   #define _COM_SMARTPTR_TYPEDEF(Interface, IID) \
    typedef _COM_SMARTPTR<Interface, &IID> \
            Interface ## Ptr
  #endif
 #endif
#endif

#if !defined(_COM_NO_STANDARD_GUIDS_)

#ifdef _WIN64
#define     IActiveScriptParse                  IActiveScriptParse64
#define     IActiveScriptParseProcedureOld      IActiveScriptParseProcedureOld64
#define     IActiveScriptParseProcedure         IActiveScriptParseProcedure64
#define     IActiveScriptParseProcedure2        IActiveScriptParseProcedure2_64
#else
#define     IActiveScriptParse                  IActiveScriptParse32
#define     IActiveScriptParseProcedureOld      IActiveScriptParseProcedureOld32
#define     IActiveScriptParseProcedure         IActiveScriptParseProcedure32
#define     IActiveScriptParseProcedure2        IActiveScriptParseProcedure2_32
#endif

// Interfaces:

struct __declspec(uuid("0000013D-0000-0000-C000-000000000046")) IClientSecurity;
struct __declspec(uuid("0000013E-0000-0000-C000-000000000046")) IServerSecurity;
struct __declspec(uuid("00000140-0000-0000-C000-000000000046")) IClassActivator;
struct __declspec(uuid("00020d00-0000-0000-c000-000000000046")) IRichEditOle;
struct __declspec(uuid("00020d03-0000-0000-c000-000000000046")) IRichEditOleCallback;
struct __declspec(uuid("000214e1-0000-0000-c000-000000000046")) INewShortcutHookA;
struct __declspec(uuid("000214e2-0000-0000-c000-000000000046")) IShellBrowser;
struct __declspec(uuid("000214e3-0000-0000-c000-000000000046")) IShellView;
struct __declspec(uuid("000214e4-0000-0000-c000-000000000046")) IContextMenu;
struct __declspec(uuid("000214e5-0000-0000-c000-000000000046")) IShellIcon;
struct __declspec(uuid("000214e6-0000-0000-c000-000000000046")) IShellFolder;
struct __declspec(uuid("000214e8-0000-0000-c000-000000000046")) IShellExtInit;
struct __declspec(uuid("000214e9-0000-0000-c000-000000000046")) IShellPropSheetExt;
struct __declspec(uuid("000214ea-0000-0000-c000-000000000046")) IPersistFolder;
struct __declspec(uuid("000214eb-0000-0000-c000-000000000046")) IExtractIconA;
struct __declspec(uuid("000214ee-0000-0000-c000-000000000046")) IShellLinkA;
struct __declspec(uuid("000214f0-0000-0000-c000-000000000046")) IFileViewerA;
struct __declspec(uuid("000214f1-0000-0000-c000-000000000046")) ICommDlgBrowser;
struct __declspec(uuid("000214f2-0000-0000-c000-000000000046")) IEnumIDList;
struct __declspec(uuid("000214f3-0000-0000-c000-000000000046")) IFileViewerSite;
struct __declspec(uuid("000214f4-0000-0000-c000-000000000046")) IContextMenu2;
struct __declspec(uuid("000214f5-0000-0000-c000-000000000046")) IShellExecuteHookA;
struct __declspec(uuid("000214f7-0000-0000-c000-000000000046")) INewShortcutHookW;
struct __declspec(uuid("000214f8-0000-0000-c000-000000000046")) IFileViewerW;
struct __declspec(uuid("000214f9-0000-0000-c000-000000000046")) IShellLinkW;
struct __declspec(uuid("000214fa-0000-0000-c000-000000000046")) IExtractIconW;
struct __declspec(uuid("000214fb-0000-0000-c000-000000000046")) IShellExecuteHookW;
struct __declspec(uuid("00021500-0000-0000-c000-000000000046")) IQueryInfo;
struct __declspec(uuid("0002DF05-0000-0000-C000-000000000046")) IWebBrowserApp;
struct __declspec(uuid("0002E000-0000-0000-C000-000000000046")) IEnumGUID;
struct __declspec(uuid("0002E011-0000-0000-C000-000000000046")) IEnumCATEGORYINFO;
struct __declspec(uuid("0002E012-0000-0000-C000-000000000046")) ICatRegister;
struct __declspec(uuid("0002E013-0000-0000-C000-000000000046")) ICatInformation;
struct __declspec(uuid("012dd920-7b26-11d0-8ca9-00a0c92dbfe8")) IDockingWindow;
struct __declspec(uuid("3050f4e9-98b5-11cf-bb82-00aa00bdce0b")) IHTMLControlElement;
struct __declspec(uuid("085FB2C0-0DF8-11D1-8F4B-00A0C905413F")) ISubscriptionMgr;
struct __declspec(uuid("08EC3E00-50B0-11CF-960C-0080C7F4EE85")) FolderItemVerb;
struct __declspec(uuid("0c6c4200-c589-11d0-999a-00c04fd655e1")) IShellIconOverlayIdentifier;
struct __declspec(uuid("1008C4A0-7613-11CF-9AF1-0020AF6E72F4")) IChannelHook;
struct __declspec(uuid("163BB1E0-6E00-11CF-837A-48DC04C10000")) IHTMLLocation;
struct __declspec(uuid("1CFF0050-6FDD-11D0-9328-00A0C90DCAA9")) IActiveScriptParseProcedureOld32;
struct __declspec(uuid("1F8352C0-50B0-11CF-960C-0080C7F4EE85")) FolderItemVerbs;
struct __declspec(uuid("1ac3d9f0-175c-11d1-95be-00609797ea4f")) IPersistFolder2;
struct __declspec(uuid("21F57128-08C9-4638-BA12-22D15D88DC5C")) IActiveScriptParseProcedureOld64;
struct __declspec(uuid("275C23E1-3747-11D0-9FEA-00AA003F8646")) IMultiLanguage;
struct __declspec(uuid("275C23E3-3747-11D0-9FEA-00AA003F8646")) IEnumCodePage;
struct __declspec(uuid("2a342fc2-7b26-11d0-8ca9-00a0c92dbfe8")) IDockingWindowSite;
struct __declspec(uuid("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBodyElement;
struct __declspec(uuid("3050F1D9-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontElement;
struct __declspec(uuid("3050F1DA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAnchorElement;
struct __declspec(uuid("3050F1DD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLUListElement;
struct __declspec(uuid("3050F1DE-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOListElement;
struct __declspec(uuid("3050F1E0-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLIElement;
struct __declspec(uuid("3050F1F0-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBRElement;
struct __declspec(uuid("3050F1F1-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDListElement;
struct __declspec(uuid("3050F1F2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDDElement;
struct __declspec(uuid("3050F1F3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDTElement;
struct __declspec(uuid("3050F1F4-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLHRElement;
struct __declspec(uuid("3050F1F5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLParaElement;
struct __declspec(uuid("3050F1F6-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLHeaderElement;
struct __declspec(uuid("3050F1F7-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFormElement;
struct __declspec(uuid("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLElement;
struct __declspec(uuid("3050F200-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDivElement;
struct __declspec(uuid("3050F202-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBaseFontElement;
struct __declspec(uuid("3050F203-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMetaElement;
struct __declspec(uuid("3050F204-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBaseElement;
struct __declspec(uuid("3050F205-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLinkElement;
struct __declspec(uuid("3050F206-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLIsIndexElement;
struct __declspec(uuid("3050F207-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLNextIdElement;
struct __declspec(uuid("3050F208-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBlockElement;
struct __declspec(uuid("3050F209-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLUnknownElement;
struct __declspec(uuid("3050F20A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLPhraseElement;
struct __declspec(uuid("3050F20C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLCommentElement;
struct __declspec(uuid("3050F20E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLListElement;
struct __declspec(uuid("3050F211-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionElement;
struct __declspec(uuid("3050F212-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDivPosition;
struct __declspec(uuid("3050F216-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDialog;
struct __declspec(uuid("3050F218-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextElement;
struct __declspec(uuid("3050F21E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTable;
struct __declspec(uuid("3050F21F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLElementCollection;
struct __declspec(uuid("3050F220-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTxtRange;
struct __declspec(uuid("3050F230-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextContainer;
struct __declspec(uuid("3050F23A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCol;
struct __declspec(uuid("3050F23B-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableSection;
struct __declspec(uuid("3050F23C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableRow;
struct __declspec(uuid("3050F23D-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCell;
struct __declspec(uuid("3050F240-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLImgElement;
struct __declspec(uuid("3050F244-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSelectElement;
struct __declspec(uuid("3050F24F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLObjectElement;
struct __declspec(uuid("3050F25A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSelectionObject;
struct __declspec(uuid("3050F25E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyle;
struct __declspec(uuid("3050F25F-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLEmbedElement;
struct __declspec(uuid("3050F265-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAreaElement;
struct __declspec(uuid("3050F266-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMapElement;
struct __declspec(uuid("3050F28B-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLScriptElement;
struct __declspec(uuid("3050F29C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLControlRange;
struct __declspec(uuid("3050F2A4-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputHiddenElement;
struct __declspec(uuid("3050F2A6-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputTextElement;
struct __declspec(uuid("3050F2AA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTextAreaElement;
struct __declspec(uuid("3050F2AD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputFileElement;
struct __declspec(uuid("3050F2B2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputButtonElement;
struct __declspec(uuid("3050F2B5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMarqueeElement;
struct __declspec(uuid("3050F2BB-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLButtonElement;
struct __declspec(uuid("3050F2BC-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionButtonElement;
struct __declspec(uuid("3050F2C2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLInputImage;
struct __declspec(uuid("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheet;
struct __declspec(uuid("3050F2E5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetRulesCollection;
struct __declspec(uuid("3050F2EB-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTableCaption;
struct __declspec(uuid("3050F2F4-98B5-11CF-BB82-00AA00BDCE0B")) IViewFilterSite;
struct __declspec(uuid("3050F311-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameBase;
struct __declspec(uuid("3050F313-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameElement;
struct __declspec(uuid("3050F315-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLIFrameElement;
struct __declspec(uuid("3050F319-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFrameSetElement;
struct __declspec(uuid("3050F322-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLTitleElement;
struct __declspec(uuid("3050F32A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLabelElement;
struct __declspec(uuid("3050F32D-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLEventObj;
struct __declspec(uuid("3050F357-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetRule;
struct __declspec(uuid("3050F35C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLScreen;
struct __declspec(uuid("3050F35F-98B5-11CF-BB82-00AA00BDCE0B")) ITimerService;
struct __declspec(uuid("3050F360-98B5-11CF-BB82-00AA00BDCE0B")) ITimer;
struct __declspec(uuid("3050F361-98B5-11CF-BB82-00AA00BDCE0B")) ITimerSink;
struct __declspec(uuid("3050F369-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLBGsound;
struct __declspec(uuid("3050F372-98B5-11CF-BB82-00AA00BDCE0B")) IViewTransition;
struct __declspec(uuid("3050F373-98B5-11CF-BB82-00AA00BDCE0B")) IViewTransitionSite;
struct __declspec(uuid("3050F375-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleElement;
struct __declspec(uuid("3050F376-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontNamesCollection;
struct __declspec(uuid("3050F377-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFontSizesCollection;
struct __declspec(uuid("3050F378-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionsHolder;
struct __declspec(uuid("3050F37E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleSheetsCollection;
struct __declspec(uuid("3050F383-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLAreasCollection;
struct __declspec(uuid("3050F38A-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLNoShowElement;
struct __declspec(uuid("3050F38C-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOptionElementFactory;
struct __declspec(uuid("3050F38E-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLImageElementFactory;
struct __declspec(uuid("3050F3CF-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLRuleStyle;
struct __declspec(uuid("3050F3D5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLStyleFontFace;
struct __declspec(uuid("3050F3E5-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSpanFlow;
struct __declspec(uuid("3050F3E7-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFieldSetElement;
struct __declspec(uuid("3050F3EA-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLLegendElement;
struct __declspec(uuid("3050F3EC-98B5-11CF-BB82-00AA00BDCE0B")) ICSSFilter;
struct __declspec(uuid("3050F3ED-98B5-11CF-BB82-00AA00BDCE0B")) ICSSFilterSite;
struct __declspec(uuid("3050F3EE-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLFiltersCollection;
struct __declspec(uuid("3050F3F0-98B5-11CF-BB82-00AA00BDCE0B")) ICustomDoc;
struct __declspec(uuid("3050F3F2-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLDatabinding;
struct __declspec(uuid("3050F3F3-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLSpanElement;
struct __declspec(uuid("3050F3FC-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLMimeTypesCollection;
struct __declspec(uuid("3050F3FD-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLPluginsCollection;
struct __declspec(uuid("3050F401-98B5-11CF-BB82-00AA00BDCE0B")) IHTMLOpsProfile;
struct __declspec(uuid("3050f3d7-98b5-11cf-bb82-00aa00bdce0b")) IImgCtx;
struct __declspec(uuid("332C4425-26CB-11D0-B483-00C04FD90119")) IHTMLDocument2;
struct __declspec(uuid("332C4426-26CB-11D0-B483-00C04FD90119")) IHTMLFramesCollection2;
struct __declspec(uuid("332C4427-26CB-11D0-B483-00C04FD90119")) IHTMLWindow2;
struct __declspec(uuid("359F3441-BD4A-11D0-B188-00AA0038C969")) IMLangFontLink;
struct __declspec(uuid("359F3443-BD4A-11D0-B188-00AA0038C969")) IMLangCodePages;
struct __declspec(uuid("3C374A41-BAE4-11CF-BF7D-00AA006946EE")) IUrlHistoryStg;
struct __declspec(uuid("3C374A42-BAE4-11CF-BF7D-00AA006946EE")) IEnumSTATURL;
struct __declspec(uuid("3DC39D1D-C030-11D0-B81B-00C04FC9B31F")) IEnumRfc1766;
struct __declspec(uuid("47d2657a-7b27-11d0-8ca9-00a0c92dbfe8")) IDockingWindowFrame;
struct __declspec(uuid("539698A0-CDCA-11CF-A5EB-00AA0047A063")) IActiveScriptSiteInterruptPoll;
struct __declspec(uuid("618736e0-3c3d-11cf-810c-00aa00389b71")) IAccessible;
struct __declspec(uuid("626FC520-A41E-11CF-A731-00A0C9082637")) IHTMLDocument;
struct __declspec(uuid("63CDBCB0-C1B1-11D0-9336-00A0C90DCAA9")) IBindEventHandler;
struct __declspec(uuid("68284faa-6a48-11d0-8c78-00c04fd918b4")) IInputObject;
struct __declspec(uuid("71EE5B20-FB04-11d1-B3A8-00A0C911E8B2")) IActiveScriptParseProcedure2_32;
struct __declspec(uuid("729FE2F8-1EA8-11D1-8F85-00C04FC2FBE1")) IShellUIHelper;
struct __declspec(uuid("744129E0-CBE5-11CE-8350-444553540000")) FolderItems;
struct __declspec(uuid("79EAC9C2-BAF9-11CE-8C82-00AA004BA90B")) IHlinkSite;
struct __declspec(uuid("79EAC9C3-BAF9-11CE-8C82-00AA004BA90B")) IHlink;
struct __declspec(uuid("79EAC9C4-BAF9-11CE-8C82-00AA004BA90B")) IHlinkTarget;
struct __declspec(uuid("79EAC9C5-BAF9-11CE-8C82-00AA004BA90B")) IHlinkFrame;
struct __declspec(uuid("79EAC9C6-BAF9-11CE-8C82-00AA004BA90B")) IEnumHLITEM;
struct __declspec(uuid("79EAC9C7-BAF9-11CE-8C82-00AA004BA90B")) IHlinkBrowseContext;
struct __declspec(uuid("79EAC9CB-BAF9-11CE-8C82-00AA004BA90B")) IExtensionServices;
struct __declspec(uuid("7d688a70-c613-11d0-999b-00c04fd655e1")) IShellIconOverlay;
struct __declspec(uuid("85BD8E82-0FBA-11D1-90C3-00C04FC2F568")) IChannelMgr;
struct __declspec(uuid("85CB6900-4D95-11CF-960C-0080C7F4EE85")) IShellWindows;
struct __declspec(uuid("88A05C00-F000-11CE-8350-444553540000")) IShellLinkDual;
struct __declspec(uuid("88e39e80-3578-11cf-ae69-08002b2e1262")) IShellView2;
struct __declspec(uuid("89BCB740-6119-101A-BCB7-00DD010655AF")) IFilter;
struct __declspec(uuid("91A565C1-E38F-11D0-94BF-00A0C9055CBF")) IPersistHistory;
struct __declspec(uuid("9BA05970-F6A8-11CF-A442-00A0C90A8F39")) IFolderViewOC;
struct __declspec(uuid("A3CCEDF3-2DE2-11D0-86F4-00A0C913F750")) IImageDecodeFilter;
struct __declspec(uuid("A4C65425-0F82-11D1-90C3-00C04FC2F568")) IEnumChannels;
struct __declspec(uuid("A6EF9860-C720-11D0-9337-00A0C90DCAA9")) IDispatchEx;
struct __declspec(uuid("A6EF9861-C720-11D0-9337-00A0C90DCAA9")) IDispError;
struct __declspec(uuid("A6EF9862-C720-11D0-9337-00A0C90DCAA9")) IVariantChangeType;
struct __declspec(uuid("AA5B6A80-B834-11D0-932F-00A0C90DCAA9")) IActiveScriptParseProcedure32;
struct __declspec(uuid("AFA0DC11-C313-11D0-831A-00C04FD5AE38")) IUrlHistoryStg2;
struct __declspec(uuid("B722BCC5-4E68-101B-A2BC-00AA00404770")) IOleDocument;
struct __declspec(uuid("B722BCC6-4E68-101B-A2BC-00AA00404770")) IOleDocumentView;
struct __declspec(uuid("B722BCC7-4E68-101B-A2BC-00AA00404770")) IOleDocumentSite;
struct __declspec(uuid("B722BCC8-4E68-101B-A2BC-00AA00404770")) IEnumOleDocumentViews;
struct __declspec(uuid("B722BCC9-4E68-101B-A2BC-00AA00404770")) IPrint;
struct __declspec(uuid("B722BCCA-4E68-101B-A2BC-00AA00404770")) IContinueCallback;
struct __declspec(uuid("B722BCCB-4E68-101B-A2BC-00AA00404770")) IOleCommandTarget;
struct __declspec(uuid("B8DA6310-E19B-11D0-933C-00A0C90DCAA9")) IActiveScriptStats;
struct __declspec(uuid("BAA342A0-2DED-11D0-86F4-00A0C913F750")) IImageDecodeEventSink;
struct __declspec(uuid("BB1A2AE1-A4F9-11CF-8F20-00805F2CD064")) IActiveScript;
struct __declspec(uuid("BB1A2AE2-A4F9-11CF-8F20-00805F2CD064")) IActiveScriptParse32;
struct __declspec(uuid("BC40BEC1-C493-11D0-831B-00C04FD5AE38")) IUrlHistoryNotify;
struct __declspec(uuid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A")) IDocHostUIHandler;
struct __declspec(uuid("C04D65CE-B70D-11D0-B188-00AA0038C969")) IMLangString;
struct __declspec(uuid("C04D65D0-B70D-11D0-B188-00AA0038C969")) IMLangStringWStr;
struct __declspec(uuid("C04D65D2-B70D-11D0-B188-00AA0038C969")) IMLangStringAStr;
struct __declspec(uuid("C4D244B0-D43E-11CF-893B-00AA00BDCE1A")) IDocHostShowUI;
struct __declspec(uuid("C64713B6-E029-4CC5-9200-438B72890B6A")) IActiveScriptParseProcedure64;
struct __declspec(uuid("C7EF7658-E1EE-480E-97EA-D52CB4D76D17")) IActiveScriptParse64;
struct __declspec(uuid("CA04B7E6-0D21-11D1-8CC5-00C04FC2B085")) IObjectIdentity;
struct __declspec(uuid("CB5BDC81-93C1-11CF-8F20-00805F2CD064")) IObjectSafety;
struct __declspec(uuid("D10F6761-83E9-11CF-8F20-00805F2CD064")) IActiveScriptSiteWindow;
struct __declspec(uuid("D24ACD21-BA72-11D0-B188-00AA0038C969")) IMLangStringBufW;
struct __declspec(uuid("D24ACD23-BA72-11D0-B188-00AA0038C969")) IMLangStringBufA;
struct __declspec(uuid("D30C1661-CDAF-11D0-8A3E-00C04FC9E26E")) IWebBrowser2;
struct __declspec(uuid("D66D6F98-CDAA-11D0-B822-00C04FC9B31F")) IMLangConvertCharset;
struct __declspec(uuid("D8F015C0-C278-11CE-A49E-444553540000")) IShellDispatch;
struct __declspec(uuid("D9E89500-30FA-11D0-B724-00AA006C1A01")) IMapMIMEToCLSID;
struct __declspec(uuid("DB01A1E3-A42B-11CF-8F20-00805F2CD064")) IActiveScriptSite;
struct __declspec(uuid("E0E270C0-C0BE-11D0-8FE4-00A0C90A6341")) OLEDBSimpleProvider;
struct __declspec(uuid("E0E270C1-C0BE-11D0-8FE4-00A0C90A6341")) OLEDBSimpleProviderListener;
struct __declspec(uuid("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")) IShellFolderViewDual;
struct __declspec(uuid("EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B")) IWebBrowser;
struct __declspec(uuid("EAE1BA61-A4ED-11CF-8F20-00805F2CD064")) IActiveScriptError;
struct __declspec(uuid("F5BE2EE1-BFD7-11D0-B188-00AA0038C969")) IMLangLineBreakConsole;
struct __declspec(uuid("F77459A0-BF9A-11CF-BA4E-00C04FD70816")) IMimeInfo;
struct __declspec(uuid("FAC32C80-CBE4-11CE-8350-444553540000")) FolderItem;
struct __declspec(uuid("FE7C4271-210C-448D-9F54-76DAB7047B28")) IActiveScriptParseProcedure2_64;
struct __declspec(uuid("FECEAAA2-8405-11CF-8BA1-00AA00476DA6")) IOmHistory;
struct __declspec(uuid("FECEAAA5-8405-11CF-8BA1-00AA00476DA6")) IOmNavigator;
struct __declspec(uuid("ac60f6a0-0fd9-11d0-99cb-00c04fd64497")) IURLSearchHook;
struct __declspec(uuid("bcfce0a0-ec17-11d0-8d10-00a0c90f2719")) IContextMenu3;
struct __declspec(uuid("cabb0da0-da57-11cf-9974-0020afd79762")) IUniformResourceLocatorW;
struct __declspec(uuid("eb0fe172-1a3a-11d0-89b3-00a0c90a90ac")) IDeskBand;
struct __declspec(uuid("f1db8392-7331-11d0-8c99-00a0c92dbfe8")) IInputObjectSite;
struct __declspec(uuid("f490eb00-1240-11d1-9888-006097deacf9")) IActiveDesktop;
struct __declspec(uuid("fbf23b80-e3f0-101b-8488-00aa003e56f8")) IUniformResourceLocatorA;

// CoClasses:

class __declspec(uuid("00000017-0000-0000-c000-000000000046")) StdMarshal;
class __declspec(uuid("0000001b-0000-0000-c000-000000000046")) IdentityUnmarshal;
class __declspec(uuid("0000001c-0000-0000-c000-000000000046")) InProcFreeMarshaler;
class __declspec(uuid("0000030c-0000-0000-c000-000000000046")) PSGenObject;
class __declspec(uuid("0000030d-0000-0000-c000-000000000046")) PSClientSite;
class __declspec(uuid("0000030e-0000-0000-c000-000000000046")) PSClassObject;
class __declspec(uuid("0000030f-0000-0000-c000-000000000046")) PSInPlaceActive;
class __declspec(uuid("00000310-0000-0000-c000-000000000046")) PSInPlaceFrame;
class __declspec(uuid("00000311-0000-0000-c000-000000000046")) PSDragDrop;
class __declspec(uuid("00000312-0000-0000-c000-000000000046")) PSBindCtx;
class __declspec(uuid("00000313-0000-0000-c000-000000000046")) PSEnumerators;
class __declspec(uuid("00000315-0000-0000-c000-000000000046")) Picture_Metafile;
class __declspec(uuid("00000315-0000-0000-c000-000000000046")) StaticMetafile;
class __declspec(uuid("00000316-0000-0000-c000-000000000046")) Picture_Dib;
class __declspec(uuid("00000316-0000-0000-c000-000000000046")) StaticDib;
class __declspec(uuid("00000319-0000-0000-c000-000000000046")) Picture_EnhMetafile;
class __declspec(uuid("0000031d-0000-0000-c000-000000000046")) DCOMAccessControl;
class __declspec(uuid("00021400-0000-0000-c000-000000000046")) ShellDesktop;
class __declspec(uuid("00021401-0000-0000-c000-000000000046")) ShellLink;
class __declspec(uuid("0002DF01-0000-0000-C000-000000000046")) InternetExplorer;
class __declspec(uuid("0002e005-0000-0000-c000-000000000046")) StdComponentCategoriesMgr;
class __declspec(uuid("08165ea0-e946-11cf-9c87-00aa005127ed")) WebCrawlerAgent;
class __declspec(uuid("0A89A860-D7B1-11CE-8350-444553540000")) ShellDispatchInproc;
class __declspec(uuid("0D04D285-6BEC-11CF-8B97-00AA00476DA6")) OldHTMLFormElement;
class __declspec(uuid("0be35200-8f91-11ce-9de3-00aa004bb851")) CFontPropPage;
class __declspec(uuid("0be35201-8f91-11ce-9de3-00aa004bb851")) CColorPropPage;
class __declspec(uuid("0be35202-8f91-11ce-9de3-00aa004bb851")) CPicturePropPage;
class __declspec(uuid("0be35203-8f91-11ce-9de3-00aa004bb851")) StdFont;
class __declspec(uuid("0be35204-8f91-11ce-9de3-00aa004bb851")) StdPicture;
class __declspec(uuid("11219420-1768-11D1-95BE-00609797EA4F")) ShellLinkObject;
class __declspec(uuid("163BB1E1-6E00-11CF-837A-48DC04C10000")) HTMLLocation;
class __declspec(uuid("1820FED0-473E-11D0-A96C-00C04FD705A2")) WebViewFolderContents;
class __declspec(uuid("25336920-03F9-11CF-8FD0-00AA00686F13")) HTMLDocument;
class __declspec(uuid("25336921-03f9-11cf-8fd0-00aa00686f13")) HTMLPluginDocument;
class __declspec(uuid("275C23E2-3747-11D0-9FEA-00AA003F8646")) CMultiLanguage;
class __declspec(uuid("3050F241-98B5-11CF-BB82-00AA00BDCE0B")) HTMLImg;
class __declspec(uuid("3050F245-98B5-11CF-BB82-00AA00BDCE0B")) HTMLSelectElement;
class __declspec(uuid("3050F246-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCell;
class __declspec(uuid("3050F248-98B5-11CF-BB82-00AA00BDCE0B")) HTMLAnchorElement;
class __declspec(uuid("3050F249-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDivPosition;
class __declspec(uuid("3050F24A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBody;
class __declspec(uuid("3050F24D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionElement;
class __declspec(uuid("3050F24E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLObjectElement;
class __declspec(uuid("3050F251-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFormElement;
class __declspec(uuid("3050F252-98B5-11CF-BB82-00AA00BDCE0B")) HTMLHRElement;
class __declspec(uuid("3050F25D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLEmbed;
class __declspec(uuid("3050F268-98B5-11CF-BB82-00AA00BDCE0B")) HTMLUnknownElement;
class __declspec(uuid("3050F269-98B5-11CF-BB82-00AA00BDCE0B")) HTMLUListElement;
class __declspec(uuid("3050F26A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTextElement;
class __declspec(uuid("3050F26B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTable;
class __declspec(uuid("3050F26C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCol;
class __declspec(uuid("3050F26D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableRow;
class __declspec(uuid("3050F26E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLPhraseElement;
class __declspec(uuid("3050F26F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLParaElement;
class __declspec(uuid("3050F270-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOListElement;
class __declspec(uuid("3050F271-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMapElement;
class __declspec(uuid("3050F272-98B5-11CF-BB82-00AA00BDCE0B")) HTMLListElement;
class __declspec(uuid("3050F273-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLIElement;
class __declspec(uuid("3050F275-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMetaElement;
class __declspec(uuid("3050F276-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBaseElement;
class __declspec(uuid("3050F277-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLinkElement;
class __declspec(uuid("3050F278-98B5-11CF-BB82-00AA00BDCE0B")) HTMLIsIndexElement;
class __declspec(uuid("3050F279-98B5-11CF-BB82-00AA00BDCE0B")) HTMLNextIdElement;
class __declspec(uuid("3050F27A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLHeaderElement;
class __declspec(uuid("3050F27B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFontElement;
class __declspec(uuid("3050F27C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDTElement;
class __declspec(uuid("3050F27D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDListElement;
class __declspec(uuid("3050F27E-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDivElement;
class __declspec(uuid("3050F27F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDDElement;
class __declspec(uuid("3050F280-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBRElement;
class __declspec(uuid("3050F281-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBlockElement;
class __declspec(uuid("3050F282-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBaseFontElement;
class __declspec(uuid("3050F283-98B5-11CF-BB82-00AA00BDCE0B")) HTMLAreaElement;
class __declspec(uuid("3050F284-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTitleElement;
class __declspec(uuid("3050F285-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyle;
class __declspec(uuid("3050F28A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLDialog;
class __declspec(uuid("3050F28C-98B5-11CF-BB82-00AA00BDCE0B")) HTMLScriptElement;
class __declspec(uuid("3050F2AB-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputTextElement;
class __declspec(uuid("3050F2AC-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTextAreaElement;
class __declspec(uuid("3050F2AE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputFileElement;
class __declspec(uuid("3050F2B4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputButtonElement;
class __declspec(uuid("3050F2B9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLMarqueeElement;
class __declspec(uuid("3050F2BE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionButtonElement;
class __declspec(uuid("3050F2C4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLInputImage;
class __declspec(uuid("3050F2C6-98B5-11CF-BB82-00AA00BDCE0B")) HTMLButtonElement;
class __declspec(uuid("3050F2E4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheet;
class __declspec(uuid("3050F2E9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableSection;
class __declspec(uuid("3050F2EC-98B5-11CF-BB82-00AA00BDCE0B")) HTMLTableCaption;
class __declspec(uuid("3050F312-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameBase;
class __declspec(uuid("3050F314-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameElement;
class __declspec(uuid("3050F316-98B5-11CF-BB82-00AA00BDCE0B")) HTMLIFrame;
class __declspec(uuid("3050F317-98B5-11CF-BB82-00AA00BDCE0B")) HTMLCommentElement;
class __declspec(uuid("3050F31A-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFrameSetSite;
class __declspec(uuid("3050F32B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLabelElement;
class __declspec(uuid("3050F35D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLScreen;
class __declspec(uuid("3050F370-98B5-11CF-BB82-00AA00BDCE0B")) HTMLBGsound;
class __declspec(uuid("3050F37D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleElement;
class __declspec(uuid("3050F37F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetsCollection;
class __declspec(uuid("3050F38B-98B5-11CF-BB82-00AA00BDCE0B")) HTMLNoShowElement;
class __declspec(uuid("3050F38D-98B5-11CF-BB82-00AA00BDCE0B")) HTMLOptionElementFactory;
class __declspec(uuid("3050F38F-98B5-11CF-BB82-00AA00BDCE0B")) HTMLImageElementFactory;
class __declspec(uuid("3050F391-98B5-11CF-BB82-00AA00BDCE0B")) HTMLWindowProxy;
class __declspec(uuid("3050F3CD-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetRulesCollection;
class __declspec(uuid("3050F3CE-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleSheetRule;
class __declspec(uuid("3050F3D0-98B5-11CF-BB82-00AA00BDCE0B")) HTMLRuleStyle;
class __declspec(uuid("3050F3D4-98B5-11CF-BB82-00AA00BDCE0B")) HTMLStyleFontFace;
class __declspec(uuid("3050F3E6-98B5-11CF-BB82-00AA00BDCE0B")) HTMLSpanFlow;
class __declspec(uuid("3050F3E8-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFieldSetElement;
class __declspec(uuid("3050F3E9-98B5-11CF-BB82-00AA00BDCE0B")) HTMLLegendElement;
class __declspec(uuid("3050F3EF-98B5-11CF-BB82-00AA00BDCE0B")) HTMLFiltersCollection;
class __declspec(uuid("3050F3F5-98B4-11CF-BB82-00AA00BDCE0B")) HTMLSpanElement;
class __declspec(uuid("3050F3FE-98B5-11CF-BB82-00AA00BDCE0B")) CMimeTypes;
class __declspec(uuid("3050F3FF-98B5-11CF-BB82-00AA00BDCE0B")) CPlugins;
class __declspec(uuid("3050F402-98B5-11CF-BB82-00AA00BDCE0B")) COpsProfile;
class __declspec(uuid("3050f3d9-98b5-11cf-bb82-00aa00bdce0b")) MHTMLDocument;
class __declspec(uuid("32b533bb-edae-11d0-bd5a-00aa00b92af1")) ClassInstallFilter;
class __declspec(uuid("3c374a40-bae4-11cf-bf7d-00aa006946ee")) CUrlHistory;
class __declspec(uuid("3dd53d40-7b8b-11d0-b013-00aa0059ce02")) CdlProtocol;
class __declspec(uuid("54c37cd0-d944-11d0-a9f4-006097942311")) StdEncodingFilterFac;
class __declspec(uuid("56fdf344-fd6d-11d0-958a-006097c9a090")) TaskbarList;
class __declspec(uuid("62112AA1-EBE4-11CF-A5FB-0020AFE7292D")) ShellFolderView;
class __declspec(uuid("63b51f81-c868-11d0-999c-00c04fd655e1")) CFSIconOverlayManager;
class __declspec(uuid("64AB4BB7-111E-11D1-8F79-00C04FC2FBE1")) ShellUIHelper;
class __declspec(uuid("75048700-ef1f-11d0-9888-006097deacf9")) ActiveDesktop;
class __declspec(uuid("79eac9d0-baf9-11ce-8c82-00aa004ba90b")) StdHlink;
class __declspec(uuid("79eac9d1-baf9-11ce-8c82-00aa004ba90b")) StdHlinkBrowseContext;
class __declspec(uuid("79eac9e0-baf9-11ce-8c82-00aa004ba90b")) StdURLMoniker;
class __declspec(uuid("79eac9e1-baf9-11ce-8c82-00aa004ba90b")) StdURLProtocol;
class __declspec(uuid("79eac9e2-baf9-11ce-8c82-00aa004ba90b")) HttpProtocol;
class __declspec(uuid("79eac9e3-baf9-11ce-8c82-00aa004ba90b")) FtpProtocol;
class __declspec(uuid("79eac9e4-baf9-11ce-8c82-00aa004ba90b")) GopherProtocol;
class __declspec(uuid("79eac9e5-baf9-11ce-8c82-00aa004ba90b")) HttpSProtocol;
class __declspec(uuid("79eac9e6-baf9-11ce-8c82-00aa004ba90b")) MkProtocol;
class __declspec(uuid("79eac9e7-baf9-11ce-8c82-00aa004ba90b")) FileProtocol;
class __declspec(uuid("79eac9f2-baf9-11ce-8c82-00aa004ba90b")) UrlMkBindCtx;
class __declspec(uuid("7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4")) InternetSecurityManager;
class __declspec(uuid("7b8a2d95-0ac9-11d1-896c-00c04fb6bfc4")) InternetZoneManager;
class __declspec(uuid("7d559c10-9fe9-11d0-93f7-00aa0059ce02")) CDLAgent;
class __declspec(uuid("7d688a77-c613-11d0-999b-00c04fd655e1")) OverlayIdentifier_SlowFile;
class __declspec(uuid("7ebdaae0-8120-11cf-899f-00aa00688b10")) StockFontPage;
class __declspec(uuid("7ebdaae1-8120-11cf-899f-00aa00688b10")) StockColorPage;
class __declspec(uuid("7ebdaae2-8120-11cf-899f-00aa00688b10")) StockPicturePage;
class __declspec(uuid("8856F961-340A-11D0-A96B-00C04FD705A2")) WebBrowser;
class __declspec(uuid("8f6b0360-b80d-11d0-a9b3-006097942311")) DeCompMimeFilter;
class __declspec(uuid("9BA05971-F6A8-11CF-A442-00A0C90A8F39")) ShellFolderViewOC;
class __declspec(uuid("9BA05972-F6A8-11CF-A442-00A0C90A8F39")) ShellWindows;
class __declspec(uuid("ABBE31D0-6DAE-11D0-BECA-00C04FD940BE")) SubscriptionMgr;
class __declspec(uuid("B3CDAE90-D170-11D0-802B-00C04FD75D13")) ChannelMgr;
class __declspec(uuid("C04D65CF-B70D-11D0-B188-00AA0038C969")) CMLangString;
class __declspec(uuid("D48A6EC6-6A4A-11CF-94A7-444553540000")) HTMLWindow2;
class __declspec(uuid("D48A6EC9-6A4A-11CF-94A7-444553540000")) OldHTMLDocument;
class __declspec(uuid("D66D6F99-CDAA-11D0-B822-00C04FC9B31F")) CMLangConvertCharset;
class __declspec(uuid("EAB22AC3-30C1-11CF-A7EB-0000C05BAE0B")) WebBrowser_V1;
class __declspec(uuid("FECEAAA3-8405-11CF-8BA1-00AA00476DA6")) HTMLHistory;
class __declspec(uuid("FECEAAA6-8405-11CF-8BA1-00AA00476DA6")) HTMLNavigator;
class __declspec(uuid("b15b8dc0-c7e1-11d0-8680-00aa00bdcb71")) SoftDistExt;
class __declspec(uuid("cfbfae00-17a6-11d0-99cb-00c04fd64497")) CURLSearchHook;
class __declspec(uuid("e3a8bde6-abce-11d0-bc4b-00c04fd929db")) ChannelAgent;
class __declspec(uuid("fb8f0821-0164-101b-84ed-08002b2ec713")) PersistPropset;
class __declspec(uuid("fb8f0822-0164-101b-84ed-08002b2ec713")) ConvertVBX;
class __declspec(uuid("fbf23b40-e3f0-101b-8488-00aa003e56f8")) InternetShortcut;

// Interface Smart Pointers:

_COM_SMARTPTR_TYPEDEF(FolderItem, __uuidof(FolderItem));
_COM_SMARTPTR_TYPEDEF(FolderItemVerb, __uuidof(FolderItemVerb));
_COM_SMARTPTR_TYPEDEF(FolderItemVerbs, __uuidof(FolderItemVerbs));
_COM_SMARTPTR_TYPEDEF(FolderItems, __uuidof(FolderItems));
_COM_SMARTPTR_TYPEDEF(IAccessible, __uuidof(IAccessible));
_COM_SMARTPTR_TYPEDEF(IActiveDesktop, __uuidof(IActiveDesktop));
_COM_SMARTPTR_TYPEDEF(IActiveScript, __uuidof(IActiveScript));
_COM_SMARTPTR_TYPEDEF(IActiveScriptError, __uuidof(IActiveScriptError));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParse, __uuidof(IActiveScriptParse));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedure, __uuidof(IActiveScriptParseProcedure));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedure2, __uuidof(IActiveScriptParseProcedure2));
_COM_SMARTPTR_TYPEDEF(IActiveScriptParseProcedureOld, __uuidof(IActiveScriptParseProcedureOld));
_COM_SMARTPTR_TYPEDEF(IActiveScriptSite, __uuidof(IActiveScriptSite));
_COM_SMARTPTR_TYPEDEF(IActiveScriptSiteInterruptPoll, __uuidof(IActiveScriptSiteInterruptPoll));
_COM_SMARTPTR_TYPEDEF(IActiveScriptSiteWindow, __uuidof(IActiveScriptSiteWindow));
_COM_SMARTPTR_TYPEDEF(IActiveScriptStats, __uuidof(IActiveScriptStats));
_COM_SMARTPTR_TYPEDEF(IAdviseSink, __uuidof(IAdviseSink));
_COM_SMARTPTR_TYPEDEF(IAdviseSink2, __uuidof(IAdviseSink2));
_COM_SMARTPTR_TYPEDEF(IAdviseSinkEx, __uuidof(IAdviseSinkEx));
_COM_SMARTPTR_TYPEDEF(IAsyncManager, __uuidof(IAsyncManager));
_COM_SMARTPTR_TYPEDEF(IAuthenticate, __uuidof(IAuthenticate));
_COM_SMARTPTR_TYPEDEF(IBindCtx, __uuidof(IBindCtx));
_COM_SMARTPTR_TYPEDEF(IBindEventHandler, __uuidof(IBindEventHandler));
_COM_SMARTPTR_TYPEDEF(IBindHost, __uuidof(IBindHost));
_COM_SMARTPTR_TYPEDEF(IBindProtocol, __uuidof(IBindProtocol));
_COM_SMARTPTR_TYPEDEF(IBindStatusCallback, __uuidof(IBindStatusCallback));
_COM_SMARTPTR_TYPEDEF(IBinding, __uuidof(IBinding));
_COM_SMARTPTR_TYPEDEF(ICSSFilter, __uuidof(ICSSFilter));
_COM_SMARTPTR_TYPEDEF(ICSSFilterSite, __uuidof(ICSSFilterSite));
_COM_SMARTPTR_TYPEDEF(ICancelMethodCalls, __uuidof(ICancelMethodCalls));
_COM_SMARTPTR_TYPEDEF(ICatInformation, __uuidof(ICatInformation));
_COM_SMARTPTR_TYPEDEF(ICatRegister, __uuidof(ICatRegister));
_COM_SMARTPTR_TYPEDEF(IChannelHook, __uuidof(IChannelHook));
_COM_SMARTPTR_TYPEDEF(IChannelMgr, __uuidof(IChannelMgr));
_COM_SMARTPTR_TYPEDEF(IClassActivator, __uuidof(IClassActivator));
_COM_SMARTPTR_TYPEDEF(IClassFactory, __uuidof(IClassFactory));
_COM_SMARTPTR_TYPEDEF(IClassFactory2, __uuidof(IClassFactory2));
_COM_SMARTPTR_TYPEDEF(IClientSecurity, __uuidof(IClientSecurity));
_COM_SMARTPTR_TYPEDEF(ICodeInstall, __uuidof(ICodeInstall));
_COM_SMARTPTR_TYPEDEF(ICommDlgBrowser, __uuidof(ICommDlgBrowser));
_COM_SMARTPTR_TYPEDEF(IConnectionPoint, __uuidof(IConnectionPoint));
_COM_SMARTPTR_TYPEDEF(IConnectionPointContainer, __uuidof(IConnectionPointContainer));
_COM_SMARTPTR_TYPEDEF(IContextMenu, __uuidof(IContextMenu));
_COM_SMARTPTR_TYPEDEF(IContextMenu2, __uuidof(IContextMenu2));
_COM_SMARTPTR_TYPEDEF(IContextMenu3, __uuidof(IContextMenu3));
_COM_SMARTPTR_TYPEDEF(IContinue, __uuidof(IContinue));
_COM_SMARTPTR_TYPEDEF(IContinueCallback, __uuidof(IContinueCallback));
_COM_SMARTPTR_TYPEDEF(ICreateErrorInfo, __uuidof(ICreateErrorInfo));
_COM_SMARTPTR_TYPEDEF(ICreateTypeInfo, __uuidof(ICreateTypeInfo));
_COM_SMARTPTR_TYPEDEF(ICreateTypeInfo2, __uuidof(ICreateTypeInfo2));
_COM_SMARTPTR_TYPEDEF(ICreateTypeLib, __uuidof(ICreateTypeLib));
_COM_SMARTPTR_TYPEDEF(ICreateTypeLib2, __uuidof(ICreateTypeLib2));
_COM_SMARTPTR_TYPEDEF(ICustomDoc, __uuidof(ICustomDoc));
_COM_SMARTPTR_TYPEDEF(IDataAdviseHolder, __uuidof(IDataAdviseHolder));
_COM_SMARTPTR_TYPEDEF(IDataFilter, __uuidof(IDataFilter));
_COM_SMARTPTR_TYPEDEF(IDataObject, __uuidof(IDataObject));
_COM_SMARTPTR_TYPEDEF(IDeskBand, __uuidof(IDeskBand));
_COM_SMARTPTR_TYPEDEF(IDirectWriterLock, __uuidof(IDirectWriterLock));
_COM_SMARTPTR_TYPEDEF(IDispError, __uuidof(IDispError));
_COM_SMARTPTR_TYPEDEF(IDispatch, __uuidof(IDispatch));
_COM_SMARTPTR_TYPEDEF(IDispatchEx, __uuidof(IDispatchEx));
_COM_SMARTPTR_TYPEDEF(IDocHostShowUI, __uuidof(IDocHostShowUI));
_COM_SMARTPTR_TYPEDEF(IDocHostUIHandler, __uuidof(IDocHostUIHandler));
_COM_SMARTPTR_TYPEDEF(IDockingWindow, __uuidof(IDockingWindow));
_COM_SMARTPTR_TYPEDEF(IDockingWindowFrame, __uuidof(IDockingWindowFrame));
_COM_SMARTPTR_TYPEDEF(IDockingWindowSite, __uuidof(IDockingWindowSite));
_COM_SMARTPTR_TYPEDEF(IDropSource, __uuidof(IDropSource));
_COM_SMARTPTR_TYPEDEF(IDropTarget, __uuidof(IDropTarget));
_COM_SMARTPTR_TYPEDEF(IEncodingFilterFactory, __uuidof(IEncodingFilterFactory));
_COM_SMARTPTR_TYPEDEF(IEnumCATEGORYINFO, __uuidof(IEnumCATEGORYINFO));
_COM_SMARTPTR_TYPEDEF(IEnumChannels, __uuidof(IEnumChannels));
_COM_SMARTPTR_TYPEDEF(IEnumCodePage, __uuidof(IEnumCodePage));
_COM_SMARTPTR_TYPEDEF(IEnumConnectionPoints, __uuidof(IEnumConnectionPoints));
_COM_SMARTPTR_TYPEDEF(IEnumConnections, __uuidof(IEnumConnections));
_COM_SMARTPTR_TYPEDEF(IEnumFORMATETC, __uuidof(IEnumFORMATETC));
_COM_SMARTPTR_TYPEDEF(IEnumGUID, __uuidof(IEnumGUID));
_COM_SMARTPTR_TYPEDEF(IEnumHLITEM, __uuidof(IEnumHLITEM));
_COM_SMARTPTR_TYPEDEF(IEnumIDList, __uuidof(IEnumIDList));
_COM_SMARTPTR_TYPEDEF(IEnumMoniker, __uuidof(IEnumMoniker));
_COM_SMARTPTR_TYPEDEF(IEnumOLEVERB, __uuidof(IEnumOLEVERB));
_COM_SMARTPTR_TYPEDEF(IEnumOleDocumentViews, __uuidof(IEnumOleDocumentViews));
_COM_SMARTPTR_TYPEDEF(IEnumOleUndoUnits, __uuidof(IEnumOleUndoUnits));
_COM_SMARTPTR_TYPEDEF(IEnumRfc1766, __uuidof(IEnumRfc1766));
_COM_SMARTPTR_TYPEDEF(IEnumSTATDATA, __uuidof(IEnumSTATDATA));
_COM_SMARTPTR_TYPEDEF(IEnumSTATPROPSETSTG, __uuidof(IEnumSTATPROPSETSTG));
_COM_SMARTPTR_TYPEDEF(IEnumSTATPROPSTG, __uuidof(IEnumSTATPROPSTG));
_COM_SMARTPTR_TYPEDEF(IEnumSTATSTG, __uuidof(IEnumSTATSTG));
_COM_SMARTPTR_TYPEDEF(IEnumSTATURL, __uuidof(IEnumSTATURL));
_COM_SMARTPTR_TYPEDEF(IEnumString, __uuidof(IEnumString));
_COM_SMARTPTR_TYPEDEF(IEnumUnknown, __uuidof(IEnumUnknown));
_COM_SMARTPTR_TYPEDEF(IEnumVARIANT, __uuidof(IEnumVARIANT));
_COM_SMARTPTR_TYPEDEF(IErrorInfo, __uuidof(IErrorInfo));
_COM_SMARTPTR_TYPEDEF(IErrorLog, __uuidof(IErrorLog));
_COM_SMARTPTR_TYPEDEF(IExtensionServices, __uuidof(IExtensionServices));
_COM_SMARTPTR_TYPEDEF(IExternalConnection, __uuidof(IExternalConnection));
_COM_SMARTPTR_TYPEDEF(IExtractIconA, __uuidof(IExtractIconA));
_COM_SMARTPTR_TYPEDEF(IExtractIconW, __uuidof(IExtractIconW));
_COM_SMARTPTR_TYPEDEF(IFileViewerA, __uuidof(IFileViewerA));
_COM_SMARTPTR_TYPEDEF(IFileViewerSite, __uuidof(IFileViewerSite));
_COM_SMARTPTR_TYPEDEF(IFileViewerW, __uuidof(IFileViewerW));
_COM_SMARTPTR_TYPEDEF(IFillLockBytes, __uuidof(IFillLockBytes));
_COM_SMARTPTR_TYPEDEF(IFilter, __uuidof(IFilter));
_COM_SMARTPTR_TYPEDEF(IFolderViewOC, __uuidof(IFolderViewOC));
_COM_SMARTPTR_TYPEDEF(IFont, __uuidof(IFont));
_COM_SMARTPTR_TYPEDEF(IFontDisp, __uuidof(IFontDisp));
_COM_SMARTPTR_TYPEDEF(IFontEventsDisp, __uuidof(IFontEventsDisp));
_COM_SMARTPTR_TYPEDEF(IGlobalInterfaceTable, __uuidof(IGlobalInterfaceTable));
_COM_SMARTPTR_TYPEDEF(IHTMLAnchorElement, __uuidof(IHTMLAnchorElement));
_COM_SMARTPTR_TYPEDEF(IHTMLAreaElement, __uuidof(IHTMLAreaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLAreasCollection, __uuidof(IHTMLAreasCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLBGsound, __uuidof(IHTMLBGsound));
_COM_SMARTPTR_TYPEDEF(IHTMLBRElement, __uuidof(IHTMLBRElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBaseElement, __uuidof(IHTMLBaseElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBaseFontElement, __uuidof(IHTMLBaseFontElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBlockElement, __uuidof(IHTMLBlockElement));
_COM_SMARTPTR_TYPEDEF(IHTMLBodyElement, __uuidof(IHTMLBodyElement));
_COM_SMARTPTR_TYPEDEF(IHTMLButtonElement, __uuidof(IHTMLButtonElement));
_COM_SMARTPTR_TYPEDEF(IHTMLCommentElement, __uuidof(IHTMLCommentElement));
_COM_SMARTPTR_TYPEDEF(IHTMLControlElement, __uuidof(IHTMLControlElement));
_COM_SMARTPTR_TYPEDEF(IHTMLControlRange, __uuidof(IHTMLControlRange));
_COM_SMARTPTR_TYPEDEF(IHTMLDDElement, __uuidof(IHTMLDDElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDListElement, __uuidof(IHTMLDListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDTElement, __uuidof(IHTMLDTElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDatabinding, __uuidof(IHTMLDatabinding));
_COM_SMARTPTR_TYPEDEF(IHTMLDialog, __uuidof(IHTMLDialog));
_COM_SMARTPTR_TYPEDEF(IHTMLDivElement, __uuidof(IHTMLDivElement));
_COM_SMARTPTR_TYPEDEF(IHTMLDivPosition, __uuidof(IHTMLDivPosition));
_COM_SMARTPTR_TYPEDEF(IHTMLDocument, __uuidof(IHTMLDocument));
_COM_SMARTPTR_TYPEDEF(IHTMLDocument2, __uuidof(IHTMLDocument2));
_COM_SMARTPTR_TYPEDEF(IHTMLElement, __uuidof(IHTMLElement));
_COM_SMARTPTR_TYPEDEF(IHTMLElementCollection, __uuidof(IHTMLElementCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLEmbedElement, __uuidof(IHTMLEmbedElement));
_COM_SMARTPTR_TYPEDEF(IHTMLEventObj, __uuidof(IHTMLEventObj));
_COM_SMARTPTR_TYPEDEF(IHTMLFieldSetElement, __uuidof(IHTMLFieldSetElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFiltersCollection, __uuidof(IHTMLFiltersCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLFontElement, __uuidof(IHTMLFontElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFontNamesCollection, __uuidof(IHTMLFontNamesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLFontSizesCollection, __uuidof(IHTMLFontSizesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLFormElement, __uuidof(IHTMLFormElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFrameBase, __uuidof(IHTMLFrameBase));
_COM_SMARTPTR_TYPEDEF(IHTMLFrameElement, __uuidof(IHTMLFrameElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFrameSetElement, __uuidof(IHTMLFrameSetElement));
_COM_SMARTPTR_TYPEDEF(IHTMLFramesCollection2, __uuidof(IHTMLFramesCollection2));
_COM_SMARTPTR_TYPEDEF(IHTMLHRElement, __uuidof(IHTMLHRElement));
_COM_SMARTPTR_TYPEDEF(IHTMLHeaderElement, __uuidof(IHTMLHeaderElement));
_COM_SMARTPTR_TYPEDEF(IHTMLIFrameElement, __uuidof(IHTMLIFrameElement));
_COM_SMARTPTR_TYPEDEF(IHTMLImageElementFactory, __uuidof(IHTMLImageElementFactory));
_COM_SMARTPTR_TYPEDEF(IHTMLImgElement, __uuidof(IHTMLImgElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputButtonElement, __uuidof(IHTMLInputButtonElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputFileElement, __uuidof(IHTMLInputFileElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputHiddenElement, __uuidof(IHTMLInputHiddenElement));
_COM_SMARTPTR_TYPEDEF(IHTMLInputImage, __uuidof(IHTMLInputImage));
_COM_SMARTPTR_TYPEDEF(IHTMLInputTextElement, __uuidof(IHTMLInputTextElement));
_COM_SMARTPTR_TYPEDEF(IHTMLIsIndexElement, __uuidof(IHTMLIsIndexElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLIElement, __uuidof(IHTMLLIElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLabelElement, __uuidof(IHTMLLabelElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLegendElement, __uuidof(IHTMLLegendElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLinkElement, __uuidof(IHTMLLinkElement));
_COM_SMARTPTR_TYPEDEF(IHTMLListElement, __uuidof(IHTMLListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLLocation, __uuidof(IHTMLLocation));
_COM_SMARTPTR_TYPEDEF(IHTMLMapElement, __uuidof(IHTMLMapElement));
_COM_SMARTPTR_TYPEDEF(IHTMLMarqueeElement, __uuidof(IHTMLMarqueeElement));
_COM_SMARTPTR_TYPEDEF(IHTMLMetaElement, __uuidof(IHTMLMetaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLMimeTypesCollection, __uuidof(IHTMLMimeTypesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLNextIdElement, __uuidof(IHTMLNextIdElement));
_COM_SMARTPTR_TYPEDEF(IHTMLNoShowElement, __uuidof(IHTMLNoShowElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOListElement, __uuidof(IHTMLOListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLObjectElement, __uuidof(IHTMLObjectElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOpsProfile, __uuidof(IHTMLOpsProfile));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionButtonElement, __uuidof(IHTMLOptionButtonElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionElement, __uuidof(IHTMLOptionElement));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionElementFactory, __uuidof(IHTMLOptionElementFactory));
_COM_SMARTPTR_TYPEDEF(IHTMLOptionsHolder, __uuidof(IHTMLOptionsHolder));
_COM_SMARTPTR_TYPEDEF(IHTMLParaElement, __uuidof(IHTMLParaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLPhraseElement, __uuidof(IHTMLPhraseElement));
_COM_SMARTPTR_TYPEDEF(IHTMLPluginsCollection, __uuidof(IHTMLPluginsCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLRuleStyle, __uuidof(IHTMLRuleStyle));
_COM_SMARTPTR_TYPEDEF(IHTMLScreen, __uuidof(IHTMLScreen));
_COM_SMARTPTR_TYPEDEF(IHTMLScriptElement, __uuidof(IHTMLScriptElement));
_COM_SMARTPTR_TYPEDEF(IHTMLSelectElement, __uuidof(IHTMLSelectElement));
_COM_SMARTPTR_TYPEDEF(IHTMLSelectionObject, __uuidof(IHTMLSelectionObject));
_COM_SMARTPTR_TYPEDEF(IHTMLSpanElement, __uuidof(IHTMLSpanElement));
_COM_SMARTPTR_TYPEDEF(IHTMLSpanFlow, __uuidof(IHTMLSpanFlow));
_COM_SMARTPTR_TYPEDEF(IHTMLStyle, __uuidof(IHTMLStyle));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleElement, __uuidof(IHTMLStyleElement));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleFontFace, __uuidof(IHTMLStyleFontFace));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheet, __uuidof(IHTMLStyleSheet));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetRule, __uuidof(IHTMLStyleSheetRule));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetRulesCollection, __uuidof(IHTMLStyleSheetRulesCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLStyleSheetsCollection, __uuidof(IHTMLStyleSheetsCollection));
_COM_SMARTPTR_TYPEDEF(IHTMLTable, __uuidof(IHTMLTable));
_COM_SMARTPTR_TYPEDEF(IHTMLTableCaption, __uuidof(IHTMLTableCaption));
_COM_SMARTPTR_TYPEDEF(IHTMLTableCell, __uuidof(IHTMLTableCell));
_COM_SMARTPTR_TYPEDEF(IHTMLTableCol, __uuidof(IHTMLTableCol));
_COM_SMARTPTR_TYPEDEF(IHTMLTableRow, __uuidof(IHTMLTableRow));
_COM_SMARTPTR_TYPEDEF(IHTMLTableSection, __uuidof(IHTMLTableSection));
_COM_SMARTPTR_TYPEDEF(IHTMLTextAreaElement, __uuidof(IHTMLTextAreaElement));
_COM_SMARTPTR_TYPEDEF(IHTMLTextContainer, __uuidof(IHTMLTextContainer));
_COM_SMARTPTR_TYPEDEF(IHTMLTextElement, __uuidof(IHTMLTextElement));
_COM_SMARTPTR_TYPEDEF(IHTMLTitleElement, __uuidof(IHTMLTitleElement));
_COM_SMARTPTR_TYPEDEF(IHTMLTxtRange, __uuidof(IHTMLTxtRange));
_COM_SMARTPTR_TYPEDEF(IHTMLUListElement, __uuidof(IHTMLUListElement));
_COM_SMARTPTR_TYPEDEF(IHTMLUnknownElement, __uuidof(IHTMLUnknownElement));
_COM_SMARTPTR_TYPEDEF(IHTMLWindow2, __uuidof(IHTMLWindow2));
_COM_SMARTPTR_TYPEDEF(IHlink, __uuidof(IHlink));
_COM_SMARTPTR_TYPEDEF(IHlinkBrowseContext, __uuidof(IHlinkBrowseContext));
_COM_SMARTPTR_TYPEDEF(IHlinkFrame, __uuidof(IHlinkFrame));
_COM_SMARTPTR_TYPEDEF(IHlinkSite, __uuidof(IHlinkSite));
_COM_SMARTPTR_TYPEDEF(IHlinkTarget, __uuidof(IHlinkTarget));
_COM_SMARTPTR_TYPEDEF(IHttpNegotiate, __uuidof(IHttpNegotiate));
_COM_SMARTPTR_TYPEDEF(IHttpSecurity, __uuidof(IHttpSecurity));
_COM_SMARTPTR_TYPEDEF(IImageDecodeEventSink, __uuidof(IImageDecodeEventSink));
_COM_SMARTPTR_TYPEDEF(IImageDecodeFilter, __uuidof(IImageDecodeFilter));
_COM_SMARTPTR_TYPEDEF(IImgCtx, __uuidof(IImgCtx));
_COM_SMARTPTR_TYPEDEF(IInputObject, __uuidof(IInputObject));
_COM_SMARTPTR_TYPEDEF(IInputObjectSite, __uuidof(IInputObjectSite));
_COM_SMARTPTR_TYPEDEF(IInternet, __uuidof(IInternet));
_COM_SMARTPTR_TYPEDEF(IInternetBindInfo, __uuidof(IInternetBindInfo));
_COM_SMARTPTR_TYPEDEF(IInternetHostSecurityManager, __uuidof(IInternetHostSecurityManager));
_COM_SMARTPTR_TYPEDEF(IInternetPriority, __uuidof(IInternetPriority));
_COM_SMARTPTR_TYPEDEF(IInternetProtocol, __uuidof(IInternetProtocol));
_COM_SMARTPTR_TYPEDEF(IInternetProtocolInfo, __uuidof(IInternetProtocolInfo));
_COM_SMARTPTR_TYPEDEF(IInternetProtocolRoot, __uuidof(IInternetProtocolRoot));
_COM_SMARTPTR_TYPEDEF(IInternetProtocolSink, __uuidof(IInternetProtocolSink));
_COM_SMARTPTR_TYPEDEF(IInternetSecurityManager, __uuidof(IInternetSecurityManager));
_COM_SMARTPTR_TYPEDEF(IInternetSecurityMgrSite, __uuidof(IInternetSecurityMgrSite));
_COM_SMARTPTR_TYPEDEF(IInternetSession, __uuidof(IInternetSession));
_COM_SMARTPTR_TYPEDEF(IInternetThreadSwitch, __uuidof(IInternetThreadSwitch));
_COM_SMARTPTR_TYPEDEF(IInternetZoneManager, __uuidof(IInternetZoneManager));
_COM_SMARTPTR_TYPEDEF(ILayoutStorage, __uuidof(ILayoutStorage));
_COM_SMARTPTR_TYPEDEF(ILockBytes, __uuidof(ILockBytes));
_COM_SMARTPTR_TYPEDEF(IMLangCodePages, __uuidof(IMLangCodePages));
_COM_SMARTPTR_TYPEDEF(IMLangConvertCharset, __uuidof(IMLangConvertCharset));
_COM_SMARTPTR_TYPEDEF(IMLangFontLink, __uuidof(IMLangFontLink));
_COM_SMARTPTR_TYPEDEF(IMLangLineBreakConsole, __uuidof(IMLangLineBreakConsole));
_COM_SMARTPTR_TYPEDEF(IMLangString, __uuidof(IMLangString));
_COM_SMARTPTR_TYPEDEF(IMLangStringAStr, __uuidof(IMLangStringAStr));
_COM_SMARTPTR_TYPEDEF(IMLangStringBufA, __uuidof(IMLangStringBufA));
_COM_SMARTPTR_TYPEDEF(IMLangStringBufW, __uuidof(IMLangStringBufW));
_COM_SMARTPTR_TYPEDEF(IMLangStringWStr, __uuidof(IMLangStringWStr));
_COM_SMARTPTR_TYPEDEF(IMalloc, __uuidof(IMalloc));
_COM_SMARTPTR_TYPEDEF(IMallocSpy, __uuidof(IMallocSpy));
_COM_SMARTPTR_TYPEDEF(IMapMIMEToCLSID, __uuidof(IMapMIMEToCLSID));
_COM_SMARTPTR_TYPEDEF(IMarshal, __uuidof(IMarshal));
_COM_SMARTPTR_TYPEDEF(IMessageFilter, __uuidof(IMessageFilter));
_COM_SMARTPTR_TYPEDEF(IMimeInfo, __uuidof(IMimeInfo));
_COM_SMARTPTR_TYPEDEF(IMoniker, __uuidof(IMoniker));
_COM_SMARTPTR_TYPEDEF(IMultiLanguage, __uuidof(IMultiLanguage));
_COM_SMARTPTR_TYPEDEF(IMultiQI, __uuidof(IMultiQI));
_COM_SMARTPTR_TYPEDEF(INewShortcutHookA, __uuidof(INewShortcutHookA));
_COM_SMARTPTR_TYPEDEF(INewShortcutHookW, __uuidof(INewShortcutHookW));
_COM_SMARTPTR_TYPEDEF(IObjectIdentity, __uuidof(IObjectIdentity));
_COM_SMARTPTR_TYPEDEF(IObjectSafety, __uuidof(IObjectSafety));
_COM_SMARTPTR_TYPEDEF(IObjectWithSite, __uuidof(IObjectWithSite));
_COM_SMARTPTR_TYPEDEF(IOleAdviseHolder, __uuidof(IOleAdviseHolder));
_COM_SMARTPTR_TYPEDEF(IOleCache, __uuidof(IOleCache));
_COM_SMARTPTR_TYPEDEF(IOleCache2, __uuidof(IOleCache2));
_COM_SMARTPTR_TYPEDEF(IOleCacheControl, __uuidof(IOleCacheControl));
_COM_SMARTPTR_TYPEDEF(IOleClientSite, __uuidof(IOleClientSite));
_COM_SMARTPTR_TYPEDEF(IOleCommandTarget, __uuidof(IOleCommandTarget));
_COM_SMARTPTR_TYPEDEF(IOleContainer, __uuidof(IOleContainer));
_COM_SMARTPTR_TYPEDEF(IOleControl, __uuidof(IOleControl));
_COM_SMARTPTR_TYPEDEF(IOleControlSite, __uuidof(IOleControlSite));
_COM_SMARTPTR_TYPEDEF(IOleDocument, __uuidof(IOleDocument));
_COM_SMARTPTR_TYPEDEF(IOleDocumentSite, __uuidof(IOleDocumentSite));
_COM_SMARTPTR_TYPEDEF(IOleDocumentView, __uuidof(IOleDocumentView));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceActiveObject, __uuidof(IOleInPlaceActiveObject));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceFrame, __uuidof(IOleInPlaceFrame));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceObject, __uuidof(IOleInPlaceObject));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceObjectWindowless, __uuidof(IOleInPlaceObjectWindowless));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSite, __uuidof(IOleInPlaceSite));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSiteEx, __uuidof(IOleInPlaceSiteEx));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceSiteWindowless, __uuidof(IOleInPlaceSiteWindowless));
_COM_SMARTPTR_TYPEDEF(IOleInPlaceUIWindow, __uuidof(IOleInPlaceUIWindow));
_COM_SMARTPTR_TYPEDEF(IOleItemContainer, __uuidof(IOleItemContainer));
_COM_SMARTPTR_TYPEDEF(IOleLink, __uuidof(IOleLink));
_COM_SMARTPTR_TYPEDEF(IOleObject, __uuidof(IOleObject));
_COM_SMARTPTR_TYPEDEF(IOleParentUndoUnit, __uuidof(IOleParentUndoUnit));
_COM_SMARTPTR_TYPEDEF(IOleUndoManager, __uuidof(IOleUndoManager));
_COM_SMARTPTR_TYPEDEF(IOleUndoUnit, __uuidof(IOleUndoUnit));
_COM_SMARTPTR_TYPEDEF(IOleWindow, __uuidof(IOleWindow));
_COM_SMARTPTR_TYPEDEF(IOmHistory, __uuidof(IOmHistory));
_COM_SMARTPTR_TYPEDEF(IOmNavigator, __uuidof(IOmNavigator));
_COM_SMARTPTR_TYPEDEF(IPSFactoryBuffer, __uuidof(IPSFactoryBuffer));
_COM_SMARTPTR_TYPEDEF(IParseDisplayName, __uuidof(IParseDisplayName));
_COM_SMARTPTR_TYPEDEF(IPerPropertyBrowsing, __uuidof(IPerPropertyBrowsing));
_COM_SMARTPTR_TYPEDEF(IPersist, __uuidof(IPersist));
_COM_SMARTPTR_TYPEDEF(IPersistFile, __uuidof(IPersistFile));
_COM_SMARTPTR_TYPEDEF(IPersistFolder, __uuidof(IPersistFolder));
_COM_SMARTPTR_TYPEDEF(IPersistFolder2, __uuidof(IPersistFolder2));
_COM_SMARTPTR_TYPEDEF(IPersistHistory, __uuidof(IPersistHistory));
_COM_SMARTPTR_TYPEDEF(IPersistMemory, __uuidof(IPersistMemory));
_COM_SMARTPTR_TYPEDEF(IPersistMoniker, __uuidof(IPersistMoniker));
_COM_SMARTPTR_TYPEDEF(IPersistPropertyBag, __uuidof(IPersistPropertyBag));
_COM_SMARTPTR_TYPEDEF(IPersistPropertyBag2, __uuidof(IPersistPropertyBag2));
_COM_SMARTPTR_TYPEDEF(IPersistStorage, __uuidof(IPersistStorage));
_COM_SMARTPTR_TYPEDEF(IPersistStream, __uuidof(IPersistStream));
_COM_SMARTPTR_TYPEDEF(IPersistStreamInit, __uuidof(IPersistStreamInit));
_COM_SMARTPTR_TYPEDEF(IPicture, __uuidof(IPicture));
_COM_SMARTPTR_TYPEDEF(IPictureDisp, __uuidof(IPictureDisp));
_COM_SMARTPTR_TYPEDEF(IPointerInactive, __uuidof(IPointerInactive));
_COM_SMARTPTR_TYPEDEF(IPrint, __uuidof(IPrint));
_COM_SMARTPTR_TYPEDEF(IProgressNotify, __uuidof(IProgressNotify));
_COM_SMARTPTR_TYPEDEF(IPropertyBag, __uuidof(IPropertyBag));
_COM_SMARTPTR_TYPEDEF(IPropertyBag2, __uuidof(IPropertyBag2));
_COM_SMARTPTR_TYPEDEF(IPropertyNotifySink, __uuidof(IPropertyNotifySink));
_COM_SMARTPTR_TYPEDEF(IPropertyPage, __uuidof(IPropertyPage));
_COM_SMARTPTR_TYPEDEF(IPropertyPage2, __uuidof(IPropertyPage2));
_COM_SMARTPTR_TYPEDEF(IPropertyPageSite, __uuidof(IPropertyPageSite));
_COM_SMARTPTR_TYPEDEF(IPropertySetStorage, __uuidof(IPropertySetStorage));
_COM_SMARTPTR_TYPEDEF(IPropertyStorage, __uuidof(IPropertyStorage));
_COM_SMARTPTR_TYPEDEF(IProvideClassInfo, __uuidof(IProvideClassInfo));
_COM_SMARTPTR_TYPEDEF(IProvideClassInfo2, __uuidof(IProvideClassInfo2));
_COM_SMARTPTR_TYPEDEF(IProvideMultipleClassInfo, __uuidof(IProvideMultipleClassInfo));
_COM_SMARTPTR_TYPEDEF(IQueryInfo, __uuidof(IQueryInfo));
_COM_SMARTPTR_TYPEDEF(IQuickActivate, __uuidof(IQuickActivate));
_COM_SMARTPTR_TYPEDEF(IROTData, __uuidof(IROTData));
_COM_SMARTPTR_TYPEDEF(IRecordInfo, __uuidof(IRecordInfo));
_COM_SMARTPTR_TYPEDEF(IRichEditOle, __uuidof(IRichEditOle));
_COM_SMARTPTR_TYPEDEF(IRichEditOleCallback, __uuidof(IRichEditOleCallback));
_COM_SMARTPTR_TYPEDEF(IRootStorage, __uuidof(IRootStorage));
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer, __uuidof(IRpcChannelBuffer));
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer2, __uuidof(IRpcChannelBuffer2));
_COM_SMARTPTR_TYPEDEF(IRpcChannelBuffer3, __uuidof(IRpcChannelBuffer3));
_COM_SMARTPTR_TYPEDEF(IRpcProxyBuffer, __uuidof(IRpcProxyBuffer));
_COM_SMARTPTR_TYPEDEF(IRpcStubBuffer, __uuidof(IRpcStubBuffer));
_COM_SMARTPTR_TYPEDEF(IRunnableObject, __uuidof(IRunnableObject));
_COM_SMARTPTR_TYPEDEF(IRunningObjectTable, __uuidof(IRunningObjectTable));
_COM_SMARTPTR_TYPEDEF(ISequentialStream, __uuidof(ISequentialStream));
_COM_SMARTPTR_TYPEDEF(IServerSecurity, __uuidof(IServerSecurity));
_COM_SMARTPTR_TYPEDEF(IServiceProvider, __uuidof(IServiceProvider));
_COM_SMARTPTR_TYPEDEF(IShellBrowser, __uuidof(IShellBrowser));
_COM_SMARTPTR_TYPEDEF(IShellDispatch, __uuidof(IShellDispatch));
_COM_SMARTPTR_TYPEDEF(IShellExecuteHookA, __uuidof(IShellExecuteHookA));
_COM_SMARTPTR_TYPEDEF(IShellExecuteHookW, __uuidof(IShellExecuteHookW));
_COM_SMARTPTR_TYPEDEF(IShellExtInit, __uuidof(IShellExtInit));
_COM_SMARTPTR_TYPEDEF(IShellFolder, __uuidof(IShellFolder));
_COM_SMARTPTR_TYPEDEF(IShellFolderViewDual, __uuidof(IShellFolderViewDual));
_COM_SMARTPTR_TYPEDEF(IShellIcon, __uuidof(IShellIcon));
_COM_SMARTPTR_TYPEDEF(IShellIconOverlay, __uuidof(IShellIconOverlay));
_COM_SMARTPTR_TYPEDEF(IShellIconOverlayIdentifier, __uuidof(IShellIconOverlayIdentifier));
_COM_SMARTPTR_TYPEDEF(IShellLinkA, __uuidof(IShellLinkA));
_COM_SMARTPTR_TYPEDEF(IShellLinkDual, __uuidof(IShellLinkDual));
_COM_SMARTPTR_TYPEDEF(IShellLinkW, __uuidof(IShellLinkW));
_COM_SMARTPTR_TYPEDEF(IShellPropSheetExt, __uuidof(IShellPropSheetExt));
_COM_SMARTPTR_TYPEDEF(IShellUIHelper, __uuidof(IShellUIHelper));
_COM_SMARTPTR_TYPEDEF(IShellView, __uuidof(IShellView));
_COM_SMARTPTR_TYPEDEF(IShellView2, __uuidof(IShellView2));
_COM_SMARTPTR_TYPEDEF(IShellWindows, __uuidof(IShellWindows));
_COM_SMARTPTR_TYPEDEF(ISimpleFrameSite, __uuidof(ISimpleFrameSite));
_COM_SMARTPTR_TYPEDEF(ISoftDistExt, __uuidof(ISoftDistExt));
_COM_SMARTPTR_TYPEDEF(ISpecifyPropertyPages, __uuidof(ISpecifyPropertyPages));
_COM_SMARTPTR_TYPEDEF(IStdMarshalInfo, __uuidof(IStdMarshalInfo));
_COM_SMARTPTR_TYPEDEF(IStorage, __uuidof(IStorage));
_COM_SMARTPTR_TYPEDEF(IStream, __uuidof(IStream));
_COM_SMARTPTR_TYPEDEF(ISubscriptionMgr, __uuidof(ISubscriptionMgr));
_COM_SMARTPTR_TYPEDEF(ISupportErrorInfo, __uuidof(ISupportErrorInfo));
_COM_SMARTPTR_TYPEDEF(ISurrogate, __uuidof(ISurrogate));
_COM_SMARTPTR_TYPEDEF(ISynchronize, __uuidof(ISynchronize));
_COM_SMARTPTR_TYPEDEF(ISynchronizeEvent, __uuidof(ISynchronizeEvent));
_COM_SMARTPTR_TYPEDEF(ISynchronizeMutex, __uuidof(ISynchronizeMutex));
_COM_SMARTPTR_TYPEDEF(ITimer, __uuidof(ITimer));
_COM_SMARTPTR_TYPEDEF(ITimerService, __uuidof(ITimerService));
_COM_SMARTPTR_TYPEDEF(ITimerSink, __uuidof(ITimerSink));
_COM_SMARTPTR_TYPEDEF(ITypeChangeEvents, __uuidof(ITypeChangeEvents));
_COM_SMARTPTR_TYPEDEF(ITypeComp, __uuidof(ITypeComp));
_COM_SMARTPTR_TYPEDEF(ITypeFactory, __uuidof(ITypeFactory));
_COM_SMARTPTR_TYPEDEF(ITypeInfo, __uuidof(ITypeInfo));
_COM_SMARTPTR_TYPEDEF(ITypeInfo2, __uuidof(ITypeInfo2));
_COM_SMARTPTR_TYPEDEF(ITypeLib, __uuidof(ITypeLib));
_COM_SMARTPTR_TYPEDEF(ITypeLib2, __uuidof(ITypeLib2));
_COM_SMARTPTR_TYPEDEF(ITypeMarshal, __uuidof(ITypeMarshal));
_COM_SMARTPTR_TYPEDEF(IURLSearchHook, __uuidof(IURLSearchHook));
_COM_SMARTPTR_TYPEDEF(IUniformResourceLocatorA, __uuidof(IUniformResourceLocatorA));
_COM_SMARTPTR_TYPEDEF(IUniformResourceLocatorW, __uuidof(IUniformResourceLocatorW));
_COM_SMARTPTR_TYPEDEF(IUnknown, __uuidof(IUnknown));
_COM_SMARTPTR_TYPEDEF(IUrlHistoryNotify, __uuidof(IUrlHistoryNotify));
_COM_SMARTPTR_TYPEDEF(IUrlHistoryStg, __uuidof(IUrlHistoryStg));
_COM_SMARTPTR_TYPEDEF(IUrlHistoryStg2, __uuidof(IUrlHistoryStg2));
_COM_SMARTPTR_TYPEDEF(IUrlMon, __uuidof(IUrlMon));
_COM_SMARTPTR_TYPEDEF(IVariantChangeType, __uuidof(IVariantChangeType));
_COM_SMARTPTR_TYPEDEF(IViewFilterSite, __uuidof(IViewFilterSite));
_COM_SMARTPTR_TYPEDEF(IViewObject, __uuidof(IViewObject));
_COM_SMARTPTR_TYPEDEF(IViewObject2, __uuidof(IViewObject2));
_COM_SMARTPTR_TYPEDEF(IViewObjectEx, __uuidof(IViewObjectEx));
_COM_SMARTPTR_TYPEDEF(IViewTransition, __uuidof(IViewTransition));
_COM_SMARTPTR_TYPEDEF(IViewTransitionSite, __uuidof(IViewTransitionSite));
_COM_SMARTPTR_TYPEDEF(IWaitMultiple, __uuidof(IWaitMultiple));
_COM_SMARTPTR_TYPEDEF(IWebBrowser, __uuidof(IWebBrowser));
_COM_SMARTPTR_TYPEDEF(IWebBrowser2, __uuidof(IWebBrowser2));
_COM_SMARTPTR_TYPEDEF(IWebBrowserApp, __uuidof(IWebBrowserApp));
_COM_SMARTPTR_TYPEDEF(IWinInetHttpInfo, __uuidof(IWinInetHttpInfo));
_COM_SMARTPTR_TYPEDEF(IWinInetInfo, __uuidof(IWinInetInfo));
_COM_SMARTPTR_TYPEDEF(IWindowForBindingUI, __uuidof(IWindowForBindingUI));
_COM_SMARTPTR_TYPEDEF(IXMLDocument, __uuidof(IXMLDocument));
_COM_SMARTPTR_TYPEDEF(IXMLElement, __uuidof(IXMLElement));
_COM_SMARTPTR_TYPEDEF(IXMLElementCollection, __uuidof(IXMLElementCollection));
_COM_SMARTPTR_TYPEDEF(IXMLError, __uuidof(IXMLError));
_COM_SMARTPTR_TYPEDEF(OLEDBSimpleProvider, __uuidof(OLEDBSimpleProvider));
_COM_SMARTPTR_TYPEDEF(OLEDBSimpleProviderListener, __uuidof(OLEDBSimpleProviderListener));

#endif  /* _COM_NO_STANDARD_GUIDS_ */

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif  /* _INC_COMDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\vccomsupport\makefile.inc ===
.SUFFIXES:.h

# Copy .h file from here to sdk\inc
.h{$(SDK_INC_PATH)}.h:
    attrib -r $@
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wu.inc ===
#
# Windows Update project wide include
#
# Owner: PeterWi

!ifdef WUBLDTYPE
!if "$(WUBLDTYPE)" != "unicode"
BINPLACE_FLAGS = $(BINPLACE_FLAGS) -b $(WUBLDTYPE)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\vccomsupport\comutil.h ===
/***
* comutil.h - Native C++ compiler COM support - BSTR, VARIANT wrappers header
*
*	Copyright (C) 1996-1999 Microsoft Corporation
*	All rights reserved.
*
****/

#if !defined(_INC_COMUTIL)
#define _INC_COMUTIL

#if _MSC_VER > 1000
#pragma once
#endif

#include <ole2.h>

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4290)
#pragma warning(disable:4310)

class _com_error;

void __stdcall _com_issue_error(HRESULT);

//////////////////////////////////////////////////////////////////////////////
//
// Forward class declarations
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t;
class _variant_t;

//////////////////////////////////////////////////////////////////////////////
//
// Error checking routines
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
	inline void CheckError(HRESULT hr) throw(_com_error)
	{
		if (FAILED(hr)) {
			_com_issue_error(hr);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Routines for handling conversions between BSTR and char*
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
	// Convert char * to BSTR
	//
	BSTR __stdcall ConvertStringToBSTR(const char* pSrc) throw(_com_error);

	// Convert BSTR to char *
	//
	char* __stdcall ConvertBSTRToString(BSTR pSrc) throw(_com_error);
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for BSTR
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t {
public:
	// Constructors
	//
	_bstr_t() throw();
	_bstr_t(const _bstr_t& s) throw();
	_bstr_t(const char* s) throw(_com_error);
	_bstr_t(const wchar_t* s) throw(_com_error);
	_bstr_t(const _variant_t& var) throw(_com_error);
	_bstr_t(BSTR bstr, bool fCopy) throw(_com_error);

	// Destructor
	//
	~_bstr_t() throw();

	// Assignment operators
	//
	_bstr_t& operator=(const _bstr_t& s) throw();
	_bstr_t& operator=(const char* s) throw(_com_error);
	_bstr_t& operator=(const wchar_t* s) throw(_com_error);
	_bstr_t& operator=(const _variant_t& var) throw(_com_error);

	// Operators
	//
	_bstr_t& operator+=(const _bstr_t& s) throw(_com_error);
	_bstr_t operator+(const _bstr_t& s) const throw(_com_error);

	// Friend operators
	//
	friend _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error);
	friend _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error);

	// Extractors
	//
	operator const wchar_t*() const throw();
	operator wchar_t*() const throw();
	operator const char*() const throw(_com_error);
	operator char*() const throw(_com_error);

	// Comparison operators
	//
	bool operator!() const throw();
	bool operator==(const _bstr_t& str) const throw();
	bool operator!=(const _bstr_t& str) const throw();
	bool operator<(const _bstr_t& str) const throw();
	bool operator>(const _bstr_t& str) const throw();
	bool operator<=(const _bstr_t& str) const throw();
	bool operator>=(const _bstr_t& str) const throw();

	// Low-level helper functions
	//
	BSTR copy() const throw(_com_error);
	unsigned int length() const throw();

	// Binary string assign
	//
	void Assign(BSTR s) throw(_com_error);

private:
	// Referenced counted wrapper
	//
	class Data_t {
	public:
		// Constructors
		//
		Data_t(const char* s) throw(_com_error);
		Data_t(const wchar_t* s) throw(_com_error);
		Data_t(BSTR bstr, bool fCopy) throw(_com_error);
		Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error);

		// Reference counting routines
		//
		unsigned long AddRef() throw();
		unsigned long Release() throw();

		// Extractors
		//
		operator const wchar_t*() const throw();
		operator const char*() const throw(_com_error);

		// Low-level helper functions
		//
		const wchar_t* GetWString() const throw();
		const char* GetString() const throw(_com_error);

		BSTR Copy() const throw(_com_error);
		void Assign(BSTR s) throw(_com_error);
		unsigned int Length() const throw();
		int Compare(const Data_t& str) const throw();

	private:
		wchar_t*		m_wstr;
		mutable char*	m_str;
		unsigned long	m_RefCount;

		// Never allow default construction
		//
		Data_t() throw();

		// Never allow copy
		//
		Data_t(const Data_t& s) throw();

		// Prevent deletes from outside. Release() must be used.
		//
		~Data_t() throw();

		void _Free() throw();
	};

private:
	// Reference counted representation
	//
	Data_t* m_Data;

private:
	// Low-level utilities
	//
	void _AddRef() throw();
	void _Free() throw();
	int _Compare(const _bstr_t& str) const throw();
};

//////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _bstr_t::_bstr_t() throw()
	: m_Data(NULL)
{
}

// Copy constructor
//
inline _bstr_t::_bstr_t(const _bstr_t& s) throw()
	: m_Data(s.m_Data)
{
	_AddRef();
}

// Construct a _bstr_t from a const char*
//
inline _bstr_t::_bstr_t(const char* s) throw(_com_error)
	: m_Data(new Data_t(s))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a _bstr_t from a const whar_t*
//
inline _bstr_t::_bstr_t(const wchar_t* s) throw(_com_error)
	: m_Data(new Data_t(s))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a _bstr_t from a BSTR.  If fCopy is FALSE, give control of
// data to the _bstr_t without making a new copy.
//
inline _bstr_t::_bstr_t(BSTR bstr, bool fCopy) throw(_com_error)
	: m_Data(new Data_t(bstr, fCopy))
{
	if (m_Data == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Destructor
//
inline _bstr_t::~_bstr_t() throw()
{
	_Free();
}

//////////////////////////////////////////////////////////////////////////////
//
// Assignment operators
//
//////////////////////////////////////////////////////////////////////////////

// Default assign operator
//
inline _bstr_t& _bstr_t::operator=(const _bstr_t& s) throw()
{
	const_cast<_bstr_t*>(&s)->_AddRef();
	_Free();
	m_Data = s.m_Data;

	return *this;
}

// Assign a const char* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const char* s) throw(_com_error)
{
	_Free();
	m_Data = new Data_t(s);

	return *this;
}

// Assign a const wchar_t* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const wchar_t* s) throw(_com_error)
{
	_Free();
	m_Data = new Data_t(s);

	return *this;
}

//////////////////////////////////////////////////////////////////////////////
//
// Operators
//
//////////////////////////////////////////////////////////////////////////////

// Concatenate a _bstr_t onto this _bstr_t
//
inline _bstr_t& _bstr_t::operator+=(const _bstr_t& s) throw(_com_error)
{
	Data_t* newData = new Data_t(*this, s);

	_Free();
	m_Data = newData;

	return *this;
}

// Return the concatenation of this _bstr_t with another _bstr_t
//
inline _bstr_t _bstr_t::operator+(const _bstr_t& s) const throw(_com_error)
{
	_bstr_t b = *this;
	b += s;

	return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Friend Operators
//
//////////////////////////////////////////////////////////////////////////////

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error)
{
	_bstr_t b = s1;
	b += s2;

	return b;
}

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error)
{
	_bstr_t b = s1;
	b += s2;

	return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::operator const wchar_t*() const throw()
{
	return (m_Data != NULL) ? m_Data->GetWString() : NULL;
}

// Extract a wchar_t*
//
inline _bstr_t::operator wchar_t*() const throw()
{
	return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);
}

// Extract a const char_t*
//
inline _bstr_t::operator const char*() const throw(_com_error)
{
	return (m_Data != NULL) ? m_Data->GetString() : NULL;
}

// Extract a char_t*
//
inline _bstr_t::operator char*() const throw(_com_error)
{
	return const_cast<char*>((m_Data != NULL) ? m_Data->GetString() : NULL);
}

//////////////////////////////////////////////////////////////////////////////
//
// Comparison operators
//
//////////////////////////////////////////////////////////////////////////////

inline bool _bstr_t::operator!() const throw()
{
	return (m_Data != NULL) ? !m_Data->GetWString() : true;
}

inline bool _bstr_t::operator==(const _bstr_t& str) const throw()
{
	return _Compare(str) == 0;
}

inline bool _bstr_t::operator!=(const _bstr_t& str) const throw()
{
	return _Compare(str) != 0;
}

inline bool _bstr_t::operator<(const _bstr_t& str) const throw()
{
	return _Compare(str) < 0;
}

inline bool _bstr_t::operator>(const _bstr_t& str) const throw()
{
	return _Compare(str) > 0;
}

inline bool _bstr_t::operator<=(const _bstr_t& str) const throw()
{
	return _Compare(str) <= 0;
}

inline bool _bstr_t::operator>=(const _bstr_t& str) const throw()
{
	return _Compare(str) >= 0;
}

//////////////////////////////////////////////////////////////////////////////
//
// Low-level help functions
//
//////////////////////////////////////////////////////////////////////////////

// Extract a copy of the wrapped BSTR
//
inline BSTR _bstr_t::copy() const throw(_com_error)
{
	return (m_Data != NULL) ? m_Data->Copy() : NULL;
}

// Return the length of the wrapped BSTR
//
inline unsigned int _bstr_t::length() const throw()
{
	return (m_Data != NULL) ? m_Data->Length() : 0;
}

// Binary string assign
//
inline void _bstr_t::Assign(BSTR s) throw(_com_error)
{
	if (m_Data != NULL) {
		m_Data->Assign(s);
	}
	else {
		m_Data = new Data_t(s, TRUE);
		if (m_Data == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}
}

// AddRef the BSTR
//
inline void _bstr_t::_AddRef() throw()
{
	if (m_Data != NULL) {
		m_Data->AddRef();
	}
}

// Free the BSTR
//
inline void _bstr_t::_Free() throw()
{
	if (m_Data != NULL) {
		m_Data->Release();
		m_Data = NULL;
	}
}

// Compare two _bstr_t objects
//
inline int _bstr_t::_Compare(const _bstr_t& str) const throw()
{
	if (m_Data == str.m_Data) {
		return 0;
	}

	if (m_Data == NULL) {
		return -1;
	}

	if (str.m_Data == NULL) {
		return 1;
	}

	return m_Data->Compare(*str.m_Data);
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Construct a Data_t from a const char*
//
inline _bstr_t::Data_t::Data_t(const char* s) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	m_wstr = _com_util::ConvertStringToBSTR(s);

	if (m_wstr == NULL && s != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a Data_t from a const wchar_t*
//
inline _bstr_t::Data_t::Data_t(const wchar_t* s) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	m_wstr = ::SysAllocString(s);

	if (m_wstr == NULL && s != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a Data_t from a BSTR.  If fCopy is FALSE, give control of
// data to the Data_t without doing a SysAllocStringByteLen.
//
inline _bstr_t::Data_t::Data_t(BSTR bstr, bool fCopy) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	if (fCopy && bstr != NULL) {
		m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
										 ::SysStringByteLen(bstr));

		if (m_wstr == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}
	else {
		m_wstr = bstr;
	}
}

// Construct a Data_t from the concatenation of two _bstr_t objects
//
inline _bstr_t::Data_t::Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error)
	: m_str(NULL), m_RefCount(1)
{
	const unsigned int l1 = s1.length();
	const unsigned int l2 = s2.length();

	m_wstr = ::SysAllocStringByteLen(NULL, (l1 + l2) * sizeof(wchar_t));

	if (m_wstr == NULL) {
		if (l1 + l2 == 0) {
			return;
		}
		_com_issue_error(E_OUTOFMEMORY);
	}

	const wchar_t* wstr1 = static_cast<const wchar_t*>(s1);

	if (wstr1 != NULL) {
		memcpy(m_wstr, wstr1, (l1 + 1) * sizeof(wchar_t));
	}

	const wchar_t* wstr2 = static_cast<const wchar_t*>(s2);

	if (wstr2 != NULL) {
		memcpy(m_wstr + l1, wstr2, (l2 + 1) * sizeof(wchar_t));
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - reference counting routines
//
//////////////////////////////////////////////////////////////////////////////

inline unsigned long _bstr_t::Data_t::AddRef() throw()
{
	InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));
	return m_RefCount;
}

inline unsigned long _bstr_t::Data_t::Release() throw()
{
	if (!InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount))) {
		delete this;
		return 0;
	}

	return m_RefCount;
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::Data_t::operator const wchar_t*() const throw()
{
	return m_wstr;
}

// Extract a const char_t*
//
inline _bstr_t::Data_t::operator const char*() const throw(_com_error)
{
	return GetString();
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - helper functions
//
//////////////////////////////////////////////////////////////////////////////

inline const wchar_t* _bstr_t::Data_t::GetWString() const throw()
{
	return m_wstr;
}

inline const char* _bstr_t::Data_t::GetString() const throw(_com_error)
{
	if (m_str == NULL) {
		m_str = _com_util::ConvertBSTRToString(m_wstr);

		if (m_str == NULL && m_wstr != NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return m_str;
}

// Return a copy of the wrapped BSTR
//
inline BSTR _bstr_t::Data_t::Copy() const throw(_com_error)
{
	if (m_wstr != NULL) {
		BSTR bstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(m_wstr),
											::SysStringByteLen(m_wstr));

		if (bstr == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}

		return bstr;
	}

	return NULL;
}

inline void _bstr_t::Data_t::Assign(BSTR s) throw(_com_error)
{
	_Free();
	if (s != NULL) {
		wchar_t* tmp = ::SysAllocStringByteLen(reinterpret_cast<char*>(s),
											::SysStringByteLen(s));
		if (tmp == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		} else {
            m_wstr = tmp;
        }
	}
}

// Return the length of the wrapper BSTR
//
inline unsigned int _bstr_t::Data_t::Length() const throw()
{
	return m_wstr ? ::SysStringLen(m_wstr) : 0;
}

// Compare two wrapped BSTRs
//
inline int _bstr_t::Data_t::Compare(const _bstr_t::Data_t& str) const throw()
{
	if (m_wstr == NULL) {
		return str.m_wstr ? -1 : 0;
	}

	if (str.m_wstr == NULL) {
		return 1;
	}

	const unsigned int l1 = ::SysStringLen(m_wstr);
	const unsigned int l2 = ::SysStringLen(str.m_wstr);

	unsigned int len = l1;
	if (len > l2) {
		len = l2;
	}

	BSTR bstr1 = m_wstr;
	BSTR bstr2 = str.m_wstr;

	while (len-- > 0) {
		if (*bstr1++ != *bstr2++) {
			return bstr1[-1] - bstr2[-1];
		}
	}

	return (l1 < l2) ? -1 : (l1 == l2) ? 0 : 1;
}

// Destruct this object
//
inline _bstr_t::Data_t::~Data_t() throw()
{
	_Free();
}

// Free up this object
//
inline void _bstr_t::Data_t::_Free() throw()
{
	if (m_wstr != NULL) {
		::SysFreeString(m_wstr);
	}

	if (m_str != NULL) {
		delete [] m_str;
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for VARIANT
//
//////////////////////////////////////////////////////////////////////////////

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 * * [C] - supported by class _variant_t
 *
 *
 *  VT_EMPTY            [V]   [P]        nothing
 *  VT_NULL             [V]   [P]        SQL style Null
 *  VT_I2               [V][T][P][S][C]  2 byte signed int
 *  VT_I4               [V][T][P][S][C]  4 byte signed int
 *  VT_R4               [V][T][P][S][C]  4 byte real
 *  VT_R8               [V][T][P][S][C]  8 byte real
 *  VT_CY               [V][T][P][S][C]  currency
 *  VT_DATE             [V][T][P][S][C]  date
 *  VT_BSTR             [V][T][P][S][C]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S][C]  IDispatch *
 *  VT_ERROR            [V][T]   [S][C]  SCODE
 *  VT_BOOL             [V][T][P][S][C]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]     VARIANT *
 *  VT_UNKNOWN          [V][T]   [S][C]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S][C]  16 byte fixed point
 *  VT_I1                  [T]           signed char
 *  VT_UI1              [V][T][P][S][C]  unsigned char
 *  VT_UI2                 [T][P]        unsigned short
 *  VT_UI4                 [T][P]        unsigned short
 *  VT_I8                  [T][P]        signed 64-bit int
 *  VT_UI8                 [T][P]        unsigned 64-bit int
 *  VT_INT                 [T]           signed machine int
 *  VT_UINT                [T]           unsigned machine int
 *  VT_VOID                [T]           C style void
 *  VT_HRESULT             [T]           Standard return type
 *  VT_PTR                 [T]           pointer type
 *  VT_SAFEARRAY           [T]          (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]           C style array
 *  VT_USERDEFINED         [T]           user defined type
 *  VT_LPSTR               [T][P]        null terminated string
 *  VT_LPWSTR              [T][P]        wide null terminated string
 *  VT_FILETIME               [P]        FILETIME
 *  VT_BLOB                   [P]        Length prefixed bytes
 *  VT_STREAM                 [P]        Name of the stream follows
 *  VT_STORAGE                [P]        Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]        Stream contains an object
 *  VT_STORED_OBJECT          [P]        Storage contains an object
 *  VT_BLOB_OBJECT            [P]        Blob contains an object
 *  VT_CF                     [P]        Clipboard format
 *  VT_CLSID                  [P]        A Class ID
 *  VT_VECTOR                 [P]        simple counted array
 *  VT_ARRAY            [V]              SAFEARRAY*
 *  VT_BYREF            [V]              void* for local use
 */

class _variant_t : public ::tagVARIANT {
public:
	// Constructors
	//
	_variant_t() throw();

	_variant_t(const VARIANT& varSrc) throw(_com_error);
	_variant_t(const VARIANT* pSrc) throw(_com_error);
	_variant_t(const _variant_t& varSrc) throw(_com_error);

	_variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error);			// Attach VARIANT if !fCopy

	_variant_t(short sSrc, VARTYPE vtSrc = VT_I2) throw(_com_error);	// Creates a VT_I2, or a VT_BOOL
	_variant_t(long lSrc, VARTYPE vtSrc = VT_I4) throw(_com_error);		// Creates a VT_I4, a VT_ERROR, or a VT_BOOL
	_variant_t(float fltSrc) throw();									// Creates a VT_R4
	_variant_t(double dblSrc, VARTYPE vtSrc = VT_R8) throw(_com_error);	// Creates a VT_R8, or a VT_DATE
	_variant_t(const CY& cySrc) throw();								// Creates a VT_CY
	_variant_t(const _bstr_t& bstrSrc) throw(_com_error);				// Creates a VT_BSTR
	_variant_t(const wchar_t *pSrc) throw(_com_error);					// Creates a VT_BSTR
	_variant_t(const char* pSrc) throw(_com_error);						// Creates a VT_BSTR
	_variant_t(IDispatch* pSrc, bool fAddRef = true) throw();			// Creates a VT_DISPATCH
	_variant_t(bool bSrc) throw();										// Creates a VT_BOOL
	_variant_t(IUnknown* pSrc, bool fAddRef = true) throw();			// Creates a VT_UNKNOWN
	_variant_t(const DECIMAL& decSrc) throw();							// Creates a VT_DECIMAL
	_variant_t(BYTE bSrc) throw();										// Creates a VT_UI1
	_variant_t(LONGLONG llSrc) throw();									// Creates a VT_I8
	_variant_t(ULONGLONG ullSrc) throw();								// Creates a VT_UI8

	// Destructor
	//
	~_variant_t() throw(_com_error);

	// Extractors
	//
	operator short() const throw(_com_error);			// Extracts a short from a VT_I2
	operator long() const throw(_com_error);			// Extracts a long from a VT_I4
	operator float() const throw(_com_error);			// Extracts a float from a VT_R4
	operator double() const throw(_com_error);			// Extracts a double from a VT_R8
	operator CY() const throw(_com_error);				// Extracts a CY from a VT_CY
	operator _bstr_t() const throw(_com_error);			// Extracts a _bstr_t from a VT_BSTR
	operator IDispatch*() const throw(_com_error);		// Extracts a IDispatch* from a VT_DISPATCH
	operator bool() const throw(_com_error);			// Extracts a bool from a VT_BOOL
	operator IUnknown*() const throw(_com_error);		// Extracts a IUnknown* from a VT_UNKNOWN
	operator DECIMAL() const throw(_com_error);			// Extracts a DECIMAL from a VT_DECIMAL
	operator BYTE() const throw(_com_error);			// Extracts a BTYE (unsigned char) from a VT_UI1
	operator LONGLONG() const throw(_com_error);		// Extracts a LONGLONG from a VT_I8
	operator ULONGLONG() const throw(_com_error);		// Extracts a ULONGLONG from a VT_UI8
	
	// Assignment operations
	//
	_variant_t& operator=(const VARIANT& varSrc) throw(_com_error);
	_variant_t& operator=(const VARIANT* pSrc) throw(_com_error);
	_variant_t& operator=(const _variant_t& varSrc) throw(_com_error);

	_variant_t& operator=(short sSrc) throw(_com_error);				// Assign a VT_I2, or a VT_BOOL
	_variant_t& operator=(long lSrc) throw(_com_error);					// Assign a VT_I4, a VT_ERROR or a VT_BOOL
	_variant_t& operator=(float fltSrc) throw(_com_error);				// Assign a VT_R4
	_variant_t& operator=(double dblSrc) throw(_com_error);				// Assign a VT_R8, or a VT_DATE
	_variant_t& operator=(const CY& cySrc) throw(_com_error);			// Assign a VT_CY
	_variant_t& operator=(const _bstr_t& bstrSrc) throw(_com_error);	// Assign a VT_BSTR
	_variant_t& operator=(const wchar_t* pSrc) throw(_com_error);		// Assign a VT_BSTR
	_variant_t& operator=(const char* pSrc) throw(_com_error);			// Assign a VT_BSTR
	_variant_t& operator=(IDispatch* pSrc) throw(_com_error);			// Assign a VT_DISPATCH
 	_variant_t& operator=(bool bSrc) throw(_com_error);					// Assign a VT_BOOL
	_variant_t& operator=(IUnknown* pSrc) throw(_com_error);			// Assign a VT_UNKNOWN
	_variant_t& operator=(const DECIMAL& decSrc) throw(_com_error);		// Assign a VT_DECIMAL
	_variant_t& operator=(BYTE bSrc) throw(_com_error);					// Assign a VT_UI1
	_variant_t& operator=(LONGLONG llSrc) throw(_com_error);			// Assign a VT_I8
	_variant_t& operator=(ULONGLONG ullSrc) throw(_com_error);			// Assign a VT_UI8
	
	// Comparison operations
	//
	bool operator==(const VARIANT& varSrc) const throw(_com_error);
	bool operator==(const VARIANT* pSrc) const throw(_com_error);

	bool operator!=(const VARIANT& varSrc) const throw(_com_error);
	bool operator!=(const VARIANT* pSrc) const throw(_com_error);

	// Low-level operations
	//
	void Clear() throw(_com_error);

	void Attach(VARIANT& varSrc) throw(_com_error);
	VARIANT Detach() throw(_com_error);

	void ChangeType(VARTYPE vartype, const _variant_t* pSrc = NULL) throw(_com_error);

	void SetString(const char* pSrc) throw(_com_error); // used to set ANSI string
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _variant_t::_variant_t() throw()
{
	::VariantInit(this);
}

// Construct a _variant_t from a const VARIANT&
//
inline _variant_t::_variant_t(const VARIANT& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));
}

// Construct a _variant_t from a const VARIANT*
//
inline _variant_t::_variant_t(const VARIANT* pSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
}

// Construct a _variant_t from a const _variant_t&
//
inline _variant_t::_variant_t(const _variant_t& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));
}

// Construct a _variant_t from a VARIANT&.  If fCopy is FALSE, give control of
// data to the _variant_t without doing a VariantCopy.
//
inline _variant_t::_variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error)
{
	if (fCopy) {
		::VariantInit(this);
		_com_util::CheckError(::VariantCopy(this, &varSrc));
	} else {
		memcpy(this, &varSrc, sizeof(varSrc));
		V_VT(&varSrc) = VT_EMPTY;
	}
}

// Construct either a VT_I2 VARIANT or a VT_BOOL VARIANT from
// a short (the default is VT_I2)
//
inline _variant_t::_variant_t(short sSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I2) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}
}

// Construct either a VT_I4 VARIANT, a VT_BOOL VARIANT, or a
// VT_ERROR VARIANT from a long (the default is VT_I4)
//
inline _variant_t::_variant_t(long lSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I4) && (vtSrc != VT_ERROR) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_ERROR) {
		V_VT(this) = VT_ERROR;
		V_ERROR(this) = lSrc;
	}
	else if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}
}

// Construct a VT_R4 VARIANT from a float
//
inline _variant_t::_variant_t(float fltSrc) throw()
{
	V_VT(this) = VT_R4;
	V_R4(this) = fltSrc;
}

// Construct either a VT_R8 VARIANT, or a VT_DATE VARIANT from
// a double (the default is VT_R8)
//
inline _variant_t::_variant_t(double dblSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_R8) && (vtSrc != VT_DATE)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_DATE) {
		V_VT(this) = VT_DATE;
		V_DATE(this) = dblSrc;
	}
	else {
		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}
}

// Construct a VT_CY from a CY
//
inline _variant_t::_variant_t(const CY& cySrc) throw()
{
	V_VT(this) = VT_CY;
	V_CY(this) = cySrc;
}

// Construct a VT_BSTR VARIANT from a const _bstr_t&
//
inline _variant_t::_variant_t(const _bstr_t& bstrSrc) throw(_com_error)
{
    BSTR bstr = static_cast<wchar_t*>(bstrSrc);
    BSTR tmp = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                 ::SysStringByteLen(bstr));

	if (tmp == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	} else {
        V_VT(this) = VT_BSTR;
    	V_BSTR(this) = tmp;
    }
}

// Construct a VT_BSTR VARIANT from a const wchar_t*
//
inline _variant_t::_variant_t(const wchar_t* pSrc) throw(_com_error)
{
	wchar_t*tmp = ::SysAllocString(pSrc);

	if (tmp == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	} else {
        V_VT(this) = VT_BSTR;
        V_BSTR(this) = tmp;
    }
}

// Construct a VT_BSTR VARIANT from a const char*
//
inline _variant_t::_variant_t(const char* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_DISPATCH VARIANT from an IDispatch*
//
inline _variant_t::_variant_t(IDispatch* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_DISPATCH(this)->AddRef();
	}
}

// Construct a VT_BOOL VARIANT from a bool
//
inline _variant_t::_variant_t(bool bSrc) throw()
{
	V_VT(this) = VT_BOOL;
	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);
}

// Construct a VT_UNKNOWN VARIANT from an IUnknown*
//
inline _variant_t::_variant_t(IUnknown* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_UNKNOWN(this)->AddRef();
	}
}

// Construct a VT_DECIMAL VARIANT from a DECIMAL
//
inline _variant_t::_variant_t(const DECIMAL& decSrc) throw()
{
	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	//
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;
}

// Construct a VT_UI1 VARIANT from a BYTE (unsigned char)
//
inline _variant_t::_variant_t(BYTE bSrc) throw()
{
	V_VT(this) = VT_UI1;
	V_UI1(this) = bSrc;
}

// Construct a VT_I8 VARIANT from a LONGLONG
//
inline _variant_t::_variant_t(LONGLONG llSrc) throw()
{
	V_VT(this) = VT_I8;
	V_I8(this) = llSrc;
}

// Construct a VT_UI8 VARIANT from a ULONGLONG
//
inline _variant_t::_variant_t(ULONGLONG ullSrc) throw()
{
	V_VT(this) = VT_UI8;
	V_UI8(this) = ullSrc;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Extracts a VT_I2 into a short
//
inline _variant_t::operator short() const throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		return V_I2(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I2, this);

	return V_I2(&varDest);
}

// Extracts a VT_I4 into a long
//
inline _variant_t::operator long() const throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		return V_I4(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I4, this);

	return V_I4(&varDest);
}

// Extracts a VT_R4 into a float
//
inline _variant_t::operator float() const throw(_com_error)
{
	if (V_VT(this) == VT_R4) {
		return V_R4(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_R4, this);

	return V_R4(&varDest);
}

// Extracts a VT_R8 into a double
//
inline _variant_t::operator double() const throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		return V_R8(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_R8, this);

	return V_R8(&varDest);
}

// Extracts a VT_CY into a CY
//
inline _variant_t::operator CY() const throw(_com_error)
{
	if (V_VT(this) == VT_CY) {
		return V_CY(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_CY, this);

	return V_CY(&varDest);
}

// Extracts a VT_BSTR into a _bstr_t
//
inline _variant_t::operator _bstr_t() const throw(_com_error)
{
	if (V_VT(this) == VT_BSTR) {
		return V_BSTR(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, this);

	return V_BSTR(&varDest);
}

// Extracts a VT_DISPATCH into an IDispatch*
//
inline _variant_t::operator IDispatch*() const throw(_com_error)
{
	if (V_VT(this) == VT_DISPATCH) {
		V_DISPATCH(this)->AddRef();
		return V_DISPATCH(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_DISPATCH, this);

	V_DISPATCH(&varDest)->AddRef();
	return V_DISPATCH(&varDest);
}

// Extract a VT_BOOL into a bool
//
inline _variant_t::operator bool() const throw(_com_error)
{
	if (V_VT(this) == VT_BOOL) {
		return V_BOOL(this) ? true : false;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BOOL, this);

	return V_BOOL(&varDest) ? true : false;
}

// Extracts a VT_UNKNOWN into an IUnknown*
//
inline _variant_t::operator IUnknown*() const throw(_com_error)
{
	if (V_VT(this) == VT_UNKNOWN) {
		V_UNKNOWN(this)->AddRef();
		return V_UNKNOWN(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UNKNOWN, this);

	V_UNKNOWN(&varDest)->AddRef();
	return V_UNKNOWN(&varDest);
}

// Extracts a VT_DECIMAL into a DECIMAL
//
inline _variant_t::operator DECIMAL() const throw(_com_error)
{
	if (V_VT(this) == VT_DECIMAL) {
		return V_DECIMAL(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_DECIMAL, this);

	return V_DECIMAL(&varDest);
}

// Extracts a VT_UI1 into a BYTE (unsigned char)
//
inline _variant_t::operator BYTE() const throw(_com_error)
{
	if (V_VT(this) == VT_UI1) {
		return V_UI1(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UI1, this);

	return V_UI1(&varDest);
}

// Extracts a VT_I8 into a LONGLONG
//
inline _variant_t::operator LONGLONG() const throw(_com_error)
{
	if(V_VT(this) == VT_I8) {
		return V_I8(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_I8, this);

	return (V_I8(&varDest));
}

// Extracts a VT_UI8 into a ULONGLONG
//
inline _variant_t::operator ULONGLONG() const throw(_com_error)
{
	if(V_VT(this) == VT_UI8) {
		return V_UI8(this);
	}

	_variant_t varDest;

	varDest.ChangeType(VT_UI8, this);

	return (V_UI8(&varDest));
}


//////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Assign a const VARIANT& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT& varSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));

	return *this;
}

// Assign a const VARIANT* (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT* pSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));

	return *this;
}

// Assign a const _variant_t& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const _variant_t& varSrc) throw(_com_error)
{
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));

	return *this;
}

// Assign a short creating either VT_I2 VARIANT or a
// VT_BOOL VARIANT (VT_I2 is the default)
//
inline _variant_t& _variant_t::operator=(short sSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		V_I2(this) = sSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I2
		//
		Clear();

		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}

	return *this;
}

// Assign a long creating either VT_I4 VARIANT, a VT_ERROR VARIANT
// or a VT_BOOL VARIANT (VT_I4 is the default)
//
inline _variant_t& _variant_t::operator=(long lSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		V_I4(this) = lSrc;
	}
	else if (V_VT(this) == VT_ERROR) {
		V_ERROR(this) = lSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I4
		//
		Clear();

		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}

	return *this;
}

// Assign a float creating a VT_R4 VARIANT
//
inline _variant_t& _variant_t::operator=(float fltSrc) throw(_com_error)
{
	if (V_VT(this) != VT_R4) {
		// Clear the VARIANT and create a VT_R4
		//
		Clear();

		V_VT(this) = VT_R4;
	}

	V_R4(this) = fltSrc;

	return *this;
}

// Assign a double creating either a VT_R8 VARIANT, or a VT_DATE
// VARIANT (VT_R8 is the default)
//
inline _variant_t& _variant_t::operator=(double dblSrc) throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		V_R8(this) = dblSrc;
	}
	else if(V_VT(this) == VT_DATE) {
		V_DATE(this) = dblSrc;
	}
	else {
		// Clear the VARIANT and create a VT_R8
		//
		Clear();

		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}

	return *this;
}

// Assign a CY creating a VT_CY VARIANT
//
inline _variant_t& _variant_t::operator=(const CY& cySrc) throw(_com_error)
{
	if (V_VT(this) != VT_CY) {
		// Clear the VARIANT and create a VT_CY
		//
		Clear();

		V_VT(this) = VT_CY;
	}

	V_CY(this) = cySrc;

	return *this;
}

// Assign a const _bstr_t& creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const _bstr_t& bstrSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	if (!bstrSrc) {
        V_VT(this) = VT_BSTR;
		V_BSTR(this) = NULL;
	}
	else {
		BSTR bstr = static_cast<wchar_t*>(bstrSrc);
		wchar_t*tmp = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
											   ::SysStringByteLen(bstr));

		if (tmp == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		} else {
            V_VT(this) = VT_BSTR;
    		V_BSTR(this) = tmp;
        }
	}

	return *this;
}

// Assign a const wchar_t* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const wchar_t* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	if (pSrc == NULL) {
        V_VT(this) = VT_BSTR;
		V_BSTR(this) = NULL;
	}
	else {
		wchar_t*tmp = ::SysAllocString(pSrc);

		if (tmp == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		} else {
            V_VT(this) = VT_BSTR;
            V_BSTR(this) = tmp;
        }
	}

	return *this;
}

// Assign a const char* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const char* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}

	return *this;
}

// Assign an IDispatch* creating a VT_DISPATCH VARIANT
//
inline _variant_t& _variant_t::operator=(IDispatch* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_DISPATCH(this)->AddRef();

	return *this;
}

// Assign a bool creating a VT_BOOL VARIANT
//
inline _variant_t& _variant_t::operator=(bool bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_BOOL) {
		// Clear the VARIANT and create a VT_BOOL
		//
		Clear();

		V_VT(this) = VT_BOOL;
	}

	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);

	return *this;
}

// Assign an IUnknown* creating a VT_UNKNOWN VARIANT
//
inline _variant_t& _variant_t::operator=(IUnknown* pSrc) throw(_com_error)
{
	// Clear VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_UNKNOWN(this)->AddRef();

	return *this;
}

// Assign a DECIMAL creating a VT_DECIMAL VARIANT
//
inline _variant_t& _variant_t::operator=(const DECIMAL& decSrc) throw(_com_error)
{
	if (V_VT(this) != VT_DECIMAL) {
		// Clear the VARIANT
		//
		Clear();
	}

	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;

	return *this;
}

// Assign a BTYE (unsigned char) creating a VT_UI1 VARIANT
//
inline _variant_t& _variant_t::operator=(BYTE bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_UI1) {
		// Clear the VARIANT and create a VT_UI1
		//
		Clear();

		V_VT(this) = VT_UI1;
	}

	V_UI1(this) = bSrc;

	return *this;
}

// Assign a LONGLONG creating a VT_I8 VARIANT
//
inline _variant_t& _variant_t::operator=(LONGLONG llSrc) throw(_com_error)
{
	if (V_VT(this) != VT_I8) {
		// Clear the VARIANT and create a VT_I8
		//
		Clear();

		V_VT(this) = VT_I8;
	}

	V_I8(this) = llSrc;

	return *this;
}

// Assign a ULONGLONG creating a VT_UI8 VARIANT
//
inline _variant_t& _variant_t::operator=(ULONGLONG ullSrc) throw(_com_error)
{
	if (V_VT(this) != VT_UI8) {
		// Clear the VARIANT and create a VT_UI8
		//
		Clear();

		V_VT(this) = VT_UI8;
	}

	V_UI8(this) = ullSrc;

	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Comparison operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Compare a _variant_t against a const VARIANT& for equality
//
inline bool _variant_t::operator==(const VARIANT& varSrc) const throw()
{
	return *this == &varSrc;
}

// Compare a _variant_t against a const VARIANT* for equality
//
inline bool _variant_t::operator==(const VARIANT* pSrc) const throw()
{
	if (this == pSrc) {
		return true;
	}

	//
	// Variants not equal if types don't match
	//
	if (V_VT(this) != V_VT(pSrc)) {
		return false;
	}

	//
	// Check type specific values
	//
	switch (V_VT(this)) {
		case VT_EMPTY:
		case VT_NULL:
			return true;

		case VT_I2:
			return V_I2(this) == V_I2(pSrc);

		case VT_I4:
			return V_I4(this) == V_I4(pSrc);

		case VT_I8:
			return V_I8(this) == V_I8(pSrc);

		case VT_R4:
			return V_R4(this) == V_R4(pSrc);

		case VT_R8:
			return V_R8(this) == V_R8(pSrc);

		case VT_CY:
			return memcmp(&(V_CY(this)), &(V_CY(pSrc)), sizeof(CY)) == 0;

		case VT_DATE:
			return V_DATE(this) == V_DATE(pSrc);

		case VT_BSTR:
			return (::SysStringByteLen(V_BSTR(this)) == ::SysStringByteLen(V_BSTR(pSrc))) &&
					(memcmp(V_BSTR(this), V_BSTR(pSrc), ::SysStringByteLen(V_BSTR(this))) == 0);

		case VT_DISPATCH:
			return V_DISPATCH(this) == V_DISPATCH(pSrc);

		case VT_ERROR:
			return V_ERROR(this) == V_ERROR(pSrc);

		case VT_BOOL:
			return V_BOOL(this) == V_BOOL(pSrc);

		case VT_UNKNOWN:
			return V_UNKNOWN(this) == V_UNKNOWN(pSrc);

		case VT_DECIMAL:
			return memcmp(&(V_DECIMAL(this)), &(V_DECIMAL(pSrc)), sizeof(DECIMAL)) == 0;

		case VT_UI1:
			return V_UI1(this) == V_UI1(pSrc);

		default:
			_com_issue_error(E_INVALIDARG);
			// fall through
	}

	return false;
}

// Compare a _variant_t against a const VARIANT& for in-equality
//
inline bool _variant_t::operator!=(const VARIANT& varSrc) const throw()
{
	return !(*this == &varSrc);
}

// Compare a _variant_t against a const VARIANT* for in-equality
//
inline bool _variant_t::operator!=(const VARIANT* pSrc) const throw()
{
	return !(*this == pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Low-level operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Clear the _variant_t
//
inline void _variant_t::Clear() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

inline void _variant_t::Attach(VARIANT& varSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	//
	// Give control of data to _variant_t
	//
	memcpy(this, &varSrc, sizeof(varSrc));
	V_VT(&varSrc) = VT_EMPTY;
}

inline VARIANT _variant_t::Detach() throw(_com_error)
{
	VARIANT varResult = *this;
	V_VT(this) = VT_EMPTY;

	return varResult;
}

// Change the type and contents of this _variant_t to the type vartype and
// contents of pSrc
//
inline void _variant_t::ChangeType(VARTYPE vartype, const _variant_t* pSrc) throw(_com_error)
{
	//
	// If pDest is NULL, convert type in place
	//
	if (pSrc == NULL) {
		pSrc = this;
	}

	if ((this != pSrc) || (vartype != V_VT(this))) {
		_com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
												  const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
												  0, vartype));
	}
}

inline void _variant_t::SetString(const char* pSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////////////////

inline _variant_t::~_variant_t() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Mutually-dependent definitions
//
//////////////////////////////////////////////////////////////////////////////////////////

// Construct a _bstr_t from a const _variant_t&
//
inline _bstr_t::_bstr_t(const _variant_t &var) throw(_com_error)
	: m_Data(NULL)
{
	if (V_VT(&var) == VT_BSTR) {
		*this = V_BSTR(&var);
		return;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, &var);

	*this = V_BSTR(&varDest);
}

// Assign a const _variant_t& to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const _variant_t &var) throw(_com_error)
{
	if (V_VT(&var) == VT_BSTR) {
		*this = V_BSTR(&var);
		return *this;
	}

	_variant_t varDest;

	varDest.ChangeType(VT_BSTR, &var);

	*this = V_BSTR(&varDest);

	return *this;
}

extern _variant_t vtMissing;

#ifndef _USE_RAW
#define bstr_t _bstr_t
#define variant_t _variant_t
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif	// _INC_COMUTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\cdm\sources.inc ===
!include $(WINDOWS_COM)\wu.inc

!IF 0

  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

  File:   source.inc

  Description:

      IU CDM.DLL stub sources

!ENDIF

TARGETNAME=CDM
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK
DLLDEF=..\CDM.DEF
C_DEFINES=$(C_DEFINES) /D_CDM_
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
USE_STL=1
USE_STATIC_ATL=1
USE_MSVCRT=1
#BROWSER_INFO=1
#
# WUBUILD LAB will set this manually
#
# NT_SIGNCODE=1

TARGETLIBS=     \
    $(SDK_LIB_PATH)\kernel32.lib        \
    $(SDK_LIB_PATH)\user32.lib          \
    $(SDK_LIB_PATH)\advapi32.lib        \
    $(SDK_LIB_PATH)\wininet.lib         \
    $(SDK_LIB_PATH)\cabinet.lib         \
    $(SDK_LIB_PATH)\shlwapi.lib         \
    $(SDK_LIB_PATH)\uuid.lib			\
    $(SDK_LIB_PATH)\ole32.lib			\
    $(SDK_LIB_PATH)\oleaut32.lib        \
    $(SDK_LIB_PATH)\wintrust.lib        \
    $(SDK_LIB_PATH)\rasapi32.lib	    \
    $(SDK_LIB_PATH)\crypt32.lib			\
    $(SDK_LIB_PATH)\cfgmgr32.lib		\
    $(SDK_LIB_PATH)\setupapi.lib		\
	$(SDK_LIB_PATH)\version.lib			\
	$(SDK_LIB_PATH)\advpack.lib			\
	$(SDK_LIB_PATH)\shell32.lib			\
	$(WULIB)\logging\$(WUBLDTYPE)\$(O)\logging.lib	\
    $(WULIB)\util\$(WUBLDTYPE)\$(O)\util.lib		\
    $(WULIB)\detect\$(WUBLDTYPE)\$(O)\detect.lib     \
    $(WULIB)\download\$(WUBLDTYPE)\$(O)\download.lib   \
    $(WULIB)\install\$(WUBLDTYPE)\$(O)\install.lib    \
    $(WULIB)\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib    

#
# cdm.h is checked in as //depot/Lab04_N/enduser/published/inc/cdm.w and
# published to $(BASEDIR)\public\internal\enduser\inc
#
INCLUDES=$(INCLUDES);$(WINDOWS_COM)\inc;$(BASEDIR)\public\internal\enduser\inc;

SOURCES= \
	..\cdm.cpp			\
	..\cdm.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\acpitabl.h ===
/*****************************************************************************
 *
 *      (C) Copyright MICROSOFT Corp., 1996
 *
 *      Title:          ACPITABL.H --- Definitions and descriptions of the various BIOS supplied ACPI tables.
 *
 *      Version:        1.00
 *
 *      Date:           6-17-96
 *
 *      Author:         Jason Clark (jasoncl)
 *
 *------------------------------------------------------------------------------
 *
 *      Change log:
 *
 *         DATE     REV DESCRIPTION
 *      ----------- --- -----------------------------------------------------------
 *
 ****************************************************************************/

//      These map to bios provided structures, so turn on 1 byte packing

#include <pshpack1.h>

#define SPEC_VER 100

#define RSDP_SIGNATURE 0x2052545020445352       // "RSD PTR "

typedef struct  _RSDP   {       // Root System Description Table Pointer Structure

ULONGLONG       Signature;              // 8 UCHAR table signature 'RSD PTR '
UCHAR   Checksum;                       // sum of all UCHARs of structure must = 0
UCHAR   OEMID[6];                       //      String that uniquely ID's the OEM
UCHAR   Reserved[1];            // must be 0
ULONG   RsdtAddress;            // physical address of Root System Description Table

}       RSDP;

typedef RSDP    *PRSDP;

#ifndef NEC_98
#define RSDP_SEARCH_RANGE_BEGIN         0xE0000         // physical address where we begin searching for the RSDP
#else   // NEC_98
#define RSDP_SEARCH_RANGE_BEGIN         0xE8000         // physical address where we begin searching for the RSDP
#endif  // NEC_98
#define RSDP_SEARCH_RANGE_END           0xFFFFF
#define RSDP_SEARCH_RANGE_LENGTH        (RSDP_SEARCH_RANGE_END-RSDP_SEARCH_RANGE_BEGIN+1)
#define RSDP_SEARCH_INTERVAL            16      // search on 16 byte boundaries

typedef struct _DESCRIPTION_HEADER      {       // Header structure appears at the beginning of each ACPI table

ULONG   Signature;                      //      Signature used to identify the type of table
ULONG   Length;                         //      Length of entire table including the DESCRIPTION_HEADER
UCHAR   Revision;                       //      Minor version of ACPI spec to which this table conforms
UCHAR   Checksum;                       //      sum of all bytes in the entire TABLE should = 0
UCHAR   OEMID[6];                       //      String that uniquely ID's the OEM
UCHAR   OEMTableID[8];                  //      String that uniquely ID's this table (used for table patching and replacement).
ULONG   OEMRevision;                    //      OEM supplied table revision number.  Bigger number = newer table.
#if SPEC_VER > 92
UCHAR   CreatorID[4];                   //      Vendor ID of utility which created this table.
ULONG   CreatorRev;                     //      Revision of utility that created the table.
#endif

}       DESCRIPTION_HEADER;

typedef DESCRIPTION_HEADER      *PDESCRIPTION_HEADER;

// Header constants

#define ACPI_MAX_SIGNATURE       4
#define ACPI_MAX_OEM_ID          6
#define ACPI_MAX_TABLE_ID        8
#define ACPI_MAX_TABLE_STRINGS   ACPI_MAX_SIGNATURE + ACPI_MAX_OEM_ID + ACPI_MAX_TABLE_ID

#define FACS_SIGNATURE  0x53434146      // "FACS"

typedef struct _FACS    {       // Firmware ACPI Control Structure.  Note that this table does not have a header, it is pointed to by the FADT

ULONG   Signature;      //      'FACS'
ULONG   Length;         //      Length of entire firmware ACPI control structure (must be 64 bytes or larger)
ULONG   HardwareSignature;
ULONG   pFirmwareWakingVector;  // physical address of location where the OS needs to put the firmware waking vector
ULONG   GlobalLock;     // 32 bit structure used for sharing Embedded Controller
#if SPEC_VER > 92
ULONG   Flags;
UCHAR   Reserved[40];
#else
UCHAR   Reserved [44];
#endif

}       FACS;

typedef FACS    *PFACS;

// FACS.GlobalLock bit field definitions

#define         GL_PENDING_BIT          0x00
#define         GL_PENDING                      (1 << GL_PENDING_BIT)

#define         GL_OWNER_BIT            0x01
#define         GL_OWNER                        (1 << GL_OWNER_BIT)

#define GL_NON_RESERVED_BITS_MASK       (GL_PENDING+GL_OWNED)

// FACS Flags definitions

#define         FACS_S4BIOS_SUPPORTED_BIT   0   // flag indicates whether or not the BIOS will save/restore memory around S4
#define         FACS_S4BIOS_SUPPORTED       (1 << FACS_S4BIOS_SUPPORTED_BIT)


#define FADT_SIGNATURE  0x50434146      // "FACP"

typedef struct _FADT    {               // Fixed ACPI description table

DESCRIPTION_HEADER      Header;
ULONG                           facs;                           // Physical address of the Firmware ACPI Control Structure
ULONG                           dsdt;                           // Physical address of the Differentiated System Description Table
UCHAR                           int_model;                      // System's Interrupt mode, 0=Dual PIC, 1=Multiple APIC, >1 reserved
UCHAR                           reserved4;
USHORT                          sci_int_vector;         // Vector of SCI interrupt.
PUCHAR                          smi_cmd_io_port;        // Address in System I/O Space of the SMI Command port, used to enable and disable ACPI.
UCHAR                           acpi_on_value;          // Value out'd to smi_cmd_port to activate ACPI
UCHAR                           acpi_off_value;         // Value out'd to smi_cmd_port to deactivate ACPI
UCHAR                           s4bios_req;             // Value to write to SMI_CMD to enter the S4 state.
UCHAR                           reserved1;                      // Must Be 0
ULONG                           pm1a_evt_blk_io_port;   // Address in System I/O Space of the PM1a_EVT_BLK register block
ULONG                           pm1b_evt_blk_io_port;   // Address in System I/O Space of the PM1b_EVT_BLK register block
ULONG                           pm1a_ctrl_blk_io_port;  // Address in System I/O Space of the PM1a_CNT_BLK register block
ULONG                           pm1b_ctrl_blk_io_port;  // Address in System I/O Space of the PM1b_CNT_BLK register block
ULONG                           pm2_ctrl_blk_io_port;   // Address in System I/O Space of the PM2_CNT_BLK register block
ULONG                           pm_tmr_blk_io_port;             // Address in System I/O Space of the PM_TMR register block
ULONG                           gp0_blk_io_port;        //      Address in System I/O Space of the GP0 register block
ULONG                           gp1_blk_io_port;        //      Address in System I/O Space of the GP1 register block
UCHAR                           pm1_evt_len;            // number of bytes decoded for PM1_BLK (must be >= 4)
UCHAR                           pm1_ctrl_len;           // number of bytes decoded for PM1_CNT (must be >= 2)
UCHAR                           pm2_ctrl_len;           // number of bytes decoded for PM1a_CNT (must be >= 1)
UCHAR                           pm_tmr_len;                     // number of bytes decoded for PM_TMR (must be >= 4)
UCHAR                           gp0_blk_len;            // number of bytes decoded for GP0_BLK (must be multiple of 2)
UCHAR                           gp1_blk_len;            // number of bytes decoded for GP1_BLK (must be multiple of 2)
UCHAR                           gp1_base;               // index at which GP1 based events start
UCHAR                           reserved2;              // Must Be 0
USHORT                          lvl2_latency;           // Worst case latency in microseconds required to enter and leave the C2 processor state
USHORT                          lvl3_latency;           // Worst case latency in microseconds required to enter and leave the C3 processor state
USHORT                          flush_size;                     // Ignored if WBINVD flag is 1 -- indicates size of memory read to flush dirty lines from
                                                                                // any processors memory caches. A size of zero indicates this is not supported.
USHORT                          flush_stride;           // Ignored if WBINVD flag is 1 -- the memory stride width, in bytes, to perform reads to flush
                                                                                // the processor's memory caches.
UCHAR                           duty_offset;            // zero based index of where the processor's duty cycle setting is within the processor's P_CNT register.
UCHAR                           duty_width;                     // bit width of the processor's duty cycle setting value in the P_CNT register.
                                                                                // a value of zero indicates that processor duty cycle is not supported
UCHAR                           day_alarm_index;
UCHAR                           month_alarm_index;
UCHAR                           century_alarm_index;
#if SPEC_VER > 92
UCHAR                           reserved3[3];
ULONG                           flags;
#else
UCHAR                           reserved3;
ULONG                           flags;
#endif

}       FADT;

typedef FADT            *PFADT;

// definition of FADT.flags bits

// this one bit flag indicates whether or not the WBINVD instruction works properly,if this bit is not set we can not use S2, S3 states, or
// C3 on MP machines
#define         WRITEBACKINVALIDATE_WORKS_BIT           0
#define         WRITEBACKINVALIDATE_WORKS               (1 << WRITEBACKINVALIDATE_WORKS_BIT)

//  this flag indicates if wbinvd works EXCEPT that it does not invalidate the cache
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT   1
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE       (1 << WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT)

//  this flag indicates that the C1 state is supported on all processors.
#define         SYSTEM_SUPPORTS_C1_BIT                  2
#define         SYSTEM_SUPPORTS_C1                      (1 << SYSTEM_SUPPORTS_C1_BIT)

// this one bit flag indicates whether support for the C2 state is restricted to uniprocessor machines
#define         P_LVL2_UP_ONLY_BIT                      3
#define         P_LVL2_UP_ONLY                          (1 << P_LVL2_UP_ONLY_BIT)

//      this bit indicates whether the PWR button is treated as a fix feature (0) or a generic feature (1)
#define         PWR_BUTTON_GENERIC_BIT                  4
#define         PWR_BUTTON_GENERIC                      (1 << PWR_BUTTON_GENERIC_BIT)

#define         SLEEP_BUTTON_GENERIC_BIT                5
#define         SLEEP_BUTTON_GENERIC                    (1 << SLEEP_BUTTON_GENERIC_BIT)

//      this bit indicates whether the RTC wakeup status is reported in fix register space (0) or not (1)
#define         RTC_WAKE_GENERIC_BIT                    6
#define         RTC_WAKE_GENERIC                        (1 << RTC_WAKE_GENERIC_BIT)

#define         RTC_WAKE_FROM_S4_BIT                    7
#define         RTC_WAKE_FROM_S4                        (1 << RTC_WAKE_FROM_S4_BIT)

// This bit indicates whether the machine implements a 24 or 32 bit timer.
#define         TMR_VAL_EXT_BIT                         8
#define         TMR_VAL_EXT                             (1 << TMR_VAL_EXT_BIT)

// This bit indicates whether the machine supports docking
#define         DCK_CAP_BIT                             9
#define         DCK_CAP                                 (1 << DCK_CAP_BIT)

//      spec defines maximum entry/exit latency values for C2 and C3, if the FADT indicates that these values are
//      exceeded then we do not use that C state.

#define         C2_MAX_LATENCY  100
#define         C3_MAX_LATENCY  1000

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY   1
#endif

// Multiple APIC description table

typedef struct _MAPIC   {

DESCRIPTION_HEADER  Header;
ULONG               LocalAPICAddress;   // Physical Address at which each processor can access its local APIC
ULONG               Flags;
ULONG               APICTables[ANYSIZE_ARRAY];  // A list of APIC tables.

}       MAPIC;

typedef MAPIC *PMAPIC;

// Multiple APIC structure flags

#define PCAT_COMPAT_BIT 0   // indicates that the system also has a dual 8259 pic setup.
#define PCAT_COMPAT     (1 << PCAT_COMPAT_BIT)

// APIC Structure Types
#define PROCESSOR_LOCAL_APIC            0
#define IO_APIC                         1
#define ISA_VECTOR_OVERRIDE             2
#define NMI_SOURCE                      3
#define PROCESSOR_LOCAL_APIC_LENGTH     8
#define IO_APIC_LENGTH                  12
#define ISA_VECTOR_OVERRIDE_LENGTH      10
#define NMI_SOURCE_LENGTH               8

// The shared beginning info in all APIC Structures

typedef struct _APICTABLE {
   UCHAR Type;
   UCHAR Length;
} APICTABLE;

typedef APICTABLE *PAPICTABLE;

typedef struct _PROCLOCALAPIC   {

UCHAR   Type;   // should be zero to identify a ProcessorLocalAPIC structure
UCHAR   Length; // better be 8
UCHAR   ACPIProcessorID;    // ProcessorID for which this processor is listed in the ACPI processor declaration
                            // operator.
UCHAR   APICID; //  The processor's local APIC ID.
ULONG   Flags;

}       PROCLOCALAPIC;

typedef PROCLOCALAPIC *PPROCLOCALAPIC;

// Processor Local APIC Flags
#define PLAF_ENABLED_BIT    0
#define PLAF_ENABLED        (1 << PLAF_ENABLED_BIT)

typedef struct _IOAPIC  {

UCHAR   Type;
UCHAR   Length; // better be 12
UCHAR   IOAPICID;
UCHAR   Reserved;
ULONG   IOAPICAddress; // Physical address at which this IO APIC resides.
ULONG   SystemVectorBase; // system interrupt vector index for this APIC

}       IOAPIC;

typedef IOAPIC *PIOAPIC;

// Interrupt Source Override
typedef struct {
    UCHAR   Type;                           // Must be 2
    UCHAR   Length;                         // Must be 10
    UCHAR   Bus;                            // Must be 0
    UCHAR   Source;                         // BusRelative IRQ
    ULONG   GlobalSystemInterruptVector;    // Global IRQ
    USHORT  Flags;                          // Same as MPS INTI Flags
} ISA_VECTOR, *PISA_VECTOR;

// Non Maskable Source Interrupt
typedef struct {
    UCHAR   Type;                           // must be 3
    UCHAR   Length;                         // better be 8
    USHORT  Flags;                          // Same as MPS INTI Flags
    ULONG   GlobalSystemInterruptVector;    // Interrupt connected to NMI
} NMISOURCE, *PNMISOURCE;

typedef struct _SMARTBATTTABLE   {

DESCRIPTION_HEADER  Header;
ULONG   WarningEnergyLevel; // mWh at which the OEM suggests we warn the user that the battery is getting low.
ULONG   LowEnergyLevel;     // mWh at which the OEM suggests we put the machine into a sleep state.
ULONG   CriticalEnergyLevel; // mWH at which the OEM suggests we do an emergency shutdown.

}       SMARTBATTTABLE;

typedef SMARTBATTTABLE *PSMARTBATTTABLE;

#define RSDT_SIGNATURE  0x54445352      // "RSDT"

typedef struct _RSDT    {       // Root System Description Table

DESCRIPTION_HEADER      Header;
ULONG   Tables[ANYSIZE_ARRAY];          // The structure contains an n length array of physical addresses each of which point to another table.

}       RSDT;

typedef RSDT            *PRSDT;

// The below macro uses the min macro to protect against the case where we are running on machine which is compliant with
// a spec prior to .99.  If you had a .92 compliant header and one table pointer we would end of subtracting 32-36 resulting
// in a really big number and hence we would think we had lots and lots of tables...  Using the min macro we end up subtracting
// the length-length getting zero which will be harmless and cause us to fail to load (with a red screen on Win9x) which is
// the best we can do in this case.

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define NumTableEntriesFromRSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/4


#define APIC_SIGNATURE  0x43495041      // "APIC"
#define DSDT_SIGNATURE  0x54445344      // "DSDT"
#define SSDT_SIGNATURE  0x54445353      // "SSDT"
#define PSDT_SIGNATURE  0x54445350      // "PSDT"
#define SBST_SIGNATURE  0x54534253      // "SBST"

typedef struct _DSDT    {       // Differentiated System Description Table

DESCRIPTION_HEADER      Header;
UCHAR                   DiffDefBlock[ANYSIZE_ARRAY];    // this is the AML describing the base system.

}       DSDT;

typedef DSDT            *PDSDT;

//      Resume normal structure packing

#include <poppack.h>

#ifdef BOOLEAN  // hack to build ASL.exe
typedef struct {
    UCHAR   NamespaceProcID;
    UCHAR   ApicID;
    UCHAR   NtNumber;
    BOOLEAN Started;
} PROC_LOCAL_APIC, *PPROC_LOCAL_APIC;

extern PROC_LOCAL_APIC HalpProcLocalApicTable[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\diamond.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   diamond.h
//
//  Description:
//
//      IU diamond decompression library
//
//=======================================================================

#ifndef __DIAMOND_INC
#define __DIAMOND_INC

HRESULT DecompressFolderCabs(LPCTSTR pszDecompressPath);
BOOL DecompressFile(LPCTSTR pszDecompressFile, LPCTSTR pszDecompressPath);
// BOOL DecompressFileToMem(LPCTSTR pszDecompressFile, PBYTE *ppBuffer);

#endif	//__FILEUTIL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\cdm\cdm.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdm.cpp
//
//  Description:
//
//      Functions exported by CDM
//
//			CloseCDMContext
//          DetFilesDownloaded
//			DownloadGetUpdatedFiles
//			DownloadIsInternetAvailable	
//			DownloadUpdatedFiles
//			FindMatchingDriver
//			LogDriverNotFound
//			OpenCDMContext
//			OpenCDMContextEx
//			QueryDetectionFiles
//
//=======================================================================
#include <objbase.h>
#include <winbase.h>
#include <tchar.h>
#include <logging.h>
#include <iucommon.h>
#include <loadengine.h>
#include <osdet.h>
#include <iu.h>
#include <wininet.h>
#include <wusafefn.h>

static BOOL g_fCloseConnection /* FALSE */;

static HMODULE g_hEngineModule /* = NULL */;
static PFN_InternalDetFilesDownloaded			g_pfnDetFilesDownloaded /* = NULL */;
static PFN_InternalDownloadGetUpdatedFiles		g_pfnDownloadGetUpdatedFiles /* = NULL */;
static PFN_InternalDownloadUpdatedFiles			g_pfnDownloadUpdatedFiles /* = NULL */;
static PFN_InternalFindMatchingDriver			g_pfnFindMatchingDriver /* = NULL */;
static PFN_InternalLogDriverNotFound			g_pfnLogDriverNotFound /* = NULL */;
static PFN_InternalQueryDetectionFiles			g_pfnQueryDetectionFiles /* = NULL */;
static PFN_InternalSetGlobalOfflineFlag			g_pfnSetGlobalOfflineFlag /* = NULL */;
static PFN_SetOperationMode						g_pfnSetOperationMode /* = NULL */;

static HMODULE									g_hCtlModule /* = NULL */;
static long										g_lLoadEngineRefCount /* = 0 */;
static PFN_LoadIUEngine							g_pfnCtlLoadIUEngine /* = NULL */;
static PFN_UnLoadIUEngine						g_pfnCtlUnLoadIUEngine /* = NULL */;


static CRITICAL_SECTION g_cs;
BOOL g_fInitCS;

const TCHAR szOpenCDMContextFirst[] = _T("Must OpenCDMContext first!");
//
// constant for SetOperationMode() API (BUILD util won't allow building iuctl.idl from cdm dir)
//
const LONG		UPDATE_COMMAND_CANCEL				= 0x00000004;


BOOL APIENTRY DllMain(
	HINSTANCE hInstance, 
    DWORD  ul_reason_for_call, 
    LPVOID /*lpReserved*/
)
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls(hInstance);

			g_fInitCS = SafeInitializeCriticalSection(&g_cs);
			//
			// Initialize free logging
			//
			InitFreeLogging(_T("CDM"));
			LogMessage("Starting");

			if (!g_fInitCS)
			{
				LogError(E_FAIL, "InitializeCriticalSection");
				return FALSE;
			}
			break;
		case DLL_PROCESS_DETACH:
			//
			// Shutdown free logging
			//
			LogMessage("Shutting down");
			TermFreeLogging();

			if (g_fInitCS)
			{
				DeleteCriticalSection(&g_cs);
			}
			break;
    }
    return TRUE;
}

void UnLoadCtlAndEngine(void)
{
	LOG_Block("UnLoadCtlAndEngine");

	EnterCriticalSection(&g_cs);

	if (0 != g_lLoadEngineRefCount)
	{
		g_lLoadEngineRefCount--;
	}

	if (0 == g_lLoadEngineRefCount)
	{
		if(NULL != g_hEngineModule)
		{
			//
			// Call UnLoadIUEngine
			//
			g_pfnCtlUnLoadIUEngine(g_hEngineModule);
			g_hEngineModule = NULL;

			g_pfnDetFilesDownloaded = NULL;
			g_pfnDownloadGetUpdatedFiles = NULL;
			g_pfnDownloadUpdatedFiles = NULL;
			g_pfnFindMatchingDriver = NULL;
			g_pfnLogDriverNotFound = NULL;
			g_pfnQueryDetectionFiles = NULL;
			g_pfnSetGlobalOfflineFlag = NULL;
			g_pfnSetOperationMode = NULL;
		}

		if (NULL != g_hCtlModule)
		{
			//
			// Unload the iuctl.dll
			//
			FreeLibrary(g_hCtlModule);
			g_hCtlModule = NULL;
			g_pfnCtlLoadIUEngine = NULL;
			g_pfnCtlUnLoadIUEngine = NULL;
		}

		if (g_fCloseConnection)
		{
			//
			// We dialed for the user - now disconnect
			//
			if (!InternetAutodialHangup(0))
			{
				LOG_ErrorMsg(E_FAIL);
				SetLastError(E_FAIL);
			}

			g_fCloseConnection = FALSE;
		}
	}

	LeaveCriticalSection(&g_cs);
}

BOOL LoadCtlAndEngine(BOOL fConnectIfNotConnected)
{
	LOG_Block("LoadCtlAndEngine");

	BOOL fRet = FALSE;
	HRESULT hr;
	DWORD dwFlags;
    BOOL fConnected = InternetGetConnectedState(&dwFlags, 0);
	LOG_Driver(_T("fConnectIfNotConnected param is %s"), fConnectIfNotConnected ? _T("TRUE") : _T("FALSE"));
	LOG_Driver(_T("fConnected = %s, dwFlags from InternetGetConnectedState = 0x%08x"), fConnected ? _T("TRUE") : _T("FALSE"), dwFlags);

	EnterCriticalSection(&g_cs);	// start touching globals

	if (fConnectIfNotConnected)
	{
		if (!fConnected)
		{
			if ((INTERNET_CONNECTION_MODEM & dwFlags) && !(INTERNET_CONNECTION_OFFLINE & dwFlags))
			{
				//
				// If we are not already connected to the internet and 
				// the system is configured to use a modem attempt a connection.
				//
				DWORD dwErr;
				if (ERROR_SUCCESS == (dwErr = InternetAttemptConnect(0)))
				{
					LOG_Driver(_T("auto-dial succeeded"));
					//
					// The auto-dial worked, we need to disconnect later
					//
					g_fCloseConnection = TRUE;
					fConnected = TRUE;
				}
				else
				{
					//
					// Bail with error since we are required to be online
					//
					LOG_Driver(_T("auto-dial failed"));
					LOG_ErrorMsg(dwErr);
					SetLastError(dwErr);
					goto CleanUp;
				}
			}
			else
			{
				//
				// We can't connect because we aren't configured for a modem or user set IE offline mode
				//
				LOG_ErrorMsg(ERROR_GEN_FAILURE);
				SetLastError(ERROR_GEN_FAILURE);
				goto CleanUp;
			}
		}
	}

	//
	// Now that we are connected (only required if TRUE == fConnectIfNotConnected)
	//
	if (NULL != g_hEngineModule)
	{
		LOG_Driver(_T("IUEngine is already loaded"));
		//
		// Bump the ref count and return TRUE
		//
		g_lLoadEngineRefCount++;
		fRet = TRUE;
		goto CleanUp;
	}
	//
	// This extra lock on wininet.dll is required to prevent a TerminateThread call from
	// WININET!AUTO_PROXY_DLLS::FreeAutoProxyInfo during FreeLibrary of CDM.DLL.
	//
	// We don't ever free the returned handle, but will fail the call if it returns NULL
	//
	if (NULL == LoadLibraryFromSystemDir(_T("wininet.dll")))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	//
	// Load iuctl.dll and get the [Un]LoadIUEngine function pointers
	//
	if (NULL == (g_hCtlModule = LoadLibraryFromSystemDir(_T("iuctl.dll"))))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (NULL == (g_pfnCtlLoadIUEngine = (PFN_LoadIUEngine) GetProcAddress(g_hCtlModule, "LoadIUEngine")))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (NULL == (g_pfnCtlUnLoadIUEngine = (PFN_UnLoadIUEngine) GetProcAddress(g_hCtlModule, "UnLoadIUEngine")))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}
	//
	// Now we can call LoadIUEngine() 
	//
	if (NULL == (g_hEngineModule = g_pfnCtlLoadIUEngine(TRUE, !fConnected)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	g_pfnDetFilesDownloaded = (PFN_InternalDetFilesDownloaded) GetProcAddress(g_hEngineModule, "InternalDetFilesDownloaded");
	g_pfnDownloadGetUpdatedFiles = (PFN_InternalDownloadGetUpdatedFiles) GetProcAddress(g_hEngineModule, "InternalDownloadGetUpdatedFiles");
	g_pfnDownloadUpdatedFiles = (PFN_InternalDownloadUpdatedFiles) GetProcAddress(g_hEngineModule, "InternalDownloadUpdatedFiles");
	g_pfnFindMatchingDriver = (PFN_InternalFindMatchingDriver) GetProcAddress(g_hEngineModule, "InternalFindMatchingDriver");
	g_pfnLogDriverNotFound = (PFN_InternalLogDriverNotFound) GetProcAddress(g_hEngineModule, "InternalLogDriverNotFound");
	g_pfnQueryDetectionFiles = (PFN_InternalQueryDetectionFiles) GetProcAddress(g_hEngineModule, "InternalQueryDetectionFiles");
	g_pfnSetGlobalOfflineFlag = (PFN_InternalSetGlobalOfflineFlag) GetProcAddress(g_hEngineModule, "InternalSetGlobalOfflineFlag");
	g_pfnSetOperationMode = (PFN_SetOperationMode) GetProcAddress(g_hEngineModule, "EngSetOperationMode");

	if (NULL == g_pfnDetFilesDownloaded				||
		NULL == g_pfnDownloadGetUpdatedFiles		||
		NULL == g_pfnDownloadUpdatedFiles			||
		NULL == g_pfnFindMatchingDriver				||
		NULL == g_pfnLogDriverNotFound				||
		NULL == g_pfnQueryDetectionFiles			||
		NULL == g_pfnSetGlobalOfflineFlag			||
		NULL == g_pfnSetOperationMode  )
	{
		LOG_Driver(_T("GetProcAddress on IUEngine failed"));
		LOG_ErrorMsg(ERROR_CALL_NOT_IMPLEMENTED);
		SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	}
	else
	{
		fRet = TRUE;
		g_lLoadEngineRefCount++;
		// Set Global Offline Flag - checked by XML Classes to disable Validation (schemas are on the net)
		g_pfnSetGlobalOfflineFlag(!fConnected);
	}
	// goto CleanUp;

CleanUp:

	if (FALSE == fRet)
	{
		UnLoadCtlAndEngine();
	}

	LeaveCriticalSection(&g_cs);

	return fRet;
}

//This API closes the internet connection opened with the OpenCDMContext() API.
//If CDM did not open the internet connection this API simply returns. The CDM
//context handle must have been the same handle that was returned from
//the OpenCDMContext() API.
//
//This call cannot fail. If the pConnection handle is invalid this function
//simply ignores it.

VOID WINAPI CloseCDMContext (
	IN HANDLE /* hConnection */	// Obsolete handle returned by OpenCDMContext.
)
{
	LOG_Block("CloseCDMContext");

	//
	// This is the only spot we unload engine (but note exceptions in
	// DownloadGetUpdatedFiles).
	//
	// Doesn't use COM
	//
	UnLoadCtlAndEngine();
}


void WINAPI DetFilesDownloaded(
    IN  HANDLE hConnection
)
{
	LOG_Block("DetFilesDownloaded");

	HRESULT hr;
	if (g_pfnDetFilesDownloaded)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			g_pfnDetFilesDownloaded(hConnection);

			CoUninitialize();
		}
		else
		{
			LOG_ErrorMsg(hr);
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
	}
}

//Win 98 entry point
//This function allows Windows 98 to call the same entry points as NT.
//The function returns TRUE if the download succeeds and FALSE if it
//does not.

BOOL DownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,	//The win98 download info structure is
												//slightly different that the NT version
												//so this function handles conversion.
	IN OUT LPTSTR			lpDownloadPath,		//returned Download path to the downloaded
												//cab files.
	IN UINT					uSize				//size of passed in download path buffer.
)
{

	LOG_Block("DownloadGetUpdatedFiles");

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return FALSE;
	}

	//
	// Special case - we need to load  and unloadengine since historically we haven't required an
	// OpenCDMContext[Ex] call before calling this function and CloseCDMContext after.
	//
	HRESULT hr;
	BOOL fRet;
	if (LoadCtlAndEngine(TRUE))
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			fRet = g_pfnDownloadGetUpdatedFiles(pDownloadInfoWin98, lpDownloadPath, uSize);

			CoUninitialize();
		}
		else
		{
			LOG_ErrorMsg(hr);
			fRet = FALSE;
		}

		UnLoadCtlAndEngine();
		return fRet;
	}
	else
	{
		return FALSE;
	}
}

//This function determines if this client can connect to the internet.

BOOL DownloadIsInternetAvailable(void)
{
	LOG_Block("DownloadIsInternetAvailable");

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return FALSE;
	}

	//
	// We don't care about the current online state, just if we have a
	// connection configured (returned in dwFlags).
	//
	DWORD dwFlags;
	(void) InternetGetConnectedState(&dwFlags, 0);

	if (	(	(INTERNET_CONNECTION_CONFIGURED & dwFlags)	||
				(INTERNET_CONNECTION_LAN & dwFlags)			||
				(INTERNET_CONNECTION_MODEM  & dwFlags)		||
				(INTERNET_RAS_INSTALLED  & dwFlags)			||
				(INTERNET_CONNECTION_PROXY  & dwFlags)		)

			&&	!(INTERNET_CONNECTION_OFFLINE & dwFlags)
		)
	{
		LOG_Driver(_T("Returning TRUE: InternetGetConnectedState returned 0x%08x in dwFlags"), dwFlags);
		return TRUE;
	}
	else
	{
		LOG_Driver(_T("Returning FALSE: InternetGetConnectedState returned 0x%08x in dwFlags"), dwFlags);
		return FALSE;
	}
}

//This function downloads the specified CDM package. The hConnection handle must have
//been returned from the OpenCDMContext() API.
//
//This function Returns TRUE if download is successful GetLastError() will return
//the error code indicating the reason that the call failed.

BOOL WINAPI DownloadUpdatedFiles(
	IN  HANDLE        hConnection,		//Connection handle from OpenCDMContext() API.
	IN  HWND          hwnd,				//Window handle for call context
	IN  PDOWNLOADINFO pDownloadInfo,	//download information structure describing
										//package to be read from server
	OUT LPWSTR        lpDownloadPath,	//local computer directory location of the
										//downloaded files
	IN  UINT          uSize,			//size of the download path buffer. If this
										//buffer is to small to contain the complete
										//path and file name no file will be downloaded.
										//The PUINT puReguiredSize parameter can be checked
										//to determine the size of buffer necessary to
										//perform the download.
	OUT PUINT         puRequiredSize	//required lpDownloadPath buffer size. This
										//parameter is filled in with the minimum size
										//that is required to place the complete path
										//file name of the downloaded file. If this
										//parameter is NULL no size is returned.
)
{
	LOG_Block("DownloadUpdatedFiles");

	HRESULT hr;
	BOOL fRet;
	if (g_pfnDownloadUpdatedFiles)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			fRet = g_pfnDownloadUpdatedFiles(hConnection, hwnd, pDownloadInfo, lpDownloadPath, uSize, puRequiredSize);

			CoUninitialize();
			return fRet;
		}
		else
		{
			LOG_ErrorMsg(hr);
			return FALSE;
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
		return FALSE;
	}
}

BOOL WINAPI  FindMatchingDriver(
	IN  HANDLE			hConnection,
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
)
{
	LOG_Block("FindMatchingDriver");

	HRESULT hr;
	BOOL fRet;
	if (g_pfnFindMatchingDriver)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			fRet = g_pfnFindMatchingDriver(hConnection, pDownloadInfo, pWuDriverInfo);

			CoUninitialize();
			return fRet;
		}
		else
		{
			LOG_ErrorMsg(hr);
			return FALSE;
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
		return FALSE;
	}
}

// supports offline logging
// hConnection NOT used at all
// no network connection or osdet.dll needed for languauge, SKU, platform detection 
void WINAPI LogDriverNotFound(
    IN  HANDLE hConnection,
	IN LPCWSTR lpDeviceInstanceID,
	IN DWORD dwFlags
)
{
	LOG_Block("LogDriverNotFound");

	HRESULT hr;
	if (g_pfnLogDriverNotFound)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			g_pfnLogDriverNotFound(hConnection, lpDeviceInstanceID, dwFlags);

			CoUninitialize();
		}
		else
		{
			LOG_ErrorMsg(hr);
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
	}
}


HANDLE WINAPI OpenCDMContext(
    IN HWND /* hwnd */	//Window handle to use for any UI that needs to be presented (not used)
)
{
	LOG_Block("OpenCDMContext");

	return OpenCDMContextEx(TRUE);
}

HANDLE WINAPI OpenCDMContextEx(
    IN BOOL fConnectIfNotConnected
)
{
	LOG_Block("OpenCDMContextEx");

	//
	// Don't open a context if we are disabled (0 and -1 OK)
	// Other functions will fail because their g_pfnXxxxx == NULL.
	//
	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		SetLastError(ERROR_SERVICE_DISABLED);
		return NULL;
	}

	//
	// Doesn't use COM
	//
	if (LoadCtlAndEngine(fConnectIfNotConnected))
	{
		//
		// This is an obsolete function that just loads the engine (which may do autodial to connect).
		// We just return non-NULL g_lLoadEngineRefCount to keep existing clients happy, but never use it.
		//


		return LongToHandle(g_lLoadEngineRefCount);
	}
	else
	{
		return NULL;
	}
}

int WINAPI QueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
)
{
	LOG_Block("QueryDetectionFiles");

	HRESULT hr;
	int nRet;
	if (g_pfnQueryDetectionFiles)
	{
		if (SUCCEEDED(hr = CoInitialize(0)))
		{
			nRet = g_pfnQueryDetectionFiles(hConnection, pCallbackParam, pCallback);

			CoUninitialize();
			return nRet;
		}
		else
		{
			LOG_ErrorMsg(hr);
			return 0;
		}
	}
	else
	{
		LOG_Error(szOpenCDMContextFirst);
		return 0;
	}
}

//
// 502965 Windows Error Reporting bucket 2096553: Hang following NEWDEV.DLL!CancelDriverSearch
//
// Provide API to allow clients to cancel synchronous calls into CDM by calling this function
// asynchronously from a second thread.
//
HRESULT WINAPI CancelCDMOperation(void)
{
	LOG_Block("CancelCDMOperation");

	if (g_pfnSetOperationMode)
	{
		return g_pfnSetOperationMode(NULL, NULL, UPDATE_COMMAND_CANCEL);
	}
	else
	{
		LOG_ErrorMsg(E_ACCESSDENIED);
		return E_ACCESSDENIED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\asptlb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Mon Nov 03 15:43:09 1997
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 



DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IReadCookie_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IReadCookie_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Count_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IReadCookie_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Key_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IReadCookie_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantDictionary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][oleautomation][dual][uuid] */ 



DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\dllite.h ===
#ifndef DLLITE_H
#define DLLITE_H

// if a new dll is added here or the values are changed, be sure to change the 
//  c_cchFilePathBuffer value below to match
const TCHAR  c_szWinHttpDll[]        = _T("winhttp.dll");
const TCHAR  c_szWinInetDll[]        = _T("wininet.dll");

// this value is comprised of the size (in TCHARS) of the largest dll above + 
//  the size of a backslash + the size of the null termiantor
const DWORD  c_cchFilePathBuffer     = (sizeof(c_szWinHttpDll) / sizeof(TCHAR)) + 1 + 1;

typedef struct tagSAUProxySettings
{
    LPWSTR  wszProxyOrig;
    LPWSTR  wszBypass;
    DWORD   dwAccessType;
    
    LPWSTR  *rgwszProxies;
    DWORD   cProxies;
    DWORD   iProxy;
} SAUProxySettings;

HRESULT DownloadFileLite(LPCTSTR pszDownloadUrl, 
                         LPCTSTR pszLocalFile,  
                         HANDLE hQuitEvent,
                         DWORD dwFlags);

HRESULT GetAUProxySettings(LPCWSTR wszUrl, SAUProxySettings *paups);
HRESULT FreeAUProxySettings(SAUProxySettings *paups);
HRESULT CleanupDownloadLib(void);

DWORD   GetAllowedDownloadTransport(DWORD dwInitialFlags);
BOOL    HandleEvents(HANDLE *phEvents, UINT nEventCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\freelog.h ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   FreeLog.h
//
//  Owner:  KenSh
//
//  Description:
//
//      Runtime logging for use in both checked and free builds.
//
//=======================================================================

#pragma once

#include <tchar.h>

#define DEFAULT_LOG_FILE_NAME		_T("Windows Update.log")


void InitFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName = DEFAULT_LOG_FILE_NAME);
void TermFreeLogging();

void LogMessage(LPCSTR pszFormatA, ...);
void LogError(DWORD dwError, LPCSTR pszFormatA, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\install.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   install.h
//
//  Description:
//
//      Functions called to install downloaded software and drivers
//
//=======================================================================

#define ITEM_STATUS_SUCCESS						0x00000000	// The package was installed successfully.
#define ITEM_STATUS_INSTALLED_ERROR				0x00000001	// The package was Installed however there were some minor problems that did not prevent installation.
#define ITEM_STATUS_FAILED						0x00000002	// The packages was not installed.
#define ITEM_STATUS_SUCCESS_REBOOT_REQUIRED		0x00000004	// The package was installed and requires a reboot.
#define ITEM_STATUS_DOWNLOAD_COMPLETE			0x00000008  // The package was downloaded but not installed
#define ITEM_STATUS_UNINSTALL_STARTED			0x00000010	// uninstall was started 		

// 

#define COMMANDTYPE_INF                         1
#define COMMANDTYPE_ADVANCEDINF                 2
#define COMMANDTYPE_EXE                         3
#define COMMANDTYPE_MSI                         4
#define COMMANDTYPE_CUSTOM                      5

typedef struct INSTALLCOMMANDINFO
{
    int iCommandType;                           // INF, ADVANCED_INF, EXE, CUSTOM
    TCHAR szCommandLine[MAX_PATH];              // Command to Run (EXE name or INF name)
    TCHAR szCommandParameters[MAX_PATH];        // Parameters for Command (switches, etc..)
    TCHAR szInfSection[256];                    // INF Install Section if Override is needed
} INSTALLCOMMANDINFO, *PINSTALLCOMMANDINFO;


/*** InstallPrinterDriver - 
 *
 */
HRESULT InstallPrinterDriver(
	IN	LPCTSTR pszDriverName,
	IN	LPCTSTR pszLocalDir,					//Local directory where installation files are.
	IN	LPCTSTR pszArchitecture,
	OUT	DWORD* pdwStatus
	);

//This function handles installation of a Device driver package.
HRESULT InstallDriver(
	IN	LPCTSTR pszLocalDir,					// Local directory where installation files are.
	IN	LPCTSTR pszDisplayName,				// Description of package, Device Manager displays this in its install dialog.
	IN	LPCTSTR pszHardwareID,				// ID from XML matched to client hardware via GetManifest()
	OUT	DWORD* pdwStatus
	);


//This function handles installation of an Active Setup type package (INF or EXE)
HRESULT InstallSoftwareItem(
    IN  LPTSTR pszInstallSourcePath,
    IN  BOOL    fRebootRequired,
    IN  LONG    lNumberOfCommands,
    IN  PINSTALLCOMMANDINFO pCommandInfoArray,
    OUT  DWORD*  pdwStatus
    );

// this function handles installation of a Custom Installer type package
HRESULT InstallCustomInstallerItem();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\iucommon.h ===
/////////////////////////////////////////////////////////////////////////////
// Defines
// 
//  2000 Microsoft Corporation. All rights reserved
//

#pragma once

#include <logging.h>	// for CleanUpXxxx that use logging
#include <tchar.h>
//
// 481561 IU: iucommon.h should use safefunc.h instead of redefining SafeRelease()
// Actually, we were first :-), but will correct conflicts in the control code rather than AU.
//
// NOTE: since these headers came from different teams, the same defines may have different
// behavior. For instance SafeRelease() in iucommon.h NULLs the pointer after release, but
// not in safefunc.h. Appropriate adjustments made in the .cpp files.
#include <safefunc.h>

const TCHAR IDENTTXT[] = _T("iuident.txt");
const CHAR	SZ_SEE_IUHIST[] = "See iuhist.xml for details:";

/**
* constant for GetManifest()
*/
const DWORD FLAG_USE_COMPRESSION = 0x00000001;

/**
* constnat for GetManifest(), Detect(), GetSystemSpec(), GetHistory()
*/
const DWORD FLAG_OFFLINE_MODE    = 0x00000002;

//
// MAX_SETUP_MULTI_SZ_SIZE is used to make sure SetupDiGetDeviceRegistryProperty
// doesn't return an unreasonably large buffer (it has been hacked).
//
// Assumptions:
//    * Multi-SZ strings will have a max of 100 strings (should be on order of 10 or less)
//    * Each string will be <= MAX_INF_STRING
//    * Don't bother accounting for NULLs (that will be swampped by overestimate on number of strings)
//
#define MAX_INF_STRING_LEN			512	// From DDK docs "General Syntax Rules for INF Files" section
#define MAX_SETUP_MULTI_SZ_SIZE		(MAX_INF_STRING_LEN * 100 * sizeof(TCHAR))
#define MAX_SETUP_MULTI_SZ_SIZE_W	(MAX_INF_STRING_LEN * 100 * sizeof(WCHAR))	// For explicit WCHAR version

//
// the following are the customized error HRESULT
//
// IU selfupdate error codes
#define IU_SELFUPDATE_NONEREQUIRED      _HRESULT_TYPEDEF_(0x00040000L)
#define IU_SELFUPDATE_USECURRENTDLL     _HRESULT_TYPEDEF_(0x00040001L)
#define IU_SELFUPDATE_USENEWDLL         _HRESULT_TYPEDEF_(0x00040002L)
#define IU_SELFUPDATE_TIMEOUT           _HRESULT_TYPEDEF_(0x80040010L)
#define IU_SELFUPDATE_FAILED            _HRESULT_TYPEDEF_(0x8004FFFFL)
// UrlAgent error codes
#define ERROR_IU_QUERYSERVER_NOT_FOUND			_HRESULT_TYPEDEF_(0x80040012L)
#define ERROR_IU_SELFUPDSERVER_NOT_FOUND		_HRESULT_TYPEDEF_(0x80040022L)

#define ARRAYSIZE(a)					(sizeof(a)/sizeof(a[0]))
#define SafeCloseInvalidHandle(h)		if (INVALID_HANDLE_VALUE != h) { CloseHandle(h); h = INVALID_HANDLE_VALUE; }
//
// Replace with SafeReleaseNULL in safefunc.h
//
// #define SafeRelease(p)					if (NULL != p) { (p)->Release(); p = NULL; }
#define SafeHeapFree(p)					if (NULL != p) { HeapFree(GetProcessHeap(), 0, p); p = NULL; }
//
// NOTE: SysFreeString() takes NULLs (just returns) so we don't have to check for NULL != p
//
#define SafeSysFreeString(p)			{SysFreeString(p); p = NULL;}

//
// Use this if the function being called does logging
//
#define CleanUpIfFailedAndSetHr(x)		{hr = x; if (FAILED(hr)) goto CleanUp;}

//
// Use this if function being called does *not* do logging
//
#define CleanUpIfFailedAndSetHrMsg(x)	{hr = x; if (FAILED(hr)) {LOG_ErrorMsg(hr); goto CleanUp;}}

//
// Use this if function being called does *not* do logging
//
#define CleanUpIfFalseAndSetHrMsg(b,x)	{if (b) {hr = x; LOG_ErrorMsg(hr); goto CleanUp;}}

//
// Use this to log Win32 errors returned from call
//
#define Win32MsgSetHrGotoCleanup(x)		{LOG_ErrorMsg(x); hr = HRESULT_FROM_WIN32(x); goto CleanUp;}

//
// Set hr = x and goto Cleanup (when you need to check HR before going to cleanup)
//
#define SetHrAndGotoCleanUp(x)				{hr = x; goto CleanUp;}

//
// Use this to log an hr msg and goto CleanUp (don't reassign hr like Failed variation)
//
#define SetHrMsgAndGotoCleanUp(x)			{hr = x; LOG_ErrorMsg(hr); goto CleanUp;}

//
// Use this to log HeapAlloc failures only using a single const string
//
#define CleanUpFailedAllocSetHrMsg(x)	{if (NULL == (x)) {hr = E_OUTOFMEMORY; LOG_ErrorMsg(hr); goto CleanUp;}}

//
// Same as CleanUpIfFailedAndSetHrMsg(), but no set hr, instead, pass in hr
//
#define CleanUpIfFailedAndMsg(hr)		{if (FAILED(hr)) {LOG_ErrorMsg(hr); goto CleanUp;}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\loadengine.h ===
#ifndef __LOADENGINE_H_
#define __LOADENGINE_H_

/////////////////////////////////////////////////////////////////////////////
// LoadIUEngine()
//
// load the engine if it's not up-to-date; perform engine's self-update here
/////////////////////////////////////////////////////////////////////////////
HMODULE WINAPI LoadIUEngine(BOOL fSynch, BOOL fOfflineMode);


/////////////////////////////////////////////////////////////////////////////
// UnLoadIUEngine()
//
// release the engine dll if ref cnt of engine is down to zero
/////////////////////////////////////////////////////////////////////////////
void WINAPI UnLoadIUEngine(HMODULE hEngineModule);


/////////////////////////////////////////////////////////////////////////////
// CtlCancelEngineLoad()
//
// Asynchronous Callers can use this abort the LoadEngine SelfUpdate Process
//
// NOTE: CDM.DLL assumes UnLoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CtlCancelEngineLoad();

//
// Typedefs
//
typedef HMODULE (WINAPI * PFN_LoadIUEngine)(BOOL fSynch, BOOL fOfflineMode);

typedef void (WINAPI * PFN_UnLoadIUEngine)(HMODULE hEngineModule);

typedef HRESULT (WINAPI * PFN_CtlCancelEngineLoad)();

#endif //__LOADENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\iuprogress.h ===
//
// include IProgressListener interface
//
#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_
MIDL_DEFINE_GUID(IID, IID_IProgressListener,0x229F78AE,0x6618,0x4DF3,0x95,0xD2,0xFC,0x26,0xC9,0xF9,0x74,0x28);

#ifndef __IProgressListener_INTERFACE_DEFINED__
#define __IProgressListener_INTERFACE_DEFINED__

/* interface IProgressListener */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProgressListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("229F78AE-6618-4DF3-95D2-FC26C9F97428")
    IProgressListener : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnItemStart( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItem,
            /* [out] */ LONG *plCommandRequest) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ VARIANT_BOOL fItemCompleted,
            /* [in] */ BSTR bstrProgress,
            /* [out] */ LONG *plCommandRequest) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnOperationComplete( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProgressListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProgressListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProgressListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProgressListener * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnItemStart )( 
            IProgressListener * This,
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItem,
            /* [out] */ LONG *plCommandRequest);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IProgressListener * This,
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ VARIANT_BOOL fItemCompleted,
            /* [in] */ BSTR bstrProgress,
            /* [out] */ LONG *plCommandRequest);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnOperationComplete )( 
            IProgressListener * This,
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems);
        
        END_INTERFACE
    } IProgressListenerVtbl;

    interface IProgressListener
    {
        CONST_VTBL struct IProgressListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgressListener_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProgressListener_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProgressListener_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProgressListener_OnItemStart(This,bstrUuidOperation,bstrXmlItem,plCommandRequest)	\
    (This)->lpVtbl -> OnItemStart(This,bstrUuidOperation,bstrXmlItem,plCommandRequest)

#define IProgressListener_OnProgress(This,bstrUuidOperation,fItemCompleted,bstrProgress,plCommandRequest)	\
    (This)->lpVtbl -> OnProgress(This,bstrUuidOperation,fItemCompleted,bstrProgress,plCommandRequest)

#define IProgressListener_OnOperationComplete(This,bstrUuidOperation,bstrXmlItems)	\
    (This)->lpVtbl -> OnOperationComplete(This,bstrUuidOperation,bstrXmlItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IProgressListener_OnItemStart_Proxy( 
    IProgressListener * This,
    /* [in] */ BSTR bstrUuidOperation,
    /* [in] */ BSTR bstrXmlItem,
    /* [out] */ LONG *plCommandRequest);


void __RPC_STUB IProgressListener_OnItemStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IProgressListener_OnProgress_Proxy( 
    IProgressListener * This,
    /* [in] */ BSTR bstrUuidOperation,
    /* [in] */ VARIANT_BOOL fItemCompleted,
    /* [in] */ BSTR bstrProgress,
    /* [out] */ LONG *plCommandRequest);


void __RPC_STUB IProgressListener_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IProgressListener_OnOperationComplete_Proxy( 
    IProgressListener * This,
    /* [in] */ BSTR bstrUuidOperation,
    /* [in] */ BSTR bstrXmlItems);


void __RPC_STUB IProgressListener_OnOperationComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProgressListener_INTERFACE_DEFINED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\iu.h ===
// base IU header

#ifndef __IU_H_
#define __IU_H_

#include <setupapi.h>
#include <advpub.h>
#include <windows.h>
#include <wtypes.h>
#include <urllogging.h>
//
// cdm.h is checked in as //depot/Lab04_N/enduser/published/inc/cdm.w and
// published to $(BASEDIR)\public\internal\enduser\inc
//
#include <cdm.h>

/////////////////////////////////////////////////////////////////////////////
// Engine typedefs
// 
// used to delegate calls to engine (IUEngine.dll) from stub (IUCtl.dll)
// and used to support other WU clients (AU/DU)
/////////////////////////////////////////////////////////////////////////////

//
// Declare a type-safe handle to use with iuengine exports
//
DECLARE_HANDLE            (HIUENGINE);

typedef HRESULT (WINAPI * PFN_GetSystemSpec)(HIUENGINE hIUEngine,
											 BSTR		bstrXmlClasses,
                                             DWORD      dwFlags,
											 BSTR*		pbstrXmlDetectionResult);

typedef HRESULT (WINAPI * PFN_GetManifest)	(HIUENGINE hIUEngine,
											 BSTR			bstrXmlClientInfo,
											 BSTR			bstrXmlSystemSpec,
											 BSTR			bstrXmlQuery,
											 DWORD			dwFlags,
											 BSTR*			pbstrXmlCatalog);

typedef HRESULT (WINAPI * PFN_Detect)		(HIUENGINE hIUEngine,
											 BSTR		bstrXmlCatalog,
                                             DWORD      dwFlags,
											 BSTR*		pbstrXmlItems);

typedef HRESULT (WINAPI * PFN_Download)		(HIUENGINE hIUEngine,
											 BSTR		bstrXmlClientInfo,
											 BSTR		bstrXmlCatalog, 
											 BSTR		bstrDestinationFolder,
											 LONG		lMode,
											 IUnknown*	punkProgressListener,
											 HWND		hWnd,
											 BSTR*		pbstrXmlItems);

typedef HRESULT (WINAPI * PFN_DownloadAsync)(HIUENGINE hIUEngine,
											 BSTR		bstrXmlClientInfo,
											 BSTR		bstrXmlCatalog, 
											 BSTR		bstrDestinationFolder,
											 LONG		lMode,
											 IUnknown*	punkProgressListener, 
											 HWND		hWnd,
											 BSTR		bstrUuidOperation,
											 BSTR*		pbstrUuidOperation);

typedef HRESULT (WINAPI * PFN_Install)		(HIUENGINE hIUEngine,
											 BSTR       bstrXmlClientInfo,
                                             BSTR		bstrXmlCatalog, 
											 BSTR		bstrXmlDownloadedItems,
											 LONG		lMode,
											 IUnknown*	punkProgressListener, 
											 HWND		hWnd,
											 BSTR*		pbstrXmlItems);

typedef HRESULT (WINAPI * PFN_InstallAsync)	(HIUENGINE hIUEngine,
											 BSTR       bstrXmlClientInfo,
                                             BSTR		bstrXmlCatalog,
											 BSTR		bstrXmlDownloadedItems,
											 LONG		lMode,
											 IUnknown*	punkProgressListener, 
											 HWND		hWnd,
											 BSTR		bstrUuidOperation,
											 BSTR*		pbstrUuidOperation);

typedef HRESULT (WINAPI * PFN_SetOperationMode)(HIUENGINE hIUEngine,
												BSTR		bstrUuidOperation,
												LONG		lMode);

typedef HRESULT (WINAPI * PFN_GetOperationMode)(HIUENGINE hIUEngine,
												BSTR		bstrUuidOperation,
												LONG*		plMode);

typedef HRESULT (WINAPI * PFN_GetHistory)(HIUENGINE hIUEngine,
										  BSTR		bstrDateTimeFrom,
										  BSTR		bstrDateTimeTo,
										  BSTR		bstrClient,
										  BSTR		bstrPath,
										  BSTR*		pbstrLog);

typedef HRESULT (WINAPI * PFN_BrowseForFolder)(	HIUENGINE hIUEngine,
												BSTR bstrStartFolder, 
												LONG flag, 
												BSTR* pbstrFolder);

typedef HRESULT (WINAPI * PFN_RebootMachine)(HIUENGINE hIUEngine);

typedef void (WINAPI * PFN_ShutdownThreads) (void);

typedef void (WINAPI * PFN_ShutdownGlobalThreads) (void);

typedef HRESULT (WINAPI * PFN_CompleteSelfUpdateProcess)();

typedef HIUENGINE (WINAPI * PFN_CreateEngUpdateInstance)();

typedef void (WINAPI * PFN_DeleteEngUpdateInstance)(HIUENGINE hIUEngine);

typedef HRESULT (WINAPI * PFN_PingIUEngineUpdateStatus)(
											PHANDLE phQuitEvents,			// ptr to handles for cancelling the operation
											UINT nQuitEventCount,			// number of handles
											LPCTSTR ptszLiveServerUrl,
											LPCTSTR ptszCorpServerUrl,
											DWORD dwError,					// error code
											LPCTSTR ptszClientName);			// client name string

/////////////////////////////////////////////////////////////////////////////
//
// CDM typedefs
//
// used to delegate calls to engine (IUEngine.dll) from stub ([IU]cdm.dll)
/////////////////////////////////////////////////////////////////////////////

// DetFilesDownloaded
typedef void (WINAPI * PFN_InternalDetFilesDownloaded)(
    IN  HANDLE hConnection 
    );

// DownloadGetUpdatedFiles
typedef BOOL (WINAPI * PFN_InternalDownloadGetUpdatedFiles)(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
	);

// DownloadUpdatedFiles
typedef BOOL (WINAPI * PFN_InternalDownloadUpdatedFiles)(
    IN HANDLE hConnection,
    IN HWND hwnd,
    IN PDOWNLOADINFO pDownloadInfo,
    OUT LPWSTR lpDownloadPath,
    IN UINT uSize,
    OUT PUINT puRequiredSize
    );

// FindMatchingDriver
typedef BOOL (WINAPI * PFN_InternalFindMatchingDriver)(
    IN  HANDLE hConnection,
	IN  PDOWNLOADINFO pDownloadInfo,
	OUT PWUDRIVERINFO pWuDriverInfo
    );

// LogDriverNotFound
typedef void (WINAPI * PFN_InternalLogDriverNotFound)(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
    );

// QueryDetectionFiles
typedef int (WINAPI * PFN_InternalQueryDetectionFiles)(
    IN  HANDLE hConnection, 
	IN	void* pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
    );

// InternalSetGlobalOfflineFlag
typedef void (WINAPI * PFN_InternalSetGlobalOfflineFlag)(
    IN  BOOL fOfflineMode 
    );

/////////////////////////////////////////////////////////////////////////////
//
// Misc. typedefs
//
/////////////////////////////////////////////////////////////////////////////

// DeleteExpiredDownloadFolders
typedef void (WINAPI * PFN_AsyncExtraWorkUponEngineLoad)();


/////////////////////////////////////////////////////////////////////////////
// custom message ID defintions
/////////////////////////////////////////////////////////////////////////////
#define UM_EVENT_ITEMSTART				WM_USER + 1001
#define UM_EVENT_PROGRESS				WM_USER + 1002
#define UM_EVENT_COMPLETE				WM_USER + 1003
#define UM_EVENT_SELFUPDATE_COMPLETE	WM_USER + 1004

/////////////////////////////////////////////////////////////////////////////
// event data structure definition
/////////////////////////////////////////////////////////////////////////////
typedef struct _EventData
{
	BSTR			bstrUuidOperation;
	VARIANT_BOOL	fItemCompleted;
	BSTR			bstrProgress;
	LONG			lCommandRequest;
	BSTR			bstrXmlData;
	HANDLE          hevDoneWithMessage;
} EventData, *pEventData;

BOOL WUPostEventAndBlock(HWND hwnd, UINT Msg, EventData *pevtData);


#endif //__IU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\fileutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   fileutil.h
//
//  Description:
//
//      IU file utility library
//
//=======================================================================

#ifndef __FILEUTIL_INC
#define __FILEUTIL_INC


// ----------------------------------------------------------------------
//
// define constant chars often used in file path processing
//
// ----------------------------------------------------------------------
#ifndef TCHAR_EOS
#define TCHAR_EOS       _T('\0')
#endif
#ifndef TCHAR_STAR
#define TCHAR_STAR      _T('*')
#endif
#ifndef TCHAR_BACKSLASH
#define TCHAR_BACKSLASH _T('\\')
#endif
#ifndef TCHAR_FWDSLASH
#define TCHAR_FWDSLASH  _T('/')
#endif
#ifndef TCHAR_COLON
#define TCHAR_COLON     _T(':')
#endif
#ifndef TCHAR_DOT
#define TCHAR_DOT       _T('.')
#endif
#ifndef TCHAR_SPACE
#define TCHAR_SPACE     _T(' ')
#endif
#ifndef TCHAR_TAB
#define TCHAR_TAB       _T('\t')
#endif




// ----------------------------------------------------------------------
//
// define constants used by path related operations.
// these constants can be found either from CRT or Shlwapi header
// files.
//
// ----------------------------------------------------------------------

#ifdef _MAX_PATH
#undef _MAX_PATH
#endif
#define _MAX_PATH		MAX_PATH

#ifdef _MAX_DRIVE
#undef _MAX_DRIVE
#endif
#define _MAX_DRIVE		3		// buffer size to take drive letter & ":"

#ifdef _MAX_DIR
#undef _MAX_DIR
#endif
#define _MAX_DIR		256		// max. length of path component

#ifdef _MAX_FNAME
#undef _MAX_FNAME
#endif
#define _MAX_FNAME		256		// max. length of file name component

#ifdef _MAX_EXT
#undef _MAX_EXT
#endif
#define _MAX_EXT		256		// max. length of extension component

#define	ARRAYSIZE(x)			(sizeof(x)/sizeof(x[0]))

//Error code for files which are not valid binaries or which do not support the machine architecture
#define BIN_E_MACHINE_MISMATCH HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH)
#define BIN_E_BAD_FORMAT  HRESULT_FROM_WIN32(ERROR_BAD_FORMAT)

// ----------------------------------------------------------------------
//
// Public function MySplitPath() - same as CRT _tsplitpath()
//		to break a path into pieces
//
//	Input: 
//		see below
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
void MySplitPath(
	LPCTSTR lpcszPath,	// original path
	LPTSTR lpszDrive,	// point to buffer to receive drive letter
	LPTSTR lpszDir,		// point to buffer to receive directory
	LPTSTR lpszFName,	// point to buffer to receive file name
	LPTSTR lpszExt		// point to buffer to receive extension
);
			

//---------------------------------------------------------------------
//  CreateNestedDirectory
//      Creates the full path of the directory (nested directories)
//---------------------------------------------------------------------
BOOL CreateNestedDirectory(LPCTSTR pszDir);


//-----------------------------------------------------------------------------------
//  GetIndustryUpdateDirectory
//		This function returns the location of the IndustryUpdate directory. All local
//		files are stored in this directory. The pszPath parameter needs to be at least
//		MAX_PATH.  
//-----------------------------------------------------------------------------------
void GetIndustryUpdateDirectory(LPTSTR pszPath);

//-----------------------------------------------------------------------------------
//  GetWindowsUpdateV3Directory - used for V3 history migration
//		This function returns the location of the WindowsUpdate(V3) directory. All V3 
//      local files are stored in this directory. The pszPath parameter needs to be 
//      at least MAX_PATH.  The directory is created if not found
//-----------------------------------------------------------------------------------
void GetWindowsUpdateV3Directory(LPTSTR pszPath);

// **********************************************************************************
// 
// File version related declarations
//
// **********************************************************************************


// ----------------------------------------------------------------------------------
// 
// define a type to hold file version data
//
// ----------------------------------------------------------------------------------
typedef struct _FILE_VERSION
{
	WORD Major;
	WORD Minor;
	WORD Build;
	WORD Ext;
} FILE_VERSION, *LPFILE_VERSION;


// ----------------------------------------------------------------------------------
//
// public function to retrieve file version
//
// ----------------------------------------------------------------------------------
BOOL GetFileVersion(LPCTSTR lpsFile, LPFILE_VERSION lpstVersion);




// ----------------------------------------------------------------------------------
//
// publif function to retrieve the creation time of a file in ISO 8601 format
//	without zone info
//
//	if buffer too small, call GetLastError();
//
// ----------------------------------------------------------------------------------
BOOL GetFileTimeStamp(
					  LPCTSTR lpsFile,		// file path
					  LPTSTR lpsTimeStamp,	// buffer to receive timestamp
					  int iBufSize			// buffer size in characters
					  );


// ----------------------------------------------------------------------------------
//
// public functions to compare file versions
//	
// return:
//		-1: if file ver of 1st parameter < file ver of 2nd parameter
//		 0: if file ver of 1st parameter = file ver of 2nd parameter
//		+1: if file ver of 1st parameter > file ver of 2nd parameter
//
// ----------------------------------------------------------------------------------
HRESULT CompareFileVersion(LPCTSTR lpsFile1, LPCTSTR lpsFile2, int *pCompareResult);
HRESULT CompareFileVersion(LPCTSTR lpsFile, FILE_VERSION stVersion, int *pCompareResult);
int CompareFileVersion(const FILE_VERSION stVersion1, const FILE_VERSION stVersion2);


// ----------------------------------------------------------------------------------
//
// public function to convert a string type functoin to FILE_VERSION type
//
// ----------------------------------------------------------------------------------
BOOL ConvertStringVerToFileVer(LPCSTR lpsVer, LPFILE_VERSION lpstVer);


// ----------------------------------------------------------------------------------
//
// publif function to convert a FILE_VERSION to a string
//
// ----------------------------------------------------------------------------------
BOOL ConvertFileVerToStringVer(
	FILE_VERSION stVer,				// version to convert
	char chDel,						// delimiter to use
	LPSTR lpsBuffer,				// buffer of string
	int ccBufSize					// size of buffer
);




// **********************************************************************************
//
// detection related, in addition to file version group
//
// **********************************************************************************

// ----------------------------------------------------------------------------------
//
// public function to check if a file exists
//
// ----------------------------------------------------------------------------------
BOOL FileExists(
	LPCTSTR lpsFile		// file with path to check
);




// ----------------------------------------------------------------------------------
//
// public function to expand the file path
//
//	Assumption: lpszFilePath points to allocated buffer of MAX_PATH.
//	if the expanded path is longer than MAX_PATH, error returned.
//
// ----------------------------------------------------------------------------------
HRESULT ExpandFilePath(
	LPCTSTR lpszFilePath,		// original string
	LPTSTR lpszDestination,		// buffer for expanded string
	UINT cChars					// number of chars that buffer can take
);



// ----------------------------------------------------------------------------------
//
// public function to find the free disk space in KB
//
// ----------------------------------------------------------------------------------
HRESULT GetFreeDiskSpace(
	TCHAR tcDriveLetter,	// drive letter
	int *piKBytes			// out result in KB if successful, 0 if fail
);

HRESULT GetFreeDiskSpace(
    LPCTSTR pszUNC,         // UNC Path
    int *piKBytes           // out result in KB if successful, 0 if fail
);



//----------------------------------------------------------------------
//
// function to validate the folder to make sure
// user has required priviledge
//
// folder will be verified exist. then required priviledge will be checked.
//
// ASSUMPTION: lpszFolder not exceeding MAX_PATH long!!!
//
//----------------------------------------------------------------------
DWORD ValidateFolder(LPTSTR lpszFolder, BOOL fCheckForWrite);


//----------------------------------------------------------------------
//
// function to get a QueryServer from the Ident File for a Given ClientName
// This also looks in the registry for the IsBeta regkey indicating Beta
// functionlality
//
//----------------------------------------------------------------------
HRESULT GetClientQueryServer(LPCTSTR pszClientName, // Client Name to get QueryServer for
                             LPTSTR pszQueryServer, // Buffer for Query Server Return
                             UINT cChars);          // Length of Buffer in Chars

//----------------------------------------------------------------------
//
// function to walk a directory and extract all cabinet files
//
//----------------------------------------------------------------------
HRESULT DecompressFolderCabs(LPCTSTR pszDecompressPath);

//----------------------------------------------------------------------
//
// wrapper function for AdvPack ExtractFiles API (forces conversion to ANSI);
//
//----------------------------------------------------------------------
BOOL IUExtractFiles(LPCTSTR pszCabFile, LPCTSTR pszDecompressFolder, LPCTSTR pszFileNames = NULL);

//Replace the file extension with a new extension
BOOL ReplaceFileExtension( LPCTSTR pszPath, LPCTSTR pszNewExt, LPTSTR pszNewPathBuf, DWORD cchNewPathBuf);
// ReplaceFileInPath
BOOL ReplaceFileInPath( LPCTSTR pszPath, LPCTSTR pszNewFile, LPTSTR pszNewPathBuf, DWORD cchNewPathBuf);

//Function to verify that the specified file is a binary
//and that it is compatible with the OS architecture
HRESULT IsBinaryCompatible(LPCTSTR lpszFile);


// file exists routine
inline BOOL fFileExists(LPCTSTR lpszFileName, BOOL *pfIsDir = NULL)
{
	DWORD dwAttribute = GetFileAttributes(lpszFileName); //GetFileAttributes do not like "\" at the end of direcotry
	if (INVALID_FILE_ATTRIBUTES != dwAttribute)
	{
		if (NULL != pfIsDir)
		{
			*pfIsDir = (FILE_ATTRIBUTE_DIRECTORY & dwAttribute);
		}
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


//Get the path to the WindowsUpdate Directory (without the backslash at the end)
BOOL GetWUDirectory(LPTSTR lpszDirPath, DWORD chCount, BOOL fGetV4Path = FALSE);


/*****************************************************************************
//Function to set ACL's on Windows Update directories, optionally creates the 
//directory if it doesnt already exists
//This function will:
// * Take ownership of the directory and it's children
// * Set all the children to inherit ACL's from parent
// * Set the specified directory to NOT inherit properties from it's parent
// * Set the required ACL's on the specified directory
// * Replace the ACL's on the children (i.e. propogate own ACL's and remove 
//   those ACL's which were explicitly set 
//
//	Input: 
//		lpszDirectory: Path to the directory to ACL, If it is NULL we use the
                       path to the WindowsUpdate directory
        fCreateAlways: Flag to indicate creation of new directory if it doesnt
                       already exist
******************************************************************************/
HRESULT CreateDirectoryAndSetACLs(LPCTSTR lpszDirectory, BOOL fCreateAlways);



// ----------------------------------------------------------------------------------
//
// File CRC API and Structure Definitions
// Note: This logic is taken from the Windows Update V3 Implemention of File CRC's.
// We use the CryptCATAdminCalcHashFromFileHandle API to calculate a CRC of the file
// and compare it to the passed in CRC_HASH.
//
// ----------------------------------------------------------------------------------

// size of the CRC hash in bytes
const int CRC_HASH_SIZE = 20;
const int CRC_HASH_STRING_LENGTH = CRC_HASH_SIZE * 2 + 1; // Double the CRC HASH SIZE (2 characters for each byte), + 1 for the NULL

// ----------------------------------------------------------------------------------
// 
// VerifyFileCRC : This function takes a File Path, calculates the hash on this file
// and compares it to the passed in Hash (pCRC).
// Returns:
// S_OK: CRC's Match
// ERROR_CRC (HRESULT_FROM_WIN32(ERROR_CRC): if the CRC's do not match
// Otherwise an HRESULT Error Code
//
// ----------------------------------------------------------------------------------
HRESULT VerifyFileCRC(LPCTSTR pszFileToVerify, LPCTSTR pszHash);

// ----------------------------------------------------------------------------------
// 
// CalculateFileCRC : This function takes a File Path, calculates a CRC from the file
// and returns it in passed in CRC_HASH pointer.
//
// ----------------------------------------------------------------------------------
HRESULT CalculateFileCRC(LPCTSTR pszFileToHash, LPTSTR pszHash, int cchBuf);

#endif	//__FILEUTIL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\download.h ===
#ifndef DOWNLOAD_H
#define DOWNLOAD_H

#include <iuprogress.h>

#define DOWNLOAD_STATUS_OK                0
#define DOWNLOAD_STATUS_ITEMCOMPLETE      1
#define DOWNLOAD_STATUS_ERROR             2
#define DOWNLOAD_STATUS_ABORTED           3
#define DOWNLOAD_STATUS_OPERATIONCOMPLETE 4
#define DOWNLOAD_STATUS_ITEMSTART         5

//---------------------------------------------------------------------------
// 
//  type definition for the parameters needed by callback function
//
class COperationMgr;
typedef struct _DOWNLOAD_CALLBACK_DATA
{
    BSTR                bstrOperationUuid;
    HWND                hEventFiringWnd;
    IProgressListener*  pProgressListener;
    float               flProgressPercentage; // Minimum Percentage Increment for Progress 0 == all progress
    float               flLastPercentage; // percentage value of the last progress callback
    LONG                lTotalDownloadSize; // estimated total download size
    LONG                lCurrentItemSize; // estimated current item size
    LONG                lTotalDownloaded; // total bytes downloaded so far
    COperationMgr*      pOperationMgr;
} DCB_DATA, *P_DCB_DATA;


//---------------------------------------------------------------------------
// 
//  type definition for the  callback function
//
typedef BOOL (WINAPI * PFNDownloadCallback)(
                VOID*       pCallbackData,
                DWORD       dwStatus, 
                DWORD       dwBytesTotal, 
                DWORD       dwBlockSizeDownloaded,  // Bytes Downloaded Since Last Callback.
                BSTR        bstrXmlData,            // XML in bstr, used by itemstart/complete, otherwise NULL
                LONG        *lCommandRequest        // return what callback function want to do:
                                                    // PAUSE (1) or CANCEL (3)
                );

//---------------------------------------------------------------------------
//
// DownloadFile
//   Implements the core downloader for IU. This is a single purpose downloader that is very generic,
//   It does not attempt to decompress or checktrust anything it downloads.
//
//   Progress Information is given for each block downloaded through the supplied callback function.
//       Specifying a callback is optional. All callbacks are 'synchronous' and if not immediately 
//       returned will block all downloads in this object.

#define WUDF_DONTALLOWPROXY      0x00000001
#define WUDF_CHECKREQSTATUSONLY  0x00000002
#define WUDF_APPENDCACHEBREAKER  0x00000004
#define WUDF_DODOWNLOADRETRY     0x00000008
#define WUDF_SKIPCABVALIDATION   0x00000010
#define WUDF_SKIPAUTOPROXYCACHE  0x00000020
#define WUDF_PERSISTTRANSPORTDLL 0x00000040

#define WUDF_ALLOWWININETONLY    0x40000000
#define WUDF_ALLOWWINHTTPONLY    0x80000000
#define WUDF_TRANSPORTMASK       (WUDF_ALLOWWINHTTPONLY | WUDF_ALLOWWININETONLY)

HRESULT DownloadFile(
            LPCTSTR pszServerUrl,               // full http url
            LPCTSTR pszLocalPath,               // local directory to download file to
            LPCTSTR pszLocalFileName,           // optional local file name to rename the downloaded file to
            PDWORD  pdwDownloadedBytes,         // bytes downloaded for this file
            HANDLE  *hQuitEvents,               // optional events causing this function to abort
            UINT    nQuitEventCount,            // number of quit events, must be 0 if array is NULL
            PFNDownloadCallback fpnCallback,    // optional call back function
            VOID*   pCallbackData,              // parameter for call back function to use
            DWORD   dwFlags = 0
);


#include "dllite.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\mistsafe.h ===
//=======================================================================
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:    MISTSafe.h
//
//  Creator: PeterWi
//
//  Purpose: Definitions related to safe functions.
//
//=======================================================================

#pragma once
#define STRSAFE_NO_DEPRECATE

#include <strsafe.h>

// Flag you should add to your String* functions to safe fill behind
// the complete buffer in chk builds to help locate buffer problems.
// e.g. StringCchCopyEx(szDest, cchDest, szSrc, &pszDestEnd, &cchRemaining, MISTSAFE_STRING_FLAGS);

#ifdef DBG
#define MISTSAFE_STRING_FLAGS   STRSAFE_FILL_BEHIND_NULL
#else
#define MISTSAFE_STRING_FLAGS   STRSAFE_IGNORE_NULLS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\logging.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   IULogger.h: interface for the CIULogger class.
//
//  Description:
//
//      CIULogger is a class that output the program logs to 
//		a text file, in order to help debugging the program.
//
//		Programs wish to have this logging function should NOT use
//		class directly. They should only use the macro defined
//		at the end of this file.
//
//=======================================================================



#ifndef _IULOGGER_H_INCLUDED_

#include <wtypes.h>
#include <FreeLog.h>

extern const LPCTSTR pszHeapAllocFailed;

#if defined(DBG)	// full logging for checked builds

//
// Common format strings
//

class CIULogger  
{
public:
	CIULogger(char* szBlockName);
	~CIULogger();


	//
	// log with no flag, so can not be removed by excluding directives
	//
	void Log(LPCTSTR szLogFormat, ...);

	//
	// log error, can not be removed by excluding directives
	// Key word "Error: " is inserted before the log msg
	//
	void LogError(LPCTSTR szLogFormat, ...);

	//
	// similar to LogError, but try to log the system msg based
	// on the error code. If the sysmsg not avail, log 
	//	"Unknown error with error code 0x%08x"
	//
	void LogErrorMsg(DWORD dwErrCode);

	//
	// similar to LogErrorMsg but prepends with "Info" rather than "Error"
	//
	void LogInfoMsg(DWORD dwErrCode);

	//
	// log with type INTERNET, this function will do nothing
	// if the Internet exclusion directive is detected from reg
	//
	void LogInternet(LPCTSTR szLogFormat, ...);

	//
	// log with type XML, this function will do nothing
	// if the XML exclusion directive is detected from reg
	//
	void LogXML(LPCTSTR szLogFormat, ...);

	//
	// log BSTR containing valid XML. This gets around length limitations
	// of LogOutput and attempts to break lines following ">". This
	// output is sent for both fre and chk builds unless excluded from reg.
	//
	void LogXmlBSTR(BSTR bstrXML);

	//
	// log with type SOFTWARE, this function will do nothing
	// if the SOFTWARE exclusion directive is detected from reg
	//
	void LogSoftware(LPCTSTR szLogFormat, ...);

	//
	// log with type DRIVER, this function will do nothing
	// if the DRIVER exclusion directive is detected from reg
	//
	void LogDriver(LPCTSTR szLogFormat, ...);

	//
	// log with type CHECKTRUST, this function will do nothing
	// if the CHECKTRUST exclusion directive is detected from reg
	//
	void LogTrust(LPCTSTR szLogFormat, ...);

	//
	// log with type DOWNLOAD, this function will do nothing
	// if the DOWNLOAD exclusion directive is detected from reg
	//
	void LogDownload(LPCTSTR szLogFormat, ...);


	int m_LineNum;
private:

	//
	// Helper for LogErrorMsg and LogInfoMsg (which supply message to prepend)
	//
	void _LogFormattedMsg(DWORD dwErrCode, LPCTSTR pszErrorInfo);

	//
	// Overwrite <CR> and <LF> with space
	//
	void _NukeCrLf(LPTSTR pszBuffer);

	//
	// actual base logging function, returns
	// if it actually logged, or just returned
	// because directives say don't make this kind of log
	//
	void _Log(DWORD LogType, LPCTSTR pszLogFormat, va_list va);

	//
	// function to write the log to log file
	//
	void _LogOut(LPTSTR pszLog);

	//
	// functions go guard writing to file
	//
	BOOL AcquireMutex();
	void ReleaseMutex();

	//
	// structure used to remember indent steps per thread
	//
	struct _THREAD_INDENT 
	{
		DWORD	dwThreadId;
		int		iIndent;
	};

	//
	// static integer to remember the log indent steps
	//
	static _THREAD_INDENT* m_psIndent;

	//
	// size of array pointed by m_psIndent
	//
	static int m_Size;

	//
	// static handle for log file
	//
	static HANDLE m_shFile;

	//
	// bitmap for logging type
	//
	static DWORD m_sdwLogMask;
	
	//
	// indent per step
	//	
	//	1~8 - number of spaces
	//	other - one tab
	//
	static int m_siIndentStep;

	//
	// function to retrieve the indent of current thread
	//
	inline int GetIndent(void);

	//
	// function to change indention of current thread
	//
	void SetIndent(int IndentDelta);


	//
	// index of indent array
	//
	int m_Index;

	//
	// controlling vars
	//
	static bool m_fLogUsable;
	static bool m_fLogFile;
	static bool m_fLogDebugMsg;
	static HANDLE m_hMutex;
	static int m_cFailedWaits;

	//
	// current block name
	//
	char m_szBlockName[MAX_PATH];
	
	// 
	// if this log object is for whole process. If yes,
	// no indention will be handled.
	//
	bool m_fProcessLog;

	//
	// var to remember time elapsed
	//
	DWORD m_dwTickBegin;

	//
	// disable the default constructor
	//
	CIULogger() {};

	//
	// timestamp helper
	//
	void GetLogHeader(LPTSTR pszBuffer, DWORD cchBufferLen);

	//
	// read registry value helper
	//
	void ReadRegistrySettings(void);

	//
	// remember thread id of itself
	//
	DWORD m_dwThreadId;

	//
	// flush every time?
	// added by charlma 11/27/01
	// if this flag is set, then flush everytime. otherwise, don't flush in order
	// to improve logging performance.
	//
	static BOOL m_fFlushEveryTime;
};



//=======================================================================
//
//	Define the macros that should be used in the programs to utilize
//	the CIULogger class.
//
//	Note: each of the following macro will practically doing nothing
//	if the registry of supporting this logging feature does not exist
//	or values not appropriately set.
//
//=======================================================================


//
// LOG_Process, is the one you can use in global namespace. 
// The purpose of this macro is to pump up ref count of log file use so
// during the whole process this log file will keep open, therefore
// the actual logging to file feature will have minimum performance
// impact on your code.
//
// This macro is mainly designed for the scenario that you can't use LOG_Block
// inside main, such as DLL_ATTACH of DllMain() - without this, each 
// function call to a DLL will cause the log file open/close.
//
#define LOG_Process				CIULogger LogBlock(NULL);

//
// LOG_Block, is the one you should use at the beginning of each
// function or block. It declares an instance of CIULogger, log the
// the entering status, and when control goes out of the scope, the
// exit/end statement is automatically logged
//
#define LOG_Block(name)			CIULogger LogBlock(name);

//
// the following macro will always send log to log file
//
#define LOG_Out					LogBlock.Log

//
// the following macro will always send log to log file, even for Free builds
//	This should be used very sparingly to avoid bloating the DLLs
//
#define LOG_OutFree				LogBlock.Log

//
// the following macro will always send log to log file
// this should be used to log ANY error case
//
#define LOG_Error				LogBlock.m_LineNum = __LINE__; LogBlock.LogError

//
// the follwoing macro will always send log to log file
// prepended with "Error Line..."
// the log is constructed based on passed in error code
// if system msg is not available for this error code,
// a generic error log "Unknown Error 0x%08x" is written.
//
#define LOG_ErrorMsg			LogBlock.m_LineNum = __LINE__; LogBlock.LogErrorMsg

//
// the follwoing macro will always send log to log file
// prepended with "Info Line..."
// the log is constructed based on passed in error code
// if system msg is not available for this error code,
// a generic error log "Unknown Info 0x%08x" is written.
//
#define LOG_InfoMsg				LogBlock.m_LineNum = __LINE__; LogBlock.LogInfoMsg

//
// this is used to log anything related to Internet, such as 
// WinInet info.
//
#define LOG_Internet			LogBlock.LogInternet

//
// this should be used to log anything directly related to XML 
// operation details
//
#define LOG_XML					LogBlock.LogXML

//
// this should be used to log BSTRs containing valid XML 
//
#define LOG_XmlBSTR				LogBlock.LogXmlBSTR

//
// this should be used to log anything related to device drivers
//
#define LOG_Driver				LogBlock.LogDriver

//
// this should be used to log anything related to software, e.g.,
// detection/installation
//
#define LOG_Software			LogBlock.LogSoftware


//
// this should be used to log anything related to check trust
//
#define LOG_Trust				LogBlock.LogTrust


//
// this should be used to log anything related to download processing
//
#define LOG_Download            LogBlock.LogDownload

//
//
//
#else
//
// Remove all debug style logging for release builds
// using the compiler __noop intrinsic
//
#define LOG_Process				__noop
#define LOG_Block				__noop
#define LOG_Error				__noop
#define LOG_ErrorMsg			__noop
#define LOG_InfoMsg				__noop
#define LOG_OutFree				__noop
#define LOG_XmlBSTR				__noop

#define LOG_Out					__noop
#define LOG_Internet			__noop
#define LOG_XML					__noop
#define LOG_Driver				__noop
#define LOG_Software			__noop
#define LOG_Trust				__noop
#define LOG_Download			__noop
#endif // defined(DBG)

//
// explanation of registry settings for log feature
//
// The registry settings control how the logging feature works.
// 
// All log related settings are under key 
//	\\HKLM\Software\Microsoft\Windows\CurrentVersion\WindowsUpdate\IUControlLogging
//
// All values are DWORD except "Logging File"
//
//	Value "Logging File" - specify the absolute file path, e.g., c:\iuctl.log
//			the actual log file name in this case is "c:\iuctl_xxxx.log", 
//			where xxxx is a decimal number represents process id.
//
//	Value "Logging DebugMsg" - indicate if log should be put onto debug window.
//			true if vlaue is 1, false for other values. this output and log file
//			output control by these 2 values independently.
//
//	Value "LogIndentStep" - indicates how many space chars to use for each
//			indent. If 0 or negative value, then tab char is used.
//
//	Value "LogExcludeBlock" - do not output block enter/exit if it's 1
//
//	Value "LogExcludeXML" - do not output logs you logged with LOG_XML if it's 1
//
//	Value "LogExcludeXmlBSTR" - do not output logs you logged with LOG_XmlBSTR if 1
//
//	Value "LogExcludeInternet" - do not output logs you logged with LOG_Internet if 1
//
//	Value "LogExcludeDriver" - do not output logs you logged with LOG_Driver if 1
//
//	Value "LogExcludeSoftware - do not output logs you logged with LOG_Software if 1
//
//	Value "LogExcludeTrust" - do not output logs you logged with LOG_Trust if 1
//

#define _IULOGGER_H_INCLUDED_
#endif // #ifndef _IULOGGER_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\memutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   MemUtil.h
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      IU memory utility library
//
//=======================================================================

#ifndef __MEM_UTIL_HEADER__


#include <ole2.h>

//
// declare a class that handles the heap memory smartly, free itself.
// you should not use this class directly. Use the macros defined
// below this class instead.
//
class CSmartHeapMem
{
public:

	//
	// constructor/destructor
	//
	CSmartHeapMem();
	~CSmartHeapMem();

	LPVOID Alloc(
			size_t nBytes, 
			DWORD dwFlags = HEAP_ZERO_MEMORY
	);


	LPVOID ReAlloc(
			LPVOID lpMem, 
			size_t nBytes, 
			DWORD dwFlags = HEAP_ZERO_MEMORY
	);
	
	size_t Size(
			LPVOID lpMem
	);

	void FreeAllocatedMem(
			LPVOID lpMem
	);

private:
	
	HANDLE	m_Heap;
	LPVOID* m_lppMems;
	size_t	m_ArraySize;
	int		GetUnusedArraySlot();
	inline int FindIndex(LPVOID pMem);
};



// *******************************************************************************
//
//		MACROs to utlize class CSmartHeapMem to provide you a "smart pointer"
//		type of memory management based on Heap memory.
//
//		Restriction: 
//			HEAP_GENERATE_EXCEPTIONS and HEAP_NO_SERIALIZE flags are ignored
//
// *******************************************************************************

//
// similar to ATL USES_CONVERSION, this macro declares
// that within this block you want to use CSmartHeapMem feature
//
#define USES_MY_MEMORY			CSmartHeapMem mem;

//
// allocate a pc of memory, e.g.:
//		LPTSTR t = (LPTSTR) MemAlloc(30*sizeof(TCHAR));
//
#define MemAlloc				mem.Alloc

//
// re-allocate a pc of memory, e.g.:
//		t = (LPTSTR) MemReAlloc(t, MemSize(t) * 2, HEAP_REALLOC_IN_PLACE_ONLY);
//
#define MemReAlloc				mem.ReAlloc

//
// macro to return the memory size allocated:
//		size_t nBytes = MemSize(t);
//
#define MemSize					mem.Size

//
// macro to free a pc of memory allocated by MemAlloc or MemReAlloc, e.g.:
//		MemFree(t);
// You only need to do this when you want to re-use this pointer to 
// call MemAlloc() repeatedly, such as, in a loop. In normal cases, 
// memory allocated by these two macros will be freed automatically
// when control goes out of the current scope.
//
#define MemFree					mem.FreeAllocatedMem


#define SafeMemFree(p) if (NULL != p) { MemFree(p); p = NULL; }



// *******************************************************************************
//
//	Duplicate USES_CONVERSION, but remove dependency on 
//	CRT memory function_alloca()
//
// *******************************************************************************



#define USES_IU_CONVERSION			int _convert = 0; \
									_convert; UINT _acp = CP_ACP; _acp; \
									USES_MY_MEMORY; \
									LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa

//
// NTRAID#NTBUG9-260079-2001/03/08-waltw PREFIX: Dereferencing NULL lpw.
// NTRAID#NTBUG9-260080-2001/03/08-waltw PREFIX: Dereferencing NULL lpw.
//
inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	//
	if (lpw)
	{
		lpw[0] = '\0';
		MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	}
	return lpw;
}

//
// NTRAID#NTBUG9-260083-2001/03/08-waltw PREFIX: Dereferencing NULL lpa.
//
inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	//
	if (lpa)
	{
		lpa[0] = '\0';
		WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	}
	return lpa;
}

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	return AtlA2WHelper(lpw, lpa, nChars, CP_ACP);
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	return AtlW2AHelper(lpa, lpw, nChars, CP_ACP);
}


#ifdef _CONVERSION_USES_THREAD_LOCALE
	#ifdef ATLA2WHELPER
		#undef ATLA2WHELPER
		#undef ATLW2AHELPER
	#endif
	#define ATLA2WHELPER AtlA2WHelper
	#define ATLW2AHELPER AtlW2AHelper
#else
	#ifndef ATLA2WHELPER
		#define ATLA2WHELPER AtlA2WHelper
		#define ATLW2AHELPER AtlW2AHelper
	#endif
#endif


#define A2W(lpa) (\
		((_lpa = lpa) == NULL) ? NULL : (\
			_convert = (lstrlenA(_lpa)+1),\
			AtlA2WHelper((LPWSTR)MemAlloc(_convert*2), _lpa, _convert, CP_ACP)))

#define W2A(lpw) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (lstrlenW(_lpw)+1)*2,\
			AtlW2AHelper((LPSTR)MemAlloc(_convert), _lpw, _convert, CP_ACP)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))



#ifdef OLE2ANSI
	inline LPOLESTR A2OLE(LPSTR lp) { return lp;}
	inline LPSTR OLE2A(LPOLESTR lp) { return lp;}
	#define W2OLE W2A
	#define OLE2W A2W
	inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;}
	inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;}
	#define W2COLE W2CA
	#define OLE2CW A2CW
#else
	inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA
#endif


#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif
#define OLE2T    W2T
#define OLE2CT   W2CT
#define T2OLE    T2W
#define T2COLE   T2CW


inline BSTR A2WBSTR(LPCSTR lp, int nLen = -1)
{
	USES_IU_CONVERSION;
	BSTR str = NULL;
	int nConvertedLen = MultiByteToWideChar(_acp, 0, lp,
		nLen, NULL, NULL)-1;
	str = ::SysAllocStringLen(NULL, nConvertedLen);
	if (str != NULL)
	{
		MultiByteToWideChar(_acp, 0, lp, -1,
			str, nConvertedLen);
	}
	return str;
}

inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {USES_IU_CONVERSION; return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return ::SysAllocString(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {USES_IU_CONVERSION; return ::SysAllocString(W2COLE(lp));}
#else
	inline BSTR T2BSTR(LPCTSTR lp) {USES_IU_CONVERSION; return A2WBSTR(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {USES_IU_CONVERSION; return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#endif



// *******************************************************************************
//
//	Other memory related functions
//
// *******************************************************************************


//
// implemenation of CRT memcpy() function
//
LPVOID MyMemCpy(LPVOID dest, const LPVOID src, size_t nBytes);

//
// allocate heap mem and copy
//
LPVOID HeapAllocCopy(LPVOID src, size_t nBytes);



#define __MEM_UTIL_HEADER__
#endif //__MEM_UTIL_HEADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\regutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RegUtil.h
//	Author:	Charles Ma, 10/20/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      IU registry utility library
//
//=======================================================================


#ifndef __REG_UTIL_H_ENCLUDED__



// ----------------------------------------------------------------------
//
// define the enum used for version status checking
//
// ----------------------------------------------------------------------
enum _VER_STATUS {
    DETX_LOWER              = -2,
	DETX_LOWER_OR_EQUAL	    = -1,
	DETX_SAME	            =  0,
	DETX_HIGHER_OR_EQUAL    = +1,
	DETX_HIGHER             = +2
};



// ----------------------------------------------------------------------
//
// public function to tell is a reg key exists
//
// ----------------------------------------------------------------------
BOOL RegKeyExists(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName		// optional value name
);


// ----------------------------------------------------------------------
//
// public function to tell is a reg value in reg matches given value
//
// ----------------------------------------------------------------------
BOOL RegKeyValueMatch(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsValue		// value value
);


// ----------------------------------------------------------------------
//
// public function to tell if a reg key has a string type value
// that contains given string
//
// ----------------------------------------------------------------------
BOOL RegKeySubstring(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsSubString	// substring to see if contained in value
);


// ----------------------------------------------------------------------
//
// public function to tell if a reg key has a version to compare
// and the compare results
//
// ----------------------------------------------------------------------
BOOL RegKeyVersion(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsVersion,		// version in string to compare
	_VER_STATUS CompareVerb	// how to compair
);



// ----------------------------------------------------------------------------------
//
// public function to find out the file path based on reg
//	assumption: 
//		lpsFilePath points to a buffer at least MAX_PATH long.
//
// ----------------------------------------------------------------------------------
BOOL GetFilePathFromReg(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR	lpsValName,		// optional value name
	LPCTSTR	lpsRelativePath,// optional additonal relative path to add to path in reg
	LPCTSTR	lpsFileName,	// optional file name to append to path
	LPTSTR	lpsFilePath
);


#define __REG_UTIL_H_ENCLUDED__
#endif //__REG_UTIL_H_ENCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\safefile.h ===
//
// SafeFile.h
//
//		Functions to help prevent opening unsafe files.
//
// History:
//
//		2002-03-18  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#pragma once


//
// You can override these allocators in your stdafx.h if necessary
//
#ifndef SafeFileMalloc
#define SafeFileMalloc malloc
#endif
#ifndef SafeFileFree
#define SafeFileFree(p) ((p) ? free(p) : NULL) // allow null to avoid confusion w/ "safe" in name
#endif


//
// "Safe file flags", used by various public API's.
//
// Note that they don't overlap, to avoid errors where one function's
// flags are passed to another function by accident.
//

// SafeCreateFile flags
//
#define SCF_ALLOW_NETWORK_DRIVE    0x00000001  // file can be on a network drive
#define SCF_ALLOW_REMOVABLE_DRIVE  0x00000002  // file can be on a removable drive (incl. CD-ROM & others)
#define SCF_ALLOW_ALTERNATE_STREAM 0x00000004  // allow filename to refer to alternate stream such as ":foo:$DATA"

// SafePathCombine flags
//
#define SPC_FILE_MUST_EXIST        0x00000010  // return an error if path or file doesn't exist
#define SPC_ALLOW_ALTERNATE_STREAM 0x00000020  // allow filename to refer to alternate stream such as ":foo:$DATA"

// SafeFileCheckForReparsePoint flags
//
#define SRP_FILE_MUST_EXIST        0x00000100  // return an error if path or file doesn't exist

// SafeDeleteFolderAndContents flags
//
#define SDF_ALLOW_NETWORK_DRIVE    0x00001000  // ok to delete files on a network drive
#define SDF_DELETE_READONLY_FILES  0x00002000  // delete files even if read-only
#define SDF_CONTINUE_IF_ERROR      0x00004000  // keep deleting files even if one fails


//
// Public function declarations. See SafeFile.cpp for detailed descriptions.
//

BOOL WINAPI IsFullPathName
	(
		IN LPCTSTR pszFileName,                    // full or relative path to a file
		OUT OPTIONAL BOOL* pfUNC = NULL,           // TRUE path is UNC (int incl mapped drive)
		OUT OPTIONAL BOOL* pfExtendedSyntax = NULL // TRUE if path is \\?\ syntax
	);

HRESULT WINAPI GetReparsePointType
	(
		IN LPCTSTR pszFileName,           // full path to folder to check
		OUT DWORD* pdwReparsePointType    // set to reparse point type, or 0 if none
	);

HRESULT WINAPI SafeFileCheckForReparsePoint
	(
		IN LPCTSTR pszFileName,           // full path of a file
		IN int     nFirstUntrustedOffset, // char offset of first path component to check
		IN DWORD   dwSafeFlags            // zero or more SRP_* flags
	);

HRESULT WINAPI SafePathCombine
	(
		OUT LPTSTR  pszBuf,               // buffer where combined path will be stored
		IN  int     cchBuf,               // size of output buffer, in TCHARs
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	);

HRESULT WINAPI SafePathCombineAlloc
	(
		OUT LPTSTR* ppszResult,           // ptr to newly alloc'd buffer stored here
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	);

HRESULT WINAPI SafeCreateFile
	(
		OUT HANDLE* phFileResult,       // receives handle to opened file, or INVALID_HANDLE_VALUE
		IN DWORD dwSafeFlags,           // zero or more SCF_* flags
		IN LPCTSTR pszFileName,         // same as CreateFile
		IN DWORD dwDesiredAccess,       // same as CreateFile
		IN DWORD dwShareMode,           // same as CreateFile
		IN LPSECURITY_ATTRIBUTES lpSecurityAttributes, // same as CreateFile
		IN DWORD dwCreationDisposition, // same as CreateFile
		IN DWORD dwFlagsAndAttributes,  // same as CreateFile + (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)
		IN HANDLE hTemplateFile         // same as CreateFile
	);

HRESULT WINAPI SafeRemoveFileAttributes
	(
		IN LPCTSTR pszFileName,    // full path to file whose attributes we will change
		IN DWORD   dwCurAttrib,    // current attributes of the file
		IN DWORD   dwRemoveAttrib  // attribute bits to remove
	);

HRESULT WINAPI SafeDeleteFolderAndContents
	(
		IN LPCTSTR pszFolderToDelete,  // full path of folder to delete
		IN DWORD   dwSafeFlags         // zero or more SDF_* flags
	);


//
// Limited ansi/unicode support
//

#ifdef UNICODE
#define IsFullPathNameW                IsFullPathName
#define GetReparsePointTypeW           GetReparsePointType
#define SafeFileCheckForReparsePointW  SafeFileCheckForReparsePoint
#define SafePathCombineW               SafePathCombine
#define SafePathCombineAllocW          SafePathCombineAlloc
#define SafeCreateFileW                SafeCreateFile
#define SafeRemoveFileAttributesW      SafeRemoveFileAttributes
#define SafeDeleteFolderAndContentsW   SafeDeleteFolderAndContents
#else // !UNICODE
#define IsFullPathNameA                IsFullPathName
#define GetReparsePointTypeA           GetReparsePointType
#define SafeFileCheckForReparsePointA  SafeFileCheckForReparsePoint
#define SafePathCombineA               SafePathCombine
#define SafePathCombineAllocA          SafePathCombineAlloc
#define SafeCreateFileA                SafeCreateFile
#define SafeRemoveFileAttributesA      SafeRemoveFileAttributes
#define SafeDeleteFolderAndContentsA   SafeDeleteFolderAndContents
#endif // !UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\redirectutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RedirectUtil.h
//	Author:	Charles Ma, 9/19/2001
//
//	Revision History:
//
//
//
//  Description:
//
//      Helper function(s) for handling server redirect
//		Can be shared by IU control and other Windows Update components
//
//=======================================================================


#pragma once

//-----------------------------------------------------------------------
// 
// DownloadCab() 
//	download a cab file of specific name from a base web address.  The
//  file will be saved locally, with file trust verified and extracted to
//  a specific folder.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszCabName - the file name of the cab file (eg. iuident.cab)
//		ptszBaseUrl - the base web address to download the cab file
//		ptszExtractDir - the local dir to save the cab file and those extracted from it
//		dwFlags - the set of flags to be passed to DownloadFileLite()
//		fExtractFiles (default as TRUE) - extract files
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadCab(
			HANDLE hQuitEvent,
			LPCTSTR ptszCabName,
			LPCTSTR ptszBaseUrl,
			LPCTSTR ptszExtractDir,
			DWORD dwFlags = 0,
			BOOL fExtractFiles = TRUE);


//-----------------------------------------------------------------------
// 
// DownloadIUIdent() 
//	download iuident.cab from a specific location, if provided.
//	Otherwise get it from where the WUServer registry value points to.
//  Either case, it will handle ident redirection.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszBaseUrl - the initial base URL for iuident.cab, must be no bigger than
//					  (INTERNET_MAX_URL_LENGTH) TCHARs.  Otherwise use
//					  WUServer entry from policy.  If entry not found,
//					  use "http://windowsupdate.microsoft.com/v4"
//		ptszFileCacheDir - the local base path to store the iuident.cab and
//						   the files extracted from it
//		dwFlags - the set of flags used by DownloadCab()
//
//		fIdentFromPolicy - tell if this is corpwu use. It has these impacts:
//					TRUE:	(1) no iuident.txt timestamp validation will be done by
//							comparing the newly downloaded cab and existing one.
//							(2) if download fail and ident cab exist and valid,
//							we will verify trust and extract iuident to use.
//					FALSE:	will validate newly downloaded cab against existing one
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadIUIdent(
			HANDLE hQuitEvent,
			LPCTSTR ptszBaseUrl,
			LPTSTR ptszFileCacheDir,
			DWORD dwFlags = 0,
			BOOL fIdentFromPolicy = TRUE);


//-----------------------------------------------------------------------
// 
// GetRedirectServerUrl() 
//	Search the [redirect] section of the given init file for the base
//  server URL corresponding to the OS version.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		lpszNewUrl - point to a buffer to receive redirect server url, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no redirect server url defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		Section name: [redirect]
//		Its entries should be defined according to GetINIValueByOSVer().
// 
//-----------------------------------------------------------------------

HRESULT GetRedirectServerUrl(
			LPCTSTR pcszInitFile, // path of file name.
			LPTSTR lpszNewUrl,	// points to a buffer to receive new server url 
			int nBufSize		// size of buffer, in chars
);


//-----------------------------------------------------------------------
// 
// GetINIValueByOSVer() 
//	Search the specified section of the given init file for
//  the value corresponding to the version of the OS.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		pcszSection - section name which the key is under
//		lpszValue - point to a buffer to receive the entry value, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no value defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		this section contains zero or more entries, each entry has format:
//		<beginVersionRange>-<endVersionRange>=<redirect server url>
//		where:
//			<beginVersionRange> ::= <VersionRangeBound>
//			<endVersionRange> ::= <VersionRangeBound>
//			<VersionRangeBound> ::= EMPTY | Major[.Minor[.Build[.ServicePackMajor[.ServicePackMinor]]]]
//			<redirect server url>=http://blahblah....
//		an empty version range bound means boundless.
//		a missing version component at end of a version data string means default value 0.
//		(e.g., 5.2 = 5.2.0.0.0)
// 
//-----------------------------------------------------------------------

HRESULT GetINIValueByOSVer(
			LPCTSTR pcszInitFile, // path of file name.
			LPCTSTR pcszSection, // section name
			LPTSTR lpszValue,	// points to a buffer to receive new server url 
			int nBufSize);		// size of buffer, in chars
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\osdet.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   osdet.h
//
//  Description:
//
//      IU Platform and language detection
//
//=======================================================================

#ifndef __IU_OSDET_INC__
#define __IU_OSDET_INC__

#include <oleauto.h>
#include <wininet.h> // for INTERNET_MAX_URL_LENGTH

extern HINSTANCE g_hinst;

	typedef struct _IU_DRIVEINFO
	{
		//
		// Drive strings are of the form "C:\" so will always be 4 TCHARs (including NULL)
		//
		TCHAR szDriveStr[4];
		INT		iKBytes;
	} IU_DRIVEINFO, * PIU_DRIVEINFO, ** PPIU_DRIVEINFO;

	// NOTE: The callee is responsible for allocating all BSTRs, and the caller
	// is responsible for freeing all BSTRs (both use SysAllocXxx calls).
	typedef struct _IU_PLATFORM_INFO 
	{
		OSVERSIONINFOEX osVersionInfoEx;	// if osVersionInfoEx.dwOSVersionInfoSize == sizeof(OSVERSIONINFO)
											// then only first six (OSVERSIONINFO) members are valid.

		BOOL	fIsAdministrator;			// Applies only to NT platforms (always FALSE on Win9x)
		
		BSTR	bstrOEMManufacturer;

		BSTR	bstrOEMModel;

		BSTR	bstrOEMSupportURL;			// Only if oeminf.ini exists on machine
	} IU_PLATFORM_INFO, *PIU_PLATFORM_INFO;


	typedef struct _OEMINFO
	{
		DWORD  dwMask;
		TCHAR  szWbemOem[65];
		TCHAR  szWbemProduct[65];
		TCHAR  szAcpiOem[65];
		TCHAR  szAcpiProduct[65];
		TCHAR  szSmbOem[65];
		TCHAR  szSmbProduct[65];
		DWORD  dwPnpOemId;
		TCHAR  szIniOem[256];
		TCHAR  szIniOemSupportUrl[INTERNET_MAX_URL_LENGTH];
	} OEMINFO, * POEMINFO;

	#define OEMINFO_WBEM_PRESENT	0x0001
	#define OEMINFO_ACPI_PRESENT	0x0002
	#define OEMINFO_SMB_PRESENT		0x0004
	#define OEMINFO_PNP_PRESENT		0x0008
	#define OEMINFO_INI_PRESENT		0x0010


	HRESULT WINAPI DetectClientIUPlatform(PIU_PLATFORM_INFO pIuPlatformInfo);

	LANGID WINAPI GetSystemLangID(void);

	LANGID WINAPI GetUserLangID(void);

	HRESULT GetOemBstrs(BSTR& bstrManufacturer, BSTR& bstrModel, BSTR& bstrSupportURL);

	HRESULT GetLocalFixedDriveInfo(DWORD* pdwNumDrives, PPIU_DRIVEINFO ppDriveInfo);

	BOOL IsAdministrator(void);

	//
	// tell whether the current logon is member of admins or power users
	//
	#define IU_SECURITY_MASK_ADMINS			0x00000001
	#define IU_SECURITY_MAST_POWERUSERS		0x00000002
	DWORD GetLogonGroupInfo(void);

	int IsWindowsUpdateDisabled(void);

	int IsWindowsUpdateUserAccessDisabled(void);

	int IsAutoUpdateEnabled(void);

	//
	// Return platform and locale strings for use with iuident.txt files.
	//
	LPTSTR GetIdentPlatformString(LPTSTR pszPlatformBuff, DWORD dwcBuffLen);

	LPTSTR GetIdentLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen);

	LPTSTR LookupLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen, BOOL fIsUser);

    BOOL LookupLocaleStringFromLCID(LCID lcid, LPTSTR pszISOCode, DWORD cchISOCode);

#endif	// __IU_OSDET_INC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\safefunc.h ===
#pragma once

#include <objbase.h>

#define SafeRelease(p)          if (NULL != p) { (p)->Release(); }
#define SafeReleaseNULL(p)      if (NULL != p) { (p)->Release(); (p) = NULL; }
#define SafeFree(p)             if (NULL != p) { free(p); }
#define SafeFreeNULL(p)         if (NULL != p) { free(p); (p) = NULL; }
#define SafeDelete(p)           if (NULL != p) { delete (p); }
#define SafeDeleteNULL(p)       if (NULL != p) { delete (p); (p) = NULL; }
#define SafeLocalFree(p)        if (NULL != p) { LocalFree(p); }
#define SafeLocalFreeNULL(p)    if (NULL != p) { LocalFree(p); (p) = NULL; }

inline void SafeCloseHandle(HANDLE h)
{
    if ( NULL != h )
    {
        CloseHandle(h);
    }
}

inline void SafeCloseHandleNULL(HANDLE & h)
{
    if ( NULL != h )
    {
        CloseHandle(h);
        h = NULL;
    }
}

inline void SafeCloseFileHandle(HANDLE h)
{
    if ( INVALID_HANDLE_VALUE != h )
    {
        CloseHandle(h);
    }
}

inline void SafeCloseFileHandleInvalidate(HANDLE & h)
{
    if ( INVALID_HANDLE_VALUE != h )
    {
        CloseHandle(h);
        h = INVALID_HANDLE_VALUE;
    }
}

inline void SafeFreeBSTR(BSTR bstr)
{
    SysFreeString(bstr);	// SysFreeString takes no action if bstr == NULL
}

inline void SafeFreeBSTRNULL(BSTR &bstr)
{
	SysFreeString(bstr);
	bstr = NULL;
}

inline int WUCompareString(LPCTSTR lpString1, LPCTSTR lpString2)
{
    return CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 0, lpString1, -1, lpString2, -1);
}

inline int WUCompareStringI(LPCTSTR lpString1, LPCTSTR lpString2)
{
    return CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, lpString1, -1, lpString2, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\safereg.h ===
//
// SafeReg.h
//
//		Functions to ensure strings read from the registry are null-terminated.
//
// History:
//
//		2002-03-20  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#pragma once


#define REG_E_MORE_DATA    HRESULT_FROM_WIN32(ERROR_MORE_DATA)

// Override these if you need a custom allocator for the safe reg functions
#ifndef SafeRegMalloc
#define SafeRegMalloc  malloc
#define SafeRegFree(p) ((p) ? free(p) : NULL)
#endif

HRESULT WINAPI SafeRegQueryStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize, // S_OK: chars written, excluding trailing null
		                                 // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz = NULL // TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize, // S_OK: bytes written, excluding trailing null
		                                // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz = NULL // TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize // S_OK: chars written, excluding final trailing null
		                                // REG_E_MORE_DATA: required size, including nulls
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize // S_OK: bytes written, excluding final trailing null
		                               // REG_E_MORE_DATA: required size, including nulls
	);

HRESULT WINAPI SafeRegQueryStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize,     // chars written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz = NULL //TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcbValueSize, // bytes written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz = NULL // TRUE if reg string is actually REG_EXPAND_SZ
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize // chars written, excluding final trailing null
	);

HRESULT WINAPI SafeRegQueryMultiStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize // chars written, excluding final trailing null
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\schemakeys.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   SchemaKeys.h
//
//	Author:	Charles Ma
//			2000.12.4
//
//  Description:
//
//      header file to declare all schema keys
//
//=======================================================================


#pragma once

#include <windows.h>
#include <ole2.h>
#include <tchar.h>

class CSchemaKeys
{
public:

	CSchemaKeys();
	~CSchemaKeys();

	BSTR		SCHEMA_KEY_XML_NAMESPACE;	// = L"xmlns";
	BSTR		SCHEMA_KEY_XML;				// = L"xml";
	BSTR		SCHEMA_KEY_SYSTEMINFO;		// = L"systemInfo";
	BSTR		SCHEMA_KEY_COMPUTERSYSTEM;	// = L"computerSystem";
	BSTR		SCHEMA_KEY_MANUFACTURER;	// = L"manufacturer";
	BSTR		SCHEMA_KEY_MODEL;			// = L"model";
	BSTR		SCHEMA_KEY_SUPPORTSITE;		// = L"supportSite";
	BSTR		SCHEMA_KEY_ADMINISTRATOR;	// = L"administrator";
	BSTR		SCHEMA_KEY_WU_DISABLED;		// = L"windowsUpdateDisabled";
	BSTR		SCHEMA_KEY_AU_ENABLED;		// = L"autoUpdateEnabled";
	BSTR		SCHEMA_KEY_DRIVESPACE;		// = L"driveSpace";
	BSTR		SCHEMA_KEY_DRIVE;			// = L"drive";
	BSTR		SCHEMA_KEY_KBYTES;			// = L"kbytes";
	BSTR		SCHEMA_KEY_REGKEYS;			// = L"regKeys";
	BSTR		SCHEMA_KEY_REG_HKLM;		// = L"HKEY_LOCAL_MACHINE";
	BSTR		SCHEMA_KEY_REG_SW;			// = L"SOFTWARE";

	BSTR		SCHEMA_KEY_NAME;			// = L"name";
	BSTR		SCHEMA_KEY_COMSERVER;		// = L"comserverID";
	BSTR		SCHEMA_KEY_KEY;				// = L"key";
	BSTR		SCHEMA_KEY_ENTRY;			// = L"entry";
	BSTR		SCHEMA_KEY_VALUE;			// = L"value";
	BSTR		SCHEMA_KEY_VERSION;			// = L"version";
	BSTR		SCHEMA_KEY_VERSIONSTATUS;	// = L"versionStatus";
	BSTR		SCHEMA_KEY_FILEPATH;		// = L"filePath";
	BSTR		SCHEMA_KEY_TIMESTAMP;		// = L"timestamp";
	BSTR		SCHEMA_KEY_GUID;			// = L"guid";

	BSTR		SCHEMA_KEY_CATALOG_PROVIDER;// = L"catalog/provider"
	BSTR		SCHEMA_KEY_ITEMS;			// = L"items"
	BSTR		SCHEMA_KEY_ITEM_SEARCH;		// = L"catalog/provider/item"
	BSTR		SCHEMA_KEY_ITEM;			// = L"item"
	BSTR		SCHEMA_KEY_ITEM_ITEMSTATUS;	// = L"items/itemStatus";
	BSTR		SCHEMA_KEY_ITEMSTATUS;		// = L"itemStatus";
	BSTR		SCHEMA_KEY_DETECTION;		// = L"detection"
    BSTR        SCHEMA_KEY_INSTALLATION;    // = L"installation";
    BSTR        SCHEMA_KEY_INSTALLSTATUS;   // = L"installStatus";
    BSTR		SCHEMA_KEY_INSTALLERTYPE;	// = L"installerType";
	BSTR		SCHEMA_KEY_EXCLUSIVE;		// = L"exclusive";
    BSTR		SCHEMA_KEY_NEEDSREBOOT;		// = L"needsReboot";
    BSTR		SCHEMA_KEY_COMMAND;			// = L"command";
    BSTR		SCHEMA_KEY_SWITCHES;		// = L"switches";
    BSTR		SCHEMA_KEY_COMMANDTYPE;		// = L"commandType";
    BSTR		SCHEMA_KEY_INFINSTALL;		// = L"infInstallSection";
	BSTR		SCHEMA_KEY_CODEBASE;		// = L"codeBase";
	BSTR        SCHEMA_KEY_CRC;				// = L"crc";
	BSTR		SCHEMA_KEY_PATCHAVAILABLE;	// = L"patchAvailable";
	BSTR		SCHEMA_KEY_SIZE;			// = L"size";
	BSTR		SCHEMA_KEY_DOWNLOADPATH;	// = L"downloadPath";
	BSTR		SCHEMA_KEY_DOWNLOADSTATUS;	// = L"downloadStatus";
    BSTR        SCHEMA_KEY_DEPENDENCIES;    // = L"dependencies";
    BSTR        SCHEMA_KEY_DESCRIPTION;     // = L"description";
	BSTR		SCHEMA_KEY_HREF;			// = L"href"
   // NSOY - Fix build break BSTR        SCHEMA_KEY_CRC;             // = L"crc"; 
	BSTR		SCHEMA_KEY_IDENTITY;		// = L"identity";
	BSTR		SCHEMA_KEY_PUBLISHERNAME;	// = L"publisherName";
	BSTR		SCHEMA_KEY_LANGUAGE;		// = L"language"
	BSTR		SCHEMA_KEY_PLATFORM;		// = L"platform"
	BSTR		SCHEMA_KEY_PROCESSORARCHITECTURE; // = L"processorArchitecture"
	BSTR		SCHEMA_KEY_SUITE;			// = L"suite"
	BSTR		SCHEMA_KEY_PRODUCTTYPE;		// = L"productType"
	BSTR		SCHEMA_KEY_LOCALE;			// = L"locale";
	BSTR		SCHEMA_KEY_CONTEXT;			// = L"context";
	BSTR		SCHEMA_KEY_MAJOR;			// = L"major"
	BSTR		SCHEMA_KEY_MINOR;			// = L"minor"
	BSTR		SCHEMA_KEY_BUILD;			// = L"build"
	BSTR		SCHEMA_KEY_SERVICEPACKMAJOR;// = L"servicePackMajor"
	BSTR		SCHEMA_KEY_SERVICEPACKMINOR;// = L"servicePackMinor"
    BSTR        SCHEMA_KEY_COMPATIBLEHARDWARE; // = L"compatibleHardware"
    BSTR        SCHEMA_KEY_DEVICES;         // = L"devices"
    BSTR        SCHEMA_KEY_DEVICE;          // = L"device"
    BSTR        SCHEMA_KEY_PRINTERINFO;     // = L"printerInfo"
    BSTR        SCHEMA_KEY_CDM_PINFO;		// = L"device/printerInfo"
    BSTR        SCHEMA_KEY_DRIVERNAME;      // = L"driverName"
    BSTR        SCHEMA_KEY_HWID;            // = L"hwid"
	BSTR		SCHEMA_KEY_CDM_HWIDPATH;	// = L"device/hwid"
    BSTR        SCHEMA_KEY_DESCRIPTIONTEXT; // = L"descriptionText"
    BSTR        SCHEMA_KEY_TITLE;           // = L"title"
    BSTR        SCHEMA_KEY_ITEMID;			// = L"itemID";
    BSTR        SCHEMA_KEY_HIDDEN;			// = L"hidden";
    BSTR        SCHEMA_KEY_ISPRINTER;       // = L"isPrinter"
    BSTR        SCHEMA_KEY_DEVICEINSTANCE;       // = L"deviceInstance"
    BSTR        SCHEMA_KEY_DRIVERPROVIDER;	// = L"driverProvider"
    BSTR        SCHEMA_KEY_MFGNAME;			// = L"mfgName"
    BSTR        SCHEMA_KEY_DRIVERVER;		// = L"driverVer"
    BSTR        SCHEMA_KEY_RANK;			// = L"rank"
	BSTR		SCHEMA_KEY_READMORE;		// = L"description/descriptionText/details"
	BSTR		SCHEMA_KEY_ERRORCODE;		// = L"errorCode";

    BSTR        SCHEMA_KEY_CATALOGSTATUS;   // = L"catalogStatus";
    BSTR        SCHEMA_KEY_PID;             // = L"pid";

	BSTR		SCHEMA_KEY_DETECTRESULT;	// = L"detectResult"
	BSTR		SCHEMA_KEY_INSTALLED;		// = L"installed"
	BSTR		SCHEMA_KEY_UPTODATE;		// = L"upToDate"
	BSTR		SCHEMA_KEY_NEWERVERSION;	// = L"newerVersion";
	BSTR		SCHEMA_KEY_EXCLUDED;		// = L"excluded"
	BSTR		SCHEMA_KEY_FORCE;			// = L"force"

	BSTR		SCHEMA_KEY_VERSTATUS_HI;	// = L"HIGHER";
	BSTR		SCHEMA_KEY_VERSTATUS_HE;	// = L"HIGHER_OR_SAME";
	BSTR		SCHEMA_KEY_VERSTATUS_EQ;	// = L"SAME";
	BSTR		SCHEMA_KEY_VERSTATUS_LE;	// = L"LOWER_OR_SAME";
	BSTR		SCHEMA_KEY_VERSTATUS_LO;	// = L"LOWER";

	BSTR		SCHEMA_KEY_FILE;			// = L"path";
	BSTR		SCHEMA_KEY_REGKEY;			// = L"regKey";
	BSTR		SCHEMA_KEY_PATH;			// = L"path";
	BSTR		SCHEMA_KEY_STATUS_COMPLETE;	// = L"COMPLETE";
	BSTR		SCHEMA_KEY_STATUS_FAILED;	// = L"FAILED";

	BSTR		SCHEMA_KEY_CLIENT;			// = L"client";
	BSTR		SCHEMA_KEY_CLIENTINFO;		// = L"clientInfo";
	BSTR		SCHEMA_KEY_CLIENTNAME;		// = L"clientName"; attr of clientInfo tag

	LPCTSTR		SCHEMA_KEY_REGKEYEXISTS;	// = _T("regKeyExists");
	LPCTSTR		SCHEMA_KEY_REGKEYVALUE;		// = _T("regKeyValue");
	LPCTSTR		SCHEMA_KEY_REGKEYSUBSTR;	// = _T("regKeySubstring");
	LPCTSTR		SCHEMA_KEY_REGKEYVERSION;	// = _T("regKeyVersion");
	LPCTSTR		SCHEMA_KEY_FILEVERSION;		// = _T("fileVersion");
	LPCTSTR		SCHEMA_KEY_FILEEXISTS;		// = _T("fileExists");
	LPCTSTR		SCHEMA_KEY_AND;				// = _T("and");
	LPCTSTR		SCHEMA_KEY_OR; 				// = _T("or");
	LPCTSTR		SCHEMA_KEY_NOT;	 			// = _T("not");
};


extern CSchemaKeys *g_pGlobalSchemaKeys;
//
// Safe return of schema key from global object pointer
//
#define	RETURN_SCHEMA_KEY( key ) (NULL == g_pGlobalSchemaKeys ? NULL : g_pGlobalSchemaKeys->##key)

#define			KEY_XML_NAMESPACE		RETURN_SCHEMA_KEY(SCHEMA_KEY_XML_NAMESPACE)
#define			KEY_XML					RETURN_SCHEMA_KEY(SCHEMA_KEY_XML)
#define			KEY_SYSTEMINFO			RETURN_SCHEMA_KEY(SCHEMA_KEY_SYSTEMINFO)
#define			KEY_COMPUTERSYSTEM		RETURN_SCHEMA_KEY(SCHEMA_KEY_COMPUTERSYSTEM)
#define			KEY_SUPPORTSITE			RETURN_SCHEMA_KEY(SCHEMA_KEY_SUPPORTSITE)
#define			KEY_ADMINISTRATOR		RETURN_SCHEMA_KEY(SCHEMA_KEY_ADMINISTRATOR)
#define			KEY_WU_DISABLED			RETURN_SCHEMA_KEY(SCHEMA_KEY_WU_DISABLED)
#define			KEY_AU_ENABLED			RETURN_SCHEMA_KEY(SCHEMA_KEY_AU_ENABLED)
#define			KEY_DRIVESPACE			RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVESPACE)
#define			KEY_DRIVE				RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVE)
#define			KEY_KBYTES				RETURN_SCHEMA_KEY(SCHEMA_KEY_KBYTES)
#define			KEY_REGKEYS				RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYS)
#define			KEY_REG_HKLM			RETURN_SCHEMA_KEY(SCHEMA_KEY_REG_HKLM)
#define			KEY_REG_SW				RETURN_SCHEMA_KEY(SCHEMA_KEY_REG_SW)

#define 		KEY_NAME				RETURN_SCHEMA_KEY(SCHEMA_KEY_NAME)				
#define 		KEY_COMSERVER			RETURN_SCHEMA_KEY(SCHEMA_KEY_COMSERVER)
#define 		KEY_KEY					RETURN_SCHEMA_KEY(SCHEMA_KEY_KEY)					
#define 		KEY_ENTRY				RETURN_SCHEMA_KEY(SCHEMA_KEY_ENTRY)				
#define 		KEY_VALUE				RETURN_SCHEMA_KEY(SCHEMA_KEY_VALUE)				
#define 		KEY_VERSION				RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSION)				
#define 		KEY_VERSIONSTATUS		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSIONSTATUS)
#define 		KEY_FILEPATH			RETURN_SCHEMA_KEY(SCHEMA_KEY_FILEPATH)	
#define 		KEY_TIMESTAMP			RETURN_SCHEMA_KEY(SCHEMA_KEY_TIMESTAMP)
#define 		KEY_GUID				RETURN_SCHEMA_KEY(SCHEMA_KEY_GUID)

#define			KEY_CATALOG_PROVIDER	RETURN_SCHEMA_KEY(SCHEMA_KEY_CATALOG_PROVIDER)
#define			KEY_ITEMS				RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEMS)
#define			KEY_ITEM_SEARCH			RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEM_SEARCH)
#define			KEY_ITEM				RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEM)
#define			KEY_ITEM_ITEMSTATUS		RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEM_ITEMSTATUS)
#define			KEY_ITEMSTATUS			RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEMSTATUS)
#define			KEY_DETECTION			RETURN_SCHEMA_KEY(SCHEMA_KEY_DETECTION)
#define         KEY_INSTALLATION        RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLATION)
#define         KEY_INSTALLSTATUS       RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLSTATUS)
#define         KEY_INSTALLERTYPE       RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLERTYPE)
#define         KEY_EXCLUSIVE			RETURN_SCHEMA_KEY(SCHEMA_KEY_EXCLUSIVE)
#define         KEY_NEEDSREBOOT			RETURN_SCHEMA_KEY(SCHEMA_KEY_NEEDSREBOOT)
#define         KEY_COMMAND				RETURN_SCHEMA_KEY(SCHEMA_KEY_COMMAND)
#define         KEY_SWITCHES			RETURN_SCHEMA_KEY(SCHEMA_KEY_SWITCHES)
#define         KEY_COMMANDTYPE			RETURN_SCHEMA_KEY(SCHEMA_KEY_COMMANDTYPE)
#define         KEY_INFINSTALL			RETURN_SCHEMA_KEY(SCHEMA_KEY_INFINSTALL)
#define         KEY_CODEBASE			RETURN_SCHEMA_KEY(SCHEMA_KEY_CODEBASE)
#define         KEY_CRC                 RETURN_SCHEMA_KEY(SCHEMA_KEY_CRC)
#define         KEY_PATCHAVAILABLE		RETURN_SCHEMA_KEY(SCHEMA_KEY_PATCHAVAILABLE)
#define         KEY_SIZE				RETURN_SCHEMA_KEY(SCHEMA_KEY_SIZE)
#define         KEY_DOWNLOADPATH		RETURN_SCHEMA_KEY(SCHEMA_KEY_DOWNLOADPATH)
#define         KEY_DOWNLOADSTATUS		RETURN_SCHEMA_KEY(SCHEMA_KEY_DOWNLOADSTATUS)
#define         KEY_DEPENDENCIES        RETURN_SCHEMA_KEY(SCHEMA_KEY_DEPENDENCIES)
#define         KEY_DESCRIPTION         RETURN_SCHEMA_KEY(SCHEMA_KEY_DESCRIPTION)
#define			KEY_HREF				RETURN_SCHEMA_KEY(SCHEMA_KEY_HREF)
#define			KEY_LANGUAGE			RETURN_SCHEMA_KEY(SCHEMA_KEY_LANGUAGE)

#define			KEY_PLATFORM			RETURN_SCHEMA_KEY(SCHEMA_KEY_PLATFORM)
#define			KEY_PROCESSORARCHITECTURE RETURN_SCHEMA_KEY(SCHEMA_KEY_PROCESSORARCHITECTURE)
#define			KEY_SUITE				RETURN_SCHEMA_KEY(SCHEMA_KEY_SUITE)
#define			KEY_PRODUCTTYPE			RETURN_SCHEMA_KEY(SCHEMA_KEY_PRODUCTTYPE)
#define			KEY_LOCALE				RETURN_SCHEMA_KEY(SCHEMA_KEY_LOCALE)
#define			KEY_CONTEXT				RETURN_SCHEMA_KEY(SCHEMA_KEY_CONTEXT)
#define			KEY_MAJOR				RETURN_SCHEMA_KEY(SCHEMA_KEY_MAJOR)
#define			KEY_MINOR				RETURN_SCHEMA_KEY(SCHEMA_KEY_MINOR)
#define			KEY_BUILD				RETURN_SCHEMA_KEY(SCHEMA_KEY_BUILD)
#define			KEY_SERVICEPACKMAJOR	RETURN_SCHEMA_KEY(SCHEMA_KEY_SERVICEPACKMAJOR)
#define			KEY_SERVICEPACKMINOR	RETURN_SCHEMA_KEY(SCHEMA_KEY_SERVICEPACKMINOR)
#define			KEY_COMPATIBLEHARDWARE  RETURN_SCHEMA_KEY(SCHEMA_KEY_COMPATIBLEHARDWARE)
#define			KEY_DEVICES             RETURN_SCHEMA_KEY(SCHEMA_KEY_DEVICES)
#define			KEY_DEVICE              RETURN_SCHEMA_KEY(SCHEMA_KEY_DEVICE)
#define         KEY_PRINTERINFO         RETURN_SCHEMA_KEY(SCHEMA_KEY_PRINTERINFO)
#define         KEY_CDM_PINFO	        RETURN_SCHEMA_KEY(SCHEMA_KEY_CDM_PINFO)
#define         KEY_DRIVERNAME          RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVERNAME)
#define			KEY_HWID                RETURN_SCHEMA_KEY(SCHEMA_KEY_HWID)
#define			KEY_CDM_HWIDPATH        RETURN_SCHEMA_KEY(SCHEMA_KEY_CDM_HWIDPATH)
#define			KEY_DESCRIPTIONTEXT     RETURN_SCHEMA_KEY(SCHEMA_KEY_DESCRIPTIONTEXT)
#define			KEY_TITLE               RETURN_SCHEMA_KEY(SCHEMA_KEY_TITLE)
#define			KEY_ITEMID				RETURN_SCHEMA_KEY(SCHEMA_KEY_ITEMID)
#define			KEY_HIDDEN				RETURN_SCHEMA_KEY(SCHEMA_KEY_HIDDEN)
#define			KEY_ISPRINTER           RETURN_SCHEMA_KEY(SCHEMA_KEY_ISPRINTER)
#define			KEY_DEVICEINSTANCE      RETURN_SCHEMA_KEY(SCHEMA_KEY_DEVICEINSTANCE)
#define			KEY_DRIVERPROVIDER		RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVERPROVIDER)
#define			KEY_MFGNAME				RETURN_SCHEMA_KEY(SCHEMA_KEY_MFGNAME)
#define			KEY_DRIVERVER			RETURN_SCHEMA_KEY(SCHEMA_KEY_DRIVERVER)
#define			KEY_RANK				RETURN_SCHEMA_KEY(SCHEMA_KEY_RANK)
#define			KEY_READMORE			RETURN_SCHEMA_KEY(SCHEMA_KEY_READMORE)
#define			KEY_ERRORCODE			RETURN_SCHEMA_KEY(SCHEMA_KEY_ERRORCODE)

#define         KEY_CATALOGSTATUS       RETURN_SCHEMA_KEY(SCHEMA_KEY_CATALOGSTATUS)
#define         KEY_PID                 RETURN_SCHEMA_KEY(SCHEMA_KEY_PID)

#define			KEY_DETECTRESULT		RETURN_SCHEMA_KEY(SCHEMA_KEY_DETECTRESULT)
#define			KEY_INSTALLED			RETURN_SCHEMA_KEY(SCHEMA_KEY_INSTALLED)
#define			KEY_UPTODATE			RETURN_SCHEMA_KEY(SCHEMA_KEY_UPTODATE)
#define			KEY_NEWERVERSION		RETURN_SCHEMA_KEY(SCHEMA_KEY_NEWERVERSION)
#define			KEY_EXCLUDED			RETURN_SCHEMA_KEY(SCHEMA_KEY_EXCLUDED)
#define			KEY_FORCE				RETURN_SCHEMA_KEY(SCHEMA_KEY_FORCE)

#define 		KEY_VERSTATUS_HI		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_HI)		
#define 		KEY_VERSTATUS_HE		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_HE)		
#define 		KEY_VERSTATUS_EQ		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_EQ)		
#define 		KEY_VERSTATUS_LE		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_LE)		
#define 		KEY_VERSTATUS_LO		RETURN_SCHEMA_KEY(SCHEMA_KEY_VERSTATUS_LO)		

#define 		KEY_IDENTITY			RETURN_SCHEMA_KEY(SCHEMA_KEY_IDENTITY)			
#define 		KEY_PUBLISHERNAME		RETURN_SCHEMA_KEY(SCHEMA_KEY_PUBLISHERNAME)		
#define 		KEY_FILE				RETURN_SCHEMA_KEY(SCHEMA_KEY_FILE)				
#define 		KEY_REGKEY				RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEY)
#define 		KEY_PATH				RETURN_SCHEMA_KEY(SCHEMA_KEY_PATH)	
#define 		KEY_STATUS_COMPLETE		RETURN_SCHEMA_KEY(SCHEMA_KEY_STATUS_COMPLETE)
#define 		KEY_STATUS_FAILED		RETURN_SCHEMA_KEY(SCHEMA_KEY_STATUS_FAILED)

#define			KEY_CLIENT				RETURN_SCHEMA_KEY(SCHEMA_KEY_CLIENT)
#define			KEY_CLIENTINFO			RETURN_SCHEMA_KEY(SCHEMA_KEY_CLIENTINFO)
#define			KEY_CLIENTNAME			RETURN_SCHEMA_KEY(SCHEMA_KEY_CLIENTNAME)

#define			KEY_MANUFACTURER		RETURN_SCHEMA_KEY(SCHEMA_KEY_MANUFACTURER)
#define			KEY_MODEL				RETURN_SCHEMA_KEY(SCHEMA_KEY_MODEL)



#define 		KEY_REGKEYEXISTS		RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYEXISTS)
#define 		KEY_REGKEYVALUE			RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYVALUE)
#define 		KEY_REGKEYSUBSTR		RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYSUBSTR)
#define 		KEY_REGKEYVERSION		RETURN_SCHEMA_KEY(SCHEMA_KEY_REGKEYVERSION)
#define 		KEY_FILEVERSION			RETURN_SCHEMA_KEY(SCHEMA_KEY_FILEVERSION)
#define 		KEY_FILEEXISTS			RETURN_SCHEMA_KEY(SCHEMA_KEY_FILEEXISTS)
#define 		KEY_AND					RETURN_SCHEMA_KEY(SCHEMA_KEY_AND)
#define 		KEY_OR 					RETURN_SCHEMA_KEY(SCHEMA_KEY_OR)
#define 		KEY_NOT 				RETURN_SCHEMA_KEY(SCHEMA_KEY_NOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\schemamisc.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   schemaMisc.h
//
//	Author:	Charles Ma
//			2000.12.4
//
//  Description:
//
//      header file of helper functions for IU schemas
//
//=======================================================================


#pragma once

#include <msxml.h>

//
// max length of platform when being converted into string
// this is an artificial number that we think enough to
// take any MS platform data.
//
extern const UINT MAX_PLATFORM_STR_LEN;			// = 1024

//
// private flags used by functions to retrieve string data
//
extern const DWORD SKIP_SUITES;					//= 0x1;
extern const DWORD SKIP_SERVICEPACK_VER;		//= 0x2;



/////////////////////////////////////////////////////////////////////////////
//
// Helper function DoesNodeHaveName()
//
//	find out the the current node has a matching name
//
//	Input:
//			a node
//
//	Return:
//			TRUE/FALSE
//
/////////////////////////////////////////////////////////////////////////////
BOOL DoesNodeHaveName(
	IXMLDOMNode* pNode, 
	BSTR bstrTagName
);



//----------------------------------------------------------------------
//
// Helper function FindNode()
//	retrieve the named child node
//
//	Input:
//		an IXMLDomNode and a bstr name
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------

BOOL
FindNode(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	IXMLDOMNode** ppFoundNode
);



//----------------------------------------------------------------------
//
// Helper function FindNodeValue()
//	retrieve the text data from a named child of the current node, 
//
//	Input:
//		an IXMLDomNode
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------
BOOL
FindNodeValue(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	BSTR* pbstrValue);


/////////////////////////////////////////////////////////////////////////////
// ReportParseError()
//
// Report parsing error information
/////////////////////////////////////////////////////////////////////////////
HRESULT ReportParseError(IXMLDOMParseError *pXMLError);

/////////////////////////////////////////////////////////////////////////////
// ValidateDoc()
//
// Validate the xml doc against the schema
/////////////////////////////////////////////////////////////////////////////
HRESULT ValidateDoc(IXMLDOMDocument* pDoc);

/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode);

/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode);

/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMNode* pParentNode, BSTR bstrName);

/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMDocument* pDoc, BSTR bstrName);

/////////////////////////////////////////////////////////////////////////////
// CreateDOMNode()
//
// Create an xml node of the given type
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNode* CreateDOMNode(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI = NULL);

/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// In various flavors.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT* piAttr);
HRESULT GetAttributeBOOL(IXMLDOMNode* pNode, BSTR bstrName, BOOL* pfAttr);
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, LONG* piAttr);
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR* pbstrAttr);

/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (integer) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT iAttr);

/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (BSTR) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR bstrAttr);

/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (VARIANT) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, VARIANT vAttr);

/////////////////////////////////////////////////////////////////////////////
// GetText()
//
// Get text (BSTR) from the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT GetText(IXMLDOMNode* pNode, BSTR* pbstrText);

/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (integer) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, INT iValue);

/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (BSTR) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, BSTR bstrValue);

/////////////////////////////////////////////////////////////////////////////
// InsertNode()
//
// Insert a child node to the parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT InsertNode(IXMLDOMNode* pParentNode, IXMLDOMNode* pChildNode, IXMLDOMNode* pChildNodeRef = NULL);

/////////////////////////////////////////////////////////////////////////////
// CopyNode()
//
// Create an xml node as a copy of the given node;
// this is different from cloneNode() as it copies node across xml document
/////////////////////////////////////////////////////////////////////////////
HRESULT CopyNode(IXMLDOMNode* pNodeSrc, IXMLDOMDocument* pDocDes, IXMLDOMNode** ppNodeDes);

/////////////////////////////////////////////////////////////////////////////
// AreNodesEqual()
//
// Return TRUE if two nodes are identical, return FALSE if they're different.
/////////////////////////////////////////////////////////////////////////////
BOOL AreNodesEqual(IXMLDOMNode* pNode1, IXMLDOMNode* pNode2);

/////////////////////////////////////////////////////////////////////////////
// LoadXMLDoc()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadXMLDoc(BSTR bstrXml, IXMLDOMDocument** ppDoc, BOOL fOffline = TRUE);

/////////////////////////////////////////////////////////////////////////////
// LoadDocument()
//
// Load an XML Document from the specified file
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocument(BSTR bstrFilePath, IXMLDOMDocument** ppDoc, BOOL fOffline = TRUE);

/////////////////////////////////////////////////////////////////////////////
// SaveDocument()
//
// Save an XML Document to the specified location
/////////////////////////////////////////////////////////////////////////////
HRESULT SaveDocument(IXMLDOMDocument* pDoc, BSTR bstrFilePath);

//----------------------------------------------------------------------
//
// public function Get3IdentiStrFromIdentNode()
//	retrieve the name, publisherName and GUID from an identity node 
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT
Get3IdentiStrFromIdentNode(
	IXMLDOMNode* pIdentityNode, 
	BSTR* pbstrName, 
	BSTR* pbstrPublisherName, 
	BSTR* pbstrGUID
);


//----------------------------------------------------------------------
//
// public function UtilGetUniqIdentityStr()
//	retrieve the unique string that make this <identity> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetUniqIdentityStr(
	IXMLDOMNode* pIdentityNode, 
	BSTR* pbstrUniqIdentifierString, 
	DWORD dwFlag);


//----------------------------------------------------------------------
//
// public function UtilGetPlatformStr()
//	retrieve the unique string that make this <platform> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetPlatformStr(
	IXMLDOMNode* pNodePlatform, 
	BSTR* pbstrPlatform, 
	DWORD dwFlag);
    

//----------------------------------------------------------------------
//
// public function UtilGetVersionStr()
//	retrieve the data from this <version> in string format
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetVersionStr(
	IXMLDOMNode* pVersionNode, 
	LPTSTR pszVersion, 
	DWORD dwFlag);
	


/////////////////////////////////////////////////////////////////////////////
// MakeUniqNameString()
//
// This is a utility function to construct the identity name string 
// based on name|publiser|GUID and the rule to make this name string.
//
// This function defines the logic about what components can be used
// to define the uniqueness of an item based on the 3 parts of data from
// GetIdentity().
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MakeUniqNameString(
					BSTR bstrName,
					BSTR bstrPublisher,
					BSTR bstrGUID,
					BSTR* pbstrUniqIdentifierString);


//-----------------------------------------------------------------------
//
// function GetFullFilePathFromFilePathNode()
//
//	retrieve the full qualified file path from a filePath node
//	the path retrieved is expanded.
//
// Input:
//		a filePath XMLDom node
//		a pointer to a buffer to receive path, assumes MAX_PATH long.
//
// Return:
//		HRESULT
//
//		
//-----------------------------------------------------------------------

HRESULT GetFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			LPTSTR lpszFilePath
);

HRESULT GetBstrFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			BSTR* pbstrFilePath
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\smbios.h ===
/*** smbios.h - SMBIOS spec
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _SMBIOS_H
#define _SMBIOS_H

#include <pshpack1.h>

#define SMBIOS_SEARCH_RANGE_BEGIN		0xF0000         // physical address where we begin searching for the RSDP
#define SMBIOS_SEARCH_RANGE_END         0xFFFFF
#define SMBIOS_SEARCH_RANGE_LENGTH      ((ULONG)(SMBIOS_SEARCH_RANGE_END-SMBIOS_SEARCH_RANGE_BEGIN+1))
#define SMBIOS_SEARCH_INTERVAL          16      // search on 16 byte boundaries

#define PNP_SIGNATURE					0x506E5024  // "$PnP"
#define SM_SIGNATURE					0x5F4D535F	// "_SM_"

#define SMBIOS_BIOS_INFO_TABLE			0
#define SMBIOS_SYSTEM_INFO_TABLE		1

typedef struct _PNPBIOSINIT
{
	DWORD		dwSignature;
	BYTE		bRevision;
	BYTE		bLength;
	WORD		wControl;
	BYTE		bChecksum;
	DWORD		dwEventNotify;
	WORD		wRealOffset;
	WORD		wRealSegment;
	WORD		wProtectedOffset;
	DWORD		dwProtectedSegment;
	DWORD		dwOEMID;
	WORD		wRealDataSegment;
	DWORD		dwProtectedDataSegment;
} PNPBIOSINIT, * PPNPBIOSINIT;

typedef struct _SMBIOSENTRY
{
	DWORD		dwSignature;
	BYTE		bChecksum;
	BYTE		bLength;
	BYTE		bMajorVersion;
	BYTE		bMinorVersion;
	WORD		wMaxStructSize;
	BYTE		bRevision;
	BYTE		abFormatedArea[5];
	BYTE		abOldSignature[5];	// _DMI_
	BYTE		bOldChecksum;
	WORD		wStructTableLength;
	DWORD		dwStructTableAddress;
	WORD		wNumberOfStructs;
	BYTE		bBCDRevision;
} SMBIOSENTRY, * PSMBIOSENTRY;

typedef struct _SMBIOSHEADER
{
	BYTE		bType;
	BYTE		bLength;
	WORD		wHandle;
} SMBIOSHEADER, * PSMBIOSHEADER;

typedef struct _SMBIOSSYSINFO
{
	BYTE		bType;
	BYTE		bLength;
	WORD		wHandle;
	BYTE		bManufacturer;
	BYTE		bProductName;
	BYTE		bVersion;
	BYTE		bSerialNumber;
	BYTE		abUUID[16];
	BYTE		bWakeUpType;
} SMBIOSSYSINFO, * PSMBIOSSYSINFO;

#endif  //_SMBIOS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\stringutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   fileutil.h
//
//  Description:
//
//      IU string utility library, providing functions available
//		only in CRT or SHLWAPI
//
//=======================================================================


#ifndef __STRINGUTIL_H_INCLUDED__

#include <ole2.h>
#include <shlwapi.h>
// ----------------------------------------------------------------------
//
// Public function StrChr() - same as shlwapi StrChr()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChr(LPCTSTR lpStart, const TCHAR wMatch);


// ----------------------------------------------------------------------
//
// Public function StrChrI() - same as shlwapi StrChrI()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case INsensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChrI(LPCTSTR lpStart, const TCHAR wMatch);

// ----------------------------------------------------------------------
//
// Public function StrRChr() - same as shlwapi StrRChr()
//		Searches a string for the last occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//      lpEnd - Address of the end of the string (NOT included in the search)
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrRChr(LPCTSTR lpStart, LPCTSTR lpEnd, const TCHAR wMatch);


// ----------------------------------------------------------------------
//
//	Private helper function to compare the contents of 
//	two BSTRs
//
// ----------------------------------------------------------------------
inline int CompareBSTRs(BSTR bstr1, BSTR bstr2)
{
	if (NULL == bstr1)
	{
		if (NULL == bstr2)
		{
			// Consider them equal
			return 0;
		}
		else
		{
			// Consider bstr1 < bstr2
			return -1;
		}
	}
	else if (NULL == bstr2)
	{
		// bstr1 isn't NULL (already checked) so consider bstr1 > bstr 2
		return 1;
	}
	//
	// Neither bstr is NULL, so we'll do a SHLWAPI compare of the first
	// string in each BSTR
	//
	LPWSTR p1 = (LPWSTR)((LPOLESTR) bstr1);
	LPWSTR p2 = (LPWSTR)((LPOLESTR) bstr2);
	return StrCmpIW(p1, p2);
};

inline BOOL CompareBSTRsEqual(BSTR bstr1, BSTR bstr2)
{
	return (CompareBSTRs(bstr1, bstr2) == 0);
};



// ----------------------------------------------------------------------
//
//	Convert a long number content in bstr into long
//	if error, 0 returned.
//
// ----------------------------------------------------------------------
LONG MyBSTR2L(BSTR bstrLongNumber);
#define MyBSTR2UL(bstrULongNumber)  (ULONG) MyBSTR2L(bstrULongNumber)

// ----------------------------------------------------------------------
//
//	Convert a a long number into bstr
//
// ----------------------------------------------------------------------
BSTR MyL2BSTR(LONG lNumber);
BSTR MyUL2BSTR(ULONG ulNumber);


// ----------------------------------------------------------------------
//
// Compare a binary buffer with a string, where data in the string
// has format:
//
//		<String>	::= <Number> [<Space><String>]
//		<Space>		::= TCHAR(' ')
//		<Number>	::= 0x<HexValue>|x<HexValue><Decimal>
//		<Decimal>	::= +<DecimalValue>|-<DecimalValue>
//		<DecimalValue> ::= <DecimalDigit>|<DecimalDigit><DecimalValue>
//		<DecimalDegit> ::= 0|1|2|3|4|5|6|7|8|9
//		<HexValue>	::= <HexDigit>|<HexDigit><HexDigit>
//		<HexDigit>	::= <DecimalDigit>|A|B|C|D|E|F
//
//	example of strings that this function recognize:
//		"12 0 45 0x1F"
//
//	Return: similar to lstrcmp() API, each byte is compared
//			as unsigned short
//			if binary > string, +1
//			if binary = string, 0
//			if binary < string, -1
//
// Note: if a number in string is bigger than a byte can handle,
// or not a valid number this funciton treats it as 0x0 when comparing.
//
// ----------------------------------------------------------------------
int CmpBinaryToString(
		LPBYTE pBinaryBuffer,		// buffer to contain binary data
		UINT nBinarySize,			// number of bytes this binary has data
		LPCTSTR pstrValue			// string contains data to compare
);

/*
 * FUNCTION:		int atoh(char *ptr)
 * 
 * PURPOSE:			This function converts an hexadecimal string into it's decimal value.
 * 
 * PARAMETERS:
 *
 *		char *ptr:	pointer to string to be converted
 * 
 * RETURNS:			The converted value.
 * 
 * COMMENTS:		Like atoi this function ends the conversion on the first innvalid
 *					hex digit.
 * 
 */
int atoh(LPCSTR ptr);

#define __STRINGUTIL_H_INCLUDED__
#endif // __STRINGUTIL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\trust.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//     	No portion of this source code may be reproduced
//     	without express written permission of Microsoft Corporation.
//
//     	This source code is proprietary and confidential.
//
//	SYSTEM:		Industry Update
//
//	CLASS:		N/A
//	MODULE:		TRUST.LIB
//	FILE:		TRUST.H
//
/////////////////////////////////////////////////////////////////////
//
//	DESC:	this header file declares functions used to make cabs 
//			signed by certain providers trusted.
//
//	AUTHOR:	Charles Ma, converted from WU CDMLIB
//	DATE:	10/4/2000
//
/////////////////////////////////////////////////////////////////////
//
//	Revision History:
//
//	Date        Author    Description
//	~~~~        ~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//	2002-01-18  KenSh     Added revocation check param to VerifyFileTrust
//
/////////////////////////////////////////////////////////////////////
//

#pragma once


//
// define the number of bytes needed to store a SHA1 hashing value
// of the public key
//
const UINT HASH_VAL_SIZE = 20;		

//
// define structure used to pass in the hash values to the following
// function in order to detect if one of the hash matches the
// public key of the leaf cert of a file.
//
typedef struct _HASH_STRUCT {
	UINT uiCount;
	PBYTE pCerts;
} CERT_HASH_ARRAY, *pCERT_HASH_ARRAY;


/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFileTrust()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			pbSha1HashVae - a pointer to a 20 byte long buffer, containing
//							the signature SHA1 hashing value that should
//							be used to check this file, or NULL for checking
//							known Microsoft cert.
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, or
//						 (2) properly signed with a non-MS cert
//          fCheckRevocation - whether the certificat revocation list (CRL) is
//                             checked to see whether any of the certs in the chain
//                             have been revoked. Never prompts the user to initiate
//                             a dial-up connection. Default = FALSE.
//
// Return:	HRESULT - S_OK the file is signed with a valid cert
//					  or error code.
//					  If the file is signed correctly but cert is not
//					  a known Microsoft cert, or it's SHA1 hash does not match
//					  the one passed in, then CERT_UNTRUSTED_ROOT is returned.
//
// Good Cert: Here is the deifnition of a good cert, in addition to the fact
//			  that the signature must be valid and not expired.
//				(1) The signature was signed with a cert that has 
//					"Microsoft Root Authority" as root, or
//				(2) Parameter pbSha1HashVal is not NULL, and the file's SHA1
//					hashing value of signature matches this value, or
//				(3) The signature was signed with one of the following known
//					Microsoft cert's (they are not rooted to MS) and 
//					pbSha1HashVal is NULL.
//					* Microsoft Corporation
//					* Microsoft Corporation MSN
//					* MSNBC Interactive News LLC
//					* Microsoft Corporation MSN (Europe)
//					* Microsoft Corporation (Europe)
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFileTrust(
						IN LPCTSTR			szFileName, 
						IN pCERT_HASH_ARRAY	pHashArray,
						BOOL				fShowBadUI,
						BOOL                fCheckRevocation = FALSE
						);


/////////////////////////////////////////////////////////////////////////////
// 
// Public Function ReadWUPolicyShowTrustUI()
//
// Input:	void
//
// Return:	BOOL - FALSE means ShowTrustUI regkey is not present, or is set to 0
//                     TRUE means ShowTrustUI regkey is present and is set to 1
//
//
/////////////////////////////////////////////////////////////////////////////
BOOL ReadWUPolicyShowTrustUI();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\timeutil.h ===
#pragma once
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <limits.h>
#include <mistsafe.h>

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

const TCHAR EOS = _T('\0');
const WCHAR WEOS = L'\0';
const int NanoSec100PerSec = 10000000;      // number of 100 nanoseconds per second

////////////////////////////////////////////////////////////////////////////
//
// Function  TimeDiff(tm1, tm2)
//          helper function to find the difference (in seconds) of 2 system times
//
// Input:   2 SYSTEMTIME structures
// Output:  None
// Return:  seconds of difference
//              > 0 if tm2 is later than tm1
//              = 0 if tm2 and tm1 are the same
//              < 0 if tm2 is earlier than tm1
//
// On error the function returns 0 even if the two times are not equal
//
// Comment: If the number of seconds goes beyond INT_MAX (that is 
//          more than 24,855 days, INT_MAX is returned.
//          If the number of seconds goes beyond INT_MIN (a negative value,
//          means 24,855 days ago), INT_MIN is returned.
//
////////////////////////////////////////////////////////////////////////////
int TimeDiff(SYSTEMTIME tm1, SYSTEMTIME tm2);


////////////////////////////////////////////////////////////////////////////
//
// Function  TimeAddSeconds(SYSTEMTIME, int, SYSTEMTIME* )
//          helper function to calculate time by adding n seconds to 
//          the given time.
//
// Input:   a SYSTEMTIME as base time, an int as seconds to add to the base time
// Output:  new time
// Return:  HRESULT
//
////////////////////////////////////////////////////////////////////////////
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew);


//Function to convert a string buffer to system time
HRESULT String2SystemTime(LPCTSTR pszDateTime, SYSTEMTIME *ptm);

//Function to convert a system time structure to a string buffer
HRESULT SystemTime2String(SYSTEMTIME & tm, LPTSTR pszDateTime, size_t cSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\urlagent.h ===
//***********************************************************************************
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	UrlAgent.h
//
//  Description:
//
//		This class encapsulates the logic about where to get the right logic
//		for various purposes, including the case of running WU in corporate 
//		environments.
//
//		An object based on this class should be created first, then call
//		GetOriginalIdentServer() function to get where to download ident,
//		then download ident, then call PopulateData() function to read
//		all URL related data.
// 
//
//  Created by: 
//		Charles Ma
//
//	Date Creatd:
//		Oct 19, 2001
//
//***********************************************************************************

#pragma once


class CUrlAgent
{
public:
	
	//
	// constructor/destructor
	//
	CUrlAgent();
	virtual ~CUrlAgent();


	//
	// when instantiated, the object is not populated, 
	// until PopulateData() is called.
	//
	inline BOOL HasBeenPopulated(void) {return m_fPopulated;}

	//
	// this function should be called after you downloaded ident, and get
	// a fresh copy of ident text file from the cab, after verifying cab was
	// signed properly.
	//
	// this function reads data from ident and registry
	//
	HRESULT PopulateData(void);

	//
	// the following are access function to obtain URL's
	//

	//
	// get the original ident server. 
	// *** this API should be called before PopulateData() is called ***
	// *** this API should be called to retrieve the base URL where you download ident ***
	//
	HRESULT GetOriginalIdentServer(
				LPTSTR lpsBuffer, 
				int nBufferSize,
				BOOL* pfInternalServer = NULL);

	//
	// get the ping/status server
	// *** this API should be called after PopulateData() is called ***
	//
	HRESULT GetLivePingServer(
				LPTSTR lpsBuffer, 
				int nBufferSize);

	// *** this API can be called before PopulateData() is called ***
	HRESULT GetCorpPingServer(
				LPTSTR lpsBuffer, 
				int nBufferSize);

	//
	// get the query server. this is per client based
	// *** this API should be called after PopulateData() is called ***
	//
	HRESULT GetQueryServer(
				LPCTSTR lpsClientName, 
				LPTSTR lpsBuffer, 
				int nBufferSize,
				BOOL* pfInternalServer = NULL);
	
	//
	// tell if a particular client is controlled by policy in corporate
	// returns: 
	//			S_OK = TRUE
	//			S_FALSE = FALSE
	//			other = error, so don't know
	//
	HRESULT IsClientSpecifiedByPolicy(
				LPCTSTR lpsClientName
				);
	//
	// when client isn't available, is IU controlled by policy in corporate?
	// returns: 
	//			S_OK = TRUE
	//			S_FALSE = FALSE
	//			other = error, so don't know
	//
	HRESULT IsIdentFromPolicy();

private:

	typedef struct _ServerPerClient {
				LPTSTR	pszClientName;	
				LPTSTR	pszQueryServer;
				BOOL	fInternalServer;
	} ServerPerClient, *PServerPerClient;

	BOOL				m_fPopulated;			// whether this object has been populated
	LPTSTR				m_pszWUServer;			// WU server defined in policy, if any
	LPTSTR				m_pszInternetPingUrl;	// ping server
	LPTSTR				m_pszIntranetPingUrl;
	
	PServerPerClient	m_ArrayUrls;
	int					m_nArrayUrlCount;		// how many we data slot we used
	int					m_nArraySize;			// current size of this array

	//
	// private functions
	//
	void DesertData(void);

	//
	// helper function
	// 
	LPTSTR RetrieveIdentStrAlloc(
						LPCTSTR pSection,
						LPCTSTR pEntry,
						LPDWORD lpdwSizeAllocated,
						LPCTSTR lpszIdentFile);
	
	//
	// helper function
	// if there is no empty slot, double the size of url array
	//
	HRESULT ExpandArrayIfNeeded(void);

protected:
	
	HANDLE				m_hProcHeap;
	BOOL				m_fIdentFromPolicy;		// tell if original ident url based on policy setup
	LPTSTR				m_pszOrigIdentUrl;		// this one should always have it, no matter population
	int					m_nOrigIdentUrlBufSize;	// in tchar count
	BOOL				m_fIsBetaMode;
};


class CIUUrlAgent : public CUrlAgent
{
public:
	//
	// constructor/destructor
	//
	CIUUrlAgent();
	~CIUUrlAgent();

	// call base class PopulateData() and then populate self-update url
	HRESULT PopulateData(void);

	//
	// get the self-update server. 
	// *** this API should be called after PopulateData() is called ***
	//
	HRESULT GetSelfUpdateServer(
				LPTSTR lpsBuffer, 
				int nBufferSize,
				BOOL* pfInternalServer = NULL);

private:
	LPTSTR				m_pszSelfUpdateUrl;		// self-update server
	BOOL				m_fIUPopulated;			// whether this object has been populated

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\wubios.h ===
/*** wubios.h - WindowsUpdate BIOS Scanning VxD Public Definitions
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _WUBIOS_H
#define _WUBIOS_H

//Type definitions
/*XLATOFF*/
#include "acpitabl.h"
#include "smbios.h"
typedef struct _ACPITABINFO
{
    DWORD dwTabSig;
    DWORD dwPhyAddr;
    DESCRIPTION_HEADER dh;
} ACPITABINFO, *PACPITABINFO;
/*XLATON*/

/*** Constants
 */

//W32 Device IO Control Code
#define WUBIOCTL_GET_VERSION			1
#define WUBIOCTL_GET_ACPI_TABINFO		2
#define WUBIOCTL_GET_ACPI_TABLE			3
#define WUBIOCTL_GET_SMB_STRUCTSIZE		4
#define WUBIOCTL_GET_SMB_STRUCT			5
#define WUBIOCTL_GET_PNP_OEMID			6

//Miscellaneous Constants
#define WUBIOS_MAJOR_VER		0x01
#define WUBIOS_MINOR_VER		0x00

#define WUBIOS_VERSION			((WUBIOS_MAJOR_VER << 8) | WUBIOS_MINOR_VER)


#endif  //ifndef _ACPITAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\urllogging.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	URLLogging.h
//
//  Description:
//
//		URL logging utility class
//		This class helps you construct the server ping URL and
//		then send the ping to the designed server.
//
//		The default base URL is defined in IUIdent, under section [IUPingServer]
//		and entry is "ServerUrl".
//
//		This class implements single-thread version only. So it is suitable
//		to call it at operation level, i.e., create a separate object
//		for each operation in a single thread.
//
//		The ping string send to the ping server has the following format:
//			/wutrack.bin
//			?U=<user>
//			&C=<client>
//			&A=<activity>
//			&I=<item>
//			&D=<device>
//			&P=<platform>
//			&L=<language>
//			&S=<status>
//			&E=<error>
//			&M=<message>
//			&X=<proxy>
//		where
//			<user>		a static 128-bit value that unique-ifies each copy
//						of Windows installed.  The class will automatically
//						reuse one previously assigned to the running OS; or
//						will generate one if it does not exist.
//			<client>	a string that identifies the entity that performed
//						activity <activity>.  Here are the possible values
//						and their meanings:
//							"iu"			IU control
//							"au"			Automatic Updates
//							"du"			Dynamic Update
//							"CDM"			Code Download Manager
//							"IU_SITE"		IU Consumer site
//							"IU_Corp"		IU Catalog site
//			<activity>	a letter that identifies the activity performed.
//						Here are the possible values and their meanings:
//							"n"				IU control initization
//							"d"				detection
//							"s"				self-update
//							"w"				download
//							"i"				installation
//			<item>		a string that identifies an update item.
//			<device>	a string that identifies either a device's PNPID when
//						device driver not found during detection; or a
//						PNPID/CompatID used by item <item> for activity
//						<activity> if the item is a device driver.
//			<platform>	a string that identifies the platform of the running
//						OS and processor architecture.  The class will
//						compute this value for the pingback.
//			<language>	a string that identifies the language of the OS
//						binaries.  The class will compute this value for the
//						pingback.
//			<status>	a letter that specifies the status that activity
//						<activity> reached.  Here are the possible values and
//						 their meanings:
//							"s"				succeeded
//							"r"				succeeded (reboot required)
//							"f"				failed
//							"c"				cancelled by user
//							"d"				declined by user
//							"n"				no items
//							"p"				pending
//			<error>		a 32-bit error code in hex (w/o "0x" as prefix).
//			<message>	a string that provides additional information for the
//						status <status>.
//			<proxy>		a 32-bit random value in hex for overriding proxy
//						caching.  This class will compute this value for
//						each pingback.
//
//=======================================================================

#pragma once

typedef CHAR URLLOGPROGRESS;
typedef CHAR URLLOGDESTINATION;
typedef TCHAR URLLOGACTIVITY;
typedef TCHAR URLLOGSTATUS;

#define URLLOGPROGRESS_ToBeSent		((CHAR)  0)
#define URLLOGPROGRESS_Sent			((CHAR) -1)

#define URLLOGDESTINATION_DEFAULT	((CHAR) '?')
#define URLLOGDESTINATION_LIVE		((CHAR) 'l')
#define URLLOGDESTINATION_CORPWU	((CHAR) 'c')

#define URLLOGACTIVITY_Initialization	((URLLOGACTIVITY) L'n')
#define URLLOGACTIVITY_Detection		((URLLOGACTIVITY) L'd')
#define URLLOGACTIVITY_SelfUpdate		((URLLOGACTIVITY) L's')
#define URLLOGACTIVITY_Download			((URLLOGACTIVITY) L'w')
#define URLLOGACTIVITY_Installation		((URLLOGACTIVITY) L'i')

#define URLLOGSTATUS_Success	((URLLOGSTATUS) L's')
#define URLLOGSTATUS_Reboot		((URLLOGSTATUS) L'r')
#define URLLOGSTATUS_Failed		((URLLOGSTATUS) L'f')
#define URLLOGSTATUS_Cancelled	((URLLOGSTATUS) L'c')
#define URLLOGSTATUS_Declined	((URLLOGSTATUS) L'd')
#define URLLOGSTATUS_NoItems	((URLLOGSTATUS) L'n')
#define URLLOGSTATUS_Pending	((URLLOGSTATUS) L'p')

typedef struct tagURLENTRYHEADER
{
	URLLOGPROGRESS progress;	// Whether this entry has been sent
	URLLOGDESTINATION destination;
	WORD wRequestSize;		// in WCHARs
	WORD wServerUrlLen;	// in WCHARs
} ULENTRYHEADER, PULENTRYHEADER;

class CUrlLog
{
public:
	CUrlLog(void);
	CUrlLog(
		LPCTSTR	ptszClientName,
		LPCTSTR	ptszLiveServerUrl,	// from iuident
		LPCTSTR ptszCorpServerUrl);	// from Federated WU domain policy

	~CUrlLog(void);

	BOOL SetDefaultClientName(LPCTSTR ptszClientName);

	inline BOOL SetLiveServerUrl(LPCTSTR ptszLiveServerUrl)
	{
		return SetServerUrl(ptszLiveServerUrl, m_ptszLiveServerUrl);
	}

	inline BOOL SetCorpServerUrl(LPCTSTR ptszCorpServerUrl)
	{
		return SetServerUrl(ptszCorpServerUrl, m_ptszCorpServerUrl);
	}

	HRESULT Ping(
				BOOL fOnline,					// online or offline ping
				URLLOGDESTINATION destination,	// live or corp WU ping server
				PHANDLE phQuitEvents,			// ptr to handles for cancelling the operation
				UINT nQuitEventCount,			// number of handles
				URLLOGACTIVITY activity,		// activity code
				URLLOGSTATUS status,			// status code
				DWORD dwError = 0x0,			// error code
				LPCTSTR ptszItemID = NULL,		// uniquely identify an item
				LPCTSTR ptszDeviceID = NULL,	// PNPID or CompatID
				LPCTSTR tszMessage = NULL,		// additional info
				LPCTSTR ptszClientName = NULL);	// client name string

	// Send all pending (offline) ping requests to server
	HRESULT Flush(PHANDLE phQuitEvents, UINT nQuitEventCount);

protected:
	LPTSTR m_ptszLiveServerUrl;
	LPTSTR m_ptszCorpServerUrl;

private:
	TCHAR	m_tszLogFile[MAX_PATH];
//	TCHAR	m_tszTmpLogFile[MAX_PATH];
	TCHAR	m_tszDefaultClientName[64];
	TCHAR	m_tszPlatform[8+1+8+1+8+1+8+1+4+1+4+1+4 + 1];
	TCHAR	m_tszLanguage[8+1+8 + 1];	// according to RFC1766
	TCHAR	m_tszPingID[sizeof(UUID) * 2 + 1];

	// Common init routine
	void Init(void);

	// Set URL for live or corp WU ping server
	BOOL SetServerUrl(LPCTSTR ptszUrl, LPTSTR & ptszServerUrl);

	// Obtain file names for offline ping
	void GetLogFileName(void);

	// Obtain the existing ping ID from the registry, or generate one if not available.
	void LookupPingID(void);

	// Obtain platfrom info for ping
	void LookupPlatform(void);

	// Obtain system language info for ping
	void LookupSystemLanguage(void);

	// Construct a URL used to ping server
	HRESULT MakePingUrl(
				LPTSTR ptszUrl,			// buffer to receive result
				int cChars,				// the number of chars this buffer can take, including ending null
				LPCTSTR ptszBaseUrl,	// server URL
				LPCTSTR ptszClientName,	// which client called
				URLLOGACTIVITY activity,
				LPCTSTR	ptszItemID,
				LPCTSTR ptszDeviceID,
				URLLOGSTATUS status,
				DWORD dwError,			// result of download. SUCCESS if S_OK or ERROR_SUCCESS
				LPCTSTR ptszMessage);

	// Ping server to report status
	HRESULT PingStatus(URLLOGDESTINATION destination, LPCTSTR ptszUrl, PHANDLE phQuitEvents, UINT nQuitEventCount) const;

	// Read a ping entry from the given file handle
	HRESULT ReadEntry(HANDLE hFile, ULENTRYHEADER & ulentryheader, LPWSTR pwszBuffer, DWORD dwBufferSize) const;

	// Save a ping entry into the log file
	HRESULT SaveEntry(ULENTRYHEADER & ulentryheader, LPCWSTR pwszString) const;
};



// Escape unsafe chars in a TCHAR string
BOOL EscapeString(
		LPCTSTR ptszUnescaped,
		LPTSTR ptszBuffer,
		DWORD dwCharsInBuffer);



// ----------------------------------------------------------------------------------
// IsConnected()
//          detect if there is a connection currently that can be used to
//          connect to Windows Update site.
//          If yes, we activate the shedule DLL
//
// Input :  ptszUrl - Url containing host name to check for connection
//			fLive - whether the destination is the live site
// Output:  None
// Return:  TRUE if we are connected and we can reach the web site.
//          FALSE if we cannot reach the site or we are not connected.
// ----------------------------------------------------------------------------------

BOOL IsConnected(LPCTSTR ptszUrl, BOOL fLive);



// ----------------------------------------------------------------------------------
// MakeUUID()
//			create a UUID that is not linked to MAC address of a NIC, if any, on the
//			system.
//
// Input :	pUuid - ptr to the UUID structure to hold the returning value.
// ----------------------------------------------------------------------------------
void MakeUUID(UUID* pUuid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\waitutil.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   WaitUtil.h
//
//  Description:
//
//      IU wait message utility library, providing thin wrapper of wait
//		message loop
//
//=======================================================================


#ifndef __WAITUTIL_H_INCLUDED__

#include <windows.h>


/////////////////////////////////////////////////////////////////////////////
// Helper function WaitAndPumpMessages()
/////////////////////////////////////////////////////////////////////////////
DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask);

/////////////////////////////////////////////////////////////////////////////
// Helper function MyMsgWaitForMultipleObjects()
// to process messages while waiting for an object
///////////////////////////////////////////////////////////////////////////////
DWORD MyMsgWaitForMultipleObjects(DWORD nCount, LPHANDLE pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);

#define __WAITUTIL_H_INCLUDED__
#endif // __WAITUTIL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\wuiutest.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   wuiutest.h
//
//  Description:
//
//      Defines used for test builds.
//
//		NOTE:	To add test features to a build define the following
//				in your build environment before building (can be any
//				combination of chk, fre, ANSI, or Unicode):
//
//				set USER_C_FLAGS=$(USER_C_FLAGS) /D__WUIUTEST=1
//
//=======================================================================

#ifndef __IU_WUIUTEST_INC__
#define __IU_WUIUTEST_INC__

#ifdef __WUIUTEST

#include <tchar.h>
//
// Reg key containing values used by builds compiled with __WUIUTEST defined
//
const TCHAR REGKEY_WUIUTEST[]				= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuiutest");
//
// Allow CDM to download drivers even if DriverVer is equal (but not less-than) installed driver
//
const TCHAR REGVAL_ALLOW_EQUAL_DRIVERVER[]	= _T("AllowEqualDriverVer");
//
// Override OS or USER LANGID
//
const TCHAR REGVAL_OS_LANGID[]				= _T("OsLangID");
const TCHAR REGVAL_USER_LANGID[]			= _T("UserLangID");
//
// Override DetectClientIUPlatform OSVERSIONINFO params
//
const TCHAR REGVAL_MAJORVER[]				= _T("OsVerMajorVersion");
const TCHAR REGVAL_MINORVER[]				= _T("OsVerMinorVersion");
const TCHAR REGVAL_BLDNUMBER[]				= _T("OsVerBuildNumber");
const TCHAR REGVAL_PLATFORMID[]				= _T("OsVerPlatformID");
const TCHAR REGVAL_SZCSDVER[]				= _T("OsVerSzCSDVersion");
//
// Override DEFAULT_EXPIRED_SECONDS time for deleting downloaded folders
//
const TCHAR REGVAL_DEFAULT_EXPIRED_SECONDS[]	=_T("DownloadExpireSeconds");

#endif //__WUIUTEST

#endif	// __IU_WUIUTEST_INC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\wutestkeys.h ===
#pragma once
#include "timeutil.h"
/***********************************************************************************************************
// This API returns true if a WU Test authorization file exists.
// The api looks for the input file name (lpszFileName) in the WindowsUpdate directory
// The test file has to have the same name as the cab file and should end with the '.txt' extension.
// Moreover it has to be an ascii file. The cab file has to be signed with a valid MS cert.
// This function will delete the extracted text file
************************************************************************************************************/
BOOL WUAllowTestKeys(LPCTSTR lpszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\wusafefn.h ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    wusafefn.h

Abstract:
    definitions for WU safe functions

******************************************************************************/

#pragma once

#include "SafeFile.h"  // file operations (SafeCreateFile, etc.)
#include "SafeReg.h"   // registry operations (SafeRegQueryStringValueCch, etc.)

// path manipulation
HRESULT PathCchCombineA(LPSTR  szPath, DWORD cchPathBuff, LPCSTR  szPrefix, LPCSTR  szSuffix);
HRESULT PathCchCombineW(LPWSTR szPath, DWORD cchPathBuff, LPCWSTR szPrefix, LPCWSTR szSuffix);
HRESULT PathCchAppendA(LPSTR  szPath, DWORD cchPathBuff, LPCSTR  szNew);
HRESULT PathCchAppendW(LPWSTR szPath, DWORD cchPathBuff, LPCWSTR szNew);
HRESULT PathCchAddBackslashA(LPSTR  szPath, DWORD cchPathBuff);
HRESULT PathCchAddBackslashW(LPWSTR szPath, DWORD cchPathBuff);
HRESULT PathCchCanonicalizeA(LPSTR  pszDest, DWORD cchDest, LPCSTR  pszSrc);
HRESULT PathCchCanonicalizeW(LPWSTR pszDest, DWORD cchDest, LPCWSTR pszSrc);
HRESULT PathCchAddExtensionA(LPSTR  pszPath, DWORD cchPath, LPCSTR  pszExt);
HRESULT PathCchAddExtensionW(LPWSTR pszPath, DWORD cchPath, LPCWSTR pszExt);
HRESULT PathCchRenameExtensionA(LPSTR  pszPath, DWORD cchPath, LPCSTR  pszExt);
HRESULT PathCchRenameExtensionW(LPWSTR pszPath, DWORD cchPath, LPCWSTR pszExt);

#if defined(UNICODE) || defined(_UNICODE)
#define PathCchCombine PathCchCombineW
#define PathCchAppend PathCchAppendW
#define PathCchAddBackslash PathCchAddBackslashW
#define PathCchCanonicalize PathCchCanonicalizeW
#define PathCchAddExtension PathCchAddExtensionW
#define PathCchRenameExtension PathCchRenameExtensionW
#else
#define PathCchCombine PathCchCombineA
#define PathCchAppend  PathCchAppendA
#define PathCchAddBackslash PathCchAddBackslashA
#define PathCchCanonicalize PathCchCanonicalizeA
#define PathCchAddExtension PathCchAddExtensionA
#define PathCchRenameExtension PathCchRenameExtensionA
#endif


// Load library
HMODULE WINAPI LoadLibraryFromSystemDir(LPCTSTR szModule);


// Critical sections

// Spin count passed to InitializeCriticalSectionAndSpinCount
#define DEFAULT_CS_SPIN_COUNT 0x80000FA0

BOOL WINAPI WUInitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpcs, DWORD dwSpinCount);

inline BOOL WINAPI SafeInitializeCriticalSection(LPCRITICAL_SECTION lpcs)
{
	return WUInitializeCriticalSectionAndSpinCount(lpcs, DEFAULT_CS_SPIN_COUNT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\detection.cpp ===
// Detection.cpp : Implementation of CDetection
#include "stdafx.h"
#include "IUCtl.h"
#include "Detection.h"

/////////////////////////////////////////////////////////////////////////////
// CDetection


STDMETHODIMP CDetection::Detect(BSTR bstrXML, DWORD *pdwDetectionResult)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\inc\wuverp.h ===
//
// The purpose of this include file is to change the minor version number for
// Windows Update components from 1 (Whistler) to 4.
//
#include <windows.h>
#include <ntverp.h>

// Override ntverp.h
// Minor version 4 is Windows Update specific, Whistler is minor version 1.
#undef VER_PRODUCTMINORVERSION
#define VER_PRODUCTMINORVERSION     4

// Override the build number when the Windows Update build lab is building.
#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#define VER_PRODUCTBUILD 3630
#endif


// Override the QFE number when the Windows Update build lab is building.
//#ifdef VER_PRODUCTBUILD_QFE
//#undef VER_PRODUCTBUILD_QFE
//#include "wubldnum.h"
//#endif

#undef VER_PRODUCTVERSION_STRING   
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#undef VER_PRODUCTVERSION          
#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define WU_VER_FILEDESCRIPTION_STR(component) "Windows Update " component
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\evtmsgwnd.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//	File: EvtMsgWnd.h: interface for the CEventMsgWindow class.
//
//	Description:
//		This window class is used to handle all event firing
//		messages posted during downloading/installation.
//
//		all custom message IDs are defined in this file too,
//		as well as the structure to pass event data
//		
//	Created by: Charles Ma
//				6/18/1999
//
//=======================================================================

#ifndef __EVTMSGWND_H_
#define __EVTMSGWND_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <shellapi.h>
#include <atlwin.h>
#include <iu.h>

/////////////////////////////////////////////////////////////////////////////
// class forward declaration
/////////////////////////////////////////////////////////////////////////////
class CUpdate;



/////////////////////////////////////////////////////////////////////////////
// CEventMsgWindow
class CEventMsgWindow :	public CWindowImpl<CEventMsgWindow>
{
public:

	/////////////////////////////////////////////////////////////////////////////
	// Construction/Destruction
	/////////////////////////////////////////////////////////////////////////////
	CEventMsgWindow(CUpdate* pControl) : m_pControl(pControl), m_hWnd(NULL)
	{
	}

	virtual ~CEventMsgWindow()
	{
	};

	/////////////////////////////////////////////////////////////////////////////
	// override method
	//
	// we need to create a popup window - a control can not create
	// a top-level child window
	//
	/////////////////////////////////////////////////////////////////////////////
	void Create();

	/////////////////////////////////////////////////////////////////////////////
	// destroy the window
	/////////////////////////////////////////////////////////////////////////////
	void Destroy();

	/////////////////////////////////////////////////////////////////////////////
	// get evt window handler
	/////////////////////////////////////////////////////////////////////////////
	HWND GetEvtHWnd() { return m_hWnd; };

	/////////////////////////////////////////////////////////////////////////////
	// message maps define all messages we handled in this class
	/////////////////////////////////////////////////////////////////////////////
	BEGIN_MSG_MAP(CEventMsgWindow)
		MESSAGE_HANDLER(UM_EVENT_ITEMSTART,				OnFireEvent)
		MESSAGE_HANDLER(UM_EVENT_PROGRESS,				OnFireEvent)
		MESSAGE_HANDLER(UM_EVENT_COMPLETE,				OnFireEvent)
		MESSAGE_HANDLER(UM_EVENT_SELFUPDATE_COMPLETE,	OnFireEvent)
	END_MSG_MAP()

	/////////////////////////////////////////////////////////////////////////////
	// message handlers
	/////////////////////////////////////////////////////////////////////////////
	LRESULT OnFireEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
	//
	// disable the default constructor
	//
	CEventMsgWindow() {};

	HWND		m_hWnd;
	CUpdate*	m_pControl;
};

#endif //__EVTMSGWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\detection.h ===
//==========================================================================
//
// Copyright (c) 1998-2000 Microsoft Corporation. 
// All Rights Reserved.
//
// File: Detection.h : 
//		 Declaration of the CDetection class
//		 CDetection declares COM interface IDetection
//
// IDetection is a class defined here without any implementation.
// It defines the template that the content provider should
// implement if they want to provide detection features beyong
// the current detection mechanism defined in the catalog schema.
//
//==========================================================================

#ifndef __DETECTION_H_
#define __DETECTION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDetection
class ATL_NO_VTABLE CDetection : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDetection, &CLSID_Detection>,
	public IDispatchImpl<IDetection, &IID_IDetection, &LIBID_IUCTLLib>
{
public:
	CDetection()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DETECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDetection)
	COM_INTERFACE_ENTRY(IDetection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDetection
public:

	STDMETHOD(Detect)(
			/*[in]*/ BSTR bstrXML,				/* detection portion of manifest where
												 * the COM server is called */
			/*[out]*/ DWORD *pdwDetectionResult /* the result of detection, see below
												 * for interpretations */
	);

	/**

	//
	// deckare the constants used to manipulate the result of Detect() method
	//

	//
	// First group, used in <expression> tag, to tell the detection result. This result
	// should combined with other expression(s) at the same level
	//
	const DWORD     IUDET_BOOL              = 0x00000001;	// mask 
	const DWORD     IUDET_FALSE             = 0x00000000;	// expression detect FALSE 
	const DWORD     IUDET_TRUE              = 0x00000001;	// expression detect TRUE 
	const DWORD     IUDET_NULL              = 0x00000002;	// expression detect data missing

	//
	// Second group, used in <detection> tag, to tell the detection result. This result
	// should overwrite the rest of <expression>, if any
	//
	const DWORD     IUDET_INSTALLED			= 0x00000010;	// mask for <installed> result
	const DWORD     IUDET_INSTALLED_NULL	= 0x00000020;	// <installed> missing 
	const DWORD     IUDET_UPTODATE			= 0x00000040;	// mask for <upToDate> result 
	const DWORD     IUDET_UPTODATE_NULL		= 0x00000080;	// <upToDate> missing 
	const DWORD     IUDET_NEWERVERSION		= 0x00000100;	// mask for <newerVersion> result 
	const DWORD     IUDET_NEWERVERSION_NULL	= 0x00000200;	// <newerVersion> missing
	const DWORD     IUDET_EXCLUDED			= 0x00000400;	// mask for <excluded> result
	const DWORD     IUDET_EXCLUDED_NULL		= 0x00000800;	// <excluded> missing
	const DWORD     IUDET_FORCE				= 0x00001000;	// mask for <force> result 
	const DWORD     IUDET_FORCE_NULL		= 0x00002000;	// <force> missing
	const DWORD		IUDET_COMPUTER			= 0x00004000;	// mask for <computerSystem> result
	const DWORD		IUDET_COMPUTER_NULL		= 0x00008000;	// <computerSystem> missing

	**/
};

#endif //__DETECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\iuctl.cpp ===
// IUCtl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f IUCtlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "IUCtl.h"

#include "IUCtl_i.c"
#include "Update.h"
#include "ProgressListener.h"
#include "Detection.h"
#include "UpdateCompleteListener.h"
#include <UrlAgent.h>
#include <FreeLog.h>
#include <wusafefn.h>

CComModule _Module;

HANDLE g_hEngineLoadQuit;

CIUUrlAgent *g_pIUUrlAgent;
CRITICAL_SECTION g_csUrlAgent;	// used to serialize access to CIUUrlAgent::Populate()
BOOL g_fInitCS;


//extern "C" const CLSID CLSID_Update2 = {0x32BF9AC1,0xB122,0x4fed,{0xB3,0xC7,0x2D,0xA5,0x20,0xDF,0x2B,0x4E}};

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Update, CUpdate)
//OBJECT_ENTRY(CLSID_Update2, CUpdate)
OBJECT_ENTRY(CLSID_ProgressListener, CProgressListener)
OBJECT_ENTRY(CLSID_Detection, CDetection)
OBJECT_ENTRY(CLSID_UpdateCompleteListener, CUpdateCompleteListener)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		//
		// create a global CIUUrlAgent object
		//
		g_pIUUrlAgent = new CIUUrlAgent;
		if (NULL == g_pIUUrlAgent)
		{
			return FALSE;
		}

		_Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

		g_fInitCS = SafeInitializeCriticalSection(&g_csUrlAgent);

		//
		// Initialize free logging
		//
		InitFreeLogging(_T("IUCTL"));
		LogMessage("Starting");

        g_hEngineLoadQuit = CreateEvent(NULL, TRUE, FALSE, NULL);

		if (!g_fInitCS || NULL == g_hEngineLoadQuit)
		{
			LogError(E_FAIL, "InitializeCriticalSection or CreateEvent");
			return FALSE;
		}
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		if (g_fInitCS)
		{
			DeleteCriticalSection(&g_csUrlAgent);
		}
		
		//
		// Shutdown free logging
		//
		LogMessage("Shutting down");
		TermFreeLogging();

        if (NULL != g_hEngineLoadQuit)
        {
            CloseHandle(g_hEngineLoadQuit);
        }

		if (NULL != g_pIUUrlAgent)
		{
			delete g_pIUUrlAgent;
		}

        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(&CLSID_Update);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\iuctlcp.h ===
#ifndef _IUCTLCP_H_
#define _IUCTLCP_H_

#include <assert.h>
#define QuitIfNull(ptr)			if (NULL == ptr) return	// TO DO: add logging if quit

template <class T>
class CProxyIUpdateEvents : public IConnectionPointImpl<T, &DIID_IUpdateEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:

	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnItemStart()
	//
	// fire event to notify that this item is about to be downloaded.
	// and (in VB) plCommandRequest can be set to pause or cancel the
	// whole download/install operation
	//
	// Input:
    // bstrUuidOperation - the operation identification guid
    // bstrXmlItem - item XML node in BSTR 
	// Output:
    // plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnItemStart(BSTR			bstrUuidOperation,
						 BSTR			bstrXmlItem,
						 LONG*			plCommandRequest)
	{
		VARIANTARG* pvars = new VARIANTARG[3];
		QuitIfNull(pvars);

		for (int i = 0; i < 3; i++)
		{
			VariantInit(&pvars[i]);
		}

		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[2].vt = VT_BSTR;
				pvars[2].bstrVal = bstrUuidOperation;
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal = bstrXmlItem;
				pvars[0].vt = VT_I4 | VT_BYREF;
				pvars[0].byref = plCommandRequest;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}



	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnProgress()
	//
    // Notify the listener that a portion of the files has finished operation
	// (e.g downloaded or installed). Enables monitoring of progress.
	// Input:
    // bstrUuidOperation - the operation identification guid
    // fItemCompleted - TRUE if the current item has completed the operation
    // nPercentComplete - total percentage of operation completed
	// Output:
    // plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnProgress(BSTR			bstrUuidOperation,
						 VARIANT_BOOL	fItemCompleted,
						 BSTR			bstrProgress,
						 LONG*			plCommandRequest)
	{
		VARIANTARG* pvars = new VARIANTARG[4];
		QuitIfNull(pvars);

		for (int i = 0; i < 4; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[3].vt = VT_BSTR;
				pvars[3].bstrVal = bstrUuidOperation;
				pvars[2].vt = VT_BOOL;
				pvars[2].boolVal = fItemCompleted;
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal = bstrProgress;
				pvars[0].vt = VT_I4 | VT_BYREF;
				pvars[0].byref = plCommandRequest;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	
	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnOperationComplete()
	//
	// Notify the listener when the operation is complete.
	// Input:
	// bstrUuidOperation - the operation identification guid
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnOperationComplete(BSTR	bstrUuidOperation, BSTR bstrXmlItems)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		QuitIfNull(pvars);

		VariantInit(&pvars[0]);
		VariantInit(&pvars[1]);

		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal = bstrUuidOperation;
				pvars[0].vt = VT_BSTR;
				pvars[0].bstrVal = bstrXmlItems;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	/////////////////////////////////////////////////////////////////////////////
	// Fire_OnSelfUpdateComplete()
	//
	// Notify the listener when the operation is complete.
	// Input:
	// bstrUuidOperation - the operation identification guid
	/////////////////////////////////////////////////////////////////////////////
    void Fire_OnSelfUpdateComplete(LONG lErrorCode)
	{
		VARIANTARG var;

		VariantInit(&var);

		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp && pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				var.vt = VT_I4;
				var.lVal = lErrorCode;
				DISPPARAMS disp = { &var, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				HRESULT hr = pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
				_ASSERT(S_OK == hr);
			}
			pp++;
		}
		pT->Unlock();
	}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\evtmsgwnd.cpp ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//	File: EvtMsgWnd.cpp: implementation of the CEventMsgWindow class.
//
//	Created by: Charles Ma
//				6/18/1999
//
//=======================================================================
#include "stdafx.h"
#include "EvtMsgWnd.h"
#include "Update.h"
#include <logging.h>
#include <atlwin.cpp>


/////////////////////////////////////////////////////////////////////////////
// CEventMsgWindow

/////////////////////////////////////////////////////////////////////////////
// override method
//
// we need to create a popup window - a control can not create
// a top-level child window
//
/////////////////////////////////////////////////////////////////////////////
void CEventMsgWindow::Create()
{
	if (NULL == m_pControl)
		return;

	//
	// make the window size 1 pixel 
	//
	RECT rcPos;
	rcPos.left = 0;
	rcPos.top = 0;
	rcPos.bottom = 1;
	rcPos.right = 1;

	//
	// call base class method, with WS_POPUP style
	//
	m_hWnd = CWindowImpl<CEventMsgWindow>::Create(NULL, rcPos, _T("EventWindow"), WS_POPUP);
}


/////////////////////////////////////////////////////////////////////////////
// destroy the window
/////////////////////////////////////////////////////////////////////////////
void CEventMsgWindow::Destroy()
{
	if (NULL != m_hWnd)
	{
		m_hWnd = NULL;
		CWindowImpl<CEventMsgWindow>::DestroyWindow();
	}
}


/////////////////////////////////////////////////////////////////////////////
// message handlers
/////////////////////////////////////////////////////////////////////////////
LRESULT CEventMsgWindow::OnFireEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
#if defined(DBG)
	USES_CONVERSION;
	LOG_Block("OnFireEvent()");
	LOG_Out(_T("Msg=%d"), uMsg);
#endif
	
	//
	// if control is not passed in, we can not fire the event. return E_FAIL
	//
	pEventData pEvtData = NULL;

	if (NULL == m_pControl)
	{
		return E_FAIL;
	}

	switch (uMsg)
	{
	case UM_EVENT_ITEMSTART:
		//
		// this item is about to get downloaded
		//
		pEvtData = (pEventData)lParam;
		if (pEvtData)
		{
			//
			// about to start an item download/install
			//
	#if defined(DBG)
			LOG_Out(_T("About to fire event OnItemStart(%s, <item>, %ld)"),
						OLE2T(pEvtData->bstrUuidOperation),
						pEvtData->lCommandRequest);
			LOG_XmlBSTR(pEvtData->bstrXmlData);
	#endif
			m_pControl->Fire_OnItemStart(pEvtData->bstrUuidOperation, 
										 pEvtData->bstrXmlData,		// this is actually BSTR of an item
										 &pEvtData->lCommandRequest);

	        if (pEvtData->hevDoneWithMessage != NULL)
	            SetEvent(pEvtData->hevDoneWithMessage);
		}
		break;

	case UM_EVENT_PROGRESS:
		//
		// dopwnlaod or install progress
		//
		pEvtData = (pEventData)lParam;
#if defined(DBG)
		LOG_Out(_T("About to fire event OnProgress(%s, %d, %s, %ld)"),
					OLE2T(pEvtData->bstrUuidOperation),
					pEvtData->fItemCompleted,
					OLE2T(pEvtData->bstrProgress),
					pEvtData->lCommandRequest);
#endif
		if (pEvtData)
		{
			m_pControl->Fire_OnProgress(pEvtData->bstrUuidOperation,
										pEvtData->fItemCompleted,
										pEvtData->bstrProgress,
										&pEvtData->lCommandRequest);

	        if (pEvtData->hevDoneWithMessage != NULL)
	            SetEvent(pEvtData->hevDoneWithMessage);
		}
		break;
	case UM_EVENT_COMPLETE:
		//
		// download or install operation complete
		//
		pEvtData = (pEventData)lParam;
#if defined(DBG)
		LOG_Out(_T("About to fire event OnOperationComplete(%s, result)"),
					OLE2T(pEvtData->bstrUuidOperation));
		LOG_XmlBSTR(pEvtData->bstrXmlData);
#endif
		if (pEvtData)
		{
			m_pControl->Fire_OnOperationComplete(pEvtData->bstrUuidOperation, pEvtData->bstrXmlData);
 	        if (pEvtData->hevDoneWithMessage != NULL)
	            SetEvent(pEvtData->hevDoneWithMessage);
		}
		break;
	case UM_EVENT_SELFUPDATE_COMPLETE:
		//
		// the lParam should be the error code
		//
#if defined(DBG)
		LOG_Out(_T("About to fire event OnSelfUpdateComplete(%ld)"), (LONG)lParam);
#endif
		m_pControl->Fire_OnSelfUpdateComplete((LONG)lParam);
		break;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\iudl.cpp ===
#include "stdafx.h"
#include <iucommon.h>
#include <trust.h>
#include <logging.h>
#include <fileutil.h>
#include "iudl.h"
#include <download.h>
#include <UrlAgent.h>

extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;

HRESULT IUDownloadFile(LPCTSTR pszDownloadUrl, 
                       LPCTSTR pszLocalFile,  
                       BOOL fDecompress, 
                       BOOL fCheckTrust, 
                       DWORD dwFlags)
{
    LOG_Block("IUDownloadFile()");

    HRESULT hr = S_OK;

	if (FAILED(hr = g_pIUUrlAgent->IsIdentFromPolicy()))
	{
		goto done;
	}

	if (S_FALSE == hr)
	{
		hr = S_OK;
	}
	else // S_OK
	{
		dwFlags |= WUDF_DONTALLOWPROXY;
		LOG_Internet(_T("WUDF_DONTALLOWPROXY set"));
	}

    // do the download
    hr = DownloadFileLite(pszDownloadUrl, pszLocalFile, g_hEngineLoadQuit, dwFlags);
    if (FAILED(hr))
        goto done;

	// check for decompress requested
	if (fCheckTrust)
	{
		if (FAILED(hr = VerifyFileTrust(pszLocalFile, NULL, ReadWUPolicyShowTrustUI())))
		{
            LOG_ErrorMsg(hr);
            
            // The file was not trusted.. delete it.
            DeleteFile(pszLocalFile);
            goto done;
		}
	}

	if (fDecompress)
	{
		TCHAR *pszLocalDir = NULL;
        DWORD cchNeed = _tcslen(pszLocalFile) + 1;

        __try { pszLocalDir = (LPTSTR)_alloca(cchNeed * sizeof(TCHAR)); }
        __except(EXCEPTION_EXECUTE_HANDLER) { pszLocalDir = NULL; }
        if (pszLocalDir == NULL)
        {
            LOG_ErrorMsg(ERROR_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto done;
        }
		
		hr=StringCchCopyEx(pszLocalDir,cchNeed,pszLocalFile,NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
		    LOG_ErrorMsg(hr);
			goto done;
		}

		PathRemoveFileSpec(pszLocalDir);
        IUExtractFiles(pszLocalFile, pszLocalDir);
	}

done:
    return hr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\iudl.h ===
#ifndef IUDL_H
#define IUDL_H

#include <dllite.h>

HRESULT IUDownloadFile(LPCTSTR pszDownloadUrl, 
                       LPCTSTR pszLocalFile,  
                       BOOL fDecompress, 
                       BOOL fCheckTrust, 
                       DWORD dwFlags = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\progresslistener.h ===
// ProgressListener.h : Declaration of the CProgressListener

#ifndef __PROGRESSLISTENER_H_
#define __PROGRESSLISTENER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CProgressListener
class ATL_NO_VTABLE CProgressListener : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CProgressListener, &CLSID_ProgressListener>,
	public IProgressListener
{
public:
	CProgressListener()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROGRESSLISTENER)
DECLARE_NOT_AGGREGATABLE(CProgressListener)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProgressListener)
	COM_INTERFACE_ENTRY(IProgressListener)
END_COM_MAP()

// IProgressListener
public:

	/////////////////////////////////////////////////////////////////////////////
	// OnItemStart()
	//
	// fire event to notify that this item is about to be downloaded.
	// and (in VB) plCommandRequest can be set to pause or cancel the
	// whole download/install operation
	//
	// Input:
	// bstrUuidOperation - the operation identification guid
	// bstrXmlItem - item XML node in BSTR 
	// Output:
	// plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	//
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(OnItemStart)(BSTR	bstrUuidOperation,
						   BSTR	bstrXmlItem,
						   LONG* plCommandRequest);
		
	
	/////////////////////////////////////////////////////////////////////////////
	// OnProgress()
	//
    // Notify the listener that a portion of the files has finished operation
	// (e.g downloaded or installed). Enables monitoring of progress.
	// Input:
    // bstrUuidOperation - the operation identification guid
    // fItemCompleted - TRUE if the current item has completed the operation
    // nPercentComplete - total percentage of operation completed
	// Output:
    // plCommandRequest - a command to pass from the listener to the owner of the event,
	//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(OnProgress)(BSTR			bstrUuidOperation,
						  VARIANT_BOOL	fItemCompleted,
						  BSTR			bstraProgress,
						  LONG*			plCommandRequest);

	/////////////////////////////////////////////////////////////////////////////
	// OnOperationComplete()
	//
	// Notify the listener when the operation is complete.
	// Input:
	// bstrUuidOperation - the operation identification guid
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(OnOperationComplete)(BSTR	bstrUuidOperation, BSTR bstrXmlItems);
};

#endif //__PROGRESSLISTENER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IUCtl.rc
//
#define IDS_PROJNAME                    100
#define IDR_UPDATE                      101
#define IDR_UPDATE2                     102
#define IDR_PROGRESSLISTENER            103
#define IDR_UPDATECOMPLETELISTENER		104
#define IDR_DETECTION                   105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\loadengine.cpp ===
#include "stdafx.h"
#include "iudl.h"
#include "selfupd.h"
#include "loadengine.h"
#include "update.h"
#include <iucommon.h>
#include <logging.h>
#include <shlwapi.h>
#include <fileutil.h>
#include <iu.h>
#include <trust.h>
#include <UrlAgent.h>
#include "wusafefn.h"

extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;


/////////////////////////////////////////////////////////////////////////////
// LoadIUEngine()
//
// load the engine if it's not up-to-date; perform engine's self-update here
//
// NOTE: CDM.DLL assumes LoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
/////////////////////////////////////////////////////////////////////////////
HMODULE WINAPI LoadIUEngine(BOOL fSynch,  BOOL fOfflineMode)
{
    LOG_Block("LoadIUEngine()");
    HRESULT hr = E_FAIL;
	HMODULE hEngineModule = NULL;

	TCHAR szEnginePath[MAX_PATH + 1];
	TCHAR szEngineNewPath[MAX_PATH + 1];
	int cch = 0;
	int iVerCheck = 0;

	if (!fSynch)
	{
		//
		// this version does not accept async load engine
		//
		LOG_ErrorMsg(E_INVALIDARG);
		return NULL;
	}

	LPTSTR ptszLivePingServerUrl = NULL;
	LPTSTR ptszCorpPingServerUrl = NULL;

	if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED(g_pIUUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get corp WU ping server URL"));
			SafeHeapFree(ptszCorpPingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
	}

    // clear the quit event in case this gets called after a previous quit attempt.
    ResetEvent(g_hEngineLoadQuit);

    // This is the first load of the engine for this instance, check for selfupdate first.
    // First step is to check for an updated iuident.cab and download it.

	if (!fOfflineMode)
	{		
		//
		// download iuident and populate g_pIUUrlAgent
		//
		CleanUpIfFailedAndMsg(DownloadIUIdent_PopulateData());

		//
		// get live ping server url
		//
		ptszLivePingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		CleanUpFailedAllocSetHrMsg(ptszLivePingServerUrl);

		if (FAILED(g_pIUUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get live ping server URL"));
			SafeHeapFree(ptszLivePingServerUrl);
		}

		//
		// Now do the self update check
		// for the current implementation, fSync must be TRUE!
		//
		hr = SelfUpdateCheck(fSynch, TRUE, NULL, NULL, NULL);

		if (IU_SELFUPDATE_FAILED == hr)
		{
			LOG_Error(_T("SelfUpdate Failed, using current Engine DLL"));
		}
	}

    if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
    {
        LOG_ErrorMsg(E_ABORT);
        goto CleanUp;
    }

    // try loading iuenginenew.dll first

	//
	// first, contrsuct file path form sys dir
	//
	cch = GetSystemDirectory(szEnginePath, ARRAYSIZE(szEnginePath));
    CleanUpIfFalseAndSetHrMsg(cch == 0 || cch >= ARRAYSIZE(szEnginePath), HRESULT_FROM_WIN32(GetLastError()));

	(void) StringCchCopy(szEngineNewPath, ARRAYSIZE(szEngineNewPath), szEnginePath);

	hr = PathCchAppend(szEnginePath, ARRAYSIZE(szEnginePath), ENGINEDLL);
	CleanUpIfFailedAndMsg(hr);

	hr = PathCchAppend(szEngineNewPath, ARRAYSIZE(szEngineNewPath), ENGINENEWDLL);
	CleanUpIfFailedAndMsg(hr);

	//
	// try to verify trust of engine new
	//
	if (FileExists(szEngineNewPath) && 
		S_OK == VerifyFileTrust(szEngineNewPath, NULL, ReadWUPolicyShowTrustUI()) &&
		SUCCEEDED(CompareFileVersion(szEnginePath, szEngineNewPath, &iVerCheck)) &&
		iVerCheck < 0)
	{
		hEngineModule = LoadLibraryFromSystemDir(ENGINENEWDLL);
		if (NULL != hEngineModule)
		{
			LOG_Internet(_T("IUCtl Using IUENGINENEW.DLL"));
		}
	}
    if (NULL == hEngineModule)
    {
        LOG_Internet(_T("IUCtl Using IUENGINE.DLL"));
        hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));
    }
	//
	// If load engine succeeded, start misc worker threads
	//
	if (NULL != hEngineModule)
	{
		PFN_AsyncExtraWorkUponEngineLoad pfnAsyncExtraWorkUponEngineLoad = 
			(PFN_AsyncExtraWorkUponEngineLoad) GetProcAddress(hEngineModule, "AsyncExtraWorkUponEngineLoad");

		if (NULL != pfnAsyncExtraWorkUponEngineLoad)
		{
			pfnAsyncExtraWorkUponEngineLoad();
		}
		hr = S_OK;
	}

CleanUp:
	PingEngineUpdate(
					hEngineModule,
					&g_hEngineLoadQuit,
					1,
					ptszLivePingServerUrl,
					ptszCorpPingServerUrl,
					hr);

	SafeHeapFree(ptszLivePingServerUrl);
	SafeHeapFree(ptszCorpPingServerUrl);
    return hEngineModule;
}


/////////////////////////////////////////////////////////////////////////////
// UnLoadIUEngine()
//
// release the engine dll if ref cnt of engine is down to zero
//
// NOTE: CDM.DLL assumes UnLoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
//
// NOTE: DeleteEngUpdateInstance must be called before calling this function
//       for any callers EXCEPT CDM (which uses the ShutdownThreads export as
//       a hack to delete the global CDM instance of the CEngUpdate class
//       if it was created by calling SetGlobalOfflineFlag.
/////////////////////////////////////////////////////////////////////////////
void WINAPI UnLoadIUEngine(HMODULE hEngineModule)
{
    LOG_Block("UnLoadIUEngine()");
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szEngineDllPath[MAX_PATH+1];
    TCHAR szEngineNewDllPath[MAX_PATH+1];
	int iVerCheck = 0;

	//
	// the engine might have some outstanding threads working, 
	// so we need to let the engine shut down these threads gracefully
	//
	PFN_ShutdownThreads pfnShutdownThreads = (PFN_ShutdownThreads) GetProcAddress(hEngineModule, "ShutdownThreads");
	if (NULL != pfnShutdownThreads)
	{
		pfnShutdownThreads();
	}


    FreeLibrary(hEngineModule);

	GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));

	
    PathCchCombine(szEngineNewDllPath,ARRAYSIZE(szEngineNewDllPath), szSystemDir, ENGINENEWDLL);
	


    HKEY hkey = NULL;
    DWORD dwStatus = 0;
    DWORD dwSize = sizeof(dwStatus);
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkey))
    {
        RegQueryValueEx(hkey, REGVAL_SELFUPDATESTATUS, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
    }
    if (FileExists(szEngineNewDllPath) && 
		S_OK == VerifyFileTrust(szEngineNewDllPath, NULL, ReadWUPolicyShowTrustUI()) &&
		SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
    {
        // an iuenginenew.dll exists, try replacing the engine.dll This will fail if this is
        // not the last process using the engine. This is not a problem, when that process
        // finishes it will rename the DLL.
		//
		// the check we do before we rename the file:
		//	1. enginenew exists
		//	2. enginenew signed by Microsoft cert
		//	3. enginenew has higher version then iuengine.dll
		//
        PathCchCombine(szEngineDllPath,ARRAYSIZE(szEngineDllPath),szSystemDir, ENGINEDLL);

        if (SUCCEEDED(CompareFileVersion(szEngineDllPath, szEngineNewDllPath, &iVerCheck)) &&
			iVerCheck < 0 &&
			TRUE == MoveFileEx(szEngineNewDllPath, szEngineDllPath, MOVEFILE_REPLACE_EXISTING))
        {
            // Rename was Successful.. reset RegKey Information about SelfUpdate Status
            // Because the rename was successful we know no other processes are interacting
            // It should be safe to set the reg key.
            dwStatus = 0;
            RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
        }
    }
    else if (SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
    {
		// registry indicates rename required, but enginenew DLL does not exist. Reset registry
		dwStatus = 0;
		RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CtlCancelEngineLoad()
//
// Asynchronous Callers can use this abort the LoadEngine SelfUpdate Process
//
// NOTE: CDM.DLL assumes UnLoadIUEngine does NOT make any use of COM. If this
//       changes then CDM will have to change at the same time.
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CtlCancelEngineLoad()
{
    if (NULL != g_hEngineLoadQuit)
    {
        SetEvent(g_hEngineLoadQuit);
    }
    else
    {
        // no event was available
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\sources.inc ===
!include $(WINDOWS_COM)\wu.inc

MAJORCOMP=windows.com
MINORCOMP=iuctl

TARGETNAME=iuctl
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\IUCtl.def

#
# Compiler settings
#
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=..\StdAfx.h
# USE_STL=1
# USE_MSVCRT=1
# USE_VCCOM=1
# USE_CRTDLL=1

#
# WUBUILD LAB will set this manually
#
# NT_SIGNCODE=1

C_DEFINES=$(C_DEFINES) -D_USRDLL

ATL_VER=30
USE_CRTDLL=1
USE_STATIC_ATL=1
ATL_DLL_IMPL=1
#BROWSER_INFO=1

#
# force rebuild of .idl on bcz
#
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_SERVERDIR=$(O)
MIDL_TLBDIR=$(O)

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

TARGETLIBS=\
       $(SDK_LIB_PATH)\oleaut32.lib		    \
       $(SDK_LIB_PATH)\ole32.lib		    \
       $(SDK_LIB_PATH)\kernel32.lib		    \
       $(SDK_LIB_PATH)\user32.lib		    \
       $(SDK_LIB_PATH)\advapi32.lib		    \
       $(SDK_LIB_PATH)\shell32.lib		    \
       $(SDK_LIB_PATH)\advapi32.lib		    \
       $(SDK_LIB_PATH)\advpack.lib                  \
       $(SDK_LIB_PATH)\uuid.lib			    \
       $(SDK_LIB_PATH)\shlwapi.lib                  \
       $(SDK_LIB_PATH)\version.lib                  \
       $(WULIB)\trust\$(WUBLDTYPE)\$(O)\trust.lib               \
       $(WULIB)\logging\$(WUBLDTYPE)\$(O)\logging.lib             \
       $(WULIB)\util\$(WUBLDTYPE)\$(O)\util.lib	            \
       $(WULIB)\detect\$(WUBLDTYPE)\$(O)\detect.lib              \
       $(WULIB)\download\$(WUBLDTYPE)\$(O)\download.lib             \
       $(WULIB)\urlagent\$(WUBLDTYPE)\$(O)\urlagent.lib	            \
       $(WULIB)\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib	            \
       $(SDK_LIB_PATH)\msvcrt.lib

#
# how about - gdi32.lib, comdlg32.lib, odbc32.lib, odbccp32.lib?
# they are showing up in the ATL project settings.
#

INCLUDES=$(INCLUDES);..\..\inc;..\.;$(BASEDIR)\public\internal\windows\inc;$(BASEDIR)\public\internal\enduser\inc;

SOURCES= ..\iuctl.idl               \
         ..\IUCtl.rc                \
         ..\StdAfx.cpp              \
         ..\IUCtl.cpp               \
         ..\Update.cpp              \
         ..\ProgressListener.cpp    \
         ..\UpdateCompleteListener.cpp \
         ..\Detection.cpp           \
         ..\EvtMsgWnd.cpp           \
         ..\iudl.cpp                \
         ..\selfupd.cpp		    \
         ..\loadengine.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\progresslistener.cpp ===
// ProgressListener.cpp : Implementation of CProgressListener
#include "stdafx.h"
#include "IUCtl.h"
#include "ProgressListener.h"

/////////////////////////////////////////////////////////////////////////////
// CProgressListener


/////////////////////////////////////////////////////////////////////////////
// OnItemStart()
//
// fire event to notify that this item is about to be downloaded.
// and (in VB) plCommandRequest can be set to pause or cancel the
// whole download/install operation
//
// Input:
// bstrUuidOperation - the operation identification guid
// bstrXmlItem - item XML node in BSTR 
// Output:
// plCommandRequest - a command to pass from the listener to the owner of the event,
//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProgressListener::OnItemStart(BSTR			bstrUuidOperation,
										   BSTR				bstrXmlItem,
										   LONG*			plCommandRequest)
{
	// TODO: Add your implementation code here

    return E_NOTIMPL;
}




/////////////////////////////////////////////////////////////////////////////
// OnProgress()
//
// Notify the listener that a portion of the files has finished operation
// (e.g downloaded or installed). Enables monitoring of progress.
// Input:
// bstrUuidOperation - the operation identification guid
// fItemCompleted - TRUE if the current item has completed the operation
// nPercentComplete - total percentage of operation completed
// Output:
// plCommandRequest - a command to pass from the listener to the owner of the event,
//                    e.g. UPDATE_COMMAND_CANCEL, zero if nothing is requested.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProgressListener::OnProgress(BSTR				bstrUuidOperation,
										   VARIANT_BOOL		fItemCompleted,
										   BSTR				bstrProgress,
										   LONG*			plCommandRequest)
{
	// TODO: Add your implementation code here

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// OnOperationComplete()
//
// Notify the listener when the operation is complete.
// Input:
// bstrUuidOperation - the operation identification guid
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProgressListener::OnOperationComplete(BSTR bstrUuidOperation, BSTR bstrXmlItems)
{
	// TODO: Add your implementation code here

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\selfupd.cpp ===
#include "stdafx.h"
#include "iudl.h"
#include "selfupd.h"
#include <iucommon.h>
#include <osdet.h>
#include <logging.h>
#include <shlwapi.h>
#include <fileutil.h>
#include <iu.h>
#include "update.h"
#include <WaitUtil.h>
#include <UrlAgent.h>
#include <RedirectUtil.h>
#include "wusafefn.h"

inline DWORD StartSelfUpdateProcess(HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener);
DWORD WINAPI MonitorUpdateCompleteProc(LPVOID lpv);

const TCHAR IDENTCAB[] = _T("iuident.cab");
const CHAR SZ_SELF_UPDATE_CHECK[] = "Checking to see if new version of Windows Update software available";
extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;
extern CRITICAL_SECTION g_csUrlAgent;

typedef struct _MONITOR_DATA {
	HANDLE hProcess;
	HANDLE evtControlQuit;
	CUpdate* pUpdateComClass;
	IUnknown* punkCallback;
} MONITOR_DATA, *PMONITOR_DATA;



//
// include declaration for interface IUpdateCompleteListener
//
#ifndef __IUpdateCompleteListener_INTERFACE_DEFINED__
#define __IUpdateCompleteListener_INTERFACE_DEFINED__

/* interface IUpdateCompleteListener */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IUpdateCompleteListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C06B895-E4C8-48eb-9E03-15A53B43B6CA")
    IUpdateCompleteListener : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnComplete( 
            /* [in] */ LONG lErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateCompleteListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUpdateCompleteListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUpdateCompleteListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUpdateCompleteListener * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnComplete )( 
            IUpdateCompleteListener * This,
            /* [in] */ LONG lErrorCode);
        
        END_INTERFACE
    } IUpdateCompleteListenerVtbl;

    interface IUpdateCompleteListener
    {
        CONST_VTBL struct IUpdateCompleteListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateCompleteListener_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUpdateCompleteListener_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUpdateCompleteListener_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUpdateCompleteListener_OnComplete(This,lErrorCode)	\
    (This)->lpVtbl -> OnComplete(This,lErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUpdateCompleteListener_OnComplete_Proxy( 
    IUpdateCompleteListener * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IUpdateCompleteListener_OnComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUpdateCompleteListener_INTERFACE_DEFINED__ */




/////////////////////////////////////////////////////////////////////////////
// SelfUpdateCheck()
//
// Determines if a SelfUpdate is needed, or if a SelfUpdate is already in process.
// If one is already in process this will immediately return. If one is needed
// it either perform the selfupdate (synchronous), or launch a rundll32.exe process 
// and have it call the BeginSelfUpdate() entrypoint to start the selfupdate (asynchronous)
//
// Return S_FALSE is asked not to update engine but this func found engine
// needs to be updated.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT SelfUpdateCheck(BOOL fSynch, BOOL fStartUpdate, HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener)
{
    LOG_Block("SelfUpdateCheck()");
    HRESULT hr = S_OK;
    int iRet = 0;
    DWORD dwRet;
    DWORD dwWaitResult;
    DWORD dwStatus = 0;
    DWORD dwSize = 0;
    BOOL fSelfUpdateAvailable = FALSE;
    BOOL fAsyncSelfUpdateStarted = FALSE;
	BOOL fBetaSelfUpdate = FALSE;
    TCHAR szEngineClientVersion[64];
    TCHAR szEngineServerVersion[64];
    char  szAnsiEngineServerVersion[64];
    TCHAR szIUDir[MAX_PATH];
    TCHAR szIdentFile[MAX_PATH];
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szEngineDllPath[MAX_PATH+1];
    FILE_VERSION fvClientEngine, fvServerEngine;
    HANDLE hDownloadEvent = NULL;
    HANDLE hDownloadEventSync = NULL;
    HANDLE hMutex = NULL;
    HKEY hkey = NULL;
    MSG msg;
    DWORD dwTickStart, dwTickCurrent, dwTickEnd;
	HANDLE aHandles[2];

	if (!fSynch && fStartUpdate && NULL == pUpdateComClass)
	{
		//
		// if to do asynchronized update but the COM class pointer not passed in, then
		// even we succeed we can not pump up the init state of that class so that COM object
		// will still not usable.
		//
		hr = E_INVALIDARG;
		goto CleanUp;
	}


    // The synchronization between multiple processes running the IU control and doing the selfupdate
    // process is reasonably complex. We do this by using two synchronization objects. A named Mutex which protects 
    // the 'selfupdate checking' process, and a named Event that protects against orphaned selfupdate processes caused
    // by reboots during a selfupdate.
    hDownloadEvent = CreateEvent(NULL, TRUE, TRUE, IU_EVENT_SELFUPDATE_IN_PROGRESS);
    if (NULL == hDownloadEvent)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    hDownloadEventSync = CreateEvent(NULL, TRUE, FALSE, IU_EVENT_SELFUPDATE_EVENT_SYNC);
    if (NULL == hDownloadEventSync)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(hr);
        goto CleanUp;
    }

    // First check to see if a selfupdate is already in process.. This is done by
    // checking a regkey for the current selfupdate state. We use a Mutex to synchronize
    // reading/writing to the registry key to ensure that only one process is attempting 
    // the selfupdate. We don't care whether we had to create the mutex, or whether it was
    // already created, so as long as it succeeds, we'll use it.
    hMutex = CreateMutex(NULL, FALSE, IU_MUTEX_SELFUPDATE_REGCHECK);
    if (NULL == hMutex)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    // We're ready to start the selfupdate check process. We'll request the mutex. This helper function
    // does a while loop checking every second (1000ms) for a timeout to elapse (calculated with GetTickCount()),
    // or for the object to be satisfied. This function should either return a timeout result, a WAIT_OBJECT_0
	// for the index 0 object, or else we got the event/mutex we were waiting for.
	aHandles[0] = g_hEngineLoadQuit;	// index 0
	aHandles[1] = hMutex;

    dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/ 30000, QS_ALLINPUT);

    if (WAIT_TIMEOUT == dwWaitResult)
    {
        LOG_ErrorMsg(IU_SELFUPDATE_TIMEOUT);
        hr = IU_SELFUPDATE_TIMEOUT;
        goto CleanUp;
    }

	if (WAIT_OBJECT_0 == dwWaitResult)
	{
		hr = E_ABORT;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

    if (ERROR_REQUEST_ABORTED == dwWaitResult) // this indicates we processed a QUIT message while waiting.
    {
        // not an error
        goto CleanUp;
    }

    dwRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, _T(""), REG_OPTION_NON_VOLATILE, 
        KEY_READ | KEY_WRITE, NULL, &hkey, &dwStatus);
    if (ERROR_SUCCESS != dwRet)
    {
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    // if the previous call to RegCreateKeyEx indicated it 'created' the key then we need to set the default
    // status to 0.
    if (REG_CREATED_NEW_KEY == dwStatus)
    {
        dwStatus = SELFUPDATE_NONE;
        dwRet = RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
    }
    else
    {
		// Check for Beta IU SelfUpdate Handling Requested
		dwStatus = 0;
		dwSize = sizeof(dwStatus);
		dwRet = RegQueryValueEx(hkey, REGVAL_BETASELFUPDATE, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
		if (1 == dwStatus)
		{
			fBetaSelfUpdate = TRUE;
		}

        dwStatus = SELFUPDATE_NONE;
        dwSize = sizeof(dwStatus);
        dwRet = RegQueryValueEx(hkey, REGVAL_SELFUPDATESTATUS, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
    }

    // check the result of the QueryValue/SetValue call - 
    if (ERROR_SUCCESS != dwRet && 2 != dwRet)
    {
		//
		// if dwRet == 2, it's the case that IUControl key exist, but SelfUpdate value not exist,
		// 
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
    {
        LOG_ErrorMsg(E_ABORT);
        hr = E_ABORT;
        goto CleanUp;
    }

    switch (dwStatus)
    {
    case SELFUPDATE_NONE:
        {
            // First find out the version of the Engine on the server.
            GetIndustryUpdateDirectory(szIUDir);

            hr=PathCchCombine(szIdentFile,ARRAYSIZE(szIdentFile),szIUDir,IDENTTXT);

			if(FAILED(hr))
			{
				LOG_ErrorMsg(hr);
				goto CleanUp;
			}

            GetPrivateProfileString(fBetaSelfUpdate ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
									IDENT_VERSION, 
									_T(""), 
									szEngineServerVersion, 
									ARRAYSIZE(szEngineServerVersion), 
									szIdentFile);
            if ('\0' == szEngineServerVersion[0])
            {
                // no selfupdate available, no server version information
                hr = S_OK;
                goto CleanUp;
            }

            GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));
            hr=PathCchCombine(szEngineDllPath,ARRAYSIZE(szEngineDllPath),szSystemDir, ENGINEDLL);
			if(FAILED(hr))
			{
				LOG_ErrorMsg(hr);
				goto CleanUp;
			}


            if (GetFileVersion(szEngineDllPath, &fvClientEngine))
            {
                // T2A requires Structured Exception Handling (because it uses alloca which can throw, so we avoid it and 
                // do it the simple way.
#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, szEngineServerVersion, -1, szAnsiEngineServerVersion, 
                    sizeof(szAnsiEngineServerVersion), NULL, NULL);
                if (!ConvertStringVerToFileVer(szAnsiEngineServerVersion, &fvServerEngine))
#else
                if (!ConvertStringVerToFileVer(szEngineServerVersion, &fvServerEngine))
#endif
                {
                    LOG_ErrorMsg(IU_SELFUPDATE_FAILED);
                    hr = IU_SELFUPDATE_FAILED;
                    goto CleanUp;
                }
                iRet = CompareFileVersion(fvClientEngine, fvServerEngine);
                if (iRet == 0)
                {
                    // IUEngine Versions are the same
                    fSelfUpdateAvailable = FALSE;
                }
                else if (iRet > 0)
                {
                    LOG_Internet(_T("Version of IUEngine on Client is NEWER than IUEngine on Server"));
                    fSelfUpdateAvailable = FALSE;
                }
                else
                {
                    // IUEngine Version on the Server is newer
                    LOG_Internet(_T("New Version (%s) of IUEngine on Server Found."), szEngineServerVersion);
#if defined(UNICODE) || defined(_UNICODE)
					LogMessage("IUEngine on Server is newer version (%ls)", szEngineServerVersion);
#else
					LogMessage("IUEngine on Server is newer version (%s)", szEngineServerVersion);
#endif
                    fSelfUpdateAvailable = TRUE;
                }
            }
            else
            {
                // no version information found on local file, probably should do a selfupdate anyway.
                LOG_Internet(_T("No Version Information On Local IUEngine, SelfUpdating to Server Version"));
                fSelfUpdateAvailable = TRUE;
            }

            if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
            {
                LOG_ErrorMsg(E_ABORT);
                hr = E_ABORT;
                goto CleanUp;
            }

            if (fSelfUpdateAvailable)
            {
				if (fStartUpdate)
				{
					dwStatus = SELFUPDATE_IN_PROGRESS;	

                    dwRet = RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
					RegCloseKey(hkey); // done with the reg key now.
					hkey = NULL;

					// The default state of the DownloadEvent is Signaled (TRUE). If a Process is 'actually' working on the
					// SelfUpdate Process this Event Needs to be Reset to FALSE. Any time a client determines that a selfupdate
					// 'should' be in progress (from the regkey status) it should check the Event state, if it is signaled (TRUE)
					// then there was probably a reboot during the selfupdate, it should restart the selfupdate process itself.
					ResetEvent(hDownloadEvent); // mark that this Process will Perform the SelfUpdate by Resetting the Download Event
					ReleaseMutex(hMutex); // we are now done with the selfupdate check, both the event and the registry values are set
										  // properly.
					CloseHandle(hMutex);
					hMutex = NULL;
					if (fSynch)
					{
						hr = BeginSelfUpdate();
						if (FAILED(hr))
						{
							LOG_Error(_T("BeginSelfUpdate Failed"));
							goto CleanUp;
						}
					}
					else
					{
						fAsyncSelfUpdateStarted = TRUE;
						// launch SelfUpdate Asynchronously.
						dwRet = StartSelfUpdateProcess(evtQuit, pUpdateComClass, punkUpdateCompleteListener); // inline function
						if (ERROR_SUCCESS != dwRet)
						{
							LOG_ErrorMsg(dwRet);
							hr = HRESULT_FROM_WIN32(dwRet);
							goto CleanUp;
						}
					}
				}
				else
				{
					//
					// in case we are asked to check update info only,
					// we signal back the result as S_FALSE for
					// engine update avail
					//
					hr = S_FALSE;
				}
            }
			else
			{
				//
				// somehow, no update needed. must be other process finished it.
				//
				if (fStartUpdate)
				{
					hr = IU_SELFUPDATE_USENEWDLL;
					goto CleanUp;
				}
			}

            break;
        }
    case SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED:
        {
            // As selfupdate has already been completed, but we're waiting to be able to rename the DLL.
            // In this case we'll tell the control to load the enginenew.dll.
            LOG_Internet(_T("SelfUpdate Already Complete, Updated Binary Available, Waiting for Rename."));
            hr = IU_SELFUPDATE_USENEWDLL;
            goto CleanUp;
        }
    case SELFUPDATE_IN_PROGRESS:
    default:
        {
			if (!fStartUpdate)
			{
				//
				// if asked to check update status but not to do actual update,
				// then this reg key flag tells the engine not update complete yet.
				//
				hr = S_FALSE;	// signal TRUE for engine need update
				goto CleanUp;
			}

            if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
            {
                LOG_ErrorMsg(E_ABORT);
                hr = E_ABORT;
                goto CleanUp;
            }

            // The RegKey indicates that a SelfUpdate is in Progress Now. We need to make sure this is
            // actually true. If a previous attempt at selfupdate was aborted because the machine rebooted
            // we could be in a false state. The 'default' state of teh DownloadEvent is Signaled (TRUE).
            // If the current State is TRUE then the SelfUpdate is actually 'NOT' in progress.

            // Find out the current state of the DownloadEvent
            dwWaitResult = WaitForSingleObject(hDownloadEvent, 0);
            if (WAIT_OBJECT_0 == dwWaitResult)
            {
                // The Event State is still Signaled (TRUE), so the selfupdate is not in progress
                ResetEvent(hDownloadEvent); // mark that this Process will Perform the SelfUpdate by Resetting the Download Event
                ReleaseMutex(hMutex);
                CloseHandle(hMutex);
                hMutex = NULL;
                if (fSynch)
                {
                    hr = BeginSelfUpdate();
                    if (FAILED(hr))
                    {
                        LOG_Error(_T("BeginSelfUpdate Failed"));
                        goto CleanUp;
                    }
                }
                else
                {
                    fAsyncSelfUpdateStarted = TRUE;
                    // launch SelfUpdate Asynchronously.
                    dwRet = StartSelfUpdateProcess(evtQuit, pUpdateComClass, punkUpdateCompleteListener); // inline function
                    if (ERROR_SUCCESS != dwRet)
                    {
                        LOG_ErrorMsg(dwRet);
                        hr = HRESULT_FROM_WIN32(dwRet);
                        goto CleanUp;
                    }
                }
            }
            else 
            {
                // The Event State is not Signaled (FALSE), everythings ok with the current selfupdate
                // Now we need to either start a thread to wait for the complete and immediately return, 'or' 
                // wait for the selfupdate to finish (synchronous or asynchronous selfupdate).
                if (fSynch)
                {
                    // we need to wait for the event to change back to signaled state. Should indicate the
                    // selfupdate is finished.
                    // before we start the wait, we will release our mutex, since we really aren't doing anything
                    // with the registry anymore
                    ReleaseMutex(hMutex);
                    CloseHandle(hMutex);
                    hMutex = NULL;

					aHandles[0] = g_hEngineLoadQuit;	// index 0
					aHandles[1] = hDownloadEvent;

                    dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*120 seconds*/ 120000, QS_ALLINPUT);
                    if (WAIT_TIMEOUT == dwWaitResult)
                    {
                        // Timed Out Waiting for SelfUpdate to Complete. May just be really slow, go ahead
                        // and use the old DLL for now.
                        LOG_ErrorMsg(IU_SELFUPDATE_TIMEOUT);
                        hr = IU_SELFUPDATE_TIMEOUT;
                        goto CleanUp;
                    }
                    if (ERROR_REQUEST_ABORTED == dwWaitResult)
                    {
                        goto CleanUp;
                    }
                    if (WAIT_OBJECT_0 == dwWaitResult)
                    {
						//
						// index 0 (g_hEngineLoadQuit) was signaled
						//
					   hr = E_ABORT;
					   LOG_ErrorMsg(hr);
					   goto CleanUp;
                    }
                    hr = IU_SELFUPDATE_USENEWDLL;
                    goto CleanUp;
                }
                else
                {
					//
                    // asked to update in async mode, but found someone else
					// already started the update process
					//
					PMONITOR_DATA pMonitorData = (PMONITOR_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MONITOR_DATA));

					if (NULL == pMonitorData)
					{
	                    hr = E_OUTOFMEMORY;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
					else
					{
						DWORD dwThreadId = 0;
						hr = S_OK;
						pMonitorData->hProcess = hDownloadEvent;
						pMonitorData->evtControlQuit = evtQuit;
						pMonitorData->pUpdateComClass = pUpdateComClass;
						pMonitorData->punkCallback = punkUpdateCompleteListener;
                        HANDLE hThread = NULL;
                        hThread = CreateThread(NULL, 0, MonitorUpdateCompleteProc, pMonitorData, 0, &dwThreadId);
						if (NULL == hThread)
						{
							HeapFree(GetProcessHeap(), 0, pMonitorData);
							//
							// otherwise, the memory allocated will be released by the thread procedure
							//
							hr = HRESULT_FROM_WIN32(GetLastError());
							LOG_ErrorMsg(hr);
							goto CleanUp;
						}
                        else
                        {
                            CloseHandle(hThread); // don't leak the thread handle
                        }
					}	

                    goto CleanUp;
                }
            }
            break;
        }
    }

CleanUp:
    // always release the mutex, there are cases during the selfupdate check that can fail, in which
    // case they fall through to here. If the mutex is free'd when its not ours the call simply fails.
    if (NULL != hMutex)
    {
        ReleaseMutex(hMutex); 
        CloseHandle(hMutex);
        hMutex = NULL;
    }

    if (fAsyncSelfUpdateStarted)
    {
        // if an Asynchronous SelfUpdate has been started we want to wait for it to
        // get the DownloadEvent before we close it. There would be a possible Race 
        // condition where the selfupdate process would 'create' the event, instead
        // of 'opening' the event in its 'reset' state. If this happened another
        // process could come along, find that the event state is signaled instead of
        // reset and assume the selfupdate process had terminated.

        // Wait for the DownloadEventSync event to be signaled. We'll put a timeout of
        // 30 seconds (should be more than sufficient for the new process to start and
        // set the event).
		aHandles[0] = g_hEngineLoadQuit;	// index 0
		aHandles[1] = hDownloadEventSync;

        dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/ 30000, QS_ALLINPUT);
        if (WAIT_TIMEOUT == dwWaitResult)
        {
            // go ahead and log that we timed out waiting. 
            LOG_Internet(_T("Timeout Elapsed while waiting for SelfUpdate Process to open the DownloadSync Event"));
        }
		if (ERROR_REQUEST_ABORTED == dwWaitResult)
		{
            // go ahead and log that a WM_QUIT, WM_CLOSE, or WM_DESTROY. 
            LOG_Internet(_T("Received WM_QUIT, WM_CLOSE, or WM_DESTROY while waiting for SelfUpdate Process to open the DownloadSync Event"));
		}
		if (WAIT_OBJECT_0 == dwWaitResult)
		{
            LOG_Internet(_T("g_hEngineLoadQuit signaled while waiting for SelfUpdate Process to open the DownloadSync Event"));
			hr = E_ABORT;
		}
    }
    if (NULL != hDownloadEvent)
    {
        CloseHandle(hDownloadEvent);
        hDownloadEvent = NULL;
    }
    if (NULL != hDownloadEventSync)
    {
        CloseHandle(hDownloadEventSync);
        hDownloadEventSync = NULL;
    }

	if (NULL != hkey)
	{
		RegCloseKey(hkey);
	}

	if (SUCCEEDED(hr))
	{
		LogMessage(SZ_SELF_UPDATE_CHECK);
	}
	else
	{
		LogError(hr, SZ_SELF_UPDATE_CHECK);
	}

    return hr;
}

inline DWORD StartSelfUpdateProcess(HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener)
{
    TCHAR szRunDll32Path[MAX_PATH+1];
    TCHAR szCommandLine[MAX_PATH+1];
    TCHAR szDirectory[MAX_PATH+1];
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    DWORD dwRet = ERROR_SUCCESS;
	DWORD dwThreadId;
	PMONITOR_DATA pMonitorData;
	HRESULT hr=S_OK;

    if (0 == GetSystemDirectory(szDirectory, ARRAYSIZE(szDirectory)))
    {
        return GetLastError();
    }
    
	hr=PathCchCombine(szRunDll32Path,ARRAYSIZE(szRunDll32Path),szDirectory, RUNDLL32);
	if(FAILED(hr))
		return HRESULT_CODE(hr);

    if (!FileExists(szRunDll32Path))
    {
        // probably running on W9x, look in the Windows Folder Instead
        if (0 == GetWindowsDirectory(szDirectory, ARRAYSIZE(szDirectory)))
        {
            return GetLastError();
        }

        hr=PathCchCombine(szRunDll32Path,ARRAYSIZE(szRunDll32Path),szDirectory, RUNDLL32);
		if(FAILED(hr))
			return HRESULT_CODE(hr);
			
        if (!FileExists(szRunDll32Path))
        {
            // we're toast.. can't find rundll32.exe .. bye-bye
            return ERROR_FILE_NOT_FOUND;
        }
    }

    // now form the path to the iuctl.dll .. we'll trust nothing and 'get' the module filename
    // instead of assuming its in the system folder.
    GetModuleFileName(GetModuleHandle(IUCTL), szDirectory, ARRAYSIZE(szDirectory));

	hr=StringCchPrintfEx(szCommandLine,ARRAYSIZE(szCommandLine),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("\"%s\" \"%s\"%s"), szRunDll32Path, szDirectory, RUNDLLCOMMANDLINE);

	if(FAILED(hr))
		return HRESULT_CODE(hr);
	
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    if (!CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi))
    {
        dwRet = GetLastError();
        return dwRet;
    }

	//
	// create a thread that can be used to monitor the completeness of
	// this update process
	//
	pMonitorData = (PMONITOR_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MONITOR_DATA));
	if (NULL != pMonitorData)
	{
		pMonitorData->hProcess = pi.hProcess;	// return process handle so we know when it's done
		pMonitorData->evtControlQuit = evtQuit;
		pMonitorData->pUpdateComClass = pUpdateComClass;
		pMonitorData->punkCallback = punkUpdateCompleteListener;
        HANDLE hThread = NULL;
        hThread = CreateThread(NULL, 0, MonitorUpdateCompleteProc, pMonitorData, 0, &dwThreadId);
		if (NULL == hThread)
		{
			HeapFree(GetProcessHeap(), 0, pMonitorData);
			//
			// otherwise, the memory allocated will be released by the thread procedure
			//
		}
        else
        {
            CloseHandle(hThread);
        }
	}	

    return dwRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// thread procedure to determine when to signal caller
// the update process has be gone
//
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI MonitorUpdateCompleteProc(LPVOID lpv)
{
	HRESULT hr;
	HWND hWnd;
	CUpdate* pUpdateClass = NULL;
	IUnknown* punkCallback = NULL;
	PMONITOR_DATA pData;
	HANDLE hEvents[2];
	DWORD dwRet, dwErr = 0;
	MSG msg;
	
	LOG_Block("MonitorUpdateCompleteProc");

	if (NULL == lpv)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return 0x1;	// impossible!
	}
	
	pData = (PMONITOR_DATA) lpv;

	hEvents[0]		= pData->hProcess;
	hEvents[1]		= pData->evtControlQuit;
	punkCallback	= pData->punkCallback;
	pUpdateClass	= pData->pUpdateComClass;
	if (pUpdateClass)
	{
		hWnd = pUpdateClass->GetEventWndClass().GetEvtHWnd();
	}

	//
	// this data allcoated by parent thread, we are responsible to release it
	//
	HeapFree(GetProcessHeap(), 0, lpv);

	if (NULL == pUpdateClass)
	{
		//
		// even we catch the update completeness, without this pointer we can not 
		// modify the init state so this COM will still not usable. We bail
		// 
		return 0;
	}

	//
	// wait till process gone or quit signal
	//
	while (TRUE)
	{
		dwRet = MsgWaitForMultipleObjects(ARRAYSIZE(hEvents), hEvents, FALSE, INFINITE, QS_ALLINPUT);
		switch (dwRet)
		{
			case WAIT_OBJECT_0:
				//
				// process done, get return code
				//
				GetExitCodeProcess(hEvents[0], &dwErr);

				if (0x0 == dwErr)
				{
					//
					// we are done with no error, then pump the
					// init state to ready state
					//
					dwErr = pUpdateClass->ChangeControlInitState(2);
				}

				//
				// signal event
				//
				if (NULL != hWnd)
				{
					PostMessage(hWnd, UM_EVENT_SELFUPDATE_COMPLETE, 0, (LPARAM)dwErr);
					LOG_Out(_T("Fired event OnComplete()"));
				}
				//
				// signal callback
				//
				if (NULL != punkCallback)
				{
					IUpdateCompleteListener* pCallback = NULL;
					if (FAILED(hr = punkCallback->QueryInterface(IID_IUpdateCompleteListener, (void**) &pCallback)))
					{
						LOG_ErrorMsg(hr);
					}
					else
					{
						pCallback->OnComplete(dwErr);
						pCallback->Release();
						LOG_Out(_T("Returned from callback API OnComplete()"));
					}
				}
				return 0;
				break;

			case WAIT_OBJECT_0 + 1:
				//
				// got global Quit event
				//
				LOG_Out(_T("Found quit event!"));
				return 1;
				break;

			case WAIT_OBJECT_0 + ARRAYSIZE(hEvents):
				//
				// got message
				//
				while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
				{
					if (WM_QUIT == msg.message)
					{
						LOG_Out(_T("Found WM_QUIT message. Leaving..."));
						return 1;
					}
					DispatchMessage(&msg);
				}
				break;
		}

	} 
	
	return 0;	// never reach here
}




HRESULT BeginSelfUpdate()
{
    LOG_Block("BeginSelfUpdate()");
    DWORD dwRet;
    DWORD dwStatus;
    DWORD dwSize;
    HRESULT hr = S_OK;
    HKEY hkey = NULL;					// PreFast
    TCHAR szIUDir[MAX_PATH+1];
    TCHAR szLocalPath[MAX_PATH+1];
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szTargetDLLName[MAX_PATH+1];
	LPTSTR pszSelfUpdateCabUrl = NULL;
    HANDLE hDownloadEventSync = NULL;	// PreFast
    HANDLE hDownloadEvent = NULL;		// PreFast
    HANDLE hMutex = NULL;				// PreFast
    MSG msg;
	BOOL fBetaSelfUpdate = FALSE;
    HMODULE hNewEngine = NULL;
    PFN_CompleteSelfUpdateProcess fpnCompleteSelfUpdateProcess = NULL;

    // The SelfUpdate process is done while the SELFUPDATE_IN_PROGRESS event is 'reset'. We
    // do everything we can to make sure we 'open' this event in the reset state, but if for
    // some reason the event is not there we will create it in the reset state.
    hDownloadEvent = CreateEvent(NULL, TRUE, FALSE, IU_EVENT_SELFUPDATE_IN_PROGRESS);
    if (NULL == hDownloadEvent)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    // The SELFUPDATE_EVENT_SYNC is the mechanism we use to 'try' to keep the SELFUPDATE_IN_PROGRESS
    // event alive and in the 'reset' state until this function can open it and keep it in that state.
    // This should prevent a race condition caused when the SelfUpdateCheck function closes the Event
    // before this function can open it. If this happens another process could start the selfupdate check
    // process and find the SELFUPDATE_IN_PROGRESS event in the wrong state.
    hDownloadEventSync = CreateEvent(NULL, TRUE, FALSE, IU_EVENT_SELFUPDATE_EVENT_SYNC);
    if (NULL == hDownloadEventSync)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(hr);
        goto CleanUp;
    }

    // tell the SelfUpdateCheck client that we have the SELFUPDATE_IN_PROGRESS event, so it can
    // release its handle to it.
    SetEvent(hDownloadEventSync); 

    // release our handle to the SELFUPDATE_EVENT_SYNC event.
    CloseHandle(hDownloadEventSync);
    hDownloadEventSync = NULL;

	// Get Self-Update Server URL
	pszSelfUpdateCabUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszSelfUpdateCabUrl);

	EnterCriticalSection(&g_csUrlAgent);

	if (FAILED(hr = g_pIUUrlAgent->PopulateData()))
	{
		LOG_Error(_T("failed to populate data in g_pIUUrlAgent (%lx)"), hr);
	}

	LeaveCriticalSection(&g_csUrlAgent);
	CleanUpIfFailedAndMsg(g_pIUUrlAgent->GetSelfUpdateServer(pszSelfUpdateCabUrl, INTERNET_MAX_URL_LENGTH));

    // Download the SelfUpdate CAB
    GetIndustryUpdateDirectory(szIUDir);

    hr=PathCchCombine(szLocalPath,ARRAYSIZE(szLocalPath),szIUDir, ENGINECAB);

	if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    hr = IUDownloadFile(pszSelfUpdateCabUrl, szLocalPath, TRUE, TRUE);

    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    DeleteFile(szLocalPath); // clean up the CAB in the IU Folder

    // Now we 'should' have IUENGINE.DLL from the SelfUpdate CAB in the IU Folder.
    // IUENGINE.DLL is self-signed so we don't need a Catalog File (IUENGINE.CAT)
	// NTRAID#NTBUG9-435844-2001/07/16-waltw WU: IU: IUCTL: Remove code to register CAT file when updating iuengine.dll

    // Copy the DLL to the new Engine DLL Name
    GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));

    hr=PathCchCombine(szTargetDLLName,ARRAYSIZE(szTargetDLLName), szSystemDir, ENGINENEWDLL);
	
	if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }


    hr=PathCchCombine(szLocalPath,ARRAYSIZE(szLocalPath),szIUDir, ENGINEDLL);
	if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }


    CopyFile(szLocalPath, szTargetDLLName, FALSE);

    DeleteFile(szLocalPath); // clean up the DLL in the IU Folder now that its been copied to the systemdir.

    // Now We've successfully downloaded the new IUEngine - we need to call an entry point in this Engine to 
    // Chain any SelfUpdate steps the Engine needs to do. It is possible the engine may need to download an
    // additional component, or do some registry configuration work. So we'll load the new Engine and call the
    // CompleteSelfUpdateProcess entrypoint.
	//
	// We don't need LoadLibraryFromSystemDir here since we have the full path and
	// iuengine isn't a Side-By-Side module.
    hNewEngine = LoadLibrary(szTargetDLLName);
    if (NULL == hNewEngine)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }
    fpnCompleteSelfUpdateProcess = (PFN_CompleteSelfUpdateProcess) GetProcAddress(hNewEngine, "CompleteSelfUpdateProcess");
    if (NULL == fpnCompleteSelfUpdateProcess)
    {
        LOG_ErrorMsg(ERROR_INVALID_DLL);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
        goto CleanUp;
    }

    // Call the New Engine to let it finish its SelfUpdate Process
    hr = fpnCompleteSelfUpdateProcess();
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    // Now update the registry information about the SelfUpdate process being Complete
    hMutex = CreateMutex(NULL, FALSE, IU_MUTEX_SELFUPDATE_REGCHECK);
    if (NULL == hMutex)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

	HANDLE aHandles[2];

	aHandles[0] = g_hEngineLoadQuit;	// index 0
	aHandles[1] = hMutex;

    // Finish the Registry Settings
    dwRet= MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/ 30000, QS_ALLINPUT);

    if (WAIT_TIMEOUT == dwRet)
    {
        LOG_Internet(_T("Timed Out while waiting for IU_MUTEX_SELFUPDATE_REGCHECK Mutex"));
        // NOTE: If we failed to RegCheck Mutex after 30 seconds something is probably wrong in another
        // process. However, we don't want to leave the registry showing a selfupdate is still in progress
        // so we'll just go ahead and update the registry.
    }
    if (ERROR_REQUEST_ABORTED == dwRet)
    {
        goto CleanUp;
    }
    if (WAIT_OBJECT_0 == dwRet)
    {
		//
		// index 0 (g_hEngineLoadQuit) was signaled
		//
	   hr = E_ABORT;
	   LOG_ErrorMsg(hr);
	   goto CleanUp;
    }

    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ | KEY_WRITE, &hkey);
    if (ERROR_SUCCESS != dwRet)
    {
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;   
    }
    dwStatus = SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED;
    dwRet = RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
    if (ERROR_SUCCESS != dwRet)
    {
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
    }
    
CleanUp:
    if (NULL != hNewEngine)
    {
        FreeLibrary(hNewEngine);
        hNewEngine = NULL;
    }
    if (NULL != hMutex)
    {
        ReleaseMutex(hMutex); // doesn't matter whether we got the mutex or not, if we didn't this will just fail.
        CloseHandle(hMutex);
        hMutex = NULL;
    }
    if (NULL != hDownloadEvent)
    {
        // Tell any clients that are waiting for the selfupdate process to finish that we're now done.
        SetEvent(hDownloadEvent);
        CloseHandle(hDownloadEvent);
        hDownloadEvent = NULL;
    }
    if (NULL != hDownloadEventSync)
    {
        CloseHandle(hDownloadEventSync);
        hDownloadEventSync = NULL;
    }
	if (NULL != hkey)
	{
		RegCloseKey(hkey);
	}
	SafeHeapFree(pszSelfUpdateCabUrl);
    return hr;
}

HRESULT PingEngineUpdate(
						HMODULE hEngineModule,
						PHANDLE phQuitEvents,
						UINT nQuitEventCount,
						LPCTSTR ptszLiveServerUrl,
						LPCTSTR ptszCorpServerUrl,
						DWORD dwError,
						LPCTSTR ptszClientName
						)
{
	LOG_Block("PingEngineUpdate");

	HRESULT hr;
	BOOL fFreeEngModule = FALSE;
	PFN_PingIUEngineUpdateStatus pfnPingIUEngineUpdateStatus;

	if (NULL == hEngineModule)
	{
		// try loading iuenginenew.dll first
		hEngineModule = LoadLibraryFromSystemDir(_T("iuenginenew.dll"));
		if (NULL != hEngineModule)
		{
			LOG_Internet(_T("Loaded IUENGINENEW.DLL"));
		}
		else
		{
			LOG_Internet(_T("Loaded IUENGINE.DLL"));
			hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));
		}
		//
		// If load engine succeeded, we'll need to unload it later
		//
		if (NULL != hEngineModule)
		{
			fFreeEngModule = TRUE;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
	}

	//
	// If we got an iuengine.dll (either passed in or loaded ourselves), call PingIUEngineUpdateStatus
	//
	if (NULL != hEngineModule)
	{
		pfnPingIUEngineUpdateStatus = (PFN_PingIUEngineUpdateStatus) GetProcAddress(hEngineModule, "PingIUEngineUpdateStatus");

		if (NULL != pfnPingIUEngineUpdateStatus)
		{
			hr = pfnPingIUEngineUpdateStatus(
								phQuitEvents,
								nQuitEventCount,
								ptszLiveServerUrl,
								ptszCorpServerUrl,
								dwError,
								ptszClientName
								);

		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
	}

	if (TRUE == fFreeEngModule)
	{
		FreeLibrary(hEngineModule);
	}

	return hr;
}


//
// this function wraps up DownloadIUIdent() and CIUUrlAgent::PopulateData(), since we use it
// in both selfupd.cpp and loadengine.cpp.
//
HRESULT DownloadIUIdent_PopulateData()
{
	LOG_Block("DownloadIUIdent_PopulateData");
	HRESULT hr = S_OK;

	//
	// Look for any specified iuident Server Location in the Registry (Overrides Default)
	//
	LPTSTR pszTempUrlBuffer = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszTempUrlBuffer);

	if (FAILED(hr = g_pIUUrlAgent->GetOriginalIdentServer(pszTempUrlBuffer, INTERNET_MAX_URL_LENGTH)))
	{
		LOG_Error(_T("failed to get original ident server URL (%lx)"), hr);
		goto CleanUp;
	}

	TCHAR szIUDir[MAX_PATH];

	//GetIndustryUpdateDirectory(szIUDir);

	//
	// ensure WU directory exist and correctly ACL'ed
	//
	CleanUpIfFalseAndSetHrMsg(!GetWUDirectory(szIUDir, ARRAYSIZE(szIUDir), TRUE), HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));
	hr = CreateDirectoryAndSetACLs(szIUDir, TRUE);
	CleanUpIfFailedAndMsg(hr);

	if (FAILED(hr = DownloadIUIdent(
						g_hEngineLoadQuit,
						pszTempUrlBuffer,
						szIUDir, 
						0,
						(S_OK == g_pIUUrlAgent->IsIdentFromPolicy()))))
	{
		LOG_Error(_T("iuident download failed (%lx)"), hr);
		goto CleanUp;
	}

	EnterCriticalSection(&g_csUrlAgent);

	if (FAILED(hr = g_pIUUrlAgent->PopulateData()))
	{
		LOG_Error(_T("failed to populate data in g_pIUUrlAgent (%lx)"), hr);
	}

	LeaveCriticalSection(&g_csUrlAgent);

CleanUp:
	SafeHeapFree(pszTempUrlBuffer);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A986663F_FF6F_4B1E_8364_B1CB06AEDFD3__INCLUDED_)
#define AFX_STDAFX_H__A986663F_FF6F_4B1E_8364_B1CB06AEDFD3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define STRSAFE_NO_DEPRECATE

#include <atlbase.h>
#include <objsafe.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <strsafe.h>
#include <MISTSAFE.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A986663F_FF6F_4B1E_8364_B1CB06AEDFD3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\updatecompletelistener.cpp ===
// ProgressListener.cpp : Implementation of CProgressListener
#include "stdafx.h"
#include "IUCtl.h"
#include "UpdateCompleteListener.h"

/////////////////////////////////////////////////////////////////////////////
// CUpdateCompleteListener


/////////////////////////////////////////////////////////////////////////////
// OnComplete()
//
// Notify the listener when the engine update is complete.
// Input:	the result of engine update
//	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdateCompleteListener::OnComplete(/*[in]*/ LONG lErrorCode)
{
	// TODO: Add your implementation code here

	//
	// usually you should change state of a synchronization object so
	// the thread that is waiting for the engine update complete 
	// can be notified by checking the state of this object
	//

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\updatecompletelistener.h ===
// ProgressListener.h : Declaration of the CProgressListener

#ifndef __UPDATECOMPLETELISTENER
#define __UPDATECOMPLETELISTENER

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CProgressListener
class ATL_NO_VTABLE CUpdateCompleteListener : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUpdateCompleteListener, &CLSID_UpdateCompleteListener>,
	public IUpdateCompleteListener
{
public:
	CUpdateCompleteListener()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_UPDATECOMPLETELISTENER)
DECLARE_NOT_AGGREGATABLE(CUpdateCompleteListener)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpdateCompleteListener)
	COM_INTERFACE_ENTRY(IUpdateCompleteListener)
END_COM_MAP()

// IProgressListener
public:

	/////////////////////////////////////////////////////////////////////////////
	// OnComplete()
	//
	// Notify the listener when the engine update is complete.
	// Input:	the result of engine update
	//	
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(OnComplete)(/*[in]*/ LONG lErrorCode);
};

#endif //__UPDATECOMPLETELISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\update.cpp ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Update.cpp
//
//  Owner:  JHou
//
//  Description:
//
//   Industry Update v1.0 client control stub - Implementation of CUpdate
//
//
//  Revision History:
//
//  Date		Author		Desc
//	~~~~		~~~~~~		~~~~
//  9/15/2000	JHou		created.
//
//=======================================================================
#include "stdafx.h"
#include "iu.h"
#include "iucommon.h"
#include "IUCtl.h"
#include "Update.h"
#include "iudl.h"
#include "selfupd.h"
#include "loadengine.h"
#include <logging.h>
#include <fileutil.h>
#include <trust.h>
#include <osdet.h>
#include <exdisp.h>
#include <UrlAgent.h>
#include <wusafefn.h>

typedef BOOL (WINAPI* pfn_InternetCrackUrl)(LPCTSTR, DWORD, DWORD, LPURL_COMPONENTS);

extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;

#define Initialized		(2 == m_lInitState)


/////////////////////////////////////////////////////////////////////////////
//
// declaration of function template for CoFreeUnusedLibrariesEx(), which is
// available on Win98+ and Win2000+ only, in ole32.dll
//
/////////////////////////////////////////////////////////////////////////////
typedef void (WINAPI * PFN_CoFreeUnusedLibrariesEx)	(IN DWORD dwUnloadDelay, 
														 IN DWORD dwReserved);
extern "C" const CLSID CLSID_Update2;
typedef HRESULT (STDMETHODCALLTYPE* PROC_RegServer)(void);

DWORD MyGetModuleFileName(HMODULE hModule, LPTSTR pszBuf, DWORD cchBuf);
BOOL IsThisUpdate2();

/////////////////////////////////////////////////////////////////////////////
// CUpdate

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
/////////////////////////////////////////////////////////////////////////////
CUpdate::CUpdate()
    : m_EvtWindow(this),
      m_dwSafety(0),
	  m_dwMode(0x0),
	  m_hValidated(E_FAIL),				// container not validated yet
	  m_fUseCompression(TRUE),
      m_fOfflineMode(FALSE),
      m_hEngineModule(NULL),
	  m_pClientSite(NULL),
	  m_lInitState(0L),
	  m_dwUpdateInfo(0x0),
	  m_hIUEngine(NULL)
{
	m_szReqControlVer[0] = _T('\0');
	m_gfInit_csLock = SafeInitializeCriticalSection(&m_lock);
	m_evtControlQuit = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_EvtWindow.Create();

	/* 
	we decided to use the new Win32 API GetControlUpdateInfo() to expose these
	data and let a wrapper control to call it so we won't have reboot issue on 
	OS prior to WinXP


	//
	// try to free unused libraries
	//
	HMODULE hOle32Dll = LoadLibrary(_T("ole32.dll"));
	if (NULL != hOle32Dll)
	{
		//
		// The min platforms support CoFreeUnusedLibrariesEx() are W2K and W98
		// so we can't call it directly
		//
		PFN_CoFreeUnusedLibrariesEx pFreeLib = (PFN_CoFreeUnusedLibrariesEx)
													GetProcAddress(hOle32Dll, 
																   "CoFreeUnusedLibrariesEx");
		if (NULL != pFreeLib)
		{
			//
			// ask to release the unused library immediately, this will cause the COM objects
			// that being released (e.g., set obj to nothing) unloaded from memory immediately, 
			// so in control update case we can safely jump to a to use <OBJECT> with codebase 
			// to update the control and it won't cause reboot even though on this page we already 
			// loaded the control
			//
			pFreeLib(0, 0);
		}
		FreeLibrary(hOle32Dll);
	}

	//
	// figure out if we are upate 2, we are if this module name ends with "2.dll"
	//
	m_fIsThisUpdate2 = ::IsThisUpdate2();

  */

}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
/////////////////////////////////////////////////////////////////////////////
CUpdate::~CUpdate()
{
    m_EvtWindow.Destroy();

	if(m_gfInit_csLock)
	{
		DeleteCriticalSection(&m_lock);
	}
	if (NULL != m_evtControlQuit)
	{
		CloseHandle(m_evtControlQuit);
	}
	SafeReleaseNULL(m_pClientSite);
}


/////////////////////////////////////////////////////////////////////////////
// GetInterfaceSafetyOptions()
//
// Retrieves the safety options supported by the object.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;
	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SetInterfaceSafetyOptions()
//
// Makes the object safe for initialization or scripting.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	// If we're being asked to set our safe for scripting option then oblige
	if (riid == IID_IDispatch)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}
	return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// InterfaceSupportsErrorInfo()
//
// Indicates whether the interface identified by riid supports the 
// IErrorInfo interface
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::InterfaceSupportsErrorInfo(REFIID riid)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	static const IID* arr[] = 
	{
		&IID_IUpdate
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// GetSystemSpec()
//
// Gets the basic system specs.
// Input:
// bstrXmlClasses - a list of requested classes in xml format, NULL if any.
//				    For example:
//				    <devices>
//				    <class name="video"/>
//				    <class name="sound" id="2560AD4D-3ED3-49C6-A937-4368C0B0E06A"/>
//				    </devices>
// Return:
// pbstrXmlDetectionResult - the detection result in xml format.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetSystemSpec(BSTR	bstrXmlClasses,
									BSTR*	pbstrXmlDetectionResult)
{
	HRESULT hr = E_FAIL;

	LOG_Block("CUpdate::GetSystemSpec");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetSystemSpec pfnGetSystemSpec = (PFN_GetSystemSpec)GetProcAddress(m_hEngineModule, "EngGetSystemSpec");
        DWORD dwFlags = 0x0;

        if (m_fOfflineMode)
        {
            dwFlags |= FLAG_OFFLINE_MODE;
        }

        if (NULL != m_hIUEngine && NULL != pfnGetSystemSpec)
		{
			hr = pfnGetSystemSpec(m_hIUEngine, bstrXmlClasses, dwFlags, pbstrXmlDetectionResult);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}
	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetManifest()
//
// Gets a catalog base on the specified information.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlSystemSpec - the detected system specifications in xml
// bstrXmlQuery - the user query infomation in xml
// Return:
// pbstrXmlCatalog - the xml catalog retrieved
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetManifest(BSTR			bstrXmlClientInfo,
								  BSTR			bstrXmlSystemSpec,
								  BSTR			bstrXmlQuery,
								  BSTR*			pbstrXmlCatalog)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::GetManifest");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // if we are in offline mode we can't download from the internet.
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetManifest pfnGetManifest = (PFN_GetManifest)GetProcAddress(m_hEngineModule, "EngGetManifest");

		if (NULL != m_hIUEngine && NULL != pfnGetManifest)
		{
			DWORD dwFlags = 0x0;
			
			if (m_fUseCompression)
			{
				dwFlags |= FLAG_USE_COMPRESSION;
			}
			
			hr = pfnGetManifest(m_hIUEngine, bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, dwFlags, pbstrXmlCatalog);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Detect()
//
// Do detection.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be detected 
// Output:
// pbstrXmlItems - the detected items in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1" force="1"/>
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Detect(BSTR		bstrXmlCatalog, 
							 BSTR*		pbstrXmlItems)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::Detect");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_Detect pfnDetect = (PFN_Detect)GetProcAddress(m_hEngineModule, "EngDetect");
        DWORD dwFlags = 0x0;

        if (m_fOfflineMode)
        {
            dwFlags |= FLAG_OFFLINE_MODE;
        }

		if (NULL != m_hIUEngine && NULL != pfnDetect)
		{
			hr = pfnDetect(m_hIUEngine, bstrXmlCatalog, dwFlags, pbstrXmlItems);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Download()
//
// Do synchronized downloading.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - indicates throttled or fore-ground downloading mode
// punkProgressListener - the callback function pointer for reporting download progress
// Output:
// pbstrXmlItems - the items with download status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Download(BSTR			bstrXmlClientInfo,
							   BSTR			bstrXmlCatalog, 
							   BSTR			bstrDestinationFolder,
							   LONG			lMode,
							   IUnknown*	punkProgressListener,
							   BSTR*		pbstrXmlItems)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::Download");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // if we are in offline mode we can't download from the internet.
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_Download pfnDownload = (PFN_Download)GetProcAddress(m_hEngineModule, "EngDownload");

		if (NULL != m_hIUEngine && NULL != pfnDownload)
		{
			hr = pfnDownload(m_hIUEngine,
							 bstrXmlClientInfo,
							 bstrXmlCatalog,
							 bstrDestinationFolder,
							 lMode,
							 punkProgressListener,
							 m_EvtWindow.GetEvtHWnd(),	// should we send event msg for sync download?
							 pbstrXmlItems);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DownloadAsync()
//
// Download asynchronously -  the method will return before completion.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - indicates throttled or fore-ground downloading mode
// punkProgressListener - the callback function pointer for reporting download progress
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID,
//                      in which case, the caller will be responsible to free the memory of
//                      the string buffer that holds the generated UUID using SysFreeString(). 
//                      Otherwise, it returns the value passed by bstrUuidOperation.        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::DownloadAsync(BSTR		bstrXmlClientInfo,
									BSTR		bstrXmlCatalog, 
									BSTR		bstrDestinationFolder,
									LONG		lMode,
									IUnknown*	punkProgressListener, 
									BSTR		bstrUuidOperation,
									BSTR*		pbstrUuidOperation)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::DownloadAsync");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // if we are in offline mode we can't download from the internet.
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_DownloadAsync pfnDownloadAsync = (PFN_DownloadAsync)GetProcAddress(m_hEngineModule, "EngDownloadAsync");

		if (NULL != m_hIUEngine && NULL != pfnDownloadAsync)
		{
			hr = pfnDownloadAsync(m_hIUEngine,
								  bstrXmlClientInfo,
								  bstrXmlCatalog,
								  bstrDestinationFolder,
								  lMode,
								  punkProgressListener,
								  m_EvtWindow.GetEvtHWnd(),
								  bstrUuidOperation,
								  pbstrUuidOperation);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Install()
//
// Do synchronized installation.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// lMode - indicates different installation mode
// punkProgressListener - the callback function pointer for reporting install progress
// Output:
// pbstrXmlItems - the items with installation status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1"/>
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Install(BSTR      bstrXmlClientInfo,
                              BSTR		bstrXmlCatalog,
							  BSTR		bstrXmlDownloadedItems,
							  LONG		lMode,
							  IUnknown*	punkProgressListener,
							  BSTR*		pbstrXmlItems)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::Install");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // make sure offline mode parameter is set if SetProperty() Offline Mode was Set
        lMode |= UPDATE_OFFLINE_MODE;
    }

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_Install pfnInstall = (PFN_Install)GetProcAddress(m_hEngineModule, "EngInstall");

		if (NULL != m_hIUEngine && NULL != pfnInstall)
		{
			hr = pfnInstall(m_hIUEngine,
							bstrXmlClientInfo,
                            bstrXmlCatalog,
							bstrXmlDownloadedItems,
							lMode,
							punkProgressListener,
							m_EvtWindow.GetEvtHWnd(),
							pbstrXmlItems);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// InstallAsync()
//
// Install Asynchronously.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// lMode - indicates different installation mode
// punkProgressListener - the callback function pointer for reporting install progress
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID,
//                      in which case, the caller will be responsible to free the memory of
//                      the string buffer that holds the generated UUID using SysFreeString(). 
//                      Otherwise, it returns the value passed by bstrUuidOperation.        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::InstallAsync(BSTR         bstrXmlClientInfo,
                                   BSTR			bstrXmlCatalog,
								   BSTR			bstrXmlDownloadedItems,
								   LONG			lMode,
								   IUnknown*	punkProgressListener, 
								   BSTR			bstrUuidOperation,
								   BSTR*		pbstrUuidOperation)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::InstallAsync");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // make sure offline mode parameter is set if SetProperty() Offline Mode was Set
        lMode |= UPDATE_OFFLINE_MODE;
    }

    //
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_InstallAsync pfnInstallAsync = (PFN_InstallAsync)GetProcAddress(m_hEngineModule, "EngInstallAsync");

		if (NULL != m_hIUEngine && NULL != pfnInstallAsync)
		{
			hr = pfnInstallAsync(m_hIUEngine,
								 bstrXmlClientInfo,
                                 bstrXmlCatalog,
								 bstrXmlDownloadedItems,
								 lMode,
								 punkProgressListener,
								 m_EvtWindow.GetEvtHWnd(),
								 bstrUuidOperation,
								 pbstrUuidOperation);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// SetOperationMode()
//		Set the operation status.
//
// Input:
//		bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
//		lMode - the mode affecting the operation:
//
//				UPDATE_COMMAND_PAUSE
//				UPDATE_COMMAND_RESUME
//				UPDATE_COMMAND_CANCEL
//				UPDATE_NOTIFICATION_COMPLETEONLY
//				UPDATE_NOTIFICATION_ANYPROGRESS
//				UPDATE_NOTIFICATION_1PCT
//				UPDATE_NOTIFICATION_5PCT
//				UPDATE_NOTIFICATION_10PCT
//				UPDATE_SHOWUI
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::SetOperationMode(
								BSTR	bstrUuidOperation,
								LONG	lMode)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::SetOperationMode");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_SetOperationMode pfnSetOperationMode = (PFN_SetOperationMode)GetProcAddress(m_hEngineModule, "EngSetOperationMode");

		if (NULL != m_hIUEngine && NULL != pfnSetOperationMode)
		{
			hr = pfnSetOperationMode(m_hIUEngine, bstrUuidOperation, lMode);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetHistory()
//
// Get the history log.
// Input:
// bstrDateTimeFrom - the start date and time for which a log is required.
//                    This is a string in ANSI format (YYYY-MM-DDTHH-MM). 
//                    If the string is empty, there will be no date restriction 
//                    of the returned history log.
// bstrDateTimeTo - the end date and time for which a log is required.
//                  This is a string in ANSI format (YYYY-MM-DDTHH-MM).
//                  If the string is empty, there will be no date restriction
//                  of the returned history log.
// bstrClient - the name of the client that initiated the action. If this parameter 
//              is null or an empty string, then there will be no filtering based 
//              on the client.
// bstrPath - the path used for download or install. Used in the corporate version 
//            by IT managers. If this parameter is null or an empty string, then 
//            there will be no filtering based on the path.
// Output:
// pbstrLog - the history log in xml format
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetHistory(BSTR		bstrDateTimeFrom,
								 BSTR		bstrDateTimeTo,
								 BSTR		bstrClient,
								 BSTR		bstrPath,
								 BSTR*		pbstrLog)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::GetHistory");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetHistory pfnGetHistory = (PFN_GetHistory)GetProcAddress(m_hEngineModule, "EngGetHistory");

		if (NULL != m_hIUEngine && NULL != pfnGetHistory)
		{
			hr = pfnGetHistory(m_hIUEngine,
							   bstrDateTimeFrom,
							   bstrDateTimeTo,
							   bstrClient,
							   bstrPath,
							   pbstrLog);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}


	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// private overriding function InternalRelease(), to unlock the engine
// if the reference (before the release) is 1, i.e., the last ref
// count about to be released
//
/////////////////////////////////////////////////////////////////////////////
ULONG CUpdate::InternalRelease()
{
	if (1 == m_dwRef)
	{
		//
		// the control is going to really gone, we need to make sure that 
		// if the engine is loaded, we unload it here.
		//
		UnlockEngine();
		CleanupDownloadLib();
	}

	return CComObjectRootEx<CComMultiThreadModel>::InternalRelease();
}

/////////////////////////////////////////////////////////////////////////////
// UnlockEngine()
//
// release the engine dll if ref cnt of engine is down to zero
/////////////////////////////////////////////////////////////////////////////
HRESULT CUpdate::UnlockEngine()
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	TCHAR szSystemDir[MAX_PATH];
    TCHAR szEngineDllPath[MAX_PATH];
    TCHAR szEngineNewDllPath[MAX_PATH];
	int iVerCheck = 0;
	HRESULT hr = S_OK;

	SetEvent(m_evtControlQuit);

	EnterCriticalSection(&m_lock);

	if (NULL != m_hEngineModule)
	{
		//
		// We have to delete the engine instance we are using. This will clean up
		// all resources, stop threads, etc. for the instance we own.
		//
		PFN_DeleteEngUpdateInstance pfnDeleteEngUpdateInstance = (PFN_DeleteEngUpdateInstance) GetProcAddress(m_hEngineModule, "DeleteEngUpdateInstance");

		if (NULL != pfnDeleteEngUpdateInstance)
		{
			pfnDeleteEngUpdateInstance(m_hIUEngine);
		}

		//
		// Cleanup any global threads (it checks to see if we are last instance)
		//
		PFN_ShutdownGlobalThreads pfnShutdownGlobalThreads = (PFN_ShutdownGlobalThreads) GetProcAddress(m_hEngineModule, "ShutdownGlobalThreads");

		if (NULL != pfnShutdownGlobalThreads)
		{
			pfnShutdownGlobalThreads();
		}

		//
		// unload engine
		//
		FreeLibrary(m_hEngineModule);
        m_hEngineModule = NULL;
        m_lInitState = 0; // mark as uninitialized

		//
		// get path of enginenew.dll
		//
		GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));
		hr = PathCchCombine(szEngineNewDllPath, ARRAYSIZE(szEngineNewDllPath), szSystemDir,ENGINENEWDLL);
		if (FAILED(hr))
		{
			return hr;
		}

		//
		// see if we should try to update the engine (locally)
		//
		HKEY hkey = NULL;
		DWORD dwStatus = 0;
		DWORD dwSize = sizeof(dwStatus);
		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkey))
		{
			RegQueryValueEx(hkey, REGVAL_SELFUPDATESTATUS, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
		}
		if (FileExists(szEngineNewDllPath) && 
			S_OK == VerifyFileTrust(szEngineNewDllPath, NULL, ReadWUPolicyShowTrustUI()) &&
			SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
		{
			// an iuenginenew.dll exists, try replacing the engine.dll This will fail if this is
			// not the last process using the engine. This is not a problem, when that process
			// finishes it will rename the DLL.
			hr = PathCchCombine(szEngineDllPath, ARRAYSIZE(szEngineDllPath), szSystemDir,ENGINEDLL);
			if (FAILED(hr))
			{
				return hr;
			}
			if (SUCCEEDED(CompareFileVersion(szEngineDllPath, szEngineNewDllPath, &iVerCheck)) &&
				iVerCheck < 0 &&
				TRUE == MoveFileEx(szEngineNewDllPath, szEngineDllPath, MOVEFILE_REPLACE_EXISTING))
			{
				// Rename was Successful.. reset RegKey Information about SelfUpdate Status
				// Because the rename was successful we know no other processes are interacting
				// It should be safe to set the reg key.
				dwStatus = 0;	// PreFast
				RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
			}
		}
		else if (SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
		{
			// registry indicates rename required, but enginenew DLL does not exist. Reset registry
			dwStatus = 0;
			RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
		}
        if (NULL != hkey)
        {
            RegCloseKey(hkey);
        }
	}

	LeaveCriticalSection(&m_lock);
	ResetEvent(m_evtControlQuit);

	return S_OK;
}




/**
*
* Get the mode of a specified operation.
*
* @param bstrUuidOperation: same as in SetOperationMode()
* @param plMode - the retval for the mode found in a bitmask for:
*					(value in brackets [] means default)
*					UPDATE_COMMAND_PAUSE (TRUE/[FALSE])
*					UPDATE_COMMAND_RESUME (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_COMPLETEONLY (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_ANYPROGRESS ([TRUE]/FALSE)
*					UPDATE_NOTIFICATION_1PCT (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_5PCT (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_10PCT (TRUE/[FALSE])
*					UPDATE_SHOWUI (TRUE/[FALSE])
*
*/
STDMETHODIMP CUpdate::GetOperationMode(BSTR bstrUuidOperation, LONG *plMode)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::GetOperationMode");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetOperationMode pfnGetOperationMode = (PFN_GetOperationMode)GetProcAddress(m_hEngineModule, "EngGetOperationMode");

		if (NULL != m_hIUEngine && NULL != pfnGetOperationMode)
		{
			hr = pfnGetOperationMode(m_hIUEngine, bstrUuidOperation, plMode);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}




/**
* 
* Set a property of this control
*		Calling this method will not cause the engine loaded
*
* @param lProperty - the identifier to flag which property need changed
*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
*
* @param varValue - the value to change
*
*/
STDMETHODIMP CUpdate::SetProperty(LONG lProperty, VARIANT varValue)
{
	LOG_Block("CUpdate::SetProperty");
	HRESULT hr = S_OK;

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	switch(lProperty)
	{
	case UPDATE_PROP_USECOMPRESSION:
		if (VT_BOOL != varValue.vt)
		{
			hr = E_INVALIDARG;
			LOG_ErrorMsg(hr);
		}
		else
		{
			m_fUseCompression = (VARIANT_TRUE == varValue.boolVal) ? TRUE : FALSE;
		}
		break;
    case UPDATE_PROP_OFFLINEMODE:
        if (VT_BOOL != varValue.vt)
        {
            hr = E_INVALIDARG;
            LOG_ErrorMsg(hr);
        }
        else
        {
            m_fOfflineMode = (VARIANT_TRUE == varValue.boolVal) ? TRUE : FALSE;
        }
        break;
	default:
		return E_NOTIMPL;
	}

	return S_OK;
}



/**
* 
* Retrieve a property of this control
*		Calling this method will not cause the engine loaded
*
* @param lProperty - the identifier to flag which property need retrieved
*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
*
* @param varValue - the value to retrieve
*					
*/
STDMETHODIMP CUpdate::GetProperty(LONG lProperty, VARIANT *pvarValue)
{
	LOG_Block("CUpdate::GetProperty");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	if (NULL == pvarValue)
	{
		return E_INVALIDARG;
	}
	
	VariantInit(pvarValue);

	switch(lProperty)
	{
	case UPDATE_PROP_USECOMPRESSION:
		pvarValue->vt = VT_BOOL;
		pvarValue->boolVal = (m_fUseCompression) ? VARIANT_TRUE : VARIANT_FALSE;
		break;
    case UPDATE_PROP_OFFLINEMODE:
        pvarValue->vt = VT_BOOL;
        pvarValue->boolVal = (m_fOfflineMode) ? VARIANT_TRUE : VARIANT_FALSE;
        break;
	default:
		return E_NOTIMPL;
	}

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// Primarily expose shlwapi BrowseForFolder API, can also do checking
// on R/W access if flagged so.
//
// @param bstrStartFolder - the folder from which to start. If NULL or empty str
//							is being passed in, then start from desktop
//
// @param flag - validating check 
//							UI_WRITABLE for checking write access, OK button may disabled. 
//							UI_READABLE for checking read access, OK button may disabled. 
//							NO_UI_WRITABLE for checking write access, return error if no access
//							NO_UI_READABLE for checking read access,  return error if no access
//							0 (default) for no checking.
//
// @param pbstrFolder - returned folder if a valid folder selected
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::BrowseForFolder(BSTR bstrStartFolder, LONG flag, BSTR* pbstrFolder)
{
	HRESULT hr = E_FAIL;

	LOG_Block("CUpdate::BrowseForFolder");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_BrowseForFolder pfnBrowseForFolder = (PFN_BrowseForFolder)GetProcAddress(m_hEngineModule, "EngBrowseForFolder");

		if (NULL != m_hIUEngine && NULL != pfnBrowseForFolder)
		{
			hr = pfnBrowseForFolder(m_hIUEngine, bstrStartFolder, flag, pbstrFolder);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}
	}
    
	return hr;
}

/**
*
* Allows the Caller to Request the Control to do a Reboot 
*
*/
STDMETHODIMP CUpdate::RebootMachine()
{
	HRESULT hr = E_FAIL;

	LOG_Block("CUpdate::RebootMachine");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
        PFN_RebootMachine pfnRebootMachine = (PFN_RebootMachine)GetProcAddress(m_hEngineModule, "EngRebootMachine");

        if (NULL != m_hIUEngine && NULL != pfnRebootMachine)
        {
            hr = pfnRebootMachine(m_hIUEngine);
        }
        else
        {
            LOG_ErrorMsg(ERROR_INVALID_DLL);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
        }
    }
    return hr;
}

//
//  Override of IObjectWithSite::SetSite()
//  Internet Explorer QIs for IObjectWithSite, and calls this method
//  with a pointer to its IOleClientSite
//
STDMETHODIMP CUpdate::SetSite(IUnknown* pSite)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	SafeReleaseNULL(m_pClientSite);
    m_pClientSite = pSite;
	if (NULL != m_pClientSite)
		m_pClientSite->AddRef();
    return IObjectWithSiteImpl<CUpdate>::SetSite(pSite);
}




/**
* 
* Security feature: make sure if the user of this control is
* a web page then the URL can be found in iuident.txt
*
* This function should be called after iuident refreshed.
*
* Return: TRUE/FALSE, to tell if we can continue
*					
*/


const TCHAR IDENT_IUSERVERCACHE[]		= _T("IUServerURLs");
const TCHAR IDENT_IUSERVERCOUNT[]		= _T("ServerCount");
const TCHAR IDENT_IUSERVER[]			= _T("Server");



HRESULT CUpdate::ValidateControlContainer(void)
{
	LOG_Block("ValidateControlContainer");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	IServiceProvider* pISP = NULL;
	IWebBrowserApp* pWeb = NULL;
	BSTR bstrUrl = NULL;
	LPTSTR lpszUrl = NULL;
#if !(defined(_UNICODE) || defined(UNICODE))
	// ANSI build
	LPSTR lpszAnsiUrl = NULL;
#endif
	TCHAR szIUDir[MAX_PATH];
	TCHAR szIdentFile[MAX_PATH];
	TCHAR szServer[32];
	LPTSTR szValidURL = NULL;
			
	if (E_FAIL != m_hValidated)
	{
		//
		// has been invalidated already
		//
		LOG_Internet(_T("Validate result: %s"), SUCCEEDED(m_hValidated) ? _T("S_OK") : _T("INET_E_INVALID_URL"));
		return m_hValidated;
	}
	//
	// check to see if the container is a web page/site, if
	// not done so yet.
	//
	if (NULL != m_pClientSite)
	{
		//
		// this is a web site!
		//
		m_hValidated = INET_E_INVALID_URL;
		LOG_Internet(_T("Found control called by a web page"));

		if (SUCCEEDED(m_pClientSite->QueryInterface(IID_IServiceProvider, (void**)&pISP)) &&
			NULL != pISP &&
			SUCCEEDED(pISP->QueryService(IID_IWebBrowserApp, IID_IWebBrowserApp, (void**)&pWeb)) &&
			NULL != pWeb &&
			SUCCEEDED(pWeb->get_LocationURL(&bstrUrl)) && 
			NULL != bstrUrl)
		{
#if defined(_UNICODE) || defined(UNICODE)
			lpszUrl = bstrUrl;
#else		// ANSI build
			int nBufferLength = WideCharToMultiByte(CP_ACP, 0, bstrUrl, -1, NULL, 0, NULL, NULL);

			lpszAnsiUrl = (LPSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nBufferLength);
			if (NULL == lpszAnsiUrl || 0 == nBufferLength)
			{
				//
				// Unfortunately, we return this error in place of E_OUTOFMEMORY, but the most
				// likely scenario that would cause this would be a security attack (bad URL)
				//
				goto CleanUp;	// Will return INET_E_INVALID_URL
			}

			WideCharToMultiByte(CP_ACP, 0, bstrUrl, -1, lpszAnsiUrl, nBufferLength, NULL, NULL);
			lpszUrl = lpszAnsiUrl;
#endif

			LOG_Internet(_T("Web address = %s"), lpszUrl);

			//
			// no matter what protocol specified in this URL
			// (can be anything: http, ftp, UNC, path...)
			// we just need to verify it against iuident.txt
			//

			szValidURL = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
			if (NULL == szValidURL)
			{
				SafeReleaseNULL(pISP);
				SafeReleaseNULL(pWeb);
				SysFreeString(bstrUrl);
				LOG_ErrorMsg(E_OUTOFMEMORY);
				return E_OUTOFMEMORY;
			}
			
			GetIndustryUpdateDirectory(szIUDir);
			m_hValidated = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir,IDENTTXT);
			if (FAILED(m_hValidated))
			{
				SafeReleaseNULL(pISP);
				SafeReleaseNULL(pWeb);
				SysFreeString(bstrUrl);
				SafeHeapFree(szValidURL);
				LOG_ErrorMsg(m_hValidated);
				return m_hValidated;
			}

			// Fix of bug 557430: IU: Security: Use InternetCrackUrl to verify server url used by control.
			URL_COMPONENTS urlComp;
			ZeroMemory(&urlComp, sizeof(urlComp));
			urlComp.dwStructSize = sizeof(urlComp);

			// Only interested in the hostname
			LPTSTR pszHostName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
			urlComp.lpszHostName = pszHostName;
			urlComp.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

#if defined(UNICODE)
			pfn_InternetCrackUrl pfnInternetCrackUrl = (pfn_InternetCrackUrl)GetProcAddress(
					GetModuleHandle(_T("wininet.dll")), "InternetCrackUrlW");
#else
			pfn_InternetCrackUrl pfnInternetCrackUrl = (pfn_InternetCrackUrl)GetProcAddress(
					GetModuleHandle(_T("wininet.dll")), "InternetCrackUrlA");
#endif

			if (pfnInternetCrackUrl != NULL)
			{
				BOOL fRet = (*pfnInternetCrackUrl)(lpszUrl, 0, 0, &urlComp);
				if (fRet==FALSE) {
					SafeHeapFree(pszHostName);
					m_hValidated = INET_E_INVALID_URL;
					goto CleanUp;
				}
			}
			else
			{
				SafeHeapFree(pszHostName);
				SafeReleaseNULL(pISP);
				SafeReleaseNULL(pWeb);
				SysFreeString(bstrUrl);
				SafeHeapFree(szValidURL);
				m_hValidated = ERROR_PROC_NOT_FOUND;
				LOG_ErrorMsg(m_hValidated);
				return m_hValidated;		
			}
				
			//
			// get number to servers to compare
			//
			int iServerCnt = GetPrivateProfileInt(IDENT_IUSERVERCACHE,
											  IDENT_IUSERVERCOUNT,
											  -1,
											  szIdentFile);
			
			//
			// loop through 
			//
			URL_COMPONENTS urlCompi;
			m_hValidated = INET_E_INVALID_URL;
			for (INT i=1; i<=iServerCnt; i++)
			{
				StringCchPrintfEx(szServer,ARRAYSIZE(szServer),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%s%d"), IDENT_IUSERVER, i);
			
				//
				// get valid server from iuident
				//
				GetPrivateProfileString(IDENT_IUSERVERCACHE,
										szServer,
										_T(""),
										szValidURL,
										INTERNET_MAX_URL_LENGTH,
										szIdentFile);

				ZeroMemory(&urlCompi, sizeof(urlCompi));
				urlCompi.dwStructSize = sizeof(urlCompi);

				LPTSTR pszHostNamei = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				urlCompi.lpszHostName = pszHostNamei;
				urlCompi.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

				if (TRUE == (*pfnInternetCrackUrl)(szValidURL, 0, 0, &urlCompi))
				{
					if (0 == lstrcmpi(urlComp.lpszHostName, urlCompi.lpszHostName))
					{
						//
						// Found the current site URL is in this valid URL domain!
						//
						LogMessage("Windows Update Web Site has a valid address: %ls", bstrUrl);
						m_hValidated = S_OK;
						SafeHeapFree(pszHostNamei);
						break;
					}
				}
				SafeHeapFree(pszHostNamei);
			}
			SafeHeapFree(pszHostName);
		}
	}
	else
	{
		//
		// NTRAID#NTBUG9-436604-2001/07/17-waltw  Security fix: block possible user system information
		// leak to non WU callers
		//
		// If the COM user doesn't call SetSite on our IObjectWithSiteImpl to set m_pClientSite or doesn't
		// support IID_IWebBrowserApp functionality on the client site then we won't support them since
		// we can't validate the URL that invoked us
		//
		m_hValidated = INET_E_INVALID_URL;
	}

CleanUp:
	SafeReleaseNULL(pISP);
	SafeReleaseNULL(pWeb);
	SysFreeString(bstrUrl);
	SafeHeapFree(szValidURL);

	LOG_Internet(_T("Validate result: %s"), SUCCEEDED(m_hValidated) ? _T("S_OK") : _T("INET_E_INVALID_URL"));

	if (FAILED(m_hValidated) && NULL != lpszUrl)
	{
#if defined(UNICODE) || defined(_UNICODE)
		LogError(m_hValidated, "Site URL %ls is not valid", lpszUrl);
#else
		LogError(m_hValidated, "Site URL %s is not valid", lpszUrl);
#endif
	}


#if !(defined(UNICODE) || defined(_UNICODE))
	if (NULL != lpszAnsiUrl)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID) lpszAnsiUrl);
	}
#endif

	return m_hValidated;
}



/////////////////////////////////////////////////////////////////////////////
//
// PRIVATE DetectEngine()
//
// download the ident and find out if need to update engine
//
// Note that this function itself is not thread safe. Need to call it
// inside critical section
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CUpdate::DetectEngine(BOOL *pfUpdateAvail)
{
	LOG_Block("GetPropUpdateInfo()");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_OK;

	if (NULL == pfUpdateAvail)
	{
		return E_INVALIDARG;
	}

	*pfUpdateAvail = FALSE;

	//
	// get the latest ident
	//
	if (NULL == m_hEngineModule)
	{
		//
        // This is the first load of the engine for this instance, check for selfupdate first.
        // First step is to check for an updated iuident.cab and download it.
		//

		//
        // Only Download the Ident if we are NOT in Offline Mode
		//
        if (!m_fOfflineMode)
		{
		    //
			// download iuident and populate g_pIUUrlAgent
			//
			if (FAILED(hr = DownloadIUIdent_PopulateData()))
			{
				LOG_ErrorMsg(hr);
				return hr;
			}

			//
			// check engine update info. Note that since 2nd pram is FALSE
			// means don't do any actual update, therefore its 1st argument
			// is also ignored.
			//
            hr = SelfUpdateCheck(
								 FALSE,			// async update? ignored now
								 FALSE,			// don't do actual update
								 m_evtControlQuit, // quit event.
								 NULL,			// no event firing
								 NULL			// no callback needed
								 );

            if (IU_SELFUPDATE_FAILED == hr)
            {
                LOG_Error(_T("SelfUpdate Failed, using current Engine DLL"));
			    hr = S_FALSE; // not fatal, let the existing engine work
            }

            *pfUpdateAvail = (S_FALSE == hr);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// Initialize() API must be called before any other API will function
//
// If any other API is called before the control is initialized, 
// that API will return OLE_E_BLANK, signalling this OLE control is an 
// uninitialized object (although in this case it's a bit different from 
// its original meaning)
//
// Parameters:
//
//	lInitFlag - IU_INIT_CHECK, cause Initialize() download ident and check if any
//				of the components need updated. currently we support control version
//				check and engine version check. Return value is a bit mask
//
//			  - IU_INIT_UPDATE_SYNC, cause Initialize() kicks off update engine
//				process if already called by IU_INIT_CHECK and a new engine is available.
//				When API returns, the update process is finished.
//
//			  - IU_INIT_UPDATE_ASYNC, cause Initialize() kicks off update engine
//				process in Asynchronized mode if already called by IU_INIT_CHECK and
//				a new engine is available. This API will return right after the 
//				update process starts. 
//
//	punkUpdateCompleteListener - this is a pointer to a user-implemented 
//				COM callback feature. It contains only one function OnComplete() that
//				will be called when the engine update is done.
//				This value can be NULL.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Initialize(LONG lInitFlag, IUnknown *punkUpdateCompleteListener, LONG *plRetVal)
{
	HRESULT hr = S_OK;

	LOG_Block("Initialize()");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	TCHAR szFilePath[MAX_PATH + 1] = {0};
	FILE_VERSION verControl;
	int   iCompareResult = 0;
	DWORD dwErr = 0;
    char szAnsiRequiredControlVersion[64];

	LOG_Out(_T("Parameters: (0x%08x, 0x%08x, 0x%08x)"), lInitFlag, punkUpdateCompleteListener, plRetVal);

	//
	// we should to previlidge check first.
	//
	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}
	if (0x0 == GetLogonGroupInfo())
	{
		//
		// if the current logon is neither member of admins nor power users
		// or windows update is disabled, there is no need to continue
		//
		return E_ACCESSDENIED;
	}


	USES_CONVERSION;
	
	EnterCriticalSection(&m_lock);

	LPTSTR ptszLivePingServerUrl = NULL;
	LPTSTR ptszCorpPingServerUrl = NULL;

	if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED(g_pIUUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get corp WU ping server URL"));
			SafeHeapFree(ptszCorpPingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
	}

	if (IU_INIT_CHECK == lInitFlag)
	{
		// RAID: 453770 IU - IUCTL - Initialize check returns Engine update required
		// after downloading new engine using Initialize Sync/Async
		// Fix: initialize dwFlag to 0 rather than m_dwUpdateInfo (carried forward
		// previous IU_UPDATE_ENGINE_BIT even when new engine had been brought down).
		DWORD dwFlag = 0;
		BOOL fEngineUpdate = FALSE;

		FILE_VERSION verCurrent;


		CleanUpIfFalseAndSetHrMsg((NULL == plRetVal), E_INVALIDARG);

		hr = DetectEngine(&fEngineUpdate);
		if (IU_SELFUPDATE_USENEWDLL == hr)
		{
			//
			// found engine already been updated by someone,
			// but not renamed to iuengine.dll yet
			//
			// doesn't matter to us,since we always try
			// to load enginenew before we try to load eng.
			//
			hr = S_OK;
		}

		if (g_pIUUrlAgent->HasBeenPopulated())
		{
			ptszLivePingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
			CleanUpFailedAllocSetHrMsg(ptszLivePingServerUrl);

			if (FAILED(g_pIUUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Out(_T("failed to get live ping server URL"));
				SafeHeapFree(ptszLivePingServerUrl);
			}
		}

		CleanUpIfFailedAndMsg(hr);

		if (fEngineUpdate)
		{
			dwFlag = IU_UPDATE_ENGINE_BIT;
		}

		//
		// get required version number of iuctl from iuident
		//

        GetIndustryUpdateDirectory(szFilePath);
		CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), IDENTTXT));

		(void) GetPrivateProfileString(
									_T("IUControl"), 
									_T("ControlVer"), 
									_T("0.0.0.0"), 
									m_szReqControlVer, 
									ARRAYSIZE(m_szReqControlVer), 
									szFilePath);

#ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, m_szReqControlVer, -1, szAnsiRequiredControlVersion, 
            sizeof(szAnsiRequiredControlVersion), NULL, NULL);
		ConvertStringVerToFileVer(szAnsiRequiredControlVersion, &verControl);
#else
		ConvertStringVerToFileVer(m_szReqControlVer, &verControl);
#endif

		//
		// get current iuctl.dll version number
		//
		szFilePath[0] = _T('\0');
		if (0 == GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath)))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), _T("iuctl.dll")));

		//
		// change for bug fix 488487 by charlma 11/30/2001
		// in order to output file ver to freelog, we dig out verionn here:
		//

		//
		// if we failed to get the version, GetFileVersion() alraedy produced debug log. 
		// we just use 0.0.0.0 to do compare, since in that case we need to update it!
		//
		ZeroMemory((void*)(&verCurrent), sizeof(verCurrent));
		if (GetFileVersion(szFilePath, &verCurrent))
		{
			LogMessage("Current iuctl.dll version: %d.%d.%d.%d", 
										verCurrent.Major, 
										verCurrent.Minor, 
										verCurrent.Build, 
										verCurrent.Ext);
		}
		iCompareResult = CompareFileVersion(verCurrent, verControl);

		//CleanUpIfFailedAndSetHrMsg(CompareFileVersion(szFilePath, verControl, &iCompareResult));

		if (iCompareResult < 0)
		{
			//
			// if current control dll (szFilePath) has lower version
			// then the one specified in ident
			//
			dwFlag |= IU_UPDATE_CONTROL_BIT;

#if defined(UNICODE) || defined(_UNICODE)
			LogMessage("IUCtl needs update to %ls", m_szReqControlVer);
#else
			LogMessage("IUCtl needs update to %s", m_szReqControlVer);
#endif
		}

		//
		// also output engine version
		//
		if ((0 != GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath)) &&
			SUCCEEDED(hr = PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), _T("iuenginenew.dll"))) &&
			GetFileVersion(szFilePath, &verCurrent)) ||
			(0 != GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath)) &&
			SUCCEEDED(hr = PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), _T("iuengine.dll"))) &&
			GetFileVersion(szFilePath, &verCurrent))
			)
		{
			LogMessage("Current iuengine.dll version: %d.%d.%d.%d", 
										verCurrent.Major, 
										verCurrent.Minor, 
										verCurrent.Build, 
										verCurrent.Ext);
		}

					
		*plRetVal = (LONG) dwFlag;
		m_dwUpdateInfo = dwFlag;

		if (0x0 == dwFlag)
		{
			//
			// no update needed. move to READY stage
			//
			m_lInitState = 2;
		}
		else
		{
			m_lInitState = 1; // we have update work to do!
		}
	}
	else
	{
		BOOL fSync = (IU_INIT_UPDATE_SYNC == lInitFlag);

		if (!fSync && (IU_INIT_UPDATE_ASYNC != lInitFlag))
		{
			//
			// unknown flag
			//
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}

		if (1 != m_lInitState || (m_dwUpdateInfo & IU_UPDATE_CONTROL_BIT))
		{
			//
			// if we are not indicated that update needed. this 
			// call shouldn't happen at all!
			//
			SetHrMsgAndGotoCleanUp(E_UNEXPECTED);
		}

		//
		// we need to check update again before we kick off the 
		// actual update process since we don't know when last
		// time you get the info saying we need to update. Probably
		// it's already been updated, or is being updated.
		//
		// so we call the check function again but this time tell 
		// the check function that if update needed then do it.
		//
		hr = SelfUpdateCheck(fSync, TRUE, m_evtControlQuit, this, punkUpdateCompleteListener);
		if (IU_SELFUPDATE_USENEWDLL == hr)
		{
			//
			// found engine already been updated by someone,
			// but not renamed to iuengine.dll yet
			//
			// doesn't matter to us,since we always try
			// to load enginenew before we try to load eng.
			//
			m_lInitState = 2;
			hr = S_OK;
		}


		if (fSync && SUCCEEDED(hr))
		{
			//
			// synchronized update done and successful
			//
			m_lInitState = 2;
		}


		if (NULL != plRetVal)
		{
			*plRetVal = (LONG)hr;	// result pass out: 0 or error code

		}
	}

	if (2 == m_lInitState)
	{
		if (NULL == m_hEngineModule)
		{
			//
			// check if iuengine new exist and validate the file
			//
			TCHAR szEnginePath[MAX_PATH + 1];
			TCHAR szEngineNewPath[MAX_PATH + 1];
			int cch = 0;
			int iVerCheck = 0;

			cch = GetSystemDirectory(szEnginePath, ARRAYSIZE(szEnginePath));
			CleanUpIfFalseAndSetHrMsg(cch == 0 || cch >= ARRAYSIZE(szEnginePath), HRESULT_FROM_WIN32(GetLastError()));

			(void) StringCchCopy(szEngineNewPath, ARRAYSIZE(szEngineNewPath), szEnginePath);

			hr = PathCchAppend(szEnginePath, ARRAYSIZE(szEnginePath), ENGINEDLL);
			CleanUpIfFailedAndMsg(hr);

			hr = PathCchAppend(szEngineNewPath, ARRAYSIZE(szEngineNewPath), ENGINENEWDLL);
			CleanUpIfFailedAndMsg(hr);

			//
			// try to verify trust of engine new
			//
			if (FileExists(szEngineNewPath) && 
				S_OK == VerifyFileTrust(szEngineNewPath, NULL, ReadWUPolicyShowTrustUI()) &&
				SUCCEEDED(CompareFileVersion(szEnginePath, szEngineNewPath, &iVerCheck)) &&
				iVerCheck < 0)
			{	
				//
				// load the engine
				//
				m_hEngineModule = LoadLibraryFromSystemDir(_T("iuenginenew.dll"));
			}
			if (NULL != m_hEngineModule)
			{
				LOG_Internet(_T("IUCtl Using IUENGINENEW.DLL"));
			}
			else
			{
				LOG_Internet(_T("IUCtl Using IUENGINE.DLL"));
				m_hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));

				if (NULL == m_hEngineModule)
				{
					dwErr = GetLastError();
					LOG_ErrorMsg(dwErr);
					hr = HRESULT_FROM_WIN32(dwErr);
				}
			}

			//
			// If load engine succeeded, get a CEngUpdate instance and start aynsc misc worker threads
			//
			if (NULL != m_hEngineModule)
			{
#if defined(DBG)
				// Log error if m_hIUEngine isn't NULL
				if (NULL != m_hIUEngine)
				{
					LOG_Error(_T("m_hIUEngine should be NULL here!"));
				}
#endif

				PFN_CreateEngUpdateInstance pfnCreateEngUpdateInstance =
					(PFN_CreateEngUpdateInstance) GetProcAddress(m_hEngineModule, "CreateEngUpdateInstance");

				if (NULL != pfnCreateEngUpdateInstance)
				{
					m_hIUEngine = pfnCreateEngUpdateInstance();
				}

				if (NULL == m_hIUEngine)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					FreeLibrary(m_hEngineModule);
					m_hEngineModule = NULL;
				}
				else
				{
					//
					// If load engine and create instance succeeded, start aynsc misc worker threads
					//
					PFN_AsyncExtraWorkUponEngineLoad pfnAsyncExtraWorkUponEngineLoad = 
						(PFN_AsyncExtraWorkUponEngineLoad) GetProcAddress(m_hEngineModule, "AsyncExtraWorkUponEngineLoad");

					if (NULL != pfnAsyncExtraWorkUponEngineLoad)
					{
						pfnAsyncExtraWorkUponEngineLoad();
					}
				}
			}
				
		}

		if (IU_INIT_UPDATE_ASYNC == lInitFlag && SUCCEEDED(hr))
		{
			//
			// this is a rare case: the previous Iniitalize() call tells
			// that engine update needed, but now, when we try to update it
			// in async mode, we found it's no longer true.
			// Must be some other process already complete the engine update
			// task since then. But it may or may not completed the change
			// file name process yet.
			//
			// For us, we just need to signal that we are done to update.
			//

			//
			// signal callback
			//
			IUpdateCompleteListener* pCallback = NULL;
			if (NULL != punkUpdateCompleteListener && (SUCCEEDED(hr = punkUpdateCompleteListener->QueryInterface(IID_IUpdateCompleteListener, (void**) &pCallback))))
			{
				pCallback->OnComplete(dwErr);
				pCallback->Release();
				LOG_Out(_T("Returned from callback API OnComplete()"));
			}
			else
			{
				//
				// signal event if user has not passed in a progress listner IUnknown ptr
				//
				HWND hWnd = m_EvtWindow.GetEvtHWnd();

				if (NULL != hWnd)
				{
					PostMessage(hWnd, UM_EVENT_SELFUPDATE_COMPLETE, 0, (LPARAM)dwErr);
					LOG_Out(_T("Fired event OnComplete()"));
				}
			}


			hr = S_OK;	
		}
	}

CleanUp:

	PingEngineUpdate(
					m_hEngineModule,
					&g_hEngineLoadQuit,
					1,
					ptszLivePingServerUrl,
					ptszCorpPingServerUrl,
					hr,
					_T("IU_SITE"));		// Only the site (other than test) calls this function

	LeaveCriticalSection(&m_lock);

	SafeHeapFree(ptszLivePingServerUrl);
	SafeHeapFree(ptszCorpPingServerUrl);
	return hr;
}




HRESULT CUpdate::ChangeControlInitState(LONG lNewState)
{
	HRESULT hr = S_OK;
	LOG_Block("ChangeControlInitState()");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	EnterCriticalSection(&m_lock);
	m_lInitState = lNewState;
	if (2 == m_lInitState && NULL == m_hEngineModule)
	{
		//
		// load the engine
		//
		m_hEngineModule = LoadLibraryFromSystemDir(_T("iuenginenew.dll"));
		if (NULL != m_hEngineModule)
		{
			LOG_Internet(_T("IUCtl Using IUENGINENEW.DLL"));
		}
		else
		{
			LOG_Internet(_T("IUCtl Using IUENGINE.DLL"));
			m_hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));

			if (NULL == m_hEngineModule)
			{
				DWORD dwErr = GetLastError();
				LOG_ErrorMsg(dwErr);
				hr = HRESULT_FROM_WIN32(dwErr);
			}
		}
		//
		// Create the CEngUpdate instance
		//
		if (NULL != m_hEngineModule)
		{
#if defined(DBG)
			// Log error if m_hIUEngine isn't NULL
			if (NULL != m_hIUEngine)
			{
				LOG_Error(_T("m_hIUEngine should be NULL here!"));
			}
#endif
			PFN_CreateEngUpdateInstance pfnCreateEngUpdateInstance =
				(PFN_CreateEngUpdateInstance) GetProcAddress(m_hEngineModule, "CreateEngUpdateInstance");

			if (NULL != pfnCreateEngUpdateInstance)
			{
				m_hIUEngine = pfnCreateEngUpdateInstance();
			}

			if (NULL == m_hIUEngine)
			{
				hr = E_OUTOFMEMORY;
				LOG_ErrorMsg(hr);
				FreeLibrary(m_hEngineModule);
				m_hEngineModule = NULL;
			}
		}
	}
	LeaveCriticalSection(&m_lock);

	return hr;
}





STDMETHODIMP CUpdate::PrepareSelfUpdate(LONG lStep)
{
	return E_NOTIMPL;
}





/////////////////////////////////////////////////////////////////////////////
//
// Helper API to let the caller (script) knows the necessary information 
// when Initialize() returns control need updated.
//
// For the current implementation, bstrClientName is ignored, and
// the returned bstr has format:
//	"<version>|<url>"
// where:
//	<version> is the expacted version number of the control
//	<url> is the base url to get the control if this is a CorpWU policy controlled machine,
//		  or empty if this is a consumer machine (in that case caller, i.e., script, knows
//		  the default base url, which is the v4 live site)
//
// Script will need these two pieces of information in order to make a right <OBJECT> tag
// for control update.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetControlExtraInfo(BSTR bstrClientName, BSTR *pbstrExtraInfo)
{
	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
//
// new Win32 API called by wrapper control to retrieve update info
//
// 
/////////////////////////////////////////////////////////////////////////////
int GetControlUpdateInfo(LPTSTR lpszUpdateInfo, int cchBufferSize)
{
	LOG_Block("GetControlUpdateInfo()");
	
	HRESULT hr = S_OK;
	int nSize = 0;
	BOOL fCorpUser = FALSE, fBetaSelfUpdate = FALSE;
	FILE_VERSION fvCurrentCtl, fvCurrentEngine;

	TCHAR szDir[MAX_PATH];
	TCHAR szFile[MAX_PATH];
	TCHAR szExpectedEngVer[64];	// 64 should be more then enough
	TCHAR szExpectedCtlVer[64];	// if not enough, then it's bad data anyway

	HKEY hKey;

	DWORD dwErr = ERROR_SUCCESS;	// error code for this API

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		dwErr = ERROR_SERVICE_DISABLED;
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		goto CleanUp;
	}
	if (0x0 == GetLogonGroupInfo())
	{
		dwErr = ERROR_ACCESS_DENIED;
		goto CleanUp;
	}


	if (FAILED(hr = DownloadIUIdent_PopulateData()))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}

	//
	// get current control ver
	//
	GetSystemDirectory(szDir, ARRAYSIZE(szDir));
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,IUCTL);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
	if (!GetFileVersion(szFile, &fvCurrentCtl))
	{
		ZeroMemory(&fvCurrentCtl, sizeof(fvCurrentCtl));
	}


	//
	// get current engine ver
	//
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,ENGINENEWDLL);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
	if (!GetFileVersion(szFile, &fvCurrentEngine))
	{
		//
		// if no engine new there, check engine ver
		//
		hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,ENGINEDLL);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			dwErr = hr;
			goto CleanUp;
		}
		if (!GetFileVersion(szFile, &fvCurrentEngine))
		{
			ZeroMemory(&fvCurrentCtl, sizeof(fvCurrentEngine));
		}
	}

	//
	// check if this is beta code
	//
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL,0, KEY_READ, &hKey))
    {
		// Check for Beta IU SelfUpdate Handling Requested
		DWORD dwStatus = 0;
		DWORD dwSize = sizeof(dwStatus);
		DWORD dwRet = RegQueryValueEx(hKey, REGVAL_BETASELFUPDATE, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
		if (1 == dwStatus)
		{
			fBetaSelfUpdate = TRUE;
		}
		RegCloseKey(hKey);
    }


	//
	// get expected control ver
	//
    GetIndustryUpdateDirectory(szDir);
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,IDENTTXT);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
    GetPrivateProfileString(_T("IUControl"), 
							_T("ControlVer"), 
							_T(""), 
							szExpectedCtlVer, 
							ARRAYSIZE(szExpectedCtlVer), 
							szFile);
    if ('\0' == szExpectedCtlVer[0])
    {
		//
        // no selfupdate available, no server version information. bad ident?
		//
        dwErr = ERROR_FILE_CORRUPT;
		goto CleanUp;
    }


	//
	// get expected engine ver
	//
    GetIndustryUpdateDirectory(szDir);
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,IDENTTXT);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
    GetPrivateProfileString(fBetaSelfUpdate ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
							IDENT_VERSION, 
							_T(""), 
							szExpectedEngVer, 
							ARRAYSIZE(szExpectedEngVer), 
							szFile);
    if ('\0' == szExpectedEngVer[0])
    {
		//
        // no selfupdate available, no server version information. bad ident?
		//
        dwErr = ERROR_FILE_CORRUPT;
		goto CleanUp;
    }


	hr = g_pIUUrlAgent->IsIdentFromPolicy();
	if (FAILED(hr))
	{
		dwErr = (DWORD)hr;
		goto CleanUp;
	}

	fCorpUser = (S_OK == hr) ? TRUE : FALSE;
	hr = S_OK;

	//
	// contscut data
	// the constructed buffer will be in format
	// <CurrentCtlVer>|<ExpCtlVer>|CurrentEngVer>|<ExpEngVer>|<baseUrl>
	//
	nSize = wnsprintf(lpszUpdateInfo, cchBufferSize, _T("%d.%d.%d.%d|%s|%d.%d.%d.%d|%s|%d"),
				fvCurrentCtl.Major, fvCurrentCtl.Minor, fvCurrentCtl.Build, fvCurrentCtl.Ext,
				szExpectedCtlVer,
				fvCurrentEngine.Major, fvCurrentEngine.Minor, fvCurrentEngine.Build, fvCurrentEngine.Ext,
				szExpectedEngVer,
				fCorpUser ? 1 : 0);

	if (nSize < 0)
	{
		nSize = 0;
		dwErr = ERROR_INSUFFICIENT_BUFFER;
		goto CleanUp;
	}
			
CleanUp:

	SetLastError(dwErr);

	return nSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\selfupd.h ===
#ifndef __SELFUPD_H_
#define __SELFUPD_H_

#include <wincrypt.h>
#include <mscat.h>
#include <wininet.h>
#include <iucommon.h>
#include <urllogging.h>

const DWORD SELFUPDATE_NONE = 0;
const DWORD SELFUPDATE_IN_PROGRESS = 1;
const DWORD SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED = 2;

const TCHAR IU_MUTEX_SELFUPDATE_REGCHECK[] = _T("{14649649-37d9-4cd4-aaaf-f066bc0c0b47}");
const TCHAR IU_EVENT_SELFUPDATE_IN_PROGRESS[] = _T("{a6c7e065-cca9-44e6-a951-ae4327845fe0}");
const TCHAR IU_EVENT_SELFUPDATE_EVENT_SYNC[] = _T("{ed3ce20f-8479-4c1a-85ae-7a58ad6dc83e}");

#if defined(__WUIUTEST)
const TCHAR WU_SERVER_URL[] = _T("http://iudev/");
#else
const TCHAR WU_SERVER_URL[] = _T("http://windowsupdate.microsoft.com/v4/");
#endif

const TCHAR IDENT_VERSION[] = _T("Version");
const TCHAR IDENT_IUSELFUPDATE[] = _T("IUSelfUpdate");
const TCHAR IDENT_IUBETASELFUPDATE[] = _T("IUBetaSelfUpdate");
const TCHAR REGKEY_IDENT_SERV[] = _T("IdentServer");
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_SELFUPDATESTATUS[] = _T("SelfUpdateStatus");
const TCHAR REGVAL_SELFUPDATEVERSION[] = _T("SelfUpdateVersion");
const TCHAR REGVAL_BETASELFUPDATE[] = _T("BetaSelfUpdate");

const TCHAR IUCTL[] = _T("iuctl.dll");
const TCHAR ENGINEDLL[] = _T("iuengine.dll");
const TCHAR ENGINENEWDLL[] = _T("iuenginenew.dll");
const TCHAR ENGINECAB[] = _T("iuengine.cab");
const TCHAR RUNDLL32[] = _T("rundll32.exe");
const TCHAR RUNDLLCOMMANDLINE[] = _T(",BeginSelfUpdate");

// MSCAT32 support (CryptCAT API's)
const TCHAR MSCAT32DLL[] = _T("mscat32.dll");

// CryptCat Function Pointer Types
typedef BOOL (*PFN_CryptCATAdminAcquireContext)(OUT HCATADMIN *phCatAdmin, 
                                                IN const GUID *pgSubsystem, 
                                                IN DWORD dwFlags);
typedef HCATINFO (*PFN_CryptCATAdminAddCatalog)(IN HCATADMIN hCatAdmin, 
                                            IN WCHAR *pwszCatalogFile, 
                                            IN OPTIONAL WCHAR *pwszSelectBaseName, 
                                            IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATCatalogInfoFromContext)(IN HCATINFO hCatInfo,
                                                   IN OUT CATALOG_INFO *psCatInfo,
                                                   IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATAdminReleaseCatalogContext)(IN HCATADMIN hCatAdmin,
                                                       IN HCATINFO hCatInfo,
                                                       IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATAdminReleaseContext)(IN HCATADMIN hCatAdmin,
                                                IN DWORD dwFlags);

// Determines if a selfupdate is needed, or is already in process. If a selfupdate is needed it will trigger
// RunDll32 to instantiate a second instance of the control and have it call the BeginSelfUpdate() entrypoint.
class CUpdate;
HRESULT SelfUpdateCheck(BOOL fSynch, BOOL fStartUpdate, HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener);

// EntryPointCalled by RunDll32.exe to actually do the selfupdate process.
HRESULT BeginSelfUpdate();

HRESULT PingEngineUpdate(
						HMODULE hEngineModule,
						PHANDLE phQuitEvents,
						UINT nQuitEventCount,
						LPCTSTR ptszLiveServerUrl,
						LPCTSTR ptszCorpServerUrl,
						DWORD dwError,
						LPCTSTR ptszClientName = NULL);

// this function wraps up DownloadIUIdent() and CIUUrlAgent::PopulateData(), since we use it
// in both selfupd.cpp and loadengine.cpp.
HRESULT DownloadIUIdent_PopulateData();

#endif //__SELFUPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuctl\update.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Update.h
//
//  Owner:  JHou
//
//  Description:
//
//   Industry Update v1.0 client control stub - Declaration of the CUpdate
//
//
//  Revision History:
//
//  Date		Author		Desc
//	~~~~		~~~~~~		~~~~
//  9/15/2000	JHou		created.
//
//=======================================================================
#ifndef __UPDATE_H_
#define __UPDATE_H_

#include "resource.h"       // main symbols
#include "IUCtl.h"
#include "IUCtlCP.h"
#include "EvtMsgWnd.h"
#include <iu.h>				// for HIUENGINE


// BOOL IsThisUpdate2();



class CMyComClassFactory : public CComClassFactory
{
public:
	// IClassFactory
   STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
   {
	   HRESULT hr = CComClassFactory::CreateInstance(pUnkOuter, riid, ppvObj);

	   if (SUCCEEDED(hr))
	   {
		   //
		   // allocate thread global variables, thread handle
		   //

	   }

	   return hr;

   }
};



/////////////////////////////////////////////////////////////////////////////
// CUpdate
class ATL_NO_VTABLE CUpdate : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CUpdate, &CLSID_Update>,
	public IObjectWithSiteImpl<CUpdate>,
	public IObjectSafety,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CUpdate>,
	public IProvideClassInfo2Impl<&CLSID_Update, NULL, &LIBID_IUCTLLib>,
	public IDispatchImpl<IUpdate, &IID_IUpdate, &LIBID_IUCTLLib>,
	public CProxyIUpdateEvents<CUpdate>
{
public:
	CUpdate();
    ~CUpdate();
	//
	// impl of object safety for scripting
	//
	ULONG InternalRelease();
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

	DECLARE_REGISTRY_RESOURCEID(IDR_UPDATE)

/* 
we decided to use the new Win32 API GetControlUpdateInfo() to expose these
data and let a wrapper control to call it so we won't have reboot issue on 
OS prior to WinXP

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		UINT nResID = IsThisUpdate2() ? IDR_UPDATE2 : IDR_UPDATE;
		return _Module.UpdateRegistryFromResource(nResID, bRegister);
	}
*/
DECLARE_NOT_AGGREGATABLE(CUpdate)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpdate)
	COM_INTERFACE_ENTRY(IUpdate)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CUpdate)
	CONNECTION_POINT_ENTRY(DIID_IUpdateEvents)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IUpdate
public:


	DECLARE_CLASSFACTORY_EX(CMyComClassFactory);


	/////////////////////////////////////////////////////////////////////////////
	//
	// Initialize() API must be called before any other API will function
	//
	// If any other API is called before the control is initialized, 
	// that API will return OLE_E_BLANK, signalling this OLE control is an 
	// uninitialized object (although in this case it's a bit different from 
	// its original meaning)
	//
	// Parameters:
	//
	//	lInitFlag - IU_INIT_CHECK, cause Initialize() download ident and check if any
	//				of the components need updated. currently we support control version
	//				check and engine version check. Return value is a bit mask
	//
	//			  - IU_INIT_UPDATE_SYNC, cause Initialize() kicks off update engine
	//				process if already called by IU_INIT_CHECK and a new engine is available.
	//				When API returns, the update process is finished.
	//
	//			  - IU_INIT_UPDATE_ASYNC, cause Initialize() kicks off update engine
	//				process in Asynchronized mode if already called by IU_INIT_CHECK and
	//				a new engine is available. This API will return right after the 
	//				update process starts. 
	//
	//	punkUpdateCompleteListener - this is a pointer to a user-implemented 
	//				COM callback feature. It contains only one function OnComplete() that
	//				will be called when the engine update is done.
	//				This value can be NULL.
	//
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(Initialize)(
						  /*[in]*/ LONG lInitFlag, 
						  /*[in]*/ IUnknown* punkUpdateCompleteListener, 
						  /*[out, retval]*/ LONG* plRetVal);

	
	/////////////////////////////////////////////////////////////////////////////
	// GetSystemSpec()
	//
	// Gets the basic system specs.
	// Input:
	// bstrXmlClasses - a list of requested classes in xml format, NULL if any.
	//				    For example:
	//				    <devices>
	//				    <class name="video"/>
	//				    <class name="sound" id="2560AD4D-3ED3-49C6-A937-4368C0B0E06A"/>
	//				    </devices>
	// Output:
	// pbstrXmlDetectionResult - the detection result in xml format.
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetSystemSpec)(BSTR	bstrXmlClasses,
							 BSTR*	pbstrXmlDetectionResult);

	/////////////////////////////////////////////////////////////////////////////
	// GetManifest()
	//
	// Gets a catalog base on the specified information.
	// Input:
	// bstrXmlClientInfo - the credentials of the client in xml format
	// bstrXmlSystemSpec - the detected system specifications in xml
	// bstrXmlQuery - the user query infomation in xml
	// Output:
	// pbstrXmlCatalog - the xml catalog retrieved
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetManifest)(BSTR			bstrXmlClientInfo,
						   BSTR			bstrXmlSystemSpec,
						   BSTR			bstrXmlQuery,
						   BSTR*		pbstrXmlCatalog);

	/////////////////////////////////////////////////////////////////////////////
	// Detect()
	//
	// Do detection.
	// Input:
	// bstrXmlCatalog - the xml catalog portion containing items to be detected 
    // Output:
	// pbstrXmlItems - the detected items in xml format
    //                 e.g.
    //                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1" force="1"/>
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(Detect)(BSTR		bstrXmlCatalog, 
					  BSTR*		pbstrXmlItems);

	/////////////////////////////////////////////////////////////////////////////
	// Download()
	//
	// Do synchronized downloading.
	// Input:
	// bstrXmlClientInfo - the credentials of the client in xml format
	// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
	// bstrDestinationFolder - the destination folder. Null will use the default IU folder
	// lMode - indicates throttled or fore-ground downloading mode
	// punkProgressListener - the callback function pointer for reporting download progress
	// Output:
	// pbstrXmlItems - the items with download status in xml format
	//                 e.g.
	//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(Download)(BSTR		bstrXmlClientInfo,
						BSTR		bstrXmlCatalog, 
						BSTR		bstrDestinationFolder,
						LONG		lMode,
						IUnknown*	punkProgressListener,
						BSTR*		pbstrXmlItems);

	/////////////////////////////////////////////////////////////////////////////
	// DownloadAsync()
	//
	// Download asynchronously -  the method will return before completion.
	// Input:
	// bstrXmlClientInfo - the credentials of the client in xml format
	// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
	// bstrDestinationFolder - the destination folder. Null will use the default IU folder
	// lMode - indicates throttled or fore-ground downloading mode
	// punkProgressListener - the callback function pointer for reporting download progress
    // bstrUuidOperation - an id provided by the client to provide further
	//                     identification to the operation as indexes may be reused.
	// Output:
    // pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
	//                      parameter (an empty string is passed), it will generate a new UUID,
    //                      in which case, the caller will be responsible to free the memory of
	//                      the string buffer that holds the generated UUID using SysFreeString(). 
    //                      Otherwise, it returns the value passed by bstrUuidOperation.        
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(DownloadAsync)(BSTR		bstrXmlClientInfo,
							 BSTR		bstrXmlCatalog, 
							 BSTR		bstrDestinationFolder,
							 LONG		lMode,
							 IUnknown*	punkProgressListener, 
							 BSTR		bstrUuidOperation,
							 BSTR*		pbstrUuidOperation);

	/////////////////////////////////////////////////////////////////////////////
    // Install()
	//
	// Do synchronized installation.
	// Input:
    // bstrXmlCatalog - the xml catalog portion containing items to be installed 
	// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
	//                          result as described in the result schema.  Install uses this
	//                          to know whether the items were downloaded and if so where they
	//                          were downloaded to so that it can install the items
	// lMode - indicates different installation mode
    // punkProgressListener - the callback function pointer for reporting install progress
	// Output:
    // pbstrXmlItems - the items with installation status in xml format
    //                 e.g.
    //                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1"/>
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(Install)(BSTR         bstrXmlClientInfo,
                       BSTR			bstrXmlCatalog,
					   BSTR			bstrXmlDownloadedItems,
					   LONG			lMode,
					   IUnknown*	punkProgressListener,
					   BSTR*		pbstrXmlItems);

	/////////////////////////////////////////////////////////////////////////////
	// InstallAsync()
	//
	// Install Asynchronously.
    // Input:
	// bstrXmlCatalog - the xml catalog portion containing items to be installed
	// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
	//                          result as described in the result schema.  Install uses this
	//                          to know whether the items were downloaded and if so where they
	//                          were downloaded to so that it can install the items
	// lMode - indicates different installation mode
    // punkProgressListener - the callback function pointer for reporting install progress
    // bstrUuidOperation - an id provided by the client to provide further
	//                     identification to the operation as indexes may be reused.
	// Output:
    // pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
	//                      parameter (an empty string is passed), it will generate a new UUID,
    //                      in which case, the caller will be responsible to free the memory of
	//                      the string buffer that holds the generated UUID using SysFreeString(). 
    //                      Otherwise, it returns the value passed by bstrUuidOperation.        
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(InstallAsync)(BSTR        bstrXmlClientInfo,
                            BSTR		bstrXmlCatalog,
							BSTR		bstrXmlDownloadedItems,
							LONG		lMode,
							IUnknown*	punkProgressListener, 
							BSTR		bstrUuidOperation,
							BSTR*		pbstrUuidOperation);

	
	/////////////////////////////////////////////////////////////////////////////
	// SetOperationMode()
	//
	// Set the operation mode
    // Input:
    // bstrUuidOperation - an id provided by the client to provide further
	//                     identification to the operation as indexes may be reused.
    // lMode - a bitmask for the following mode:
	//						UPDATE_COMMAND_PAUSE 
	//						UPDATE_COMMAND_RESUME
	//						UPDATE_COMMAND_CANCEL
	//						UPDATE_NOTIFICATION_COMPLETEONLY
	//						UPDATE_NOTIFICATION_ANYPROGRESS
	//						UPDATE_NOTIFICATION_1PCT
	//						UPDATE_NOTIFICATION_5PCT
	//						UPDATE_NOTIFICATION_10PCT
	//						UPDATE_SHOWUI
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(SetOperationMode)(BSTR		bstrUuidOperation,
								LONG		lMode);
	/**
	*
	* Get the mode of a specified operation.
	*
	* @param bstrUuidOperation: same as in SetOperationMode()
	* @param plMode - the retval for the mode found in a bitmask for:
	*					(value in brackets [] means default)
	*					UPDATE_COMMAND_PAUSE (TRUE/[FALSE])
	*					UPDATE_COMMAND_RESUME (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_COMPLETEONLY (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_ANYPROGRESS ([TRUE]/FALSE)
	*					UPDATE_NOTIFICATION_1PCT (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_5PCT (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_10PCT (TRUE/[FALSE])
	*					UPDATE_SHOWUI (TRUE/[FALSE])
	*
	*/

	STDMETHOD(GetOperationMode)(
					/*[in]*/ BSTR bstrUuidOperation, 
					/*[out,retval]*/ LONG* plMode
					);

	
	/**
	* 
	* Retrieve a property of this control
	*		Calling this method will not cause the engine loaded
	*
	* @param lProperty - the identifier to flag which property need retrieved
	*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
	*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
	*
	* @param varValue - the value to retrieve
	*					
	*/
	STDMETHOD(GetProperty)(
					/*[in]*/ LONG lProperty, 
					/*[out,retval]*/ VARIANT* pvarValue
					);

	/**
	* 
	* Set a property of this control
	*		Calling this method will not cause the engine loaded
	*
	* @param lProperty - the identifier to flag which property need changed
	*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
	*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
	*
	* @param varValue - the value to change
	*
	*/
	STDMETHOD(SetProperty)(
					/*[in]*/ LONG lProperty, 
					/*[in]*/ VARIANT varValue
					);


	/////////////////////////////////////////////////////////////////////////////
    // GetHistory()
	//
	// Get the history log.
	// Input:
    // bstrDateTimeFrom - the start date and time for which a log is required.
	//                    This is a string in ANSI format (YYYY-MM-DDTHH-MM). 
	//                    If the string is empty, there will be no date restriction 
	//                    of the returned history log.
    // bstrDateTimeTo - the end date and time for which a log is required.
	//                  This is a string in ANSI format (YYYY-MM-DDTHH-MM).
	//                  If the string is empty, there will be no date restriction
	//                  of the returned history log.
	// bstrClient - the name of the client that initiated the action. If this parameter 
	//              is null or an empty string, then there will be no filtering based 
	//              on the client.
	// bstrPath - the path used for download or install. Used in the corporate version 
	//            by IT managers. If this parameter is null or an empty string, then 
	//            there will be no filtering based on the path.
	// Output:
	// pbstrLog - the history log in xml format
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(GetHistory)(BSTR		bstrDateTimeFrom,
						  BSTR		bstrDateTimeTo,
						  BSTR		bstrClient,
						  BSTR		bstrPath,
						  BSTR*		pbstrLog);


	/////////////////////////////////////////////////////////////////////////////
	//
	// Primarily expose shlwapi BrowseForFolder API, can also do checking
	// on R/W access if flagged so.
	//
	// @param bstrStartFolder - the folder from which to start. If NULL or empty str
	//							is being passed in, then start from desktop
	//
	// @param flag - validating check 
	//							UI_WRITABLE for checking write access, OK button may disabled. 
	//							UI_READABLE for checking read access, OK button may disabled. 
	//							NO_UI_WRITABLE for checking write access, return error if no access
	//							NO_UI_READABLE for checking read access,  return error if no access
	//							0 (default) for no checking.
	//
	// @param pbstrFolder - returned folder if a valid folder selected
	//
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(BrowseForFolder)(BSTR bstrStartFolder, 
							   LONG flag, 
							   BSTR* pbstrFolder);



    /////////////////////////////////////////////////////////////////////////////
    //
    // Allows the Caller to Request the Control to do a Reboot 
    //
    /////////////////////////////////////////////////////////////////////////////
    STDMETHOD(RebootMachine)();


    /////////////////////////////////////////////////////////////////////////////
    //
    // Make the other control can be unloaded from IE/OLE
    //
    /////////////////////////////////////////////////////////////////////////////
	STDMETHOD(PrepareSelfUpdate)(/*[in]*/ LONG lStep);



    /////////////////////////////////////////////////////////////////////////////
	//
	// Helper API to let the caller (script) knows the necessary information 
	// when Initialize() returns control need updated.
	//
	// For the current implementation, bstrClientName is ignored, and
	// the returned bstr has format:
	//	"<version>|<url>"
	// where:
	//	<version> is the expacted version number of the control
	//	<url> is the base url to get the control if this is a CorpWU policy controlled machine,
	//		  or empty if this is a consumer machine (in that case caller, i.e., script, knows
	//		  the default base url, which is the v4 live site)
	//
	// Script will need these two pieces of information in order to make a right <OBJECT> tag
	// for control update.
	//
    /////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetControlExtraInfo)(/*[in]*/ BSTR bstrClientName, 
								 /*[out,retval]*/ BSTR *pbstrExtraInfo);




	//
	// override IObjectWithSiteImpl function to get the site pointer
	//
	STDMETHOD(SetSite)(IUnknown* pSite);

	HRESULT ChangeControlInitState(LONG lNewState);

	inline CEventMsgWindow& GetEventWndClass() {return m_EvtWindow;};

private:

	HANDLE		m_evtControlQuit;

	DWORD		m_dwMode;

	DWORD		m_dwSafety;

	HMODULE     m_hEngineModule;

	HIUENGINE	m_hIUEngine;	// Life of this handle must be within scope of valid m_hEngineModule

	BOOL		m_fUseCompression;

    BOOL        m_fOfflineMode;

	HRESULT		m_hValidated;	// E_FAIL: initialized, 
								// S_OK: validated, 
								// INET_E_INVALID_URL: bad URL, don't continue

	LONG		m_lInitState;	// 0 - not initialized
								// 1 - need update
								// 2 - initialized, ready to work
	DWORD		m_dwUpdateInfo;	// result of first Initialize() call

	IUnknown*	m_pClientSite;

	TCHAR		m_szReqControlVer[64];


	//
	// private function
	//

	/////////////////////////////////////////////////////////////////////////////
	// 
	// Security feature: make sure if the user of this control is
	// a web page then the URL can be found in iuident.txt
	//
	// This function should be called after iuident refreshed.
	//
	// Return: TRUE/FALSE, to tell if we can continue
	//					
	/////////////////////////////////////////////////////////////////////////////
	HRESULT	ValidateControlContainer(void);



	/////////////////////////////////////////////////////////////////////////////
	// UnlockEngine()
	//
	// release the engine dll if ref cnt of engine is down to zero
	/////////////////////////////////////////////////////////////////////////////
	HRESULT	UnlockEngine();


	/////////////////////////////////////////////////////////////////////////////
	// GetPropUpdateInfo()
	//
	// get the latest iuident.txt, find out the version requirement, then
	// compare with the current file version data to determine
	// if we will update anything if the engine get loaded.
	//
	/////////////////////////////////////////////////////////////////////////////
	HRESULT DetectEngine(BOOL* pfUpdateAvail);


	/////////////////////////////////////////////////////////////////////////////
	// event handling members
	/////////////////////////////////////////////////////////////////////////////
	CEventMsgWindow m_EvtWindow;

	/////////////////////////////////////////////////////////////////////////////
	// synchronization object to make sure we lock/unlock engine correctly 
	// in multi-threaded cases
	/////////////////////////////////////////////////////////////////////////////
	CRITICAL_SECTION m_lock;
	BOOL m_gfInit_csLock;

//	BOOL m_fIsThisUpdate2;

};

#endif //__UPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\browse.h ===
//=======================================================================
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Browse.h
//
//  Owner:  EdDude
//
//  Description:
//
//      Implements the CBrowseFolder class.
//
//      Browse for a Folder for downloads.
//
// ======================================================================
//
// History:
//
// Date		Who			What
// ----		---			---------------------------------------
// 01/18/01	charlma		copy to IU control project, and modify
//
//=======================================================================

#ifndef _BROWSE_H_
#define _BROWSE_H_


//----------------------------------------------------------------------
// CBrowseFolder
//
//      Browse for a Folder for downloads.
//----------------------------------------------------------------------  
class CBrowseFolder
{

public:
	CBrowseFolder(LONG lFlag);
    ~CBrowseFolder();

	HRESULT BrowseFolder(HWND hwParent, LPCTSTR lpszDefaultPath, 
	                     LPTSTR szPathSelected, DWORD cchPathSelected);


private:

	CBrowseFolder() {};	// disable default constructor

    static bool s_bBrowsing;
	static int CALLBACK _BrowseCallbackProc( HWND hwDlg, UINT uMsg, LPARAM lParam, LPARAM lpData );

	HWND	m_hwParent;
	BOOL	m_fValidateWrite;
	BOOL	m_fValidateUI;	// FALSE if OK button not affected, TRUE if need to disable UI if validation fail
	TCHAR	m_szFolder[MAX_PATH];
};


#endif // _BROWSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\browse.cpp ===
//=======================================================================
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Browse.cpp
//
//  Owner:  EdDude
//
//  Description:
//
//      Implements the CBrowseFolder class.
//
//      Browse for a Folder for downloads.
//
//=======================================================================

#include "iuengine.h"
#include <shlobj.h>
#include <logging.h>
#include <fileutil.h>
#include "Browse.h"

//************************************************************************
//
// IUENGINE.DLL EXPORTED API BrowseForFolder()
//
//************************************************************************
HRESULT CEngUpdate::BrowseForFolder(BSTR bstrStartFolder, 
						LONG flag, 
						BSTR* pbstrFolder)
{
	LOG_Block("BrowseForFolder()");
	TCHAR szFolder[MAX_PATH];
	HRESULT hr = E_FAIL;
	CBrowseFolder br(flag);

	USES_IU_CONVERSION;

	LPTSTR lpszStartFolder = OLE2T(bstrStartFolder);

	LOG_Out(_T("BroseForFolder passed in start folder %s, flag %x"), lpszStartFolder, (DWORD)flag);

	if (IUBROWSE_NOBROWSE & flag)
	{
		//
		// if not browse dlgbox required, the purpose of this call is 
		// to validate the folder
		//
		DWORD dwRet = ValidateFolder(lpszStartFolder, (IUBROWSE_WRITE_ACCESS & flag));
		hr = (ERROR_SUCCESS == dwRet) ? S_OK : HRESULT_FROM_WIN32(dwRet);

		if (SUCCEEDED(hr))
		{
			*pbstrFolder = SysAllocString(T2OLE(lpszStartFolder));
		}
	}
	else
	{
		//
		// pop up the browse dlgbox
		//
		hr = br.BrowseFolder(NULL, lpszStartFolder, szFolder, ARRAYSIZE(szFolder));
		if (SUCCEEDED(hr))
		{
			*pbstrFolder = SysAllocString(T2OLE(szFolder));
		}

	}

	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		*pbstrFolder = NULL;
	}

	return hr;
}













//
//Only allow one of these dialogs at a time.
//
bool CBrowseFolder::s_bBrowsing = false;

//
//Max length of compacted path string in dialog status line (so it doesn't get too long).
//
#define MAX_BROWSEDLG_COMPACT_PATH   30

//
//Ctor
//
CBrowseFolder::CBrowseFolder(LONG lFlag)
    :   m_hwParent(0)
{
	m_szFolder[0] = _T('\0');
	
	m_fValidateWrite	= 0 == (IUBROWSE_WRITE_ACCESS & lFlag) ? FALSE : TRUE;
	m_fValidateUI		= 0 == (IUBROWSE_AFFECT_UI & lFlag) ? FALSE : TRUE;

}


//
//Dtor
//
CBrowseFolder::~CBrowseFolder()
{
}


//----------------------------------------------------------------------
// BrowseCallbackProc
//
//  Callback procedure used by SHBrowseForFolder() API call.
//
//	This callback function handles the initialization of the browse dialog and when
//	the user changes the selection in the tree-view.  We want to keep updating the 
//	g_szBrowsePath buffer with selection changes until the user clicks OK.
//  
// Returns: 
//  0
//
//----------------------------------------------------------------------
int CALLBACK CBrowseFolder::_BrowseCallbackProc( HWND hwDlg, UINT uMsg, LPARAM lParam, LPARAM lpData )
{    
    CBrowseFolder* pThis = (CBrowseFolder*) lpData;
    int iRet = 0;
    BOOL bValidated = FALSE;
    
    switch(uMsg)
    {
    case BFFM_INITIALIZED:
        {
			//
            // Initialize the dialog with the OK button and m_szFolder
			//
			bValidated = (ERROR_SUCCESS == ValidateFolder(pThis->m_szFolder, pThis->m_fValidateWrite) || !pThis->m_fValidateUI);
            SendMessage(hwDlg, BFFM_ENABLEOK, 0, bValidated);
			//
			// 469738 IU - BrowseForFolder shows incorrect selection when passed in a start folder name
			//
			// Always select the folder passed in regardless of the bValidated flag
			//
			SendMessage(hwDlg, BFFM_SETSELECTION, TRUE, (LPARAM) pThis->m_szFolder);

            return 0;
            break;

        } //case BFFM_INITIALIZED
        
    case BFFM_SELCHANGED:
        {
            HRESULT hr = S_OK;
            TCHAR pszPath[MAX_PATH];
            LPITEMIDLIST pidl = (LPITEMIDLIST) lParam;

            //
            // Validate folder with a status message
            //
            if (SHGetPathFromIDList(pidl, pszPath))
            {
				//
				// if it's file system, validate the path
				//
                bValidated = (ERROR_SUCCESS == ValidateFolder(pszPath, pThis->m_fValidateWrite) || !pThis->m_fValidateUI);

				if (bValidated)
				{
				    hr = StringCchCopyEx(pThis->m_szFolder, ARRAYSIZE(pThis->m_szFolder), pszPath,
				                         NULL, NULL, MISTSAFE_STRING_FLAGS);
				    if (FAILED(hr))
				    {
				        pThis->m_szFolder[0] = _T('\0');

				        // since we've failed, just set bValidated to FALSE and use that failure path
				        bValidated = FALSE;
				    }
				}

				SendMessage(hwDlg, BFFM_ENABLEOK, 0, bValidated);
				if (bValidated)
				{
					//SendMessage(hwDlg, BFFM_SETSTATUSTEXT, 0, (LPARAM) (LPCTSTR)pszCompactPath);
					SendMessage(hwDlg, BFFM_SETSTATUSTEXT, 0, (LPARAM) (LPCTSTR)pszPath);
				}
            }

            break;

        } //case BFFM_SELCHANGED

    } //switch(uMsg)

    return iRet;
}  


//----------------------------------------------------------------------
// 
// main public function
//
//----------------------------------------------------------------------
HRESULT CBrowseFolder::BrowseFolder(HWND hwParent, LPCTSTR lpszDefaultPath, 
                                    LPTSTR szPathSelected, DWORD cchPathSelected)
{
	HRESULT			hr = S_OK;
	BROWSEINFO		br;
	LPCITEMIDLIST	pidl;

	LOG_Block("BrowseFolder");

	m_szFolder[0] = szPathSelected[0] = _T('\0');

	//
	//Only allow one of thes Browse dialogs at a time.
	//
	if (s_bBrowsing)
	{
		hr = HRESULT_FROM_WIN32(ERROR_BUSY);
		LOG_ErrorMsg(hr);
		return hr;
	}
	else
	{
		s_bBrowsing = true;
	}

	m_hwParent = hwParent;
	hr = StringCchCopyEx(m_szFolder, ARRAYSIZE(m_szFolder), lpszDefaultPath, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
	if (FAILED(hr))
	{
	    m_szFolder[0] = _T('\0');
		LOG_ErrorMsg(hr);
		return hr;
	}

	//
	//Browse dialog parameters
	//
    br.hwndOwner		= hwParent;
	br.pidlRoot			= NULL;			            //rooted at desktop
	br.pszDisplayName	= NULL;	
	br.lpszTitle		= NULL;
	br.ulFlags			= BIF_RETURNONLYFSDIRS|BIF_STATUSTEXT;     //only want FS dirs, and a status line
	br.lpfn				= _BrowseCallbackProc;
	br.lParam			= (__int3264)this;
	br.iImage			= 0;

	//
	// Popup browse dialog
	//
	pidl = SHBrowseForFolder(&br);

    if (0 == pidl)
    {
		//
        // Cancel pressed
		//
		LOG_Out(_T("User clicked CANCEL button!"));
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    else
    {
		//
		// 469729  IU - BrowseForFolder does not return error when passed IUBROWSE_WRITE_ACCESS flag
		//
		// For the case of IUBROWSE_WRITE_ACCESS, but **NO** IUBROWSE_AFFECT_UI flag, the user may
		// have selected a folder that has no write access and clicked OK, which will return the
		// folder with no write access. We have to call ValidateFolder once again here. We
		// probably shouldn't allow IUBROWSE_WRITE_ACCESS without IUBROWSE_AFFECT_UI, but since
		// we do we have to have this fix.
		//
		if (m_fValidateWrite && ERROR_SUCCESS != ValidateFolder(m_szFolder, m_fValidateWrite))
		{
			LOG_Out(_T("We should have write access to the folder, but don't -- return E_ACCESSDENIED"));
			hr = E_ACCESSDENIED;
		}
		//
		// Return the folder even if E_ACCESSDENIED, so caller can advise user
		//

    	hr = StringCchCopyEx(szPathSelected, cchPathSelected, m_szFolder, 
    	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    	if (FAILED(hr))
    	{
    	    szPathSelected[0] = _T('\0');
    		LOG_ErrorMsg(hr);
    	}
		
		LOG_Out(_T("User selected path %s"), m_szFolder);
		LPMALLOC pMalloc = NULL;
		if (SUCCEEDED(SHGetMalloc(&pMalloc)) && NULL != pMalloc)
		{
			pMalloc->Free((LPVOID) pidl);
			pMalloc->Release();
		}
		/*
		throughout MSDN, there is no mentioning of what to do if failed to get shell malloc object.
		so, we'll have to assume SHGetMalloc() never fail.
		else
		{
			CoTaskMemFree((void*)pidl);
		}
		*/
        pidl = 0;
    }

    s_bBrowsing = false;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\cdmi.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmi.cpp
//
//  Description:
//
//      Functions exported by IUEngine.dll for use by CDM.DLL
//
//          InternalDetFilesDownloaded
//			InternalDownloadGetUpdatedFiles
//			InternalDownloadUpdatedFiles
//			InternalFindMatchingDriver
//			InternalLogDriverNotFound
//			InternalQueryDetectionFiles
//
//=======================================================================
#include "iuengine.h"
#include "cdmp.h"

#include <setupapi.h>
#include <cfgmgr32.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <wininet.h>
#include <osdet.h>
#include <fileutil.h>
#include "iuxml.h"
#include <wuiutest.h>

const CHAR SZ_APW_LIST[] = "Downloading printer list for Add Printer Wizard";
const CHAR SZ_FIND_MATCH[] = "Finding matching driver";
const CHAR SZ_OPENING_HS[] = "Opening Help and Support with: ";


void WINAPI InternalDetFilesDownloaded(
    IN  HANDLE hConnection
)
{
	LOG_Block("InternalDetFilesDownloaded");
	//
	// NOTE: This function is only used by WinME to expand the
	//       V3 buckets.cab (see commented out code below) and has no use
	//		 in V4 (IU) but remains for backwards compatibility of the export API.
	//
	LOG_ErrorMsg(E_NOTIMPL);
}

// Win 98 entry point
// This function allows Windows 98 to call the same entry points as NT.
// The function returns TRUE if the download succeeds and FALSE if it
// does not.
//
// Win 98 DOWNLOADINFO
// typedef struct _DOWNLOADINFOWIN98
// {
//		DWORD		dwDownloadInfoSize;	// size of this structure				- validate param (not validated in V3)
// 		LPTSTR		lpHardwareIDs;		// multi_sz list of Hardware PnP IDs	- only use first string
// 		LPTSTR		lpCompatIDs;		// multi_sz list of compatible IDs		- never used
// 		LPTSTR		lpFile;				// File name (string)					- never used
// 		OSVERSIONINFO	OSVersionInfo;	//OSVERSIONINFO from GetVersionEx()		- never used
// 		DWORD		dwFlags;			//Flags									- never used
// 		DWORD		dwClientID;			//Client ID								- never used
// } DOWNLOADINFOWIN98, *PDOWNLOADINFOWIN98;
// 
// typedef struct _DOWNLOADINFO {
//     DWORD          dwDownloadInfoSize;
//     LPCWSTR        lpHardwareIDs;				- copied from DOWNLOADINFOWIN98 using T2OLE()
//     LPCWSTR        lpDeviceInstanceID;			- in V3, match was sometimes found and this was filled in
//													-	but for IU we just let InternalDownloadUpdatedFiles do it all
//     LPCWSTR        lpFile;
//     OSVERSIONINFOW OSVersionInfo;
//     DWORD          dwArchitecture;				- set to PROCESSOR_ARCHITECTURE_UNKNOWN per V3 code
//     DWORD          dwFlags;
//     DWORD          dwClientID;
//     LCID           localid;						- not set in V3
// } DOWNLOADINFO, *PDOWNLOADINFO;

BOOL InternalDownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,	//The win98 download info structure is
												//slightly different that the NT version
												//so this function handles conversion.
	IN OUT LPTSTR			lpDownloadPath,		//returned Download path to the downloaded
												//cab files.
	IN UINT					uSize				//size of passed in download path buffer.
) {
	USES_IU_CONVERSION;

	LOG_Block("InternalDownloadGetUpdatedFiles");

	if (NULL == pDownloadInfoWin98 ||
		NULL == pDownloadInfoWin98->lpHardwareIDs ||
		sizeof(DOWNLOADINFOWIN98) != pDownloadInfoWin98->dwDownloadInfoSize)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

    HRESULT hr;
	BOOL fOK = FALSE;
	DOWNLOADINFO info;
	ZeroMemory(&info, sizeof(info));
	info.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
	info.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
	//
	// NOTE: In V3 sources, we only use the _first_ HWID in the Multi_SZ pDownloadInfoWin98->lpHardwareIDs
	// and compare that against all enumerated hardware IDs.
	// In IU, this compare will be done in InternalDownloadUpdatedFiles, so we just pass through
	// the HWID
	//

	// Prefast - using too much stack, so move HWIDBuff to heap
	LPWSTR pwszHWIDBuff = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, HWID_LEN);
	if (NULL != pwszHWIDBuff)
	{
        // buffer size obtained from HeapAlloc call above.
        hr = StringCbCopyExW(pwszHWIDBuff, HWID_LEN, T2OLE(pDownloadInfoWin98->lpHardwareIDs),
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SafeHeapFree(pwszHWIDBuff);
            LOG_ErrorMsg(hr);
            return FALSE;
        }
        	    
		info.lpHardwareIDs = pwszHWIDBuff;

		WCHAR wszbufPath[MAX_PATH];
		UINT uRequiredSize;
		//
		// We no longer have context handles, so just pass 1 to make InternalDownloadUpdatedFiles happy.
		//
		fOK = InternalDownloadUpdatedFiles((HANDLE) 1, NULL,  &info, wszbufPath,
									uSize * (sizeof(WCHAR)/sizeof(TCHAR)), &uRequiredSize);
	}
	else
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
	}

	if (fOK)
	{
		hr = StringCbCopyEx(lpDownloadPath, uSize, OLE2T(pwszHWIDBuff), 
		                    NULL, NULL, MISTSAFE_STRING_FLAGS | STRSAFE_NO_TRUNCATION);
	    if (FAILED(hr))
	        fOK = FALSE;
	}
	
	SafeHeapFree(pwszHWIDBuff);

    return fOK;
}

//This function downloads the specified CDM package. The hConnection handle must have
//been returned from the OpenCDMContext() API.
//
//This function Returns TRUE if download is successful GetLastError() will return
//the error code indicating the reason that the call failed.

BOOL WINAPI InternalDownloadUpdatedFiles(
	IN  HANDLE        hConnection,		//Connection handle from OpenCDMContext() API.
	IN  HWND          hwnd,				//Window handle for call context
	IN  PDOWNLOADINFO pDownloadInfo,	//download information structure describing
										//package to be read from server
	OUT LPWSTR        lpDownloadPath,	//local computer directory location of the
										//downloaded files
	IN  UINT          uSize,				// Not Used (we require the buffer to be a WCHAR buffer
											// MAX_PATH characters long)
	OUT PUINT         /*puRequiredSize*/	// Not used (we don't validate uSize - see comments inline)
) {
	USES_IU_CONVERSION;

	LOG_Block("InternalDownloadUpdatedFiles");

	TCHAR szDownloadPathTmp[MAX_PATH];
	BSTR bstrXmlCatalog = NULL;
	HRESULT hr = S_OK;
	BOOL fPlist = FALSE;

	if (NULL == g_pCDMEngUpdate)
	{
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	}

	//
	// Reset Quit Event in case client retries after a SetOperationMode
	//
	ResetEvent(g_pCDMEngUpdate->m_evtNeedToQuit);

	// Since all current platforms call DownloadUpdatedFiles with MAX_PATH TCHARS, we will just
	// require MAX_PATH for all callers.
	//
	// UNFORTUNATELY, NewDev passes up uSize in bytes and the Printer folks pass us characters,
	// so there is no way to validate this parameter. In addition, we won't bother validating
	// puRequiredSize since we never use it (would be return chars or bytes?)
	if (NULL == pDownloadInfo || NULL == lpDownloadPath || NULL == hConnection)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if (g_pCDMEngUpdate->m_fOfflineMode)
	{
		SetLastError(ERROR_REM_NOT_LIST);
		return FALSE;
	}

	//
	// Check to see if this is a printer catalog request. Note: 3FBF5B30-DEB4-11D1-AC97-00A0C903492B
	// is not defined in any system or private headers and is copied from
	// \\index2\ntsrc\printscan\print\spooler\splsetup\util.c (or equiv.)
	//
	// Only the first string passed in lpHardwareIDs is relevant to this test
	fPlist = (	NULL != pDownloadInfo->lpHardwareIDs && 
				CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
					L"3FBF5B30-DEB4-11D1-AC97-00A0C903492B", -1, pDownloadInfo->lpHardwareIDs, -1)
			 );

	OSVERSIONINFO osVersionInfo;
	ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFO));
	osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (!GetVersionEx(&osVersionInfo))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	//
	// Only support printers for Win2K up & WinME
	//
	if ( fPlist &&
		!(	(	// Win2K (NT 5.0) up
				(VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId) &&
				(4 < osVersionInfo.dwMajorVersion)
			)
			||
			(	// WinME (or higher)
				(VER_PLATFORM_WIN32_WINDOWS == osVersionInfo.dwPlatformId) &&
				(90	<= osVersionInfo.dwMinorVersion)
			)
		 )
	   )
	{
		CleanUpIfFailedAndSetHrMsg(E_NOTIMPL);
	}
	
	hr = GetPackage(fPlist ? GET_PRINTER_INFS : DOWNLOAD_DRIVER,
						pDownloadInfo, szDownloadPathTmp, ARRAYSIZE(szDownloadPathTmp), &bstrXmlCatalog);
	if (FAILED(hr))
	{
		lpDownloadPath[0] = 0;
		//
		// Map an HRESULT to a WIN32 error value
		// Note: This assumes that WIN32 errors fall in the range -32k to 32k,
		// same as HRESULT_FROM_WIN32 that packaged them into HRESULT.
		//
		SetLastError(hr & 0x0000FFFF);
		goto CleanUp;
	}
	else
	{
        // The comment above says that different callers pass in different types
        //  of values for uSize, so the function assumes that the buffer is MAX_PATH.
        //  Attempting to find out if we can force callers into this function to 
        //  do the right thing.  For now, assume buffer is MAX_PATH.
	    hr = StringCchCopyExW(lpDownloadPath, MAX_PATH, T2OLE(szDownloadPathTmp),
	                          NULL, NULL, MISTSAFE_STRING_FLAGS);
	    if (FAILED(hr))
	    {
	        SetLastError(HRESULT_CODE(hr));
	        goto CleanUp;
	    }
	    
		LOG_Driver(_T("Downloaded files for %s located at %S"), pDownloadInfo->lpHardwareIDs, lpDownloadPath);
		goto CleanUp;
	}

CleanUp:

	SysFreeString(bstrXmlCatalog);

	if (fPlist)
	{
		if (SUCCEEDED(hr))
		{
			LogMessage(SZ_APW_LIST);
		}
		else
		{
			LogError(hr, SZ_APW_LIST);
		}
	}
	else
	{
		if (SUCCEEDED(hr))
		{
			LogMessage("Downloaded driver for %ls at %ls", pDownloadInfo->lpHardwareIDs, lpDownloadPath);
		}
		else
		{
			LogError(hr, "Driver download failed for %ls", pDownloadInfo->lpHardwareIDs);
		}
	}

	return SUCCEEDED(hr);
}

BOOL WINAPI  InternalFindMatchingDriver(
	IN  HANDLE			hConnection,
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
) {
	LOG_Block("InternalFindMatchingDriver");

	BSTR bstrXmlCatalog = NULL;
	BSTR bstrHWID = NULL;
	BSTR bstrDisplayName = NULL;
	BSTR bstrDriverName = NULL;
	BSTR bstrMfgName = NULL;
	BSTR bstrDriverProvider = NULL;
	BSTR bstrDriverVer = NULL;
	BSTR bstrArchitecture = NULL;



	HRESULT hr = S_OK;
	CXmlCatalog* pCatalog = NULL;
	HANDLE_NODE hCatalogItem;
	HANDLE_NODE hProvider;
	HANDLE_NODELIST hItemList;
	HANDLE_NODELIST hProviderList;
	BOOL fIsPrinter;

	if (NULL == g_pCDMEngUpdate)
	{
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	}

	//
	// Reset Quit Event in case client retries after a SetOperationMode
	//
	ResetEvent(g_pCDMEngUpdate->m_evtNeedToQuit);

	if (NULL == pDownloadInfo || NULL == pWuDriverInfo || NULL == hConnection)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if (g_pCDMEngUpdate->m_fOfflineMode)
	{
		SetLastError(ERROR_REM_NOT_LIST);
		return FALSE;
	}

	CleanUpFailedAllocSetHrMsg(pCatalog = (CXmlCatalog*) new CXmlCatalog);

	//
	// Get the catalog XML
	//
	CleanUpIfFailedAndSetHr(GetPackage(GET_CATALOG_XML, pDownloadInfo, NULL, 0, &bstrXmlCatalog));
	//
	// Load the XML and get the <item/> list and node of first item (only one in CDM case)
	//
	CleanUpIfFailedAndSetHr(pCatalog->LoadXMLDocument(bstrXmlCatalog, g_pCDMEngUpdate->m_fOfflineMode));

	hProviderList = pCatalog->GetFirstProvider(&hProvider);
	if (HANDLE_NODELIST_INVALID == hProviderList || HANDLE_NODE_INVALID == hProvider)
	{
		hr = S_FALSE;
		goto CleanUp;
	}
	
	hItemList = pCatalog->GetFirstItem(hProvider, &hCatalogItem);
	if (HANDLE_NODELIST_INVALID == hItemList || HANDLE_NODE_INVALID == hProvider)
	{
		hr = S_FALSE;
		goto CleanUp;
	}
	//
	// Populate pWuDriverInfo with data from the catalog
	//
	CleanUpIfFailedAndSetHr(pCatalog->GetDriverInfoEx(hCatalogItem,
													&fIsPrinter,
													&bstrHWID,
													&bstrDriverVer,
													&bstrDisplayName,
													&bstrDriverName,
													&bstrDriverProvider,
													&bstrMfgName,
													&bstrArchitecture));
	
    hr = StringCchCopyExW(pWuDriverInfo->wszHardwareID, 
                          ARRAYSIZE(pWuDriverInfo->wszHardwareID), 
                          bstrHWID,
                          NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto CleanUp;

    hr = StringCchCopyExW(pWuDriverInfo->wszDescription, 
                          ARRAYSIZE(pWuDriverInfo->wszDescription), 
                          bstrDisplayName,
                          NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto CleanUp;
    
	//
	// Convert from ISO to DriverVer date format
	//
	// DriverVer: "mm-dd-yyyy" <--> ISO 8601: "yyyy-mm-dd"
	//     index:  0123456789                  0123456789
	//
    if (ARRAYSIZE(pWuDriverInfo->wszDriverVer) >= 11 && 
        SysStringLen(bstrDriverVer) == 10)
    {
    	pWuDriverInfo->wszDriverVer[0]  = bstrDriverVer[5];
    	pWuDriverInfo->wszDriverVer[1]  = bstrDriverVer[6];
    	pWuDriverInfo->wszDriverVer[2]  = L'-';
    	pWuDriverInfo->wszDriverVer[3]  = bstrDriverVer[8];
    	pWuDriverInfo->wszDriverVer[4]  = bstrDriverVer[9];
    	pWuDriverInfo->wszDriverVer[5]  = L'-';
    	pWuDriverInfo->wszDriverVer[6]  = bstrDriverVer[0];
    	pWuDriverInfo->wszDriverVer[7]  = bstrDriverVer[1];
    	pWuDriverInfo->wszDriverVer[8]  = bstrDriverVer[2];
    	pWuDriverInfo->wszDriverVer[9]  = bstrDriverVer[3];
    	pWuDriverInfo->wszDriverVer[10] = L'\0';
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto CleanUp;
    }
    

	if(fIsPrinter)
	{
        hr = StringCchCopyExW(pWuDriverInfo->wszMfgName, 
                              ARRAYSIZE(pWuDriverInfo->wszMfgName), 
                              bstrMfgName,
                              NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;

        hr = StringCchCopyExW(pWuDriverInfo->wszProviderName, 
                              ARRAYSIZE(pWuDriverInfo->wszProviderName), 
                              bstrDriverProvider,
                              NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;
	}

CleanUp:

	if (S_OK == hr)
	{
		LogMessage("Found matching driver for %ls, %ls, %ls", bstrHWID, bstrDisplayName, bstrDriverVer);
	}
	else
	{
		if (S_FALSE == hr)
		{
			if (pDownloadInfo->lpDeviceInstanceID)
			{
				LogMessage("Didn't find matching driver for %ls", pDownloadInfo->lpDeviceInstanceID);
			}
			else if (pDownloadInfo->lpHardwareIDs)
			{
				LogMessage("Didn't find matching driver for %ls", pDownloadInfo->lpHardwareIDs);
			}
			else
			{
				LogMessage("Didn't find matching driver"); 
			}
		}
		else	// error happened
		{
			if (pDownloadInfo->lpDeviceInstanceID)
			{
				LogError(hr, "%s for %ls", SZ_FIND_MATCH, pDownloadInfo->lpDeviceInstanceID);
			}
			else if (pDownloadInfo->lpHardwareIDs)
			{
				LogError(hr, "%s for %ls", SZ_FIND_MATCH, pDownloadInfo->lpHardwareIDs);
			}
			else
			{
				LogError(hr, SZ_FIND_MATCH); 
			}
		}

	}

	SysFreeString(bstrXmlCatalog);
	SysFreeString(bstrHWID);
	SysFreeString(bstrDisplayName);
	SysFreeString(bstrDriverName);
	SysFreeString(bstrMfgName);
	SysFreeString(bstrDriverProvider);
	SysFreeString(bstrDriverVer);
	SysFreeString(bstrArchitecture);

	if (NULL != pCatalog)
	{
		delete pCatalog;
	}

	return SUCCEEDED(hr);
}


// supports offline logging
// hConnection NOT used at all
// no network connection or osdet.dll needed for languauge, SKU, platform detection 
void WINAPI InternalLogDriverNotFound(
    IN  HANDLE hConnection,
	IN LPCWSTR lpDeviceInstanceID,
	IN DWORD dwFlags				// dwFlags could be either 0 or BEGINLOGFLAG from NEWDEV
) {
	USES_IU_CONVERSION;

	LOG_Block("InternalLogDriverNotFound");

#if !(defined(_UNICODE) || defined(UNICODE))
	LOG_ErrorMsg(E_NOTIMPL);
	return;
#else

	HRESULT hr = E_FAIL;
	DWORD dwBytes;
	TCHAR* pszBuff = NULL;
	ULONG ulLength;
	DWORD dwDeviceCount = 0;
	DWORD dwRank = 0;

	TCHAR szUniqueFilename[MAX_PATH] = _T("");
	DWORD dwWritten;
	DEVINST devinst;
	bool fXmlFileError = false;
	HANDLE hFile = NULL;
	BSTR bstrXmlSystemSpec = NULL;
	BSTR bstrThisID = NULL;
	HANDLE_NODE hDevices = HANDLE_NODE_INVALID;

	static CDeviceInstanceIdArray apszDIID; //device instance id list
	LPWSTR pDIID = NULL; //Device Instance ID

	CXmlSystemSpec xmlSpec;

	if (NULL == g_pCDMEngUpdate)
	{
		SetLastError(ERROR_OUTOFMEMORY);
		return;
	}

	//
	// Reset Quit Event in case client retries after a SetOperationMode
	//
	ResetEvent(g_pCDMEngUpdate->m_evtNeedToQuit);

	//
	// Only allow BEGINLOGFLAG or no flags
	//
	if (!(0 == dwFlags || BEGINLOGFLAG == dwFlags))
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}
	//
	// If no flags, then lpDeviceInstanceID must be valid
	//
	if (0 == dwFlags && NULL == lpDeviceInstanceID)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}

	LogMessage("Started process to regester driver not found with Help Center. Not completing this process may not be error.");

	IU_PLATFORM_INFO iuPlatformInfo;
	//
	// We need iuPlatformInfo for both <platform> and <devices> elements
	// NOTE: iuPlatformInfo is initialized by DetectClientIUPlatform, and BSTRs must be
	//       freed in CleanUp (don't just there before this call).
	//
	CleanUpIfFailedAndSetHr(DetectClientIUPlatform(&iuPlatformInfo));

	//
	// Should only be called on Whistler up except CHK builds can run on Win2K
	//
	if (  !( (VER_PLATFORM_WIN32_NT == iuPlatformInfo.osVersionInfoEx.dwPlatformId) &&
			(4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion) &&
			(0 < iuPlatformInfo.osVersionInfoEx.dwMinorVersion)	 )	)
	{
		LOG_Driver(_T("Should only be called on Whistler or greater"));
		CleanUpIfFailedAndSetHr(E_NOTIMPL);
	}

	if (NULL != lpDeviceInstanceID)
	{
		LOG_Driver(_T("DeviceInstanceID is %s"), lpDeviceInstanceID);
		
		//
		// Add the DeviceInstanceID to the list
		//
		if (-1 == apszDIID.Add(lpDeviceInstanceID))
		{
			goto CleanUp;
		}
	}


	if (0 == (dwFlags & BEGINLOGFLAG) || 0 == apszDIID.Size())
	{
		// not last log request or nothing to log
		LOG_Driver(_T("Won't log to hardware_XXX.xml until we get BEGINLOGFLAG when we have cached at least 1 HWID"));
		return;
	}

	////////////////////////////////////////////
	// ELSE, WRITE XML FILE and call HelpCenter
	////////////////////////////////////////////

	hr = OpenUniqueFileName(szUniqueFilename, ARRAYSIZE(szUniqueFilename), hFile);
	if (S_OK != hr) 
	{
		fXmlFileError = true;
		goto CleanUp;
	}

	//
	// Write Unicode Header
	//
	if (0 == WriteFile(hFile, (LPCVOID) &UNICODEHDR, ARRAYSIZE(UNICODEHDR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}

	//
	// Add Platform
	//
	CleanUpIfFailedAndSetHr(AddPlatformClass(xmlSpec, iuPlatformInfo));

	//
	// Add OS Locale information
	//
	CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, FALSE));

	//
	// Initialize pszBuff to one NULL character
	//
	CleanUpFailedAllocSetHrMsg(pszBuff = (TCHAR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(TCHAR)));

	for (int i = 0; i < apszDIID.Size(); i++)
	{
		TCHAR* pszTemp;
		pDIID = apszDIID[i];
		
		//
		// NTBUG9#151928 - Log both hardware and compatible IDs of the device that matches lpDeviceInstanceID
		//

		LOG_Driver(_T("Log device instance with id %s"), pDIID);
		//
		// NOTE: We will ignore MatchingDeviceID's since we won't be called by DevMgr unless there is no installed
		// driver. This will allow test harnesses to call this function with valid DeviceInstanceIDs for the
		// test client to generate XML.
		//
		if (CR_SUCCESS == CM_Locate_DevNodeW(&devinst, (LPWSTR) pDIID, 0))
		{
			dwRank = 0;
			//
			// Open a <device> element
			//
			BSTR bstrDeviceInstance = SysAllocString(pDIID);
			CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(bstrDeviceInstance, -1, NULL, NULL, NULL, &hDevices));
			SafeSysFreeString(bstrDeviceInstance);

			//
			// Log all the hardware IDs
			//
			ulLength = 0;
			if (CR_BUFFER_SMALL == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_HARDWAREID, NULL, NULL, &ulLength, 0))
			{
				CleanUpFailedAllocSetHrMsg(pszTemp = (TCHAR*) HeapReAlloc(GetProcessHeap(), 0, (LPVOID) pszBuff, ulLength));
				pszBuff = pszTemp;

				if (CR_SUCCESS == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_HARDWAREID, NULL, pszBuff, &ulLength, 0))
				{
					for (TCHAR* pszThisID = pszBuff; *pszThisID; pszThisID += (lstrlen(pszThisID) + 1))
					{
						dwDeviceCount++;
						LOG_Driver(_T("<hwid/>: %s, rank: %d"), pszThisID, dwRank);
						bstrThisID = T2BSTR(pszThisID);
						CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, FALSE, dwRank++, bstrThisID, NULL));
						SafeSysFreeString(bstrThisID);
					}
				}
			}

			//
			// Log all the compatible IDs
			//
			ulLength = 0;
			if (CR_BUFFER_SMALL == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_COMPATIBLEIDS, NULL, NULL, &ulLength, 0))
			{
				CleanUpFailedAllocSetHrMsg(pszTemp = (TCHAR*) HeapReAlloc(GetProcessHeap(), 0, (LPVOID) pszBuff, ulLength));
				pszBuff = pszTemp;

				if (CR_SUCCESS == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_COMPATIBLEIDS, NULL, pszBuff, &ulLength, 0))
				{
					for (TCHAR* pszThisID = pszBuff; *pszThisID; pszThisID += (lstrlen(pszThisID) + 1))
					{
						dwDeviceCount++;
						LOG_Driver(_T("<compid/>: %s, rank: %d"), pszThisID, dwRank);
						bstrThisID = T2BSTR(pszThisID);
						CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, TRUE, dwRank++, bstrThisID, NULL));
						SafeSysFreeString(bstrThisID);
					}
				}
			}

			if (HANDLE_NODE_INVALID != hDevices)
			{
				xmlSpec.SafeCloseHandleNode(hDevices);
			}
		}
	}
	
	//
	// Write the XML to the file
	//
	if (SUCCEEDED(xmlSpec.GetSystemSpecBSTR(&bstrXmlSystemSpec)))
	{
		if (0 == WriteFile(hFile, (LPCVOID) OLE2T(bstrXmlSystemSpec),
							lstrlenW(bstrXmlSystemSpec) * sizeof(TCHAR), &dwWritten, NULL))
		{
			SetHrMsgAndGotoCleanUp(GetLastError());
		}
	}
	else
	{
		fXmlFileError = true;
	}

CleanUp:

	SysFreeString(iuPlatformInfo.bstrOEMManufacturer);
	SysFreeString(iuPlatformInfo.bstrOEMModel);
	SysFreeString(iuPlatformInfo.bstrOEMSupportURL);

	if (NULL != hFile)
	{
		CloseHandle(hFile);
	}

	SafeSysFreeString(bstrXmlSystemSpec);
	SafeSysFreeString(bstrThisID);

	//
	// We've already written everything in list, init so we can start over
	//
	apszDIID.FreeAll();
	SafeHeapFree(pszBuff);

	//
	// Open Help Center only if we have valid xml and one or more devices
	//
	if (!fXmlFileError && 0 < dwDeviceCount)
	{
		DWORD dwLen;
		LPTSTR pszSECommand = NULL;	// INTERNET_MAX_URL_LENGTH

		//
		// Allocate buffers
		//
		pszBuff = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszBuff)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			DeleteFile(szUniqueFilename);
			return;
		}

		pszSECommand = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszSECommand)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			SafeHeapFree(pszBuff);
			DeleteFile(szUniqueFilename);
			return;
		}

		//
		// Manually canonicalize second '?' in base string as excaped "%3F"
		//
		const static TCHAR tszBase[] =
			_T("hcp://services/layout/xml?definition=hcp://system/dfs/viewmode.xml&topic=hcp://system/dfs/uplddrvinfo.htm%3F");

		LOG_Driver(_T("Filename: %s"), szUniqueFilename);
		//
		// Canonicalize the filename once (i.e. ' ' -> %20) into pszBuff
		//
		dwLen = INTERNET_MAX_URL_LENGTH;
		if (!InternetCanonicalizeUrl(szUniqueFilename, pszBuff, &dwLen, 0))
		{
			LOG_ErrorMsg(GetLastError());
			SafeHeapFree(pszBuff);
			SafeHeapFree(pszSECommand);
			DeleteFile(szUniqueFilename);
			return;
		}

		LOG_Driver(_T("Filename canonicalized once: %s"), pszBuff);

		//
		// Concatinate canonicalized filename on to end of base reusing tszBuff1
		//
		// We don't need to check length since we know length of tszBase + MAX_PATH canonicalized
		// string won't exceed INTERNET_MAX_URL_LENGTH;
		//

		// pszSECommand was allocated to be INTERNET_MAX_URL_LENGTH TCHARs above.
		hr = StringCchPrintfEx(pszSECommand, INTERNET_MAX_URL_LENGTH, 
		                       NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("%s%s"), tszBase, pszBuff);
		if (SUCCEEDED(hr))
		{
    		LOG_Driver(_T("Opening HelpCenter via Shell Execute: \"%s\""), (LPCTSTR) pszSECommand);

#if defined(UNICODE) || defined(_UNICODE)
    		LogMessage("%s\"%S\"", SZ_OPENING_HS, pszSECommand);
#else
    		LogMessage("%s\"%s\"", SZ_OPENING_HS, pszSECommand);
#endif
    		//
    		// Call HelpCenter
    		//
    		ShellExecute(NULL, NULL, pszSECommand, NULL, NULL, SW_SHOWNORMAL);
		}
		else
		{
			LOG_ErrorMsg(hr);
		}

		SafeHeapFree(pszBuff);
		SafeHeapFree(pszSECommand);

		return;
	}
	else
	{ 
		//
		// Remove the generated file
		//
		LOG_Driver(_T("fXmlFileError was true or no devices were added - deleting %s"), szUniqueFilename);
		DeleteFile(szUniqueFilename);
	}

	return;

#endif	// UNICODE is defined
}

//
// Currently, this function is not implemented for Whistler or IU (called by V3 AU on WinME
// to support offline driver cache).
//
int WINAPI InternalQueryDetectionFiles(
    IN  HANDLE							/* hConnection */, 
	IN	void*							/* pCallbackParam */, 
	IN	PFN_QueryDetectionFilesCallback	/* pCallback */
) {
	LOG_Block("InternalQueryDetectionFiles");

	LOG_ErrorMsg(E_NOTIMPL);

	return 0;
}

void InternalSetGlobalOfflineFlag(BOOL fOfflineMode)
{
	//
	// Called once exclusively by CDM. This property is used
	// to maintain backwards compatibility with the XPClient
	// V4 version of CDM (single-instance design). See also
	// the comments in the exported ShutdownThreads function.
	//
	// Unfortunately, we can't report errors to CDM, but we check the
	// global before dereferencing (except here which has an HRESULT).
	//

	if (SUCCEEDED(CreateGlobalCDMEngUpdateInstance()))
	{
		g_pCDMEngUpdate->m_fOfflineMode = fOfflineMode;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\delexdl.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   delexdl.cpp
//
//  Description:
//
//      Function exported by IUEngine.dll to do extra work upon 
//		the engine Dll gets loaded, including:
//		(1) clean up old download folders
//		(2) download security data
//
//=======================================================================
#include "iuengine.h"
#include <wuiutest.h>
#include <fileutil.h>
#include <stringutil.h>
#include <trust.h>
#include <download.h>
#include <freelog.h>
#include <advpub.h>			// for ExtractFiles
#include <WaitUtil.h>
#include <urllogging.h>
#include <safefile.h>

#define GotoCleanUpIfAskedQuit				if (WaitForSingleObject(g_evtNeedToQuit, 0) == WAIT_OBJECT_0) {goto CleanUp;}


//
// Default expiration time is 30 days (30 days * 24 hrs * 60 min * 60 sec)
//
// Since the default time has a very large granularity, we don't account for the
// documented differences between FILETIME for different platforms and file systems
// (see MSDN for details).
//
const DWORD DEFAULT_EXPIRED_SECONDS = 2592000;

const int NanoSec100PerSec = 10000000;		// number of 100 nanoseconds per second (FILETIME unit)

DWORD WINAPI DeleteFoldersThreadProc(LPVOID lpv);

void AsyncDeleteExpiredDownloadFolders(void);


//=========================================================================
//
// exported public function called by control after the engine loaded.
//
//=========================================================================
void WINAPI AsyncExtraWorkUponEngineLoad()
{
	//
	// Only do this the first time we are loaded (not for every client / instance)
	//
	if (0 == InterlockedExchange(&g_lDoOnceOnLoadGuard, 1))
	{
		AsyncDeleteExpiredDownloadFolders();
	}
}



//-------------------------------------------------------------------------
//
// Creates a thread that searches WUTemp folders for old downloaded content
// that has not been deleted.
//
// Since it is not critical that this function succeed, we don't return
// errors.
//
//-------------------------------------------------------------------------
void AsyncDeleteExpiredDownloadFolders()
{
	LOG_Block("DeleteExpiredDownloadFolders");

	DWORD dwThreadId;
	HANDLE hThread;

	//
	// Create thread and let it run until it finishes or g_evtNeedToQuit gets signaled
	//
    InterlockedIncrement(&g_lThreadCounter);

    hThread = CreateThread(NULL, 0, DeleteFoldersThreadProc, (LPVOID) NULL, 0, &dwThreadId);
    if (NULL == hThread)
    {
        LOG_ErrorMsg(GetLastError());
		InterlockedDecrement(&g_lThreadCounter);
        return;
    }

	CloseHandle(hThread);
}


//-------------------------------------------------------------------------
//
// DeleteFoldersThreadProc()
//
//	thread function to clean up expired download folders
//	
//-------------------------------------------------------------------------
DWORD WINAPI DeleteFoldersThreadProc(LPVOID /*lpv*/)
{
	LOG_Block("DeleteFoldersThreadProc");

	DWORD dwExpiredSeconds = DEFAULT_EXPIRED_SECONDS;
	HRESULT hr;
	FILETIME ftExpired;
	ULARGE_INTEGER u64ft;
	ULARGE_INTEGER u64Offset;
	DWORD dwRet;

#if defined(__WUIUTEST)
	// Override DEFAULT_EXPIRED_SECONDS
	HKEY hKey;
	int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
	if (ERROR_SUCCESS == error)
	{
		DWORD dwSize = sizeof(DWORD);
		DWORD dwValue;
		error = RegQueryValueEx(hKey, REGVAL_DEFAULT_EXPIRED_SECONDS, 0, 0, (LPBYTE) &dwExpiredSeconds, &dwSize);
		if (ERROR_SUCCESS == error)
		{
			LOG_Driver(_T("DEFAULT_EXPIRED_SECONDS changed to %d seconds"), dwExpiredSeconds);
		}

		RegCloseKey(hKey);
	}
#endif

	GetSystemTimeAsFileTime(&ftExpired);

	u64ft.u.LowPart = ftExpired.dwLowDateTime;
	u64ft.u.HighPart = ftExpired.dwHighDateTime;

	u64Offset.u.LowPart = NanoSec100PerSec;
	u64Offset.u.HighPart = 0;
	u64Offset.QuadPart *= dwExpiredSeconds;
	u64ft.QuadPart -= u64Offset.QuadPart;

	ftExpired.dwLowDateTime = u64ft.u.LowPart;
	ftExpired.dwHighDateTime = u64ft.u.HighPart;
	//
	// Get list of drives we will search
	//
	TCHAR szDriveStrBuffer[MAX_PATH + 2];
	TCHAR szWUTempPath[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFindFile = INVALID_HANDLE_VALUE;

	LPTSTR pszRootPathName;

	//
	// If quit was signaled before we were scheduled, just bail
	//
	GotoCleanUpIfAskedQuit;

	//
	// Make sure we are double-null terminated by zeroing buffer and lying about size
	//
	ZeroMemory(szDriveStrBuffer, sizeof(szDriveStrBuffer));

	if (0 == (dwRet = GetLogicalDriveStrings(ARRAYSIZE(szDriveStrBuffer) - 2, (LPTSTR) szDriveStrBuffer))
		|| (ARRAYSIZE(szDriveStrBuffer) - 2) < dwRet)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	for (pszRootPathName = szDriveStrBuffer; NULL != *pszRootPathName; pszRootPathName += lstrlen(pszRootPathName) + 1)
	{
		//
		// Only look for szIUTemp on fixed drives
		//
		if (DRIVE_FIXED == GetDriveType(pszRootPathName))
		{
			//
			// Create the dir path
			//
            hr = StringCchCopyEx(szWUTempPath, ARRAYSIZE(szWUTempPath), pszRootPathName,
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    continue;
			}

			hr = PathCchAppend(szWUTempPath, ARRAYSIZE(szWUTempPath), IU_WUTEMP);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    continue;
			}

			DWORD dwAttr;

			dwAttr = GetFileAttributes(szWUTempPath);

			if (dwAttr != 0xFFFFFFFF && (FILE_ATTRIBUTE_DIRECTORY & dwAttr))
			{
				//
				// Look for directories older than ftExpired
				//
				// NOTE:When we add support for AU and/or Drizzle we should add a
				// file to the folder to override the default delete time. 
				// We should synchronize access to this file by opening exclusive.
				//

				// Find the first file in the directory
    			hr = PathCchAppend(szWUTempPath, ARRAYSIZE(szWUTempPath), _T("\\*.*"));
    			if (FAILED(hr))
    			{
    			    LOG_ErrorMsg(hr);
			        continue;
    			}

				if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(szWUTempPath, &fd)))
				{
					LOG_ErrorMsg(GetLastError());
			        continue;
				}

				do 
				{
					if (
						(CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						fd.cFileName, -1, TEXT("."), -1)) ||
						(CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						fd.cFileName, -1, TEXT(".."), -1))
					) continue;
					
					if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
					{
						//
						// If directory creation time < expired time delete the directory
						//
						if (-1 == CompareFileTime(&fd.ftCreationTime, &ftExpired))
						{
							TCHAR szDirPath[MAX_PATH];

                            hr = StringCchCopyEx(szDirPath, ARRAYSIZE(szDirPath), pszRootPathName,
                                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
                			if (FAILED(hr))
                			{
                			    LOG_ErrorMsg(hr);
            			        continue;
                			}

                			hr = PathCchAppend(szDirPath, ARRAYSIZE(szDirPath), IU_WUTEMP);
                			if (FAILED(hr))
                			{
                			    LOG_ErrorMsg(hr);
            			        continue;
                			}

                			hr = PathCchAppend(szDirPath, ARRAYSIZE(szDirPath), fd.cFileName);
                			if (FAILED(hr))
                			{
                			    LOG_ErrorMsg(hr);
            			        continue;
                			}
							
							(void) SafeDeleteFolderAndContents(szDirPath, SDF_DELETE_READONLY_FILES | SDF_CONTINUE_IF_ERROR);
						}
					}

					GotoCleanUpIfAskedQuit;

				} while (FindNextFile(hFindFile, &fd));// Find the next entry
			}
		}

	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}

    InterlockedDecrement(&g_lThreadCounter);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\cdmp.h ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmp.h
//
//
//  Description:
//
//      CDM internal header
//
//=======================================================================

#ifndef _CDMP_H
#define _CDMP_H

#include <winspool.h>
#include <winsprlp.h>	// private header containing EPD_ALL_LOCAL_AND_CLUSTER define
#include <winnt.h>
#include <iuxml.h>

#if defined(__cplusplus)
extern "C" {
#endif

#define MAX_INDEX_TO_SEARCH 100 //range to find unique file names for hardware_XXX.xml

//
// Unicode text files require a magic header (first byte of file must be 0xFF and second 0xFE).
//
const BYTE UNICODEHDR[] = { 0xFF, 0xFE };


class CDeviceInstanceIdArray
{
public:
	CDeviceInstanceIdArray();
	~CDeviceInstanceIdArray();

	int Add(LPCWSTR pszDIID);
	LPWSTR operator[](int index);
	int Size() { return m_nCount; }
	void FreeAll();

private:
	LPWSTR* m_ppszDIID;
	int m_nCount;
	int m_nPointers;
};
//
// Used to control functionality of GetPackage() : NOTE that pBstrCatalog is always
// allocated and returned unless function fails.
//
typedef enum {	GET_PRINTER_INFS,	// writes generated printer INF's to path returned in lpDownloadPath
				DOWNLOAD_DRIVER,	// downloads driver to path returned in lpDownloadPath
				GET_CATALOG_XML		// returns catalog BSTR only - no download or INF created
} ENUM_GETPKG;

HRESULT GetPackage(	ENUM_GETPKG eFunction,
					PDOWNLOADINFO pDownloadInfo,
					LPTSTR lpDownloadPath,
					DWORD cchDownloadPath,
					BSTR* pbstrXmlCatalog);		// must be freed by caller if allocated

// called by DownloadUpdatedFiles()
HRESULT GetDownloadPath(BSTR bstrXmlItems, LPTSTR szPath);

HRESULT OpenUniqueProviderInfName(
						IN		LPCTSTR szDirPath,
						IN		LPCTSTR pszProvider,
						IN OUT	LPTSTR	pszFilePath,
						IN      DWORD cchFilePath,
						OUT		HANDLE &hFile);
HRESULT WriteInfHeader(LPCTSTR pszProvider, HANDLE& hFile);
HRESULT PruneAndBuildPrinterINFs(BSTR bstrXmlPrinterCatalog, LPTSTR lpDownloadPath, DRIVER_INFO_6* paDriverInfo6, DWORD dwDriverInfoCount);
HRESULT GetInstalledPrinterDriverInfo(const OSVERSIONINFO* pOsVersionInfo, DRIVER_INFO_6** ppaDriverInfo6, DWORD* pdwDriverInfoCount);

//
// Located in sysspec.cpp, but used in cdmp.cpp and sysspec.cpp
//
HRESULT AddPrunedDevRegProps(HDEVINFO hDevInfoSet,
									PSP_DEVINFO_DATA pDevInfoData,
									CXmlSystemSpec& xmlSpec,
									LPTSTR pszMatchingID,			// pszMatchingID and pszDriverVer should be NULL or
									LPTSTR pszDriverVer,			// point to valid strings
									DRIVER_INFO_6* paDriverInfo6,	// OK if this is NULL (no installed printer drivers)
									DWORD dwDriverInfoCount,
									BOOL fIsSysSpecCall);			// Called by GetSystemSpec and GetPackage, with slightly different behavior

HRESULT GetMultiSzDevRegProp(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, DWORD dwProperty, LPTSTR* ppMultiSZ);

HRESULT DoesHwidMatchPrinter(
					DRIVER_INFO_6* paDriverInfo6,			// array of DRIVER_INFO_6 structs for installed printer drivers
					DWORD dwDriverInfoCount,				// count of structs in paDriverInfo6 array
					LPCTSTR pszMultiSZ,						// Hardware or Compatible MultiSZ to compare with installed drivers
					BOOL* pfHwidMatchesInstalledPrinter		// [OUT] set TRUE if we match an installed printer driver
);

HRESULT AddIDToXml(LPCTSTR pszMultiSZ, CXmlSystemSpec& xmlSpec, DWORD dwProperty,
						  DWORD& dwRank, HANDLE_NODE& hDevices, LPCTSTR pszMatchingID, LPCTSTR pszDriverVer);


HRESULT GetMatchingDeviceID(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, LPTSTR* ppszMatchingID, LPTSTR* ppszDriverVer);

//called by InternalLogDriverNotFound()
HRESULT OpenUniqueFileName(
					IN LPTSTR lpBuffer, 
					IN DWORD  cchBuffer,
					OUT HANDLE &hFile
);


#if defined(__cplusplus)
}	// end extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\detect.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   detect.cpp
//
//  Description:
//
//      Implementation for the Detect() function
//
//=======================================================================

#include "iuengine.h"
#include "iuxml.h"

#include <logging.h>
#include <StringUtil.h>
#include <download.h>
#include "schemamisc.h"
#include "expression.h"
#include <iucommon.h>


//
// define constants used in this file
//
#define C_INDEX_STATUS_INSTALLED	0
#define C_INDEX_STATUS_UPTODATE		1
#define C_INDEX_STATUS_NEWVERSION	2
#define C_INDEX_STATUS_EXCLUDED		3
#define	C_INDEX_STATUS_FORCE		4
#define C_INDEX_STATUS_COMPUTER		5	// <computerSystem>
#define C_INDEX_ARRAY_SIZE			6


//
// declare macros used in this cpp file
//

/** 
* deckare the constants used to manipulate the result of Detect() method
*/
/**
* used in <detection> tag, to tell the detection result. This result
* should overwrite the rest of <expression>, if any
*/
extern const LONG     IUDET_INSTALLED;							/* mask for <installed> result */
extern const LONG     IUDET_INSTALLED_NULL;					/* mask for <installed> missing */
extern const LONG     IUDET_UPTODATE;							/* mask for <upToDate> result */
extern const LONG     IUDET_UPTODATE_NULL;						/* mask for <upToDate> missing */
extern const LONG     IUDET_NEWERVERSION;						/* mask for <newerVersion> result */
extern const LONG     IUDET_NEWERVERSION_NULL;					/* mask for <newerVersion> missing */
extern const LONG     IUDET_EXCLUDED;							/* mask for <excluded> result */
extern const LONG     IUDET_EXCLUDED_NULL;						/* mask for <excluded> missing */
extern const LONG     IUDET_FORCE;								/* mask for <force> result */
extern const LONG     IUDET_FORCE_NULL;						/* mask for <force> missing */
extern const LONG	   IUDET_COMPUTER;							// mask for <computerSystem> result
extern const LONG	   IUDET_COMPUTER_NULL;						// <computerSystem> missing


const DetResultMask[6][2] = {
	{IUDET_INSTALLED, IUDET_INSTALLED_NULL},
	{IUDET_UPTODATE, IUDET_UPTODATE_NULL},
	{IUDET_NEWERVERSION, IUDET_NEWERVERSION_NULL},
	{IUDET_EXCLUDED, IUDET_EXCLUDED_NULL},
	{IUDET_FORCE, IUDET_FORCE_NULL},
	{IUDET_COMPUTER, IUDET_COMPUTER_NULL}
};
					


//
// local macros
//
#define ReturnIfHrFail(hr)		if (FAILED(hr)) {LOG_ErrorMsg(hr); return hr;}
#define GotoCleanupIfNull(p)	if (p) goto CleanUp
#define SetDetResultFromDW(arr, index, dw, bit, bitNull)	\
								if (bitNull == (dw & bitNull)) \
									arr[index] = -1; \
								else \
									arr[index] = (bit == (dw & bit)) ? 1 : 0;
		






/////////////////////////////////////////////////////////////////////////
//
// Private function DoDetection()
//		do detection on one item
//		
//	Input:
//		one item node
//
//	Output:
//		detect result: array of integer, each represents a result
//		of one element. indexes are defined as C_INDEX_STATUS_XXX
//		value:	<0	expresison not present
//				=0	evalues to FALSE
//				>0	evalues to TRUE
//
//
//	Return:
//		S_OK if everything fine or error code
/////////////////////////////////////////////////////////////////////////
HRESULT 
DoDetection(
	IXMLDOMNode*	pNode,			// one item node
	BOOL			fIsItemNode,	// need to go down 1 level to get detection node
	int*			pResultArray	// array of result
)
{
	LOG_Block("DoDetection");

	int					i;
	BOOL				fRet = FALSE;
	BOOL				fNeedReleaseNode = FALSE;
	HRESULT				hr = S_OK;
	BSTR				bstrNodeName	= NULL;
	BSTR				bstrText		= NULL;
	IXMLDOMNode*		pDetectionNode	= NULL;
	IXMLDOMNode*		pDetectionChild = NULL;
	IXMLDOMNode*		pExpression		= NULL;



	USES_IU_CONVERSION;

	if (fIsItemNode)
	{
		hr = pNode->selectSingleNode(KEY_DETECTION, &pDetectionNode);
		if (S_FALSE == hr || NULL == pDetectionNode)
		{
			hr = E_INVALIDARG;	// no detection node found!
			LOG_ErrorMsg(hr);
			return hr;
		}
	}
	else
	{
		pDetectionNode = pNode;
	}

	if (NULL == pDetectionNode)
	{
		//
		// no detection node. Legal schema though.
		// nothing we can do, so bail out.
		//
		LOG_XML(_T("no detection node found for this item! Returns S_FALSE, so it won't be reported"));
		return S_FALSE;
	}


	//
	// initialize result array
	//
	for (i = 0; i < C_INDEX_ARRAY_SIZE; i++)
	{
		pResultArray[i] = -1;
	}


	//
	// detection node may have a list of child nodes, each child node has
	// a different name for different purpose of detection.
	// each child node contains one and only one expression node
	//
	LOG_XML(_T("No costom detection DLL found. Detection children..."));

	(void) pDetectionNode->get_firstChild(&pDetectionChild);


	while (NULL != pDetectionChild)
	{
		//
		// for each child, see if it is a known detection child
		//
		(void) pDetectionChild->get_nodeName(&bstrNodeName);

		static const BSTR C_DETX_NAME[] = {
										KEY_INSTALLED, 
										KEY_UPTODATE, 
										KEY_NEWERVERSION, 
										KEY_EXCLUDED, 
										KEY_FORCE,
										KEY_COMPUTERSYSTEM
		};
		for (i = 0; i < ARRAYSIZE(C_DETX_NAME); i++)
		{
			if (CompareBSTRsEqual(bstrNodeName, C_DETX_NAME[i]))
			{
				//
				// found this child node is a known detection node
				//
				if (C_INDEX_STATUS_COMPUTER == i)
				{
					//
					// if this is the computerSystem detection, 
					// then we ignore all child nodes, just do a simple
					// function call to find out if this machine matches
					// the manufacturer and model
					//
					hr = DetectComputerSystem(pDetectionChild, &fRet);
				}
				else
				//
				// get the expression node from this child node
				//
				if (SUCCEEDED(hr = pDetectionChild->get_firstChild(&pExpression)))
				{

					if (NULL != pExpression)
					{
						hr = DetectExpression(pExpression, &fRet);
						LOG_XML(_T("Detection result for tag %s = %d, returns 0x%08x"), OLE2T(bstrNodeName), fRet?1:0, hr);
					}
					else
					{
						//
						// if there is no child, this is an empty detection type, 
						// then we will treat this as "ALWAYS TRUE", and reset hr so
						// this "always true" result can be sent out
						//
						fRet = TRUE;
						hr = S_OK;
					}
					
					SafeReleaseNULL(pExpression);

				}

				//
				// store the detection result
				//
				pResultArray[i] = (fRet) ? 1 : 0;

				break;	// done with current node
			}
		}

		SafeSysFreeString(bstrNodeName);


		if (FAILED(hr))
		{
			//
			// report error to log file
			//
			IXMLDOMNode* pIdentityNode = NULL, *pProviderNode = NULL;
			BSTR bstrIdentStr = NULL;
			char* pNodeType = (fIsItemNode) ? "Provider:" : "Item:";

			//
			// we need to find out the identity string of this node
			//
			if (fIsItemNode)
			{
				//
				// this is an item node, containing identity node
				//
				(void)FindNode(pNode, KEY_IDENTITY, &pIdentityNode);
			}
			else
			{
				//
				// this is the detection node of a provider
				//
				if (SUCCEEDED(pNode->get_parentNode(&pProviderNode)) && NULL != pProviderNode)
				{
					(void)FindNode(pProviderNode, KEY_IDENTITY, &pIdentityNode);
				}

			}


			//
			// if we have a valid identity node
			//
			if (NULL != pIdentityNode &&
				SUCCEEDED(UtilGetUniqIdentityStr(pIdentityNode, &bstrIdentStr, 0x0)) &&
				NULL != bstrIdentStr)
			{
				//
				// output log about the error
				//
#if defined(UNICODE) || defined(_UNICODE)
					LogError(hr, "Found error during detection %hs %ls", pNodeType, bstrIdentStr);
#else

					LogError(hr, "Found error during detection %s %s", pNodeType,  OLE2T(bstrIdentStr));
#endif
					SysFreeString(bstrIdentStr);
			}
			SafeReleaseNULL(pProviderNode);
			SafeReleaseNULL(pIdentityNode);

			//
			// if any one detection returns fail, then this detection node is
			// not valid - it means something wrong in the detection
			// data. we will just ignore this detection, no output for it.
			//
			break;
		}

		//
		// try next detection child
		//
		IXMLDOMNode* pNextNode = NULL;
		pDetectionChild->get_nextSibling(&pNextNode);
		SafeReleaseNULL(pDetectionChild);
		pDetectionChild = pNextNode;
	}

	SafeReleaseNULL(pDetectionChild);
	if (fIsItemNode)
	{
		SafeReleaseNULL(pDetectionNode);
	}
	
	return hr;
}





/////////////////////////////////////////////////////////////////////////////
// public function Detect()
//
// Do detection.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be detected 
// Output:
// pbstrXmlItems - the detected items in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1" force="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::Detect(BSTR bstrXmlCatalog, DWORD dwFlags, BSTR *pbstrXmlItems)
{
	HRESULT				hr				= S_OK;
	IXMLDOMNodeList*	pProviderList	= NULL;
	IXMLDOMNodeList*	pProvChildList	= NULL;
	IXMLDOMNode*		pCurProvider	= NULL;
	IXMLDOMNode*		pCurNode		= NULL;
	CXmlCatalog			xmlCatalog;
	CXmlItems			ItemList;					// result item list
	HANDLE_NODE			hNode;
	int					DetStatus[C_INDEX_ARRAY_SIZE];
	int					i;

	DWORD				dwDownloadFlags	= 0;

	LOG_Block("Detect()");

//#if defined(_DEBUG) || defined(DEBUG)
	USES_IU_CONVERSION;
//#endif

	if (NULL == bstrXmlCatalog || NULL == pbstrXmlItems)
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		return hr;
	}

	LOG_XML(_T("Catalog=%s"), OLE2T(bstrXmlCatalog));

    // Set Global Offline Flag - checked by XML Classes to disable Validation (schemas are on the net)
    if (dwFlags & FLAG_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

	//
	// Convert bstrXmlCatalog to XMLDOM
	//
	hr = xmlCatalog.LoadXMLDocument(bstrXmlCatalog, m_fOfflineMode);
	ReturnIfHrFail(hr);
	LOG_XML(_T("Catalog has been loaded into XMLDOM"));

	//
	// get the list of providers from catalog 
	//
	pProviderList = xmlCatalog.GetProviders();
	if (NULL == pProviderList)
	{
		LOG_Error(_T("No provider found!"));
		return E_INVALIDARG;
	}

	//
	// get the first provider
	//
	(void) pProviderList->nextNode(&pCurProvider);

	//
	// for each provider, process their item list
	//
	while (NULL != pCurProvider)
	{
		//
		// get the children list from this node
		//
		pCurProvider->get_childNodes(&pProvChildList);

		if (NULL != pProvChildList)
		{
			long n;
			//
			// loop through the list to process each item of catalog
			//
			long iProvChildren = 0;
			pProvChildList->get_length(&iProvChildren);


			BOOL	fProviderOkay = TRUE;
			BSTR	bstrHref = NULL;

			//
			// process each child of this provider to see
			// if there is any detection node or any item node,
			//
			for (n = 0; n < iProvChildren && fProviderOkay; n++)
			{
				pProvChildList->get_item(n, &pCurNode);

				BOOL fIsItemNode = DoesNodeHaveName(pCurNode, KEY_ITEM);

				if (fIsItemNode ||
					DoesNodeHaveName(pCurNode, KEY_DETECTION))
				{
					//
					// initialize the status result array
					//
					for (i = 0; i < C_INDEX_ARRAY_SIZE; i++)
					{
						DetStatus[i] = -1;	// init to not present
					}

					//
					// detect each pression of this detection node of this item
					// error reported inside this function
					//
					if (S_OK == DoDetection(pCurNode, fIsItemNode, DetStatus))
					{
						//
						// add the item to the item list
						//
						if (SUCCEEDED(ItemList.AddItem(fIsItemNode ? pCurNode : pCurProvider, &hNode)) && HANDLE_NODE_INVALID != hNode)
						{
							//
							// update the detection status result of this item
							//
							ItemList.AddDetectResult(
													 hNode, 
													 DetStatus[C_INDEX_STATUS_INSTALLED],
													 DetStatus[C_INDEX_STATUS_UPTODATE],
													 DetStatus[C_INDEX_STATUS_NEWVERSION],
													 DetStatus[C_INDEX_STATUS_EXCLUDED],
													 DetStatus[C_INDEX_STATUS_FORCE],
													 DetStatus[C_INDEX_STATUS_COMPUTER]
													);
							ItemList.SafeCloseHandleNode(hNode);
						}
					}
				}

				SafeReleaseNULL(pCurNode);

			} // end of this item 

			//SafeReleaseNULL(pCurNode); // in case it's not item node


		} // end of non-empty node list of this provider

		//
		// finished processing the current provider
		//
		SafeReleaseNULL(pProvChildList);
		SafeReleaseNULL(pCurProvider);

		//
		// try to get a hold of the next provider
		//
		(void) pProviderList->nextNode(&pCurProvider);

	} // end of iterating provider list

	
	//
	// output the detection reuslt as an item list
	//
	ItemList.GetItemsBSTR(pbstrXmlItems);

	LOG_XML(_T("Result=%s"), *pbstrXmlItems);

	//
	// done
	//
	SafeReleaseNULL(pProviderList);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\cdmp.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmp.cpp
//
//  Description:
//
//      CDM auxiliary functions
//
//			called by DownloadUpdatedFiles()
//				GetDownloadPath
//			
//			called by InternalLogDriverNotFound()
//				OpenUniqueFileName
//
//=======================================================================

#include <iuengine.h>
#include <shlwapi.h>
#include <ras.h>
#include <tchar.h>
#include <winver.h>

#include <download.h>
#include <wininet.h>
#include <fileutil.h>
#include "iuxml.h"
#include <wuiutest.h>
#include <StringUtil.h>

#include <cdm.h>
#include "cdmp.h"
#include "schemamisc.h"
#include <safefile.h>

const DWORD MAX_INF_STRING = 512;	// From DDK docs "General Syntax Rules for INF Files" section

const OLECHAR szXmlClientInfo[] = L"<clientInfo xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/clientInfo.xml\" clientName=\"CDM\" />";

const OLECHAR szXmlPrinterCatalogQuery[] = L"<query><dObjQueryV1 procedure=\"printercatalog\"></dObjQueryV1></query>";
const OLECHAR szXmlDriverDownloadQuery[] = L"<query><dObjQueryV1 procedure=\"driverupdates\"></dObjQueryV1></query>";

/////////////////////////////////////////////////////////////////////////////
// CXmlDownloadResult
class CXmlDownloadResult : public CIUXml
{
public:
	CXmlDownloadResult();

	~CXmlDownloadResult();

	HRESULT LoadXMLDocumentItemStatusList(BSTR bstrXml);
	//
	// Expose m_pItemNodeList so it can be used directly
	//
	IXMLDOMNodeList*	m_pItemStatusNodeList;

private:
	IXMLDOMDocument*	m_pDocResultItems;
};

/////////////////////////////////////////////////////////////////////////////
// CXmlDownloadResult
/////////////////////////////////////////////////////////////////////////////

CXmlDownloadResult::CXmlDownloadResult()
 : m_pDocResultItems(NULL), m_pItemStatusNodeList(NULL)
{
}


CXmlDownloadResult::~CXmlDownloadResult()
{
	SafeReleaseNULL(m_pDocResultItems);
	SafeReleaseNULL(m_pItemStatusNodeList);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocumentItemStatusList()
//
// Load an XML Document from string and create the list of items
//
// Calls to Download produce return status in the following (example) XML format:
//
// <?xml version="1.0"?>
// <items xmlns="x-schema:http://schemas.windowsupdate.com/iu/resultschema.xml">
// 	<itemStatus xmlns="">
// 		<identity name="nvidia.569">nvidia.569
// 		<publisherName>nvidia</publisherName>
// 		</identity>
// 		<downloadStatus value="COMPLETE" errorCode="100"/>
// 	</itemStatus>
// </items>
// 
// We expose m_pItemNodeList so it can be used directly to retrieve the value
// attribute of the <downloadStatus /> item.
//
// NOTE: for CDM there will only be one item downloaded at a time, so the list
// will only contain a single <itemStatus/> element.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlDownloadResult::LoadXMLDocumentItemStatusList(BSTR bstrXml)
{
	LOG_Block("CXmlDownloadResult::LoadXMLDocumentItemStatusList");

	HRESULT hr = S_OK;
	BSTR bstrAllDocumentItems = NULL;

	if (NULL == bstrXml || m_pDocResultItems || m_pItemStatusNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	CleanUpIfFailedAndSetHr(LoadXMLDoc(bstrXml, &m_pDocResultItems));
	//
	// Get a list of all <itemStatus/> elements anywhere in the document
	//
	if (NULL == (bstrAllDocumentItems = SysAllocString(L"//itemStatus")))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

	if (NULL == (m_pItemStatusNodeList = FindDOMNodeList(m_pDocResultItems, bstrAllDocumentItems)))
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}

CleanUp:

	SysFreeString(bstrAllDocumentItems);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CXmlPrinterCatalogList
class CXmlPrinterCatalogList : public CIUXml
{
public:
	CXmlPrinterCatalogList();

	~CXmlPrinterCatalogList();

	HRESULT LoadXMLDocumentAndGetCompHWList(BSTR bstrXml);
	//
	// Expose m_pCompHWNodeList so it can be used directly
	//
	IXMLDOMNodeList*	m_pCompHWNodeList;

private:
	IXMLDOMDocument*	m_pDocCatalogItems;
};

/////////////////////////////////////////////////////////////////////////////
// CXmlPrinterCatalogList
/////////////////////////////////////////////////////////////////////////////

CXmlPrinterCatalogList::CXmlPrinterCatalogList()
 : m_pDocCatalogItems(NULL), m_pCompHWNodeList(NULL)
{
}


CXmlPrinterCatalogList::~CXmlPrinterCatalogList()
{
	SafeReleaseNULL(m_pDocCatalogItems);
	SafeReleaseNULL(m_pCompHWNodeList);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocumentAndGetCompHWList()
//
// Load an XML Document from string and create the list of
//    <compatibleHardware/> elements.
//
// "printercatalog" SOAP queries sent via GetManifest return a list of
// all printers for the given platform in the following format (validates against
// http://schemas.windowsupdate.com/iu/catalogschema.xml) having the following
// characteristics:
//
//   * <catalog clientType="CONSUMER">
//   * Only a single <provider> with <identity name="printerCatalog">printerCatalog</identity>
//   * returned <platform/> is not used by CDM
//   * <item/> identity and <platform> are likewise ignored by CDM
//   * Under item/detection/compatibleHardware/device the driverName, driverProvider, mfgName,
//     and driverVer attributes, as well as hwid string are extracted and used to build
//     printer INF files.
//   * Algorithms in this class take advantage of the fact that driverProvider attributes
//     are serialized (e.g. grouped in order by driverProvider), however this is not a requirement.
//   * Note that <item/> elements can contain more than one <compatibleHardware/> element,
//     but the complete list of <compatibleHardware/> elements provides all printers in
//     the given catalog
//
// Sample start of a "printerCatalog" catalog:
// ------------------------------------------
//	  <?xml version="1.0" ?> 
//	- <catalog clientType="CONSUMER">
//		- <provider>
//		  <identity name="printerCatalog">printerCatalog</identity> 
//		  <platform>ver_platform_win32_nt.5.0.x86.en</platform> 
//		+ <item installable="1">
//			  <identity name="hp.3">hp.3</identity> 
//			- <detection>
//				- <compatibleHardware>
//					- <device isPrinter="1">
//						  <printerInfo driverName="HP PSC 500" driverProvider="Hewlett-Packard Co." mfgName="HP" /> 
//						  <hwid rank="0" driverVer="1999-12-14">DOT4PRT\HEWLETT-PACKARDPSC_59784</hwid> 
//					  </device>
//				  </compatibleHardware>
//				- <compatibleHardware>
//				... etc.
//			  </detection>
//		  </item>
//		+ <item installable="1">
//		... etc.
//
//
// Likewise, driver information for requested PnP drivers is returned in catalog
// items.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlPrinterCatalogList::LoadXMLDocumentAndGetCompHWList(BSTR bstrXml)
{
	LOG_Block("CXmlPrinterCatalogList::LoadXMLDocumentAndGetCompHWList");

	HRESULT hr = S_OK;
	BSTR bstrAllDocumentItems = NULL;

	if (NULL == bstrXml || m_pDocCatalogItems || m_pCompHWNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	CleanUpIfFailedAndSetHr(LoadXMLDoc(bstrXml, &m_pDocCatalogItems));
	//
	// Get a list of all <item/> elements anywhere in the document
	//
	if (NULL == (bstrAllDocumentItems = SysAllocString(L"//compatibleHardware")))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

	if (NULL == (m_pCompHWNodeList = FindDOMNodeList(m_pDocCatalogItems, bstrAllDocumentItems)))
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}

CleanUp:
	SysFreeString(bstrAllDocumentItems);

	return hr;
}


///////////////////////////////////////////////////////////////////
//
// Locally defined LPTSTR array - dynamically expands
//
///////////////////////////////////////////////////////////////////

#define NUM_DIIDPTR_ALLOC 10

CDeviceInstanceIdArray::CDeviceInstanceIdArray()
: m_ppszDIID(NULL), m_nCount(0), m_nPointers(0)
{
}

CDeviceInstanceIdArray::~CDeviceInstanceIdArray()
{
	LOG_Block("CDeviceInstanceIdArray::~CDeviceInstanceIdArray");

	FreeAll();
	//
	// Free the array of LPTSTRs
	//
	SafeHeapFree(m_ppszDIID);
	m_nPointers = 0;
}

void CDeviceInstanceIdArray::FreeAll()
{
	LOG_Block("CDeviceInstanceIdArray::Free");

	if (NULL != m_ppszDIID && 0 < m_nCount)
	{
		//
		// Free the strings
		//
		for (int i = 0; i < m_nCount; i++)
		{
			SafeHeapFree(*(m_ppszDIID+i));
		}
		m_nCount = 0;
	}
}

int CDeviceInstanceIdArray::Add(LPCWSTR pszDIID)
{
	HRESULT hr;
	LPWSTR  pszIDtoAdd = NULL;
	DWORD   cch;

	LOG_Block("CDeviceInstanceIdArray::Add");

	if (NULL == pszDIID)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return -1;
	}

	//
	// Allocate or realloc space for NUM_DIIDPTR_ALLOC LPSTRs
	//
	if (NULL == m_ppszDIID)
	{
		m_ppszDIID = (LPWSTR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LPWSTR) * NUM_DIIDPTR_ALLOC);

		if(NULL == m_ppszDIID)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			return -1;
		}
		m_nPointers = NUM_DIIDPTR_ALLOC;
	}
	else if (m_nCount == m_nPointers)
	{
		//
		// We've used all our allocated pointers, realloc more
		//
		LPWSTR* ppTempDIID;
		//
		// Increase number of pointers currently allocated by NUM_DIIDPTR_ALLOC
		//
		ppTempDIID =  (LPWSTR*) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_ppszDIID,
			(sizeof(LPWSTR) * (m_nPointers + NUM_DIIDPTR_ALLOC))  );

		if(NULL == ppTempDIID)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			return -1;
		}

		m_ppszDIID = ppTempDIID;
		m_nPointers += NUM_DIIDPTR_ALLOC;
	}

	//
	// Alloc memory for to hold the DIID and copy it
	//
	cch = (lstrlenW(pszDIID) + 1);
	if (NULL == (pszIDtoAdd = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, cch * sizeof(WCHAR))))
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
		goto CleanUp;
	}

	hr = StringCchCopyExW(pszIDtoAdd, cch, pszDIID, NULL, NULL, MISTSAFE_STRING_FLAGS);
	if (FAILED(hr))
	{
	    HeapFree(GetProcessHeap(), 0, pszIDtoAdd);
	    pszIDtoAdd = NULL;
	    goto CleanUp;
	}

	*(m_ppszDIID+m_nCount) = pszIDtoAdd;
	m_nCount++;

CleanUp:

	if (NULL == pszIDtoAdd)
	{
		return -1;
	}
	else
	{
#if defined(_UNICODE) || defined(UNICODE)
		LOG_Driver(_T("%s added to list"), pszIDtoAdd);
#else
		LOG_Driver(_T("%S added to list"), pszIDtoAdd);
#endif
		return m_nCount - 1;
	}
}


LPWSTR CDeviceInstanceIdArray::operator[](int index)
{
	LOG_Block("CDeviceInstanceIdArray::operator[]");

	if (0 > index || m_nCount < index + 1)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return NULL;
	}

	return *(m_ppszDIID+index);
}

///////////////////////////////////////////////////////////////////

// Gets a path to the directory that cdm.dll has copied the install cabs to
// and returns the length of the path.
// Note: The input buffer must be at least MAX_PATH size.

HRESULT GetDownloadPath(
	IN		BSTR bstrXmlCatalog,	// Catalog we passed to Download (only contains one item)
	IN		BSTR bstrXmlDownloadedItems,
	IN OUT	LPTSTR lpDownloadPath,	// Local directory where extracted files were placed.
	IN OUT  DWORD  cchDownloadPath
)
{
	USES_IU_CONVERSION;

	LOG_Block("GetDownloadPath");
	
	HRESULT hr = S_OK;

	BSTR bstrDownloadPath = NULL;
	BSTR bstrItem = NULL;

	CXmlItems* pxmlDownloadedItems = NULL;
	CXmlCatalog catalog;
	HANDLE_NODE hCatalogItem;
	HANDLE_NODE hProvider;
	HANDLE_NODELIST hItemList;
	HANDLE_NODELIST hProviderList;

	if (NULL == bstrXmlCatalog || NULL == lpDownloadPath || NULL == bstrXmlDownloadedItems || 0 == cchDownloadPath)
	{
		CleanUpIfFailedAndSetHr(E_INVALIDARG);
	}

	lpDownloadPath[0] = _T('\0');

	//
	// Load the XML and get the <item/> list and node of first item (only one in CDM case)
	//
	CleanUpIfFailedAndSetHr(catalog.LoadXMLDocument(bstrXmlCatalog, g_pCDMEngUpdate->m_fOfflineMode));

	hProviderList = catalog.GetFirstProvider(&hProvider);
	if (HANDLE_NODELIST_INVALID == hProviderList || HANDLE_NODE_INVALID == hProvider)
	{
		CleanUpIfFailedAndSetHr(E_INVALIDARG);
	}
	
	hItemList = catalog.GetFirstItem(hProvider, &hCatalogItem);
	if (HANDLE_NODELIST_INVALID == hItemList || HANDLE_NODE_INVALID == hProvider)
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}
	//
	// Construct CXmlItems for read
	//
	CleanUpFailedAllocSetHrMsg(pxmlDownloadedItems = new CXmlItems(TRUE));

	CleanUpIfFailedAndMsg(pxmlDownloadedItems->LoadXMLDocument(bstrXmlDownloadedItems));
	
    hr = pxmlDownloadedItems->GetItemDownloadPath(&catalog, hCatalogItem, &bstrDownloadPath);
    if (NULL == bstrDownloadPath)
    {
        LOG_Driver(_T("Failed to get Item Download Path from ReturnSchema"));
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        goto CleanUp;
    }

    hr = StringCchCopyEx(lpDownloadPath, cchDownloadPath, OLE2T(bstrDownloadPath),
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto CleanUp;

CleanUp:

	if (pxmlDownloadedItems)
	{
		delete pxmlDownloadedItems;
	}
	
	SysFreeString(bstrDownloadPath);
	SysFreeString(bstrItem);

	return hr;
}

// called by InternalDriverNotFound(...)
// Find a file name not used so far into which hardware xml information will be inserted
// The file name will be in format hardware_xxx.xml where xxx is in range [1..MAX_INDEX_TO_SEARCH]
// The position file found last time is remembered and new search will start from the next position
// Caller is supposed to close handle and delete file
//  pszFilePath	IN OUT : allocated and freed by caller. Buffer to store unique file name found: MUST be MAX_PATH
//  hFile		OUT    : store a handle to the opened file
//return S_OK if Unique File Name found 
//return E_INVALIDARG if buffer pointer is NULL (must be called with MAX_PATH length buffer)
//return E_FAIL if all qualified file names already taken
HRESULT OpenUniqueFileName(
						IN OUT	LPTSTR pszFilePath, 
						IN      DWORD  cchFilePath,
						OUT		HANDLE &hFile
)
{
	LOG_Block("OpenUniqueFileName");

	static DWORD dwFileIndex = 1;
	int nCount = 0;
	const TCHAR FILENAME[] = _T("Hardware_");
	const TCHAR FILEEXT[] = _T("xml");
	TCHAR szDirPath[MAX_PATH + 1];
	HRESULT hr;

	if (NULL == pszFilePath || 0 == cchFilePath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	pszFilePath[0] = _T('\0');

	GetIndustryUpdateDirectory(szDirPath);
	LOG_Out(_T("Directory to search unique file names: %s"), szDirPath);

	hFile = INVALID_HANDLE_VALUE;
	do 
	{
	    hr = StringCchPrintfEx(pszFilePath, cchFilePath, NULL, NULL, MISTSAFE_STRING_FLAGS,
	                           _T("%s%s%d.%s"), szDirPath, FILENAME, dwFileIndex, FILEEXT);
	    if (FAILED(hr))
	    {
	        LOG_ErrorMsg(hr);
	        return hr;
	    }
	    
		hFile = CreateFile(pszFilePath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, NULL);
		if (INVALID_HANDLE_VALUE == hFile) 
		{
			//
			// Could test for ERROR_FILE_EXISTS == dwErr (expected) and bail on other errors indicating
			// a more serious problem, however this return isn't doc'ed in the JAN 2001 SDK, and the
			// documented ERROR_ALREADY_EXISTS applies instead to CREATE_ALWAYS or OPEN_ALWAYS.
			//
			LOG_Out(_T("%s already exists"), pszFilePath);
			dwFileIndex ++;
			nCount ++;
			if (dwFileIndex > MAX_INDEX_TO_SEARCH)
			{
				dwFileIndex = 1;
			}
		}
		else 
		{
			break; //first available file name found
		}
	}while(nCount < MAX_INDEX_TO_SEARCH );
	
	if (nCount == MAX_INDEX_TO_SEARCH ) 
	{
		LOG_Out(_T("All %d file names have been taken"), nCount);
		LOG_ErrorMsg(E_FAIL);
		return E_FAIL;
	}

	LOG_Out(_T("Unique file name %s opened for GENERIC_WRITE using CreateFile"), pszFilePath);
	dwFileIndex++; //next time skip file name found this time
	if (dwFileIndex > MAX_INDEX_TO_SEARCH)
	{
		//
		// Start again at the beginning - maybe one of earlier files has been deleted by HelpCenter...
		//
		dwFileIndex = 1;
	}
	return S_OK;
}

HRESULT WriteInfHeader(LPCTSTR pszProvider, HANDLE& hFile)
{
	LOG_Block("WriteInfHeader");

	const TCHAR HEADER_START[] =
			_T("[Version]\r\n")
			_T("Signature=\"$Windows NT$\"\r\n")
			_T("Provider=%PRTPROV%\r\n")
			_T("ClassGUID={4D36E979-E325-11CE-BFC1-08002BE10318}\r\n")
			_T("Class=Printer\r\nCatalogFile=webntprn.cat\r\n")
			_T("\r\n")
			_T("[ClassInstall32.NT]\r\n")
			_T("AddReg=printer_class_addreg\r\n")
			_T("\r\n")
			_T("[printer_class_addreg]\r\n")
			_T("HKR,,,,%%PrinterClassName%%\r\n")
			_T("HKR,,Icon,,\"-4\"\r\n")
			_T("HKR,,Installer32,,\"ntprint.dll,ClassInstall32\"\r\n")
			_T("HKR,,NoDisplayClass,,1\r\n")
			_T("HKR,,EnumPropPages32,,\"printui.dll,PrinterPropPageProvider\"\r\n")
			_T("\r\n")
			_T("[Strings]\r\n")
			_T("PRTPROV=\"");

	const TCHAR HEADER_END[] = 
			_T("\"\r\n")
			_T("PrinterClassName=\"Printer\"\r\n")
			_T("\r\n");

	HRESULT hr = S_OK;
	DWORD dwWritten;

	if (NULL == pszProvider || hFile == INVALID_HANDLE_VALUE)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

#if defined(_UNICODE) || defined(UNICODE)
	//
	// Write Unicode Header
	//
	if (0 == WriteFile(hFile, (LPCVOID) &UNICODEHDR, sizeof(UNICODEHDR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}
#endif
	//
	// Write the first part of INF header
	//
	if (0 == WriteFile(hFile, HEADER_START, sizeof(HEADER_START) - sizeof(TCHAR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}
	//
	// Write the provider string
	//
	if (0 == WriteFile(hFile, (LPCVOID) pszProvider, lstrlen(pszProvider) * sizeof(TCHAR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}
	//
	// Write the remainder of the INF header
	//
	if (0 == WriteFile(hFile, HEADER_END, sizeof(HEADER_END) - sizeof(TCHAR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}

CleanUp:

	if (FAILED(hr) && INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

	return hr;
}

//
// pszFilePath must be >= MAX_PATH characters
//
HRESULT OpenUniqueProviderInfName(
						IN		LPCTSTR szDirPath,
						IN		LPCTSTR pszProvider,
						IN OUT	LPTSTR	pszFilePath,
						IN      DWORD cchFilePath,
						OUT		HANDLE &hFile
)
{
	LOG_Block("OpenUniqueProviderInfName");

	const TCHAR FILEROOT[] = _T("PList_");
	const TCHAR FILEEXT[] = _T("inf");
	DWORD dwErr;
	HRESULT hr;

	hFile = INVALID_HANDLE_VALUE;

	if (NULL == pszFilePath || NULL == pszProvider || NULL == szDirPath || 0 == cchFilePath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	pszFilePath[0] = _T('\0');

	hr = StringCchPrintfEx(pszFilePath, cchFilePath, NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%s%s%s.%s"), szDirPath, FILEROOT, pszProvider, FILEEXT);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
		pszFilePath[0] = _T('\0');
        return hr;
    }

	//
	// Try to open an existing INF of this name. If this fails try to create then init the file.
	//
	hFile = CreateFile(pszFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL,
						OPEN_EXISTING, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, NULL);
	if (INVALID_HANDLE_VALUE == hFile) 
	{
		hFile = CreateFile(pszFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL,
							CREATE_NEW, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, NULL);
		if (INVALID_HANDLE_VALUE == hFile) 
		{
			dwErr = GetLastError();
			LOG_ErrorMsg(dwErr);
			pszFilePath[0] = _T('\0');
			return HRESULT_FROM_WIN32(dwErr);
		}
		//
		// Write the INF "Header" information to the new file
		//
		if (FAILED( hr = WriteInfHeader(pszProvider, hFile)))
		{
			pszFilePath[0] = _T('\0');
			return hr;
		}
	}

	return S_OK;
}

HRESULT OfferThisPrinterDriver(
					DRIVER_INFO_6* paDriverInfo6,	// array of DRIVER_INFO_6 structs for installed printer drivers
					DWORD dwDriverInfoCount,		// count of structs in paDriverInfo6 array
					IXMLDOMNode* pCompHWNode,		// <compatibleHardware> node from catalog
					BOOL* pfOfferDriver,			// [OUT] If TRUE offer this driver - remainder of outputs are valid
					VARIANT& vDriverName,			// [OUT]
					VARIANT& vDriverVer,			// [OUT]
					VARIANT& vDriverProvider,		// [OUT]
					VARIANT& vMfgName,				// [OUT]
					BSTR* pbstrHwidText)			// [OUT]
{
	USES_IU_CONVERSION;

	LOG_Block("OfferThisPrinterDriver");

	HRESULT hr = S_OK;
	IXMLDOMNode* pDriverNameNode = NULL;
	IXMLDOMNode* pDriverProviderNode = NULL;
	IXMLDOMNode* pMfgNameNode = NULL;
	IXMLDOMNode* pPInfoNode = NULL;
	IXMLDOMNode* pHwidNode = NULL;
	IXMLDOMNode* pDriverVerNode = NULL;
	IXMLDOMNamedNodeMap* pAttribMap = NULL;
	LPCTSTR pszCompareHwid = NULL;
#if !(defined(_UNICODE) || defined(UNICODE))
	//
	// We need to special-case ANSI since we can't use pointers into pbstrHwidText, which is wide
	//
	TCHAR szHwid[MAX_INF_STRING + 1];
#endif

	if (
		NULL == pCompHWNode	||
		NULL == pfOfferDriver ||
		NULL == pbstrHwidText)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	VariantInit(&vDriverName);
	VariantInit(&vDriverVer);
	VariantInit(&vDriverProvider);
	VariantInit(&vMfgName);
	*pfOfferDriver = TRUE;
	*pbstrHwidText = NULL;

	//
	// Get the first <printerInfo/> node of the item (we expect at least one else fail)
	//
	CleanUpIfFailedAndSetHrMsg(pCompHWNode->selectSingleNode(KEY_CDM_PINFO, &pPInfoNode));
	//
	// 517297 Ignore non-printer HWIDs in OfferThisPrinterDriver
	//
	// We may get device nodes that are not marked isPrinter="1" and do not have the <printerInfo/>
	// element. We don't offer these device nodes, but it is not an error.
	//
	if (NULL == pPInfoNode)
	{
		//
		// Change S_FALSE back to S_OK, but don't offer this device
		//
		hr = S_OK;
		*pfOfferDriver = FALSE;
		goto CleanUp;
	}

	CleanUpIfFailedAndSetHrMsg(pPInfoNode->get_attributes(&pAttribMap));
	if (NULL == pAttribMap) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	//
	// suck out the printerInfo attributes
	//
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_DRIVERNAME, &pDriverNameNode));
	if (NULL == pDriverNameNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_DRIVERPROVIDER, &pDriverProviderNode));
	if (NULL == pDriverProviderNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_MFGNAME, &pMfgNameNode));
	if (NULL == pMfgNameNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	//
	// pAttribMap will be reused later, free it here
	//
	SafeReleaseNULL(pAttribMap);
	
	CleanUpIfFailedAndSetHrMsg(pDriverNameNode->get_nodeValue(&vDriverName));
	CleanUpIfFailedAndSetHrMsg(pDriverProviderNode->get_nodeValue(&vDriverProvider));
	CleanUpIfFailedAndSetHrMsg(pMfgNameNode->get_nodeValue(&vMfgName));
	if (VT_BSTR != vDriverName.vt || VT_BSTR != vDriverProvider.vt || VT_BSTR != vMfgName.vt)
	{
		CleanUpIfFailedAndSetHrMsg(E_FAIL);
	}
	//
	// Get the first <hwid/> node of the item (we expect at least one else fail)
	//
	CleanUpIfFailedAndSetHrMsg(pCompHWNode->selectSingleNode(KEY_CDM_HWIDPATH, &pHwidNode));
	if (NULL == pHwidNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

	CleanUpIfFailedAndSetHrMsg(pHwidNode->get_attributes(&pAttribMap));
	if (NULL == pAttribMap) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	//
	// suck out the DriverVer attribute
	//
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_DRIVERVER, &pDriverVerNode));
	if (NULL == pDriverVerNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

	CleanUpIfFailedAndSetHrMsg(pDriverVerNode->get_nodeValue(&vDriverVer));
	if (VT_BSTR != vDriverVer.vt)
	{
		CleanUpIfFailedAndSetHrMsg(E_FAIL);
	}
	//
	// Get the <hwid/> text
	//
	// NOTE: Each item is restricted to a single <hwid/> element due to INF syntax,
	// however our catalog schema doesn't make similar restrictions and currently our
	// backend doesn't distinguish between <hwid/> and <compid/> values, so it is
	// possible we could get more than one <hwid/> returned. For the purpose of
	// generating INFs for Add Printer Wizard, any <hwid/> from the CAB will do.
	//
	CleanUpIfFailedAndSetHrMsg(pHwidNode->get_text(pbstrHwidText));

#if !(defined(_UNICODE) || defined(UNICODE))
    hr = StringCchCopyEx(szHwid, ARRAYSIZE(szHwid), OLE2T(*pbstrHwidText), 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
	LOG_Driver(_T("Got \"%s\" from XML for compare to DRIVER_INFO_6."), szHwid);
#else
	LOG_Driver(_T("Got \"%s\" from XML for compare to DRIVER_INFO_6."), *pbstrHwidText);
#endif

	if (NULL == paDriverInfo6 || 0 == dwDriverInfoCount)
	{
		LOG_Driver(_T("WARNING: We're missing information (maybe no installed printer drivers), so we won't prune"));
		goto CleanUp;
	}

#if !(defined(_UNICODE) || defined(UNICODE))
		pszCompareHwid = szHwid;
#else
		pszCompareHwid = (LPCTSTR) *pbstrHwidText;
#endif

	for (DWORD dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
	{
		if (NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
		{
			continue;
		}

		//
		// Use case-insensitive compares (paDriverInfo6 is different case from pszCompareHwid)
		//
		if (0 != lstrcmpi(pszCompareHwid, (paDriverInfo6 + dwCount)->pszHardwareID))
		{
			continue;
		}
		//
		// Else we have a hardware match - check the other attributes for exact match
		//
		if (0 != lstrcmpi(OLE2T(vDriverName.bstrVal), (paDriverInfo6 + dwCount)->pName) ||
			0 != lstrcmpi(OLE2T(vDriverProvider.bstrVal), (paDriverInfo6 + dwCount)->pszProvider) ||
			0 != lstrcmpi(OLE2T(vMfgName.bstrVal), (paDriverInfo6 + dwCount)->pszMfgName))
		{
			//
			LOG_Driver(_T("Prune this driver: it doesn't match all the attributes of the installed driver"));
			*pfOfferDriver = FALSE;
			goto CleanUp;
		}
		//
		// The driver matches, but make sure it has a newer DriverVer than the installed driver
		//
		LOG_Driver(_T("Driver item in catalog is compatible with installed driver"));

		SYSTEMTIME systemTime;
		if (0 == FileTimeToSystemTime((CONST FILETIME*) &((paDriverInfo6 + dwCount)->ftDriverDate), &systemTime))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
		//
		// Convert to ISO ISO 8601 prefered format (yyyy-mm-dd) so we can string compare with catalog BSTR
		//
		WCHAR wszDriverVer[11];

    	hr = StringCchPrintfExW(wszDriverVer, ARRAYSIZE(wszDriverVer), NULL, NULL, MISTSAFE_STRING_FLAGS,
                                L"%04d-%02d-%02d", systemTime.wYear, systemTime.wMonth, systemTime.wDay);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
			goto CleanUp;
        }

		if (0 < lstrcmpW(vDriverVer.bstrVal, wszDriverVer))
		{
			LOG_Driver(_T("WU DriverVer (%s) is > installed (%s)"), vDriverVer.bstrVal, wszDriverVer);
			*pfOfferDriver = TRUE;
			goto CleanUp;
		}
		else
		{
			LOG_Driver(_T("Prune this driver: WU DriverVer (%s) is <= installed (%s)"), vDriverVer.bstrVal, wszDriverVer);
			*pfOfferDriver = FALSE;
#if defined(__WUIUTEST)
			// DriverVer Override for ==
			HKEY hKey;
			int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
			if (ERROR_SUCCESS == error)
			{
				DWORD dwSize = sizeof(DWORD);
				DWORD dwValue;
				error = RegQueryValueEx(hKey, REGVAL_ALLOW_EQUAL_DRIVERVER, 0, 0, (LPBYTE) &dwValue, &dwSize);
				if (ERROR_SUCCESS == error && 1 == dwValue)
				{
					//
					// If DriverVers are equal (we already installed a driver from WU, allow it anyway
					//
					if (0 == lstrcmpW(vDriverVer.bstrVal, wszDriverVer))
					{
						*pfOfferDriver = TRUE;
						LOG_Driver(_T("WU DriverVer (%s) is = installed (%s), WUIUTEST override and offer"), vDriverVer.bstrVal, wszDriverVer);
					}
				}

				RegCloseKey(hKey);
			}
#endif
			goto CleanUp;
		}
	}

CleanUp:

	if (FAILED(hr))
	{
		if (NULL != pfOfferDriver)
		{
			*pfOfferDriver = FALSE;
		}

		if (NULL != pbstrHwidText)
		{
			SafeSysFreeString(*pbstrHwidText);
		}
		VariantClear(&vDriverName);
		VariantClear(&vDriverVer);
		VariantClear(&vDriverProvider);
		VariantClear(&vMfgName);
	}

	SafeReleaseNULL(pDriverNameNode);
	SafeReleaseNULL(pDriverProviderNode);
	SafeReleaseNULL(pMfgNameNode);
	SafeReleaseNULL(pPInfoNode);
	SafeReleaseNULL(pHwidNode);
	SafeReleaseNULL(pDriverVerNode);
	SafeReleaseNULL(pAttribMap);

	return hr;
}

HRESULT GetInstalledPrinterDriverInfo(const OSVERSIONINFO* pOsVersionInfo, DRIVER_INFO_6** ppaDriverInfo6, DWORD* pdwDriverInfoCount)
{
	LOG_Block("GetInstalledPrinterDriverInfo");

	HRESULT hr = S_OK;
	DWORD dwBytesNeeded;

	if (NULL == pOsVersionInfo || NULL == ppaDriverInfo6 || NULL == pdwDriverInfoCount)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*pdwDriverInfoCount = 0;
	*ppaDriverInfo6 = NULL;

	LPTSTR pszEnvironment;

	if (VER_PLATFORM_WIN32_WINDOWS == pOsVersionInfo->dwPlatformId)
	{
		//
		// Don't pass an environment string for Win9x
		//
		pszEnvironment = NULL;
	}
	else if (5 <= pOsVersionInfo->dwMajorVersion && 1 <= pOsVersionInfo->dwMinorVersion)
	{
		//
		// Use EPD_ALL_LOCAL_AND_CLUSTER only on Whistler and up
		//
		pszEnvironment = EPD_ALL_LOCAL_AND_CLUSTER;
	}
	else
	{
		//
		// From V3 sources (hard-coded for NT)
		//
		pszEnvironment = _T("all");
	}

	if(!EnumPrinterDrivers(NULL, pszEnvironment, 6, NULL, 0, &dwBytesNeeded, pdwDriverInfoCount))
	{
		if (ERROR_INSUFFICIENT_BUFFER != GetLastError() || (0 == dwBytesNeeded))
		{
			LOG_Driver(_T("No printer drivers enumerated"));
		}
		else
		{
			//
			// Allocate the requested buffer
			//
			CleanUpFailedAllocSetHrMsg(*ppaDriverInfo6 = (DRIVER_INFO_6*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytesNeeded));

			//
			// Fill in DRIVER_INFO_6 array
			//
			if (!EnumPrinterDrivers(NULL, pszEnvironment, 6, (LPBYTE) *ppaDriverInfo6, dwBytesNeeded, &dwBytesNeeded, pdwDriverInfoCount))
			{
				Win32MsgSetHrGotoCleanup(GetLastError());
			}
			LOG_Driver(_T("%d printer drivers found"), *pdwDriverInfoCount);
			//
			// Validate the driver elements for each printer driver. 
			//
			for (DWORD dwCount = 0; dwCount < *pdwDriverInfoCount; dwCount++)
			{
				if (   NULL == (*ppaDriverInfo6 + dwCount)->pszHardwareID
					|| NULL == (*ppaDriverInfo6 + dwCount)->pszProvider
					|| NULL == (*ppaDriverInfo6 + dwCount)->pszMfgName
					|| NULL == (*ppaDriverInfo6 + dwCount)->pName  )
				{
					LOG_Driver(_T("Skiping driver with incomplete ID info: set pszHardwareID = NULL"));
					//
					// We use pszHardwareID == NULL to invalidate incomplete entry
					//
					(*ppaDriverInfo6 + dwCount)->pszHardwareID = NULL;
					continue;
				}
			}
		}
	}

CleanUp:

	if (FAILED(hr))
	{
		SafeHeapFree(*ppaDriverInfo6);
		*ppaDriverInfo6 = NULL;
		*pdwDriverInfoCount = 0;
	}

	return hr;
}

//
// Build and write to disk Printer INFs constructed from printer items available
// on this platform. Also prunes printer drivers that would conflict with installed
// drivers (e.g. Unidriver vs. Monolithic, etc.).
//
HRESULT PruneAndBuildPrinterINFs(BSTR bstrXmlPrinterCatalog, LPTSTR lpDownloadPath, DWORD cchDownloadPath, DRIVER_INFO_6* paDriverInfo6, DWORD dwDriverInfoCount)
{
	USES_IU_CONVERSION;

	LOG_Block("PruneAndBuildPrinterINFs");

	HRESULT hr;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	const TCHAR SZ_PLISTDIR[] = _T("CDMPlist\\");
	DWORD dwWritten;
	LONG lLength;

	VARIANT vDriverName;
	VARIANT vDriverVer;
	VARIANT vDriverProvider;
	VARIANT vMfgName;

	VariantInit(&vDriverName);
	VariantInit(&vDriverVer);
	VariantInit(&vDriverProvider);
	VariantInit(&vMfgName);

	BOOL fOfferDriver = FALSE;

	BSTR bstrHwidText = NULL;

	IXMLDOMNode* pCompHWNode = NULL;

	LPTSTR pszInfDirPath = NULL;
	LPTSTR pszInfFilePath = NULL;
	LPOLESTR pwszDriverProvider = NULL;
	LPTSTR pszMfgName = NULL;
	LPTSTR pszDriverName = NULL;
	LPTSTR pszInstallSection = NULL;

	CXmlPrinterCatalogList xmlItemList;

	if (NULL == bstrXmlPrinterCatalog || NULL == lpDownloadPath || 0 == cchDownloadPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	lpDownloadPath[0] = _T('\0');
	//
	// Dynamically allocate buffers (PreFast warning 831: This function uses 5884 bytes of stack,
	// consider moving some data to heap.)
	//
	pszInfDirPath		= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof(TCHAR));
	pszInfFilePath		= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof(TCHAR));
	pwszDriverProvider	= (LPOLESTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(OLECHAR));
	pszMfgName			= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(TCHAR));
	pszDriverName		= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(TCHAR));
	pszInstallSection	= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(TCHAR));

	if (NULL == pszInfDirPath ||
		NULL == pszInfFilePath ||
		NULL == pwszDriverProvider ||
		NULL == pszMfgName ||
		NULL == pszDriverName ||
		NULL == pszInstallSection	)
	{
		SetHrMsgAndGotoCleanUp(E_OUTOFMEMORY);
	}

	//
	// Create the directory for the INFs after deleting any existing directory
	//
	GetIndustryUpdateDirectory((LPTSTR) pszInfDirPath);
	if ((MAX_PATH) < (lstrlen(pszInfDirPath) + ARRAYSIZE(SZ_PLISTDIR) + 1))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

    // pszInfDirPath was alloced to be MAX_PATH above
    hr = PathCchAppend(pszInfDirPath, MAX_PATH, SZ_PLISTDIR);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

	//
	// Delete any existing INFs and recreate the directory - we'll get fresh content
	//
	LOG_Driver(_T("SafeDeleteFolderAndContents: %s"), pszInfDirPath);
	(void) SafeDeleteFolderAndContents(pszInfDirPath, SDF_DELETE_READONLY_FILES | SDF_CONTINUE_IF_ERROR);

	hr = CreateDirectoryAndSetACLs(pszInfDirPath, TRUE);
	CleanUpIfFailedAndMsg(hr);

	//
	// Load the XML and get the <compatibleHardware/> list and number of items
	//
	// NOTE: each <compatibleHardware/> element contains a single unique driver.
	// In the event we get duplicates with different driverVer's we really don't care
	// as the last one will overright the previous instances and Add Printer Wizard
	// doesn't look at driverVer (we prune if it's too old).
	//
	CleanUpIfFailedAndSetHr(xmlItemList.LoadXMLDocumentAndGetCompHWList(bstrXmlPrinterCatalog));
	CleanUpIfFailedAndSetHrMsg(xmlItemList.m_pCompHWNodeList->get_length(&lLength));

	for (LONG l = 0; l < lLength; l++)
	{
		//
		// Get the next <item/> node from list
		//
		CleanUpIfFailedAndSetHrMsg(xmlItemList.m_pCompHWNodeList->nextNode(&pCompHWNode));
		if (NULL == pCompHWNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
		//
		// Check the driver against installed printer drivers for compatibility and prune if
		//  incompatible or DriverVer <= installed DriverVer.
		//
		CleanUpIfFailedAndSetHr(OfferThisPrinterDriver(paDriverInfo6, dwDriverInfoCount, pCompHWNode, &fOfferDriver, \
									vDriverName, vDriverVer, vDriverProvider, vMfgName, &bstrHwidText));

		SafeReleaseNULL(pCompHWNode);

		if (!fOfferDriver)								
		{
			LOG_Driver(_T("Pruning hwid = %s, driverVer = %s, driverName = %s, driverProvider = %s, driverMfgr = %s"),\
				OLE2T(bstrHwidText), OLE2T(vDriverVer.bstrVal),  \
				OLE2T(vDriverName.bstrVal), OLE2T(vDriverProvider.bstrVal), OLE2T(vMfgName.bstrVal) );

            VariantClear(&vDriverName);
            VariantClear(&vDriverVer);
            VariantClear(&vDriverProvider);
            VariantClear(&vMfgName);
            SafeSysFreeString(bstrHwidText);
            continue;
		}

		LOG_Driver(_T("Adding hwid = %s, driverVer = %s, driverName = %s, driverProvider = %s, driverMfgr = %s to INF"),\
			OLE2T(bstrHwidText), OLE2T(vDriverVer.bstrVal),  \
			OLE2T(vDriverName.bstrVal), OLE2T(vDriverProvider.bstrVal), OLE2T(vMfgName.bstrVal) );

		if (0 != lstrcmpiW(pwszDriverProvider, vDriverProvider.bstrVal))
		{

            // pwszDriverProvider was alloced to be MAX_INF_STRING * sizeof(OLECHAR) above.
            hr = StringCchCopyExW(pwszDriverProvider, MAX_INF_STRING, vDriverProvider.bstrVal,
                                  NULL, NULL, MISTSAFE_STRING_FLAGS);
            CleanUpIfFailedAndSetHr(hr);
			//
			// Open pszInfFilePath and initialize with "header" an INF file based on pwszDriverProvider.
			// If it already exists, just open it (and return existing pszInfFilePath) 
			//
            // pszInfFilePath is allocated to be MAX_PATH above.
			CleanUpIfFailedAndSetHr(OpenUniqueProviderInfName(pszInfDirPath, OLE2T(pwszDriverProvider), pszInfFilePath, MAX_PATH, hFile));
			//
			// Once the file is initialized, we don't need to keep it open
			//
			CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
		}
		//
		// Write the mfgName in the [Manufacturer] section, for example
		// [Manufacturer]
		// "Ricoh"="Ricoh"
		//
		// ISSUE-2001/02/05-waltw Could optimize by caching last known name like provider above...

		
		// pszMfgName is alloced to be MAX_INF_STRING characters above
    	hr = StringCchPrintfEx(pszMfgName, MAX_INF_STRING, NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("\"%s\""), (LPCTSTR) OLE2T(vMfgName.bstrVal));
        CleanUpIfFailedAndSetHr(hr);

		if (0 == WritePrivateProfileString(_T("Manufacturer"), pszMfgName, pszMfgName, pszInfFilePath))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		// pszDriverName is alloced to be MAX_INF_STRING characters above
    	hr = StringCchPrintfEx(pszDriverName, MAX_INF_STRING, NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("\"%s\""), OLE2T(vDriverName.bstrVal));
        CleanUpIfFailedAndSetHr(hr);
        
		// pszInstallSection is alloced to be MAX_INF_STRING characters above
    	hr = StringCchPrintfEx(pszInstallSection, MAX_INF_STRING, NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("InstallSection,\"%s\""), OLE2T(bstrHwidText));
        CleanUpIfFailedAndSetHr(hr);
		//
		// Write printer item in [mfgName] section, for example:
		// [RICOH]
		// "RICOH Aficio 850 PCL 6"=InstallSection,"LPTENUM\RICOHAFICIO_850F1B7"
		if (0 == WritePrivateProfileString(OLE2T(vMfgName.bstrVal), pszDriverName, pszInstallSection, pszInfFilePath))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

        VariantClear(&vDriverName);
        VariantClear(&vDriverVer);
        VariantClear(&vDriverProvider);
        VariantClear(&vMfgName);
        SafeSysFreeString(bstrHwidText);
	}

CleanUp:

	if(SUCCEEDED(hr))
	{
        hr = StringCchCopyEx(lpDownloadPath, cchDownloadPath, pszInfDirPath,
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
			lpDownloadPath[0] = _T('\0');
            LOG_ErrorMsg(hr);
        }
	}

	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

	VariantClear(&vDriverName);
	VariantClear(&vDriverVer);
	VariantClear(&vDriverProvider);
	VariantClear(&vMfgName);

	SafeHeapFree(pszInfDirPath);
	SafeHeapFree(pszInfFilePath);
	SafeHeapFree(pwszDriverProvider);
	SafeHeapFree(pszMfgName);
	SafeHeapFree(pszDriverName);
	SafeHeapFree(pszInstallSection);
	SafeSysFreeString(bstrHwidText);

	SafeReleaseNULL(pCompHWNode);

	return hr;
}

BOOL HwidMatchesDeviceInfo(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA deviceInfoData, LPCTSTR pszHardwareID)
{
	LOG_Block("HwidMatchesDeviceInfo");

	HRESULT hr = S_OK;
	LPTSTR pszMultiHwid = NULL;
	LPTSTR pszMultiCompid = NULL;
	LPTSTR pszTemp;

	//
	// Get the Hardware and Compatible Multi-SZ strings so we can prune printer devices before commiting to XML.
	//
	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, &deviceInfoData, SPDRP_HARDWAREID, &pszMultiHwid));

	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, &deviceInfoData, SPDRP_COMPATIBLEIDS, &pszMultiCompid));
	//
	// Do we have a match with an enumerated device HWID or Compatible ID?
	//
	if (NULL != pszMultiHwid)
	{
		for(pszTemp = pszMultiHwid; *pszTemp; pszTemp += (lstrlen(pszTemp) + 1))
		{
			if (0 == lstrcmpi(pszTemp, pszHardwareID))
			{
				LOG_Driver(_T("This deviceInfoData matches HWID %s"), pszHardwareID);
				goto CleanUp;
			}
		}
	}

	if (NULL != pszMultiCompid)
	{
		for(pszTemp = pszMultiCompid; *pszTemp; pszTemp += (lstrlen(pszTemp) + 1))
		{
			if (0 == lstrcmpi(pszTemp, pszHardwareID))
			{
				LOG_Driver(_T("This deviceInfoData matches HWID %s"), pszHardwareID);
				goto CleanUp;
			}
		}
	}
	//
	// We didn't find a match
	//
	LOG_Driver(_T("Failed to find a matching HWID or Printer ID for %s"), pszHardwareID);
	hr = E_FAIL;

CleanUp:

	SafeHeapFree(pszMultiHwid);
	SafeHeapFree(pszMultiCompid);

	return (SUCCEEDED(hr));
}


// This function is called to download the actual package.
//
// If this function is successfull then it returns S_OK. If the case of a
// failure this function returns an error code.

HRESULT GetPackage(
	IN	ENUM_GETPKG eFunction,			// Function to be performed by GetPackage
	IN	PDOWNLOADINFO pDownloadInfo,	// DownloadInformation structure describing package to be read from server
	OUT LPTSTR lpDownloadPath,			// Pointer to local directory on the client computer system
										// where the downloaded files are to be stored. NOTE: OK to pass NULL if
										// GET_CATALOG_XML == eFunction.
    IN  DWORD cchDownloadPath,
	OUT BSTR* pbstrXmlCatalog			// On SUCCESS, catalog is always allocated - caller must call SysFreeString()
)
{
	USES_IU_CONVERSION;

	LOG_Block("GetPackage");

	HRESULT hr;

	BSTR bstrXmlSystemSpec = NULL;
	BSTR bstrXmlClientInfo = NULL;
	BSTR bstrXmlQuery = NULL;
	BSTR bstrXmlDownloadedItems = NULL;
	BSTR bstrDownloadStatus = NULL;
	BSTR bstrStatusValue = NULL;
	BSTR bstrProvider = NULL;
	BSTR bstrMfgName = NULL;
	BSTR bstrName = NULL;
	BSTR bstrHardwareID = NULL;
	BSTR bstrDriverVer = NULL;

	IU_PLATFORM_INFO iuPlatformInfo;
	HDEVINFO hDevInfoSet = INVALID_HANDLE_VALUE;
	SP_DEVINFO_DATA devInfoData;
	DRIVER_INFO_6* paDriverInfo6 = NULL;
	DWORD dwDriverInfoCount = 0;
	LPCTSTR pszHardwareID = NULL;	// pDownloadInfo LPCWSTR converted to ANSI (automatically freed by IU_CONVERSION)
									// OR just points to LPCWSTR pDownloadInfo->lpHardwareIDs or ->lpDeviceInstanceID 
	DWORD dwDeviceIndex;
	BOOL fHwidMatchesInstalledPrinter = FALSE;
	BOOL fAPWNewPrinter = FALSE;
	HANDLE_NODE hPrinterDevNode = HANDLE_NODE_INVALID;
	HANDLE_NODE hDevices = HANDLE_NODE_INVALID;
	DWORD dwCount;

	CXmlSystemSpec xmlSpec;
	CXmlDownloadResult xmlItemStatusList;
	IXMLDOMNode* pItemStatus = NULL;
	IXMLDOMNode* pStatusNode = NULL;
	IXMLDOMNode* pValueNode = NULL;
	IXMLDOMNamedNodeMap* pAttribMap = NULL;
	VARIANT vStatusValue;

	LPTSTR	pszMatchingID = NULL;
	LPTSTR	pszDriverVer= NULL;

	//
	// Initialize variant before any possible jump to CleanUp (BUG: 467098)
	//
	VariantInit(&vStatusValue);

	if (NULL == pDownloadInfo ||
		(NULL == lpDownloadPath && GET_CATALOG_XML != eFunction) ||
		NULL == pbstrXmlCatalog ||
		NULL == g_pCDMEngUpdate)
	{
		hr = E_INVALIDARG;
		return E_INVALIDARG;
	}

	if (NULL != lpDownloadPath && cchDownloadPath > 0)
	{
		lpDownloadPath[0] = _T('\0');
	}
	*pbstrXmlCatalog = NULL;

	//
	// Get iuPlatformInfo, but remember to clean up BSTRs on function exit
	//
	CleanUpIfFailedAndSetHr(DetectClientIUPlatform(&iuPlatformInfo));

	//
	// Get array of DRIVER_INFO_6 holding info on installed printer drivers. Only allocates and returns
	// memory for appropriate platforms that have printer drivers already installed.
	//
	CleanUpIfFailedAndSetHr(GetInstalledPrinterDriverInfo((OSVERSIONINFO*) &iuPlatformInfo.osVersionInfoEx, &paDriverInfo6, &dwDriverInfoCount));

	//
	// Build common bstrXmlClientInfo and parts of bstrXmlSystemSpec
	//
	if (NULL == (bstrXmlClientInfo = SysAllocString((OLECHAR*) &szXmlClientInfo)))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

	//
	// Add Computer System
	//
	CleanUpIfFailedAndSetHr(AddComputerSystemClass(xmlSpec));

	//
	// Add Platform
	//
	CleanUpIfFailedAndSetHr(AddPlatformClass(xmlSpec, iuPlatformInfo));
	//
	// Add OS & USER Locale information
	//
	CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, FALSE));
	CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, TRUE));

	//
	// If GET_PRINTER_INFS, we are retrieving a list of supported printers (V3 PLIST format) rather than a driver
	//
	switch (eFunction)
	{
	case GET_PRINTER_INFS:
		{
			CleanUpFailedAllocSetHrMsg(bstrXmlQuery = SysAllocString(szXmlPrinterCatalogQuery));

			CleanUpIfFailedAndSetHr(xmlSpec.GetSystemSpecBSTR(&bstrXmlSystemSpec));

			//
			// GetManifest will ResetEvent, so check before calling
			//
			if (WaitForSingleObject(g_pCDMEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
			{
				CleanUpIfFailedAndSetHrMsg(E_ABORT);
			}

			CleanUpIfFailedAndSetHrMsg(g_pCDMEngUpdate->GetManifest(bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, FLAG_USE_COMPRESSION, pbstrXmlCatalog));

			LOG_XmlBSTR(*pbstrXmlCatalog);

			//
			// Now, convert the returned pbstrXmlCatalog to an inf file per provider and write to a temporary location
			//
			CleanUpIfFailedAndSetHr(PruneAndBuildPrinterINFs(*pbstrXmlCatalog, lpDownloadPath, cchDownloadPath, paDriverInfo6, dwDriverInfoCount));
			break;
		}

	case DOWNLOAD_DRIVER:
	case GET_CATALOG_XML:
		{
			//
			// Put either the Hardware & Compatible ID from the DeviceInstanceID or printer info from DRIVER_INFO_6
			// or <hwid> passed by APW into a systemspec to pass to server with driver query.
			//
			if (NULL != pDownloadInfo->lpDeviceInstanceID)
			{
				if (INVALID_HANDLE_VALUE == (hDevInfoSet = (HDEVINFO)SetupDiCreateDeviceInfoList(NULL, NULL)))
				{
					Win32MsgSetHrGotoCleanup(GetLastError());
				}
				//
				// This is the Device Instance ID for an installed hardware device
				//
				ZeroMemory(&devInfoData, sizeof(SP_DEVINFO_DATA));
				devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

#if !(defined(_UNICODE) || defined(UNICODE))
				// OK to cast away const-ness since OLE2T copies string for ANSI
				pszHardwareID = OLE2T(const_cast<LPWSTR>(pDownloadInfo->lpDeviceInstanceID));
				CleanUpFailedAllocSetHrMsg(pszHardwareID);
#else
				pszHardwareID = pDownloadInfo->lpDeviceInstanceID;
#endif
				if (!SetupDiOpenDeviceInfo(hDevInfoSet, pszHardwareID, 0, 0, &devInfoData))
				{
					Win32MsgSetHrGotoCleanup(GetLastError());
				}
			}
			else if (NULL != pDownloadInfo->lpHardwareIDs)
			{
				// one hardware id for a package - either printers or w9x if we cannot find device instance ID
				// if architecture is not the same as current archtecture we need to prefix it
				SYSTEM_INFO sysInfo;
				GetSystemInfo(&sysInfo);
				
				if (pDownloadInfo->dwArchitecture != (DWORD) sysInfo.wProcessorArchitecture)
				{
					// Supporting PRINT_ENVIRONMENT_INTEL and PRINT_ENVIRONMENT_ALPHA prefixes
					// was V3 legacy functionality that was never used (originally intended to
					// support installation of non-native architecture drivers on print servers).
					// Since this feature isn't required or expected by the print team for
					// Windows Update functionality, we simply retain the compare as a sanity
					// check in case one of our clients forgets this.
					SetHrMsgAndGotoCleanUp(E_NOTIMPL);
				}

#if !(defined(_UNICODE) || defined(UNICODE))
				// OK to cast away const-ness since OLE2T copies string for ANSI
				pszHardwareID = OLE2T(const_cast<LPWSTR>(pDownloadInfo->lpHardwareIDs));
				CleanUpFailedAllocSetHrMsg(pszHardwareID);
#else
				pszHardwareID = pDownloadInfo->lpHardwareIDs;
#endif

				//
				// First see if we can match an installed printer driver HWID to the pszHardwareID
				//
				for (dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
				{
					if (NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
					{
						LOG_Driver(_T("Skipping NULL printer driver index %d"), dwCount);
						continue;
					}

					//
					// Use case-insensitive compares (paDriverInfo6 is different case from pszHardwareID)
					//
					if (0 != lstrcmpi(pszHardwareID, (paDriverInfo6 + dwCount)->pszHardwareID))
					{
						continue;
					}

					LOG_Driver(_T("Found match with an installed printer driver dwCount = %d"), dwCount);
					fHwidMatchesInstalledPrinter = TRUE;
					break;
				}

				if (!fHwidMatchesInstalledPrinter)
				{
					LOG_Driver(_T("Didn't find an installed printer driver with a matching HWID, enumerating the PnP IDs..."));
					//
					// We couldn't find a matching installed printer, so now
					// enumerate all the PnP IDs and try to find a matching node to
					// add to the system spec
					//
					if (INVALID_HANDLE_VALUE == (hDevInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES)))
					{
						Win32MsgSetHrGotoCleanup(GetLastError());
					}
		
					ZeroMemory(&devInfoData, sizeof(SP_DEVINFO_DATA));
					devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
					BOOL fRet;
					dwDeviceIndex = 0;
					while (fRet = SetupDiEnumDeviceInfo(hDevInfoSet, dwDeviceIndex++, &devInfoData))
					{
						//
						// Find a matching ID (could spit out Device Instance ID using SetupDiGetDeviceInstanceId for debug)
						//
						if (HwidMatchesDeviceInfo(hDevInfoSet, devInfoData, pszHardwareID))
						{
							break;
						}
					}

					if (!fRet)
					{
						//
						// We hit the end of the list without finding a match
						//
						if (ERROR_NO_MORE_ITEMS == GetLastError())
						{
							LOG_Driver(_T("Couldn't find a matching device instance enumerating the PnP devices - must be APW request for new printer"));
							fAPWNewPrinter = TRUE;
						}
						else
						{
							Win32MsgSetHrGotoCleanup(GetLastError());
						}
					}
				}
			}
			else
			{
				SetHrMsgAndGotoCleanUp(E_INVALIDARG);
			}
			//
			// We either found a matching printer driver or PnP device instance - add it to the system spec.
			// if DriverVer > installed DriverVer - for printer we have additional requirements
			//
			//
			if (fHwidMatchesInstalledPrinter)
			{
				//
				// Open a <device> element to write the printer info
				//
				bstrProvider = T2BSTR((paDriverInfo6 + dwCount)->pszProvider);
				bstrMfgName = T2BSTR((paDriverInfo6 + dwCount)->pszMfgName);
				bstrName = T2BSTR((paDriverInfo6 + dwCount)->pName);

				CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, 1, bstrProvider, \
					bstrMfgName, bstrName, &hPrinterDevNode));

				SafeSysFreeString(bstrProvider);
				SafeSysFreeString(bstrMfgName);
				SafeSysFreeString(bstrName);
				//
				// Convert ftDriverDate to ISO 8601 prefered format (yyyy-mm-dd)
				//
				SYSTEMTIME systemTime;
				if (0 == FileTimeToSystemTime((CONST FILETIME*) &((paDriverInfo6 + dwCount)->ftDriverDate), &systemTime))
				{
					LOG_Error(_T("FileTimeToSystemTime failed:"));
					LOG_ErrorMsg(GetLastError());
					SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(GetLastError()));
				}

				TCHAR szDriverVer[11];

            	hr = StringCchPrintfEx(szDriverVer, ARRAYSIZE(szDriverVer), NULL, NULL, MISTSAFE_STRING_FLAGS,
                                       _T("%04d-%02d-%02d"), systemTime.wYear, systemTime.wMonth, systemTime.wDay);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
				
				// Always rank 0 and never fIsCompatible
				bstrHardwareID = T2BSTR((paDriverInfo6 + dwCount)->pszHardwareID);
				bstrDriverVer = T2BSTR(szDriverVer);

				CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hPrinterDevNode, FALSE, 0, \
							bstrHardwareID, bstrDriverVer));

				SafeSysFreeString(bstrHardwareID);
				SafeSysFreeString(bstrDriverVer);

				xmlSpec.SafeCloseHandleNode(hPrinterDevNode);

#if defined(DBG)
				//
				// Need to copy strings to non-const for OLE2T conversion (ANSI)
				//
				TCHAR szbufHardwareID[MAX_PATH];
				TCHAR szbufDriverName[MAX_PATH];
				TCHAR szbufDriverProvider[MAX_PATH];
				TCHAR szbufMfgName[MAX_PATH];

                hr = StringCchCopyEx(szbufHardwareID, ARRAYSIZE(szbufHardwareID),
                                     (paDriverInfo6 + dwCount)->pszHardwareID,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                hr = StringCchCopyEx(szbufDriverName, ARRAYSIZE(szbufDriverName),
                                     (paDriverInfo6 + dwCount)->pName,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                hr = StringCchCopyEx(szbufDriverProvider, ARRAYSIZE(szbufDriverProvider),
                                     (paDriverInfo6 + dwCount)->pszProvider,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                hr = StringCchCopyEx(szbufMfgName, ARRAYSIZE(szbufMfgName),
                                     (paDriverInfo6 + dwCount)->pszMfgName,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
				
				LOG_Driver(_T("Offering Printer hwid = %s, driverVer = %s, driverName = %s, driverProvider = %s, driverMfgr = %s"),\
					(LPTSTR) szbufHardwareID, (LPTSTR) szDriverVer,  \
					(LPTSTR) szbufDriverName, (LPCWSTR) szbufDriverProvider, \
					(LPTSTR) szbufMfgName );
#endif
			}
			else if (fAPWNewPrinter)
			{
				if (NULL == pDownloadInfo->lpFile)
				{
					//
					// We need to "fake" a <hwid/> element with the ID passed in. User is trying to install
					// a printer driver picked in the Add Printer Wizard that doesn't already exist on the
					// system.
					//
					DWORD dwRank;
					dwRank = 0;
					CleanUpIfFailedAndSetHr(AddIDToXml(pszHardwareID, xmlSpec, SPDRP_HARDWAREID, dwRank, hDevices, NULL, NULL));
					if (HANDLE_NODE_INVALID != hDevices)
					{
						xmlSpec.SafeCloseHandleNode(hDevices);
					}
				}
				else
				{
					//
					// 516376 Changes required in CDM to fix the APW <-> CDM  bug found for multi-Provider scenario
					//
					// APW will pass a MULTI-SZ string containing (in this order) the following strings in the
					// previously unused lpFile member of DOWNLOADINFO if it wishes to specify provider.
					//
					// This string is not required (for convenience and backwards compatibility) but
					// if the lpFile member passed to CDM is non-NULL, it must contain all three strings
					// as follows:
					//   String 1: driver provider
					//   String 2: manufacturer name
					//   String 3: driver name
#if !(defined(_UNICODE) || defined(UNICODE))
					//
					// We will never support this functionality on Win9x
					//
					CleanUpIfFailedAndSetHr(E_NOTIMPL);
#else					
					LPCWSTR pszProvider = pDownloadInfo->lpFile;
					int nLenProvider = lstrlen(pszProvider);
					if (NULL == pszProvider + nLenProvider + 1)
					{
						CleanUpIfFailedAndSetHr(E_INVALIDARG);
					}
					LPCWSTR pszMfgName = pszProvider + nLenProvider + 1;
					int nLenMfgName = lstrlen(pszMfgName);
					if (NULL == pszMfgName + nLenMfgName + 1)
					{
						CleanUpIfFailedAndSetHr(E_INVALIDARG);
					}
					LPCWSTR pszDriverName = pszMfgName + nLenMfgName + 1;

					//
					// Open a <device> element to write the printer info
					//
					bstrProvider = SysAllocString(pszProvider);
					bstrMfgName = SysAllocString(pszMfgName);
					bstrName = SysAllocString(pszDriverName);

					if (NULL == bstrProvider || NULL == bstrMfgName || NULL == bstrName)
					{
						CleanUpIfFailedAndSetHr(E_OUTOFMEMORY);
					}

					CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, 1, bstrProvider, \
						bstrMfgName, bstrName, &hPrinterDevNode));

					SafeSysFreeString(bstrProvider);
					SafeSysFreeString(bstrMfgName);
					SafeSysFreeString(bstrName);

					// Always rank 0 and never fIsCompatible and no driverVer
					CleanUpFailedAllocSetHrMsg(bstrHardwareID = SysAllocString(pszHardwareID));

					CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hPrinterDevNode, FALSE, 0, \
								bstrHardwareID));

					SafeSysFreeString(bstrHardwareID);

					xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
#endif
				}
			}
			else
			{
				//
				// Get DriverVer for the PnP ID and check that offered driver is greater using the 
				// hDevInfoSet and devInfoData matched above while enumerating
				//
				CleanUpIfFailedAndSetHr(GetMatchingDeviceID(hDevInfoSet, &devInfoData, &pszMatchingID, &pszDriverVer));
				//
				// Add <device/> we matched and want to download to XML
				//
				CleanUpIfFailedAndSetHr(AddPrunedDevRegProps(hDevInfoSet, &devInfoData, xmlSpec, \
													pszMatchingID, pszDriverVer, paDriverInfo6, dwDriverInfoCount, FALSE));
			}

			//
			// Get the query string
			//
			CleanUpFailedAllocSetHrMsg(bstrXmlQuery = SysAllocString(szXmlDriverDownloadQuery));
			//
			// Get the bstrXmlSystemSpec
			//
			CleanUpIfFailedAndSetHr(xmlSpec.GetSystemSpecBSTR(&bstrXmlSystemSpec));

			LOG_XmlBSTR(bstrXmlSystemSpec);

			//
			// GetManifest will ResetEvent, so check before calling
			//
			if (WaitForSingleObject(g_pCDMEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
			{
				CleanUpIfFailedAndSetHrMsg(E_ABORT);
			}
			//
			// Call GetManifest to see if the server has anything that matches our system spec
			//
			CleanUpIfFailedAndSetHrMsg(g_pCDMEngUpdate->GetManifest(bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, \
												FLAG_USE_COMPRESSION, pbstrXmlCatalog));

			LOG_XmlBSTR( *pbstrXmlCatalog);

			//
			// If we are just getting the catalog we're done
			//
			if (GET_CATALOG_XML == eFunction)
			{
				break;
			}

			//
			// Download will ResetEvent, so check before calling
			//
			if (WaitForSingleObject(g_pCDMEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
			{
				CleanUpIfFailedAndSetHrMsg(E_ABORT);
			}
			//
			// Call Download passing it the catalog we got from GetManifest
			//
			CleanUpIfFailedAndSetHrMsg(g_pCDMEngUpdate->Download(bstrXmlClientInfo, *pbstrXmlCatalog, NULL, 0, NULL, NULL, &bstrXmlDownloadedItems));

			LOG_XmlBSTR(bstrXmlDownloadedItems);

			//
			// Verify that the package was downloaded
			//
			CleanUpIfFailedAndSetHr(xmlItemStatusList.LoadXMLDocumentItemStatusList(bstrXmlDownloadedItems));
			//
			// Get the first [only] item in the list
			//
			CleanUpIfFailedAndSetHr(xmlItemStatusList.m_pItemStatusNodeList->nextNode(&pItemStatus));
			if (NULL == pItemStatus) CleanUpIfFailedAndSetHrMsg(E_FAIL);

			//
			// Get the first <downloadStatus/> node of the statusItem (we expect at least one else fail)
			//
			if (NULL == (bstrDownloadStatus = SysAllocString(L"downloadStatus")))
			{
				CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
			}

			CleanUpIfFailedAndSetHrMsg(pItemStatus->selectSingleNode(bstrDownloadStatus, &pStatusNode));
			if (NULL == pStatusNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

			CleanUpIfFailedAndSetHr(pStatusNode->get_attributes(&pAttribMap));
			if (NULL == pAttribMap) CleanUpIfFailedAndSetHrMsg(E_FAIL);
			//
			// suck out the <downloadStatus/> value attributes
			//
			if (NULL == (bstrStatusValue = SysAllocString((OLECHAR*) L"value")))
			{
				CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
			}
			CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(bstrStatusValue, &pValueNode));
			if (NULL == pValueNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

			CleanUpIfFailedAndSetHrMsg(pValueNode->get_nodeValue(&vStatusValue));
			if (VT_BSTR != vStatusValue.vt)
			{
				CleanUpIfFailedAndSetHrMsg(E_FAIL);
			}

			if (0 != lstrcmpW((LPWSTR) vStatusValue.bstrVal, L"COMPLETE"))
			{
				CleanUpIfFailedAndSetHrMsg(E_FAIL);
			}
			//
			// Now copy the path to the buffer we were passed
			//
			CleanUpIfFailedAndSetHr(GetDownloadPath(*pbstrXmlCatalog, bstrXmlDownloadedItems, lpDownloadPath, cchDownloadPath));
			//
			// DecompressFolderCabs may return S_FALSE if it didn't find a cab to decompress...
			//
			hr = DecompressFolderCabs(lpDownloadPath);
			if (S_OK != hr)
			{
				CleanUpIfFailedAndSetHr(E_FAIL);
			}

			break;
		}

	default:
		{
			CleanUpIfFailedAndSetHr(E_INVALIDARG);
			break;
		}
	}	// switch (eFunction)
	

CleanUp:

	if (INVALID_HANDLE_VALUE != hDevInfoSet)
	{
		SetupDiDestroyDeviceInfoList(hDevInfoSet);
	}

	if (HANDLE_NODE_INVALID != hPrinterDevNode)
	{
		xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
	}

	if (HANDLE_NODE_INVALID != hDevices)
	{
		xmlSpec.SafeCloseHandleNode(hDevices);
	}

	SafeReleaseNULL(pItemStatus);
	SafeReleaseNULL(pStatusNode);
	SafeReleaseNULL(pValueNode);
	SafeReleaseNULL(pAttribMap);

	SafeHeapFree(paDriverInfo6);
	SafeHeapFree(pszMatchingID);
	SafeHeapFree(pszDriverVer);

	VariantClear(&vStatusValue);

	SysFreeString(bstrXmlSystemSpec);
	SysFreeString(bstrXmlClientInfo);
	SysFreeString(bstrXmlQuery);
	SysFreeString(bstrXmlDownloadedItems);
	SysFreeString(bstrDownloadStatus);
	SysFreeString(bstrStatusValue);
	SysFreeString(bstrProvider);
	SysFreeString(bstrMfgName);
	SysFreeString(bstrName);
	SysFreeString(bstrHardwareID);
	SysFreeString(bstrDriverVer);
	SysFreeString(iuPlatformInfo.bstrOEMManufacturer);
	SysFreeString(iuPlatformInfo.bstrOEMModel);
	SysFreeString(iuPlatformInfo.bstrOEMSupportURL);

	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrXmlCatalog);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\download.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   downld.cpp
//
//  Description:
//
//      Implementation for the Download() function
//
//=======================================================================

#include "iuengine.h"   // PCH - must include first
#include <iu.h>
#include <iucommon.h>
#include <download.h>
#include <trust.h>
#include <wininet.h>
#include <fileutil.h>
#include <shlwapi.h>
#include "iuxml.h"
#include "history.h"
#include <schemakeys.h>
//#include <serverPing.h> changed to use urllogging.h.
#include <intshcut.h>
#include <schemamisc.h>
#include <WaitUtil.h>
#include <urllogging.h>

#define MAX_CORPORATE_PATH      100

// named mutex used to update historical speed/time information in the registry.
const TCHAR IU_MUTEX_HISTORICALSPEED_REGUPDATE[] = _T("{5f3255a9-9051-49b1-80b9-aac31c092af4}");
const TCHAR IU_READMORE_LINK_NAME[] = _T("ReadMore.url");
const CHAR  SZ_DOWNLOAD_FINISHED[] = "Download finished";

const LONG     UPDATE_COMMAND                    = 0x0000000F;

typedef struct IUDOWNLOADSTARTUPINFO
{
    BSTR bstrClientName;
    BSTR bstrXmlCatalog;
    BSTR bstrDestinationFolder;
    LONG lMode;
    IUnknown *punkProgressListener;
    HWND hwnd;
    BSTR bstrUuidOperation;
	CEngUpdate* pEngUpdate;
} IUDOWNLOADSTARTUPINFO, *PIUDOWNLOADSTARTUPINFO;


// --------------------------------------------------------------------
// function forward declarations
// --------------------------------------------------------------------

//
// Callback function to provide status from the downloader
//
BOOL WINAPI DownloadCallback(VOID* pCallbackData, DWORD dwStatus, DWORD dwBytesTotal, DWORD dwBytesComplete, BSTR bstrXmlData, LONG* plCommandRequest);

//
// thread function used by DownloadAsync
// 
DWORD WINAPI DownloadThreadProc(LPVOID lpv);

/////////////////////////////////////////////////////////////////////////////
// CreateReadMoreLink()
//
// If the item contains a "description/descriptionText/details" node, suck
// out the URL and create a shortcut for it in the destination folder
//
// Input:
// pxmlCatalog          - CXmlCatalog containing downloaded items
// hItem                - Handle to current download item in the catalog
// pszDestinationFolder - Folder where item is downloaded
//
// Return:
//  S_OK    - Wrote the ReadMore.htm link
//  S_FALSE - details node didn't exist in item
//  <other> - HRESULT returned from calling other functions
/////////////////////////////////////////////////////////////////////////////
HRESULT CreateReadMoreLink(CXmlCatalog* pxmlCatalog, HANDLE_NODE hItem, LPCTSTR pszDestinationFolder)
{
    USES_IU_CONVERSION;

    LOG_Block("CreateReadMoreLink");

    IXMLDOMNode*                pItemNode = NULL;
    IXMLDOMNode*                pReadMoreNode = NULL;
    IUniformResourceLocator*    purl = NULL;
    IPersistFile*               ppf = NULL;
    HRESULT                     hr;
    TCHAR                       szShortcut[MAX_PATH];
    BSTR                        bstrURL = NULL;

    if (NULL == pxmlCatalog || HANDLE_NODE_INVALID == hItem || NULL == pszDestinationFolder)
    {
        CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
    }

    //
    // Get <item> node in catalog
    //
    if (NULL == (pItemNode = pxmlCatalog->GetDOMNodebyHandle(hItem)))
    {
        CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
    }
    //
    // Get node containing ReadMore URL, or S_FALSE if it doesn't exist
    //
    hr = pItemNode->selectSingleNode(KEY_READMORE, &pReadMoreNode);
    if (S_OK != hr)
    {
        if (S_FALSE != hr)
        {
            LOG_ErrorMsg(hr);
        }
        goto CleanUp;
    }

    //
    // suck out the href attribute
    //
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pReadMoreNode, KEY_HREF, &bstrURL));

    // Get pointers to the IID_IUniformResourceLocator and IID_IPersistFile interfaces
    // on the CLSID_InternetShortcut object
    CleanUpIfFailedAndSetHrMsg(CoCreateInstance(CLSID_InternetShortcut, \
                                    NULL,                               \
                                    CLSCTX_INPROC_SERVER,               \
                                    IID_IUniformResourceLocator,        \
                                    (LPVOID*)&purl));

    CleanUpIfFailedAndSetHrMsg(purl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf));
    
    // We want to check the URL we got from the Manifest Data to make sure it is a HTTP URL, not some local file spec
    URL_COMPONENTS UrlComponents;
    // Break down the URL to get the Protocol Used
    //  Specifically we need the server name, object to download, username and 
    //  password information.
    TCHAR       szScheme[32];
    szScheme[0] = _T('\0');
    
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszScheme       = szScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(szScheme);

    if (!InternetCrackUrl(OLE2T(bstrURL), 0, 0, &UrlComponents))
    {
        LOG_ErrorMsg(HRESULT_FROM_WIN32(GetLastError()));
        goto CleanUp;
    }

    if (szScheme[0] == _T('\0') || (0 != lstrcmpi(szScheme, _T("http")) && 0 != lstrcmpi(szScheme, _T("https"))))
    {
        // If the Scheme was undeterminable, or the scheme is not HTTP then we shouldn't trust this URL.
        LOG_ErrorMsg(E_UNEXPECTED);
        goto CleanUp;
    }
    
    //
    // Set the URL, form the shortcut path, and write the link
    //
    CleanUpIfFailedAndSetHrMsg(purl->SetURL(OLE2T(bstrURL), 0));

    hr = StringCchCopyEx(szShortcut, ARRAYSIZE(szShortcut), pszDestinationFolder, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

    hr = PathCchAppend(szShortcut, ARRAYSIZE(szShortcut), IU_READMORE_LINK_NAME);
    CleanUpIfFailedAndSetHrMsg(hr);

    CleanUpIfFailedAndSetHrMsg(ppf->Save(T2OLE(szShortcut), FALSE));

CleanUp:

    SysFreeString(bstrURL);
    // pItemNode is owned by CXmlCatalog, don't release
    SafeReleaseNULL(pReadMoreNode);
    SafeReleaseNULL(ppf);
    SafeReleaseNULL(purl);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CreateItemDependencyList()
//
// If the item contains a "dependencies" node, we want to walk
// the dependendant Item List and list the proper order that installs should
// be done in. If a dependant Item is not available in the current catalog it
// will be ignored.
//
// Input:
// pxmlCatalog          - CXmlCatalog containing downloaded items
// hItem                - Handle to current download item in the catalog
// pszDestinationFolder - Folder where item is downloaded
//
// Return:
//  S_OK    - Dependency List Written
//  S_FALSE - No Dependencies Available
//  <other> - HRESULT returned from calling other functions
/////////////////////////////////////////////////////////////////////////////
HRESULT CreateItemDependencyList(CXmlCatalog* pxmlCatalog, HANDLE_NODE hItem, LPCTSTR pszDestinationFolder)
{
    HRESULT hr = S_FALSE;

    HANDLE_NODE hDependentItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hDependentItem = HANDLE_NODE_INVALID;
    int iDependentItemOrder = 1;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesWritten;
    TCHAR szFileName[MAX_PATH];
    char szWriteBuffer[MAX_PATH + 12]; // max_path is the safe length for the identitystr plus room for the order information
    BSTR bstrIdentityStr = NULL;
    BOOL fWroteItem = FALSE;
    
    USES_IU_CONVERSION;
    
    hDependentItemList = pxmlCatalog->GetFirstItemDependency(hItem, &hDependentItem);
    if (HANDLE_NODELIST_INVALID != hDependentItemList)
    {
        hr = PathCchCombine(szFileName, ARRAYSIZE(szFileName), pszDestinationFolder, _T("order.txt"));
        if (FAILED(hr))
        {
            pxmlCatalog->CloseItem(hDependentItem);
            pxmlCatalog->CloseItemList(hDependentItemList);
            return hr;
        }
        
        hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            pxmlCatalog->CloseItem(hDependentItem);
            pxmlCatalog->CloseItemList(hDependentItemList);
            return hr;
        }

        hr = S_OK;
        while (hr == S_OK)
        {
            if (HANDLE_NODELIST_INVALID != hDependentItem)
            {
                pxmlCatalog->GetIdentityStr(hDependentItem, &bstrIdentityStr);

                hr = StringCchPrintfExA(szWriteBuffer, ARRAYSIZE(szWriteBuffer), NULL, NULL, MISTSAFE_STRING_FLAGS,
                                        "%d = %s\r\n", iDependentItemOrder, OLE2A(bstrIdentityStr));
                if (FAILED(hr))
                {
                    SafeSysFreeString(bstrIdentityStr);
                    pxmlCatalog->CloseItem(hDependentItem);
                    pxmlCatalog->CloseItemList(hDependentItemList);
                    return hr;
                }
                
                WriteFile(hFile, szWriteBuffer, lstrlenA(szWriteBuffer), &dwBytesWritten, NULL); 
                iDependentItemOrder++;

                SafeSysFreeString(bstrIdentityStr);
                pxmlCatalog->CloseItem(hDependentItem);
                fWroteItem = TRUE;
            }
            hr = pxmlCatalog->GetNextItemDependency(hDependentItemList, &hDependentItem);
        }

        pxmlCatalog->CloseItemList(hDependentItemList);
        CloseHandle(hFile);
        if (!fWroteItem)
            DeleteFile(szFileName); // no dependencies written

        if (SUCCEEDED(hr))
            hr = S_OK; // convert S_FALSE to S_OK, we successfully wrote the dependencylist
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// _Download()
//
// Do synchronous downloading.
// Input:
// bstrClientName - the name of the client, for history logging use
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - bitmask indicates throttled/foreground and notification options
// punkProgressListener - the callback function pointer for reporting download progress
// hWnd - the event msg window handler passed from the stub
// Output:
// pbstrXmlItems - the items with download status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT _Download(BSTR bstrClientName, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
                        IUnknown *punkProgressListener, HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrXmlItems,
						CEngUpdate* pEngUpdate)
{
    LOG_Block("Download()");

    HRESULT     hr = S_OK;
    HRESULT     hrGlobalItemFailure = S_OK;
    LPTSTR      lpszClientInfo = NULL;
    TCHAR       szBaseDestinationFolder[MAX_PATH];
    TCHAR       szDestinationFolder[MAX_PATH];
    TCHAR       szItemPath[MAX_PATH];
    LPTSTR      pszCabUrl = NULL;
    HANDLE_NODE hCatalogItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hProviderList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hProvider = HANDLE_NODE_INVALID;
    HANDLE_NODE hXmlItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hItemCabList = HANDLE_NODELIST_INVALID;
    BSTR        bstrCabUrl = NULL;
    BSTR        bstrLocalFileName = NULL;
    BSTR        bstrProviderName = NULL;
    BSTR        bstrProviderPublisher = NULL;
    BSTR        bstrProviderUUID = NULL;
    BSTR        bstrProviderIdentityStr = NULL;
    BSTR        bstrItemPath = NULL;
    BSTR        bstrInstallerType = NULL;
    BSTR        bstrLanguage = NULL;
    BSTR        bstrPlatformDir = NULL;
    BSTR        bstrTemp = NULL;
    BSTR        bstrCRC = NULL;
    BOOL        fCabPatchAvail;
    BOOL        fReboot;
    BOOL        fExclusive;
    LONG        lCommandCount;
    LONG        lCabSize = 0;
    LPTSTR      pszLocalFileName = NULL;
    LPTSTR      pszAllocatedFileName = NULL;
    BOOL        fNTFSDriveAvailable = FALSE;
    TCHAR       szFileSystemType[12];
    TCHAR       szLargestFATDrive[4];
    int         iMaxNTFSDriveFreeSpace = 0;
    int         iMaxDriveFreeSpace = 0;
    BOOL        fCorpCase = FALSE;
    BOOL        fContinue = TRUE;   // for async mode
    BOOL        fUseSuppliedPath = FALSE;
    long        n;
    DWORD       dwBytesDownloaded = 0;
    DWORD       dwCount1, dwCount2, dwElapsedTime;
    DWORD       dwTotalElapsedTime = 0;
    DWORD       dwTotalBytesDownloaded = 0;
    DWORD       dwWaitResult;
    DWORD       dwHistoricalSpeed = 0;
    DWORD       dwHistoricalTime = 0;
    DWORD       dwSize;
    DWORD       dwRet;
    HKEY        hkeyIU = NULL;
    HANDLE      hMutex = NULL;
    DCB_DATA    CallbackData;

    {
        CXmlCatalog xmlCatalog;
        CXmlItems   xmlItemList;
		LPTSTR		ptszLivePingServerUrl = NULL;
		LPTSTR		ptszCorpPingServerUrl = NULL;
		DWORD		dwFlags = 0;

        // clear any previous cancel event
        ResetEvent(pEngUpdate->m_evtNeedToQuit);

        ZeroMemory(&CallbackData, sizeof(CallbackData));
		CallbackData.pOperationMgr = &pEngUpdate->m_OperationMgr;

        USES_IU_CONVERSION;

        CIUHistory  history;

        lpszClientInfo = OLE2T(bstrClientName);

		if (NULL != (ptszLivePingServerUrl = (LPTSTR)HeapAlloc(
														GetProcessHeap(),
														HEAP_ZERO_MEMORY,
														INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
		{
			if (FAILED(g_pUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Out(_T("failed to get live ping server URL"));
				SafeHeapFree(ptszLivePingServerUrl);
			}
		}
		else
		{
			LOG_Out(_T("failed to allocate memory for ptszLivePingServerUrl"));
		}

		if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(
														GetProcessHeap(),
														HEAP_ZERO_MEMORY,
														INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
		{
			if (FAILED(g_pUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Out(_T("failed to get corp WU ping server URL"));
				SafeHeapFree(ptszCorpPingServerUrl);
			}
		}
		else
		{
			LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
		}

		CUrlLog pingSvr(lpszClientInfo, ptszLivePingServerUrl, ptszCorpPingServerUrl); 

		SafeHeapFree(ptszLivePingServerUrl);
		SafeHeapFree(ptszCorpPingServerUrl);

		if (FAILED(hr = g_pUrlAgent->IsClientSpecifiedByPolicy(lpszClientInfo)))
		{
            LOG_ErrorMsg(hr);
            goto CleanUp;
		}

		//
		// Set the flags for use by DownloadFile
		//
		if (S_FALSE == hr)
		{
			dwFlags = 0;
			hr = S_OK;
		}
		else // S_OK
		{
			dwFlags = WUDF_DONTALLOWPROXY;
			LOG_Internet(_T("WUDF_DONTALLOWPROXY set"));
		}

        pszCabUrl = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
        if (NULL == pszCabUrl)
        {
            dwRet = GetLastError();
            hr = HRESULT_FROM_WIN32(dwRet);
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

 
        CallbackData.bstrOperationUuid = (NULL == bstrUuidOperation) ? NULL : SysAllocString(bstrUuidOperation);
        CallbackData.hEventFiringWnd = hWnd;
        if (NULL != punkProgressListener)
        {
            // get the IProgressListener interface pointer from the IUnknown pointer.. If the 
            // interface is not supported the pProgressListener is set to NULL
            punkProgressListener->QueryInterface(IID_IProgressListener, (void**)&CallbackData.pProgressListener);
        }
        else
        {
            CallbackData.pProgressListener = NULL;
        }

        // Check for Corporate Download Handling Mode
        if ((DWORD) lMode & (DWORD) UPDATE_CORPORATE_MODE)
        {
            fCorpCase = TRUE;
        }

        // Check for Progress Notification Requested Mode
        if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_10PCT)
        {
            CallbackData.flProgressPercentage = (float).10;
        }
        else if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_5PCT)
        {
            CallbackData.flProgressPercentage = (float).05;
        }
        else if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_1PCT)
        {
            CallbackData.flProgressPercentage = (float).01;
        }
        else if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_COMPLETEONLY)
        {
            CallbackData.flProgressPercentage = (float) 1;
        }
        else
        {
            CallbackData.flProgressPercentage = 0;
        }

        if (NULL != bstrDestinationFolder && 0 < SysStringLen(bstrDestinationFolder))
        {
            if (SysStringLen(bstrDestinationFolder) > MAX_CORPORATE_PATH)
            {
                hr = E_INVALIDARG;
                LOG_ErrorMsg(hr);
                LogMessage("Catalog Download Path Greater Than (%d)", MAX_CORPORATE_PATH);
                goto CleanUp;
            }

            // Caller specified a Base Path - Set this Flag so we don't create our temp folder
            // structure under this path.
            fUseSuppliedPath = TRUE;

            //
            // user passed in a designated path, this is to signal the 
            // download-no-install case, usually for corporate site
            //

            hr = StringCchCopyEx(szBaseDestinationFolder, 
                                 ARRAYSIZE(szBaseDestinationFolder), 
                                 OLE2T(bstrDestinationFolder),
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
            
            //
            // verify that we have write access to this folder
            // --- most likely it's a UNC path
            //
            DWORD dwErr = ValidateFolder(szBaseDestinationFolder, TRUE);
            if (ERROR_SUCCESS != dwErr)
            {
                LOG_ErrorMsg(dwErr);
                goto CleanUp;
            }

            //
            // Find out if this Path is a UNC
            //
            if ('\\' == szBaseDestinationFolder[0] && '\\' == szBaseDestinationFolder[1])
            {
                // correct the path to the UNC to get the available space
                hr = StringCchCopyEx(szDestinationFolder, ARRAYSIZE(szDestinationFolder),
                                     szBaseDestinationFolder, 
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                LPTSTR pszWalk = szDestinationFolder;
                pszWalk += 2; // skip the double slash
                pszWalk = StrChr(pszWalk, '\\'); // find the next slash (separate machine and share name)
                pszWalk += 1;
                pszWalk = StrChr(pszWalk, '\\'); // try to find the next slash (end of share name)
                if (NULL == pszWalk)
                {
                    // no trailing slash and no further path information
                    hr = PathCchAddBackslash(szDestinationFolder, ARRAYSIZE(szBaseDestinationFolder));
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        goto CleanUp;
                   }
                }
                else
                {
                    // this path has a trailing slash (may have more path information, truncate after the slash)
                    pszWalk += 1;
                    *pszWalk = '\0';
                }
                GetFreeDiskSpace(szDestinationFolder, &iMaxDriveFreeSpace);
            }
            else
            {
                // path must be a local drive
                GetFreeDiskSpace(szBaseDestinationFolder[0], &iMaxDriveFreeSpace);
            }
        }
        else
        {
            //
            // user passed in NULL as the destination folder, 
            // it means this is the normal case to download and install
            // updates for this machine. we will try to find the 
            // drive with the most free space
            //
            TCHAR szDriveList[MAX_PATH];
            GetLogicalDriveStrings(MAX_PATH, szDriveList);
            LPTSTR pszCurrent = szDriveList;
            int iSize;

            //
            // find the local fixed drive with the 'most' free space
            //
            while (NULL != pszCurrent && *pszCurrent != _T('\0'))
            {
                fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                if (DRIVE_FIXED == GetDriveType(pszCurrent))
                {
                    hr = GetFreeDiskSpace(*pszCurrent, &iSize);
                    if (FAILED(hr))
                    {
                        LOG_Error(_T("Error Reading Drive Space %c, hr = 0x%08x"), *pszCurrent, hr);
                        pszCurrent += (lstrlen(pszCurrent) + 1);    // skip current and null terminater
                        continue;
                    }

                    if (!GetVolumeInformation(pszCurrent, NULL, 0, NULL, NULL, NULL, szFileSystemType, ARRAYSIZE(szFileSystemType)))
                    {
                        DWORD dwErr = GetLastError();
                        LOG_Error(_T("Error Reading VolumeInfo for Drive %c, GLE = %d"), *pszCurrent, dwErr);
                        pszCurrent += (lstrlen(pszCurrent) + 1);    // skip current and null terminater
                        continue;
                    }
                    if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						szFileSystemType, -1, _T("NTFS"), -1))
                    {
                        fNTFSDriveAvailable = TRUE;
                        if (iSize > iMaxNTFSDriveFreeSpace)
                        {
                            iMaxNTFSDriveFreeSpace = iSize;
                            hr = StringCchCopyEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), pszCurrent,
                                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
                            if (FAILED(hr))
                            {
                                LOG_ErrorMsg(hr);
                                continue;
                            }
                        }
                    }
                    else
                    {
                        // we want to keep track of non NTFS drive sizes in case there the largest
                        // NTFS drive size is too small, but a FAT partition has enough space. In this
                        // case we want to fall back to the FAT partition. Note: this is a behavior change
                        // from the initial design where we treated NTFS and FAT as mutually exclusive with
                        // NTFS always winning.
                        if (iSize > iMaxDriveFreeSpace)
                        {
                            iMaxDriveFreeSpace = iSize;
                            if (!fNTFSDriveAvailable)
                            {
                                // if no NTFS drive is available save this drive letter as the preferred
                                hr = StringCchCopyEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), pszCurrent,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                                if (FAILED(hr))
                                {
                                    LOG_ErrorMsg(hr);
                                    continue;
                                }

                                hr = StringCchCopyEx(szLargestFATDrive, ARRAYSIZE(szLargestFATDrive), pszCurrent,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                                if (FAILED(hr))
                                {
                                    LOG_ErrorMsg(hr);
                                    continue;
                                }
                                
                            }
                            else
                            {
                                // NTFS drive exists, save this drive as a back up choice for the size check.
                                hr = StringCchCopyEx(szLargestFATDrive, ARRAYSIZE(szLargestFATDrive), pszCurrent,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                                if (FAILED(hr))
                                {
                                    LOG_ErrorMsg(hr);
                                    continue;
                                }
                            }
                        }
                    }
                }
                pszCurrent += (lstrlen(pszCurrent) + 1);    // skip current and null terminater
            }

            if (!fContinue)
            {
                hr = E_UNEXPECTED;
                goto CleanUp;
            }

            if ((0 == iMaxDriveFreeSpace) && (0 == iMaxNTFSDriveFreeSpace))
            {
                //
                // running on a system with no local drives?
                //
                hr = E_FAIL;
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
        }

        //
        // load the XML document into the XmlCatalog Class
        //
        if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
        {
            hr = E_ABORT;
            goto CleanUp;
        }

        hr = xmlCatalog.LoadXMLDocument(bstrXmlCatalog, pEngUpdate->m_fOfflineMode);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        // We need to find the total estimated size of the download we're about to do.
        // We'll walk the XML Catalog getting Size Info for each item.
        hr = xmlCatalog.GetTotalEstimatedSize(&CallbackData.lTotalDownloadSize);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        CallbackData.lTotalDownloaded = 0;

        //
        // added by JHou - bug#314: download does not detect available free space on local hard drive
        //
        // The lTotalDownloadSize is the size of the download in Bytes, the MaxDriveSpace is in KBytes
        if ((CallbackData.lTotalDownloadSize / 1024) > ((fNTFSDriveAvailable) ? iMaxNTFSDriveFreeSpace : iMaxDriveFreeSpace))
        {
            // Before we bail out of the download we need to look to see if we excluded a chose a NTFS drive
            // over a FAT drive. If the NTFS drive doesn't have enough space, but a FAT drive does we want to 
            // go ahead and allow the use of the FAT drive. This is a change in spec'd behavior per bug: 413079
            if ((CallbackData.lTotalDownloadSize / 1024) < iMaxDriveFreeSpace)
            {
                // no error.. a FAT partition has enough free space, use it instead
                hr = StringCchCopyEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), szLargestFATDrive,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
            }
            else
            {
                // tried both NTFS and FAT partitions.. none have enough space.. bail out.
                dwRet = ERROR_DISK_FULL;
                LOG_ErrorMsg(dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                // need to write items result information for each item indicating it failed because of diskspace
                hrGlobalItemFailure = HRESULT_FROM_WIN32(dwRet);
            }
        }

        if (SUCCEEDED(hrGlobalItemFailure))
        {
            if (!fUseSuppliedPath)
            {
                // When a destination folder is specified, we don't need to add anything to it. If no path
                // is specified we pick a drive letter, so we need to add the WUTemp directory
                // to that base path.
                hr = StringCchCatEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), IU_WUTEMP,
                                    NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
            }
			//
			// 500953 Allow Power Users to access WUTEMP
			//
			DWORD dwAttr = GetFileAttributes(szBaseDestinationFolder);
			if (INVALID_FILE_ATTRIBUTES == dwAttr || 0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttr))
			{
				//
				// Only create directory if it doesn't already exist (Power Users can't
				// SetFileAttributes if an administrator created the directory originally).
				//
				if (FAILED(hr = CreateDirectoryAndSetACLs(szBaseDestinationFolder, TRUE)))
				{
					LOG_ErrorMsg(hr);
					hrGlobalItemFailure = hr;
				}
				if (!fUseSuppliedPath &&
					!SetFileAttributes(szBaseDestinationFolder, FILE_ATTRIBUTE_HIDDEN))
				{
					DWORD dwErr = GetLastError();
					LOG_ErrorMsg(dwErr);
					hr = HRESULT_FROM_WIN32(dwErr);
					hrGlobalItemFailure = HRESULT_FROM_WIN32(dwRet);
				}
			}

#if defined(UNICODE) || defined(_UNICODE)
            LogMessage("Download destination root folder is: %ls", szBaseDestinationFolder);
#else
            LogMessage("Download destination root folder is: %s", szBaseDestinationFolder);
#endif
       
            if (fCorpCase)
            {
                history.SetDownloadBasePath(szBaseDestinationFolder);
            }
        }

        //
        // loop through each provider in the catalog, then each item in the provider
        //
        if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
        {
            hr = E_ABORT;
            goto CleanUp;
        }

        hProviderList = xmlCatalog.GetFirstProvider(&hProvider);
        while (fContinue && HANDLE_NODE_INVALID != hProvider)
        {
            xmlCatalog.GetIdentity(hProvider, &bstrProviderName, &bstrProviderPublisher, &bstrProviderUUID);

            xmlCatalog.GetIdentityStr(hProvider, &bstrProviderIdentityStr);

            //
            // Get the Enumerator List of Items in this Provider, and get the first item
            //
            hCatalogItemList = xmlCatalog.GetFirstItem(hProvider, &hItem);
            if ((HANDLE_NODELIST_INVALID == hCatalogItemList) || (HANDLE_NODE_INVALID == hItem))
            {
                // No Items under this Provider
                xmlCatalog.GetNextProvider(hProviderList, &hProvider);
                continue;
            }
            while (fContinue && HANDLE_NODE_INVALID != hItem)
            {
                if (FAILED(hrGlobalItemFailure))
                {
                    xmlItemList.AddItem(&xmlCatalog, hItem, &hXmlItem);
                    bstrTemp = T2BSTR(_T(""));
                    xmlItemList.AddDownloadPath(hXmlItem, bstrTemp);
                    SafeSysFreeString(bstrTemp);
                    history.AddHistoryItemDownloadStatus(&xmlCatalog, hItem, HISTORY_STATUS_FAILED, /*no download path*/_T(""), lpszClientInfo, hrGlobalItemFailure);
                    xmlItemList.AddDownloadStatus(hXmlItem, KEY_STATUS_FAILED, hrGlobalItemFailure);
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                    continue;
                }
                LONG lCallbackRequest = 0;  // check if user set something in callback

                xmlCatalog.GetIdentityStr(hItem, &bstrItemPath);
                if (NULL == bstrItemPath)
                {
                    LOG_Download(_T("Failed to Get Identity String for an Item"));
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                    continue;
                }

                //
                // send out status to caller to tell which item we are about to download
                //
                BSTR bstrXmlItemForCallback = NULL;
                if (SUCCEEDED(xmlCatalog.GetBSTRItemForCallback(hItem, &bstrXmlItemForCallback)))
                {
                    CallbackData.lCurrentItemSize = 0;
                    DownloadCallback(&CallbackData, 
                                     DOWNLOAD_STATUS_ITEMSTART, 
                                     0,
                                     0, 
                                     bstrXmlItemForCallback, 
                                     &lCallbackRequest);
                    SafeSysFreeString(bstrXmlItemForCallback);
                    bstrXmlItemForCallback = NULL;
                    if (UPDATE_COMMAND_CANCEL == lCallbackRequest)
                    {
						LOG_Out(_T("Download Callback received UPDATE_COMMAND_CANCEL"));
                        SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
                        fContinue = FALSE;
                    }
                    else
                    {
                        //
                        // check the global quit event. If quit, then server ping treat it as a cancel.
                        //
                        fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                    }
                    if (!fContinue)
                    {
                        continue;   // or break, same effect.
                    }
                }
                else
                {
                    //
                    // something wrong with this item, so we should skip it
                    //
                    continue;
                }

                if (fCorpCase)
                {
                    LPCTSTR szName = NULL;
                    
                    // Corporate Folder Path is Constructed from Several Item Elements
                    // Software | Driver\<Locale>\<ProviderIdentity>\<Platform>\<ItemIdentity>.<version>
                    xmlCatalog.GetItemInstallInfo(hItem, &bstrInstallerType, &fExclusive, &fReboot, &lCommandCount);
                    if (NULL == bstrInstallerType)
                    {
                        LOG_Download(_T("Missing InstallerType Info for Item %ls"), bstrItemPath);
                        goto doneCorpCase;
                    }

                    if (CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						(LPCWSTR)bstrInstallerType, -1, L"CDM", -1))
                    {
                        szName = _T("Driver");
                    }
                    else
                    {
                        szName = _T("Software");
                    }

                    hr = StringCchCopyEx(szItemPath, ARRAYSIZE(szItemPath), szName, NULL, NULL, MISTSAFE_STRING_FLAGS);
                    if (FAILED(hr))
                        goto doneCorpCase;

                    xmlCatalog.GetItemLanguage(hItem, &bstrLanguage);
                    xmlCatalog.GetCorpItemPlatformStr(hItem, &bstrPlatformDir);
                    if (NULL == bstrLanguage || NULL == bstrPlatformDir)
                    {
                        LOG_Download(_T("Missing Language or Platform Info for Item %ls"), bstrItemPath);
                        goto doneCorpCase;
                    }
                
                    hr = PathCchCombine(szDestinationFolder, ARRAYSIZE(szDestinationFolder), szBaseDestinationFolder, szItemPath);
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrLanguage));
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrProviderIdentityStr));
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrPlatformDir));
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrItemPath));
                    if (FAILED(hr))
                        goto doneCorpCase;
doneCorpCase:
                    SafeSysFreeString(bstrInstallerType);
                    SafeSysFreeString(bstrLanguage);
                    SafeSysFreeString(bstrPlatformDir);
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        SafeSysFreeString(bstrItemPath);
                        xmlCatalog.CloseItem(hItem);
                        xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                        continue;
                    }
                }
                else
                {
                    hr = PathCchCombine(szDestinationFolder, ARRAYSIZE(szDestinationFolder), szBaseDestinationFolder, OLE2T(bstrItemPath));
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        SafeSysFreeString(bstrItemPath);
                        xmlCatalog.CloseItem(hItem);
                        xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                        continue;
                    }
                }

                if (FAILED(hr = CreateDirectoryAndSetACLs(szDestinationFolder, TRUE)))
				{
					LOG_ErrorMsg(hr);
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
					SafeSysFreeString(bstrItemPath);
					continue;
				}

                //
                // Now get the collection of CodeBases for this Item
                //
                hItemCabList = xmlCatalog.GetItemFirstCodeBase(hItem, &bstrCabUrl, &bstrLocalFileName, &bstrCRC, &fCabPatchAvail, &lCabSize);
                if ((HANDLE_NODELIST_INVALID == hItemCabList) || (NULL == bstrCabUrl))
                {
                    // No Cabs for this Item?? skip it.
                    LOG_Download(_T("Item: %ls has no cabs, Skipping"), bstrItemPath);
                    SafeSysFreeString(bstrItemPath);
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                    continue;
                }

                while (fContinue && NULL != bstrCabUrl)
                {
                    LPTSTR pszTempCabUrl = OLE2T(bstrCabUrl);

                    // pszCabUrl is allocated to be INTERNET_MAX_URL_LENGTH above.
                    hr = StringCchCopyEx(pszCabUrl, INTERNET_MAX_URL_LENGTH, pszTempCabUrl, 
                                         NULL, NULL, MISTSAFE_STRING_FLAGS);
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        break;
                    }
                 
                    SafeMemFree(pszTempCabUrl);
                    
                    if (NULL != bstrLocalFileName && SysStringLen(bstrLocalFileName) > 0)
                    {
                        if (NULL != pszAllocatedFileName)
                        {
                            MemFree(pszAllocatedFileName);
                        }
                        pszAllocatedFileName = OLE2T(bstrLocalFileName);
                    }
                    else
                    {
                        //
                        // has not specified file name, use the same file name in URL
                        //
                        // search for the last forward slash (will separate the URL from the filename)
                        LPTSTR lpszLastSlash = StrRChr(pszCabUrl, NULL, _T('/'));
                        if (NULL != lpszLastSlash)
                        {
                            // last slash was found, skip to next character (will be the beginning of the filename)
                            lpszLastSlash++;
                        }
                        pszLocalFileName = lpszLastSlash;
                    }
                    // Download the Cab - Store Information for Progress Callbacks

                    dwBytesDownloaded = 0;
                    CallbackData.lCurrentItemSize = lCabSize;
                    dwCount1 = GetTickCount();
                    hr = DownloadFile(pszCabUrl, // fileurl to download
                                      szDestinationFolder, // destination folder for file
                                      (NULL != pszAllocatedFileName) ? pszAllocatedFileName : pszLocalFileName, // use AllocatedFileName if possible, else use localfilename
                                      &dwBytesDownloaded, // bytes downloaded for this file
                                      &pEngUpdate->m_evtNeedToQuit,  // quit event array
                                      1,  // number of events
                                      DownloadCallback, // callback function
                                      &CallbackData, // data structure for callback function
                                      dwFlags);
                    if (FAILED(hr))
                    {
                        //
                        // added by JHou: bug335292 - Temporary folder not deleted when network plug removed
                        //
                        // only empty folder can be deleted successfully so if RemoveDirectory() failed that
                        // may because it's not empty which means it's ok
                        if (RemoveDirectory(szDestinationFolder) && fCorpCase)
                        {
                            HRESULT hrCopy;
                            // If this Directory was successfully removed and this is the Corp Case we should
                            // try to remove its parents up to the base directory.
                            TCHAR szCorpDestinationFolderRemove[MAX_PATH];
                            
                            hrCopy = StringCchCopyEx(szCorpDestinationFolderRemove,
                                                     ARRAYSIZE(szCorpDestinationFolderRemove),
                                                     szDestinationFolder,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                            if (FAILED(hrCopy))
                            {
                                LOG_ErrorMsg(hrCopy);
                                break;
                            }
                            
                            LPTSTR pszBackslash = NULL;
                            PathRemoveBackslash(szBaseDestinationFolder); // strip any trailing backslashes - need to normalize this to compare when we're done walking the folder tree
                            for (;;)
                            {
                                pszBackslash = StrRChr(szCorpDestinationFolderRemove, NULL, '\\');
                                if (NULL == pszBackslash)
                                    break; // unexpected
                                *pszBackslash = '\0';
                                if (0 == StrCmp(szCorpDestinationFolderRemove, szBaseDestinationFolder))
                                    break; // reached the base directory, done removing directories;
                                if (!RemoveDirectory(szCorpDestinationFolderRemove))
                                    break; // couldn't remove folder at this level, assume folder not empty, leave the rest of the structure intact.
                            }
                        }

                        if (E_ABORT == hr)
                        {
                            LOG_Download(_T("DownloadFile function returns E_ABORT while downloading %s."), pszCabUrl);
#if defined(UNICODE) || defined(_UNICODE)
                            LogError(hr, "Download cancelled while processing file %ls", pszCabUrl);
#else
                            LogError(hr, "Download cancelled while processing file %s", pszCabUrl);
#endif
                        }
                        else
                        {
                            LOG_Download(_T("Download Failed for URL: %s, Skipping remaining files for this Item"), pszCabUrl);
#if defined(UNICODE) || defined(_UNICODE)
                            LogError(hr, "Downloading file %ls, skipping remaining files for this Item", pszCabUrl);
#else
                            LogError(hr, "Downloading file %s, skipping remaining files for this Item", pszCabUrl);
#endif
                        }
                        SafeSysFreeString(bstrCabUrl);
                        //
                        // since one file got error, we can exit the file loop for the current item
                        // because missing one file will make this item not usable.
                        //
                        break;  
                    }
                    dwCount2 = GetTickCount();
                    if (0 != dwBytesDownloaded)
                    {
                        if (dwCount1 < dwCount2) // normal case, no roll-over
                        {
                            dwElapsedTime = dwCount2 - dwCount1;
                        }
                        else
                        {
                            // roll-over case, should almost never happen
                            dwElapsedTime = (0xFFFFFFFF - dwCount1) + dwCount2;
                        }

                        dwTotalBytesDownloaded += dwBytesDownloaded;
                        dwTotalElapsedTime += dwElapsedTime;
                    }

                    // Form the full Path and Filename of the file we just downloaded
                    hr = PathCchCombine(szItemPath, ARRAYSIZE(szItemPath), szDestinationFolder, 
                                                     (NULL != pszAllocatedFileName) ? pszAllocatedFileName : pszLocalFileName);
                    if (FAILED(hr))
                    {
                        DeleteFile(szItemPath);
                        break;
                    }
                    
                    // Verify CRC
                    //---------------
                    if (NULL != bstrCRC)
                    {
                        TCHAR szCRCHash[CRC_HASH_STRING_LENGTH] = {'\0'};
                        hr = StringCchCopyEx(szCRCHash, ARRAYSIZE(szCRCHash), OLE2T(bstrCRC), NULL, NULL, MISTSAFE_STRING_FLAGS);
                        if (FAILED(hr))
                        {
                            // Something was wrong with the BSTR we got back from XML. Fail Safely, delete the file.
                            // The Failed HR will fail the item
                            DeleteFile(szItemPath);
                            break;
                        }
                        hr = VerifyFileCRC(szItemPath, szCRCHash);
                        if (HRESULT_FROM_WIN32(ERROR_CRC) == hr || FAILED(hr))
                        {
                            // The File CRC's Did Not Match, or we had a problem Calculating the CRC. Fail Safely, delete the file.
                            // The Failed HR will fail the item
                            DeleteFile(szItemPath);
                            break;
                        }
                    }

                    // Check Trust
                    //---------------
                    hr = VerifyFileTrust(szItemPath, 
                                         NULL, 
                                         ReadWUPolicyShowTrustUI()
                                         );
                    if (FAILED(hr))
                    {
                        // File Was Not Trusted - Need to Delete it and fail the item
                        DeleteFile(szItemPath);
                        break;
                    }

#if defined(UNICODE) || defined(_UNICODE)
                    LogMessage("Downloaded file %ls", pszCabUrl);
                    LogMessage("Local path %ls", szItemPath);
#else
                    LogMessage("Downloaded file %s", pszCabUrl);
                    LogMessage("Local path %s", szItemPath);
#endif

                    SafeSysFreeString(bstrCabUrl);
                    SafeSysFreeString(bstrLocalFileName);
                    SafeSysFreeString(bstrCRC);
                    bstrCabUrl = bstrLocalFileName = NULL;
                    fContinue = SUCCEEDED(xmlCatalog.GetItemNextCodeBase(hItemCabList, &bstrCabUrl, &bstrLocalFileName, &bstrCRC, &fCabPatchAvail, &lCabSize)) &&
                                (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                }

 
                // Write XMLItems entry for this download result
                xmlItemList.AddItem(&xmlCatalog, hItem, &hXmlItem);
                bstrTemp = T2BSTR(szDestinationFolder);
                xmlItemList.AddDownloadPath(hXmlItem, bstrTemp);
                SafeSysFreeString(bstrTemp);

                //
                // For "corporate" download write ReadMore Link before writing history (in case we fail
                //
                if (TRUE == fCorpCase)
                {
                    //
                    // Ignore errors as we want to keep downloaded cab anyway
                    //
                    (void) CreateReadMoreLink(&xmlCatalog, hItem, szDestinationFolder);
                    (void) CreateItemDependencyList(&xmlCatalog, hItem, szDestinationFolder);
                }

                //
                // Also add download history for this item
                //
                if (SUCCEEDED(hr))
                {
                    history.AddHistoryItemDownloadStatus(&xmlCatalog, hItem, HISTORY_STATUS_COMPLETE, szDestinationFolder, lpszClientInfo);
                    xmlItemList.AddDownloadStatus(hXmlItem, KEY_STATUS_COMPLETE);
                }
                else
                {
                    history.AddHistoryItemDownloadStatus(&xmlCatalog, hItem, HISTORY_STATUS_FAILED, szDestinationFolder, lpszClientInfo, hr);
                    xmlItemList.AddDownloadStatus(hXmlItem, KEY_STATUS_FAILED, hr);
                }

                //
                // ping server to report the download status for this item
                //
                {
                    BSTR bstrIdentityPing = NULL;
                    if (SUCCEEDED(xmlCatalog.GetIdentityStrForPing(hItem, &bstrIdentityPing)))
                    {
						URLLOGSTATUS status = SUCCEEDED(hr) ? URLLOGSTATUS_Success : URLLOGSTATUS_Failed;
                        if (E_ABORT == hr)
                        {
                            //
                            // user/system cancelled the current process
                            //
							status = URLLOGSTATUS_Cancelled;
                        }
                        pingSvr.Ping(
									TRUE,						// on-line
									URLLOGDESTINATION_DEFAULT,	// going live or corp WU ping server
									&pEngUpdate->m_evtNeedToQuit,			// pt to cancel events
									1,							// number of events
									URLLOGACTIVITY_Download,	// activity
									status,						// status code
									hr,							// error code, can be 0 or 1
									OLE2T(bstrIdentityPing),	// itemID
									NULL						// no device data can be given during dld phase
									);
                    }

                    SafeSysFreeString(bstrIdentityPing);
                    //SafeSysFreeString(bstrPlatformPing);
                    //SafeSysFreeString(bstrLanguagePing);
                }

                xmlCatalog.CloseItemList(hItemCabList);

                //
                // done with this item, fire itemcomplete event
                //
                DownloadCallback(&CallbackData, DOWNLOAD_STATUS_ITEMCOMPLETE, CallbackData.lCurrentItemSize, 0, NULL, &lCallbackRequest);

                SafeSysFreeString(bstrItemPath);
                // get the next item. hItem will be HANDLE_NODE_INVALID when there are no
                // remaining items.
                xmlCatalog.CloseItem(hItem);
                xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                if (UPDATE_COMMAND_CANCEL == lCallbackRequest)
                {
					LOG_Out(_T("Download Callback received UPDATE_COMMAND_CANCEL"));
                    SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
                    fContinue = FALSE;
                }
                else
                {
                    //
                    // check the global quit event. If quit, then server ping treat it as a cancel.
                    // TODO: also need to check the operation quit event!
                    //
                    fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                }
            }

            xmlCatalog.CloseItemList(hCatalogItemList);

            SafeSysFreeString(bstrProviderName);
            SafeSysFreeString(bstrProviderPublisher);
            SafeSysFreeString(bstrProviderUUID);
            SafeSysFreeString(bstrProviderIdentityStr);
            xmlCatalog.CloseItem(hProvider);
            xmlCatalog.GetNextProvider(hProviderList, &hProvider);
            fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
        }

        xmlCatalog.CloseItemList(hProviderList);

        RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkeyIU);
        hMutex = CreateMutex(NULL, FALSE, IU_MUTEX_HISTORICALSPEED_REGUPDATE);


        if ((0 != dwTotalBytesDownloaded) && (0 != dwTotalElapsedTime) && (NULL != hkeyIU) && (NULL != hMutex))
        {
			HANDLE aHandles[2];

			aHandles[0] = hMutex;
			aHandles[1] = pEngUpdate->m_evtNeedToQuit;

            dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/30000, QS_ALLINPUT);
            if (WAIT_OBJECT_0 == dwWaitResult)
            {
                // convert elapsed time from milliseconds to seconds
                dwTotalElapsedTime = dwTotalElapsedTime / 1000;
                if (0 == dwTotalElapsedTime)
                    dwTotalElapsedTime = 1; // minimum one second

                // we have the mutex, go ahead and read/write the reg information.  
                dwSize = sizeof(dwHistoricalSpeed);
                RegQueryValueEx(hkeyIU, REGVAL_HISTORICALSPEED, NULL, NULL, (LPBYTE)&dwHistoricalSpeed, &dwSize);
                dwSize = sizeof(dwHistoricalTime);
                RegQueryValueEx(hkeyIU, REGVAL_TIMEELAPSED, NULL, NULL, (LPBYTE)&dwHistoricalTime, &dwSize);

                // We need to get the Bytes Downloaded to add the bytes just downloaded
                DWORD dwHistoricalBytes = dwHistoricalSpeed * dwHistoricalTime; // could be 0 if no previous history was recorded
                dwHistoricalBytes += dwTotalBytesDownloaded; // new byte count
                dwHistoricalTime += dwTotalElapsedTime; // new time count
                dwHistoricalSpeed = dwHistoricalBytes / dwHistoricalTime; // calculate new speed bytes/second
                RegSetValueEx(hkeyIU, REGVAL_HISTORICALSPEED, NULL, REG_DWORD, (LPBYTE)&dwHistoricalSpeed, sizeof(dwHistoricalSpeed));
                RegSetValueEx(hkeyIU, REGVAL_TIMEELAPSED, NULL, REG_DWORD, (LPBYTE)&dwHistoricalTime, sizeof(dwHistoricalTime));
                ReleaseMutex(hMutex);
                CloseHandle(hMutex);
                hMutex = NULL;
            }
        }

		//
		// We pass in pEngUpdate->m_evtNeedToQuit to MyMsgWaitForMultipleObjects above so it will exit immediately
		// but don't bother to handle the WAIT_OBJECT_0 + 1 case there since the if statement may not
		// execute and even if this is the case we still need to check pEngUpdate->m_evtNeedToQuit below anyway.
		//
        if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
        {
            hr = E_ABORT;
        }

CleanUp:

        //
        // add HRESULT in case the download failed before the download loop
        //
        if (S_OK != hr)
        {
            xmlItemList.AddGlobalErrorCodeIfNoItems(hr);
        }

        //
        // generate result
        //
        xmlItemList.GetItemsBSTR(pbstrXmlItems);

        SafeSysFreeString(CallbackData.bstrOperationUuid);
    
        SafeHeapFree(pszCabUrl);

        SafeSysFreeString(bstrCabUrl);
        SafeSysFreeString(bstrLocalFileName);
        SafeSysFreeString(bstrProviderName);
        SafeSysFreeString(bstrProviderPublisher);
        SafeSysFreeString(bstrProviderUUID);
        SafeSysFreeString(bstrProviderIdentityStr);
        SafeSysFreeString(bstrItemPath);
        SafeSysFreeString(bstrInstallerType);
        SafeSysFreeString(bstrLanguage);
        SafeSysFreeString(bstrPlatformDir);
        SafeSysFreeString(bstrTemp);

        if (NULL != hkeyIU)
        {
            RegCloseKey(hkeyIU);
            hkeyIU = NULL;
        }

        if (NULL != hMutex)
        {
            // shouldn't need to release, if hmutex is still valid at this point we were unable to 
            // get the mutex 
            CloseHandle(hMutex);
            hMutex = NULL;
        }
    }

    //
    // notify that we are completed
    //
    if (NULL != punkProgressListener || NULL != hWnd)
    {
        DownloadCallback(&CallbackData, DOWNLOAD_STATUS_OPERATIONCOMPLETE, 0, 0, *pbstrXmlItems, NULL); 
    }

    if (SUCCEEDED(hr))
    {
        LogMessage("%s %s", SZ_SEE_IUHIST, SZ_DOWNLOAD_FINISHED);
    }
    else
    {
        LogError(hr, "%s %s", SZ_SEE_IUHIST, SZ_DOWNLOAD_FINISHED);
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// Download()
//
// Do synchronous downloading.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - bitmask indicates throttled/foreground and notification options
// punkProgressListener - the callback function pointer for reporting download progress
// hWnd - the event msg window handler passed from the stub
// Output:
// pbstrXmlItems - the items with download status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::Download(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
                        IUnknown *punkProgressListener, HWND hWnd, BSTR *pbstrXmlItems)
{
    CXmlClientInfo clientInfo;
    BSTR bstrClientName = NULL;

    HRESULT hr;

    LOG_Block("Download()");

    LogMessage("Download started");

    hr = clientInfo.LoadXMLDocument(bstrXmlClientInfo, m_fOfflineMode);
    CleanUpIfFailedAndMsg(hr);

    hr = clientInfo.GetClientName(&bstrClientName);
    CleanUpIfFailedAndMsg(hr);

    hr = _Download(
                    bstrClientName, 
                    bstrXmlCatalog, 
                    bstrDestinationFolder, 
                    lMode, 
                    punkProgressListener, 
                    hWnd, 
                    NULL,                   // no op id needed for sync download
                    pbstrXmlItems,
					this);

CleanUp:

    SysFreeString(bstrClientName);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DownloadAsync()
//
// Download asynchronously -  the method will return before completion.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - indicates throttled or fore-ground downloading mode
// punkProgressListener - the callback function pointer for reporting download progress
// hWnd - the event msg window handler passed from the stub
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID,
//                      in which case, the caller will be responsible to free the memory of
//                      the string buffer that holds the generated UUID using SysFreeString(). 
//                      Otherwise, it returns the value passed by bstrUuidOperation.        
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::DownloadAsync(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
                             IUnknown *punkProgressListener, HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrUuidOperation)
{
    HRESULT  hr = S_OK;
    BSTR     bstrClientName = NULL;
    DWORD    dwThreadId = 0x0;
    DWORD    dwErr = 0x0;
    HANDLE   hThread = NULL;
    GUID     guid;
    LPWSTR   lpswClientInfo = NULL;
    LPOLESTR pwszUuidOperation = NULL;
    PIUDOWNLOADSTARTUPINFO pStartupInfo = NULL;
    HANDLE   hHeap = GetProcessHeap();
    CXmlClientInfo clientInfo;

    LOG_Block("DownloadAsync()");

    LogMessage("Asynchronous Download started");

    USES_IU_CONVERSION;

    //
    // validate parameters:
    //  if no catalog, or no return var, or no client info, this function can do nothing.
    //
    if ((NULL == bstrXmlCatalog) ||
        (NULL == bstrXmlClientInfo) ||
        (SysStringLen(bstrXmlCatalog) == 0) ||
        (SysStringLen(bstrXmlClientInfo) == 0))
    {
        hr = E_INVALIDARG;
        CleanUpIfFailedAndMsg(hr);
    }

    //
    // validate the client info
    //
    hr = clientInfo.LoadXMLDocument(bstrXmlClientInfo, m_fOfflineMode);
    CleanUpIfFailedAndMsg(hr);

    hr = clientInfo.GetClientName(&bstrClientName);
    CleanUpIfFailedAndMsg(hr);

    if (NULL == (pStartupInfo = (PIUDOWNLOADSTARTUPINFO) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(IUDOWNLOADSTARTUPINFO))))
    {
        hr = E_OUTOFMEMORY;
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    pStartupInfo->bstrClientName = SysAllocString(bstrClientName);
    pStartupInfo->bstrXmlCatalog = SysAllocString(bstrXmlCatalog);
    pStartupInfo->hwnd = hWnd;
    pStartupInfo->lMode = lMode;
    pStartupInfo->punkProgressListener = punkProgressListener;
	pStartupInfo->pEngUpdate = this;
    if (NULL != bstrDestinationFolder && SysStringLen(bstrDestinationFolder) > 0)
    {
        LOG_Download(_T("Caller specified destination folder=%s"), OLE2T(bstrDestinationFolder));
        pStartupInfo->bstrDestinationFolder = SysAllocString(bstrDestinationFolder);
    }

    //
    // session id is required for download operation
    //
    if (NULL != bstrUuidOperation && SysStringLen(bstrUuidOperation) > 0)
    {
        LOG_Download(_T("User passed in UUID %s"), OLE2T(bstrUuidOperation));
        pStartupInfo->bstrUuidOperation = SysAllocString(bstrUuidOperation);
        if (NULL != pbstrUuidOperation)
        {
            *pbstrUuidOperation = SysAllocString(bstrUuidOperation);
        }
    }
    else
    {
        //
        // if user doesn't have an operation id, we generate one
        //
        hr = CoCreateGuid(&guid);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        hr = StringFromCLSID(guid, &pwszUuidOperation);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        pStartupInfo->bstrUuidOperation = SysAllocString(pwszUuidOperation);
        if (NULL != pbstrUuidOperation)
        {
            *pbstrUuidOperation = SysAllocString(pwszUuidOperation);
        }
        LOG_Download(_T("UUID generated %s"), OLE2T(pwszUuidOperation));
        CoTaskMemFree(pwszUuidOperation);
    }
    

    InterlockedIncrement(&m_lThreadCounter);
	if (NULL != pStartupInfo->punkProgressListener)
	{
		//
		// since this is an async operation, to prevent caller free this object after 
		// this call returns, we pump up ref count here. The thread proc will 
		// release refcount after it finishes the work
		//
		pStartupInfo->punkProgressListener->AddRef();
	}

    hThread = CreateThread(NULL, 0, DownloadThreadProc, (LPVOID)pStartupInfo, 0, &dwThreadId);
    
    if (NULL == hThread)
    {
        //
        // clean up allocated strings in pStartupInfo.
        //
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        LOG_ErrorMsg(hr);
		SafeRelease(pStartupInfo->punkProgressListener);
        InterlockedDecrement(&m_lThreadCounter);
    }
    else
    {
        LOG_Download(_T("Download thread generated successfully"));
    }

CleanUp:
    if (FAILED(hr))
    {
        LogError(hr, "Asynchronous Download failed during startup");

        if (NULL != pStartupInfo)
        {
            SysFreeString(pStartupInfo->bstrDestinationFolder);
            SysFreeString(pStartupInfo->bstrXmlCatalog);
            SysFreeString(pStartupInfo->bstrClientName);
            SysFreeString(pStartupInfo->bstrUuidOperation);
            HeapFree(hHeap, 0, pStartupInfo);
        }
    }

    SysFreeString(bstrClientName);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DownloadCallback()
//
// Callback Function to recieve progress from IU Downloader. 
// 
// Input:
// pCallbackData - void pointer to DCB_DATA structure
// dwStatus - Current Download Status
// dwBytesTotal - Total Bytes of File being Downloaded
// dwBytesComplete - Bytes Downloaded so far
// bstrCompleteResult - Contains Item Result XML
//
// Output:
// plCommandRequest - Used to Instruct the Downloader to continue, abort, suspend...
//
// Return:
// 0 - always, exit code is irrelevant since calling thread doesn't check the
// status of this thread after creation.
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DownloadCallback(VOID* pCallbackData, DWORD dwStatus, DWORD dwBytesTotal, DWORD dwBlockSizeDownloaded, BSTR bstrXmlData, LONG* plCommandRequest)
{
    LOG_Block("DownloadCallback()");

    HRESULT hr;
    LONG lUpdateMask = 0;
    float flNewPercentage;
    EventData evtData;
    char szProgressSize[64] = {'\0'};
    BOOL fPostWaitSuccess = TRUE;
    ZeroMemory((LPVOID) &evtData, sizeof(evtData));

    USES_IU_CONVERSION;

    P_DCB_DATA pCallbackParam = (P_DCB_DATA) pCallbackData;

    if (NULL != pCallbackParam->bstrOperationUuid)
    {
        evtData.bstrUuidOperation = SysAllocString(pCallbackParam->bstrOperationUuid);
        LOG_Download(_T("Found UUID=%s"), OLE2T(evtData.bstrUuidOperation));
    }

    if (dwBytesTotal != pCallbackParam->lCurrentItemSize && DOWNLOAD_STATUS_ITEMCOMPLETE != dwStatus)
    {
        pCallbackParam->lTotalDownloadSize = (pCallbackParam->lTotalDownloadSize - pCallbackParam->lCurrentItemSize) + dwBytesTotal;
        pCallbackParam->lCurrentItemSize = dwBytesTotal;
    }

    // Keep the Total Downloaded Bytes Counter
    if (0 != dwBlockSizeDownloaded && DOWNLOAD_STATUS_ITEMCOMPLETE != dwStatus)
        pCallbackParam->lTotalDownloaded += dwBlockSizeDownloaded;

    LOG_Download(_T("dwStatus=0x%08x"), dwStatus);

    //
    // if the Status is DOWNLOAD_STATUS_FILECOMPLETE we are done with this File
    //
    evtData.fItemCompleted = (dwStatus == DOWNLOAD_STATUS_ITEMCOMPLETE);

    switch (dwStatus)
    {
    case DOWNLOAD_STATUS_ITEMSTART:

        if (NULL != pCallbackParam->pProgressListener)
        {
            pCallbackParam->pProgressListener->OnItemStart(pCallbackParam->bstrOperationUuid, 
                bstrXmlData, &evtData.lCommandRequest);
        }
        else
        {
            // only use event window if no progresslistener interface was given
            if (NULL != pCallbackParam->hEventFiringWnd)
            {
                evtData.bstrXmlData = bstrXmlData;
                SendMessage(pCallbackParam->hEventFiringWnd, UM_EVENT_ITEMSTART, 0, LPARAM(&evtData));
                evtData.bstrXmlData = NULL;
            }
        }


        break;

    case DOWNLOAD_STATUS_OK:    // simple progress update
    case DOWNLOAD_STATUS_ITEMCOMPLETE:
        if (0 != pCallbackParam->flProgressPercentage)
        {
            // we need to give progress callbacks on given percentage increments
            flNewPercentage = ((float)pCallbackParam->lTotalDownloaded / pCallbackParam->lTotalDownloadSize);
            if (((flNewPercentage - pCallbackParam->flLastPercentage) >= pCallbackParam->flProgressPercentage) ||
                ((1.0 - flNewPercentage) < 0.0001 && 1 != pCallbackParam->flProgressPercentage))
            {
                // The Difference between LastPercentComplete and CurrentPercentComplete complies with the 
                // Progress Percentage granuluarity OR the percentage is 100 (complete)
                if (evtData.fItemCompleted)
                {
                    //wsprintfA(szProgressSize, "%d", (int)flNewPercentage); // float should be 1.0, cast as int will be 1
                    //
                    // when we notify the user this "item", not file, completed, we don't need
                    // to pass out any percentage info.
                    //
                    szProgressSize[0] = _T('\0');
                }
                else
                {
                    if ((1.0 - flNewPercentage) < 0.0001)
                    {
                        if (ARRAYSIZE(szProgressSize) >= 2)
                        {
                            szProgressSize[0] = _T('1');
                            szProgressSize[1] = _T('\0');
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        hr = StringCchPrintfExA(szProgressSize, ARRAYSIZE(szProgressSize),
                                                NULL, NULL, MISTSAFE_STRING_FLAGS,
                                                ".%02d", (int)(flNewPercentage*100)); // string equivilant of a float
                        if (FAILED(hr))
                        {
                            LOG_ErrorMsg(hr);
                            break;
                        }
                    }
                }
                pCallbackParam->flLastPercentage = flNewPercentage;
            }
            else
            {
                // don't make a callback
                break;
            }
        }
        else
        {
            // No percentage callback was requested.. just give the byte values.
            if (dwStatus == DOWNLOAD_STATUS_ITEMCOMPLETE)
            {
                szProgressSize[0] = _T('\0');
            }
            else
            {
                hr = StringCchPrintfExA(szProgressSize, ARRAYSIZE(szProgressSize),
                                        NULL, NULL, MISTSAFE_STRING_FLAGS,
                                        "%lu:%lu", (ULONG)pCallbackParam->lTotalDownloadSize, (ULONG)pCallbackParam->lTotalDownloaded);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    break;
                }
            }
        }
        evtData.bstrProgress = SysAllocString(A2OLE(szProgressSize));
        if (NULL != pCallbackParam->pProgressListener)
        {
            pCallbackParam->pProgressListener->OnProgress(pCallbackParam->bstrOperationUuid, 
                evtData.fItemCompleted, evtData.bstrProgress, &evtData.lCommandRequest);
        }
        else
        {
            // only use event window if no progresslistener interface was given
            if (NULL != pCallbackParam->hEventFiringWnd)
            {
                SendMessage(pCallbackParam->hEventFiringWnd, UM_EVENT_PROGRESS, 0, LPARAM(&evtData));
            }
        }
        break;

    case DOWNLOAD_STATUS_OPERATIONCOMPLETE:
        if (NULL != pCallbackParam->pProgressListener)
        {
            pCallbackParam->pProgressListener->OnOperationComplete(pCallbackParam->bstrOperationUuid,
                bstrXmlData);
        }
        else
        {
            // only use event window if no progresslistener interface was given
            if (NULL != pCallbackParam->hEventFiringWnd) 
            {
                evtData.bstrXmlData = bstrXmlData;
                fPostWaitSuccess = WUPostEventAndBlock(pCallbackParam->hEventFiringWnd, 
                                                       UM_EVENT_COMPLETE, 
                                                       &evtData);
            }
        }

        // Look for an existing Operation in the Mgr, and update the Complete Result if available.
        if (pCallbackParam->pOperationMgr->FindOperation(OLE2T(pCallbackParam->bstrOperationUuid), &lUpdateMask, NULL))
        {
            pCallbackParam->pOperationMgr->UpdateOperation(OLE2T(pCallbackParam->bstrOperationUuid), lUpdateMask, bstrXmlData);
        }
        break;
    case DOWNLOAD_STATUS_ABORTED:
    case DOWNLOAD_STATUS_ERROR:
        //
        // abort case: user should know. nothing to report
        // error case: progress callback doesn't give us any way of telling the caller that its an error, no reason to send the callback
        // the itemcomplete callback will have the error status for the item.
        //
        break;
    }
    
    if (NULL != plCommandRequest) // we made a callback and the command request value was retrieved
    {
        *plCommandRequest = (LONG)((DWORD) evtData.lCommandRequest & (DWORD) UPDATE_COMMAND);
        LOG_Download(_T("Command returned: 0x%08x"), *plCommandRequest);
    }

    // don't free up the strings below unless the wait succeeded in 
    //  WUPostEventAndBlock.  If we do free the strings up and the wait didn't
    //  succeed, then we run the risk of AVing ourselves.  Note that fPostWaitSuccess
    //  is initialized to TRUE so if we will free these BSTRs if WUPostEventAndBlock
    //  is not called.
    if (fPostWaitSuccess)
    {
        SysFreeString(evtData.bstrProgress);
        SysFreeString(evtData.bstrUuidOperation);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DownloadThreadProc()
//
// Thread Proc for Async Download. Retrieves the startup information from
// the input param and calls Download() from this seperate thread. The calling
// thread returns immediately.
// 
// Input:
// lpv - void pointer to IUDOWNLOADSTARTINFO struct containing all information
//       needed to call Download()
//
// Return:
// 0 - always, exit code is irrelevant since calling thread doesn't check the
// status of this thread after creation.
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DownloadThreadProc(LPVOID lpv)
{
    LOG_Block("DownloadThreadProc()");
    //
    // in this new thread need to call CoInitialize again
    // but since we don't know who the caller is, what threading they
    // are using, so we just use single apartment
    //
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        LogError(hr, "Asynchronous Download thread exiting");
        LOG_ErrorMsg(hr);
        return 0;
    }
    LOG_Download(_T("CoInitialize called successfully"));

    PIUDOWNLOADSTARTUPINFO pStartupInfo = (PIUDOWNLOADSTARTUPINFO)lpv;
    BSTR bstrXmlItems = NULL;

    LOG_Download(_T("Download thread started, now the thread count=%d"), pStartupInfo->pEngUpdate->m_lThreadCounter);

    //
    // call synchronized download function in this thread
    //
    _Download(
        pStartupInfo->bstrClientName, 
        pStartupInfo->bstrXmlCatalog, 
        pStartupInfo->bstrDestinationFolder, 
        pStartupInfo->lMode, 
        pStartupInfo->punkProgressListener, 
        pStartupInfo->hwnd, 
        pStartupInfo->bstrUuidOperation,
        &bstrXmlItems,
		pStartupInfo->pEngUpdate);
    
    //
    // pStartupInfo is a buffer allocated by calling thread, when we are done, we need to 
    // free it here
    //
    SysFreeString(pStartupInfo->bstrDestinationFolder);
    SysFreeString(pStartupInfo->bstrXmlCatalog);
    SysFreeString(pStartupInfo->bstrClientName);
    SysFreeString(pStartupInfo->bstrUuidOperation);
    SysFreeString(bstrXmlItems);
	SafeRelease(pStartupInfo->punkProgressListener);		// so the caller can free this object

    CoUninitialize();
    LOG_Download(_T("CoUninitialize called"));

    InterlockedDecrement(&(pStartupInfo->pEngUpdate->m_lThreadCounter));

    HeapFree(GetProcessHeap(), 0, pStartupInfo);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\expression.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   expression.CPP
//
//	Author:	Charles Ma
//			2000.10.27
//
//  Description:
//
//      Implement function related to detection expressions
//
//=======================================================================

#include "iuengine.h"
#include "SchemaMisc.h"
#include "expression.h"

#include <RegUtil.h>
#include <FileUtil.h>
#include <StringUtil.h>
#include <shlwapi.h>

#include "SchemaKeys.h"
#include "iucommon.h"


//
// include IDetection interface
//

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_
MIDL_DEFINE_GUID(IID, IID_IDetection,0x8E2EF6DC,0x0AB8,0x4FE0,0x90,0x49,0x3B,0xEA,0x45,0x06,0xBF,0x8D);


#ifndef __IDetection_FWD_DEFINED__
#define __IDetection_FWD_DEFINED__
typedef interface IDetection IDetection;
#endif 	/* __IDetection_FWD_DEFINED__ */


#ifndef __IDetection_INTERFACE_DEFINED__
#define __IDetection_INTERFACE_DEFINED__

/* interface IDetection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDetection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E2EF6DC-0AB8-4FE0-9049-3BEA4506BF8D")
    IDetection : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Detect( 
            /* [in] */ BSTR bstrXML,
            /* [out] */ DWORD *pdwDetectionResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDetectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDetection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDetection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDetection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDetection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDetection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDetection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDetection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Detect )( 
            IDetection * This,
            /* [in] */ BSTR bstrXML,
            /* [out] */ DWORD *pdwDetectionResult);
        
        END_INTERFACE
    } IDetectionVtbl;

    interface IDetection
    {
        CONST_VTBL struct IDetectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDetection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDetection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDetection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDetection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDetection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDetection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDetection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDetection_Detect(This,bstrXML,pdwDetectionResult)	\
    (This)->lpVtbl -> Detect(This,bstrXML,pdwDetectionResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDetection_Detect_Proxy( 
    IDetection * This,
    /* [in] */ BSTR bstrXML,
    /* [out] */ DWORD *pdwDetectionResult);


void __RPC_STUB IDetection_Detect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IDetection_INTERFACE_DEFINED__ */

//
// deckare the constants used to manipulate the result of Detect() method
//

//
// First group, used in <expression> tag, to tell the detection result. This result
// should combined with other expression(s) at the same level
//
const DWORD     IUDET_BOOL              = 0x00000001;	// mask 
const DWORD     IUDET_FALSE             = 0x00000000;	// expression detect FALSE 
const DWORD     IUDET_TRUE              = 0x00000001;	// expression detect TRUE 
const DWORD     IUDET_NULL              = 0x00000002;	// expression detect data missing

//
// Second group, used in <detection> tag, to tell the detection result. This result
// should overwrite the rest of <expression>, if any
//
extern const LONG      IUDET_INSTALLED         = 0x00000010;   /* mask for <installed> result */
extern const LONG      IUDET_INSTALLED_NULL    = 0x00000020;   /* <installed> missing */
extern const LONG      IUDET_UPTODATE          = 0x00000040;   /* mask for <upToDate> result */
extern const LONG      IUDET_UPTODATE_NULL     = 0x00000080;   /* <upToDate> missing */
extern const LONG      IUDET_NEWERVERSION      = 0x00000100;   /* mask for <newerVersion> result */
extern const LONG      IUDET_NEWERVERSION_NULL = 0x00000200;   /* <newerVersion> missing */
extern const LONG      IUDET_EXCLUDED          = 0x00000400;   /* mask for <excluded> result */
extern const LONG      IUDET_EXCLUDED_NULL     = 0x00000800;   /* <excluded> missing */
extern const LONG      IUDET_FORCE             = 0x00001000;   /* mask for <force> result */
extern const LONG      IUDET_FORCE_NULL        = 0x00002000;   /* <force> missing */
extern const LONG		IUDET_COMPUTER			= 0x00004000;	// mask for <computerSystem> result
extern const LONG		IUDET_COMPUTER_NULL		= 0x00008000;	// <computerSystem> missing





#define GotoCleanupIfNull(p)	if (NULL==p) goto CleanUp
#define GotoCleanupHR(hrCode)	hr = hrCode; LOG_ErrorMsg(hr); goto CleanUp


// ----------------------------------------------------------------------
//
// public helper function to convert a bstr value to
// version status enum value, if possible
//
// ----------------------------------------------------------------------
BOOL ConvertBstrVersionToEnum(BSTR bstrVerVerb, _VER_STATUS *pEnumVerVerb)
{
	//
	// convert the versionStatus in bstr into enum
	//
	if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_HI))
	{
		*pEnumVerVerb = DETX_HIGHER;
	}
	else if (CompareBSTRsEqual(bstrVerVerb,KEY_VERSTATUS_HE))
	{
		*pEnumVerVerb = DETX_HIGHER_OR_EQUAL;
	}
	else if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_EQ))
	{
		*pEnumVerVerb = DETX_SAME;
	}
	else if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_LE))
	{
		*pEnumVerVerb = DETX_LOWER_OR_EQUAL;
	}
	else if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_LO))
	{
		*pEnumVerVerb = DETX_LOWER;
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}






//----------------------------------------------------------------------
//
// public function DetectExpression()
//	retrieve the data from the express node, 
//	and do actual detection work
//
//	Input:
//		expression node
//		LPCTSTR			lpcsDllPath,	// path that this provider saved the cust detection Dll
//
//	Return:
//		TRUE/FALSE, detection result
//
//----------------------------------------------------------------------
HRESULT DetectExpression(IXMLDOMNode* pExpression, BOOL *pfResult)
{
	HRESULT				hr			= E_INVALIDARG;
	int					iRet		= -1;
	BOOL				fRet		= TRUE;
	IXMLDOMNodeList*	pChildList	= NULL;
	IXMLDOMNode*		pCandidate	= NULL;

	BSTR				bstrName = NULL;
	BSTR				bstrKey = NULL, 
						bstrEntry = NULL, 
						bstrValue = NULL;
	
	LPCTSTR				lpszKeyComputer = NULL;

	LOG_Block("DetectExpression()");

	USES_IU_CONVERSION;
	

	if (NULL == pExpression || NULL == pfResult)
	{
		LOG_ErrorMsg(hr);
		return hr;
	}


	*pfResult = TRUE;

	//
	// retrieve all child nodes
	//
	(void)pExpression->get_childNodes(&pChildList);
	if (NULL == pChildList)
	{
		LOG_XML(_T("Empty expression found!"));
		GotoCleanupHR(E_INVALIDARG);
	}

	//
	// get the first child
	//
	(void)pChildList->nextNode(&pCandidate);
	if (NULL == pCandidate)
	{
		LOG_XML(_T("empty child list for passed in expresson node!"));
		GotoCleanupHR(E_INVALIDARG);
	}

	//
	// loop through each child node, find out the type
	// of node, call actual detection func accordingly
	//
	lpszKeyComputer = OLE2T(KEY_COMPUTERSYSTEM);
	CleanUpFailedAllocSetHrMsg(lpszKeyComputer);

	while (NULL != pCandidate)
	{
		CleanUpIfFailedAndSetHrMsg(pCandidate->get_nodeName(&bstrName));

		LPTSTR lpszName = OLE2T(bstrName);
		CleanUpFailedAllocSetHrMsg(lpszName);

		if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYEXISTS, 
										-1))
		{
			//
			// call detection function
			//
			hr = DetectRegKeyExists(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYVALUE, 
										-1))
		{
			//
			// process RegKeyValue expression
			//
			hr = DetectRegKeyValue(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYSUBSTR, 
										-1))
		{
			//
			// process RegKeySubstring expression
			//
			hr = DetectRegKeySubstring(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYVERSION, 
										-1))
		{
			//
			// process RegVersion expression
			//
			hr = DetectRegVersion(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_FILEVERSION, 
										-1))
		{
			//
			// process FileVersion expression
			//
			hr = DetectFileVersion(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_FILEEXISTS, 
										-1))
		{
			//
			// process FileExists expression
			//
			hr = DetectFileExists(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										lpszKeyComputer, 
										-1))
		{
			//
			// process computerSystem check
			//
			hr = DetectComputerSystem(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_AND, 
										-1))
		{
			//
			// process AND expression
			//
			IXMLDOMNodeList*	pSubExpList = NULL;
			IXMLDOMNode*		pSubExp = NULL;
			long				lLen = 0;

			//
			// get child list
			//
			pCandidate->get_childNodes(&pSubExpList);
			if (NULL == pSubExpList)
			{
				LOG_XML(_T("Found no children of AND expression"));
				GotoCleanupHR(E_INVALIDARG);
			}

			pSubExpList->get_length(&lLen);
			fRet = TRUE;
			for (long i = 0; i < lLen && fRet; i++)
			{
				//
				// each child should be an expression
				// process it. if false, then short-cut.
				//
				pSubExpList->get_item(i, &pSubExp);
				if (NULL == pSubExp)
				{
					pSubExpList->Release();
					pSubExpList = NULL;
					LOG_XML(_T("Failed to get the #%d sub-expression in this AND expression"), i);
					GotoCleanupHR(E_INVALIDARG);		
				}
				hr = DetectExpression(pSubExp, &fRet);
				SafeReleaseNULL(pSubExp);
				if (FAILED(hr))
				{
					//
					// if found something wrong in recursion, don't continue
					//
					break;
				}
			}
			SafeReleaseNULL(pSubExpList);
			*pfResult = fRet;
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_OR, 
										-1))
		{
			//
			// process OR expression
			//
			IXMLDOMNodeList*	pSubExpList = NULL;
			IXMLDOMNode*		pSubExp = NULL;
			long				lLen = 0;

			//
			// get child list
			//
			pCandidate->get_childNodes(&pSubExpList);
			if (NULL == pSubExpList)
			{
				LOG_XML(_T("Found no children of OR expression"));
				GotoCleanupHR(E_INVALIDARG);
			}

			pSubExpList->get_length(&lLen);
			fRet = FALSE;
			for (long i = 0; i < lLen && !fRet; i++)
			{
				//
				// each child is one expression
				// do it one by one
				//
				pSubExpList->get_item(i, &pSubExp);
				if (NULL == pSubExp)
				{
					pSubExpList->Release();
					pSubExpList = NULL;
					LOG_XML(_T("Failed to get the #%d sub-expression in this OR expression"), i);
					GotoCleanupHR(E_INVALIDARG);		
				}
				hr = DetectExpression(pSubExp, &fRet);
				SafeReleaseNULL(pSubExp);

				if (FAILED(hr))
				{
					//
					// if found something wrong in recursion, don't continue
					//
					break;
				}
			}
			SafeReleaseNULL(pSubExpList);
			*pfResult = fRet;

		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_NOT, 
										-1))
		{
			//
			// process NOT expression
			//
			IXMLDOMNode*		pSubExp = NULL;
			//
			// get the only child
			//
			pCandidate->get_firstChild(&pSubExp);
			if (NULL == pSubExp)
			{
				LOG_XML(_T("Failed to get first child in NOT expression"));
				GotoCleanupHR(E_INVALIDARG);
			}
			//
			// the child must be an expression, process it
			//
			hr = DetectExpression(pSubExp, &fRet);
			if (SUCCEEDED(hr))
			{
				fRet = !fRet;	// flip the result for NOT expression
				*pfResult = fRet;
			}
			else
			{
				LOG_ErrorMsg(hr);
			}
			SafeReleaseNULL(pSubExp);
		}

		if (FAILED(hr))
		{
			goto CleanUp;
		}

		if (!*pfResult)
		{
			//
			// if found one expression FALSE, the whole thing false, so
			// no need to continue
			//
			break;
		}
		SafeReleaseNULL(pCandidate);
		pChildList->nextNode(&pCandidate);
		SafeSysFreeString(bstrName);
	}
		




CleanUp:
	SafeReleaseNULL(pCandidate);
	SafeReleaseNULL(pChildList);
	SysFreeString(bstrName);
	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrValue);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectRegKeyExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyExists node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyExists(
	IXMLDOMNode* pRegKeyExistsNode,
	BOOL *pfResult
)
{
	LOG_Block("DetectRegKeyExists");
	
	HRESULT	hr = E_INVALIDARG;
	BOOL	fRet = FALSE;
	LPTSTR	lpszKey = NULL, lpszEntry = NULL;
	BSTR	bstrKey = NULL, bstrEntry = NULL;

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (FindNodeValue(pRegKeyExistsNode, KEY_KEY, &bstrKey))
	{
		lpszKey = OLE2T(bstrKey);
		CleanUpFailedAllocSetHrMsg(lpszKey);

		//
		// find the optional entry value
		//
		if (FindNodeValue(pRegKeyExistsNode, KEY_ENTRY, &bstrEntry))
		{
			lpszEntry = OLE2T(bstrEntry);
			CleanUpFailedAllocSetHrMsg(lpszEntry);
		}

		*pfResult = RegKeyExists(lpszKey, lpszEntry);

		hr = S_OK;
	}

CleanUp:
	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectRegKeyExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyValue(
	IXMLDOMNode* pRegKeyValueNode,
	BOOL *pfResult
)
{
	LOG_Block("DetectRegKeyValue");

	HRESULT	hr			= E_INVALIDARG;
	BOOL	fRet		= FALSE;
	LPTSTR	lpszKey		= NULL, 
			lpszEntry	= NULL, 
			lpszValue	= NULL;
	BSTR	bstrKey		= NULL, 
			bstrEntry	= NULL, 
			bstrValue	= NULL;

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (!FindNodeValue(pRegKeyValueNode, KEY_KEY, &bstrKey))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}


	lpszKey = OLE2T(bstrKey);
	CleanUpFailedAllocSetHrMsg(lpszKey);

	//
	// find the optional entry value
	//
	if (FindNodeValue(pRegKeyValueNode, KEY_ENTRY, &bstrEntry))
	{
		lpszEntry = OLE2T(bstrEntry);
		CleanUpFailedAllocSetHrMsg(lpszEntry);
	}

	//
	// find the value to compare
	//
	if (!FindNodeValue(pRegKeyValueNode, KEY_VALUE, &bstrValue))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszValue = OLE2T(bstrValue);
	CleanUpFailedAllocSetHrMsg(lpszValue);

	*pfResult = RegKeyValueMatch((LPCTSTR)lpszKey, (LPCTSTR)lpszEntry, (LPCTSTR)lpszValue);
	hr = S_OK;
CleanUp:

	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrValue);

	return hr;

}



//----------------------------------------------------------------------
//
// Helper function DetectRegKeySubstring()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeySubstring(
	IXMLDOMNode* pRegKeySubstringNode,
	BOOL *pfResult
)
{
	LOG_Block("DetectRegKeySubstring");

	HRESULT	hr			= E_INVALIDARG;
	BOOL	fRet		= FALSE;
	LPTSTR	lpszKey		= NULL, 
			lpszEntry	= NULL, 
			lpszValue	= NULL;
	BSTR	bstrKey		= NULL,
			bstrEntry	= NULL,
			bstrValue	= NULL;

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (!FindNodeValue(pRegKeySubstringNode, KEY_KEY, &bstrKey))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszKey = OLE2T(bstrKey);
	CleanUpFailedAllocSetHrMsg(lpszKey);

	//
	// find the optional entry value
	//
	if (FindNodeValue(pRegKeySubstringNode, KEY_ENTRY, &bstrEntry))
	{
		lpszEntry = OLE2T(bstrEntry);
		CleanUpFailedAllocSetHrMsg(lpszEntry);
	}

	//
	// find the value to compare
	//
	if (!FindNodeValue(pRegKeySubstringNode, KEY_VALUE, &bstrValue))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszValue = OLE2T(bstrValue);
	CleanUpFailedAllocSetHrMsg(lpszValue);

	*pfResult = RegKeySubstring((LPCTSTR)lpszKey, (LPCTSTR)lpszEntry, (LPCTSTR)lpszValue);

	hr = S_OK;

CleanUp:

	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrValue);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectFileVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectRegVersion(
	IXMLDOMNode* pRegKeyVersionNode,
	BOOL *pfResult
)
{
	HRESULT	hr			= E_INVALIDARG;
	BOOL	fRet		= FALSE;
	LPTSTR	lpszKey		= NULL, 
			lpszEntry	= NULL, 
			lpszVersion = NULL;
	BSTR	bstrVerVerb	= NULL,
			bstrKey		= NULL,
			bstrEntry	= NULL,
			bstrVersion	= NULL;

	_VER_STATUS verStatus;

	LOG_Block("DetectRegVersion()");

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (!FindNodeValue(pRegKeyVersionNode, KEY_KEY, &bstrKey))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszKey = OLE2T(bstrKey);
	CleanUpFailedAllocSetHrMsg(lpszKey);

	LOG_XML(_T("Found Key=%s"), lpszKey);


	//
	// find the optional entry value
	//
	if (FindNodeValue(pRegKeyVersionNode, KEY_ENTRY, &bstrEntry))
	{
		lpszEntry = OLE2T(bstrEntry);
		CleanUpFailedAllocSetHrMsg(lpszEntry);
		LOG_XML(_T("Found optional entry=%s"), lpszEntry);
	}

	//
	// find the value to compare
	//
	if (!FindNodeValue(pRegKeyVersionNode, KEY_VERSION, &bstrVersion))
	{
		goto CleanUp;
	}

	lpszVersion = OLE2T(bstrVersion);
	CleanUpFailedAllocSetHrMsg(lpszVersion);
	LOG_XML(_T("Version found from node: %s"), lpszVersion);

	//
	// get the attribute versionStatus, a version compare verb
	//
	if (S_OK != (hr = GetAttribute(pRegKeyVersionNode, KEY_VERSIONSTATUS, &bstrVerVerb)))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}
	LOG_XML(_T("Version verb found from node: %s"), OLE2T(bstrVerVerb));

	//
	// convert the versionStatus in bstr into enum
	//
	if (!ConvertBstrVersionToEnum(bstrVerVerb, &verStatus))
	{
		SafeSysFreeString(bstrVerVerb);
		goto CleanUp;
	}


	*pfResult = RegKeyVersion((LPCTSTR)lpszKey, (LPCTSTR)lpszEntry, (LPCTSTR)lpszVersion, verStatus);

	hr = S_OK;

CleanUp:

	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrVersion);
	SysFreeString(bstrVerVerb);
	
	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectFileVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileVersion(
	IXMLDOMNode* pFileVersionNode,
	BOOL *pfResult
)
{
	BOOL	fRet = FALSE;
	BOOL	fFileExists = FALSE;
	HRESULT	hr = E_INVALIDARG;
	IXMLDOMNode* pFilePathNode = NULL;
	TCHAR	szFilePath[MAX_PATH];
	int		iFileVerComp;
	LPTSTR	lpszTimeStamp = NULL,
			lpszVersion = NULL;
	
	BSTR	bstrTime	= NULL,
			bstrVersion	= NULL,
			bstrVerState= NULL;
	

	FILE_VERSION fileVer;
	_VER_STATUS verStatus;

	LOG_Block("DetectFileVersion()");

	USES_IU_CONVERSION;

	if (NULL == pfResult || NULL == pFileVersionNode)
	{
		LOG_ErrorMsg(hr);
		return hr;
	}

	*pfResult = FALSE;	

	//
	// find the version value
	//
	if (!FindNodeValue(pFileVersionNode, KEY_VERSION, &bstrVersion))
	{
		LOG_ErrorMsg(hr);
		return hr;
	}

	if (NULL == (lpszVersion = OLE2T(bstrVersion)))
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
		goto CleanUp;
	}
	
	LOG_XML(_T("Version=%s"), lpszVersion);

	if (!ConvertStringVerToFileVer(T2A(lpszVersion), &fileVer))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;	// bad version string
	}

	//
	// find the file path value
	//
	//if (!FindNodeValue(pFileVersionNode, KEY_FILEPATH, &bstrFile))
	if (!FindNode(pFileVersionNode, KEY_FILEPATH, &pFilePathNode) ||
		NULL == pFilePathNode ||
		FAILED(hr = GetFullFilePathFromFilePathNode(pFilePathNode, szFilePath)))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;		// no file path found!
	}

	LOG_XML(_T("File=%s"), szFilePath);

	//
	// check if file exist
	//
	fFileExists = FileExists(szFilePath);

	//
	// get the attribute versionStatus, a version compare verb
	//
	if (S_OK != GetAttribute(pFileVersionNode, KEY_VERSIONSTATUS, &bstrVerState))
	{
		goto CleanUp;	// no version status found
	}
	LOG_XML(_T("VersionStatus=%s"), OLE2T(bstrVerState));

	if (!ConvertBstrVersionToEnum(bstrVerState, &verStatus))
	{
		//
		// bad version enum, shouldn't happen since the manifest has
		// been loaded into XMLDOM
		//
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// get optional timestamp
	//
	if (S_OK == GetAttribute(pFileVersionNode, KEY_TIMESTAMP, &bstrTime))
	{
		TCHAR szFileTimeStamp[20];
		LPTSTR lpXmlTimeStamp = OLE2T(bstrTime);
		CleanUpFailedAllocSetHrMsg(lpXmlTimeStamp);

		//
		// find out the file creation time stamp
		//
		int iCompare;
		if (!fFileExists || !GetFileTimeStamp(szFilePath, szFileTimeStamp, 20))
		{
			//szFileTimeStamp[0] = '\0';	// we don't have a timestamp to compare
			//
			// for timestamp compare, it's date/time ISO format compare, i.e., 
			// in alphabetical order, so empty timestamp always smaller.
			//
			iCompare = -1;
		}
		else
		{

			//
			// compare file timestamp, if szFileTimeStamp < lpXmlTimeStamp, -1
			//
			int iCompVal = CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										szFileTimeStamp, 
										-1, 
										lpXmlTimeStamp, 
										-1);
			iCompare = (CSTR_EQUAL == iCompVal) ? 0 : ((CSTR_LESS_THAN == iCompVal) ? -1 : +1);
		}

		switch (verStatus)
		{
		case DETX_LOWER:
			fRet = (iCompare < 0);
			break;
		case DETX_LOWER_OR_EQUAL:
			fRet = (iCompare <= 0);
			break;
		case DETX_SAME:
			fRet = (iCompare == 0);
			break;
		case DETX_HIGHER_OR_EQUAL:
			fRet = (iCompare >= 0);
			break;
		case DETX_HIGHER:
			fRet = (iCompare > 0);
			break;
		}
		*pfResult = fRet;

		if (!fRet)
		{
			//
			// false, not need to continue
			//
			hr = S_OK;
			goto CleanUp;
		}
	}
	
	//
	// compare file version: if a < b, -1; a > b, +1
	//
	if (!fFileExists || (FAILED(CompareFileVersion((LPCTSTR)szFilePath, fileVer, &iFileVerComp))))
	{
		//
		// failed to compare version - file may doesn't have a version data.
		// in this case, we assume the file need to compare have version 0,0,0,0, and force
		// the comparision oontinue.
		//
		FILE_VERSION verNoneExists = {0,0,0,0};
		iFileVerComp = CompareFileVersion(verNoneExists, fileVer);
	}

	switch (verStatus)
	{
	case DETX_LOWER:
		fRet = (iFileVerComp < 0);
		break;
	case DETX_LOWER_OR_EQUAL:
		fRet = (iFileVerComp <= 0);
		break;
	case DETX_SAME:
		fRet = (iFileVerComp == 0);
		break;
	case DETX_HIGHER_OR_EQUAL:
		fRet = (iFileVerComp >= 0);
		break;
	case DETX_HIGHER:
		fRet = (iFileVerComp > 0);
		break;
	}

	*pfResult = fRet;

	hr = S_OK;

CleanUp:
	SysFreeString(bstrTime);
	SysFreeString(bstrVersion);
	SysFreeString(bstrVerState);
	SafeReleaseNULL(pFilePathNode);
	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectFileExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileExists(
	IXMLDOMNode* pFileExistsNode,
	BOOL *pfResult
)
{
	BOOL	fRet = FALSE;
	HRESULT hr = E_INVALIDARG;
	TCHAR	szFilePath[MAX_PATH];
	IXMLDOMNode* pFilePathNode = NULL;
	_VER_STATUS verStatus;

	USES_IU_CONVERSION;

	LOG_Block("DetectFileExists()");

	if (NULL == pFileExistsNode || NULL == pfResult)
	{
		return E_INVALIDARG;
	}

	//
	// find the version value
	//
	if (!FindNode(pFileExistsNode, KEY_FILEPATH, &pFilePathNode) ||
		NULL == pFilePathNode ||
		FAILED(hr = GetFullFilePathFromFilePathNode(pFilePathNode, szFilePath)))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		*pfResult = FileExists((LPCTSTR)szFilePath);
		hr = S_OK;
	}

	SafeReleaseNULL(pFilePathNode);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectComputerSystem()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		computerSystem node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectComputerSystem(
	IXMLDOMNode* pComputerSystemNode,
	BOOL *pfResult
)
{
	HRESULT hr = E_INVALIDARG;

	LOG_Block("DetectComputerSystem()");

	BSTR bstrManufacturer = NULL;
	BSTR bstrModel = NULL;
	BSTR bstrSupportURL = NULL;
	BSTR bstrXmlManufacturer = NULL;
	BSTR bstrXmlModel = NULL;


	if (NULL == pComputerSystemNode || NULL == pfResult)
	{
		LOG_ErrorMsg(hr);
		return hr;
	}

	*pfResult = FALSE;	// anything wrong, result should be FALSE and return error

	//
	// get manufecturer and model from XML node
	//
	hr = GetAttribute(pComputerSystemNode, KEY_MANUFACTURER, &bstrXmlManufacturer);
	CleanUpIfFailedAndMsg(hr);

	//
	// optional model
	//
	GetAttribute(pComputerSystemNode, KEY_MODEL, &bstrXmlModel);
	
	//
	// find out real manufectuer and model of this machine
	//
	hr = GetOemBstrs(bstrManufacturer, bstrModel, bstrSupportURL);
	CleanUpIfFailedAndMsg(hr);

	//
	// compare to see if manufacturer and model match.
	// mafufacturer match required. If no model provided in xml
	// then no check on model performed.
	//
	// definition of match: both empty or bstr compare equal
	// definition of empty: bstr NULL or string length zero
	//
	*pfResult = (
		(((NULL == bstrXmlManufacturer || SysStringLen(bstrXmlManufacturer) == 0) && // xml data empty and
		  (NULL == bstrManufacturer || SysStringLen(bstrManufacturer) == 0)) ||		// machine manufecturer empty, or
		 CompareBSTRsEqual(bstrManufacturer, bstrXmlManufacturer)) &&				// manufacturer same as xml data, also, 
		 ((NULL == bstrXmlModel) ||													// xml data empty or
		  CompareBSTRsEqual(bstrModel, bstrXmlModel)));								// model matches xml data

	LOG_Out(_T("XML: %ls (%ls), Machine: %ls (%ls), Return: %hs"), 
		(LPCWSTR)bstrManufacturer,
		(LPCWSTR)bstrModel,
		(LPCWSTR)bstrXmlManufacturer,
		(LPCWSTR)bstrXmlModel,
		((*pfResult) ? "True" : "False"));

CleanUp:

	SysFreeString(bstrManufacturer);
	SysFreeString(bstrModel);
	SysFreeString(bstrSupportURL);
	SysFreeString(bstrXmlManufacturer);
	SysFreeString(bstrXmlModel);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\history.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   History.CPP
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      Class to handle history log
//
//=======================================================================


#include "iuengine.h"
#include <iucommon.h>
#include <fileutil.h>
#include <StringUtil.h>
#include <shlwapi.h>	// for PathAppend() API
#include "history.h"

const TCHAR C_V3_LOG_FILE[]			= _T("wuhistv3.log");
const TCHAR C_LOG_FILE[]			= _T("iuhist.xml");
const TCHAR C_LOG_FILE_CORP[]		= _T("iuhist_catalog.xml");
const TCHAR C_LOG_FILE_CORP_ADMIN[]	= _T("iuhist_catalogAdmin.xml");
const OLECHAR	C_IU_CORP_SITE[]	= L"IU_CORP_SITE";
const OLECHAR	C_HISTORICALSPEED[]	= L"GetHistoricalSpeed";

//
// we use a global mutex name to let all clients, including services
// on terminal servers gain exclusive access for updating history on disk
//
#if defined(UNICODE) || defined(_UNICODE)
const TCHAR C_MUTEX_NAME[] = _T("Global\\6D7495AB-399E-4768-89CC-9444202E8412");
#else
const TCHAR C_MUTEX_NAME[] = _T("6D7495AB-399E-4768-89CC-9444202E8412");
#endif

#define CanSaveHistory					(NULL != m_hMutex)
#define ReturnFailedAllocSetHrMsg(x)	{if (NULL == (x)) {hr = E_OUTOFMEMORY; LOG_ErrorMsg(hr); return hr;}}



CIUHistory::CIUHistory()
 : m_pszDownloadBasePath(NULL),
   m_bstrCurrentClientName(NULL)
{
	LOG_Block("CIUHisotry::CIUHistory()");

	m_pxmlExisting = new CXmlItems(TRUE);
	m_pxmlDownload = new CXmlItems(FALSE);
	m_pxmlInstall = new CXmlItems(FALSE);

	m_hMutex = CreateMutex(
						   NULL,	// no security descriptor
						   FALSE,	// mutex object not owned, yet
						   C_MUTEX_NAME
						   );
	if (NULL == m_hMutex)
	{
		DWORD dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		m_ErrorCode = HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
		LOG_Out(_T("Mutex created okay"));
		m_ErrorCode = S_OK;
	}

	m_fSavePending = FALSE;
}



CIUHistory::~CIUHistory()
{
	if (m_fSavePending)
	{
		SaveHistoryToDisk();
	}

	if (CanSaveHistory)
	{
		CloseHandle(m_hMutex);
	}

	if (NULL != m_pxmlExisting)
	{
		delete m_pxmlExisting;
	}

	if (NULL != m_pxmlDownload)
	{
		delete m_pxmlDownload;
	}

	if (NULL != m_pxmlInstall)
	{
		delete m_pxmlInstall;
	}

	SafeHeapFree(m_pszDownloadBasePath);
	SysFreeString(m_bstrCurrentClientName);
}



// ------------------------------------------------------------------
//
// public function SetDownloadBasePath()
//	this function should be called before AddHistoryItemDownloadStatus()
//	for corporate case to set the download path that the user has input,
//	so that we know where to save the history log.
//	
// ------------------------------------------------------------------
HRESULT CIUHistory::SetDownloadBasePath(LPCTSTR pszDownloadedBasePath)
{
	LOG_Block("SetDownloadBasePath()");

	if (NULL != pszDownloadedBasePath)
	{
        HRESULT hr = S_OK;
	    
		if (NULL != m_pszDownloadBasePath)
		{
			//
			// most likely user called SetDownloadBasePath() at least twice
			// within the same instance of this class
			//
			SafeHeapFree(m_pszDownloadBasePath);
		}

		
		m_pszDownloadBasePath = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof (TCHAR));
		if (NULL == m_pszDownloadBasePath)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			return E_OUTOFMEMORY;
		}

		hr = StringCchCopyEx(m_pszDownloadBasePath, MAX_PATH,  pszDownloadedBasePath,
		                     NULL, NULL, MISTSAFE_STRING_FLAGS);
		if (FAILED(hr))
		{
		    SafeHeapFree(m_pszDownloadBasePath);
		    LOG_ErrorMsg(hr);
		    return hr;
		}
		
		BSTR bstrCorpSite = SysAllocString(C_IU_CORP_SITE);
		SetClientName(bstrCorpSite);
		SafeSysFreeString(bstrCorpSite);
	}
	return S_OK;
}
	

	
// ------------------------------------------------------------------
//
// public function AddHistoryItemDownloadStatus()
//	this function should be called when you want to record the
//	download status of this item. A new history item will be
//	added to the history file
//	
// ------------------------------------------------------------------
HRESULT CIUHistory::AddHistoryItemDownloadStatus(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			_HISTORY_STATUS enDownloadStatus,
			LPCTSTR lpcszDownloadedTo,
			LPCTSTR lpcszClient,
			DWORD dwErrorCode /*= 0*/
)
{
    LOG_Block("AddHistoryItemDownloadStatus()");

	HRESULT	hr	= S_OK;

    HANDLE_NODE hDownloadItem = HANDLE_NODE_INVALID;

	ReturnFailedAllocSetHrMsg(m_pxmlDownload);

	if (NULL == lpcszClient || _T('\0') == lpcszClient[0])
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		return hr;
	}

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	BSTR bstrDownloadedTo = NULL;
	BSTR bstrClient = T2BSTR(lpcszClient);
	BSTR bstrDownloadStatus = GetBSTRStatus(enDownloadStatus);

	//
	// append a new node
	//
	hr = m_pxmlDownload->AddItem(pCatalog, hCatalogItem, &hDownloadItem);
	if (SUCCEEDED(hr))
	{
		m_pxmlDownload->AddTimeStamp(hDownloadItem);
		if (0 != dwErrorCode)
		{
			m_pxmlDownload->AddDownloadStatus(hDownloadItem, bstrDownloadStatus, dwErrorCode);
		}
		else
		{
			m_pxmlDownload->AddDownloadStatus(hDownloadItem, bstrDownloadStatus);
		}

		bstrDownloadedTo = T2BSTR(lpcszDownloadedTo);
		m_pxmlDownload->AddDownloadPath(hDownloadItem, bstrDownloadedTo);
		m_pxmlDownload->AddClientInfo(hDownloadItem, bstrClient);
		m_pxmlDownload->CloseItem(hDownloadItem);

		m_fSavePending = TRUE;
	}

	SetClientName(bstrClient);
	SysFreeString(bstrDownloadedTo);
	SysFreeString(bstrClient);
	SysFreeString(bstrDownloadStatus);
	return hr;
}
			


// ------------------------------------------------------------------
//
// public function AddHistoryItemInstallStatus()
//	this function should be called when you want to record the
//	install status of this item. This function will go to the
//	existing history tree and find the first item that matches
//	the identity of hCatalogItem, and assume that one as 
//	the one you want to modify the install status
//	
//
// return:
//		HRESULT - S_OK if succeeded
//				- E_HANDLE if can't find hCatalogItem from 
//				  the current history log tree
//				- or other HRESULT error
//
// ------------------------------------------------------------------
HRESULT CIUHistory::AddHistoryItemInstallStatus(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			_HISTORY_STATUS enInstallStatus,
			LPCTSTR lpcszClient,
			BOOL fNeedsReboot,
			DWORD dwErrorCode /*= 0*/
)
{
    LOG_Block("AddHistoryItemInstallStatus()");

	HRESULT	hr	= S_OK;

    HANDLE_NODE hInstallItem = HANDLE_NODE_INVALID;

	ReturnFailedAllocSetHrMsg(m_pxmlInstall);

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	BSTR bstrClient = NULL;
	BSTR bstrInstallStatus = GetBSTRStatus(enInstallStatus);
	//
	// append a new node
	//
	hr = m_pxmlInstall->AddItem(pCatalog, hCatalogItem, &hInstallItem);
	if (SUCCEEDED(hr))
	{
		m_pxmlInstall->AddTimeStamp(hInstallItem);
		if (0 != dwErrorCode)
		{
			m_pxmlInstall->AddInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot, dwErrorCode);
		}
		else
		{
			m_pxmlInstall->AddInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot);
		}
		bstrClient = T2BSTR(lpcszClient);
		m_pxmlInstall->AddClientInfo(hInstallItem, bstrClient);
		m_pxmlInstall->CloseItem(hInstallItem);
	
		m_fSavePending = TRUE;
	}

	SysFreeString(bstrClient);
	SysFreeString(bstrInstallStatus);
	return hr;
}



// ------------------------------------------------------------------
//
// public function UpdateHistoryItemInstallStatus()
//	this function should be called when you want to record the
//	install status of this item. This function will go to the
//	existing history tree and find the first item that matches
//	the identity of hCatalogItem, and assume that one as 
//	the one you want to modify the install status
//	
//
// return:
//		HRESULT - S_OK if succeeded
//				- E_HANDLE if can't find hCatalogItem from 
//				  the current history log tree
//				- or other HRESULT error
//
// ------------------------------------------------------------------
HRESULT CIUHistory::UpdateHistoryItemInstallStatus(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			_HISTORY_STATUS enInstallStatus,
			BOOL fNeedsReboot,
			DWORD dwErrorCode /*= 0*/
)
{
    LOG_Block("UpdateHistoryItemInstallStatus()");

	HRESULT	hr	= S_OK;

    HANDLE_NODE hInstallItem = HANDLE_NODE_INVALID;

	ReturnFailedAllocSetHrMsg(m_pxmlInstall);

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	BSTR bstrInstallStatus = GetBSTRStatus(enInstallStatus);
	//
	// append a new node
	//
	hr = m_pxmlInstall->FindItem(pCatalog, hCatalogItem, &hInstallItem);
	if (SUCCEEDED(hr))
	{
		m_pxmlInstall->AddTimeStamp(hInstallItem);
		if (0 != dwErrorCode)
		{
			m_pxmlInstall->UpdateItemInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot, dwErrorCode);
		}
		else
		{
			m_pxmlInstall->UpdateItemInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot);
		}
		m_pxmlInstall->CloseItem(hInstallItem);
	
		m_fSavePending = TRUE;
	}

	SysFreeString(bstrInstallStatus);
	return hr;
}



/*
// ------------------------------------------------------------------
//
// public function RetrieveItemDownloadPath()
//	this function will go to the existing history tree and find
//  the first item that matches the identity of hCatalogItem, and
//  assume that's the one you want to retrieve the download path from
//
// return:
//		HRESULT - S_OK if succeeded
//				- E_HANDLE if can't find hCatalogItem from 
//				  the current history log tree
//				- or other HRESULT error
//
// ------------------------------------------------------------------
HRESULT CIUHistory::RetrieveItemDownloadPath(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			BSTR* pbstrDownloadPath
)
{
	HRESULT	hr = S_OK;

	if (NULL == m_Existing.'DocumentPtr())
	{
		//
		// need to read the existing history
		//
		WaitForSingleObject(m_hMutex, INFINITE);

		hr = ReadHistoryFromDisk(NULL);
		if (FAILED(hr))
		{
			//
			// if we can't load the existing history
			// we can't do anything here
			//
			ReleaseMutex(m_hMutex);
			return hr;
		}

		ReleaseMutex(m_hMutex);
	}

	hr = m_Existing.GetItemDownloadPath(pCatalog, hCatalogItem, pbstrDownloadPath);
	return hr;
}		
*/	
			
			
// ------------------------------------------------------------------
//
// public function ReadHistoryFromDisk()
//	this function will read the history from the given file
//
// if the file path is NULL, assumes default IU log file locally
//
// ------------------------------------------------------------------
HRESULT CIUHistory::ReadHistoryFromDisk(LPCTSTR lpszLogFile, BOOL fCorpAdmin /*= FALSE*/)
{
	LOG_Block("ReadHistoryFromDisk()");

	HRESULT hr = S_OK;
	TCHAR szLogPath[MAX_PATH];

	ReturnFailedAllocSetHrMsg(m_pxmlExisting);

	//
	// check to see if we use designated path (comsumer)
	// or user-specified path (corporate)
	//
	if ((NULL == lpszLogFile || _T('\0') == lpszLogFile[0]) && !fCorpAdmin)
	{
		GetIndustryUpdateDirectory(szLogPath);
		hr = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_LOG_FILE);
		if (FAILED(hr))
		{
		    LOG_ErrorMsg(hr);
		    return hr;
		}
	}
	else
	{
		//
		// this is corporate case to read log file from
		// a server location
		//
		if (fCorpAdmin)
		{
			GetIndustryUpdateDirectory(szLogPath);
			hr = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_LOG_FILE_CORP_ADMIN);
    		if (FAILED(hr))
    		{
    		    LOG_ErrorMsg(hr);
    		    return hr;
    		}
		}
		else
		{
			hr = StringCchCopyEx(szLogPath, ARRAYSIZE(szLogPath), lpszLogFile, 
			                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    		if (FAILED(hr))
    		{
    		    LOG_ErrorMsg(hr);
    		    return hr;
    		}
			
			hr = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_LOG_FILE_CORP);
    		if (FAILED(hr))
    		{
    		    LOG_ErrorMsg(hr);
    		    return hr;
    		}
		}
	}

	//
	// if we are not passing in the class file path buffer,
	// then update the class path buffer with this new path
	//
	if (szLogPath != m_szLogFilePath)
	{
	    hr = StringCchCopyEx(m_szLogFilePath, ARRAYSIZE(m_szLogFilePath), szLogPath,
	                         NULL, NULL, MISTSAFE_STRING_FLAGS);
	    if (FAILED(hr))
	    {
		    LOG_ErrorMsg(hr);
		    return hr;
	    }
	}

	//
	// load the xml file
	//
	m_pxmlExisting->Clear();
	
	BSTR bstrLogPath = T2BSTR(szLogPath);
	hr = m_pxmlExisting->LoadXMLDocumentFile(bstrLogPath);
	SysFreeString(bstrLogPath);
		
	return hr;
}



// ------------------------------------------------------------------
//
// public function SaveHistoryToDisk()
//	this function will re-read the history in exclusive mode, and
//	merge the newly added data to the tree (so we don't overwrite
//	new changes made by other instances of this control) and
//	write it back 
//
// ------------------------------------------------------------------
HRESULT CIUHistory::SaveHistoryToDisk(void)
{
	LOG_Block("SaveHistoryToDisk()");

	HRESULT	hr = S_OK, hr2 = S_OK;
	BSTR bstrLogFilePath = NULL;

	ReturnFailedAllocSetHrMsg(m_pxmlExisting);
	ReturnFailedAllocSetHrMsg(m_pxmlDownload);
	ReturnFailedAllocSetHrMsg(m_pxmlInstall);

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	if (!m_fSavePending)
	{
		//
		// nothing to save
		//
		return S_OK;
	}

	//
	// first, we need to gain exclusive access
	// to the log file before reading it
	//
	// since this is not a long process, so I 
	// don't think we need to take care of WM_QUIT
	// message
	//
	WaitForSingleObject(m_hMutex, INFINITE);

	BSTR bstrCorpSite = SysAllocString(C_IU_CORP_SITE);
	ReturnFailedAllocSetHrMsg(bstrCorpSite);

	if (!CompareBSTRsEqual(bstrCorpSite, m_bstrCurrentClientName))
	{
		SysFreeString(bstrCorpSite);
		//
		// re-read history file
		//
		hr = ReadHistoryFromDisk(NULL);

		//
		// comment out...if we get failure on reading, 
		// we recreate a new history file later when saving.
		//
		//if (FAILED(hr))
		//{
		//	//
		//	// if we can't load the existing history
		//	// we can't do anything here
		//	//
		//	ReleaseMutex(m_hMutex);
		//	return hr;
		//}

		//
		// merge changes:
		// 
		// loop through m_Download, insert each node to top of m_Existing
		//
		hr = m_pxmlExisting->MergeItemDownloaded(m_pxmlDownload);
		if (FAILED(hr))
		{
			ReleaseMutex(m_hMutex);
			return hr;
		}

		//
		// loop through m_Install, for each node in m_Install
		// find the one in m_Existing, update install status
		//
		hr = m_pxmlExisting->UpdateItemInstalled(m_pxmlInstall);
		if (FAILED(hr))
		{
			ReleaseMutex(m_hMutex);
			return hr;
		}

		//
		// save the xml file
		//
		bstrLogFilePath = T2BSTR(m_szLogFilePath);
		hr = m_pxmlExisting->SaveXMLDocument(bstrLogFilePath);
		SafeSysFreeString(bstrLogFilePath);
		if (SUCCEEDED(hr))
		{
			m_fSavePending = FALSE;
		}
	}
	else
	{
		//
		// this is the corporate case...
		//
		SysFreeString(bstrCorpSite);
		if (NULL != m_pszDownloadBasePath && _T('\0') != m_pszDownloadBasePath[0])
		{
			//
			// re-read corp history from download base folder
			//
			ReadHistoryFromDisk(m_pszDownloadBasePath);

			//
			// merge new items downloaded
			// 
			hr = m_pxmlExisting->MergeItemDownloaded(m_pxmlDownload);
			if (FAILED(hr))
			{
				ReleaseMutex(m_hMutex);
				return hr;
			}

			//
			// save the xml file
			//
			bstrLogFilePath = T2BSTR(m_szLogFilePath);
			hr = m_pxmlExisting->SaveXMLDocument(bstrLogFilePath);
			SafeSysFreeString(bstrLogFilePath);
		}
		//
		// re-read corp admin history from windowsupdate folder
		//
		ReadHistoryFromDisk(m_pszDownloadBasePath, TRUE);

		//
		// merge new items downloaded
		// 
		hr2 = m_pxmlExisting->MergeItemDownloaded(m_pxmlDownload);
		if (FAILED(hr2))
		{
			ReleaseMutex(m_hMutex);
			return hr2;
		}

		//
		// save the xml file
		//
		bstrLogFilePath = T2BSTR(m_szLogFilePath);
		hr2 = m_pxmlExisting->SaveXMLDocument(bstrLogFilePath);
		SafeSysFreeString(bstrLogFilePath);
		if (SUCCEEDED(hr) && SUCCEEDED(hr2))
		{
			m_fSavePending = FALSE;
		}
	}

	ReleaseMutex(m_hMutex);
	SysFreeString(bstrLogFilePath);
	hr = SUCCEEDED(hr) ? hr2 : hr;
	return hr;
}



// ------------------------------------------------------------------
//
// public function to set the client name 
//
//	a client name is used to put in history to denode who
//	caused download/install happened.
//
// ------------------------------------------------------------------
void CIUHistory::SetClientName(BSTR bstrClientName)
{
	if (NULL != m_bstrCurrentClientName)
	{
		SysFreeString(m_bstrCurrentClientName);
		m_bstrCurrentClientName = NULL;
	}
	if (NULL != bstrClientName)
	{
		m_bstrCurrentClientName = SysAllocString(bstrClientName);
	}
}



// ------------------------------------------------------------------
//
// public function GetHistory
//
//	read the current history XML file and convert it
//	into bstr to pass out
//
// ------------------------------------------------------------------
HRESULT CIUHistory::GetHistoryStr(
				LPCTSTR lpszLogFile,
				BSTR BeginDateTime, 
				BSTR EndDateTime, 
				BSTR* pbstrHistory)
{
	LOG_Block("GetHistoryStr()");

	HRESULT	hr	= S_OK;

	ReturnFailedAllocSetHrMsg(m_pxmlExisting);

	//
	// need to read the existing history
	//
	WaitForSingleObject(m_hMutex, INFINITE);

	BSTR bstrCorpSite = SysAllocString(C_IU_CORP_SITE);
	if (bstrCorpSite == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    goto done;
	}

	if (CompareBSTRsEqual(bstrCorpSite, m_bstrCurrentClientName))
	{
		TCHAR szLogPath[MAX_PATH];
	    TCHAR szLogFileParam[MAX_PATH];

        if (lpszLogFile != NULL && lpszLogFile[0] != _T('\0'))
        {
    	    hr = StringCchCopyEx(szLogFileParam, ARRAYSIZE(szLogFileParam), lpszLogFile, 
    	                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    	    if (FAILED(hr))
    	    {
    	        LOG_ErrorMsg(hr);
    	        goto done;
    	    }

    	    hr = PathCchAddBackslash(szLogFileParam, ARRAYSIZE(szLogFileParam));
    	    if (FAILED(hr))
    	    {
    	        LOG_ErrorMsg(hr);
    	        goto done;
    	    }
        }
        else
        {
            szLogFileParam[0] = _T('\0');
        }
	    
		//
		// corporate case
		//
		GetIndustryUpdateDirectory(szLogPath);
		if (_T('\0') == szLogFileParam[0] || !lstrcmpi(szLogPath, szLogFileParam))
		{
			// corp admin history
			hr = ReadHistoryFromDisk(szLogPath, TRUE);
		}
		else
		{
			// corp history
			hr = ReadHistoryFromDisk(lpszLogFile);
		}
	}
	else
	{
	    HRESULT hrAppend;
		//
		// consumer case
		//
		hr = ReadHistoryFromDisk(NULL);

		//
		// migrate V3 history to iuhist.xml
		// - if succeeded, save the updated iuhist.xml file and delete wuhistv3.log
		// - if failed, just log error and keep using the current iuhist.xml
		//
		TCHAR szLogPath[MAX_PATH];
		GetWindowsUpdateV3Directory(szLogPath);
		hrAppend = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_V3_LOG_FILE);
		if (FAILED(hrAppend))
		{
		    LOG_ErrorMsg(hrAppend);
		    if (SUCCEEDED(hr))
		        hr = hrAppend;
		    goto done;
		}

		if (0xffffffff != GetFileAttributes(szLogPath))
		{
			// V3 history file "wuhistv3.log" exists, so start migration
			if (FAILED(m_pxmlExisting->MigrateV3History(szLogPath)))
			{
				LOG_Out(_T("Failed to migrate v3 consumer history"));
			}
			else
			{
				BSTR bstrLogFilePath = T2BSTR(m_szLogFilePath);
				if (FAILED(m_pxmlExisting->SaveXMLDocument(bstrLogFilePath)))
				{
					LOG_Out(_T("Failed to save the updated history file %s"), m_szLogFilePath);
				}
				else
				{
					DeleteFile(szLogPath);
				}
				SafeSysFreeString(bstrLogFilePath);
			}
		}
	}

done:
	ReleaseMutex(m_hMutex);
	SafeSysFreeString(bstrCorpSite);

	if (FAILED(hr))
	{
		//
		// if we can't load the existing history
		// we can't do anything here. Return empty string.
		//
		*pbstrHistory = SysAllocString(L"");
		LOG_Out(_T("Loading the history xml file failed"));
		return S_FALSE;
	}

	// 
	// traverse history tree, inspect each node
	// to see if time/clientName fit. If not, delete it
	// then output the string
	//
	hr = m_pxmlExisting->GetFilteredHistoryBSTR(BeginDateTime, EndDateTime, m_bstrCurrentClientName, pbstrHistory);

	return hr;
}



// *****************************************************************
//
// IUENGINE.DLL Public API:
//
// *****************************************************************

HRESULT WINAPI CEngUpdate::GetHistory(
	BSTR		bstrDateTimeFrom,
	BSTR		bstrDateTimeTo,
	BSTR		bstrClient,
	BSTR		bstrPath,
	BSTR*		pbstrLog)
{
	LOG_Block("GetHistory()");

	USES_IU_CONVERSION;

	HRESULT		hr = S_OK;
	BSTR		bsStart = NULL;
	BSTR		bsEnd = NULL;
	CIUHistory	cHistory;

	//
	// first, check to see if this is to ask historical speed
	//
	if (NULL != bstrClient && lstrcmpiW(C_HISTORICALSPEED, (LPWSTR)((LPOLESTR) bstrClient)) == 0)
	{
		HKEY	hKey = NULL;
		TCHAR	szSpeed[32];
		DWORD	dwSpeed = 0x0;
		DWORD	dwSize = sizeof(dwSpeed);
		LONG	lResult = ERROR_SUCCESS;

		//
		// get speed here from reg; if failure, dwSpeed remains to be 0.
		//	
		if (ERROR_SUCCESS == (lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hKey)))
		{
			lResult = RegQueryValueEx(hKey, REGVAL_HISTORICALSPEED, NULL, NULL, (LPBYTE)&dwSpeed, &dwSize);
			RegCloseKey(hKey);

			if (ERROR_SUCCESS != lResult)
			{
				*pbstrLog = SysAllocString(L"0");
				LOG_Out(_T("GetHistoricalSpeed registry key not found, it must be no downloads happened yet"));
				return hr;
			}
		}
		else
		{
			*pbstrLog = SysAllocString(L"0");
			LOG_ErrorMsg((DWORD)lResult);
			return hr;
		}

		hr = StringCchPrintfEx(szSpeed, ARRAYSIZE(szSpeed), NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("%d"), dwSpeed);
		if (FAILED(hr))
		{
		    *pbstrLog = SysAllocString(L"0");
		    LOG_ErrorMsg(hr);
		    return hr;
		}
		*pbstrLog = SysAllocString(T2OLE(szSpeed));
	
		LOG_Out(_T("GetHistoricalSpeed get called! Return value %s"), szSpeed);
		return hr;
	}

	//
	// really asking history log
	//

	//
	// set the client name
	//
	if (NULL != bstrClient && SysStringLen(bstrClient) > 0)
	{
		LOG_Out(_T("Set client name as %s"), OLE2T(bstrClient));
		cHistory.SetClientName(bstrClient);
	}
	else
	{
		LOG_Out(_T("Set client name as NULL"));
		cHistory.SetClientName(NULL);
	}

	//
	// for script: they may pass empty string. we treat them
	// as NULL
	//
	if (NULL != bstrDateTimeFrom && SysStringLen(bstrDateTimeFrom) > 0)
	{
		LOG_Out(_T("DateTimeFrom=%s"), OLE2T(bstrDateTimeFrom));
		bsStart = bstrDateTimeFrom;
	}
	if (NULL != bstrDateTimeTo && SysStringLen(bstrDateTimeTo) > 0)
	{
		LOG_Out(_T("DateTimeTo=%s"), OLE2T(bstrDateTimeTo));
		bsEnd = bstrDateTimeTo;
	}

	//
	// we do NOT validate the format of these two date/time strings.
	// They are supposed to be in XML datetime format. If not, then
	// the returned history logs may be filtered incorrectly.
	//
	hr = cHistory.GetHistoryStr(OLE2T(bstrPath), bsStart, bsEnd, pbstrLog);

	SysFreeString(bsStart);
	SysFreeString(bsEnd);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\install.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   install.cpp
//
//  Description:
//
//      Implementation for the Install() function
//
//=======================================================================

#include "iuengine.h"	// PCH - must include first
#include <iu.h>
#include <iucommon.h>
#include <trust.h>
#include <install.h>
#include <fileutil.h>
#include <shlwapi.h>
#include <srrestoreptapi.h>
#include <iuprogress.h>
#include "history.h"
#include "iuxml.h"
//#include <serverPing.h>
#include <logging.h>
#include <UrlLogging.h>

#define AVERAGE_IDENTITY_SIZE_PER_ITEM 200
#define SafeFreeLibrary(x) if (NULL != x) { FreeLibrary(x); x = NULL; }
const TCHAR SFCDLL[] = _T("sfc.dll");
const TCHAR SYSTEMRESTOREDESCRIPTION[] = _T("Windows Update V4");
const CHAR	SZ_INSTALL_FINISHED[] = "Install finished";
const CHAR	SZ_INSTALLASYNC_FAILED[] = "Asynchronous Install failed during startup";

typedef BOOL (WINAPI * PFN_SRSetRestorePoint)(PRESTOREPOINTINFO pRestorePtSpec, PSTATEMGRSTATUS pSMgrStatus);

typedef struct IUINSTALLSTARTUPINFO
{
    BSTR bstrXmlClientInfo;
    BSTR bstrXmlCatalog;
	BSTR bstrXmlDownloadedItems;
    BSTR bstrOperationUUID;
    LONG lMode;
    IUnknown *punkProgressListener;
    HWND hwnd;
	CEngUpdate* pEngUpdate;
} IUINSTALLSTARTUPINFO, *PIUINSTALLSTARTUPINFO;

DWORD WINAPI InstallThreadProc(LPVOID lpv);

class CIUInstall
{
public:
    CIUInstall(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrXmlDownloadedItems, BSTR bstrOperationUUID, LONG lMode, IUnknown *punkProgressListener, HWND hWnd);
    ~CIUInstall();

public:
    HRESULT ProcessInstallCatalog(CEngUpdate* pEngUpdate);
    HRESULT GetXmlItemsBSTR(BSTR *pbstrXmlItems);

private:
    HRESULT RecursiveInstallDependencies(HANDLE_NODE hItem, CEngUpdate* pEngUpdate);
    HRESULT DoInstall(HANDLE_NODE hItem, CEngUpdate* pEngUpdate);
	void RemoveDownloadTemporaryFolders(LPCTSTR pszComponentPath);
	void PingServerForInstall(HRESULT hr, HANDLE_NODE hItem, PHANDLE phEvtNeedToQuit, LPCTSTR lpszDeviceId=NULL, BOOL fExclusive=FALSE);

private:
    BSTR        m_bstrXmlClientInfo;
    BSTR        m_bstrClientName;
    BSTR        m_bstrXmlCatalog;
    BSTR        m_bstrOperationUUID;
    BSTR        m_bstrXmlResult;
    LONG        m_lMode;
    IProgressListener* m_pProgressListener;
    HWND        m_hWnd;

    CXmlCatalog m_xmlCatalog;
    CXmlItems   m_xmlItems;
    CXmlItems   *m_pxmlDownloadedItems;
    CXmlClientInfo m_xmlClientInfo;
    CIUHistory  m_history;
	CUrlLog		m_pingSvr;

    DWORD       m_dwStatus;

    LPTSTR      m_pszInstalledItemsList;
    LPTSTR      m_pszItemDownloadPathListForDelete;
    LONG        m_lInstalledItemsListAllocatedLength;
    LONG        m_lItemDownloadPathListForDeleteLength;

    LONG        m_lItemCount;
    LONG        m_lItemsCompleted;

    BOOL        m_fAbort;
    BOOL        m_fSomeItemsSuccessful;
};

CIUInstall::CIUInstall(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrXmlDownloadedItems, BSTR bstrOperationUUID, LONG lMode, IUnknown *punkProgressListener, HWND hWnd)
  : m_pProgressListener(NULL),
    m_bstrXmlClientInfo(NULL),
    m_bstrClientName(NULL),
    m_bstrXmlCatalog(NULL),
    m_bstrOperationUUID(NULL),
    m_bstrXmlResult(NULL),
    m_lMode(lMode),
    m_hWnd(hWnd),
    m_dwStatus(0),
    m_pszInstalledItemsList(NULL),
    m_pszItemDownloadPathListForDelete(NULL),
    m_lInstalledItemsListAllocatedLength(0),
    m_lItemDownloadPathListForDeleteLength(0),
    m_lItemCount(0),
    m_lItemsCompleted(0),
    m_fAbort(FALSE),
    m_fSomeItemsSuccessful(FALSE),
    m_pxmlDownloadedItems(NULL)
{
    USES_IU_CONVERSION;

    m_bstrXmlClientInfo = SysAllocString(bstrXmlClientInfo);
    m_bstrXmlCatalog = SysAllocString(bstrXmlCatalog);
    m_bstrOperationUUID = SysAllocString(bstrOperationUUID);
    
    if (NULL != punkProgressListener)
    {
        punkProgressListener->QueryInterface(IID_IProgressListener, (void**)&m_pProgressListener);
    }

	m_pxmlDownloadedItems = new CXmlItems(TRUE);
	if (NULL != m_pxmlDownloadedItems)
	{
		m_pxmlDownloadedItems->LoadXMLDocument(bstrXmlDownloadedItems);
	}
}

CIUInstall::~CIUInstall()
{
    SysFreeString(m_bstrXmlClientInfo);
    SysFreeString(m_bstrClientName);
    SysFreeString(m_bstrXmlCatalog);
    SysFreeString(m_bstrOperationUUID);
    SafeReleaseNULL(m_pProgressListener);
    SafeHeapFree(m_pszInstalledItemsList);
    SafeHeapFree(m_pszItemDownloadPathListForDelete);
    SysFreeString(m_bstrXmlResult);

    if (NULL != m_pxmlDownloadedItems)
    {
        delete m_pxmlDownloadedItems;
    }
}

HRESULT CIUInstall::GetXmlItemsBSTR(BSTR *pbstrXmlItems)
{
    if (NULL != m_bstrXmlResult)
        *pbstrXmlItems = SysAllocString(m_bstrXmlResult);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Install()
//
// Do synchronous installation.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// punkProgressListener - the callback function pointer for reporting install progress
// hWnd - the event msg window handler passed from the stub
// Output:
// pbstrXmlItems - the items with installation status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::Install(BSTR bstrXmlClientInfo,
                       BSTR	bstrXmlCatalog,
					   BSTR bstrXmlDownloadedItems,
					   LONG lMode,
					   IUnknown *punkProgressListener,
					   HWND hWnd,
					   BSTR *pbstrXmlItems)
{
    HRESULT hr;

    if ((DWORD) lMode & (DWORD) UPDATE_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

	LogMessage("Install started");

    CIUInstall iuInstall(bstrXmlClientInfo, bstrXmlCatalog, bstrXmlDownloadedItems, NULL, lMode, punkProgressListener, hWnd);
    hr = iuInstall.ProcessInstallCatalog(this);
    iuInstall.GetXmlItemsBSTR(pbstrXmlItems);

    return hr;
}

HRESULT CIUInstall::ProcessInstallCatalog(CEngUpdate* pEngUpdate)
{
    LOG_Block("ProcessInstallCatalog()");

    // clear any previous cancel event
    ResetEvent(pEngUpdate->m_evtNeedToQuit);

    HRESULT     hr = S_OK, hrString = S_OK;
    HANDLE_NODE hCatalogItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hProviderList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hDependentItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hDependentItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hProvider = HANDLE_NODE_INVALID;
    BSTR        bstrPlatform = NULL;
    BSTR        bstrUniqueIdentity = NULL;
    BSTR        bstrProviderName = NULL;
    BSTR        bstrProviderPublisher = NULL;
    BSTR        bstrProviderUUID = NULL;
    TCHAR       szUniqueIdentitySearch[MAX_PATH];
    HINSTANCE   hSystemRestoreDLL = NULL;
    PFN_SRSetRestorePoint fpnSRSetRestorePoint = NULL;
    RESTOREPOINTINFO restoreInfo;
    STATEMGRSTATUS   restoreStatus;	
	BOOL		fContinue = TRUE;
	LPTSTR ptszLivePingServerUrl = NULL;
	LPTSTR ptszCorpPingServerUrl = NULL;
	BOOL fPostWaitSuccess = TRUE;


    DWORD       dwStatus = 0;

    USES_IU_CONVERSION;

	EventData evtData;
	ZeroMemory((LPVOID) &evtData, sizeof(evtData));

	if (NULL == m_pxmlDownloadedItems)
	{
		// Error occured during object initialization, no Return Schema Available
		// Cannot continue
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
        goto CleanUp;
	}

    hr = m_xmlCatalog.LoadXMLDocument(m_bstrXmlCatalog, pEngUpdate->m_fOfflineMode);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    hr = m_xmlClientInfo.LoadXMLDocument(m_bstrXmlClientInfo, pEngUpdate->m_fOfflineMode);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    m_xmlClientInfo.GetClientName(&m_bstrClientName);
    if (NULL == m_bstrClientName)
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    m_pingSvr.SetDefaultClientName(OLE2T(m_bstrClientName));

	if (NULL != (ptszLivePingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (SUCCEEDED(g_pUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			m_pingSvr.SetLiveServerUrl(ptszLivePingServerUrl);
		}
		else
		{
			LOG_Out(_T("failed to get live ping server URL"));
		}
		SafeHeapFree(ptszLivePingServerUrl);
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszLivePingServerUrl"));
	}

	if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (SUCCEEDED(g_pUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			m_pingSvr.SetCorpServerUrl(ptszCorpPingServerUrl);
		}
		else
		{
			LOG_Out(_T("failed to get corp WU ping server URL"));
		}
		SafeHeapFree(ptszCorpPingServerUrl);
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
	}

    m_xmlCatalog.GetItemCount(&m_lItemCount);
    SafeHeapFree(m_pszInstalledItemsList);
    m_lInstalledItemsListAllocatedLength = m_lItemCount * (AVERAGE_IDENTITY_SIZE_PER_ITEM * sizeof(TCHAR));
    m_pszInstalledItemsList = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_lInstalledItemsListAllocatedLength);
    if (NULL == m_pszInstalledItemsList)
    {
		hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    SafeHeapFree(m_pszItemDownloadPathListForDelete);
    m_lItemDownloadPathListForDeleteLength = m_lItemCount * (MAX_PATH * sizeof(TCHAR));
    m_pszItemDownloadPathListForDelete = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_lItemDownloadPathListForDeleteLength);
    if (NULL == m_pszItemDownloadPathListForDelete)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    // try to load the System Restore DLL (sfc.dll).
    hSystemRestoreDLL = LoadLibraryFromSystemDir(SFCDLL);
    if (NULL != hSystemRestoreDLL)
    {
#ifdef UNICODE
        fpnSRSetRestorePoint = (PFN_SRSetRestorePoint)GetProcAddress(hSystemRestoreDLL, "SRSetRestorePointW");
#else
        fpnSRSetRestorePoint = (PFN_SRSetRestorePoint)GetProcAddress(hSystemRestoreDLL, "SRSetRestorePointA");
#endif
        if (NULL != fpnSRSetRestorePoint)
        {
            // Set the Restore Point
            ZeroMemory(&restoreInfo, sizeof(restoreInfo));
            ZeroMemory(&restoreStatus, sizeof(restoreStatus));
            restoreInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
            restoreInfo.dwRestorePtType = APPLICATION_INSTALL;
            restoreInfo.llSequenceNumber = 0;

            hr = StringCchCopyEx(restoreInfo.szDescription, ARRAYSIZE(restoreInfo.szDescription),
                                 SYSTEMRESTOREDESCRIPTION,
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }

            if (!fpnSRSetRestorePoint(&restoreInfo, &restoreStatus))
            {
                // this will return FALSE if there is an error 'or' if its called from an OS without SystemRestore
                // support. SR is only supported on Professional and Personal SKU's of Whistler.
                if (ERROR_SUCCESS != restoreStatus.nStatus)
                {
                    LOG_Software(_T("Failed SRSetRestorePoint Call, Error was: 0x%x"), restoreStatus.nStatus);
					LogError(restoreStatus.nStatus, "Install Set Restore Point");
                }
            }
        }
    }


	//
	// added by JHou for bug#433 in IU db: send 0:N OnProgress event before the install begins
	//
    TCHAR szProgress[64];
    hr = StringCchPrintfEx(szProgress, ARRAYSIZE(szProgress), NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%lu:0"), (ULONG)m_lItemCount);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
	evtData.bstrProgress = SysAllocString(T2OLE(szProgress));
    if (NULL != m_pProgressListener)
    {
        m_pProgressListener->OnProgress(m_bstrOperationUUID, VARIANT_FALSE, evtData.bstrProgress, &evtData.lCommandRequest);
    }
    else
    {
        if (NULL != m_hWnd)
        {
            evtData.fItemCompleted = FALSE;
            evtData.bstrUuidOperation = SysAllocString(m_bstrOperationUUID);
            SendMessage(m_hWnd, UM_EVENT_PROGRESS, 0, LPARAM(&evtData));
        }
    }

	//
	// Need to check for a cancel command returned from OnProgress
	//
	if (UPDATE_COMMAND_CANCEL == evtData.lCommandRequest)
	{
		LOG_Out(_T("OnProgress received UPDATE_COMMAND_CANCEL"));
		SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
		hr = E_ABORT;
		fContinue = FALSE;
	}

    // Install has a complexity in how we loop through to install each item. Basically
    // we have to handle any dependent Item installs before installing core Item
    // Since Detection will already have been done at this point we rely on the caller
    // to only give us the list of items that really need to be installed. What we'll do
    // is go through each item and before actually installing it we'll look for any 
    // dependent items that are also in the catalog. If they are in the Catalog then it is
    // assumed it needs to be installed. This check is done recursively for each item.

    // start the base item loop.
    hProviderList = m_xmlCatalog.GetFirstProvider(&hProvider);
    while (HANDLE_NODE_INVALID != hProvider && fContinue)
    {
        m_xmlCatalog.GetIdentity(hProvider, &bstrProviderName, &bstrProviderPublisher, &bstrProviderUUID);
        SafeSysFreeString(bstrProviderName);
        SafeSysFreeString(bstrProviderPublisher);
        SafeSysFreeString(bstrProviderUUID);

        // Get the Enumerator List of Items in this Catalog, and get the first item
        hCatalogItemList = m_xmlCatalog.GetFirstItem(hProvider, &hItem);
        if ((HANDLE_NODELIST_INVALID == hCatalogItemList) || (HANDLE_NODE_INVALID == hItem))
        {
            hr = E_FAIL;
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

		//
        // loop through each item in the catalog, calling the installer for each one
		//
        while (HANDLE_NODE_INVALID != hItem && fContinue)
        {
			BSTR bstrXmlItemForCallback = NULL;
			if (SUCCEEDED(m_xmlCatalog.GetBSTRItemForCallback(hItem, &bstrXmlItemForCallback)))
			{
				if (NULL != m_pProgressListener)
				{
					m_pProgressListener->OnItemStart(m_bstrOperationUUID, bstrXmlItemForCallback, &evtData.lCommandRequest);
				}
				else
				{
					if (NULL != m_hWnd)
					{
						evtData.bstrXmlData = bstrXmlItemForCallback;
                        SendMessage(m_hWnd, UM_EVENT_ITEMSTART, 0, LPARAM(&evtData));
						evtData.bstrXmlData = NULL;
					}
				}
				SysFreeString(bstrXmlItemForCallback);
				bstrXmlItemForCallback = NULL;
				if (UPDATE_COMMAND_CANCEL == evtData.lCommandRequest)
				{
					LOG_Out(_T("OnItemStart received UPDATE_COMMAND_CANCEL"));
					SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
					hr = E_ABORT;
					fContinue = FALSE;
				}
				else
				{
					//
					// check the global quit event. If quit, then server ping treat it as a cancel.
					//
					fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
				}
				if (!fContinue)
				{
					continue;	// or break, same effect.
				}
			}
			else
			{
				//
				// something wrong with this item, so we should skip it
				//
				// get the next item. hItem will be HANDLE_NODE_INVALID when there are no
				// remaining items.
				m_xmlCatalog.CloseItem(hItem);
				m_xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
				continue;
			}

            // We have an Item in the Catalog to be Installed. First Look for any Top
            // level dependencies
            hDependentItemList = m_xmlCatalog.GetFirstItemDependency(hItem, &hDependentItem);
            if (HANDLE_NODELIST_INVALID != hDependentItemList)
            {
                
                hr = S_OK;
                while (S_OK == hr)
                {
                    // walk each dependent Item and call the Recursive Installer
                    if (HANDLE_NODE_INVALID != hDependentItem)
                    {
                        // Check if we have installed this item already in this session
                        m_xmlCatalog.GetIdentityStr(hDependentItem, &bstrUniqueIdentity);
                        hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS,
                                                     _T("%ls|"), bstrUniqueIdentity);
                        SafeSysFreeString(bstrUniqueIdentity);
                        if (FAILED(hrString))
                        {
                            // The string check for the unique identity is an optimization to prevent installing the same item more
                            // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
                            // the item. There is no real problem with installing the same item more than once, its just ineffecient.
                            LOG_ErrorMsg(hrString);
                        }
                        else
                        {
                            if (NULL != StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
                            {
                                // we have already installed this item, skip to the next one.
                                m_xmlCatalog.CloseItem(hDependentItem);
                                hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
                                continue;
                            }
                        }

                        // There is a Item in the Catalog that is a dependency of the Item we
                        // are installing and we haven't installed it yet, so Call the 
                        // RecursiveInstaller to handle this one first
                        hr = RecursiveInstallDependencies(hDependentItem, pEngUpdate);
                    }

                    // Get the next Dependent Item - will Return S_FALSE when there are
                    // no more items.
                    m_xmlCatalog.CloseItem(hDependentItem);
                    hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
                }
                m_xmlCatalog.CloseItemList(hDependentItemList);
            }

            if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
            {
                m_xmlCatalog.CloseItem(hItem);
                goto CleanUp;
            }

            // Check if we have installed this item already in this session
            m_xmlCatalog.GetIdentityStr(hItem, &bstrUniqueIdentity);
            hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                         NULL, NULL, MISTSAFE_STRING_FLAGS,
                                         _T("%ls|"), bstrUniqueIdentity);
            SafeSysFreeString(bstrUniqueIdentity);
            if (FAILED(hrString))
            {
                // The string check for the unique identity is an optimization to prevent installing the same item more
                // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
                // the item. There is no real problem with installing the same item more than once, its just ineffecient.
                LOG_ErrorMsg(hrString);
            }
            else
            {
                if (NULL == StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
                {
                    // we have NOT installed this item in this session
                    hr = DoInstall(hItem, pEngUpdate);
                }
            }

            if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
            {
                m_xmlCatalog.CloseItem(hItem);
                goto CleanUp;
            }

            // get the next item. hItem will be HANDLE_NODE_INVALID when there are no
            // remaining items.
            m_xmlCatalog.CloseItem(hItem);
            m_xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
        }
        m_xmlCatalog.CloseItem(hProvider);
        m_xmlCatalog.GetNextProvider(hProviderList, &hProvider);
    }

CleanUp:
    // BUG: 441316: Earlier in the install process we left the downloaded files on the machine to
    // support this bug which involves installing Multi Function Device Drivers, Now we want to enumerate
    // the list of download source paths and all folders/files from them.
    if (NULL != m_pszItemDownloadPathListForDelete)
    {
        LPTSTR pszWalk = m_pszItemDownloadPathListForDelete;
        LPTSTR pszChr = NULL;
        while (_T('\0') != *pszWalk)
        {
            pszChr = StrChr(pszWalk, _T('|'));
            if (NULL != pszChr)
            {
                *pszChr = _T('\0');
                // Call RemoveDownloadTemporaryFolders to delete this folder path
                RemoveDownloadTemporaryFolders(pszWalk);
                *pszChr = _T('|');
                pszWalk = pszChr + 1; // skip to next character
            }
        }
    }

	//
	// add HRESULT in case the install failed before the install loop
	//
	if (S_OK != hr)
	{
		m_xmlItems.AddGlobalErrorCodeIfNoItems(hr);
	}

    m_xmlItems.GetItemsBSTR(&m_bstrXmlResult); // get result for Caller and to Send OnOperationComplete
    if (NULL != m_pProgressListener)
    {
        m_pProgressListener->OnOperationComplete(m_bstrOperationUUID, m_bstrXmlResult);
    }
    else
    {
        if (NULL != m_hWnd)
        {
			if (NULL == evtData.bstrUuidOperation)
			{
				evtData.bstrUuidOperation = SysAllocString(m_bstrOperationUUID);
			}
            evtData.bstrXmlData = SysAllocString(m_bstrXmlResult);
            evtData.fItemCompleted = TRUE;
            fPostWaitSuccess = WUPostEventAndBlock(m_hWnd, 
                                                   UM_EVENT_COMPLETE, 
                                                   &evtData);
        }
    }

    if ((NULL != fpnSRSetRestorePoint) && (ERROR_SUCCESS == restoreStatus.nStatus))
    {
        if (!m_fSomeItemsSuccessful)
        {
            // need to revert our systemrestore point, no successful installs were done.
            restoreInfo.dwEventType = END_SYSTEM_CHANGE;
            restoreInfo.dwRestorePtType = CANCELLED_OPERATION;
            restoreInfo.llSequenceNumber = restoreStatus.llSequenceNumber;
            fpnSRSetRestorePoint(&restoreInfo, &restoreStatus);
        }
        else
        {
            // signal the end of the restore point change.
            restoreInfo.dwEventType = END_SYSTEM_CHANGE;
            restoreInfo.llSequenceNumber = restoreStatus.llSequenceNumber;
            fpnSRSetRestorePoint(&restoreInfo, &restoreStatus);
            m_fSomeItemsSuccessful = FALSE;
        }
    }

	if (SUCCEEDED(hr))
	{
		LogMessage("%s %s", SZ_SEE_IUHIST, SZ_INSTALL_FINISHED);
	}
	else
	{
		LogError(hr, "%s %s", SZ_SEE_IUHIST, SZ_INSTALL_FINISHED);
	}
    
    fpnSRSetRestorePoint = NULL;
    SafeFreeLibrary(hSystemRestoreDLL);

    // don't free up the strings below unless the wait succeeded in 
    //  WUPostEventAndBlock.  If we do free the strings up and the wait didn't
    //  succeed, then we run the risk of AVing ourselves.  Note that fPostWaitSuccess
    //  is initialized to TRUE so if we will free these BSTRs if WUPostEventAndBlock
    //  is not called.
    if (fPostWaitSuccess)
    {
    	SafeSysFreeString(evtData.bstrProgress);
    	SafeSysFreeString(evtData.bstrUuidOperation);
    	SafeSysFreeString(evtData.bstrXmlData);
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// InstallAsync()
//
// Install Asynchronously.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// punkProgressListener - the callback function pointer for reporting install progress
// hWnd - the event msg window handler passed from the stub
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID.
//                      Otherwise, it allocates and copies the value passed by bstrUuidOperation.        
//                      The caller is responsible for freeing the memory returned in
//                      pbstrUuidOperation using SysFreeString(). 
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::InstallAsync(BSTR bstrXmlClientInfo,
                            BSTR bstrXmlCatalog,
							BSTR bstrXmlDownloadedItems,
							LONG lMode,
							IUnknown *punkProgressListener,
							HWND hWnd,
							BSTR bstrUuidOperation,
                            BSTR *pbstrUuidOperation)
{
    HRESULT  hr = S_OK;
    DWORD    dwThreadId;
    DWORD    dwErr;
    HANDLE   hThread = NULL;
    GUID     guid;
    LPOLESTR pwszUuidOperation = NULL;
    PIUINSTALLSTARTUPINFO pStartupInfo;

    LOG_Block("InstallAsync()");

	LogMessage("Asynchronous Install started");

    if ((NULL == bstrXmlCatalog) || (NULL == pbstrUuidOperation))
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
		LogError(hr, SZ_INSTALLASYNC_FAILED);
        return hr;
    }

	*pbstrUuidOperation = NULL;

    if (NULL == (pStartupInfo = (PIUINSTALLSTARTUPINFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IUINSTALLSTARTUPINFO))))
	{
		hr = E_OUTOFMEMORY;
		LOG_ErrorMsg(hr);
		LogError(hr, SZ_INSTALLASYNC_FAILED);
		return hr;
	}

    if ((DWORD) lMode & (DWORD) UPDATE_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

	//
	// 481020 IU - Getting a blank for bstrUuidOperation in the
	// oIUControl_OnItemStart/OnProgress/OnOperationComplete events
	// when calling InstallAsync
	//
	// Also found that BSTRs were leaking (now freed), and that if bstrUuidOperation
	// was NULL or zero length, we need to generate a GUID, so this is done
	// prior to allocating (again) for pStartupInfo->bstrOperationUUID
	//
    if (NULL != bstrUuidOperation && SysStringLen(bstrUuidOperation) > 0)
    {
        *pbstrUuidOperation = SysAllocString(bstrUuidOperation);
    }
    else
    {
        hr = CoCreateGuid(&guid);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
			LogError(hr, SZ_INSTALLASYNC_FAILED);
            return hr;
        }
        hr = StringFromCLSID(guid, &pwszUuidOperation);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
			LogError(hr, SZ_INSTALLASYNC_FAILED);
            return hr;
        }
        *pbstrUuidOperation = SysAllocString(pwszUuidOperation);
        CoTaskMemFree(pwszUuidOperation);
    }


    pStartupInfo->lMode = lMode;
    pStartupInfo->hwnd = hWnd;
    pStartupInfo->punkProgressListener = punkProgressListener;
	pStartupInfo->pEngUpdate = this;
    pStartupInfo->bstrXmlClientInfo = SysAllocString(bstrXmlClientInfo);
    pStartupInfo->bstrXmlCatalog = SysAllocString(bstrXmlCatalog);
	pStartupInfo->bstrXmlDownloadedItems = SysAllocString(bstrXmlDownloadedItems);
	pStartupInfo->bstrOperationUUID = SysAllocString(*pbstrUuidOperation);

	LOG_XmlBSTR(pStartupInfo->bstrXmlClientInfo);
	LOG_XmlBSTR(pStartupInfo->bstrXmlCatalog);
	LOG_XmlBSTR(pStartupInfo->bstrXmlDownloadedItems);

    InterlockedIncrement(&m_lThreadCounter);

	if (NULL != pStartupInfo->punkProgressListener)
	{
		pStartupInfo->punkProgressListener->AddRef();
	}
    hThread = CreateThread(NULL, 0, InstallThreadProc, (LPVOID)pStartupInfo, 0, &dwThreadId);
    if (NULL == hThread)
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        LOG_ErrorMsg(hr);
		SysFreeString(pStartupInfo->bstrXmlClientInfo);
		SysFreeString(pStartupInfo->bstrXmlCatalog);
		SysFreeString(pStartupInfo->bstrXmlDownloadedItems);
		SysFreeString(pStartupInfo->bstrOperationUUID);
		SafeRelease(pStartupInfo->punkProgressListener);
        SafeHeapFree(pStartupInfo);
		SysFreeString(*pbstrUuidOperation);
		*pbstrUuidOperation = NULL;
		InterlockedDecrement(&m_lThreadCounter);
		LogError(hr, SZ_INSTALLASYNC_FAILED);
        return hr;
    }

	if (SUCCEEDED(hr))
	{
		LogMessage("Asynchronous Install completed startup");
	}
	else
	{
		LogError(hr, SZ_INSTALLASYNC_FAILED);
	}

    return hr;
}


DWORD WINAPI InstallThreadProc(LPVOID lpv)
{
	USES_IU_CONVERSION;

	LOG_Block("InstallThreadProc");

    PIUINSTALLSTARTUPINFO pStartupInfo = (PIUINSTALLSTARTUPINFO)lpv;
    HRESULT hr = CoInitialize(NULL);

	if (SUCCEEDED(hr))
	{
		LOG_Out(_T("CoInitialize called successfully"));
	}

    {
        // we need to scope this object so it destructs before we decrement our thread counter
        // If we didn't do this and the control was unloading while the thread closed we would fault
        // when the engine unloaded and this class was destructing.
        CIUInstall iuInstall(pStartupInfo->bstrXmlClientInfo, pStartupInfo->bstrXmlCatalog, pStartupInfo->bstrXmlDownloadedItems, pStartupInfo->bstrOperationUUID, pStartupInfo->lMode, pStartupInfo->punkProgressListener, pStartupInfo->hwnd);
        iuInstall.ProcessInstallCatalog(pStartupInfo->pEngUpdate);
    }

	SysFreeString(pStartupInfo->bstrXmlClientInfo);
	SysFreeString(pStartupInfo->bstrXmlCatalog);
	SysFreeString(pStartupInfo->bstrXmlDownloadedItems);
	SysFreeString(pStartupInfo->bstrOperationUUID);
	SafeRelease(pStartupInfo->punkProgressListener);

    if (SUCCEEDED(hr))
	{
		CoUninitialize();
		LOG_Out(_T("CoUninitialize called"));
	}

    InterlockedDecrement(&pStartupInfo->pEngUpdate->m_lThreadCounter);

	SafeHeapFree(pStartupInfo);

    return 0;
}

HRESULT CIUInstall::RecursiveInstallDependencies(HANDLE_NODE hItem, CEngUpdate* pEngUpdate)
{
    LOG_Block("RecursiveInstallDependencies()");
    BOOL fRet = FALSE;
    HRESULT hr = S_FALSE, hrString;

    HANDLE_NODE hDependentItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hDependentItem = HANDLE_NODE_INVALID;

    BSTR bstrUniqueIdentity = NULL;
    TCHAR szUniqueIdentitySearch[MAX_PATH];

    // Check to see if this item has dependencies
    hDependentItemList = m_xmlCatalog.GetFirstItemDependency(hItem, &hDependentItem);
    if (HANDLE_NODELIST_INVALID != hDependentItemList)
    {
        hr = S_OK;
        while (S_OK == hr)
        {
            // walk each dependent Item and call the Recursive Installer
            if (HANDLE_NODE_INVALID != hDependentItem)
            {
                // Check if we have installed this item already in this session
                m_xmlCatalog.GetIdentityStr(hDependentItem, &bstrUniqueIdentity);
                hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                             NULL, NULL, MISTSAFE_STRING_FLAGS,
                                             _T("%ls|"), bstrUniqueIdentity);
                SafeSysFreeString(bstrUniqueIdentity);
                if (FAILED(hrString))
                {

                    // The string check for the unique identity is an optimization to prevent installing the same item more
                    // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
                    // the item. There is no real problem with installing the same item more than once, its just ineffecient.
                    LOG_ErrorMsg(hrString);
                }
                else
                {
                    if (NULL != StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
                    {
                        // we have already installed this item, skip to the next one.
                        m_xmlCatalog.CloseItem(hDependentItem);
                        hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
                        continue;
                    }
                }

                // There is a Item in the Catalog that is a dependency of the Item we
                // are installing and we haven't installed it yet, so Call the 
                // RecursiveInstaller to handle this one first
                hr = RecursiveInstallDependencies(hDependentItem, pEngUpdate);
            }

            // Get the next Dependent Item - will Return S_FALSE when there are
            // no more items.
            m_xmlCatalog.CloseItem(hDependentItem);
            hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
        }

        m_xmlCatalog.CloseItemList(hDependentItemList);
    }

    // if all installs have succeeded up to this point (hr should be S_FALSE when all 
    // nested installs have completed)
    if (SUCCEEDED(hr))
    {
        // No More Recursive Dependencies, Install This Item - Recursive Functions will unwind
        // Installing each nested item as it goes.
        // Check if we have installed this item already in this session
        m_xmlCatalog.GetIdentityStr(hItem, &bstrUniqueIdentity);
        hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                     NULL, NULL, MISTSAFE_STRING_FLAGS,
                                     _T("%ls|"), bstrUniqueIdentity);
        SafeSysFreeString(bstrUniqueIdentity);
        if (FAILED(hrString))
        {
            LOG_ErrorMsg(hrString);

            // The string check for the unique identity is an optimization to prevent installing the same item more
            // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
            // the item. There is no real problem with installing the same item more than once, its just ineffecient.
            hr = DoInstall(hItem, pEngUpdate);
        }
        else
        {
            if (NULL == StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
            {
                // we have NOT installed this item in this session
                hr = DoInstall(hItem, pEngUpdate);
            }
        }
    }
    return hr;
}


HRESULT CIUInstall::DoInstall(HANDLE_NODE hItem, CEngUpdate* pEngUpdate)
{
    LOG_Block("DoInstall()");
    HRESULT hr, hrString;

    USES_IU_CONVERSION;

    BSTR  bstrName = NULL;
    BSTR  bstrPublisherName = NULL;
    BSTR  bstrItemUUID = NULL;
    BSTR  bstrInstallerType = NULL;
    BSTR  bstrCommand = NULL;
    BSTR  bstrSwitches = NULL;
    BSTR  bstrCommandType = NULL;
    BSTR  bstrInfSection = NULL;
    BSTR  bstrItemDownloadPath = NULL;
    BSTR  bstrDriverName = NULL;
    BSTR  bstrArchitecture = NULL;
    BSTR  bstrHWID = NULL;
    BSTR  bstrDisplayName = NULL;
    BSTR  bstrUniqueIdentity = NULL;
    BSTR  bstrCodeBase = NULL;
    BSTR  bstrCRC = NULL;
    BSTR  bstrFileName = NULL;
    TCHAR szProgress[64];
    TCHAR szCommandType[64];
    TCHAR szInstallerType[256];
    TCHAR szItemSourcePath[MAX_PATH];
    TCHAR szCabFilePath[MAX_PATH];
    LPTSTR pszCabUrl = NULL;
    LPTSTR pszAllocatedFileName = NULL;
    LPTSTR pszLocalFileName = NULL;
    LONG  lItemCommandCount = 0;
    LONG  lListNeededLength = 0;
    LONG  lSize;
    BOOL  fInstallerNeedsReboot = FALSE;
    BOOL  fExclusive = FALSE;
    BOOL  fPatch;
    BOOL  fContinue = TRUE;
    PINSTALLCOMMANDINFO pCommandInfoArray = NULL;
    DWORD dwStatus = ITEM_STATUS_FAILED;
    HANDLE_NODE hXmlItem = HANDLE_NODE_INVALID;
    HANDLE_NODELIST hItemCodeBaseList = HANDLE_NODELIST_INVALID;
    EventData evtData;
	ZeroMemory((LPVOID) &evtData, sizeof(evtData));

    LPTSTR pszClientName = OLE2T(m_bstrClientName);

    m_dwStatus = ITEM_STATUS_FAILED; // default install status to failure
    
    hr = m_xmlCatalog.GetIdentity(hItem, &bstrName, &bstrPublisherName, &bstrItemUUID);
    if (FAILED(hr))
    {
        LOG_Software(_T("Failed to get an Identity for an Item (invalid document??)"));
		LogError(hr, "Install failed to get an Item Identity");
        goto CleanUp;
    }

    hr = m_pxmlDownloadedItems->GetItemDownloadPath(&m_xmlCatalog, hItem, &bstrItemDownloadPath);
    if (NULL == bstrItemDownloadPath)
    {
        LOG_Software(_T("Failed to get Item Download Path"));
        if (SUCCEEDED(hr))
            hr = E_FAIL;
		LogError(hr, "Install couldn't get Item %ls Download Path", bstrName);
        goto CleanUp;
    }

    hr = StringCchCopyEx(szItemSourcePath, ARRAYSIZE(szItemSourcePath), 
                         OLE2T(bstrItemDownloadPath),
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    SafeSysFreeString(bstrItemDownloadPath);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    

    hr = m_xmlCatalog.GetItemInstallInfo(hItem, &bstrInstallerType, &fExclusive, &fInstallerNeedsReboot, &lItemCommandCount);
    if (FAILED(hr))
    {
        LOG_Software(_T("Failed to get ItemInstallInfo for Item %ls"), bstrName);
		LogError(hr, "Failed to get Item %ls Install Information", bstrName);
        goto CleanUp;
    }

	LogMessage("Installing %ls item from publisher %ls", bstrInstallerType, bstrPublisherName);

    if (lItemCommandCount > 0)
    {
        // Allocate INSTALLCOMMANDINFO array and fill out with command info
        pCommandInfoArray = (PINSTALLCOMMANDINFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
            sizeof(INSTALLCOMMANDINFO) * lItemCommandCount);
        if (NULL == pCommandInfoArray)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
			LogError(hr, "Install Command processing");
            goto CleanUp;
        }
    }

    for (LONG lCnt = 0; lCnt < lItemCommandCount; lCnt++)
    {
        // Get Install Command Information for each Command
        m_xmlCatalog.GetItemInstallCommand(hItem, lCnt, &bstrCommandType, &bstrCommand, &bstrSwitches, &bstrInfSection);
        if (NULL == bstrCommandType || NULL == bstrCommand)
        {
            hr = E_INVALIDARG;
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LogMessage("Installer Command Type: %ls", bstrCommandType);

        // Copy the Command to Execute
        hr = StringCchCopyEx(pCommandInfoArray[lCnt].szCommandLine, ARRAYSIZE(pCommandInfoArray[lCnt].szCommandLine),
                             OLE2T(bstrCommand),
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        hr = StringCchCopyEx(szCommandType, ARRAYSIZE(szCommandType), OLE2T(bstrCommandType),
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        
        if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
			szCommandType, -1, _T("INF"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_INF;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
			szCommandType, -1, _T("ADVANCED_INF"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_ADVANCEDINF;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
			szCommandType, -1, _T("EXE"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_EXE;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
			szCommandType, -1, _T("WI"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_MSI;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
			szCommandType, -1, _T("CUSTOM"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_CUSTOM;
        }
        else
        {
            LOG_Software(_T("Unable to determine Installer Type %s"), szCommandType);
            pCommandInfoArray[lCnt].iCommandType = 0; // unknown
        }

        // Copy the Command Line Parameters (if any)
        if (NULL != bstrSwitches)
        {
            hr = StringCchCopyEx(pCommandInfoArray[lCnt].szCommandParameters, ARRAYSIZE(pCommandInfoArray[lCnt].szCommandParameters),
                                 OLE2T(bstrSwitches),
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
        }

        if (NULL != bstrInfSection)
        {
            hr = StringCchCopyEx(pCommandInfoArray[lCnt].szInfSection, ARRAYSIZE(pCommandInfoArray[lCnt].szInfSection),
                                 OLE2T(bstrInfSection),
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
        }
    
        SafeSysFreeString(bstrCommandType);
        SafeSysFreeString(bstrCommand);
        SafeSysFreeString(bstrSwitches);
        SafeSysFreeString(bstrInfSection);
    }

    // Before we start the install we need to verify the signature on all cabs of this item. This is to verify that they
    // haven't been tampered with between download and install (especially during non-consumer scenarios)
    hItemCodeBaseList = m_xmlCatalog.GetItemFirstCodeBase(hItem, &bstrCodeBase, &bstrFileName, &bstrCRC, &fPatch, &lSize);
    if ((HANDLE_NODELIST_INVALID == hItemCodeBaseList) || (NULL == bstrCodeBase))
    {
        LOG_Software(_T("Item %s has no Cabs, cannot verify signature"), bstrName);
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    while (fContinue && NULL != bstrCodeBase)
    {
        if (NULL != bstrFileName && SysStringLen(bstrFileName) > 0)
        {
            if (NULL != pszAllocatedFileName)
            {
                MemFree(pszAllocatedFileName);
            }
            pszAllocatedFileName = OLE2T(bstrFileName);
        }
        else // no special filename specified, use filename from URL
        {
            if (NULL != pszCabUrl)
            {
                MemFree(pszCabUrl);
            }
            pszCabUrl = OLE2T(bstrCodeBase);
			// search for the last forward slash (will separate the URL from the filename)
            LPTSTR pszLastSlash = StrRChr(pszCabUrl, NULL, _T('/'));
            // if the last slash was found, skip to next character (will be the beginning of the filename)
            if (NULL != pszLastSlash)
                pszLastSlash++;
            pszLocalFileName = pszLastSlash;
        }

        hr = PathCchCombine(szCabFilePath, ARRAYSIZE(szCabFilePath),
                            szItemSourcePath, (NULL != pszAllocatedFileName) ? pszAllocatedFileName : pszLocalFileName);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            m_xmlCatalog.CloseItemList(hItemCodeBaseList);
            goto CleanUp;
        }
        
        hr = VerifyFileTrust(szCabFilePath, 
                             NULL, 
                             ReadWUPolicyShowTrustUI()
                             );
        if (FAILED(hr))
        {
            // Cab File Failed Trust Validation
            LOG_ErrorMsg(hr);
            m_xmlCatalog.CloseItemList(hItemCodeBaseList);
            goto CleanUp;
        }
        SafeSysFreeString(bstrCodeBase);
        SafeSysFreeString(bstrFileName);
        SafeSysFreeString(bstrCRC);
        fContinue = SUCCEEDED(m_xmlCatalog.GetItemNextCodeBase(hItemCodeBaseList, &bstrCodeBase, &bstrFileName, &bstrCRC, &fPatch, &lSize)) &&
            (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
    }

    // If this item is Exclusive we need to write something to the history to indicate that the install has started
	// Normally an exclusive item won't return control back to the installer so no other history information will be
	// available
	if (fExclusive)
	{
        m_history.AddHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_IN_PROGRESS, pszClientName, fInstallerNeedsReboot, S_OK);
		m_history.SaveHistoryToDisk();
		PingServerForInstall(hr, hItem, &(pEngUpdate->m_evtNeedToQuit), NULL, TRUE);	// ping exclusive item now
	}

    // Call Install Library with Item Information

    hr = StringCchCopyEx(szInstallerType, ARRAYSIZE(szInstallerType), OLE2T(bstrInstallerType),
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
    if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
		szInstallerType, -1, _T("SOFTWARE"), -1))
    {
        if (lItemCommandCount == 0)
        {
            LOG_Software(_T("Item %s has no Commands.. cannot install"), bstrName);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
        hr = InstallSoftwareItem(szItemSourcePath, fInstallerNeedsReboot, lItemCommandCount, pCommandInfoArray, &dwStatus);
    }
    else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
		szInstallerType, -1, _T("CDM"), -1))
    {
        if (m_xmlCatalog.IsPrinterDriver(hItem))
        {
            // Printer Driver
            m_xmlCatalog.GetPrinterDriverInfo(hItem, &bstrDriverName, &bstrArchitecture);
            SafeSysFreeString(bstrArchitecture); // not used yet, should be NULL from xmlCatalog.GetPrinterDriverInfo()

            hr = InstallPrinterDriver(OLE2T(bstrDriverName), szItemSourcePath, NULL, &dwStatus);
			if (FAILED(hr))
			{
				LogError(hr, "Installing Printer Driver %ls", bstrDriverName);
			}
        }
        else
        {
            // Normal Device Driver
            m_xmlCatalog.GetDriverInfo(hItem, &bstrHWID, &bstrDisplayName);

            hr = InstallDriver(szItemSourcePath, OLE2T(bstrDisplayName), OLE2T(bstrHWID), &dwStatus);
			if (FAILED(hr))
			{
				LogError(hr, "Installing PnP Driver %ls, %ls", bstrHWID, bstrDisplayName);
			}
            SafeSysFreeString(bstrDisplayName);
        }
    }

    // Bug 441336: Deleting all files on a successful install of an item causes some problems with
    // Multi Function Device Drivers, these show up as multiple instances of the same 'item', share
    // the same downloaded driver package, but have different HWID's. The Item's all have different
    // identities because the calling application is making them unique when they recognize a MFD
    // driver package. We need to purposely leave the downloaded files installed until the 'very' end
    // of the installation process, so all items have a chance to be installed.
    // So, we will no longer perform this deletion step here, but will instead enumerate the InstalledItemsList
    // and remove the folders for each one.

    // Regardless of Success or Failure, update the Count of Items Installed
    m_lItemsCompleted++;

    // Add this Item to the InstalledItemsList
    m_xmlCatalog.GetIdentityStr(hItem, &bstrUniqueIdentity);
    lListNeededLength = (lstrlen(m_pszInstalledItemsList) + lstrlen(OLE2T(bstrUniqueIdentity)) + 2) * sizeof(TCHAR);
    if (lListNeededLength > m_lInstalledItemsListAllocatedLength)
    {
        // need to reallocate the installeditemlist
        LPTSTR pszNew = (LPTSTR) HeapReAlloc(GetProcessHeap(), 
                                             0, 
                                             m_pszInstalledItemsList, 
                                             m_lInstalledItemsListAllocatedLength * 2);

        if (NULL != pszNew)
        {
            m_pszInstalledItemsList = pszNew;
            m_lInstalledItemsListAllocatedLength *= 2;

            // only do this if the realloc worked, if it didn't we won't be adding more items
            hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength,
                               OLE2T(bstrUniqueIdentity),
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }

            hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength, _T("|"),
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }
        }
    }
    else
    {
        // only do this if the realloc worked, if it didn't we won't be adding more items
        hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength,
                           OLE2T(bstrUniqueIdentity),
                           NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hrString))
        {
            LOG_ErrorMsg(hrString);
        }

        hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength, _T("|"),
                           NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hrString))
        {
            LOG_ErrorMsg(hrString);
        }
    }

    if (SUCCEEDED(hr))
    {
        lListNeededLength = (lstrlen(m_pszItemDownloadPathListForDelete) + lstrlen(szItemSourcePath) + 2) * sizeof(TCHAR);
        if (lListNeededLength > m_lItemDownloadPathListForDeleteLength)
        {
            // need to reallocate the downloadpathitemlist
            LPTSTR pszNew = (LPTSTR) HeapReAlloc(GetProcessHeap(),
                                                 0,
                                                 m_pszItemDownloadPathListForDelete,
                                                 m_lItemDownloadPathListForDeleteLength * 2);
            if (NULL != pszNew)
            {
                m_pszItemDownloadPathListForDelete = pszNew;
                m_lItemDownloadPathListForDeleteLength *= 2;

                // only do this if the realloc worked, if it didn't we won't be adding more items
                hrString = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength,
                                   szItemSourcePath,
                                   NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hrString))
                {
                    LOG_ErrorMsg(hrString);
                }

                hrString = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength, _T("|"),
                                   NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hrString))
                {
                    LOG_ErrorMsg(hrString);
                }
            }
        }
        else
        {
            hrString = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength,
                               szItemSourcePath,
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }

            hr = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength, _T("|"),
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }
        }
    }

CleanUp:

	//
	// Could have gotten here with stale hr if client called SetOperationMode
	//
    if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
    {
        hr = E_ABORT;
    }

    m_xmlItems.AddItem(&m_xmlCatalog, hItem, &hXmlItem);

    if (ITEM_STATUS_SUCCESS_REBOOT_REQUIRED == dwStatus)
    {
        fInstallerNeedsReboot = TRUE;
    }

    if (ITEM_STATUS_FAILED == dwStatus)
    {
		if (fExclusive)
		{
			m_history.UpdateHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_FAILED, fInstallerNeedsReboot, hr);
		}
		else
		{
			m_history.AddHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_FAILED, pszClientName, fInstallerNeedsReboot, hr);
		}
		m_xmlItems.AddInstallStatus(hXmlItem, KEY_STATUS_FAILED, 0, hr);
    }
    else
    {
        // install completed successfully
		if (fExclusive)
		{
	        m_history.UpdateHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_COMPLETE, fInstallerNeedsReboot, 0);
		}
		else
		{
			m_history.AddHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_COMPLETE, pszClientName, fInstallerNeedsReboot, 0);
		}
        if (ITEM_STATUS_INSTALLED_ERROR == dwStatus)
        {
            LOG_Software(_T("Item Installed However there were Minor Errors"));
        }
        m_xmlItems.AddInstallStatus(hXmlItem, KEY_STATUS_COMPLETE, fInstallerNeedsReboot, 0);
        m_fSomeItemsSuccessful = TRUE; // any success in the install operation should set to true
    }

   	//
	// ping server to report the download status for this item
	//
	if (!fExclusive)
	{
		//
		// if we haven't done so, ping server now
		//
		LPCTSTR pDeviceId = NULL;
		if (NULL != bstrDriverName) 
		{
			pDeviceId = OLE2T(bstrDriverName);
		}
		else if (NULL != bstrHWID)
		{
			pDeviceId = OLE2T(bstrHWID);
		}
		PingServerForInstall(hr, hItem, &(pEngUpdate->m_evtNeedToQuit), pDeviceId);
	}

    if ((DWORD) m_lMode & (DWORD) UPDATE_NOTIFICATION_COMPLETEONLY)
    {
        // Only Send OnOperationComplete, we won't send any progress messages.
    }
    else
    {
        // Send all Progress Messages
        hrString = StringCchPrintfEx(szProgress, ARRAYSIZE(szProgress), NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("%lu:%lu"), (ULONG)m_lItemCount, (ULONG)m_lItemsCompleted);
        if (SUCCEEDED(hrString))
        {
			evtData.bstrProgress = SysAllocString(T2OLE(szProgress));
            if (NULL != m_pProgressListener)
            {
                m_pProgressListener->OnProgress(m_bstrOperationUUID, VARIANT_TRUE, evtData.bstrProgress, &evtData.lCommandRequest);
            }
            else
            {
                if (NULL != m_hWnd)
                {
                    evtData.fItemCompleted = TRUE;
                    evtData.bstrUuidOperation = SysAllocString(m_bstrOperationUUID);
                    SendMessage(m_hWnd, UM_EVENT_PROGRESS, 0, LPARAM(&evtData));
                }
            }
        }
        else
        {
            LOG_ErrorMsg(hrString);
        }
		//
		// Need to check for a cancel command returned from OnProgress
		//
		if (UPDATE_COMMAND_CANCEL == evtData.lCommandRequest)
		{
			LOG_Out(_T("OnProgress received UPDATE_COMMAND_CANCEL"));
			SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit, we'll handle it in WaitForSingleObject
		}
    }

    m_dwStatus = dwStatus; // return the status up the chain

    SafeHeapFree(pCommandInfoArray);
    SysFreeString(bstrName);
    SysFreeString(bstrPublisherName);
    SysFreeString(bstrItemUUID);
    SysFreeString(bstrInstallerType);
    SafeSysFreeString(bstrCommandType);
    SafeSysFreeString(bstrCommand);
    SafeSysFreeString(bstrSwitches);
    SafeSysFreeString(bstrInfSection);
    SafeSysFreeString(bstrHWID);
    SafeSysFreeString(bstrDriverName);
	SafeSysFreeString(evtData.bstrProgress);
	SafeSysFreeString(evtData.bstrUuidOperation);

	//
	// Could have missed change during lengthy ping or OnProgress
	//
    if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
    {
        hr = E_ABORT;
    }

    return hr;
}


//
// RemoveDownloadTemporaryFolders
//
// This helper function is called after the install is successfully finished
// in DoInstall() to delete the temporary component directory and all files underneath
//
void CIUInstall::RemoveDownloadTemporaryFolders(LPCTSTR pszComponentPath)
{
	LOG_Block("CIUInstall::RemoveDownloadTemporaryFolders()");

    HRESULT hr;
    TCHAR szBuffer[MAX_PATH], szDeleteFile[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind;

	hr = PathCchCombine(szBuffer, ARRAYSIZE(szBuffer), pszComponentPath, _T("*.*"));
	if (FAILED(hr))
	{
	    LOG_ErrorMsg(hr);
	    return;
	}

	hFind = FindFirstFile(szBuffer, &fd);
	BOOL fMore = (hFind != INVALID_HANDLE_VALUE);
	while (fMore)
	{
		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
		{
			hr = PathCchCombine(szDeleteFile, ARRAYSIZE(szDeleteFile), pszComponentPath, fd.cFileName);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    goto doneCurrentEntry;
			}
			
			if (!DeleteFile(szDeleteFile))
			{
				// Try waiting a bit before trying one last time. 
				Sleep(1000);
				DeleteFile(szDeleteFile);
			}
		}
		else if (_T('.') != fd.cFileName[0] && 
		         (_T('\0') != fd.cFileName[1] || 
		          (_T('.') != fd.cFileName[1] && _T('\0') != fd.cFileName[2])))
		{
			hr = PathCchCombine(szBuffer, ARRAYSIZE(szDeleteFile), pszComponentPath, fd.cFileName);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    goto doneCurrentEntry;
			}
			RemoveDownloadTemporaryFolders(szBuffer);
		}
		
doneCurrentEntry:	
		fMore = FindNextFile(hFind, &fd);
	}
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);
			
	BOOL fSuccess = RemoveDirectory(pszComponentPath);
	if (!fSuccess)
	{
		// Try waiting a bit before trying one last time. 
		Sleep(1000);
		fSuccess = RemoveDirectory(pszComponentPath);
	}
}



//
// private utility function to ping server for installation activity. 
// since there are two places we do this, so wrap this in a function to safe size
//
void CIUInstall::PingServerForInstall(HRESULT hr, HANDLE_NODE hItem, PHANDLE phEvtNeedToQuit, LPCTSTR lpszDeviceId /*=NULL*/, BOOL fExclusive /*=FALSE*/)
{
	LOG_Block("CIUInstall::PingServerForInstall()");

	BSTR bstrIdentity = NULL;

	USES_IU_CONVERSION;

	if (SUCCEEDED(m_xmlCatalog.GetIdentityStrForPing(hItem, &bstrIdentity)))
	{
		BOOL fOnLine = (0 == ((DWORD) m_lMode & (DWORD) UPDATE_OFFLINE_MODE));
		URLLOGSTATUS status = SUCCEEDED(hr) ? URLLOGSTATUS_Success : URLLOGSTATUS_Failed;
		if (fExclusive)
		{
			status = URLLOGSTATUS_Pending;
		}
		if (m_fAbort)
		{
			//
			// user/system cancelled the current process
			//
			hr = E_ABORT;
			status = URLLOGSTATUS_Cancelled;
		}

		m_pingSvr.Ping(
					fOnLine,						// on-line
					URLLOGDESTINATION_DEFAULT,		// going to live or corp WU server
					phEvtNeedToQuit,				// pt to cancel events
					1,								// number of events
					URLLOGACTIVITY_Installation,	// activity
					status,							// status code
					hr,								// error code, can be 0 or 1
					OLE2T(bstrIdentity),			// itemID
					lpszDeviceId					// add'l device data for driver update
					);
	}

	SafeSysFreeString(bstrIdentity);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\engmain.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   engmain.cpp
//
//  Description:
//
//      DllMain and globals for the IUEngine DLL
//
//=======================================================================

#include "iuengine.h"
#include "iucommon.h"
#include "download.h"
#include <limits.h>


//***********************************************************************
// 
// The following definitions are copied from IUCtl.IDL.
// If IUCtl.IDL is changed, these constants need to be
// changed accordingly
//
//***********************************************************************


/**
* the following two groups of constants can be used to construct
* lMode parameter of the following APIs:
*		Download()
*		DownloadAsync()
*		Install()
*		InstallAsync()
*
* Obviousely, you can only pick one from each group to make up
* lMode parameter.
*
*/
const LONG		UPDATE_NOTIFICATION_DEFAULT			= 0x00000000;    
const LONG		UPDATE_NOTIFICATION_ANYPROGRESS		= 0x00000000;
const LONG		UPDATE_NOTIFICATION_COMPLETEONLY	= 0x00010000;
const LONG		UPDATE_NOTIFICATION_1PCT			= 0x00020000;
const LONG		UPDATE_NOTIFICATION_5PCT			= 0x00040000;
const LONG		UPDATE_NOTIFICATION_10PCT			= 0x00080000;

/**
* constant can also be used for SetOperationMode() and GetOperationMode()
*/
const LONG		UPDATE_MODE_THROTTLE				= 0x00000100;    

/**
* constant can be used by Download() and DownloadAsync(), which will
* tell these API's to use Corporate directory structure for destination folder.
*/
const LONG		UPDATE_CORPORATE_MODE			= 0x00000200;    

/**
* constant can be used by Install() and InstallAsync(). Will disable all
* internet related features
*/
const LONG      UPDATE_OFFLINE_MODE                 = 0x00000400;

/**
* constants for SetOperationMode() API
*/
const LONG		UPDATE_COMMAND_PAUSE				= 0x00000001;
const LONG		UPDATE_COMMAND_RESUME				= 0x00000002;
const LONG		UPDATE_COMMAND_CANCEL				= 0x00000004;

/**
* constants for GetOperationMode() API
*/
const LONG		UPDATE_MODE_PAUSED					= 0x00000001;
const LONG		UPDATE_MODE_RUNNING					= 0x00000002;
const LONG		UPDATE_MODE_NOTEXISTS				= 0x00000004;


/**
* constants for SetProperty() and GetProperty() API
*/
const LONG		UPDATE_PROP_USECOMPRESSION			= 0x00000020;
const LONG      UPDATE_PROP_OFFLINEMODE             = 0x00000080;

/**
* constants for BrowseForFolder() API
*	IUBROWSE_WRITE_ACCESS - validate write access on selected folder
*	IUBROWSE_AFFECT_UI - write-access validation affect OK button enable/disable
*	IUBROWSE_NOBROWSE - do not show browse folder dialog box. validate path passed-in only
*
*	default:
*		pop up browse folder dialog box, not doing any write-access validation
*		
*/
const LONG		IUBROWSE_WRITE_ACCESS				= 1;
const LONG		IUBROWSE_AFFECT_UI					= 2;
const LONG		IUBROWSE_NOBROWSE					= 4;


CEngUpdate*  g_pCDMEngUpdate;		// single global instance used by CDM within the process
CRITICAL_SECTION g_csCDM;			// used to serialize access to g_pCDMEngUpdate
CRITICAL_SECTION g_csGlobalClasses;	// used to serialize access to CSchemaKeys::Initialize() and
BOOL gfInit_csCDM, gfInit_csGC;
									// CSchemaKeys::Uninitialize()
ULONG g_ulGlobalClassRefCount;			// Reference count to track how many CEngUpdate instances are
									// using the g_pGlobalSchemaKeys object
LONG g_lDoOnceOnLoadGuard;			// Used to prevent AsyncExtraWorkUponEngineLoad() from doing
									// any work after the first time it is called.

//
// Used to control shutdown of global threads
//
LONG g_lThreadCounter;
HANDLE g_evtNeedToQuit;
CUrlAgent *g_pUrlAgent = NULL;


BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		//
		// create a global CUrlAgent object
		//
		if (NULL == (g_pUrlAgent = new CUrlAgent) ||
			FAILED(g_pUrlAgent->PopulateData()))
		{
			return FALSE;
		}
			
		DisableThreadLibraryCalls(hInstance);
        g_hinst = hInstance;

		gfInit_csCDM = SafeInitializeCriticalSection(&g_csCDM);
		gfInit_csGC = SafeInitializeCriticalSection(&g_csGlobalClasses);

		//
		// each global thread when started, should increase this counter
		// before exit, should decrease this counter,
		// such that ShutdownGlobalThreads() knows when it can return
		//
		g_lThreadCounter = 0;

		//
		// create a manual-reset event with init state non-signaled. 
		// each global thread will check this event, when signalled, it means
		// the thread should exit ASAP.
		//
		g_evtNeedToQuit = CreateEvent(NULL, TRUE, FALSE, NULL);

		//
		// Initialize free logging
		//
		InitFreeLogging(_T("IUENGINE"));
		LogMessage("Starting");

		if (!gfInit_csCDM ||!gfInit_csGC)
		{
			LogError(E_FAIL, "InitializeCriticalSection");
			return FALSE;
		}
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (NULL != g_evtNeedToQuit)
		{
			CloseHandle(g_evtNeedToQuit);
		}

		if (NULL != g_pUrlAgent)
		{
			delete g_pUrlAgent;
		}

		if (gfInit_csCDM)
		{
			DeleteCriticalSection(&g_csCDM);
		}
		if (gfInit_csGC)
		{
			DeleteCriticalSection(&g_csGlobalClasses);
		}

		//
		// Shutdown free logging
		//
		LogMessage("Shutting down");
		TermFreeLogging();
    }
    return TRUE;
}


// ----------------------------------------------------------------------
//
// DLL API: CompleteSelfUpdateProcess()
//
// call by IUCtl.dll after downloading the new IUEngine.dll to complete
// any selfupdate steps beyond update the engine itself.
// 
// ----------------------------------------------------------------------
HRESULT WINAPI CompleteSelfUpdateProcess()
{
    LOG_Block("CompleteSelfUpdateProcess()");
    HRESULT hr = S_OK;

    // Nothing to do yet, just return S_OK.

	LogMessage("IUEngine update completed");
    return hr;
}

// ----------------------------------------------------------------------
//
// DLL API: PingIUEngineUpdateStatus
//
// Used by iuctl.dll to ping status of iuengine.dll supdate
// 
// ----------------------------------------------------------------------
HRESULT WINAPI PingIUEngineUpdateStatus(
				PHANDLE phQuitEvents,			// ptr to handles for cancelling the operation
				UINT nQuitEventCount,			// number of handles
				LPCTSTR ptszLiveServerUrl,
				LPCTSTR ptszCorpServerUrl,
				DWORD dwError,					// error code
				LPCTSTR ptszClientName			// client name string
)
{
	HRESULT hr;

	if (NULL == phQuitEvents || 1 > nQuitEventCount)
	{
		return E_INVALIDARG;
	}

	CUrlLog pingSvr(
				NULL == ptszClientName ? _T("iu") : ptszClientName,
				ptszLiveServerUrl,
				ptszCorpServerUrl);

	hr = pingSvr.Ping(
					TRUE,							// force online
					URLLOGDESTINATION_DEFAULT,		// going to live or corp WU server
					phQuitEvents,					// pt to cancel events
					nQuitEventCount,				// number of events
					URLLOGACTIVITY_Initialization,	// activity
					SUCCEEDED(dwError) ? URLLOGSTATUS_Success : URLLOGSTATUS_Failed,	// status code
					dwError							// error code
				);

	return hr;
}

// ----------------------------------------------------------------------
//
// DLL API: CreateEngUpdateInstance()
//
// Returns a CEngUpdate instance pointer cast to HIUENGINE, or NULL if it fails.
// 
// ----------------------------------------------------------------------
HIUENGINE WINAPI CreateEngUpdateInstance()
{
	LOG_Block("CreateEngUpdateInstance");

	return reinterpret_cast<HIUENGINE>(new CEngUpdate);
}

// ----------------------------------------------------------------------
//
// DLL API: DeleteEngUpdateInstance()
//
// Returns a CEngUpdate instance pointer, or NULL if it fails.
// 
// ----------------------------------------------------------------------
void WINAPI DeleteEngUpdateInstance(HIUENGINE hIUEngine)
{
	LOG_Block("DeleteEngUpdateInstance");

	if (NULL != hIUEngine)
	{
		delete (reinterpret_cast<CEngUpdate*>(hIUEngine));
	}
}

// ----------------------------------------------------------------------
//
// DLL API: Stubs to export CEngUpdate functionality across DLL boundry
//
// ----------------------------------------------------------------------

HRESULT EngGetSystemSpec(HIUENGINE hIUEngine, BSTR bstrXmlClasses, DWORD dwFlags, BSTR *pbstrXmlDetectionResult)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetSystemSpec(bstrXmlClasses, dwFlags, pbstrXmlDetectionResult);
}

HRESULT EngGetManifest(HIUENGINE hIUEngine, BSTR	bstrXmlClientInfo, BSTR	bstrXmlSystemSpec, BSTR	bstrXmlQuery, DWORD dwFlags, BSTR *pbstrXmlCatalog)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetManifest(bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, dwFlags, pbstrXmlCatalog);
}

HRESULT EngDetect(HIUENGINE hIUEngine, BSTR bstrXmlCatalog, DWORD dwFlags, BSTR *pbstrXmlItems)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->Detect(bstrXmlCatalog, dwFlags, pbstrXmlItems);
}

HRESULT EngDownload(HIUENGINE hIUEngine,BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder,
					LONG lMode, IUnknown *punkProgressListener, HWND hWnd, BSTR *pbstrXmlItems)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->Download(bstrXmlClientInfo, bstrXmlCatalog, bstrDestinationFolder,
					lMode, punkProgressListener, hWnd, pbstrXmlItems);
}

HRESULT EngDownloadAsync(HIUENGINE hIUEngine,BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog,
						 BSTR bstrDestinationFolder, LONG lMode, IUnknown *punkProgressListener, 
						HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrUuidOperation)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->DownloadAsync(bstrXmlClientInfo, bstrXmlCatalog,
						bstrDestinationFolder, lMode, punkProgressListener, 
						hWnd, bstrUuidOperation, pbstrUuidOperation);
}

HRESULT EngInstall(HIUENGINE hIUEngine,
				   BSTR bstrXmlClientInfo,
                   BSTR	bstrXmlCatalog,
				   BSTR bstrXmlDownloadedItems,
				   LONG lMode,
				   IUnknown *punkProgressListener,
				   HWND hWnd,
				   BSTR *pbstrXmlItems)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->Install(bstrXmlClientInfo,
                   bstrXmlCatalog,
				   bstrXmlDownloadedItems,
				   lMode,
				   punkProgressListener,
				   hWnd,
				   pbstrXmlItems);
}

HRESULT EngInstallAsync(HIUENGINE hIUEngine,
						BSTR bstrXmlClientInfo,
                        BSTR bstrXmlCatalog,
						BSTR bstrXmlDownloadedItems,
						LONG lMode,
						IUnknown *punkProgressListener,
						HWND hWnd,
						BSTR bstrUuidOperation,
                        BSTR *pbstrUuidOperation)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->InstallAsync(bstrXmlClientInfo,
                        bstrXmlCatalog,
						bstrXmlDownloadedItems,
						lMode,
						punkProgressListener,
						hWnd,
						bstrUuidOperation,
                        pbstrUuidOperation);
}

HRESULT EngSetOperationMode(HIUENGINE hIUEngine, BSTR bstrUuidOperation, LONG lMode)
{
	//
	// 502965 Windows Error Reporting bucket 2096553: Hang following NEWDEV.DLL!CancelDriverSearch
	//
	// Special-case this function for NULL == hIUEngine to allow access
	// by CDM to g_pCDMEngUpdate for CDM.DLL's in .NET Server / SP1 and later
	//
	if (NULL == hIUEngine)
	{
		if (NULL == g_pCDMEngUpdate)
		{
			return E_INVALIDARG;
		}
		else
		{
			return g_pCDMEngUpdate->SetOperationMode(bstrUuidOperation, lMode);
		}
	}
	else
	{
		//
		// Normal case (instance handle passed in)
		//
		return (reinterpret_cast<CEngUpdate*>(hIUEngine))->SetOperationMode(bstrUuidOperation, lMode);
	}
}

HRESULT EngGetOperationMode(HIUENGINE hIUEngine, BSTR bstrUuidOperation, LONG* plMode)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetOperationMode(bstrUuidOperation, plMode);
}

HRESULT EngGetHistory(HIUENGINE hIUEngine,
	BSTR		bstrDateTimeFrom,
	BSTR		bstrDateTimeTo,
	BSTR		bstrClient,
	BSTR		bstrPath,
	BSTR*		pbstrLog)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetHistory(bstrDateTimeFrom, bstrDateTimeTo, bstrClient, bstrPath, pbstrLog);
}

HRESULT EngBrowseForFolder(HIUENGINE hIUEngine,
						   BSTR bstrStartFolder, 
						LONG flag, 
						BSTR* pbstrFolder)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->BrowseForFolder(bstrStartFolder, flag, pbstrFolder);
}

HRESULT EngRebootMachine(HIUENGINE hIUEngine)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->RebootMachine();
}

// ----------------------------------------------------------------------
//
// DLL API: CreateGlobalCDMEngUpdateInstance()
//
// Initializes the single (global) CEngUpdate instance to be used by CDM
// 
// ----------------------------------------------------------------------
HRESULT WINAPI CreateGlobalCDMEngUpdateInstance()
{
	LOG_Block("CreateGlobalCDMEngUpdateInstance");

	HRESULT hr = S_OK;

	EnterCriticalSection(&g_csCDM);

	if (NULL != g_pCDMEngUpdate)
	{
		LOG_Error(_T("Another thread in process is already using CDM functionality"));
		hr = E_ACCESSDENIED;
		goto CleanUp;
	}

	CleanUpFailedAllocSetHrMsg(g_pCDMEngUpdate = new CEngUpdate);

CleanUp:

	LeaveCriticalSection(&g_csCDM);

	return hr;
}

// ----------------------------------------------------------------------
//
// DLL API: DeleteGlobalCDMEngUpdateInstance()
//
// Deletes the single (global) CEngUpdate instance used by CDM.
// 
// ----------------------------------------------------------------------
HRESULT WINAPI DeleteGlobalCDMEngUpdateInstance()
{
	LOG_Block("DeleteGlobalCDMEngUpdateInstance");

	HRESULT hr = S_OK;

	EnterCriticalSection(&g_csCDM);

	//
	// Unfortunately (due to backwards compatibility with XPClient V4 CDM)
	// we can't tell if this was reached via CDM calling UnloadIUEngine
	// or some other client (e.g. AU) within the scope of a CDM instance.
	//
	// As a result, CDM's instance could get deleted at the wrong time
	// causing further calls to CDM to fail with E_INVALIDARG. Nothing
	// we can do about it because we reach hear after the other client's
	// instance is already deleted, so we can't use g_ulGlobalClassRefCount
	// as a guard against this. However AU and CDM should never be in the
	// same process, so we should be OK. CDM will coexist with instances
	// created via the iuctl COM object since they never call then old
	// ShutdownThreads export.
	//
	if (NULL != g_pCDMEngUpdate)
	{
		delete g_pCDMEngUpdate;
		g_pCDMEngUpdate = NULL;
		LOG_Driver(_T("CDM's global instance of CEngUpdate was deleted"));
	}
	//
	// ELSE this would be the case when iuctl!UnLoadIUEngine is
	// called from a client other than CDM, such as AU
	//
	LeaveCriticalSection(&g_csCDM);

	return hr;
}

CEngUpdate::CEngUpdate()
{
	LOG_Block("CEngUpdate::CEngUpdate");

	HRESULT hr;
	//
	// each thread when start, should increase this counter
	// before exit, should decrease this counter,
	// such that ShutdownInstanceThreads() knows when it can return
	//
	m_lThreadCounter = 0;

	//
	// create a manual-reset event with init state non-signaled. 
	// each thread will check this event, when signalled, it means
	// the thread should exit ASAP.
	//
	m_evtNeedToQuit = CreateEvent(NULL, TRUE, FALSE, NULL);

	//
	// If needed, create a global CSchemaKeys object, but always
	// keep global ref count so we know when to delete
	//
	EnterCriticalSection(&g_csGlobalClasses);

	//
	// Construct the global object
	//
	if (NULL == g_pGlobalSchemaKeys)
	{
		g_pGlobalSchemaKeys = new CSchemaKeys;
	}

#if defined(DBG)
	//
	// We don't worry about this for practical purposes (will fail to construct
	// CEngUpdate before we reach this limit), but maybe on ia64 with huge
	// amounts of memory in a test scenario?
	//
	if (ULONG_MAX == g_ulGlobalClassRefCount)
	{
		LOG_Error(_T("g_ulGlobalClassRefCount is already ULONG_MAX and we are trying to add another"));
	}
#endif

	g_ulGlobalClassRefCount++;
	LOG_Out(_T("g_ulGlobalClassRefCount is now %d"), g_ulGlobalClassRefCount);

	LeaveCriticalSection(&g_csGlobalClasses);
}

CEngUpdate::~CEngUpdate()
{
	LOG_Block("CEngUpdate::~CEngUpdate");

	HRESULT hr;
	//
	// First shut down any outstanding threads
	//
	this->ShutdownInstanceThreads();

    if (NULL != m_evtNeedToQuit)
	{
		CloseHandle(m_evtNeedToQuit);
	}
	//
	// Always Uninitialize global CSchemaKeys object
	//
	EnterCriticalSection(&g_csGlobalClasses);

#if defined(DBG)
	//
	// Paranoid check for coding error
	//
	if (0 == g_ulGlobalClassRefCount)
	{
		LOG_Error(_T("Unbalanced calls to CEngUpdate ctor and dtor"));
	}
#endif

	g_ulGlobalClassRefCount--;
	LOG_Out(_T("g_ulGlobalClassRefCount is now %d"), g_ulGlobalClassRefCount);

	if (0 == g_ulGlobalClassRefCount)
	{
		//
		// The last CEngUpdate instance is going away, delete the
		// global CSchemaKeys object
		//
		if (NULL != g_pGlobalSchemaKeys)
		{
			delete g_pGlobalSchemaKeys;
			g_pGlobalSchemaKeys = NULL;
		}
		else
		{
			LOG_Error(_T("Unexpected NULL == g_pGlobalSchemaKeys"));
		}

		CleanupDownloadLib();
	}

	LeaveCriticalSection(&g_csGlobalClasses);
}

// ----------------------------------------------------------------------
//
// ShutdownInstanceThreads()
// 
// called by CEngUpdate::~CEngUpdate to shut down any outstanding
// threads before the control can end
//
// ----------------------------------------------------------------------
void WINAPI CEngUpdate::ShutdownInstanceThreads()
{
	LOG_Block("ShutdownInstanceThreads");

	if (NULL != m_evtNeedToQuit)
	{
		//
		// notify all threads go away
		//
		SetEvent(m_evtNeedToQuit);
		
		LOG_Out(_T("Shutdown event has been signalled"));

		//
		// wait all threads to quit
		// I don't think we should have a time limit here
		// since if we quit before all threads quit,
		// it's almost sure that AV will happen.
		//
        MSG msg;
		while (m_lThreadCounter > 0)
		{
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
		}

		LOG_Out(_T("All threads appeared gone."));

		//
		// reset the signal
		//
		ResetEvent(m_evtNeedToQuit);
	}
}

HRESULT CEngUpdate::RebootMachine()
{
    LOG_Block("RebootMachine()");

    HRESULT hr = S_OK;
    DWORD dwRet;
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    // Check if we're running on NT, if we are, we need to see if we have Privileges to Reboot
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        HANDLE hToken;
        TOKEN_PRIVILEGES tkp;
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            dwRet = GetLastError();
            LOG_ErrorMsg(dwRet);
            hr = HRESULT_FROM_WIN32(dwRet);
            return hr;
        }

        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
        tkp.PrivilegeCount = 1;
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
        {
            dwRet = GetLastError();
            LOG_ErrorMsg(dwRet);
            hr = HRESULT_FROM_WIN32(dwRet);
            return hr;
        }
    }

    //
    // shutdown the system and force all applications to close
    //
    ExitWindowsEx(EWX_REBOOT, 0);
    return hr;
}


// ----------------------------------------------------------------------
//
// DLL Public API: ShutdownThreads()
// 
// called by unlockengine form control to shut down any outstanding
// threads before the control can end
//
// ----------------------------------------------------------------------
void WINAPI ShutdownThreads()
{
	LOG_Block("ShutdownThreads");

	//
	// To maintain XPClient V4 CDM compatibility with the iuengine.dll, we
	// use the following hack to create and delete the global instance
	// of CEngUpdate:
	//
	// After CDM calls LoadIUEngine, it calls SetGlobalOfflineFlag,
	// which we hook and call CreateGlkobalCDMEngUpdateInstance.
	//
	// When CDM calls UnLoadIUEngine, the function calls the old
	// single-instance ShutdownThreads export, which we now use
	// to call DeleteGlobalCDMEngUpdateInstance. CEngUpdate does
	// its own ShutdownThreads call in it's destructor.
	//
	DeleteGlobalCDMEngUpdateInstance();

	//
	// If we are the last client, shutdown the global threads
	//
	ShutdownGlobalThreads();
}

void WINAPI ShutdownGlobalThreads()
{
	LOG_Block("ShutdownGlobalThreads");
	//
	// Now shut down any global (not CEngUpdate instance) threads
	// if there are no CEngUpdate instances left (last client is exiting)
	//
	if (NULL != g_evtNeedToQuit && 0 == g_ulGlobalClassRefCount)
	{
		//
		// notify all threads go away
		//
		SetEvent(g_evtNeedToQuit);
		
		LOG_Out(_T("Shutdown event has been signalled"));

		//
		// wait all threads to quit
		// I don't think we should have a time limit here
		// since if we quit before all threads quit,
		// it's almost sure that AV will happen.
		//
        MSG msg;
		while (g_lThreadCounter > 0)
		{
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
		}

		LOG_Out(_T("All global threads appear gone."));

		//
		// reset the signal
		//
		ResetEvent(g_evtNeedToQuit);
	}
}

COperationMgr::COperationMgr() : m_pOperationInfoList(NULL)
{
}

COperationMgr::~COperationMgr()
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    PIUOPERATIONINFO pNext;
    while (pCurrent)
    {
        pNext = pCurrent->pNext;
        if (NULL != pCurrent->bstrOperationResult)
        {
            SafeSysFreeString(pCurrent->bstrOperationResult);
        }
        HeapFree(GetProcessHeap(), 0, pCurrent);
        pCurrent = pNext;
    }
}


BOOL COperationMgr::AddOperation(LPCTSTR pszOperationID, LONG lUpdateMask)
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    PIUOPERATIONINFO pLastOperation = NULL;
    PIUOPERATIONINFO pNewOperation = NULL;

    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    // try to find the operation if its already here
    while (pCurrent)
    {
        pLastOperation = pCurrent;
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            // match
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    if (NULL == pCurrent)
    {
        // not found, or no operations in list yet
        pNewOperation = (IUOPERATIONINFO *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IUOPERATIONINFO));
        if (NULL == pNewOperation)
        {
            // out of memory, can't persist operation info.. 
            return FALSE;
        }

        lstrcpyn(pNewOperation->szOperationUUID, pszOperationID, ARRAYSIZE(pNewOperation->szOperationUUID));
        pNewOperation->lUpdateMask = lUpdateMask;

        if (NULL == m_pOperationInfoList)
        {
            m_pOperationInfoList = pNewOperation;
        }
        else
        {
            if (NULL != pLastOperation)
            {
                pLastOperation->pNext = pNewOperation;
            }
        }
    }
    else
    {
        // found the existing operation.. update it.
        pCurrent->lUpdateMask = lUpdateMask;
        SafeSysFreeString(pCurrent->bstrOperationResult); // reset result, new download request
    }
    return TRUE;
}

BOOL COperationMgr::FindOperation(LPCTSTR pszOperationID, PLONG plUpdateMask, BSTR *pbstrOperationResult)
{
    BOOL fFound = FALSE;
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    while (pCurrent)
    {
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            fFound = TRUE;
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    if (pCurrent)
    {
        if (plUpdateMask)
            *plUpdateMask = pCurrent->lUpdateMask;

        if (pbstrOperationResult)
        {
            if (NULL != pCurrent->bstrOperationResult)
            {
                *pbstrOperationResult = SysAllocString(pCurrent->bstrOperationResult);
            }
            else
            {
                *pbstrOperationResult = NULL;
            }
        }
    }
    return fFound;
}

BOOL COperationMgr::RemoveOperation(LPCTSTR pszOperationID)
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    PIUOPERATIONINFO pLastOperation = NULL;

    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    while (pCurrent)
    {
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            break;
        }
        pLastOperation = pCurrent;
        pCurrent = pCurrent->pNext;
    }

    if (NULL == pCurrent)
    {
        return FALSE; // not found
    }
    else
    {
        if (pCurrent == m_pOperationInfoList) // only operation in list
        {
            m_pOperationInfoList = NULL;
        }
        else
        {
            pLastOperation->pNext = pCurrent->pNext;
        }
    }

    SafeSysFreeString(pCurrent->bstrOperationResult);
    HeapFree(GetProcessHeap(), 0, pCurrent);

    return TRUE;
}

BOOL COperationMgr::UpdateOperation(LPCTSTR pszOperationID, LONG lUpdateMask, BSTR bstrOperationResult)
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;

    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    while (pCurrent)
    {
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    if (NULL == pCurrent)
    {
        return FALSE; // not found
    }

    pCurrent->lUpdateMask = lUpdateMask;
    SafeSysFreeString(pCurrent->bstrOperationResult);
    if (NULL != bstrOperationResult)
    {
        pCurrent->bstrOperationResult = SysAllocString(bstrOperationResult);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// WUPostMessageAndBlock()
//
// Since COM doesn't like to have COM calls made while processing a SendMessage
//  message, we need to use PostMessage instead.  However, using PostMessage
//  isn't synchronous, so what we need to do is create an event, do the post,
//  and wait on the event.  When the WndProc at the other end of the post is 
//  done, it will signal the event and we can unblock.
// Input:
//  hwnd: hwnd to post to
//  Msg:  message value
//  pevtData: pointer to an EventData structure to send as the LPARAM. We fill
//             in the hevDoneWithMessage field with the event we allocate.
// Return:
//  TRUE if we successfully waited for the message processing to complete
//   and FALSE otherwise
//  
/////////////////////////////////////////////////////////////////////////////
BOOL WUPostEventAndBlock(HWND hwnd, UINT Msg, EventData *pevtData)
{
    BOOL    fRet = TRUE;

    // ok, so this is funky: if we are in the thread that owns the HWND, then
    //  just maintain previous semantics and call SendMessage (yes, this means
    //  effectively not fixing the bug for this case, but nobody should be 
    //  using the synchronus download or install functions.)
    if (GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId())
    {
        SendMessage(hwnd, Msg, 0, (LPARAM)pevtData);
    }
    else
    {
        DWORD dw;
        
        // alloc the event we're going to wait on & fill in the field of the
        //  EventData structure.  If this fails, we can't really go on, so 
        //  bail
        pevtData->hevDoneWithMessage = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pevtData->hevDoneWithMessage == NULL)
            return TRUE;

        // do the post
        PostMessage(hwnd, Msg, 0, (LPARAM)pevtData);

        // wait for the WndProc to signal that it's done.
        dw = WaitForSingleObject(pevtData->hevDoneWithMessage, INFINITE);

        // cleanup & return
        CloseHandle(pevtData->hevDoneWithMessage);
        pevtData->hevDoneWithMessage = NULL;
        
        fRet = (dw == WAIT_OBJECT_0);
    }
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\expression.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   expression.h
//
//	Author:	Charles Ma
//			2000.10.27
//
//  Description:
//
//      header file for expression related functions
//
//=======================================================================


#ifndef __EXPRESSOIN_HEADER_INCLUDED__

#include "iuengine.h"
#include <msxml.h>

//----------------------------------------------------------------------
//
// public function DetectExpression()
//	retrieve the data from the express node, 
//	and do actual detection work
//
//	Input:
//		expression node
//
//	Return:
//		TRUE/FALSE, detection result
//
//----------------------------------------------------------------------
HRESULT 
DetectExpression(
	IXMLDOMNode* pExpression,	// expression node
	BOOL *pfResult
);



//----------------------------------------------------------------------
//
// Helper function DetectRegKeyExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyExists node
//
//	Return:
//		TRUE/FALSE, detection result
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyExists(
	IXMLDOMNode* pRegKeyExistsNode,
	BOOL *pfResult
);


//----------------------------------------------------------------------
//
// Helper function DetectRegKeyValue()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyValue(
	IXMLDOMNode* pRegKeyValueNode,
	BOOL *pfResult
);


//----------------------------------------------------------------------
//
// Helper function DetectRegKeySubstring()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeySubstring(
	IXMLDOMNode* pRegKeySubstringNode,
	BOOL *pfResult
);




//----------------------------------------------------------------------
//
// Helper function DetectRegVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegVersion(
	IXMLDOMNode* pRegKeyVersionNode,
	BOOL *pfResult
);


//----------------------------------------------------------------------
//
// Helper function DetectFileExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileExists(
	IXMLDOMNode* pFileExistsNode,
	BOOL *pfResult
);

//----------------------------------------------------------------------
//
// Helper function DetectFileVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileVersion(
	IXMLDOMNode* pFileVersionNode,
	BOOL *pfResult
);



//----------------------------------------------------------------------
//
// Helper function DetectComputerSystem()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		computerSystem node
//
//	Return:
//		detection result TRUE/FALSE. Default is FALSE for
//		anything wrong inside this function, plus the return
//		code as error code
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectComputerSystem(
	IXMLDOMNode* pComputerSystemNode,
	BOOL *pfResult
);





#define __EXPRESSOIN_HEADER_INCLUDED__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\iuengine.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuengine.cpp
//
//  Description:
//
//      PCH module for IUEngine DLL
//
//=======================================================================

#include "iuengine.h"

//
// NOTE:	Do not put anything else in this PCH file - add additional
//			common includes to iuengine.h instead.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\history.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   History.h
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      Class to handle history log
//
//=======================================================================

#include "iuxml.h"


// ----------------------------------------------------------------------
// 
// define the enum for download/install status
//
// ----------------------------------------------------------------------
enum _HISTORY_STATUS {
		HISTORY_STATUS_COMPLETE = 0,
		HISTORY_STATUS_IN_PROGRESS = 1,	// currently should be ignored of this!
		HISTORY_STATUS_FAILED = -1
};



// ----------------------------------------------------------------------
//
// define the class for history
//
// ----------------------------------------------------------------------

class CIUHistory
{
public:

	CIUHistory();
	~CIUHistory();

	// ------------------------------------------------------------------
	//
	// public function SetDownloadBasePath()
	//	this function should be called before AddHistoryItemDownloadStatus()
	//	for corporate case to set the download path that the user has input,
	//	so that we know where to save the history log.
	//	
	// ------------------------------------------------------------------
	HRESULT SetDownloadBasePath(LPCTSTR pszDownloadedBasePath);
	
	
	// ------------------------------------------------------------------
	//
	// public function AddHistoryItemDownloadStatus()
	//	this function should be called when you want to record the
	//	download status of this item. A new history item will be
	//	added to the history file
	//	
	// ------------------------------------------------------------------
	HRESULT AddHistoryItemDownloadStatus(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				_HISTORY_STATUS enDownloadStatus,
				LPCTSTR lpcszDownloadedTo,
				LPCTSTR lpcszClient,
				DWORD dwErrorCode = 0
	);
				

	// ------------------------------------------------------------------
	//
	// public function AddHistoryItemInstallStatus()
	//	this function should be called when you want to record the
	//	install status of this item. This function will go to the
	//	existing history tree and find the first item that matches
	//	the identity of hCatalogItem, and assume that one as 
	//	the one you want to modify the install status
	//	
	//
	// return:
	//		HRESULT - S_OK if succeeded
	//				- E_HANDLE if can't find hCatalogItem from 
	//				  the current history log tree
	//				- or other HRESULT error
	//
	// ------------------------------------------------------------------
	HRESULT AddHistoryItemInstallStatus(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				_HISTORY_STATUS enInstallStatus,
				LPCTSTR lpcszClient,
				BOOL fNeedsReboot,
				DWORD dwErrorCode = 0
	);


	// ------------------------------------------------------------------
	//
	// public function UpdateHistoryItemInstallStatus()
	//	this function should be called when you want to record the
	//	install status of this item. This function will go to the
	//	existing history tree and find the first item that matches
	//	the identity of hCatalogItem, and assume that one as 
	//	the one you want to modify the install status
	//	
	//
	// return:
	//		HRESULT - S_OK if succeeded
	//				- E_HANDLE if can't find hCatalogItem from 
	//				  the current history log tree
	//				- or other HRESULT error
	//
	// ------------------------------------------------------------------
	HRESULT UpdateHistoryItemInstallStatus(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				_HISTORY_STATUS enInstallStatus,
				BOOL fNeedsReboot,
				DWORD dwErrorCode /*= 0*/
	);


/*	// ------------------------------------------------------------------
	//
	// public function RetrieveItemDownloadPath()
	//	this function will go to the existing history tree and find
	//  the first item that matches the identity of hCatalogItem, and
	//  assume that's the one you want to retrieve the download path from
	//
	// return:
	//		HRESULT - S_OK if succeeded
	//				- E_HANDLE if can't find hCatalogItem from 
	//				  the current history log tree
	//				- or other HRESULT error
	//
	// ------------------------------------------------------------------
	HRESULT CIUHistory::RetrieveItemDownloadPath(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				BSTR* pbstrDownloadPath
	);
*/

	// ------------------------------------------------------------------
	//
	// public function ReadHistoryFromDisk()
	//	this function will read the history from the given file
	//
	// ------------------------------------------------------------------
	HRESULT ReadHistoryFromDisk(LPCTSTR lpszLogFile, BOOL fCorpAdmin = FALSE);


	// ------------------------------------------------------------------
	//
	// public function SaveHistoryToDisk()
	//	this function will re-read the history in exclusive mode, and
	//	merge the newly added data to the tree (so we don't overwrite
	//	new changes made by other instances of this control) and
	//	write it back 
	//
	// ------------------------------------------------------------------
	HRESULT SaveHistoryToDisk(void);


	// ------------------------------------------------------------------
	//
	// public function to set the client name 
	//
	//	a client name is used to put in history to denode who
	//	caused download/install happened.
	//
	// ------------------------------------------------------------------
	void SetClientName(BSTR bstrClientName);


	// ------------------------------------------------------------------
	//
	// public function GetHistory
	//
	//	read the current history XML file and convert it
	//	into bstr to pass out
	//
	// ------------------------------------------------------------------
	HRESULT GetHistoryStr(
					LPCTSTR lpszLogFile,
					BSTR BeginDateTime, 
					BSTR EndDateTime, 
					BSTR* pbstrHistory);

private:

	// ------------------------------------------------------------------
	//
	// private inline function GetBSTRStatus
	//
	// ------------------------------------------------------------------
	inline BSTR GetBSTRStatus(_HISTORY_STATUS enStatus)
	{
		BSTR bstrStatus = NULL;
		switch (enStatus)
		{
		case HISTORY_STATUS_COMPLETE:
			bstrStatus = SysAllocString(L"COMPLETE");
			break;
		case HISTORY_STATUS_IN_PROGRESS:
			bstrStatus = SysAllocString(L"IN_PROGRESS");
			break;
		default:
			bstrStatus = SysAllocString(L"FAILED");
		};
		return bstrStatus;
	};

	//
	// named mutex used to gain exclusive access to the history file
	//
	BOOL	m_fSavePending;
	HANDLE	m_hMutex;
	HRESULT m_ErrorCode;
	BSTR	m_bstrCurrentClientName;
	TCHAR	m_szLogFilePath[MAX_PATH];
	LPTSTR	m_pszDownloadBasePath;

	CXmlItems *m_pxmlExisting;
	CXmlItems *m_pxmlDownload;
	CXmlItems *m_pxmlInstall;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\iuengine.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuengine.h
//
//  Description:
//
//      Common include file for IUEngine DLL
//
//=======================================================================

#ifndef __IUENGINE_H_
#define __IUENGINE_H_


#include <windows.h>
#include <tchar.h>
#include <ole2.h>
#include "..\inc\iu.h"
#include <logging.h>
#include <shlwapi.h>
#include <iucommon.h>
#include <osdet.h>
#include <UrlAgent.h>

// #define __IUENGINE_USES_ATL_
#if defined(__IUENGINE_USES_ATL_)
#include <atlbase.h>
#define USES_IU_CONVERSION USES_CONVERSION
#else
#include <MemUtil.h>
#endif


#include "schemakeys.h"

#include <mistsafe.h>
#include <wusafefn.h>


//***********************************************************************
// 
// The following constants are defined in engmain.cpp
//
//***********************************************************************


/**
* the following two groups of constants can be used to construct
* lMode parameter of the following APIs:
*		Download()
*		DownloadAsync()
*		Install()
*		InstallAsync()
*
* Obviousely, you can only pick one from each group to make up
* lMode parameter.
*
*/
extern const LONG UPDATE_NOTIFICATION_DEFAULT;
extern const LONG UPDATE_NOTIFICATION_ANYPROGRESS;
extern const LONG UPDATE_NOTIFICATION_COMPLETEONLY;
extern const LONG UPDATE_NOTIFICATION_1PCT;
extern const LONG UPDATE_NOTIFICATION_5PCT;
extern const LONG UPDATE_NOTIFICATION_10PCT;

/**
* constant can also be used for SetOperationMode() and GetOperationMode()
*/
extern const LONG UPDATE_MODE_THROTTLE;

/**
* constant can be used by Download() and DownloadAsync(), which will
* tell these API's to use Corporate directory structure for destination folder.
*/
extern const LONG UPDATE_CORPORATE_MODE;


/**
* constant can be used by Install() and InstallAsync(). Will disable all
* internet related features
*/
extern const LONG UPDATE_OFFLINE_MODE;

/**
* constants for SetOperationMode() API
*/
extern const LONG UPDATE_COMMAND_PAUSE;
extern const LONG UPDATE_COMMAND_RESUME;
extern const LONG UPDATE_COMMAND_CANCEL;

/**
* constants for GetOperationMode() API
*/
extern const LONG UPDATE_MODE_PAUSED;
extern const LONG UPDATE_MODE_RUNNING;
extern const LONG UPDATE_MODE_NOTEXISTS;


/**
* constants for SetProperty() and GetProperty() API
*/
extern const LONG UPDATE_PROP_USECOMPRESSION;
extern const LONG UPDATE_PROP_OFFLINEMODE;

/**
* constants for BrowseForFolder() API
*
*	IUBROWSE_WRITE_ACCESS - validate write access on selected folder
*	IUBROWSE_AFFECT_UI - write-access validation affect OK button enable/disable
*	IUBROWSE_NOBROWSE - do not show browse folder dialog box. validate path passed-in only
*
*	default:
*		pop up browse folder dialog box, not doing any write-access validation
*		
*/
extern const LONG IUBROWSE_WRITE_ACCESS;
extern const LONG IUBROWSE_AFFECT_UI;
extern const LONG IUBROWSE_NOBROWSE;

// constants for historical speed registry
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_HISTORICALSPEED[] = _T("HistoricalSpeed");	// in bytes/sec
const TCHAR REGVAL_TIMEELAPSED[] = _T("TimeElapsed");			// in seconds

// constant for default downloads folder name
const TCHAR IU_WUTEMP[] = _T("WUTemp");

//
// Globals for the IUEngine

extern LONG g_lThreadCounter;
extern HANDLE g_evtNeedToQuit;
extern CUrlAgent *g_pUrlAgent;

typedef struct IUOPERATIONINFO
{
    TCHAR szOperationUUID[64];
    LONG lUpdateMask;
    BSTR bstrOperationResult;
    IUOPERATIONINFO *pNext;
} IUOPERATIONINFO, *PIUOPERATIONINFO;
class COperationMgr
{
public:
    COperationMgr();
    ~COperationMgr();

    BOOL AddOperation(LPCTSTR pszOperationID, LONG lUpdateMask);
    BOOL RemoveOperation(LPCTSTR pszOperationID);
    BOOL FindOperation(LPCTSTR pszOperationID, PLONG plUpdateMask, BSTR *pbstrOperationResult);
    BOOL UpdateOperation(LPCTSTR pszOperationID, LONG lUpdateMask, BSTR bstrOperationResult);

private:
    PIUOPERATIONINFO m_pOperationInfoList;
};

//
// CEngUpdate class used to export apartment safe instances of the update class to WU clients (iuctl, AU, DU, CDM)
//

class CEngUpdate
{

public:

	CEngUpdate();
	~CEngUpdate();

public:
	HRESULT WINAPI GetSystemSpec(BSTR bstrXmlClasses, DWORD dwFlags, BSTR *pbstrXmlDetectionResult);

	HRESULT WINAPI GetManifest(BSTR	bstrXmlClientInfo, BSTR	bstrXmlSystemSpec, BSTR	bstrXmlQuery, DWORD dwFlags, BSTR *pbstrXmlCatalog);

	HRESULT WINAPI Detect(BSTR bstrXmlCatalog, DWORD dwFlags, BSTR *pbstrXmlItems);

	HRESULT WINAPI Download(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
							IUnknown *punkProgressListener, HWND hWnd, BSTR *pbstrXmlItems);

	HRESULT WINAPI DownloadAsync(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
								 IUnknown *punkProgressListener, HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrUuidOperation);

	HRESULT WINAPI Install(BSTR bstrXmlClientInfo,
                       BSTR	bstrXmlCatalog,
					   BSTR bstrXmlDownloadedItems,
					   LONG lMode,
					   IUnknown *punkProgressListener,
					   HWND hWnd,
					   BSTR *pbstrXmlItems);

	HRESULT WINAPI InstallAsync(BSTR bstrXmlClientInfo,
                            BSTR bstrXmlCatalog,
							BSTR bstrXmlDownloadedItems,
							LONG lMode,
							IUnknown *punkProgressListener,
							HWND hWnd,
							BSTR bstrUuidOperation,
                            BSTR *pbstrUuidOperation);

	HRESULT WINAPI SetOperationMode(BSTR bstrUuidOperation, LONG lMode);

	HRESULT WINAPI GetOperationMode(BSTR bstrUuidOperation, LONG* plMode);

	HRESULT WINAPI GetHistory(
		BSTR		bstrDateTimeFrom,
		BSTR		bstrDateTimeTo,
		BSTR		bstrClient,
		BSTR		bstrPath,
		BSTR*		pbstrLog);

	HRESULT WINAPI BrowseForFolder(BSTR bstrStartFolder, 
							LONG flag, 
							BSTR* pbstrFolder);

	HRESULT WINAPI RebootMachine();

private:
	void WINAPI ShutdownInstanceThreads();	// called in dtor to shut down any outstanding threads

public:
	LONG m_lThreadCounter;
	HANDLE m_evtNeedToQuit;
	BOOL m_fOfflineMode;
	COperationMgr m_OperationMgr;
};

//
// CDM Internal Exports (called by IUCDM stub cdm.dll)
//

//
// We use a separate Real(tm) global for CDM to hold an instance of the CEngUpdate class,
// since it is never multiple instanced.
//
extern CEngUpdate* g_pCDMEngUpdate;

VOID WINAPI InternalDetFilesDownloaded(
    IN  HANDLE			hConnection
	);

BOOL InternalDownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
);

BOOL WINAPI InternalDownloadUpdatedFiles(
    IN  HANDLE        hConnection, 
    IN  HWND          hwnd,  
    IN  PDOWNLOADINFO pDownloadInfo, 
    OUT LPWSTR        lpDownloadPath, 
    IN  UINT          uSize, 
    OUT PUINT         puRequiredSize
    );


BOOL WINAPI InternalFindMatchingDriver(
    IN  HANDLE			hConnection, 
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
	);

VOID WINAPI InternalLogDriverNotFound(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
	);

int WINAPI InternalQueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
	);

void InternalSetGlobalOfflineFlag(
	IN BOOL fOfflineMode
	);

//
// GetSystemSpec functionality exported for use by CDM
//

class CXmlSystemSpec;

HRESULT AddComputerSystemClass(CXmlSystemSpec& xmlSpec);

HRESULT AddRegKeyClass(CXmlSystemSpec& xmlSpec);

HRESULT AddPlatformClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo);

HRESULT AddLocaleClass(CXmlSystemSpec& xmlSpec, BOOL fIsUser);

HRESULT AddDevicesClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo, BOOL fIsSysSpecCall);

//
// Misc. functionality
//

extern LONG g_lDoOnceOnLoadGuard;

void WINAPI DeleteExpiredDownloadFolders();

HRESULT WINAPI CreateGlobalCDMEngUpdateInstance();

HRESULT WINAPI DeleteGlobalCDMEngUpdateInstance();

void WINAPI ShutdownThreads();	// called by UnlockEnginge -- maintains backwards CDM compatibility

void WINAPI ShutdownGlobalThreads();	// called to shut down any outstanding global threads

#endif // __IUENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\sources.inc ===
!include $(WINDOWS_COM)\wu.inc

#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	detect
#
# Abstract:		IUEngine.DLL Implementation
#

MAJORCOMP=windows.com
MINORCOMP=iuengine

TARGETNAME=iuengine
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\IUEngine.def

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
PRECOMPILED_INCLUDE=..\iuengine.h
PRECOMPILED_CXX=1
USE_STATIC_ATL=1
ATL_DLL_IMPL=1
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1

#
# WUBUILD LAB will set this manually
#
# NT_SIGNCODE=1
USE_CRTDLL=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

TARGETLIBS=\
       $(SDK_LIB_PATH)\oleaut32.lib             \
       $(SDK_LIB_PATH)\ole32.lib                \
       $(SDK_LIB_PATH)\kernel32.lib             \
       $(SDK_LIB_PATH)\user32.lib               \
       $(SDK_LIB_PATH)\shlwapi.lib              \
       $(SDK_LIB_PATH)\ShFolder.Lib             \
       $(SDK_LIB_PATH)\shell32.lib              \
       $(SDK_LIB_PATH)\advapi32.lib             \
       $(SDK_LIB_PATH)\advpack.lib              \
       $(SDK_LIB_PATH)\uuid.lib                 \
       $(SDK_LIB_PATH)\wininet.lib              \
       $(SDK_LIB_PATH)\version.lib              \
       $(SDK_LIB_PATH)\setupapi.lib             \
       $(SDK_LIB_PATH)\winspool.lib             \
       $(SDK_LIB_PATH)\rpcrt4.lib               \
       $(SDK_LIB_PATH)\Rasapi32.lib             \
       $(WULIB)\logging\$(WUBLDTYPE)\$(O)\logging.lib	\
       $(WULIB)\util\$(WUBLDTYPE)\$(O)\util.lib		\
       $(WULIB)\detect\$(WUBLDTYPE)\$(O)\detect.lib     \
       $(WULIB)\download\$(WUBLDTYPE)\$(O)\download.lib   \
       $(WULIB)\install\$(WUBLDTYPE)\$(O)\install.lib    \
       $(WULIB)\trust\$(WUBLDTYPE)\$(O)\trust.lib \
       $(WULIB)\urllogging\$(WUBLDTYPE)\$(O)\urllogging.lib \
       $(WULIB)\schemamisc\$(WUBLDTYPE)\$(O)\schemamisc.lib \
       $(WULIB)\urlagent\$(WUBLDTYPE)\$(O)\urlagent.lib \
       $(WULIB)\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib \

#
# how about - gdi32.lib, comdlg32.lib, odbc32.lib, odbccp32.lib?
# they are showing up in the ATL project settings.
#

INCLUDES=$(INCLUDES);..\..\inc;..\.;$(BASEDIR)\public\internal\windows\inc;$(BASEDIR)\public\internal\enduser\inc;$(BASEDIR)\public\internal\inetcore\inc;

SOURCES= \
        ..\engmain.cpp    \
        ..\detect.cpp     \
        ..\download.cpp   \
        ..\setopsts.cpp   \
        ..\install.cpp    \
        ..\manifest.cpp   \
        ..\sysspec.cpp    \
        ..\iuxml.cpp      \
        ..\expression.cpp \
        ..\history.cpp    \
        ..\cdmi.cpp       \
        ..\cdmp.cpp       \
	..\delexdl.cpp    \
        ..\browse.cpp	  \
	..\v3applog.cpp	  \
        ..\iuengine.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\iuxml.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuxml.h
//
//  Description:
//
//      Declaration of the CIUXml class
//
//=======================================================================

#ifndef __IUXML_H_
#define __IUXML_H_

#include <msxml.h>

#define HANDLE_NODE_INVALID     -1
#define HANDLE_NODELIST_INVALID -1

typedef DWORD   HANDLE_NODE;
typedef DWORD   HANDLE_NODELIST;

// Bitmap of existence of all possible system info classes
extern const DWORD  COMPUTERSYSTEM;
extern const DWORD  REGKEYS;
extern const DWORD  PLATFORM;
extern const DWORD  LOCALE;
extern const DWORD  DEVICES;


/////////////////////////////////////////////////////////////////////////////
// CIUXml
class CIUXml
{
public:
    CIUXml();
    virtual ~CIUXml();

    /////////////////////////////////////////////////////////////////////////////
    // SafeCloseHandleNode()
    //
    // User can explicitly can this function to release a node for reuse when 
    // writing a xml doc.
    /////////////////////////////////////////////////////////////////////////////
    void SafeCloseHandleNode(HANDLE_NODE& hNode);

    /////////////////////////////////////////////////////////////////////////////
    // SafeFindCloseHandle()
    //
    // User can explicitly can this function to release a nodelist for reuse when 
    // reading a xml doc.
    /////////////////////////////////////////////////////////////////////////////
    void SafeFindCloseHandle(HANDLE_NODELIST& hNodeList);

    /////////////////////////////////////////////////////////////////////////////
    // GetDOMNodebyHandle()
    //
    // Retrieve the xml node with the given index of m_ppNodeArray
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNode* GetDOMNodebyHandle(HANDLE_NODE hNode);

private:
    /////////////////////////////////////////////////////////////////////////////
    // Handle to the heap of the calling process, used for HeapAlloc()
    /////////////////////////////////////////////////////////////////////////////
    HANDLE  m_hHeap;

    /////////////////////////////////////////////////////////////////////////////
    // Length of the node array "m_ppNodeArray"
    /////////////////////////////////////////////////////////////////////////////
    DWORD   m_dwSizeNodeArray;

    /////////////////////////////////////////////////////////////////////////////
    // Length of the nodelist array "m_ppNodeListArray"
    /////////////////////////////////////////////////////////////////////////////
    DWORD   m_dwSizeNodeListArray;

    /////////////////////////////////////////////////////////////////////////////
    // InitNodeArray()
    //
    // Allocate or re-allocate memory for the node array "m_ppNodeArray"
    /////////////////////////////////////////////////////////////////////////////
    HRESULT InitNodeArray(BOOL fRealloc = FALSE);

    /////////////////////////////////////////////////////////////////////////////
    // InitNodeListArray()
    //
    // Allocate or re-allocate memory for the nodelist array "m_ppNodeListArray"
    /////////////////////////////////////////////////////////////////////////////
    HRESULT InitNodeListArray(BOOL fRealloc = FALSE);

    /////////////////////////////////////////////////////////////////////////////
    // GetNodeHandle()
    //
    // Look for the first un-used node from the "m_ppNodeArray" array,
    // including the memory allocation, if needed.
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODE GetNodeHandle();

    /////////////////////////////////////////////////////////////////////////////
    // GetNodeListHandle()
    //
    // Look for the first un-used nodelist from the "m_ppNodeListArray" array,
    // including the memory allocation, if needed.
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetNodeListHandle();

protected:
    /////////////////////////////////////////////////////////////////////////////
    // This array is used to keep track of different nodes that can remain
    // opened at the same time to write into; the index of the array will be
    // returned to caller as a HANDLE_NODE to perform writing against.
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNode**           m_ppNodeArray;

    /////////////////////////////////////////////////////////////////////////////
    // This array is used to keep track of different nodelists that can remain
    // opened at the same time to read from; the index of the array will be
    // returned to caller as a HANDLE_NODELIST to perform reading against.
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNodeList**       m_ppNodeListArray;

    /////////////////////////////////////////////////////////////////////////////
    // FindFirstDOMNode()
    //
    // Retrieve the first xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode);

    /////////////////////////////////////////////////////////////////////////////
    // FindFirstDOMNode()
    //
    // Retrieve the handle of first xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, HANDLE_NODE* phNode);

	/////////////////////////////////////////////////////////////////////////////
	// FindFirstDOMNode()
	//
	// Retrieve the first xml node with the given tag name in the given xml doc
	/////////////////////////////////////////////////////////////////////////////
	HANDLE_NODELIST FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode);

	/////////////////////////////////////////////////////////////////////////////
	// FindFirstDOMNode()
	//
	// Retrieve the handle of first xml node with the given tag name in the given xml doc
	/////////////////////////////////////////////////////////////////////////////
	HANDLE_NODELIST FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, HANDLE_NODE* phNode);

    /////////////////////////////////////////////////////////////////////////////
    // FindNextDOMNode()
    //
    // Retrieve the next xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindNextDOMNode(HANDLE_NODELIST hNodeList, IXMLDOMNode** ppNode);

    /////////////////////////////////////////////////////////////////////////////
    // FindNextDOMNode()
    //
    // Retrieve the handle of next xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindNextDOMNode(HANDLE_NODELIST hNodeList, HANDLE_NODE* phNode);

    /////////////////////////////////////////////////////////////////////////////
    // CreateDOMNodeWithHandle()
    //
    // Create an xml node of the given type
    // Return: index of the node array "m_ppNodeArray"; or -1 if failure.
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODE CreateDOMNodeWithHandle(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI = NULL);
};


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemSpec
class CXmlSystemSpec : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for SystemSpec
    /////////////////////////////////////////////////////////////////////////////
    CXmlSystemSpec();

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for SystemSpec
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlSystemSpec();

    /////////////////////////////////////////////////////////////////////////////
    // AddComputerSystem()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddComputerSystem(BSTR bstrManufacturer,
                              BSTR bstrModel,
                              BSTR bstrSupportSite = NULL,
                              INT  iAdmin = -1,
                              INT  iWUDisabled = -1,
                              INT  iAUEnabled = -1,
							  BSTR bstrPID=NULL);

    /////////////////////////////////////////////////////////////////////////////
    // AddDriveSpace()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDriveSpace(BSTR bstrDrive, INT iKBytes);

    /////////////////////////////////////////////////////////////////////////////
    // AddReg()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddReg(BSTR bstrProvider);

    /////////////////////////////////////////////////////////////////////////////
    // AddPlatform()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddPlatform(BSTR bstrName);

    /////////////////////////////////////////////////////////////////////////////
    // AddProcessor()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddProcessor(BSTR bstrProcessor);

    /////////////////////////////////////////////////////////////////////////////
    // AddVersion()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddVersion(INT  iMajor = -1,
                       INT  iMinor = -1,
                       INT  iBuild = -1,
                       INT  iSPMajor = -1,
                       INT  iSPMinor = -1,
                       BSTR bstrTimeStamp = NULL);

    /////////////////////////////////////////////////////////////////////////////
    // AddSuite()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddSuite(BSTR bstrSuite);

    /////////////////////////////////////////////////////////////////////////////
    // AddProductType()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddProductType(BSTR bstrProductType);

    /////////////////////////////////////////////////////////////////////////////
    // AddLocale()
    //
    // We need to pass back a handle to differentiate different <locale> node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddLocale(BSTR bstrContext, HANDLE_NODE* phNodeLocale);

    /////////////////////////////////////////////////////////////////////////////
    // AddLanguage()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddLanguage(HANDLE_NODE hNodeLocale, BSTR bstrLocale);

    /////////////////////////////////////////////////////////////////////////////
    // AddDevice()
    //
    // We need to pass back a handle to differentiate different <device> node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDevice(BSTR bstrDeviceInstance,
                      INT  iIsPrinter,
                      BSTR bstrProvider,
                      BSTR bstrMfgName,
                      BSTR bstrDriverName,
                      HANDLE_NODE* phNodeDevice);

    /////////////////////////////////////////////////////////////////////////////
    // AddHWID()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddHWID(HANDLE_NODE hNodeDevice,
                    BOOL fIsCompatible,
                    UINT iRank,
                    BSTR bstrHWID,
                    BSTR bstrDriverVer = NULL);

    /////////////////////////////////////////////////////////////////////////////
    // GetSystemSpecBSTR()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetSystemSpecBSTR(BSTR *pbstrXmlSystemSpec);

private:
    IXMLDOMDocument*    m_pDocSystemSpec;
    IXMLDOMNode*        m_pNodeSystemInfo;
    IXMLDOMNode*        m_pNodeComputerSystem;
    IXMLDOMNode*        m_pNodeRegKeysSW;
    IXMLDOMNode*        m_pNodePlatform;
    IXMLDOMNode*        m_pNodeDevices;
};


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemClass
class CXmlSystemClass : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for SystemInfoClasses
    /////////////////////////////////////////////////////////////////////////////
    CXmlSystemClass();

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for SystemInfoClasses
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlSystemClass();

    /////////////////////////////////////////////////////////////////////////////
    // LoadXMLDocument()
    //
    // Load an XML Document from string
    /////////////////////////////////////////////////////////////////////////////
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

    /////////////////////////////////////////////////////////////////////////////
    // GetClasses()
    //
    // Return the bitmap of existence of all possible system info classes
    /////////////////////////////////////////////////////////////////////////////
    DWORD GetClasses();

private:
    IXMLDOMDocument*    m_pDocSystemClass;
};


/////////////////////////////////////////////////////////////////////////////
// CXmlCatalog
class CXmlCatalog : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for Catalog
    /////////////////////////////////////////////////////////////////////////////
    CXmlCatalog();

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for Catalog
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlCatalog();

    /////////////////////////////////////////////////////////////////////////////
    // LoadXMLDocument()
    //
    // Load an XML Document from string
    /////////////////////////////////////////////////////////////////////////////
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemCount()
    //
    // Gets a Count of How Many Items are in this Catalog
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemCount(LONG *plItemCount);

    /////////////////////////////////////////////////////////////////////////////
    // GetProviders()
    // 
    // Find a list of <provider> node in catalog xml
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNodeList* GetProviders();

    /////////////////////////////////////////////////////////////////////////////
    // GetFirstProvider()
    //
    // Find the first provider in catalog xml doc
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstProvider(HANDLE_NODE* phNodeProvider);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetNextProvider()
    //
    // Find the next provider in catalog xml doc
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextProvider(HANDLE_NODELIST hNodeListProvider, HANDLE_NODE* phNodeProvider);    

    /////////////////////////////////////////////////////////////////////////////
    // GetFirstItem()
    //
    // Find the first item in provider (parent) node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstItem(HANDLE_NODE hNodeProvider, HANDLE_NODE* phNodeItem);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetNextItem()
    //
    // Find the next item in provider (parent) node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);    
        
    /////////////////////////////////////////////////////////////////////////////
    // GetFirstItemDependency()
    //
    // Find the first dependency item in Item Dependencies node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstItemDependency(HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetNextItem()
    //
    // Find the next dependency item in the Item Dependencies node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextItemDependency(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);  

    /////////////////////////////////////////////////////////////////////////////
    // CloseItemList()
    //
    // Release the item nodelist
    /////////////////////////////////////////////////////////////////////////////
    void CloseItemList(HANDLE_NODELIST hNodeListItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetIdentity()
    //
    // Retrieve the unique name (identity) of the given provider or item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetIdentity(HANDLE_NODE hNode,
                        BSTR* pbstrName,
                        BSTR* pbstrPublisherName,
                        BSTR* pbstrGUID);

    /////////////////////////////////////////////////////////////////////////////
    // GetIdentityStr()
    //
    // Retrieve the string that can be used to uniquely identify an item.
    // This function defines the logic about what components can be used
    // to define the uniqueness of an item based on the 3 parts of data from
    // GetIdentity().
    //
    // The created string will be language neutral. That is, it can not
    // ensure the uniqueness for two items having the same <identity> node
    // except different only on <langauge> part inside <identity>
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetIdentityStr(HANDLE_NODE hNode,
                        BSTR* pbstrUniqIdentifierString);

	HRESULT GetIdentityStrForPing(HANDLE_NODE hNode,
                        BSTR* pbstrUniqIdentifierString);

    /////////////////////////////////////////////////////////////////////////////
    // GetBSTRItemForCallback()
    //
    // Create an item node as the passed-in node, have child nodes identity and
	// platform (anything uniquely idenitify this item) then output this 
	// item node data as string, then delete the crated node
    //
    /////////////////////////////////////////////////////////////////////////////
	HRESULT GetBSTRItemForCallback(HANDLE_NODE hItem, BSTR* pbstrXmlItemForCallback);

    /////////////////////////////////////////////////////////////////////////////
    // IsPrinterDriver()
    //
    // Retrieves from the Catalog whether this Item is a Printer Driver
    //
    /////////////////////////////////////////////////////////////////////////////
    BOOL IsPrinterDriver(HANDLE_NODE hNode);

    /////////////////////////////////////////////////////////////////////////////
    // GetDriverInfo()
    //
    // Retrieves the Driver Information from the Catalog for this Item. Returns
    // the Display Name and HWID for this driver - This is passed to the CDM 
    // installer
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetDriverInfo(HANDLE_NODE hNode, 
                          BSTR* pbstrHWID, 
                          BSTR* pbstrDisplayName);

    /////////////////////////////////////////////////////////////////////////////
    // GetPrinterDriverInfo()
    //
    // Retrieves the Printer Driver Information from the Catalog for this Item. 
    // Returns the DriverName and the Architecture - This is passed to the CDM
    // installer
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetPrinterDriverInfo(HANDLE_NODE hNode,
                                 BSTR* pbstrDriverName,
                                 BSTR* pbstrArchitecture);


	/////////////////////////////////////////////////////////////////////////////
	// GetDriverInfoEx()
	//
	// Combines functionality of IsPrinterDriver, GetDriverInfo, and
	// GetPrinterDriverInfo plus retreives MfgName and DriverProvider.
	// Used by FindMatchingDriver()
	//
	// If SUCCEEDES pbstrHWID, pbstrDriverVer, and pbstrDisplayName
	//    are always returned.
	// If SUCCEEDES && *pFIsPrinter == TRUE then pbstrDriverName,
	//    pbstrDriverProvider, and pbstrMfgName are returned.
	//
	// Currently pbstrArchitecture is never returned.
	//
	/////////////////////////////////////////////////////////////////////////////
    HRESULT CXmlCatalog::GetDriverInfoEx(HANDLE_NODE hNode,
                                         BOOL* pfIsPrinter,
                                         BSTR* pbstrHWID,
										 BSTR* pbstrDriverVer,
                                         BSTR* pbstrDisplayName,
                                         BSTR* pbstrDriverName,
                                         BSTR* pbstrDriverProvider,
                                         BSTR* pbstrMfgName,
                                         BSTR* pbstrArchitecture);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemFirstPlatformStr()
    //
    // The input node pointer points to an item node has <platform> as its child.
    // This function will retrieve the first <platform> node from this item node and
    // convert the data inside <platform> into a string that can be used to
    // uniquely identify a platform.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemFirstPlatformStr(HANDLE_NODE hNodeItem,
                        BSTR* pbstrPlatform);
    
    /////////////////////////////////////////////////////////////////////////////
    // GetItemAllPlatformStr()
    //
    // The input node pointer points to an item node that has <platform> node(s).
    // This function will retrieve every <platform> node from this item node and
    // convert the data inside <platform> into a string that can be used to
    // uniquely identify a platform.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemAllPlatformStr(HANDLE_NODE hNodeItem,
                        BSTR** ppbPlatforms, UINT* pnPlatformCount);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemFirstLanguageStr()
    //
    // The input node pointer points to a node has <identity> as its child.
    // This function will retrieve the first <language> node from <identity> 
    // node 
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemFirstLanguageStr(HANDLE_NODE hNodeItem,
                        BSTR* pbstrLanguage);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemAllLanguageStr()
    //
    // The input node pointer points to a node has <identity> as its child.
    // This function will retrieve every <language> node from <identity> node and
    // convert the data into an BSTR array to return.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemAllLanguageStr(HANDLE_NODE hNodeItem,
                        BSTR** ppbstrLanguage, UINT* pnLangCount);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemFirstCodeBase()
    //
    // Find the first codebase (path) of the given item
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetItemFirstCodeBase(HANDLE_NODE hNodeItem,
                                         BSTR* pbstrCodeBase,
                                         BSTR* pbstrName,
                                         BSTR* pbstrCRC,
                                         BOOL* pfPatchAvailable,
                                         LONG* plSize);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemNextCodeBase()
    //
    // Find the next codebase (path) of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemNextCodeBase(HANDLE_NODELIST hNodeListCodeBase,
                                BSTR* pbstrCodeBase,
                                BSTR* pbstrName,
                                BSTR* pbstrCRC,
                                BOOL* pfPatchAvailable,
                                LONG* plSize);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemInstallInfo()
    //
    // Retrieve the installation information of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemInstallInfo(HANDLE_NODE hNodeItem,
                               BSTR* pbstrInstallerType,
							   BOOL* pfExclusive,
                               BOOL* pfReboot,
                               LONG* plNumCommands);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetItemInstallCommand()
    //
    // Find the installation command type, command and switches of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemInstallCommand(HANDLE_NODE hNodeItem,
                                  INT   iOrder,
                                  BSTR* pbstrCommandType,
                                  BSTR* pbstrCommand,
                                  BSTR* pbstrSwitches,
                                  BSTR* pbstrInfSection);

    /////////////////////////////////////////////////////////////////////////////
    // CloseItem()
    //
    // Release the item node
    /////////////////////////////////////////////////////////////////////////////
    void CloseItem(HANDLE_NODE hNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetTotalEstimatedSize()
    //
    // Get the Total Estimated Download Size of all Items based on Codebase Size
    HRESULT GetTotalEstimatedSize(LONG *plTotalSize);

    /////////////////////////////////////////////////////////////////////////////
    // FindItemByIdentity()
    //
    // Finds an Item in the Catalog that Matches the Supplied Identity                
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindItemByIdentity(IXMLDOMNode* pNodeIdentity, HANDLE_NODE* phNodeItem);

 /*   /////////////////////////////////////////////////////////////////////////////
    // IfSameIdentity()
    //
    // Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2);
*/

    /////////////////////////////////////////////////////////////////////////////
    // GetItemLanguage()
    //
    // Get the Language Entity from the Item Identity
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemLanguage(HANDLE_NODE hNodeItem, BSTR* pbstrLanguage);

    /////////////////////////////////////////////////////////////////////////////
    // GetCorpItemPlatformStr()
    //
    // Get the Simplified Platform String for an Item (uses the first available platform element)
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetCorpItemPlatformStr(HANDLE_NODE hNodeItem, BSTR* pbstrPlatformStr);
    

private:
    IXMLDOMDocument*    m_pDocCatalog;

    //
    // helper functions
    //

    //
    // get data from a version node and convert them into a string with
    // format: 
    //          VersionStr   = <Version>[,<SvcPackVer>[,<timeStamp>]]
    //          <Version>    = <Major>[.<Minor>[.<Build>]]
    //          <SvcPackVer> = <Major>[.<minor>]
    //
    //
    // Assumption:
    //          pszVersion points to a buffer LARGE ENOUGH to store
    //          any legal version number.
    //
    HRESULT getVersionStr(IXMLDOMNode* pVersionNode, LPTSTR pszVersion);
    HRESULT getVersionStrWithoutSvcPack(IXMLDOMNode* pVersionNode, LPTSTR pszVersion);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemPlatformStr()
    //
    // The input node pointer points to a <platform> node.
    // This function will retrieve the data from this <platform> node and
    // convert the data into a string that can be used to
    // uniquely identify a platform.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetPlatformStr(IXMLDOMNode* pNodePlatform, BSTR* pbstrPlatform);
    HRESULT GetPlatformStrForPing(IXMLDOMNode* pNodePlatform, BSTR* pbstrPlatform);

private:

};


/////////////////////////////////////////////////////////////////////////////
// CXmlItems
class CXmlItems : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for Items; this is for write only
    /////////////////////////////////////////////////////////////////////////////
    CXmlItems();

    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for Items; take TRUE for read, FALSE for write
    /////////////////////////////////////////////////////////////////////////////
    CXmlItems(BOOL fRead);

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for Items
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlItems();

    /////////////////////////////////////////////////////////////////////////////
    // GetItemsDocumentPtr()
    //
    // Retrieve the items XML Document node
    /////////////////////////////////////////////////////////////////////////////
    inline IXMLDOMDocument* GetItemsDocumentPtr() { return m_pDocItems; };

    /////////////////////////////////////////////////////////////////////////////
    // Clear()
    //
    // Reset IXMLDOMDocument* for Items
    /////////////////////////////////////////////////////////////////////////////
    void Clear();

	/////////////////////////////////////////////////////////////////////////////
	// LoadXMLDocument()
	//
	// Load an XML Document from string
	/////////////////////////////////////////////////////////////////////////////
	HRESULT LoadXMLDocument(BSTR bstrXml);

	/////////////////////////////////////////////////////////////////////////////
	// LoadXMLDocumentFile()
	//
	// Load an XML Document from the specified file
	/////////////////////////////////////////////////////////////////////////////
	HRESULT LoadXMLDocumentFile(BSTR bstrFilePath);

    /////////////////////////////////////////////////////////////////////////////
    // SaveXMLDocument()
    //
    // Save an XML Document to the specified location
    /////////////////////////////////////////////////////////////////////////////
    HRESULT SaveXMLDocument(BSTR bstrFilePath);

	/////////////////////////////////////////////////////////////////////////////
	// AddGlobalErrorCodeIfNoItems()
	//
	// Add the errorCode attribute for <items> if there's no <itemStatus> child node
	/////////////////////////////////////////////////////////////////////////////
	HANDLE_NODELIST AddGlobalErrorCodeIfNoItems(DWORD dwErrorCode);

    /////////////////////////////////////////////////////////////////////////////
    // GetFirstItem()
    //
    // Find the first item in Items xml doc
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstItem(HANDLE_NODE* phNodeItem);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetNextItem()
    //
    // Find the next item in Items xml doc
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);    
        
    /////////////////////////////////////////////////////////////////////////////
    // CloseItemList()
    //
    // Release the item nodelist
    /////////////////////////////////////////////////////////////////////////////
    void CloseItemList(HANDLE_NODELIST hNodeListItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemDownloadPath()
    //
    // Retrieve the download path of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemDownloadPath(HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemDownloadPath()
    //
    // Retrieve the download path of the given item in catalog
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemDownloadPath(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath);

    /////////////////////////////////////////////////////////////////////////////
    // CloseItem()
    //
    // Release the item node
    /////////////////////////////////////////////////////////////////////////////
    void CloseItem(HANDLE_NODE hNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // FindItem()
    //
    // Input:
    // pNodeItem    - the <itemStatus> node of the install items xml; we need
    //                to find the corresponding <itemStatus> node in the existing 
    //                items xml with the identical <identity>, <platform> and 
    //                <client> nodes.
    // Output:
    // phNodeItem   - the handle we pass back to differentiate different
    //                <itemStatus> node in the existing items xml
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem, BOOL fIdentityOnly = FALSE);

	/////////////////////////////////////////////////////////////////////////////
	// FindItem()
	//
	// Input:
	// pCatalog		- the pointer to the CXmlCatalog object
	// hNodeItem	- the handle of the <item> node of the catalog xml; we need
	//                to find the corresponding <itemStatus> node in the existing 
	//                items xml with the identical <identity>, <platform> and 
	//                <client> nodes.
	// Output:
	// phNodeItem	- the handle we pass back to differentiate different
	//				  <itemStatus> node in items xml
	/////////////////////////////////////////////////////////////////////////////
	HRESULT FindItem(CXmlCatalog* pCatalog,	HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // MergeItemDownloaded()
    //
    // Insert items with download history into existing history
    /////////////////////////////////////////////////////////////////////////////
    HRESULT MergeItemDownloaded(CXmlItems *pHistoryDownload);

    /////////////////////////////////////////////////////////////////////////////
    // UpdateItemInstalled()
    //
    // Update items with installation history in existing history
    /////////////////////////////////////////////////////////////////////////////
    HRESULT UpdateItemInstalled(CXmlItems *pHistoryInstall);

    /////////////////////////////////////////////////////////////////////////////
    // UpdateItemInstallStatus()
    //
    // Update the install status of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT UpdateItemInstallStatus(HANDLE_NODE hNodeItem,
                                    BSTR bstrValue,
                                    INT iNeedsReboot = -1,
                                    DWORD dwErrorCode = 0);

    /////////////////////////////////////////////////////////////////////////////
    // AddItem()
    //
    // Input:
    // pNodeItem    - the <item> node of the catalog xml; we need to read
    //                <identity> node, <description> node and <platform> nodes
    //                from it and write to the items xml (insert in front).
    // Output:
    // phNodeItem   - the handle we pass back to differentiate different
    //                <itemStatus> node in items xml
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // AddItem()
    //
    // Input:
    // pCatalog     - the pointer to the CXmlCatalog object
    // hNodeItem    - the handle of the <item> node of the catalog xml; we need
    //                to read <identity> node, <description> node and <platform>
    //                nodes from it and write to the items xml (insert in front).
    // Output:
    // phNodeItem   - the handle we pass back to differentiate different
    //                <itemStatus> node in items xml
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddItem(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);
	
	/////////////////////////////////////////////////////////////////////////////
    // AddTimeStamp()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddTimeStamp(HANDLE_NODE hNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // AddDetectResult()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDetectResult(HANDLE_NODE hNodeItem,
                            INT iInstalled    = -1,
                            INT iUpToDate     = -1,
                            INT iNewerVersion = -1,
                            INT iExcluded     = -1,
                            INT iForce        = -1,
							INT iComputerSystem = -1);

    /////////////////////////////////////////////////////////////////////////////
    // AddDownloadStatus()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDownloadStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, DWORD dwErrorCode = 0);

    /////////////////////////////////////////////////////////////////////////////
    // AddDownloadPath()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDownloadPath(HANDLE_NODE hNodeItem, BSTR bstrDownloadPath);

    /////////////////////////////////////////////////////////////////////////////
    // AddInstallStatus()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddInstallStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, BOOL fNeedsReboot, DWORD dwErrorCode = 0);

    /////////////////////////////////////////////////////////////////////////////
    // AddClientInfo()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddClientInfo(HANDLE_NODE hNodeItem, BSTR bstrClient);

	/////////////////////////////////////////////////////////////////////////////
	// MigrateV3History()
	//
	// Migrate V3 History: Consumer history only.
	/////////////////////////////////////////////////////////////////////////////
	HRESULT MigrateV3History(LPCTSTR pszHistoryFilePath);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemsBSTR()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemsBSTR(BSTR *pbstrXmlItems);

    /////////////////////////////////////////////////////////////////////////////
    // GetFilteredHistoryBSTR()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetFilteredHistoryBSTR(BSTR bstrBeginDateTime,
                                   BSTR bstrEndDateTime,
                                   BSTR bstrClient,
                                   BSTR *pbstrXmlHistory);

private:

	/////////////////////////////////////////////////////////////////////////////
	//
	// Initialize XML DOC node pointers before writing
	/////////////////////////////////////////////////////////////////////////////
	void Init();

/*    /////////////////////////////////////////////////////////////////////////////
    // IfSameClientInfo()
    //
    // Return TRUE if the two <client> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSameClientInfo(IXMLDOMNode* pNodeClient1, IXMLDOMNode* pNodeClient2);

    /////////////////////////////////////////////////////////////////////////////
    // IfSameIdentity()
    //
    // Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2);

    /////////////////////////////////////////////////////////////////////////////
    // IfSamePlatform()
    //
    // Return TRUE if the two <platform> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSamePlatform(IXMLDOMNode* pNodePlatform1, IXMLDOMNode* pNodePlatform2);
*/

    IXMLDOMDocument*    m_pDocItems;
    IXMLDOMNode*        m_pNodeItems;
};




/////////////////////////////////////////////////////////////////////////////
// CXmlClientInfo
class CXmlClientInfo
{
public:

    CXmlClientInfo();
    ~CXmlClientInfo();

    //
    // load and parse and validate an XML document from string
    //
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

    //
    // retrieve client name attribute
    //
    HRESULT GetClientName(BSTR* pbstrClientName);

	inline IXMLDOMDocument* GetDocument() { return m_pDocClientInfo; }

private:
    IXMLDOMDocument*    m_pDocClientInfo;


};



#endif //__IUXML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\setopsts.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   setopsts.cpp
//
//  Description:
//
//      Implementation for the GetOperationResult() function
//
//=======================================================================

#include "iuengine.h"


/////////////////////////////////////////////////////////////////////////////
// SetOperationMode()
//		Set the operation mode.
//
// Input:
//		bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
//		lMode - the mode affecting the operation:
//
//				UPDATE_COMMAND_PAUSE
//				UPDATE_COMMAND_RESUME
//				UPDATE_COMMAND_CANCEL
//
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::SetOperationMode(BSTR bstrUuidOperation, LONG lMode)
{
	LOG_Block("CEngUpdate::SetOperationMode");
    if (UPDATE_COMMAND_CANCEL != lMode)
        return E_INVALIDARG;

    // only supported operation mode is cancel
    SetEvent(m_evtNeedToQuit);
	LOG_Out(_T("Set m_evtNeedToQuit"));
    return S_OK;    
}



/////////////////////////////////////////////////////////////////////////////
// GetOperationMode()
//		Get the operation mode.
//
// Input:
//		bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
//		lMode - the mode affecting the operation:
//
//				UPDATE_MODE_PAUSED
//				UPDATE_MODE_RUNNING
//				UPDATE_MODE_NOTEXISTS
//				UPDATE_MODE_THROTTLE
//
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::GetOperationMode(BSTR bstrUuidOperation, LONG* plMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\v3applog.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    v3applog.cpp
//
//  Purpose: Reading WindowsUpdate V3 history logging 
//
//  History: 22-Feb-99   YAsmi    Created
//			 02-May-01   JHou	  Modified
//
//=======================================================================

#include "iuengine.h"
#include <iucommon.h>
#include "v3applog.h"


//
// CV3AppLog class
//


//--------------------------------------------------------------------------------
// CV3AppLog::CV3AppLog
//
// if the pszLogFileName=NULL, then the caller must set the log file name by
// calling SetLogFile before using
//--------------------------------------------------------------------------------
CV3AppLog::CV3AppLog(LPCTSTR pszLogFileName) :
	m_pFileBuf(NULL),
	m_pFieldBuf(NULL),
	m_pLine(NULL),
	m_dwFileSize(0),
	m_dwBufLen(0),
	m_dwFileOfs(0)
{
	m_pszLogFN = NULL;
	SetLogFile(pszLogFileName);
}


//--------------------------------------------------------------------------------
// CV3AppLog::~CV3AppLog
//
// free resources
//--------------------------------------------------------------------------------
CV3AppLog::~CV3AppLog()
{
	SafeHeapFree(m_pszLogFN);
	SafeHeapFree(m_pFileBuf);
	SafeHeapFree(m_pFieldBuf);
}


//--------------------------------------------------------------------------------
// CV3AppLog::CheckBuf
//
// allocates the internal buffer to be atleast dwSize big.  Does not do anything
// if the the buffer is already big enough
//--------------------------------------------------------------------------------
void CV3AppLog::CheckBuf(DWORD dwSize)
{
	if (m_dwBufLen >= dwSize)
		return;

	SafeHeapFree(m_pFieldBuf);

	m_dwBufLen = dwSize + 16;   
    m_pFieldBuf = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwBufLen);
}


//--------------------------------------------------------------------------------
// CV3AppLog::SetLogFile
//
// sets the log file name.  Use this function if you did not specify the file name
// in the ctor
//--------------------------------------------------------------------------------
void CV3AppLog::SetLogFile(LPCTSTR pszLogFileName)
{
	SafeHeapFree(m_pszLogFN);
	
	if (pszLogFileName != NULL)
	{
		m_pszLogFN = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof (TCHAR));
		if (NULL != m_pszLogFN)
		{
		    HRESULT hr;

		    hr = StringCchCopyEx(m_pszLogFN, MAX_PATH, pszLogFileName, NULL, NULL, MISTSAFE_STRING_FLAGS);
		    if (FAILED(hr))
		    {
		        SafeHeapFree(m_pszLogFN);
		        m_pszLogFN = NULL;
		    }
		}
	}
}


//--------------------------------------------------------------------------------
// CV3AppLog::StartReading
//
// Reads the entire log in memory so we can read lines.  Following is an example:
//
//		CV3AppLog V3His("C:\\wuhistv3.log");
//		V3His.StartReading();
//		while (V3His.ReadLine())
//			// do something;
//		V3His.StopReading();
//--------------------------------------------------------------------------------
void CV3AppLog::StartReading()
{
	if (NULL != m_pszLogFN)
	{
		m_dwFileSize = 0;
		m_dwFileOfs = 0;
		SafeHeapFree(m_pFileBuf);

		HANDLE hFile = CreateFile(m_pszLogFN, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			return;

		m_dwFileSize = GetFileSize(hFile, NULL);
		if (m_dwFileSize >0)
		{
			m_pFileBuf = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwFileSize+1);
			if (NULL == m_pFileBuf)
			{
				m_dwFileSize = 0;
			}
			else
			{
				DWORD dwBytes;
				if (!ReadFile(hFile, m_pFileBuf, m_dwFileSize, &dwBytes, NULL) || dwBytes != m_dwFileSize)
				{
					SafeHeapFree(m_pFileBuf);
					m_dwFileSize = 0;
				}
			}
		}

		CloseHandle(hFile);
	}
}


//--------------------------------------------------------------------------------
// CV3AppLog::ReadLine
//
// reads a line from the memory buffer where the entire file was loaded
// moves the internal pointer to the next line. 
//--------------------------------------------------------------------------------
BOOL CV3AppLog::ReadLine()
{
	DWORD dwOrgOfs; 
	
	if (m_dwFileSize == 0 || m_dwFileOfs >= m_dwFileSize || (NULL == m_pFileBuf))
		return FALSE;

	// setup the start of field parsing
	m_pLine = &m_pFileBuf[m_dwFileOfs];

	dwOrgOfs = m_dwFileOfs;
	while (m_dwFileOfs < m_dwFileSize && m_pFileBuf[m_dwFileOfs] != '\r')
		m_dwFileOfs++;

	if ((m_dwFileOfs - dwOrgOfs) > 2048)
	{
		// self imposed limit of 2048 chars in a line
		// we consider a file with a longer line of text an invalid log file
		m_dwFileOfs	= m_dwFileSize;
		m_pLine = NULL;
		return FALSE;
	}

	// this is where we have the \r (13), we replace it with a 0 to create
	// end of string here
	m_pFileBuf[m_dwFileOfs] = '\0';

	// point the ofset to next line
	m_dwFileOfs += 2;

	// allocate enough memory to parse out fields when CopyNextField is called
	CheckBuf(m_dwFileOfs - dwOrgOfs - 2);
	if (NULL == m_pFieldBuf)
	{
		return FALSE;
	}
	return TRUE;
}


//--------------------------------------------------------------------------------
// CV3AppLog::CopyNextField
//
// parses out the current line separated by the LOG_FIELD_SEPARATOR
// and copies the string to pszBuf upto cBufSize long field and moves internal 
// pointer to next field.  When the end of line is reached, returns a blank string
// 
// RETURNS: TRUE if more fields are left, FALSE otherwise
//
// NOTES: Once you get a field you cannot get it again.  
//--------------------------------------------------------------------------------
BOOL CV3AppLog::CopyNextField(LPSTR pszBuf, int cBufSize)
{
	BOOL bMoreFields = FALSE;

	if (m_pLine == NULL || *m_pLine == '\0')
	{
		//there are no more fields 
		m_pFieldBuf[0] = '\0';
		m_pLine = NULL;
	}
	else
	{
		LPCSTR p = strstr(m_pLine, LOG_FIELD_SEPARATOR);
		if (p != NULL)
		{
		    DWORD cch;  

            // this will fail if the size of the field is > 4GB.  But it should be
            //  very unlikely that this will ever happen...
		    cch = (DWORD)(DWORD_PTR)(p - m_pLine);
		    if (cch >= m_dwBufLen)
		        cch = m_dwBufLen - 1;
		    
			// copy the field to buffer but there are still more fields

            // this is safe because we made sure above that the max amount of data
            //  copied will be ARRAYSIZE(buffer) - 1 giving us room for the NULL at the end
			CopyMemory(m_pFieldBuf, m_pLine, cch * sizeof(m_pFieldBuf[0]));
			m_pFieldBuf[cch] = '\0';
			m_pLine = const_cast<LPSTR>(p + strlen(LOG_FIELD_SEPARATOR));
			bMoreFields = TRUE;
		}
		else
		{
			// this is the last field, there are no more fields

			// don't care if this fails- it will always truncate the string which is
			//  exactly what we want
			(void)StringCchCopyExA(m_pFieldBuf, m_dwBufLen, m_pLine, NULL, NULL, MISTSAFE_STRING_FLAGS);
			m_pLine = NULL;
		}
	}

	// don't care if this fails- it will always truncate the string which is exactly what 
	//  we want
    (void)StringCchCopyExA(pszBuf, cBufSize, m_pFieldBuf, NULL, NULL, MISTSAFE_STRING_FLAGS);

	return bMoreFields;
}


//--------------------------------------------------------------------------------
// CV3AppLog::StopReading
//
// free up memory from allocated in StartReading
//--------------------------------------------------------------------------------
void CV3AppLog::StopReading()
{
	SafeHeapFree(m_pFileBuf);
	m_dwFileSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\sysspec.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   sysspec.cpp
//
//  Description:
//
//      Implementation for the GetSystemSpec() function
//
//=======================================================================

#include "iuengine.h"
#include "iuxml.h"
#include <iucommon.h>

#include <comdef.h>
#include <osdet.h>
#include <setupapi.h>
#include <regstr.h>
#include <winspool.h>	// for DRIVER_INFO_6
#include "cdmp.h"		// for GetInstalledPrinterDriverInfo()
#include <shlwapi.h>
#include <safereg.h>
#include <safefile.h>
#include <safefunc.h>
#include <wusafefn.h>





//
// Specify a V1 structure passed to SetupDiBuildDriverInfoList
// so we will work on NT4/Win9x and don't need to
// fill in the extra V2 data on Win2K up
//
#define  USE_SP_DRVINFO_DATA_V1 1

//
// Constants
//

const TCHAR SZ_WIN32_NT[] = _T("VER_PLATFORM_WIN32_NT");
const TCHAR SZ_WIN32_WINDOWS[] = _T("VER_PLATFORM_WIN32_WINDOWS");
const CHAR	SZ_GET_SYSTEM_SPEC[] = "Determining machine configuration";

#if defined(_X86_) || defined(i386)
const TCHAR SZ_PROCESSOR[] = _T("x86");
#else // defined(_IA64_) || defined(IA64)
const TCHAR SZ_PROCESSOR[] = _T("ia64");
#endif

const TCHAR SZ_SUITE_SMALLBUSINESS[] = _T("VER_SUITE_SMALLBUSINESS");
const TCHAR SZ_SUITE_ENTERPRISE[] = _T("VER_SUITE_ENTERPRISE");
const TCHAR SZ_SUITE_BACKOFFICE[] = _T("VER_SUITE_BACKOFFICE");
const TCHAR SZ_SUITE_COMMUNICATIONS[] = _T("VER_SUITE_COMMUNICATIONS");
const TCHAR SZ_SUITE_TERMINAL[] = _T("VER_SUITE_TERMINAL");
const TCHAR SZ_SUITE_SMALLBUSINESS_RESTRICTED[] = _T("VER_SUITE_SMALLBUSINESS_RESTRICTED");
const TCHAR SZ_SUITE_EMBEDDEDNT[] = _T("VER_SUITE_EMBEDDEDNT");
const TCHAR SZ_SUITE_DATACENTER[] = _T("VER_SUITE_DATACENTER");
const TCHAR SZ_SUITE_SINGLEUSERTS[] = _T("VER_SUITE_SINGLEUSERTS");
const TCHAR SZ_SUITE_PERSONAL[] = _T("VER_SUITE_PERSONAL");
const TCHAR SZ_SUITE_BLADE[] = _T("VER_SUITE_BLADE");


const TCHAR SZ_NT_WORKSTATION[] = _T("VER_NT_WORKSTATION");
const TCHAR SZ_NT_DOMAIN_CONTROLLER[] = _T("VER_NT_DOMAIN_CONTROLLER");
const TCHAR SZ_NT_SERVER[] = _T("VER_NT_SERVER");

const TCHAR SZ_AMPERSAND[] = _T("&");


const TCHAR SZ_LICDLL[]=_T("licdll.dll");

LPCSTR  lpszIVLK_GetEncPID  = (LPCSTR)227;

typedef HRESULT (WINAPI *PFUNCGetEncryptedPID)(OUT BYTE  **ppbPid,OUT DWORD *pcbPid);


//
// DriverVer in schema uses ISO 8601 prefered format (yyyy-mm-dd)
//
const TCHAR SZ_UNKNOWN_DRIVERVER[] = _T("0000-00-00");
#define SIZEOF_DRIVERVER sizeof(SZ_UNKNOWN_DRIVERVER)
#define TCHARS_IN_DRIVERVER (ARRAYSIZE(SZ_UNKNOWN_DRIVERVER) - 1)


//forward declaration for the function which gets the PID
HRESULT GetSystemPID(BSTR &bstrPID);
HRESULT BinaryToString(BYTE *lpBinary,DWORD dwLength,LPWSTR lpString,DWORD *pdwLength);

//
// Helper functions
//

HRESULT GetMultiSzDevRegProp(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, DWORD dwProperty, LPTSTR* ppMultiSZ)
{
	LOG_Block("GetMultiSzDevRegProp");

	HRESULT hr = S_OK;
	ULONG ulSize = 0;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || NULL == pDevInfoData || NULL == ppMultiSZ)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppMultiSZ = NULL;

	//
	// Several different errors may be set depending on the size/existance of the property,
	// but these aren't errors for us, we only care about filling in the buffer if the
	// property exists
	//
	(void) SetupDiGetDeviceRegistryProperty(hDevInfoSet, pDevInfoData, dwProperty, NULL, NULL, 0, &ulSize);

	if (0 < ulSize)
	{
		//
		// Create a zero initialized buffer 4 bytes (two Unicode characters) longer than we think we need
		// to protect ourselves from incorrect results returned by SetupDiGetDeviceRegistryProperties on
		// some platforms. In addition, Win98 requires at least one character more than what it returned
		// in ulSize, so we just make it 8 bytes over and pass four of them as an extra-sized buffer.
		//
		CleanUpFailedAllocSetHrMsg(*ppMultiSZ = (TCHAR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulSize + 8));

		//
		// Get the actual hardware/compatible IDs (but don't tell SetupDiXxx about the extra four bytes of buffer)
		//
		if (!SetupDiGetDeviceRegistryProperty(hDevInfoSet, pDevInfoData, dwProperty, NULL, (LPBYTE) *ppMultiSZ, ulSize + 4, NULL))
		{
			DWORD dwError = GetLastError();
			LOG_Driver(_T("Informational: SetupDiGetDeviceRegistryProperty failed: 0x%08x"), dwError);
			if (ERROR_NO_SUCH_DEVINST == dwError || ERROR_INVALID_REG_PROPERTY == dwError || ERROR_INSUFFICIENT_BUFFER == dwError)
			{
				//
				// Return valid errors
				//
				SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(dwError));
			}
			//
			// Some devices don't have the registry info we are looking for, so exit with default S_OK
			//
			goto CleanUp;
		}
	}

CleanUp:

	if (FAILED(hr))
	{
		SafeHeapFree(*ppMultiSZ);
	}

	return hr;
}

HRESULT AddIDToXml(LPCTSTR pszMultiSZ, CXmlSystemSpec& xmlSpec, DWORD dwProperty,
						  DWORD& dwRank, HANDLE_NODE& hDevices, LPCTSTR pszMatchingID, LPCTSTR pszDriverVer)
{
	LOG_Block("AddIDToXml");
	HRESULT hr = S_OK;
	BSTR bstrMultiSZ = NULL;
	BSTR bstrDriverVer = NULL;

	if (NULL == pszMultiSZ)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	//
	// Open a <device> element if necessary (don't reopen for compatible IDs)
	//
	if (HANDLE_NODE_INVALID == hDevices)
	{
		CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, -1, NULL, NULL, NULL, &hDevices));
	}

	for (NULL ; *pszMultiSZ; pszMultiSZ += (lstrlen(pszMultiSZ) + 1))
	{
		if (   NULL != pszMatchingID
			&& NULL != pszDriverVer
			&& 0 == lstrcmpi(pszMultiSZ, pszMatchingID)	)
		{
			LOG_Driver(_T("ID: %s Match: %s, rank: %d, DriverVer: %s"), pszMultiSZ, pszMatchingID, dwRank, pszDriverVer);
			CleanUpFailedAllocSetHrMsg(bstrMultiSZ = T2BSTR(pszMultiSZ));
			CleanUpFailedAllocSetHrMsg(bstrDriverVer = T2BSTR(pszDriverVer));
			CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, (SPDRP_COMPATIBLEIDS == dwProperty), dwRank++, bstrMultiSZ, bstrDriverVer));
			SafeSysFreeString(bstrMultiSZ);
			SafeSysFreeString(bstrDriverVer);
			//
			// We found the ID with the driver installed - don't pass any of lower rank up
			//
			hr = S_FALSE;
			break;
		}
		else
		{
			LOG_Driver(_T("ID: %s, rank: %d"), pszMultiSZ, dwRank);
			CleanUpFailedAllocSetHrMsg(bstrMultiSZ = T2BSTR(pszMultiSZ));
			CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, (SPDRP_COMPATIBLEIDS == dwProperty), dwRank++, bstrMultiSZ, NULL));
			SafeSysFreeString(bstrMultiSZ);
		}
	}

CleanUp:

	SysFreeString(bstrMultiSZ);
	SysFreeString(bstrDriverVer);
	return hr;
}

HRESULT DoesHwidMatchPrinter(
					DRIVER_INFO_6* paDriverInfo6,			// array of DRIVER_INFO_6 structs for installed printer drivers
					DWORD dwDriverInfoCount,				// count of structs in paDriverInfo6 array
					LPCTSTR pszMultiSZ,						// Hardware or Compatible MultiSZ to compare with installed printer drivers
					BOOL* pfHwidMatchesInstalledPrinter)	// [OUT] set TRUE if we match an installed printer driver
{
	LOG_Block("DoesHwidMatchPrinter");

	HRESULT hr = S_OK;

	if (NULL == pfHwidMatchesInstalledPrinter || NULL == pszMultiSZ)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*pfHwidMatchesInstalledPrinter = FALSE;

	if (NULL == paDriverInfo6 || 0 == dwDriverInfoCount)
	{
		LOG_Driver(_T("WARNING: We're missing printer information (maybe no installed printer drivers), so we won't prune"));
		goto CleanUp;
	}

	for (NULL; *pszMultiSZ; pszMultiSZ += (lstrlen(pszMultiSZ) + 1))
	{
		for (DWORD dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
		{
			if (NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
			{
				continue;
			}
			//
			// Use case-insensitive compares (paDriverInfo6 is different case from bstrHwidTxtTemp)
			//
			if (0 == lstrcmpi(pszMultiSZ, (paDriverInfo6 + dwCount)->pszHardwareID))
			{
				LOG_Driver(_T("HWID (%s) matches an installed printer driver"), pszMultiSZ);
				*pfHwidMatchesInstalledPrinter = TRUE;
				goto CleanUp;
			}
		}
	}

CleanUp:

	return hr;
}

HRESULT AddPrunedDevRegProps(HDEVINFO hDevInfoSet,
									PSP_DEVINFO_DATA pDevInfoData,
									CXmlSystemSpec& xmlSpec,
									LPTSTR pszMatchingID,
									LPTSTR pszDriverVer,
									DRIVER_INFO_6* paDriverInfo6,	// OK if this is NULL (no installed printer drivers)
									DWORD dwDriverInfoCount,
									BOOL fIsSysSpecCall)			// Called by GetSystemSpec and GetPackage, with slightly different behavior
{
	LOG_Block("AddPrunedDevRegProps");
	HRESULT hr = S_OK;
	LPTSTR pszMultiHwid = NULL;
	LPTSTR pszMultiCompid = NULL;
	DWORD dwRank = 0;
	HANDLE_NODE hDevices = HANDLE_NODE_INVALID;
	BOOL fHwidMatchesInstalledPrinter = FALSE;

	//
	// Get the Hardware and Compatible Multi-SZ strings so we can prune printer devices before commiting to XML.
	//
	// Note that GetMultiSzDevRegProp may return S_OK and a NULL *ppMultiSZ if the SRDP doesn't exist.
	//
	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, pDevInfoData, SPDRP_HARDWAREID, &pszMultiHwid));

	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, pDevInfoData, SPDRP_COMPATIBLEIDS, &pszMultiCompid));

	if (fIsSysSpecCall)
	{
		//
		// We prune this device if a HWID or CompID matches a HWID of an installed printer since we
		// must avoid offering a driver that may conflict with one if the installed printer drivers.
		// Other code will write <device isPrinter="1" /> elements to the system spec XML to be used in
		// offering printer drivers. NOTE, if there is no printer driver currently installed for the given
		// HWID we will just offer the driver based on the PnP match.
		//
		if (NULL != pszMultiHwid)
		{
			CleanUpIfFailedAndSetHr(DoesHwidMatchPrinter(paDriverInfo6, dwDriverInfoCount, pszMultiHwid, &fHwidMatchesInstalledPrinter));
			if(fHwidMatchesInstalledPrinter)
			{
				goto CleanUp;
			}
		}

		if (NULL != pszMultiCompid)
		{
			CleanUpIfFailedAndSetHr(DoesHwidMatchPrinter(paDriverInfo6, dwDriverInfoCount, pszMultiCompid, &fHwidMatchesInstalledPrinter));
			if(fHwidMatchesInstalledPrinter)
			{
				goto CleanUp;
			}
		}
	}

	//
	// Add the Hardware and Compatible IDs to XML
	//
	if (NULL != pszMultiHwid)
	{
		CleanUpIfFailedAndSetHr(AddIDToXml(pszMultiHwid, xmlSpec, SPDRP_HARDWAREID, dwRank, hDevices, pszMatchingID, pszDriverVer));
	}
	//
	// Skip compatible IDs if we don't have any or already found a match (hr == S_FALSE)
	//
	if (NULL != pszMultiCompid && hr == S_OK)
	{
		CleanUpIfFailedAndSetHr(AddIDToXml(pszMultiCompid, xmlSpec, SPDRP_COMPATIBLEIDS, dwRank, hDevices, pszMatchingID, pszDriverVer));
	}

CleanUp:

	SafeHeapFree(pszMultiHwid);
	SafeHeapFree(pszMultiCompid);

	if (HANDLE_NODE_INVALID != hDevices)
	{
		xmlSpec.SafeCloseHandleNode(hDevices);
	}

	return hr;
}

static HRESULT DriverVerToIso8601(LPTSTR * ppszDriverVer)
{
	LOG_Block("DriverVerToIso8601");

	HRESULT hr = S_OK;
	TCHAR pszDVTemp[TCHARS_IN_DRIVERVER + 1];
	LPTSTR pszMonth = pszDVTemp;
	LPTSTR pszDay = NULL;
	LPTSTR pszYear = NULL;

	//
	//                     buffer:      pszDVTemp                     *ppszDriverVer
	// DriverVer: "[m]m-[d]d-yyyy" or "[m]m/[d]d/yyyy" --> ISO 8601: "yyyy-mm-dd"
	//                     index:         01   234567                 0123456789
	//                                  0 12 3 456789 ,,, etc, 
	//
	if (NULL == ppszDriverVer || NULL == *ppszDriverVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

    int nInLength = lstrlen(*ppszDriverVer);
    if (nInLength < TCHARS_IN_DRIVERVER - 2 || nInLength > TCHARS_IN_DRIVERVER)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		(*ppszDriverVer)[0] = _T('\0');
		return E_INVALIDARG;
	}

	// Make sure *ppszDriverVer is large enough for ISO 8601
	//
	// **** It is VERY IMPORTANT that NO FAILURE CASE with an error of E_INVALIDARG go from before this ****
	// ****  size check to the CleanUp section below.                                                   ****
	//
	if (ARRAYSIZE(pszDVTemp) > nInLength)
	{
	    // if the size of this alloc is changed from SIZEOF_DRIVERVER, the StringCbCopy call below will need to be
	    //  changd appropriately as well.
		LPTSTR pszTemp = (LPTSTR) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (LPVOID) *ppszDriverVer, SIZEOF_DRIVERVER);
		if (NULL == pszTemp)
		{
			CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
		}
		*ppszDriverVer = pszTemp;
	}
	
	LOG_Driver(_T("In: \"%s\""), *ppszDriverVer);

	if ((_T('-') == (*ppszDriverVer)[4] || _T('/') == (*ppszDriverVer)[4]) &&
		(_T('-') == (*ppszDriverVer)[7] || _T('/') == (*ppszDriverVer)[7]))
	{
		//
		// It's probably already a valid ISO date, so do nothing
		//
		SetHrMsgAndGotoCleanUp(S_FALSE);
	}
	//
	// Unfortunately, DriverDate under HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class (Win2K)
	// in the registry doesn't *always* pad the mm and dd fields with _T('0') for single digit months and days,
	// so we have to do this the hard way. But watch out - there's more. Win98SE (and maybe more)
	// pad with spaces, so we also have to change spaces to _T('0').
	//
	
	//
	// Copy to pszDVTemp
	//
	hr = StringCchCopyEx(pszDVTemp, ARRAYSIZE(pszDVTemp), *ppszDriverVer,
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndSetHrMsg(hr);
	//
	// Find end of month, start of day
	//
	int i;
	for (i = 0; i < 3; i++)
	{
		if (_T('-') == pszMonth[i] || _T('/') == pszMonth[i])
		{
			pszMonth[i] = 0;
			pszDay = &pszMonth[i+1];
			break;
		}
		else if (_T(' ') == pszMonth[i])
		{
			pszMonth[i] = _T('0');
		}
		else if (!(_T('0') <= pszMonth[i] && _T('9') >= pszMonth[i]))
		{
			//
			// non-decimal characters other than _T('/') and "-"
			//
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}
	}
	if (NULL == pszDay || 0 == pszMonth[0])
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
	//
	// Find end of day, start of year
	//
	for (i = 0; i < 3; i++)
	{
		if (_T('-') == pszDay[i] || _T('/') == pszDay[i])
		{
			pszDay[i] = 0;
			pszYear = &pszDay[i+1];
			break;
		}
		else if (' ' == pszDay[i])
		{
			pszDay[i] = _T('0');
		}
		else if (!(_T('0') <= pszDay[i] && _T('9') >= pszDay[i]))
		{
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}
	}
	if (NULL == pszYear || 0 == pszDay[0])
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
	//
	// Verify year is four decimal digits
	//
	for (i = 0; i < 4 ; i++)
	{
		if (!(_T('0') <= pszYear[i] && _T('9') >= pszYear[i]) || _T('\0') == pszYear[i])
		{
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}
	}

	//
	// Copy back "yyyy" to start of string
	//
	hr = StringCbCopyEx(*ppszDriverVer, SIZEOF_DRIVERVER, pszYear, 
	                    NULL, NULL, MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndSetHrMsg(hr);
	
	//
	// Copy month and pad if necessary
	//
	if (2 == lstrlen(pszMonth))
	{
		(*ppszDriverVer)[5] = pszMonth[0];
		(*ppszDriverVer)[6] = pszMonth[1];
	}
	else
	{
		(*ppszDriverVer)[5] = _T('0');
		(*ppszDriverVer)[6] = pszMonth[0];
	}
	//
	// Copy day and pad if necessary
	//
	//
	if (2 == lstrlen(pszDay))
	{
		(*ppszDriverVer)[8] = pszDay[0];
		(*ppszDriverVer)[9] = pszDay[1];
	}
	else
	{
		(*ppszDriverVer)[8] = _T('0');
		(*ppszDriverVer)[9] = pszDay[0];
	}
	// Add back the field separators: _T('-')
	//
	(*ppszDriverVer)[4] = _T('-');
	(*ppszDriverVer)[7] = _T('-');
	//
	// NULL terminate string
	//
	(*ppszDriverVer)[10] = _T('\0');

CleanUp:

	//
	// If we got garbage in, copy default date to *ppszDriverVer and return S_FALSE
	//
	if (E_INVALIDARG == hr)
	{
	    // This is safe to do because we know that this function calls HeapReAlloc
		// on this buffer if it is too small above.
	    (void) StringCbCopyEx(*ppszDriverVer, SIZEOF_DRIVERVER, SZ_UNKNOWN_DRIVERVER, 
	                   NULL, NULL, MISTSAFE_STRING_FLAGS);
		hr = S_FALSE;
	}

	LOG_Driver(_T("Out: \"%s\""), *ppszDriverVer);

	return hr;
}



static HRESULT GetFirstStringField(HINF hInf, LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue, DWORD dwcValueTCHARs)
{
	LOG_Block("GetFirstStringField");

	INFCONTEXT ctx;
	HRESULT hr = S_OK;

	if (INVALID_HANDLE_VALUE == hInf	||
		NULL == szSection				||
		NULL == szKey					||
		NULL == szValue					||
		0 == dwcValueTCHARs				)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*szValue = _T('\0');
	
	if (0 == SetupFindFirstLine(hInf, szSection, szKey, &ctx))
	{
		LOG_Error(_T("SetupFindFirstLine"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (0 == SetupGetStringField(&ctx, 1, szValue, dwcValueTCHARs, NULL))
	{
		LOG_Error(_T("SetupGetStringField"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

CleanUp:

	if (FAILED(hr))
	{
		*szValue = _T('\0');
	}

	return hr;
}


static HRESULT GetPropertyFromSetupDi(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, ULONG ulProperty, LPTSTR* ppszProperty)
{
	LOG_Block("GetPropertyFromSetupDi");

	HRESULT hr = S_OK;
	ULONG ulSize = 0;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || NULL == ppszProperty)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppszProperty = NULL;

	if (!SetupDiGetDeviceRegistryProperty(hDevInfoSet, &devInfoData, ulProperty, NULL, NULL, 0, &ulSize))
	{
		if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
		{
			LOG_Error(_T("SetupDiGetDeviceRegistryProperty"));
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
	}

	if (0 == ulSize)
	{
		LOG_Error(_T("SetupDiGetDeviceRegistryProperty returned zero size"));
		SetHrAndGotoCleanUp(E_FAIL);
	}
    // Win98 has a bug when requesting SPDRP_HARDWAREID
    // NTBUG9#182680 We make this big enough to always have a Unicode double-null at the end
    // so that we don't fault if the reg value isn't correctly terminated. Don't tell SetupDiXxxx
	// about all eight extra bytes.
	ulSize += 8;
	// NTBUG9#182680 zero the buffer so we don't get random garbage - REG_MULTI_SZ isn't always double-null terminated
	CleanUpFailedAllocSetHrMsg(*ppszProperty = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulSize));

	if (!SetupDiGetDeviceRegistryProperty(hDevInfoSet, &devInfoData, ulProperty, NULL, (LPBYTE)*ppszProperty, ulSize - 4 , NULL))
	{
		LOG_Error(_T("SetupDiGetDeviceRegistryProperty"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

CleanUp:

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszProperty);
	}

	return hr;
}

static HRESULT GetPropertyFromSetupDiReg(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, LPCTSTR szProperty, LPTSTR *ppszData)
{
	LOG_Block("GetPropertyFromSetupDiReg");

	int cchValueSize = 0;
	HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
	HRESULT hr = S_OK;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || NULL == szProperty || NULL == ppszData)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppszData = NULL;
	//
	// Open a software, or driver, registry key for the device. This key is located in the Class branch.
	//
	if (INVALID_HANDLE_VALUE == (hKey = SetupDiOpenDevRegKey(hDevInfoSet, &devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ)))
	{
		LOG_Error(_T("SetupDiOpenDevRegKey"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	hr = SafeRegQueryStringValueCch(hKey, szProperty, NULL, 0, &cchValueSize);
	if (REG_E_MORE_DATA != hr || 0 == cchValueSize)
	{
		CleanUpIfFailedAndSetHrMsg(hr);
	}

	//
	// Sanity check size of data in registry
	//
	if (MAX_INF_STRING_LEN < cchValueSize)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	//
	// Add extra character of zero'ed memory for safety
	//
	CleanUpFailedAllocSetHrMsg(*ppszData = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (cchValueSize + 1) * sizeof(TCHAR)));

	CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKey, szProperty, *ppszData, cchValueSize, &cchValueSize));

CleanUp:

	if (INVALID_HANDLE_VALUE != hKey)
	{
		RegCloseKey(hKey);
	}

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszData);
	}

	return hr;
}

static HRESULT DriverVerFromInf(HINF hInf, LPTSTR pszMfg, LPTSTR pszDescription, LPTSTR* ppszDriverVer)
{
	LOG_Block("DriverVerFromInf");

	HRESULT hr;
	TCHAR szDeviceSec[MAX_PATH + 1];
	TCHAR szValue[MAX_PATH + 1];
	TCHAR szInstallSec[MAX_PATH + 1];

	if (INVALID_HANDLE_VALUE == hInf	||
		NULL == pszMfg					||
		NULL == pszDescription			||
		NULL == ppszDriverVer	)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	ZeroMemory(szDeviceSec , sizeof(szDeviceSec));
	ZeroMemory(szValue , sizeof(szValue));
	ZeroMemory(szInstallSec , sizeof(szInstallSec));
	*ppszDriverVer = NULL;
	//
	// Lie about buffer size so we are always NULL terminated
	//
	CleanUpIfFailedAndSetHr(GetFirstStringField(hInf, _T("Manufacturer"), pszMfg, szDeviceSec, ARRAYSIZE(szDeviceSec) - 1));	// Driver section

	CleanUpIfFailedAndSetHr(GetFirstStringField(hInf, szDeviceSec, pszDescription, szInstallSec, ARRAYSIZE(szInstallSec) - 1));	// Install section

	CleanUpIfFailedAndSetHr(GetFirstStringField(hInf, szInstallSec, _T("DriverVer"), szValue, ARRAYSIZE(szValue) - 1));		// DriverVer

CleanUp:

	if (FAILED(hr))
	{
		//
		// if we didn't get it from the "Manufacturer" section, try the "Version" section
		//
		hr = GetFirstStringField(hInf, _T("Version"), _T("DriverVer"), szValue, MAX_PATH);
	}

	if (SUCCEEDED(hr))
	{
		if (NULL != ppszDriverVer)
		{
		    DWORD cch = (lstrlen(szValue) + 1);
			if (NULL == (*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cch * sizeof(TCHAR))))
			{
				LOG_ErrorMsg(E_OUTOFMEMORY);
				hr = E_OUTOFMEMORY;
			}
			else
			{
				// Convert to ISO 8601 format
			    hr = StringCchCopyEx(*ppszDriverVer, cch, szValue, NULL, NULL, MISTSAFE_STRING_FLAGS);
			    if (FAILED(hr))
			    {
			        LOG_ErrorMsg(hr);
			    }
			    else
			    {
				    hr = DriverVerToIso8601(ppszDriverVer);
			    }
				if (FAILED(hr))
				{
					SafeHeapFree(*ppszDriverVer);
				}
			}
		}
	}

	return hr;
}

inline bool IsDriver(LPCTSTR szFile)
{
#if defined(DBG)
	if (NULL == szFile)
	{
		return false;
	}
#endif

	LPCTSTR szExt = PathFindExtension(szFile);
	if (NULL == szExt)
	{
		return false;
	}

	static const TCHAR* aszExt[] = {
		_T(".sys"),
		_T(".dll"),
		_T(".drv"),
		_T(".vxd"),
	};
	for(int i = 0; i < ARRAYSIZE(aszExt); i ++)
	{
		if(0 == lstrcmpi(aszExt[i], szExt))
			return true;
	}
	return false;
}

static UINT CALLBACK FileQueueScanCallback(
	IN PVOID pContext,			// setup api context
	IN UINT ulNotification,		// notification message
	IN UINT_PTR ulParam1,				// extra notification message information 1
	IN UINT_PTR /*Param2*/	)		// extra notification message information 2
{
	LOG_Block("FileQueueScanCallback");

	HRESULT hr;

	if (NULL == pContext || 0 == ulParam1)
	{
		LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
		return ERROR_INVALID_PARAMETER;
	}

	if (SPFILENOTIFY_QUEUESCAN == ulNotification)
	{
		PFILETIME pftDateLatest = (PFILETIME)pContext;
		LPCTSTR szFile = (LPCTSTR)ulParam1; 
		// Is this a binary
		if (IsDriver(szFile)) 
		{
			HANDLE hFile = INVALID_HANDLE_VALUE;
			if (SUCCEEDED(hr = SafeCreateFile(&hFile, 0, szFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
			{
				FILETIME ft;
				if (GetFileTime(hFile, NULL, NULL, &ft))
				{
#if defined(DBG)
					SYSTEMTIME st;
 					if (FileTimeToSystemTime(&ft, &st))
					{
						LOG_Out(_T("%s : %04d-%02d-%02d"), szFile, (int)st.wYear, (int)st.wMonth, (int)st.wDay);
					}
#endif
					if (CompareFileTime(pftDateLatest, &ft) < 0)
						*pftDateLatest = ft;

				}
				else
				{
					LOG_Error(_T("GetFileTime %s"), szFile);
					LOG_ErrorMsg(GetLastError());
				}
				CloseHandle(hFile);
			}
			else
			{
				LOG_Error(_T("SafeCreateFile %s:"), szFile);
				LOG_ErrorMsg(hr);
			}
		}
		else
		{
			LOG_Out(_T("%s: not a driver"), szFile);
		}
	}

	return NO_ERROR;
}

static HRESULT LatestDriverFileTime(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, LPTSTR pszMfg,
									LPTSTR pszDescription, LPTSTR pszProvider, LPCTSTR pszInfFile, LPTSTR* ppszDriverVer)
{
	LOG_Block("LatestDriverFileTime");

	HRESULT hr = S_OK;
	FILETIME ftDate = {0,0};
	HSPFILEQ hspfileq = INVALID_HANDLE_VALUE;
	SP_DEVINSTALL_PARAMS	DeviceInstallParams;

	if (INVALID_HANDLE_VALUE == hDevInfoSet ||
		NULL == pszMfg						||
		NULL == pszDescription				||
		NULL == pszProvider					||
		NULL == pszInfFile					||
		NULL == ppszDriverVer	)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	ZeroMemory(&DeviceInstallParams, sizeof(SP_DEVINSTALL_PARAMS));
	DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

	*ppszDriverVer = NULL;

	if (!SetupDiGetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		LOG_Error(_T("SetupDiGetDeviceInstallParams"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	hr = StringCchCopyEx(DeviceInstallParams.DriverPath, ARRAYSIZE(DeviceInstallParams.DriverPath),
	                     pszInfFile,
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndSetHrMsg(hr);
	
	DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;

	if (!SetupDiSetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		LOG_Error(_T("SetupDiSetDeviceInstallParams"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//Now build a class driver list from this INF.
	if (!SetupDiBuildDriverInfoList(hDevInfoSet, &devInfoData, SPDIT_CLASSDRIVER))
	{
		LOG_Error(_T("SetupDiBuildDriverInfoList"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//Prepare driver info struct
	SP_DRVINFO_DATA	DriverInfoData;
	ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));
	DriverInfoData.cbSize = sizeof(DriverInfoData);
	DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
	DriverInfoData.Reserved	= 0;

	hr = StringCchCopyEx(DriverInfoData.MfgName, ARRAYSIZE(DriverInfoData.MfgName), pszMfg, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

	hr = StringCchCopyEx(DriverInfoData.Description, ARRAYSIZE(DriverInfoData.Description), pszDescription, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

	hr = StringCchCopyEx(DriverInfoData.ProviderName, ARRAYSIZE(DriverInfoData.ProviderName), pszProvider, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

	if (!SetupDiSetSelectedDriver(hDevInfoSet, &devInfoData, (SP_DRVINFO_DATA*)&DriverInfoData))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (INVALID_HANDLE_VALUE == (hspfileq = SetupOpenFileQueue()))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Set custom queue to device install params
	if (!SetupDiGetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	DeviceInstallParams.FileQueue	 = hspfileq;
	DeviceInstallParams.Flags		|= DI_NOVCP;

	if (!SetupDiSetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (!SetupDiInstallDriverFiles(hDevInfoSet, &devInfoData))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	// Parse the queue
	DWORD dwScanResult;
	if (!SetupScanFileQueue(hspfileq, SPQ_SCAN_USE_CALLBACK, NULL, (PSP_FILE_CALLBACK)FileQueueScanCallback, &ftDate, &dwScanResult))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	SYSTEMTIME st;
 	if (!FileTimeToSystemTime(&ftDate, &st))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (1990 > st.wYear)
	{
		//
		// Didn't enumerate any files, or files had bogus dates. Return an error so
		// we will fallback on default "0000-00-00"
		//
		hr = E_NOTIMPL;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

#if defined(DBG)
	LOG_Out(_T("%s - %s %04d-%02d-%02d"), pszMfg, pszDescription, (int)st.wYear, (int)st.wMonth, (int)st.wDay);
#endif

	CleanUpFailedAllocSetHrMsg(*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, SIZEOF_DRIVERVER));

	// ISO 8601 prefered format (yyyy-mm-dd)
	hr = StringCbPrintfEx(*ppszDriverVer, SIZEOF_DRIVERVER, NULL, NULL, MISTSAFE_STRING_FLAGS, 
	                      _T("%04d-%02d-%02d"), (int)st.wYear, (int)st.wMonth, (int)st.wDay);
	CleanUpIfFailedAndSetHrMsg(hr);

CleanUp:

	if (INVALID_HANDLE_VALUE != hspfileq)
	{
		SetupCloseFileQueue(hspfileq);
	}

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszDriverVer);
	}

	return hr;
}

//
// Called if we don't get driver date from registry
//
static HRESULT GetDriverDateFromInf(HKEY hDevRegKey, HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, LPTSTR* ppszDriverVer)
{
	LOG_Block("GetDriverDateFromInf");
	HRESULT hr;
	UINT nRet;
	HINF hInf = INVALID_HANDLE_VALUE;
	LPTSTR pszMfg = NULL;
	LPTSTR pszDescription = NULL;
	LPTSTR pszProvider = NULL;
	TCHAR szInfName[MAX_PATH + 2];
	int cchValueSize;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || (HKEY)INVALID_HANDLE_VALUE == hDevRegKey || NULL == ppszDriverVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppszDriverVer = NULL;

	//
	// Get INF File name from registry, but lie about size to make sure we are NULL terminated
	//
	ZeroMemory(szInfName, sizeof(szInfName));
	CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_INFPATH, szInfName, ARRAYSIZE(szInfName)-1, &cchValueSize));

	//
	// Verify the file name ends with ".inf"
	//
	if (CSTR_EQUAL != WUCompareStringI(&szInfName[lstrlen(szInfName) - 4], _T(".inf")))
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}
	//
	// Look for szInfName in %windir%\inf\ or %windir%\inf\other\
	//
	TCHAR szInfFile[MAX_PATH + 1];
	nRet = GetWindowsDirectory(szInfFile, ARRAYSIZE(szInfFile));
	if (0 == nRet || ARRAYSIZE(szInfFile) < nRet)
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), _T("inf"));
	CleanUpIfFailedAndSetHrMsg(hr);	
	
	hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), szInfName);
	CleanUpIfFailedAndSetHrMsg(hr);	
	
	if (INVALID_HANDLE_VALUE == (hInf = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL)))
	{
		nRet = GetWindowsDirectory(szInfFile, ARRAYSIZE(szInfFile));
		if (0 == nRet || ARRAYSIZE(szInfFile) < nRet)
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), _T("inf\\other"));
		CleanUpIfFailedAndSetHrMsg(hr);	

		hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), szInfName);
		CleanUpIfFailedAndSetHrMsg(hr);	

		if (INVALID_HANDLE_VALUE == (hInf = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL)))
		{
			LOG_Driver(_T("SetupOpenInfFile %s"), szInfFile);
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
	}
	
	// first try to get it from inf
	CleanUpIfFailedAndSetHr(GetPropertyFromSetupDi(hDevInfoSet, devInfoData, SPDRP_MFG, &pszMfg));
	CleanUpIfFailedAndSetHr(GetPropertyFromSetupDi(hDevInfoSet, devInfoData, SPDRP_DEVICEDESC, &pszDescription));

	if (SUCCEEDED(hr = DriverVerFromInf(hInf, pszMfg, pszDescription, ppszDriverVer)))
	{
		goto CleanUp;
	}
	//
	// Try enumerating the files as last resort
	//
	CleanUpIfFailedAndSetHr(GetPropertyFromSetupDiReg(hDevInfoSet, devInfoData, REGSTR_VAL_PROVIDER_NAME, &pszProvider));

	hr = LatestDriverFileTime(hDevInfoSet, devInfoData, pszMfg, pszDescription, pszProvider, szInfFile, ppszDriverVer);

CleanUp:

	if (INVALID_HANDLE_VALUE != hInf)
	{
		SetupCloseInfFile(hInf);
	}

	SafeHeapFree(pszMfg);
	SafeHeapFree(pszDescription);
	SafeHeapFree(pszProvider);

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszDriverVer);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Add Classes helper functionality for GetSystemSpec() and CDM functions
/////////////////////////////////////////////////////////////////////////////
HRESULT AddComputerSystemClass(CXmlSystemSpec& xmlSpec)
{
	USES_IU_CONVERSION;
	LOG_Block("AddComputerSystemClass");

	HRESULT hr;
	BSTR bstrDrive = NULL;
	BSTR bstrPID = NULL;


	PIU_DRIVEINFO pDriveInfo = NULL;
	DWORD dwNumDrives;

	IU_PLATFORM_INFO iuPlatformInfo;

	ZeroMemory( &iuPlatformInfo, sizeof(iuPlatformInfo));
	CleanUpIfFailedAndSetHr( DetectClientIUPlatform(&iuPlatformInfo) );


	if( 4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion )
	{
		BOOL bPid = TRUE;
		
		if(5 == iuPlatformInfo.osVersionInfoEx.dwMajorVersion)
		{
			if( 1 > iuPlatformInfo.osVersionInfoEx.dwMinorVersion)
				bPid = FALSE;
			else if(1 == iuPlatformInfo.osVersionInfoEx.dwMinorVersion)
			{
				if(1 > iuPlatformInfo.osVersionInfoEx.wServicePackMajor)
					bPid = FALSE;
			}
		}

		if(bPid)
			GetSystemPID(bstrPID);

		//Note: Return value  is not checked because
		//Any failure to get the PID is not considered as a failure on the GetSystemSpec method
		//If the pid attribute is missing on the supported platforms  it is still considered as 
		//an invalid pid case and no items will be returned in the catalog from the server
		//if there is any error bstrPID will  be null and it will not be added to 
		//the systemspec xml
	}


	//CleanUpIfFailedAndSetHr(GetOemBstrs(bstrManufacturer, bstrModel, bstrOEMSupportURL));
	// NTRAID#NTBUG9-277070-2001/01/12-waltw IUpdate methods should return
	// HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED) when Windows Update is disabled
	// Just pass -1 to AddComputerSystem()

	CleanUpIfFailedAndSetHr(xmlSpec.AddComputerSystem(iuPlatformInfo.bstrOEMManufacturer, iuPlatformInfo.bstrOEMModel,
				iuPlatformInfo.bstrOEMSupportURL, IsAdministrator(), IsWindowsUpdateDisabled(), IsAutoUpdateEnabled(), bstrPID));

	CleanUpIfFailedAndSetHr(GetLocalFixedDriveInfo(&dwNumDrives, &pDriveInfo));

	for (DWORD i = 0; i < dwNumDrives; i++)
	{
		CleanUpFailedAllocSetHrMsg(bstrDrive = SysAllocString(T2OLE((&pDriveInfo[i])->szDriveStr)));

		CleanUpIfFailedAndSetHr(xmlSpec.AddDriveSpace(bstrDrive, (&pDriveInfo[i])->iKBytes));
		
		SafeSysFreeString(bstrDrive);
	}

CleanUp:

	SafeHeapFree(pDriveInfo);
	SysFreeString(bstrDrive);
	SysFreeString(bstrPID);
	return hr;
}

HRESULT AddRegKeyClass(CXmlSystemSpec& xmlSpec)
{
	LOG_Block("AddRegKeysClass");

	HRESULT hr = S_OK;
	LONG lRet;
	HKEY hkSoftware;
	TCHAR szSoftware[MAX_PATH];
	DWORD dwcSoftware;
	DWORD dwIndex = 0;
	FILETIME ftLastWriteTime;
	BSTR bstrSoftware = NULL;
	BOOL fRegKeyOpened = FALSE;

	if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE"), 0, KEY_READ, &hkSoftware)))
	{
		Win32MsgSetHrGotoCleanup(lRet);
	}
	else
	{
		fRegKeyOpened = TRUE;
	}

	do
	{
		dwcSoftware = MAX_PATH;
		if (ERROR_SUCCESS != (lRet = (RegEnumKeyEx(hkSoftware, dwIndex++, szSoftware, &dwcSoftware, NULL, NULL, NULL, &ftLastWriteTime))))
		{
			if (ERROR_NO_MORE_ITEMS == lRet)
			{
				break;
			}
			else
			{
				LOG_ErrorMsg(lRet);
				hr = HRESULT_FROM_WIN32(lRet);
				break;
			}
		}
		CleanUpFailedAllocSetHrMsg(bstrSoftware = T2BSTR(szSoftware));
		CleanUpIfFailedAndSetHr(xmlSpec.AddReg(bstrSoftware));
		SafeSysFreeString(bstrSoftware);

	} while (ERROR_SUCCESS == lRet);

CleanUp:

	SysFreeString(bstrSoftware);

	if (TRUE == fRegKeyOpened)
	{
		RegCloseKey(hkSoftware);
	}
	return hr;
}

HRESULT AddPlatformClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo)
{
	USES_IU_CONVERSION;
	LOG_Block("AddPlatformClass");

	HRESULT hr;
	BSTR bstrTemp = NULL;

	// NOTE: we never expect to be called on Win32s
	const TCHAR* pszPlatformName = (VER_PLATFORM_WIN32_NT == iuPlatformInfo.osVersionInfoEx.dwPlatformId)
															? SZ_WIN32_NT : SZ_WIN32_WINDOWS;

	CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(pszPlatformName));
	CleanUpIfFailedAndSetHr(xmlSpec.AddPlatform(bstrTemp));
	SafeSysFreeString(bstrTemp);

	CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_PROCESSOR));
	CleanUpIfFailedAndSetHr(xmlSpec.AddProcessor(bstrTemp));
	SafeSysFreeString(bstrTemp);


	hr = xmlSpec.AddVersion(	iuPlatformInfo.osVersionInfoEx.dwMajorVersion,
								iuPlatformInfo.osVersionInfoEx.dwMinorVersion,
								iuPlatformInfo.osVersionInfoEx.dwBuildNumber,
								(sizeof(OSVERSIONINFOEX) == iuPlatformInfo.osVersionInfoEx.dwOSVersionInfoSize)
									? iuPlatformInfo.osVersionInfoEx.wServicePackMajor : 0,
								(sizeof(OSVERSIONINFOEX) == iuPlatformInfo.osVersionInfoEx.dwOSVersionInfoSize)
									? iuPlatformInfo.osVersionInfoEx.wServicePackMinor : 0
							);
	CleanUpIfFailedAndSetHr(hr);

	//
	// If we can, add Suite and Product Type
	//
	if (sizeof(OSVERSIONINFOEX) == iuPlatformInfo.osVersionInfoEx.dwOSVersionInfoSize)
	{
		//
		// Add all suites
		//
		if (VER_SUITE_SMALLBUSINESS & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_SMALLBUSINESS));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_ENTERPRISE & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_ENTERPRISE));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_BACKOFFICE & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_BACKOFFICE));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_COMMUNICATIONS & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_COMMUNICATIONS));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_TERMINAL & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_TERMINAL));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_SMALLBUSINESS_RESTRICTED & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_SMALLBUSINESS_RESTRICTED));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_EMBEDDEDNT & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_EMBEDDEDNT));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_DATACENTER & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_DATACENTER));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_SINGLEUSERTS & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_SINGLEUSERTS));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_PERSONAL & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_PERSONAL));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_BLADE & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_BLADE));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		//
		// Add Product Type
		//
		if (VER_NT_WORKSTATION == iuPlatformInfo.osVersionInfoEx.wProductType)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_NT_WORKSTATION));
			CleanUpIfFailedAndSetHr(xmlSpec.AddProductType(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}
		else if (VER_NT_DOMAIN_CONTROLLER == iuPlatformInfo.osVersionInfoEx.wProductType)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_NT_DOMAIN_CONTROLLER));
			CleanUpIfFailedAndSetHr(xmlSpec.AddProductType(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}
		else if (VER_NT_SERVER == iuPlatformInfo.osVersionInfoEx.wProductType)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_NT_SERVER));
			CleanUpIfFailedAndSetHr(xmlSpec.AddProductType(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}
		// else skip - there's a new one defined we don't know about
	}

CleanUp:

	SysFreeString(bstrTemp);
	return hr;
}

HRESULT AddLocaleClass(CXmlSystemSpec& xmlSpec, BOOL fIsUser)
{
	LOG_Block("AddLocaleClass");

	HRESULT hr;
	BSTR bstrTemp = NULL;
	HANDLE_NODE hLocale = HANDLE_NODE_INVALID;
	TCHAR szLang[256] = _T("");	// Usually ISO format five characters + NULL (en-US) but note exceptions
								// such as "el_IBM"

	CleanUpFailedAllocSetHrMsg(bstrTemp = SysAllocString(fIsUser ? L"USER" : L"OS"));
	CleanUpIfFailedAndSetHr(xmlSpec.AddLocale(bstrTemp, &hLocale));
	SafeSysFreeString(bstrTemp);

	LookupLocaleString((LPTSTR) szLang, ARRAYSIZE(szLang), fIsUser ? TRUE : FALSE);
	CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(szLang));
	CleanUpIfFailedAndSetHr(xmlSpec.AddLanguage(hLocale, bstrTemp));
	SafeSysFreeString(bstrTemp);
	xmlSpec.SafeCloseHandleNode(hLocale);

CleanUp:

	if (HANDLE_NODE_INVALID != hLocale)
	{
		xmlSpec.SafeCloseHandleNode(hLocale);
	}

	SysFreeString(bstrTemp);
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// NOTE: Caller must clean up heap allocations made for *ppszMatchingID and *ppszDriverVer
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT GetMatchingDeviceID(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, LPTSTR* ppszMatchingID, LPTSTR* ppszDriverVer)
{
	LOG_Block("GetMatchingDeviceID");

	HKEY hDevRegKey = (HKEY) INVALID_HANDLE_VALUE;
	HRESULT hr = S_OK;

	if (NULL == ppszMatchingID || NULL == ppszDriverVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppszMatchingID = NULL;
	*ppszDriverVer = NULL;

	//
	// Get the MatchingDeviceID and DriverDate (succeedes only if driver is already installed)
	//
	if (INVALID_HANDLE_VALUE == (hDevRegKey = SetupDiOpenDevRegKey(hDevInfoSet, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ)))
	{
		LOG_Driver(_T("Optional SetupDiOpenDevRegKey returned INVALID_HANDLE_VALUE"));
	}
	else
	{
		int cchValueSize = 0;
		hr = SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_MATCHINGDEVID, NULL, 0, &cchValueSize);
		if (REG_E_MORE_DATA != hr || 0 == cchValueSize)
		{
			LOG_Driver(_T("Driver doesn't have a matching ID"));
			//
			// This is not an error
			//
			hr = S_OK;
		}
		else
		{
			//
			// Sanity check size of data in registry
			//
			if (MAX_INF_STRING_LEN < cchValueSize)
			{
				CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
			}
			//
			// MatchingDeviceID
			//
			// Add extra character of zero'ed memory for safety
			//
			CleanUpFailedAllocSetHrMsg(*ppszMatchingID = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (cchValueSize + 1) * sizeof(TCHAR)));

			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_MATCHINGDEVID, *ppszMatchingID, cchValueSize, &cchValueSize));
			//
			// We got the matching ID, now do our best to get DriverVer (prefer from registry)
			//
			hr = SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_DRIVERDATE, NULL, 0, &cchValueSize);
			if (REG_E_MORE_DATA != hr || 0 == cchValueSize)
			{
				LOG_Error(_T("No DRIVERDATE registry key, search the INF"));
				//
				// Search the INF and driver files for a date
				//
				if (FAILED(hr = GetDriverDateFromInf(hDevRegKey, hDevInfoSet, *pDevInfoData, ppszDriverVer)))
				{
					//
					// Use a default driver date
					//
					CleanUpFailedAllocSetHrMsg(*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SIZEOF_DRIVERVER));
                    hr = StringCbCopyEx(*ppszDriverVer, SIZEOF_DRIVERVER, SZ_UNKNOWN_DRIVERVER, 
                                        NULL, NULL, MISTSAFE_STRING_FLAGS);
                    CleanUpIfFailedAndSetHrMsg(hr);
				}
			}
			else
			{
				//
				// Sanity check size of data in registry
				//
				if (MAX_INF_STRING_LEN < cchValueSize)
				{
					CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
				}
				//
				// Get the driver date from the registry
				//
				// Add extra character of zero'ed memory for safety
				//
				CleanUpFailedAllocSetHrMsg(*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (cchValueSize + 1) * sizeof(TCHAR)));

				CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_DRIVERDATE, *ppszDriverVer, cchValueSize, &cchValueSize));
				//
				// Convert to ISO 8601 format
				//
				CleanUpIfFailedAndSetHr(DriverVerToIso8601(ppszDriverVer));
			}
		}
	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hDevRegKey)
	{
		RegCloseKey(hDevRegKey);
	}

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszMatchingID);
		SafeHeapFree(*ppszDriverVer);
	}

	return hr;
}			


HRESULT AddDevicesClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo, BOOL fIsSysSpecCall)
{
	USES_IU_CONVERSION;
	LOG_Block("AddDevicesClass");

	HRESULT hr = E_NOTIMPL;
	LONG lRet;
	BSTR bstrProvider = NULL;
	BSTR bstrMfgName = NULL;
	BSTR bstrName = NULL;
	BSTR bstrHardwareID = NULL;
	BSTR bstrDriverVer = NULL;
	DWORD dwDeviceIndex = 0;
	HDEVINFO hDevInfoSet = INVALID_HANDLE_VALUE;
	HANDLE_NODE hPrinterDevNode = HANDLE_NODE_INVALID;
	SP_DEVINFO_DATA devInfoData;
	LPTSTR	pszMatchingID = NULL;
	LPTSTR	pszDriverVer= NULL;
	DRIVER_INFO_6* paDriverInfo6 = NULL;
	DWORD dwDriverInfoCount = 0;

	//
	// We only enumerate drivers on Win2K up or Win98 up
	//
	if (  ( (VER_PLATFORM_WIN32_NT == iuPlatformInfo.osVersionInfoEx.dwPlatformId) &&
			(4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion)
		  )
		  ||
		  ( (VER_PLATFORM_WIN32_WINDOWS == iuPlatformInfo.osVersionInfoEx.dwPlatformId) &&
			(	(4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion)	||
				(	(4 == iuPlatformInfo.osVersionInfoEx.dwMajorVersion) &&
					(0 < iuPlatformInfo.osVersionInfoEx.dwMinorVersion)	)	)
		  )
		)
	{
		//
		// Get array of DRIVER_INFO_6 holding info on installed printer drivers. Only allocates and returns
		// memory for appropriate platforms that have printer drivers already installed.
		//
		CleanUpIfFailedAndSetHr(GetInstalledPrinterDriverInfo((OSVERSIONINFO*) &iuPlatformInfo.osVersionInfoEx, &paDriverInfo6, &dwDriverInfoCount));

		if (INVALID_HANDLE_VALUE == (hDevInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES)))
		{
			LOG_Error(_T("SetupDiGetClassDevs failed: 0x%08x"), GetLastError());
			return HRESULT_FROM_WIN32(GetLastError());
		}
		
		ZeroMemory(&devInfoData, sizeof(SP_DEVINFO_DATA));
		devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
		while (SetupDiEnumDeviceInfo(hDevInfoSet, dwDeviceIndex++, &devInfoData))
		{
			CleanUpIfFailedAndSetHr(GetMatchingDeviceID(hDevInfoSet, &devInfoData, &pszMatchingID, &pszDriverVer));
			//
			// Write the Hardware & Compatible IDs to XML
			//
			CleanUpIfFailedAndSetHr(AddPrunedDevRegProps(hDevInfoSet, &devInfoData, xmlSpec, pszMatchingID, \
												pszDriverVer, paDriverInfo6, dwDriverInfoCount, fIsSysSpecCall));

			SafeHeapFree(pszMatchingID);
			SafeHeapFree(pszDriverVer);
		}
		if (ERROR_NO_MORE_ITEMS != GetLastError())
		{
				Win32MsgSetHrGotoCleanup(GetLastError());
		}
		//
		// Get the Printer "Hardware IDs" for Win2K up (already checked dwMajorVersion) & WinME
		//
		if (NULL != paDriverInfo6 && 0 != dwDriverInfoCount)
		{
			//
			// Add the driver elements for each printer driver. 
			//
			for (DWORD dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
			{
				if (   NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
				{
					LOG_Driver(_T("Skiping driver with incomplete ID info"));
					continue;
				}

				//
				// Open a <device> element to write the printer info
				//
				CleanUpFailedAllocSetHrMsg(bstrProvider = T2BSTR((paDriverInfo6 + dwCount)->pszProvider));
				CleanUpFailedAllocSetHrMsg(bstrMfgName = T2BSTR((paDriverInfo6 + dwCount)->pszMfgName));
				CleanUpFailedAllocSetHrMsg(bstrName = T2BSTR((paDriverInfo6 + dwCount)->pName));
				CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, 1, bstrProvider, bstrMfgName, bstrName, &hPrinterDevNode));
				//
				// Convert ftDriverDate to ISO 8601 prefered format (yyyy-mm-dd)
				//
				SYSTEMTIME systemTime;
				if (0 == FileTimeToSystemTime(&((paDriverInfo6 + dwCount)->ftDriverDate), &systemTime))
				{
					LOG_Error(_T("FileTimeToSystemTime failed:"));
					LOG_ErrorMsg(GetLastError());
					SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(GetLastError()));
				}

				TCHAR szDriverVer[11];
				hr = StringCchPrintfEx(szDriverVer, ARRAYSIZE(szDriverVer), NULL, NULL, MISTSAFE_STRING_FLAGS,
				                       _T("%04d-%02d-%02d"), systemTime.wYear, systemTime.wMonth, systemTime.wDay);
				if (FAILED(hr))
				{
					LOG_Error(_T("wsprintf failed:"));
					LOG_ErrorMsg(GetLastError());
					SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(GetLastError()));
				}

				// Always rank 0 and never fIsCompatible
				CleanUpFailedAllocSetHrMsg(bstrHardwareID = T2BSTR((paDriverInfo6 + dwCount)->pszHardwareID));
				CleanUpFailedAllocSetHrMsg(bstrDriverVer = T2BSTR(szDriverVer));
				CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hPrinterDevNode, FALSE, 0, bstrHardwareID, bstrDriverVer));
				xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
				//
				// 514009 Apparent memory leak in getting info - Getsystemspec increases memory
				// consumption as follows - approximately 32 Kb when successfully called with all
				// class types (also approximately 8 Kb on failed call to get iexplorer server context)
				//
				// T2BSTR macro calls SysAllocString()
				//
				SafeSysFreeString(bstrProvider);
				SafeSysFreeString(bstrMfgName);
				SafeSysFreeString(bstrName);
				SafeSysFreeString(bstrHardwareID);
				SafeSysFreeString(bstrDriverVer);
			}
		}
	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hDevInfoSet)
	{
		if (0 == SetupDiDestroyDeviceInfoList(hDevInfoSet))
		{
			LOG_Driver(_T("Warning: SetupDiDestroyDeviceInfoList failed: 0x%08x"), GetLastError());
		}
	}

	if (HANDLE_NODE_INVALID != hPrinterDevNode)
	{
		xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
	}

	SafeHeapFree(pszMatchingID);
	SafeHeapFree(pszDriverVer);
	SafeHeapFree(paDriverInfo6);

	SysFreeString(bstrProvider);
	SysFreeString(bstrMfgName);
	SysFreeString(bstrName);
	SysFreeString(bstrHardwareID);
	SysFreeString(bstrDriverVer);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetSystemSpec()
//
// Gets the basic system specs.
// Input:
// bstrXmlClasses - a list of requested classes in xml format, NULL BSTR if all.
//				    For example:
//						<?xml version=\"1.0\"?>
//						<classes xmlns=\"file://\\kingbird\winupddev\Slm\src\Specs\v4\systeminfoclassschema.xml\">
//							<computerSystem/>
//							<regKeys/>
//							<platform/>
//							<locale/>
//							<devices/>
//						</classes>
//					Where all of the classes are optional.
//
// Return:
// pbstrXmlDetectionResult - the detection result in xml format.
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::GetSystemSpec(BSTR bstrXmlClasses, DWORD dwFlags, BSTR *pbstrXmlDetectionResult)
{
	USES_IU_CONVERSION;
	LOG_Block("GetSystemSpec");

	//
	// By default we return all <classes/>
	//
	DWORD dwClasses = (COMPUTERSYSTEM | REGKEYS	| PLATFORM | LOCALE | DEVICES);
	HRESULT hr = S_OK;
	IU_PLATFORM_INFO iuPlatformInfo;
	CXmlSystemSpec xmlSpec;

	if (NULL == pbstrXmlDetectionResult)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*pbstrXmlDetectionResult = NULL;

	//
	// We have to init iuPlatformInfo (redundant) because we may goto CleanUp before calling DetectClientIUPlatform
	//
	ZeroMemory(&iuPlatformInfo, sizeof(iuPlatformInfo));

    // Set Global Offline Flag - checked by XML Classes to disable Validation (schemas are on the net)
    if (dwFlags & FLAG_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

	//
	// 494519 A call to GetSystemSpec with bstrXmlClasses that is less then 10 character suceeds, weather it is valid or invalid XML.
	//
	// If client passes us anything it must be well formed [and possibly valid] XML
	//
	// But, allow BSTRs of length 0 to be treated the same as a NULL BSTR
	//     (497059 A call to GetSystemSpec with bstrXmlClasses equal
	//     to empty string fails.)
	//
	if (NULL != bstrXmlClasses && SysStringLen(bstrXmlClasses) > 0)
	{
		CXmlSystemClass xmlClass;
		if (FAILED(hr = xmlClass.LoadXMLDocument(bstrXmlClasses, m_fOfflineMode)))
		{
			//
			// They probably passed us invalid XML
			//
			goto CleanUp;
		}

		dwClasses = xmlClass.GetClasses();
	}

	

	//
	// Add the ComputerSystem node
	//

	if (dwClasses & COMPUTERSYSTEM)
	{
		CleanUpIfFailedAndSetHr(AddComputerSystemClass(xmlSpec));
	}

	//
	// Enumerate and add the Software RegKey elements
	//
	if (dwClasses & REGKEYS)
	{
		CleanUpIfFailedAndSetHr(AddRegKeyClass(xmlSpec));
	}

	//
	// We need iuPlatformInfo for both <platform> and <devices>  elements
	//
	
	if (dwClasses & (PLATFORM | DEVICES))
	{
		CleanUpIfFailedAndSetHr(DetectClientIUPlatform(&iuPlatformInfo));
	}

	//
	// Add Platform
	//
	if (dwClasses & PLATFORM)
	{
		CleanUpIfFailedAndSetHr(AddPlatformClass(xmlSpec, iuPlatformInfo));
	}

	//
	// Add Locale information
	//
	if (dwClasses & LOCALE)
	{
		//
		// OS locale
		//
		CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, FALSE));
		//
		// USER locale
		//
		CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, TRUE));
	}

	//
	// Add devices
	//
	if (dwClasses & DEVICES)
	{
		CleanUpIfFailedAndSetHr(AddDevicesClass(xmlSpec, iuPlatformInfo, TRUE));
	}

	

CleanUp:

	//
	// Only return S_OK for success (S_FALSE sometimes drops through from above)
	//
	if (S_FALSE == hr)
	{
		hr = S_OK;
	}

	if (SUCCEEDED(hr))
	{
		//
		// Return the spec as a BSTR
		//
		hr = xmlSpec.GetSystemSpecBSTR(pbstrXmlDetectionResult);
	}

	if (SUCCEEDED(hr))
	{
		LogMessage(SZ_GET_SYSTEM_SPEC);
	}
	else
	{
		LogError(hr, SZ_GET_SYSTEM_SPEC);
		//
		// If the DOM allocates but returns error, we will leak, but
		// this is safer than calling SysFreeString()
		//
		*pbstrXmlDetectionResult = NULL;
	}

	SysFreeString(iuPlatformInfo.bstrOEMManufacturer);
	SysFreeString(iuPlatformInfo.bstrOEMModel);
	SysFreeString(iuPlatformInfo.bstrOEMSupportURL);

	return hr;
}



// Function name	: GetSystemPID
// Description	    : This method basically obtaing the encrypted version of the System PID
// This method also converts the binary blob in to string format
// Return type		: HRESULT 
// Argument         : BSTR &bstrPID  --containg the hex encoded string
// author			:a-vikuma



HRESULT GetSystemPID(BSTR &bstrPID)
{

	LOG_Block("GetSystemPID");

	HRESULT hr = S_OK;
	HMODULE hLicDll = NULL;
	PFUNCGetEncryptedPID pPIDEncrProc = NULL;
	
	BYTE *pByte = NULL;
	DWORD dwLen = 0;
	
	LPWSTR 	lpszData = NULL;
	

	if(bstrPID)
	{
		bstrPID = NULL;
	}


	//load the pid encryption library
	hLicDll = LoadLibraryFromSystemDir(SZ_LICDLL);

	if (!hLicDll)
    { 
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto CleanUp;
    }

	//get the pointer to GetEncryptedPID method 
	pPIDEncrProc = (PFUNCGetEncryptedPID)GetProcAddress(hLicDll, lpszIVLK_GetEncPID);

	if (!pPIDEncrProc)
    { 
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto CleanUp;
    }

	CleanUpIfFailedAndSetHrMsg(pPIDEncrProc(&pByte, &dwLen));
	
	
	DWORD dwSize = 0;
	

	//convert the binary stream to string format
	//initially get the length for the string buffer
	CleanUpIfFailedAndSetHrMsg(BinaryToString(pByte, dwLen, lpszData, &dwSize));

	//allocate memory
	CleanUpFailedAllocSetHrMsg( lpszData = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize*sizeof(WCHAR)));

	//get the binary blob in string format
	CleanUpIfFailedAndSetHrMsg(BinaryToString(pByte, dwLen, lpszData, &dwSize));

	//convert the LPWSTR to a BSTR
	CleanUpFailedAllocSetHrMsg(bstrPID = SysAllocString(lpszData));

	
CleanUp:

	if(hLicDll)
		FreeLibrary(hLicDll);

	SafeHeapFree(lpszData);

	//LocalFree can take nulls. So not checked if pByte is null
	LocalFree(pByte);

	if(FAILED(hr))
	{
	
		SysFreeString(bstrPID);
		bstrPID = NULL;
	
	}
	return hr;

}


// Function name	: HexEncode
// Description	    : This is a helper function to convert a binary stream in to string format
// Return type		: DWORD 
// Argument         : IN BYTE const *pbIn
// Argument         : DWORD cbIn
// Argument         : WCHAR *pchOut
// Argument         : DWORD *pcchOut

DWORD HexEncode(IN BYTE const *pbIn, DWORD cbIn, WCHAR *pchOut, DWORD *pcchOut)
{
    WCHAR *pszsep;
    WCHAR *psznl;
    DWORD nCount;
    DWORD cbremain;
    DWORD cchOut = 0;

	//each byte needs two characters for encoding
    DWORD cch = 2;
    WCHAR *pch = pchOut;
    DWORD dwErr = ERROR_INSUFFICIENT_BUFFER;
	
    DWORD dwRem = *pcchOut;


	HRESULT hr = S_OK;
   
    for (nCount = 0; nCount < cbIn; nCount ++)
    {
		if (NULL != pchOut)
		{
			if (cchOut + cch + 1 > *pcchOut)
			{
				goto ErrorReturn;
			}
			hr = StringCchPrintfW(pch, dwRem, L"%02x", pbIn[nCount]);
			if(FAILED(hr))
			{
				dwErr = HRESULT_CODE(hr);
				goto ErrorReturn;
			}
			pch += cch;
			dwRem -= cch;
		}
		cchOut += cch;
    }
  
	if (NULL != pchOut)
	{

		*pch = L'\0';

	}

    *pcchOut = cchOut+1;
    dwErr = ERROR_SUCCESS;

ErrorReturn:
    return(dwErr);
}



// Function name	: BinaryToString
// Description	    : This function converts a binary stream in to a string format
// Return type		: HRESULT 
// Argument         : BYTE *lpBinary --The binary stream
// Argument         : DWORD dwLength --The length of the stream
// Argument         : LPWSTR lpString --Pointer to the string which contains the converted encoded data on return
// If this parameter is NULL the DWORD pointed ny pdwLength parameter contains to the size of the buffer needed to hold
// the encoded data
// Argument         : DWORD *pdwLength --pointer to the zise of the string buffer in no of characters


HRESULT BinaryToString(BYTE *lpBinary, DWORD dwLength, LPWSTR lpString, DWORD *pdwLength)
{

	HRESULT hr = S_OK;

	if(!lpBinary || !pdwLength)
		return E_INVALIDARG;

	DWORD dwStatus = HexEncode(lpBinary, dwLength, lpString, pdwLength);

	if(ERROR_SUCCESS != dwStatus)
	{
		hr = HRESULT_FROM_WIN32(dwStatus);

	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\manifest.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   manifest.cpp
//
//  Description:
//
//      Implementation for the GetManifest() function
//
//=======================================================================

#include "iuengine.h"
#include <iucommon.h>
#include <fileutil.h>
#include <shlwapi.h>
#include <wininet.h>
#include "schemamisc.h"
#include "WaitUtil.h"
#include "download.h"
#include <httprequest.h>
#include <httprequest_i.c>
#include <iuxml.h>

#define QuitIfNull(p) {if (NULL == p) {hr = E_INVALIDARG; LOG_ErrorMsg(hr);	return hr;}}
#define QuitIfFail(x) {hr = x; if (FAILED(hr)) goto CleanUp;}




#define ERROR_INVALID_PID 100
#define E_INVALID_PID MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,ERROR_INVALID_PID)
#define errorInvalidLicense 1
const TCHAR g_szInvalidPID[]			= _T("The PID is invalid");



const TCHAR IDENT_IUSCHEMA[]			= _T("IUSchema");
const TCHAR IDENT_IUSCHEMA_SOAPQUERY[]	= _T("SOAPQuerySchema");
const TCHAR IDENT_IUSERVERCACHE[]		= _T("IUServerCache");
const TCHAR IDENT_IUSERVERCOUNT[]		= _T("ServerCount");
const TCHAR IDENT_IUSERVER[]			= _T("Server");

const CHAR	SZ_GET_MANIFEST[] = "Querying software update catalog from";
const CHAR	SZ_GET_MANIFEST_ERROR[] = "Querying software update catalog";

HRESULT ValidatePID(IXMLDOMDocument *pXmlDomDocument);
void PingInvalidPID(BSTR bstrClientName,HRESULT hRes,HANDLE *phQuit,DWORD dwNumHandles);


/////////////////////////////////////////////////////////////////////////////
// Function forward declarations
/////////////////////////////////////////////////////////////////////////////
HRESULT GetServerURL(IXMLDOMDocument *pXMLQuery, IXMLDOMDocument *pXMLClientInfo, LPTSTR *ppszURL);
HRESULT GetSOAPQuery(IXMLDOMDocument *pXMLClientInfo, IXMLDOMDocument *pXMLSystemSpec,
					 IXMLDOMDocument *pXMLQuery, IXMLDOMDocument **ppSOAPQuery);

/////////////////////////////////////////////////////////////////////////////
// GetManifest()
//
// Gets a catalog base on the specified information.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlSystemSpec - the detected system specifications in xml
// bstrXmlQuery - the user query infomation in xml
// Return:
// pbstrXmlCatalog - the xml catalog retrieved
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::GetManifest(BSTR	bstrXmlClientInfo,
						   BSTR	bstrXmlSystemSpec,
						   BSTR	bstrXmlQuery,
						   DWORD dwFlags,
						   BSTR *pbstrXmlCatalog)
{
	LOG_Block("GetManifest()");

    // clear any previous cancel event
    ResetEvent(m_evtNeedToQuit);

	USES_IU_CONVERSION;

	HRESULT	hr	= E_FAIL;
	CXmlClientInfo	xmlClientInfo;
	IXMLDOMDocument *pXMLSystemSpec		= NULL;
	IXMLDOMDocument	*pXMLQuery			= NULL;
	IXMLDOMDocument	*pSOAPQuery			= NULL;
	IXMLHttpRequest	*pIXMLHttpRequest	= NULL;
	IWinHttpRequest *pWinHttpRequest	= NULL;
	BSTR	bstrXmlSOAPQuery = NULL;
	BSTR	bstrPOST = NULL, bstrURL = NULL;
	BSTR	bstrClientName = NULL;
	LPTSTR	pszURL = NULL;
	LONG lCount = 0;
	MSG msg;
	DWORD dwRet;
	BOOL fDontAllowProxy = FALSE;
	SAUProxySettings pauProxySettings;
	ZeroMemory(&pauProxySettings, sizeof(SAUProxySettings));

	//
	// load the DOM Doc for Query, ClientInfo, SystemSpec respectively
	//
	LOG_XmlBSTR(bstrXmlQuery);
	hr = LoadXMLDoc(bstrXmlQuery, &pXMLQuery, FALSE);
	CleanUpIfFailedAndMsg(hr);

	LOG_XmlBSTR(bstrXmlClientInfo);
	hr = xmlClientInfo.LoadXMLDocument(bstrXmlClientInfo, FALSE);
	CleanUpIfFailedAndMsg(hr);

	CleanUpIfFailedAndSetHrMsg(xmlClientInfo.GetClientName(&bstrClientName));

	CleanUpIfFailedAndSetHrMsg(g_pUrlAgent->IsClientSpecifiedByPolicy(OLE2T(bstrClientName)));


	//
	// Set flag to NOT set proxy for WinHTTP
	//
	if (S_FALSE ==hr)
	{
		fDontAllowProxy = FALSE;
		hr = S_OK;
	}
	else // S_OK
	{
		fDontAllowProxy = TRUE;
	}

	//
	// we treat bstrXmlSystemSpec as optional
	//
	if (NULL != bstrXmlSystemSpec && SysStringLen(bstrXmlSystemSpec) > 0)
	{
		LOG_XmlBSTR(bstrXmlSystemSpec);
		hr = LoadXMLDoc(bstrXmlSystemSpec, &pXMLSystemSpec, FALSE);
		CleanUpIfFailedAndMsg(hr);
	}

	//
	// retrieve the ServerCache URL from the Query xml doc and validate it
	//
	hr = GetServerURL(pXMLQuery, xmlClientInfo.GetDocument(), &pszURL);
	CleanUpIfFailedAndMsg(hr);

	//
	// concatenate the above several xml client input into a single XML
	// with the SOAP syntax/format that the server recognizes
	//
	hr = GetSOAPQuery(xmlClientInfo.GetDocument(), pXMLSystemSpec, pXMLQuery, &pSOAPQuery);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
        goto CleanUp;
	}
#if defined(DBG)
	else
	{
		BSTR	bstrSOAPQuery = NULL;
		pSOAPQuery->get_xml(&bstrSOAPQuery);
		LOG_XmlBSTR(bstrSOAPQuery);
		SafeSysFreeString(bstrSOAPQuery);
	}
#endif
	//
	// change again: add WINHTTP support for AU running as a service;
	//               use GetAllowedDownloadTransport(0) to determine -
	//               1)  0 == try winhttp first & if that fails, try wininet.
	//               2)  WUDF_ALLOWWINHTTPONLY == only try winhttp.  never fall back on wininet.
	//               3)  WUDF_ALLOWWININETONLY == only try wininet.  never use winhttp.
	//
	// in WINHTTP the compression is not supported yet at this time;
	// in WININET we removed the compression support at this point due to a bug in URLMON (< IE6.0).
	//
	// in both cases we use asynchronized sending in order to abort timely for a cancel event
	//

	BOOL fLoadWINHTTP = FALSE;
	DWORD dwTransportFlag = GetAllowedDownloadTransport(0);

	if ((0 == dwTransportFlag) || (WUDF_ALLOWWINHTTPONLY == dwTransportFlag))
	{
		hr = CoCreateInstance(CLSID_WinHttpRequest,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IWinHttpRequest,
							  (void **) &pWinHttpRequest);
		if (SUCCEEDED(hr))
		{
			BOOL fRetry = FALSE;
		    
			bstrURL = SysAllocString(T2OLE(pszURL));
			
			fLoadWINHTTP = TRUE;
			VARIANT	vProxyServer, vBypassList;
			hr = GetAUProxySettings(bstrURL, &pauProxySettings);
			CleanUpIfFailedAndMsg(hr);
			DWORD iProxy = pauProxySettings.iProxy;
			if (-1 == iProxy)
				pauProxySettings.iProxy = iProxy = 0;

			//
			// open request
			//
			VARIANT	vBool;
			vBool.vt = VT_BOOL;
			vBool.boolVal = VARIANT_TRUE;
			bstrPOST = SysAllocString(L"POST");
Retry:
			hr = pWinHttpRequest->Open(bstrPOST,	// HTTP method: "POST"
										bstrURL,	// requested URL
										vBool);		// asynchronous operation
			CleanUpIfFailedAndMsg(hr);

			//
			// For SSL URLs, set the WinHttpRequestOption_SslErrorIgnoreFlags
			// option to zero so that no server certificate errors are ignored.
			//
			// The default at the time this code was written was 0x3300, which
			// means ignore all server certificate errors.  Using this default
			// would significantly reduce security in various ways; for example
			// if the 0x0100 bit was set, WinHttp would trust certificates from
			// any root certificate authority, even it it was not in the list of
			// trusted CAs.
			//
			// Note that at the time this code was written, the WinHttp 
			// documentation made no mention of Certificate Revocation List
			// checking.  It is assumed that the default CRL behavior
			// implemented by WinHttp will provide adequate security and 
			// performance.
			//
			if ((_T('H') == pszURL[0] || _T('h') == pszURL[0]) &&    // Sorry, this is simpler than using a function.
				(_T('T') == pszURL[1] || _T('t') == pszURL[1]) &&
				(_T('T') == pszURL[2] || _T('t') == pszURL[2]) &&
				(_T('P') == pszURL[3] || _T('p') == pszURL[3]) &&
				(_T('S') == pszURL[4] || _T('s') == pszURL[4]) &&
				_T(':') == pszURL[5])
			{
				VARIANT vOption;
				VariantInit(&vOption);
				vOption.vt = VT_I4;
				vOption.lVal = 0;
				
				hr = pWinHttpRequest->put_Option(WinHttpRequestOption_SslErrorIgnoreFlags, vOption);

				VariantClear(&vOption);
				CleanUpIfFailedAndMsg(hr);
			}

			if (TRUE == fDontAllowProxy)
			{
				LOG_Internet(_T("Don't set the proxy due to policy"));
			}
			else
			{
				//
				// set proxy
				//
				VariantInit(&vProxyServer);
				VariantInit(&vBypassList);
				BOOL fSetProxy = TRUE;

				if (pauProxySettings.rgwszProxies != NULL)
				{
					vProxyServer.vt = VT_BSTR;
					vProxyServer.bstrVal = SysAllocString(pauProxySettings.rgwszProxies[iProxy]);
				}
				else if (pauProxySettings.rgwszProxies == NULL)
				{
					fSetProxy = FALSE;
				}

				if (pauProxySettings.wszBypass != NULL)
				{
					vBypassList.vt = VT_BSTR;
					vBypassList.bstrVal = SysAllocString(pauProxySettings.wszBypass);
				}

				if (fSetProxy)
				{
					hr = pWinHttpRequest->SetProxy(HTTPREQUEST_PROXYSETTING_PROXY, vProxyServer, vBypassList);
				}
				
				VariantClear(&vProxyServer);
				VariantClear(&vBypassList);
				CleanUpIfFailedAndMsg(hr);
			}


			//
			// send request
			//
			VARIANT	vQuery;
			vQuery.vt = VT_UNKNOWN;
			vQuery.punkVal = pSOAPQuery;

			hr = pWinHttpRequest->Send(vQuery);
    		if (FAILED(hr))
    		{
		        LOG_Internet(_T("WinHttpRequest: Send failed: 0x%08x"), hr);
    		    fRetry = TRUE;
    		    goto getNextProxyForRetry;
    		}

			//
			// check if quit or completion every 1/4 second
			//
			VARIANT vTimeOut;
			vTimeOut.vt = VT_I4;
			vTimeOut.lVal = 0;
			VARIANT_BOOL fSuccess = VARIANT_FALSE;
			hr = pWinHttpRequest->WaitForResponse(vTimeOut, &fSuccess);
			if (FAILED(hr))
			{
			    LOG_Internet(_T("WinHttpRequest: WaitForResponse failed: 0x%08x"), hr);
			    fRetry = TRUE;
			    goto getNextProxyForRetry;
			}

			// we wait up to 30 sec (120*250 ms)
			lCount = 0;
			while (!fSuccess && lCount <120)
			{
				lCount++;
				//
				// Wait for 250ms while pumping messages, but return if m_evtNeedToQuit signaled
				//
				dwRet = MyMsgWaitForMultipleObjects(1, &m_evtNeedToQuit, FALSE, 250, QS_ALLINPUT);
				if (WAIT_TIMEOUT != dwRet)
				{
					//
					// Either the event was signaled or a message being pumped says quit
					//
					pWinHttpRequest->Abort();
					hr = E_ABORT;
					goto CleanUp;
				}

				hr = pWinHttpRequest->WaitForResponse(vTimeOut, &fSuccess);
        		if (FAILED(hr))
        		{
			        LOG_Internet(_T("WinHttpRequest: WaitForResponse failed: 0x%08x"), hr);
        		    fRetry = TRUE;
        		    goto getNextProxyForRetry;
        		}
			}

			//
			// check the HTTP status code returned by a request
			//
			LONG lStatus = HTTP_STATUS_OK;// 200
			hr = pWinHttpRequest->get_Status(&lStatus);
        	if (FAILED(hr))
        	{
			    LOG_Internet(_T("WinHttpRequest: get_Status failed: 0x%08x"), hr);
        		fRetry = TRUE;
        		goto getNextProxyForRetry;
        	}

            fRetry = FALSE;
			if (!fSuccess)
			{
				// time out
				hr = E_FAIL;
				fRetry = TRUE;
			}
			else if (HTTP_STATUS_OK != lStatus)
			{
				// COMPLETED, but error in status
				hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, lStatus);
				LOG_ErrorMsg(hr);			
				fRetry = TRUE;
			}
			else
			{
				//
				// get response
				//
				hr = pWinHttpRequest->get_ResponseText(pbstrXmlCatalog);
				CleanUpIfFailedAndMsg(hr);

				//
				// verify the response is a well-formed XML document
				//
				IXMLDOMDocument	*pXMLDoc = NULL;
				hr = LoadXMLDoc(*pbstrXmlCatalog, &pXMLDoc);

				if(SUCCEEDED(hr))
				{
					hr=ValidatePID(pXMLDoc);

					if(FAILED(hr))
					{
						PingInvalidPID(bstrClientName,hr,&m_evtNeedToQuit,1);
						LogError(hr,"Validation of PID failed");
					}

					//The Banned PID case is not a failure for the GetManifest call.
					if(E_INVALID_PID == hr)
					{
						hr = S_OK;
					}

				}
				SafeReleaseNULL(pXMLDoc);
				CleanUpIfFailedAndMsg(hr);
			}

getNextProxyForRetry:
			if (fRetry && !fDontAllowProxy)
			{
				if (pauProxySettings.cProxies > 1 && pauProxySettings.rgwszProxies != NULL)
				{
					iProxy = ( iProxy + 1) % pauProxySettings.cProxies;
				}
				if (iProxy != pauProxySettings.iProxy)
				{
					LogError(hr, "Will retry.");
					pWinHttpRequest->Abort();
					goto Retry;
				}
				else
				{
					LogError(hr, "Already tried all proxies. Will not retry.");
				}
			}

		}
		else
		{
			if (WUDF_ALLOWWINHTTPONLY == dwTransportFlag)
			{
				CleanUpIfFailedAndMsg(hr);
			}
		}
	}

	if ((0 == dwTransportFlag && !fLoadWINHTTP) || (WUDF_ALLOWWININETONLY == dwTransportFlag))
	{
		//
		// 475506 W2K: IU - IU control's GetManifest method call fails on all subsequent
		// calls after the first. - On Win 2K Only
		//
		// We no longer take the FLAG_USE_COMPRESSION into account for WinInet since we
		// previously used URLMON and there are bugs that would require a rewrite of
		// xmlhttp.* to fix and we haven't been using compression on the live site to date.
		//
		LOG_Internet(_T("GetManifest using WININET.DLL"));

		//
		// create an XMLHttpRequest object
		//
		hr = CoCreateInstance(CLSID_XMLHTTPRequest,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IXMLHttpRequest,
							  (void **) &pIXMLHttpRequest);
		CleanUpIfFailedAndMsg(hr);

		//
		// open request
		//
		VARIANT	vEmpty, vBool;
		vEmpty.vt = VT_EMPTY;
		vBool.vt = VT_BOOL;
		vBool.boolVal= VARIANT_FALSE;
		bstrPOST = SysAllocString(L"POST");
		bstrURL = SysAllocString(T2OLE(pszURL));

		hr = pIXMLHttpRequest->open(bstrPOST,	// HTTP method: "POST"
									bstrURL,	// requested URL
									vBool,		// synchronous operation
									vEmpty,		// user for authentication (no authentication for V1.0)
									vEmpty);	// pswd for authentication
		CleanUpIfFailedAndMsg(hr);

		//
		// send request
		//
		VARIANT	vQuery;
		vQuery.vt = VT_UNKNOWN;
		vQuery.punkVal = pSOAPQuery;

		hr = pIXMLHttpRequest->send(vQuery);
		CleanUpIfFailedAndMsg(hr);

		//
		// check the HTTP status code returned by a request
		//
		LONG lResultStatus = HTTP_STATUS_OK;// 200
		hr = pIXMLHttpRequest->get_status(&lResultStatus);
		CleanUpIfFailedAndMsg(hr);

		if (HTTP_STATUS_OK != lResultStatus)
		{
			hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, lResultStatus);
			LOG_ErrorMsg(hr);			
		}
		else
		{
			//
			// get response
			//
			hr = pIXMLHttpRequest->get_responseText(pbstrXmlCatalog);
			CleanUpIfFailedAndMsg(hr);	

			//
			// verify the response is a well-formed XML document
			//
			IXMLDOMDocument	*pXMLDoc = NULL;
			hr = LoadXMLDoc(*pbstrXmlCatalog, &pXMLDoc);

			if(SUCCEEDED(hr))
			{
				hr=ValidatePID(pXMLDoc);

				if(FAILED(hr))
				{
					PingInvalidPID(bstrClientName,hr,&m_evtNeedToQuit,1);
					LogError(hr,"Validation of PID failed");
				}
				
				//The Banned pid case is not a failure for the GetManifest call
				if(E_INVALID_PID == hr)
				{
					hr = S_OK;
				}

			}
			SafeReleaseNULL(pXMLDoc);
			CleanUpIfFailedAndMsg(hr);
		}
	}

CleanUp:
	if (SUCCEEDED(hr))
	{
#if defined(UNICODE) || defined(_UNICODE)
		LogMessage("%s %ls", SZ_GET_MANIFEST, pszURL);
#else
		LogMessage("%s %s", SZ_GET_MANIFEST, pszURL);
#endif
	}
	else
	{
		if (NULL == pszURL)
		{
			LogError(hr, SZ_GET_MANIFEST_ERROR);
		}
		else
		{
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "%s %ls", SZ_GET_MANIFEST, pszURL);
#else
			LogError(hr, "%s %s", SZ_GET_MANIFEST, pszURL);
#endif
		}
	}

	if (NULL != pszURL)
		HeapFree(GetProcessHeap(), 0, pszURL);
	SafeReleaseNULL(pXMLSystemSpec);
	SafeReleaseNULL(pXMLQuery);
	SafeReleaseNULL(pSOAPQuery);
	SafeReleaseNULL(pIXMLHttpRequest);
	SafeReleaseNULL(pWinHttpRequest);
	SysFreeString(bstrPOST);
	SysFreeString(bstrURL);
	SysFreeString(bstrXmlSOAPQuery);
	SysFreeString(bstrClientName);
	FreeAUProxySettings(&pauProxySettings);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetServerURL()
//
// Retrieve the ServerCache URL from the Query xml doc and validate that
// URL against the ServerCache URLs in iuident.txt.
// Return:
// ppszURL - the ServerCache URL path pointer
/////////////////////////////////////////////////////////////////////////////
HRESULT GetServerURL(IXMLDOMDocument *pXMLQuery, IXMLDOMDocument *pXMLClientInfo, LPTSTR *ppszURL)
{
    LOG_Block("GetServerURL()");

	USES_IU_CONVERSION;

	HRESULT	hr	= E_FAIL;

    if ((NULL == pXMLQuery) || (NULL == pXMLClientInfo) || (NULL == ppszURL))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    IXMLDOMNode*	pQueryNode = NULL;
    IXMLDOMNode*	pQueryClient = NULL;
	BSTR bstrQuery = SysAllocString(L"query");
	BSTR bstrHref = SysAllocString(L"href");
	BSTR bstrClientInfo = SysAllocString(L"clientInfo");
	BSTR bstrClientName = SysAllocString(L"clientName");
	BSTR bstrURL = NULL, bstrClient = NULL;
	LPTSTR pszURL = NULL;
	INT iServerCnt;
	BOOL fInternalServer = FALSE;

	QuitIfFail(FindSingleDOMNode(pXMLClientInfo, bstrClientInfo, &pQueryClient));
	QuitIfFail(GetAttribute(pQueryClient, bstrClientName, &bstrClient));

	pszURL = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszURL);

	//
	// failure in "g_pUrlAgent = new CUrlAgent"
	//
	CleanUpFailedAllocSetHrMsg(g_pUrlAgent);
	QuitIfFail(g_pUrlAgent->GetQueryServer(OLE2T(bstrClient), pszURL, INTERNET_MAX_URL_LENGTH, &fInternalServer));

	if (fInternalServer)
	{
		//
		// we have policy override for this client, set the query url as WUServer in policy
		//
		*ppszURL = pszURL;
		hr = S_OK;
	}
	else
	{
		//
		// we don't have policy override for this client;
		//
		// find the ServerCache URL from <query> node
		//
		QuitIfFail(FindSingleDOMNode(pXMLQuery, bstrQuery, &pQueryNode));
		if (SUCCEEDED(GetAttribute(pQueryNode, bstrHref, &bstrURL))
			&& NULL != bstrURL && SysStringLen(bstrURL) >0)
		{
			//
			// this is the case that the query specified the serverl url, we need
			// to do the validation for the url here...
			//

			// pszURL is alloced to be INTERNET_MAX_URL_LENGTH above.
			hr = StringCchCopyEx(pszURL, INTERNET_MAX_URL_LENGTH, OLE2T(bstrURL), 
			                     NULL, NULL, MISTSAFE_STRING_FLAGS);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    goto CleanUp;
			}

			//
			// process the iuident.txt to find all valid ServerCache URLs
			//
			TCHAR szIUDir[MAX_PATH];
			TCHAR szIdentFile[MAX_PATH];

			GetIndustryUpdateDirectory(szIUDir);
			hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    goto CleanUp;
			}

			iServerCnt = GetPrivateProfileInt(IDENT_IUSERVERCACHE,
											  IDENT_IUSERVERCOUNT,
											  -1,
											  szIdentFile);
			if (-1 == iServerCnt)
			{
				// no ServerCount number specified in iuident.txt
				LOG_Error(_T("No ServerCount number specified in iuident.txt"));
				hr = E_FAIL;
				goto CleanUp;
			}

			hr = INET_E_INVALID_URL;
			for (INT i=1; i<=iServerCnt; i++)
			{
				TCHAR szValidURL[INTERNET_MAX_URL_LENGTH];
				TCHAR szServer[32];

				hr = StringCchPrintfEx(szServer, ARRAYSIZE(szServer), NULL, NULL, MISTSAFE_STRING_FLAGS,
				                       _T("%s%d"), IDENT_IUSERVER, i);
				if (FAILED(hr))
				{
				    LOG_ErrorMsg(hr);
				    goto CleanUp;
				}

				hr = INET_E_INVALID_URL;
				GetPrivateProfileString(IDENT_IUSERVERCACHE,
										szServer,
										_T(""),
										szValidURL,
										ARRAYSIZE(szValidURL),
										szIdentFile);

				if ('\0' == szValidURL[0])
				{
					// no ServerCache URL specified in iuident.txt for this server
					LOG_Error(_T("No ServerCache URL specified in iuident.txt for %s%d"), IDENT_IUSERVER, i);
					hr = E_FAIL;
					goto CleanUp;
				}
				
				if (0 == lstrcmpi(szValidURL, pszURL))
				{
					// it's a valid ServerCache URL
					*ppszURL = pszURL;
					hr = S_OK;
					break;
				}
			}
		}
		else
		{
			//
			// this is the case that the query didn't specify the serverl url, we just use the
			// server url that was found through g_pUrlAgent according to the clientName.
			//
			// now insert the URL into the <query> node
			//
			BSTR bstrTemp = T2BSTR(pszURL);
			QuitIfFail(SetAttribute(pQueryNode, bstrHref, bstrTemp));
			SafeSysFreeString(bstrTemp);

			*ppszURL = pszURL;
		}
	}

CleanUp:
    if (FAILED(hr))
	{
		HeapFree(GetProcessHeap(), 0, pszURL);
		*ppszURL = NULL;
		LOG_ErrorMsg(hr);
	}
    SafeReleaseNULL(pQueryNode);
    SafeReleaseNULL(pQueryClient);
	SysFreeString(bstrQuery);
	SysFreeString(bstrHref);
	SysFreeString(bstrURL);
	SysFreeString(bstrClientInfo);
	SysFreeString(bstrClientName);
	SysFreeString(bstrClient);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetSOAPQuery()
//
// Concatenate the several xml client input into a single XML
// with the SOAP syntax/format that the server recognizes
// Input:
// pXMLClientInfo - the credentials of the client in DOM Doc format
// pXMLSystemSpec - the detected system specifications in DOM Doc
// pXMLQuery - the user query infomation in DOM Doc
// Return:
// ppSOAPQuery - the concatenated query in DOM Doc with required SOAP syntax
//
// SOAPQuery xml doc example:
// <SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/">
//	<SOAP:Body>
//		<GetManifest>
//			<clientInfo>...</clientInfo>
//			<systemSpec>...</systemSpec>
//			<query href="//windowsupdate.microsoft.com/servecache.asp">...</query>
//		</GetManifest>
//	</SOAP:Body>
// </SOAP:Envelope>
//
/////////////////////////////////////////////////////////////////////////////
HRESULT GetSOAPQuery(IXMLDOMDocument *pXMLClientInfo,
					 IXMLDOMDocument *pXMLSystemSpec,
					 IXMLDOMDocument *pXMLQuery,
					 IXMLDOMDocument **ppSOAPQuery)
{
	LOG_Block("GetSOAPQuery()");

	USES_IU_CONVERSION;

	HRESULT	hr = E_FAIL;

	IXMLDOMDocument*	pDocSOAPQuery = NULL;
	IXMLDOMNode*	pNodeSOAPEnvelope = NULL;
	IXMLDOMNode*	pNodeSOAPBody = NULL;
	IXMLDOMNode*	pNodeGetManifest = NULL;
	IXMLDOMNode*	pNodeClientInfo = NULL;
	IXMLDOMNode*	pNodeClientInfoNew = NULL;
	IXMLDOMNode*	pNodeSystemInfo = NULL;
	IXMLDOMNode*	pNodeSystemInfoNew = NULL;
	IXMLDOMNode*	pNodeQuery = NULL;
	IXMLDOMNode*	pNodeQueryNew = NULL;
	BSTR bstrNameSOAPEnvelope = SysAllocString(L"SOAP:Envelope");
	BSTR bstrNameSOAPBody = SysAllocString(L"SOAP:Body");
	BSTR bstrNameGetManifest = SysAllocString(L"GetManifest");
	BSTR bstrClientInfo = SysAllocString(L"clientInfo");
	BSTR bstrSystemInfo = SysAllocString(L"systemInfo");
	BSTR bstrQuery = SysAllocString(L"query");
	BSTR bstrNameSpaceSchema = NULL;

	//
	// process the iuident.txt to find the SOAPQuery schema path
	//
    TCHAR szIUDir[MAX_PATH];
    TCHAR szIdentFile[MAX_PATH];
    LPTSTR pszSOAPQuerySchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	pszSOAPQuerySchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	if (NULL == pszSOAPQuerySchema)
	{
		hr = E_OUTOFMEMORY;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}
	pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	if (NULL == pszNameSpaceSchema)
	{
		hr = E_OUTOFMEMORY;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	GetIndustryUpdateDirectory(szIUDir);
    hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
    if (FAILED(hr))
    {
		LOG_ErrorMsg(hr);
		goto CleanUp;
    }

    GetPrivateProfileString(IDENT_IUSCHEMA,
							IDENT_IUSCHEMA_SOAPQUERY,
							_T(""),
							pszSOAPQuerySchema,
							INTERNET_MAX_URL_LENGTH,
							szIdentFile);

    if ('\0' == pszSOAPQuerySchema[0])
    {
        // no SOAPQuery schema path specified in iuident.txt
        LOG_Error(_T("No schema path specified in iuident.txt for SOAPQuery"));
        hr = E_FAIL;
		goto CleanUp;
    }

    // pszNameSpaceSchema is alloced to be INTERNET_MAX_URL_LENGTH above
	hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
	                       _T("x-schema:%s"), pszSOAPQuerySchema);
	if (FAILED(hr))
	{
	    LOG_ErrorMsg(hr);
	    goto CleanUp;
	}

	bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

 	//
	// construct the SOAPQuery xml
	//
	QuitIfFail(CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void **)&pDocSOAPQuery));

	pNodeSOAPEnvelope = CreateDOMNode(pDocSOAPQuery, NODE_ELEMENT, bstrNameSOAPEnvelope, bstrNameSpaceSchema);
	if (NULL == pNodeSOAPEnvelope) goto CleanUp;
	QuitIfFail(InsertNode(pDocSOAPQuery, pNodeSOAPEnvelope));

	pNodeSOAPBody = CreateDOMNode(pDocSOAPQuery, NODE_ELEMENT, bstrNameSOAPBody, bstrNameSpaceSchema);
	if (NULL == pNodeSOAPBody) goto CleanUp;
	QuitIfFail(InsertNode(pNodeSOAPEnvelope, pNodeSOAPBody));

	pNodeGetManifest = CreateDOMNode(pDocSOAPQuery, NODE_ELEMENT, bstrNameGetManifest);
	if (NULL == pNodeGetManifest) goto CleanUp;
	QuitIfFail(InsertNode(pNodeSOAPBody, pNodeGetManifest));

	if (NULL != pXMLClientInfo)
	{
		QuitIfFail(FindSingleDOMNode(pXMLClientInfo, bstrClientInfo, &pNodeClientInfo));
		QuitIfFail(CopyNode(pNodeClientInfo, pDocSOAPQuery, &pNodeClientInfoNew));
		QuitIfFail(InsertNode(pNodeGetManifest, pNodeClientInfoNew));
	}
	if (NULL != pXMLSystemSpec)
	{
		QuitIfFail(FindSingleDOMNode(pXMLSystemSpec, bstrSystemInfo, &pNodeSystemInfo));
		QuitIfFail(CopyNode(pNodeSystemInfo, pDocSOAPQuery, &pNodeSystemInfoNew));
		QuitIfFail(InsertNode(pNodeGetManifest, pNodeSystemInfoNew));
	}
	QuitIfFail(FindSingleDOMNode(pXMLQuery, bstrQuery, &pNodeQuery));
	QuitIfFail(CopyNode(pNodeQuery, pDocSOAPQuery, &pNodeQueryNew));
	QuitIfFail(InsertNode(pNodeGetManifest, pNodeQueryNew));

CleanUp:
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		SafeReleaseNULL(pDocSOAPQuery);
	}
	SafeReleaseNULL(pNodeSOAPEnvelope);
	SafeReleaseNULL(pNodeSOAPBody);
	SafeReleaseNULL(pNodeGetManifest);
	SafeReleaseNULL(pNodeClientInfo);
	SafeReleaseNULL(pNodeClientInfoNew);
	SafeReleaseNULL(pNodeSystemInfo);
	SafeReleaseNULL(pNodeSystemInfoNew);
	SafeReleaseNULL(pNodeQuery);
	SafeReleaseNULL(pNodeQueryNew);
	SysFreeString(bstrNameSOAPEnvelope);
	SysFreeString(bstrNameSOAPBody);
	SysFreeString(bstrNameGetManifest);
	SysFreeString(bstrClientInfo);
	SysFreeString(bstrSystemInfo);
	SysFreeString(bstrQuery);
	SafeHeapFree(pszSOAPQuerySchema);
	SafeHeapFree(pszNameSpaceSchema);
	SysFreeString(bstrNameSpaceSchema);
	*ppSOAPQuery = pDocSOAPQuery;
	return hr;
}





// Function name	: ValidatePID
// Description	    : This function is used to check the return xml from the 
// server in response to getmanifest calls. 
// If the catalogStatus attribute is  not present or is 0 then the pid validation succeeded
// If the catalogStatus attribute is 1 then an error is returned
 
// Return type		: HRESULT 
// Argument         : IXMLDOMDocument *pXmlDomDocument

HRESULT ValidatePID(IXMLDOMDocument *pXmlDomDocument)
{
	
	LOG_Block("ValidatePID()");
	HRESULT hr = S_OK;
	IXMLDOMElement *pRootElement = NULL;


	long lStatus = 0;


	if(!pXmlDomDocument)
	{
		return E_INVALIDARG;
	}


	BSTR bCatalogStatus = SysAllocString(L"catalogStatus");

	if(!bCatalogStatus)
	{
		return E_OUTOFMEMORY;
	}
	

	QuitIfFail( pXmlDomDocument->get_documentElement(&pRootElement) );

	//get the catalogStatus attribute
	QuitIfFail( GetAttribute( (IXMLDOMNode *)pRootElement, bCatalogStatus, &lStatus));

	if(errorInvalidLicense == lStatus)
		hr = E_INVALID_PID;

CleanUp:

	if(FAILED(hr))
		LOG_ErrorMsg(hr);

	//catalogStatus is an optional attribute. If it is not found we get the
	//hresult as S_FALSE. So reset it to S_OK

	if(S_FALSE == hr)
		hr = S_OK;

	SafeReleaseNULL(pRootElement);
	SysFreeString(bCatalogStatus);
	return hr;

}




// Function name	: PingInvalidPID
// Description	    : This function sends a ping message to the server
// to indicate failure of PID validation
// Return type		: void 
// Argument         : BSTR bstrClientName
// Argument         : HRESULT hRes
// Argument         : HANDLE *phQuit
// Argument         : DWORD dwNumHandles

void PingInvalidPID(BSTR bstrClientName, HRESULT hRes, HANDLE *phQuit, DWORD dwNumHandles)
{


		
	LOG_Block("PingInvalidPID()");
	
	USES_IU_CONVERSION;

	HRESULT hr = S_OK;
	URLLOGSTATUS status = URLLOGSTATUS_Declined;
	LPTSTR		ptszLivePingServerUrl = NULL;
	LPTSTR		ptszCorpPingServerUrl = NULL;

	if (NULL != (ptszLivePingServerUrl = (LPTSTR)HeapAlloc(
														GetProcessHeap(),
														HEAP_ZERO_MEMORY,
														INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED( g_pUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH) ) )
		{
			SafeHeapFree(ptszLivePingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszLivePingServerUrl"));
	}

	if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(
													GetProcessHeap(),
													HEAP_ZERO_MEMORY,
													INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED(g_pUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get corp WU ping server URL"));
			SafeHeapFree(ptszCorpPingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
	}


	LPTSTR lpClientName = NULL;

	if(bstrClientName)
	{
		lpClientName = OLE2T(bstrClientName);

	}

	CUrlLog pingSvr(lpClientName, ptszLivePingServerUrl, ptszCorpPingServerUrl); 

	SafeHeapFree(ptszLivePingServerUrl);
	SafeHeapFree(ptszCorpPingServerUrl);


	pingSvr.Ping(TRUE,						// on-line
				URLLOGDESTINATION_DEFAULT,	// going live or corp WU ping server
				phQuit,			// pt to cancel events
				dwNumHandles,							// number of events
				URLLOGACTIVITY_Download,	// activity
				status,						// status code
				hRes,							
				NULL,
				NULL,
				g_szInvalidPID
			);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\iuxml.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuxml.cpp
//
//  Description:
//
//      Implementation for the CIUXml class
//
//=======================================================================

#include "iuengine.h"
#include "iuxml.h"
#include <iucommon.h>
#include <fileutil.h>
#include <StringUtil.h>
#include <shlwapi.h>
#include <wininet.h>
#include "schemakeys.h"
#include "schemamisc.h"
#include "v3applog.h"

#define QuitIfNull(p) {if (NULL == p) {hr = E_INVALIDARG; LOG_ErrorMsg(hr);	return hr;}}
#define QuitIfFail(x) {hr = x; if (FAILED(hr)) goto CleanUp;}
#define ReturnIfFail(x) {hr = x; if (FAILED(hr)) {LOG_ErrorMsg(hr); return hr;}}
#define SkipIfFail(x) {hr = x; if (FAILED(hr)) {hr = S_FALSE; continue;}}

const TCHAR IDENT_IUSCHEMA[]			= _T("IUSchema");
const TCHAR IDENT_IUSCHEMA_SYSTEMSPEC[]	= _T("SystemSpecSchema");
const TCHAR IDENT_IUSCHEMA_ITEMS[]		= _T("ResultSchema");

const WCHAR CORP_PLATFORM_DIR_NT4[]     = L"x86WinNT4";
const WCHAR CORP_PLATFORM_DIR_NT5[]     = L"x86win2k";
const WCHAR CORP_PLATFORM_DIR_W98[]     = L"x86Win98";
const WCHAR CORP_PLATFORM_DIR_W95[]     = L"x86Win95";
const WCHAR CORP_PLATFORM_DIR_WINME[]   = L"x86WinME";
const WCHAR CORP_PLATFORM_DIR_X86WHI[]  = L"x86WinXP";
const WCHAR CORP_PLATFROM_DIR_IA64WHI[] = L"ia64WinXP";


// Initial length of the node array "m_ppNodeArray"
const DWORD MAX_NODES = 16;

// Initial length of the node array "m_ppNodeListArray"
const DWORD MAX_NODELISTS = 16;

// Bitmap of existence of all possible system info classes
const DWORD	COMPUTERSYSTEM	= 0x00000001;
const DWORD	REGKEYS			= 0x00000010;
const DWORD	PLATFORM		= 0x00000100;
const DWORD	LOCALE			= 0x00001000;
const DWORD	DEVICES			= 0x00010000;


// The following are constants used for V3 history migration:
//
// Log line types
#define LOG_V2				"V2"             // line format for items migrated from V2
#define LOG_V3CAT			"V3CAT"			 // V3 Beta format (version 1)
#define LOG_V3_2			"V3_2"			 // V3 log line format (version 2)
#define LOG_PSS				"PSS"			 // Entry for PSS

// LOG_V2 format
//    V2|DATE|TIME|LOGSTRING|
//
// LOG_V3CAT format
//    V3CAT|PUID|OPERATION|TITLE|VERSION|DATESTRING|TIMESTRING|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//
// LOG_V3_2 format
//    V3_2|PUID|OPERATION|TITLE|VERSION|TIMESTAMP|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//
// LOG_PSS format
//    PSS|PUID|OPERATION|TITLE|VERSION|TIMESTAMP|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//

// operation type
#define LOG_INSTALL         "INSTALL"

// result
#define LOG_SUCCESS         "SUCCESS"
#define LOG_FAIL            "FAIL"
#define LOG_STARTED			"STARTED"      // started but reboot was required: exclusive items only

const WCHAR C_V3_CLIENTINFO[] = L"WU_V3";


/////////////////////////////////////////////////////////////////////////////
// CIUXml

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
/////////////////////////////////////////////////////////////////////////////
CIUXml::CIUXml()
 : m_dwSizeNodeArray(MAX_NODES),
   m_dwSizeNodeListArray(MAX_NODELISTS),
   m_ppNodeArray(NULL),
   m_ppNodeListArray(NULL)
{
	m_hHeap = GetProcessHeap();
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
/////////////////////////////////////////////////////////////////////////////
CIUXml::~CIUXml()
{
	DWORD	dwIndex;

	if (NULL != m_ppNodeArray)
	{
		for (dwIndex = 0; dwIndex < m_dwSizeNodeArray; dwIndex++)
		{
			SafeReleaseNULL(m_ppNodeArray[dwIndex]);
		}

		HeapFree(m_hHeap, 0, m_ppNodeArray);
		m_ppNodeArray = NULL;
	}

	if (NULL != m_ppNodeListArray)
	{
		for (dwIndex = 0; dwIndex < m_dwSizeNodeListArray; dwIndex++)
		{
			SafeReleaseNULL(m_ppNodeListArray[dwIndex]);
		}

		HeapFree(m_hHeap, 0, m_ppNodeListArray);
		m_ppNodeListArray = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SafeCloseHandleNode()
//
// User can explicitly can this function to release a node for reuse when 
// writing a xml doc.
/////////////////////////////////////////////////////////////////////////////
void CIUXml::SafeCloseHandleNode(HANDLE_NODE& hNode)
{
	if (HANDLE_NODE_INVALID != hNode)
	{
		SafeReleaseNULL(m_ppNodeArray[hNode]);
		hNode = HANDLE_NODE_INVALID;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SafeFindCloseHandle()
//
// User can explicitly can this function to release a nodelist for reuse when 
// reading a xml doc.
/////////////////////////////////////////////////////////////////////////////
void CIUXml::SafeFindCloseHandle(HANDLE_NODELIST& hNodeList)
{
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeReleaseNULL(m_ppNodeListArray[hNodeList]);
		hNodeList = HANDLE_NODELIST_INVALID;
	}
}


/////////////////////////////////////////////////////////////////////////////
// InitNodeArray()
//
// Allocate or re-allocate memory for the node array "m_ppNodeArray"
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::InitNodeArray(BOOL fRealloc /*= FALSE*/)
{
	if (fRealloc)	// re-allocation
	{
		IXMLDOMNode** ppNodeArrayTemp = (IXMLDOMNode**)HeapReAlloc(m_hHeap,
																HEAP_ZERO_MEMORY,
																m_ppNodeArray,
																m_dwSizeNodeArray * sizeof(IXMLDOMNode*));
		if (NULL == ppNodeArrayTemp)
		{
	        return E_OUTOFMEMORY;
		}
		else
		{
			m_ppNodeArray = ppNodeArrayTemp;
		}
	}
	else			// initial allocation
	{
		m_ppNodeArray = (IXMLDOMNode**)HeapAlloc(m_hHeap,
												 HEAP_ZERO_MEMORY,
												 m_dwSizeNodeArray * sizeof(IXMLDOMNode*));
		if (NULL == m_ppNodeArray)
		{
	        return E_OUTOFMEMORY;
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// InitNodeListArray()
//
// Allocate or re-allocate memory for the nodelist array "m_ppNodeListArray"
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::InitNodeListArray(BOOL fRealloc /*= FALSE*/)
{
	if (fRealloc)	// re-allocation
	{
		IXMLDOMNodeList** ppNodeListArrayTemp = (IXMLDOMNodeList**)HeapReAlloc(m_hHeap,
																	HEAP_ZERO_MEMORY,
																	m_ppNodeListArray,
																	m_dwSizeNodeListArray * sizeof(IXMLDOMNodeList*));
		if (NULL == ppNodeListArrayTemp)
		{
	        return E_OUTOFMEMORY;
		}
		else
		{
			m_ppNodeListArray = ppNodeListArrayTemp;
		}
	}
	else			// initial allocation
	{
		m_ppNodeListArray = (IXMLDOMNodeList**)HeapAlloc(m_hHeap,
													HEAP_ZERO_MEMORY,
													m_dwSizeNodeListArray * sizeof(IXMLDOMNodeList*));
		if (NULL == m_ppNodeListArray)
		{
	        return E_OUTOFMEMORY;
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// GetNodeHandle()
//
// Look for the first un-used node from the "m_ppNodeArray" array,
// including the memory allocation, if needed.
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODE CIUXml::GetNodeHandle()
{
	HRESULT	hr;
	DWORD	dwIndex;

	//
	// allocate memory for "m_ppNodeArray" array if this is the first time using it
	//
	if (NULL == m_ppNodeArray)
	{
		QuitIfFail(InitNodeArray());
		return 0;	// return the first element of the array
	}
		
	//
	// find the next node to use, or, if any node was used but closed, reuse it
	//
	for (dwIndex = 0; dwIndex < m_dwSizeNodeArray; dwIndex++)
	{
		if (NULL == m_ppNodeArray[dwIndex])
		{
			return dwIndex;
		}
	}

	//
	// all pre-allocated nodes are used up, so re-allocate longer array
	//
	m_dwSizeNodeArray += m_dwSizeNodeArray;	// double the size
	QuitIfFail(InitNodeArray(TRUE));		// re-allocation
	return dwIndex;

CleanUp:
    return HANDLE_NODE_INVALID;
}
	

/////////////////////////////////////////////////////////////////////////////
// GetNodeListHandle()
//
// Look for the first un-used nodelist from the "m_ppNodeListArray" array,
// including the memory allocation, if needed.
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::GetNodeListHandle()
{
	HRESULT	hr;
	DWORD	dwIndex;

	//
	// allocate memory for "m_ppNodeListArray" array if this is the first time using it
	//
	if (NULL == m_ppNodeListArray)
	{
		QuitIfFail(InitNodeListArray());
		return 0;	// return the first element of the array
	}
		
	//
	// find the next nodelist to use, or, if any nodelist was used but closed, reuse it
	//
	for (dwIndex = 0; dwIndex < m_dwSizeNodeListArray; dwIndex++)
	{
		if (NULL == m_ppNodeListArray[dwIndex])
		{
			return dwIndex;
		}
	}

	//
	// all pre-allocated nodelists are used up, so re-allocate longer array
	//
	m_dwSizeNodeListArray += m_dwSizeNodeListArray;	// double the size
	QuitIfFail(InitNodeListArray(TRUE));			// re-allocation
	return dwIndex;

CleanUp:
	return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// GetDOMNodebyHandle()
//
// Retrieve the xml node with the given index of m_ppNodeArray
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNode* CIUXml::GetDOMNodebyHandle(HANDLE_NODE hNode)
{
	if (NULL != m_ppNodeArray && HANDLE_NODE_INVALID != hNode)
	{
		return m_ppNodeArray[hNode];
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the first xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pParentNode)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex;
    dwIndex = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex)
	{
		LONG	lLength;
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex]));
		if (NULL == m_ppNodeListArray[dwIndex])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->nextNode(ppNode));
		if (NULL == *ppNode)
		{
			goto CleanUp;
		}
		return dwIndex;
	}

CleanUp:
	*ppNode = NULL;
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the handle of first xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, HANDLE_NODE* phNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pParentNode)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex1, dwIndex2;
    dwIndex1 = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex1)
	{
		LONG	lLength;
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex1]));
		if (NULL == m_ppNodeListArray[dwIndex1])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex1]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		dwIndex2 = GetNodeHandle();
		if (HANDLE_NODE_INVALID != dwIndex2)
		{
			QuitIfFail(m_ppNodeListArray[dwIndex1]->nextNode(&m_ppNodeArray[dwIndex2]));
			if (NULL == m_ppNodeArray[dwIndex2])
			{
				goto CleanUp;
			}
			*phNode = dwIndex2;
			return dwIndex1;
		}
	}

CleanUp:
	*phNode = HANDLE_NODE_INVALID;
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the first xml node with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pDoc)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex;
	IXMLDOMNode	*pParentNode = NULL;
    dwIndex = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex)
	{
		LONG		lLength;
		QuitIfFail(pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex]));
		if (NULL == m_ppNodeListArray[dwIndex])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->nextNode(ppNode));
		if (NULL == *ppNode)
		{
			goto CleanUp;
		}
		SafeReleaseNULL(pParentNode);
		return dwIndex;
	}

CleanUp:
	*ppNode = NULL;
	SafeReleaseNULL(pParentNode);
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the handle of first xml node with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, HANDLE_NODE* phNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pDoc)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex1, dwIndex2;
	IXMLDOMNode	*pParentNode = NULL;
    dwIndex1 = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex1)
	{
		LONG	lLength;
		QuitIfFail(pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex1]));
		if (NULL == m_ppNodeListArray[dwIndex1])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex1]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		dwIndex2 = GetNodeHandle();
		if (HANDLE_NODE_INVALID != dwIndex2)
		{
			QuitIfFail(m_ppNodeListArray[dwIndex1]->nextNode(&m_ppNodeArray[dwIndex2]));
			if (NULL == m_ppNodeArray[dwIndex2])
			{
				goto CleanUp;
			}
			*phNode = dwIndex2;
			SafeReleaseNULL(pParentNode);
			return dwIndex1;
		}
	}

CleanUp:
	*phNode = HANDLE_NODE_INVALID;
	SafeReleaseNULL(pParentNode);
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindNextDOMNode()
//
// Retrieve the next xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::FindNextDOMNode(HANDLE_NODELIST hNodeList, IXMLDOMNode** ppNode)
{
	HRESULT		hr = E_FAIL;

	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		hr = m_ppNodeListArray[hNodeList]->nextNode(ppNode);
	}

    if (FAILED(hr) || NULL == *ppNode)
	{
		*ppNode = NULL;
		return E_FAIL;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindNextDOMNode()
//
// Retrieve the handle of next xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::FindNextDOMNode(HANDLE_NODELIST hNodeList, HANDLE_NODE* phNode)
{
	HRESULT		hr = E_FAIL;
	DWORD		dwIndex = HANDLE_NODE_INVALID;

	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		dwIndex = GetNodeHandle();
		if (HANDLE_NODE_INVALID != dwIndex)
		{
			hr = m_ppNodeListArray[hNodeList]->nextNode(&m_ppNodeArray[dwIndex]);
		}
	}

    if (FAILED(hr) || NULL == m_ppNodeArray[dwIndex])
	{
		*phNode = HANDLE_NODE_INVALID;
		return E_FAIL;
	}
	*phNode = dwIndex;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CreateDOMNodeWithHandle()
//
// Create an xml node of the given type
// Return: index of the node array "m_ppNodeArray"; or -1 if failure.
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODE CIUXml::CreateDOMNodeWithHandle(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI /*= NULL*/)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pDoc)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODE_INVALID;
	}

	DWORD		dwIndex;
    VARIANT		vType;
	VariantInit(&vType);

    vType.vt = VT_I2;
    vType.iVal = nType;

    dwIndex = GetNodeHandle();
	if (HANDLE_NODE_INVALID != dwIndex)
	{
		QuitIfFail(pDoc->createNode(vType, bstrName, bstrNamespaceURI, &m_ppNodeArray[dwIndex]));
		return dwIndex;
	}

CleanUp:
    return HANDLE_NODE_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemSpec

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for SystemSpec
/////////////////////////////////////////////////////////////////////////////
CXmlSystemSpec::CXmlSystemSpec()
 : m_pDocSystemSpec(NULL),
   m_pNodeSystemInfo(NULL),
   m_pNodeComputerSystem(NULL),
   m_pNodeRegKeysSW(NULL),
   m_pNodePlatform(NULL),
   m_pNodeDevices(NULL)
{
    LOG_Block("CXmlSystemSpec()");

 	HRESULT hr = CoCreateInstance(CLSID_DOMDocument,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IXMLDOMDocument,
								  (void **) &m_pDocSystemSpec);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		IXMLDOMNode*	pNodeXML = NULL;
		BSTR bstrNameSpaceSchema = NULL;

		//
		// create the <?xml version="1.0"?> node
		//
		pNodeXML = CreateDOMNode(m_pDocSystemSpec, NODE_PROCESSING_INSTRUCTION, KEY_XML);
		if (NULL == pNodeXML) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocSystemSpec, pNodeXML));

		//
		// process the iuident.txt to find the SystemSpec schema path
		//
		TCHAR szIUDir[MAX_PATH];
		TCHAR szIdentFile[MAX_PATH];
		LPTSTR pszSystemSpecSchema = NULL;
		LPTSTR pszNameSpaceSchema = NULL;

		pszSystemSpecSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszSystemSpecSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
		pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszNameSpaceSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
	
		GetIndustryUpdateDirectory(szIUDir);
		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir,IDENTTXT);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		if (GetPrivateProfileString(IDENT_IUSCHEMA,
								IDENT_IUSCHEMA_SYSTEMSPEC,
								_T(""),
								pszSystemSpecSchema,
								INTERNET_MAX_URL_LENGTH,
								szIdentFile) == INTERNET_MAX_URL_LENGTH - 1)
		{
			LOG_Error(_T("SystemSpec schema buffer overflow"));
			goto CleanUp;
		}

		if ('\0' == pszSystemSpecSchema[0])
		{
			// no SystemSpec schema path specified in iuident.txt
			LOG_Error(_T("No schema path specified in iuident.txt for SystemSpec"));
			goto CleanUp;
		}

		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("x-schema:%s"), pszSystemSpecSchema);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}
		
		bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

		//
		// create the <systemInfo> node with the path of the schema
		//
		m_pNodeSystemInfo = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_SYSTEMINFO, bstrNameSpaceSchema);
		SafeSysFreeString(bstrNameSpaceSchema);
		if (NULL == m_pNodeSystemInfo) goto CleanUp;
		
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocSystemSpec, m_pNodeSystemInfo));

CleanUp:
		SafeReleaseNULL(pNodeXML);
		SafeHeapFree(pszSystemSpecSchema);
		SafeHeapFree(pszNameSpaceSchema);
	}
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for SystemSpec
/////////////////////////////////////////////////////////////////////////////
CXmlSystemSpec::~CXmlSystemSpec()
{
	SafeReleaseNULL(m_pNodeDevices);
	SafeReleaseNULL(m_pNodePlatform);
	SafeReleaseNULL(m_pNodeRegKeysSW);
	SafeReleaseNULL(m_pNodeComputerSystem);
	SafeReleaseNULL(m_pNodeSystemInfo);

	SafeReleaseNULL(m_pDocSystemSpec);
}


/////////////////////////////////////////////////////////////////////////////
// AddComputerSystem()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddComputerSystem(BSTR bstrManufacturer,
										  BSTR bstrModel,
										  BSTR bstrSupportSite /*= NULL*/,
										  INT  iAdmin /*= -1*/,
										  INT  iWUDisabled /*= -1*/,
										  INT  iAUEnabled /*= -1*/,
										  BSTR bstrPID)
{
	LOG_Block("AddComputerSystem()");

	HRESULT		hr = E_FAIL;

	m_pNodeComputerSystem = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_COMPUTERSYSTEM);
	if (NULL == m_pNodeComputerSystem) return hr;

	//
	// Manufacturer and Model are now optional (RAID#337879	IU: can't get latest IU controls to work with IU site)
	//
	if (NULL != bstrManufacturer)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_MANUFACTURER, bstrManufacturer));
	}
	if (NULL != bstrModel)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_MODEL, bstrModel));
	}
	if (NULL != bstrSupportSite)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_SUPPORTSITE, bstrSupportSite));
	}

	if (NULL != bstrPID)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_PID, bstrPID));
	}

	if (-1 != iAdmin)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_ADMINISTRATOR, iAdmin));
	}
	if (-1 != iWUDisabled)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_WU_DISABLED, iWUDisabled));
	}
	if (-1 != iAUEnabled)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_AU_ENABLED, iAUEnabled));
	}
	ReturnIfFail(InsertNode(m_pNodeSystemInfo, m_pNodeComputerSystem));
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDriveSpace()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddDriveSpace(BSTR bstrDrive, INT iKBytes)
{
	LOG_Block("AddDriveSpace()");

	HRESULT			hr = E_FAIL;
	IXMLDOMNode*	pNodeDriveSpace = NULL;

	pNodeDriveSpace = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_DRIVESPACE);
	if (NULL == pNodeDriveSpace) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDriveSpace, KEY_DRIVE, bstrDrive));
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDriveSpace, KEY_KBYTES, iKBytes));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeComputerSystem, pNodeDriveSpace));

CleanUp:
	SafeReleaseNULL(pNodeDriveSpace);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddReg()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddReg(BSTR bstrProvider)
{
	LOG_Block("AddReg()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeRegKeys = NULL;
	IXMLDOMNode*	pNodeRegKeysHKLM = NULL;
	IXMLDOMNode*	pNodeRegValue = NULL;
	IXMLDOMNode*	pNodeRegValueText = NULL;

	if (NULL == m_pNodeRegKeysSW)
	{
		//
		// create the <regKeys> node
		//
		pNodeRegKeys = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_REGKEYS);
		if (NULL == pNodeRegKeys) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeSystemInfo, pNodeRegKeys));

		//
		// create the <HKEY_LOCAL_MACHINE> node
		//
		pNodeRegKeysHKLM = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_REG_HKLM);
		if (NULL == pNodeRegKeysHKLM) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeRegKeys, pNodeRegKeysHKLM));

		//
		// create the <SOFTWARE> node
		//
		m_pNodeRegKeysSW = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_REG_SW);
		if (NULL == m_pNodeRegKeysSW) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeRegKeysHKLM, m_pNodeRegKeysSW));
	}

	//
	// add the <value> node
	//
	pNodeRegValue = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_VALUE);
	if (NULL == pNodeRegValue) goto CleanUp;

	pNodeRegValueText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeRegValueText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeRegValueText, bstrProvider));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeRegValue, pNodeRegValueText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeRegKeysSW, pNodeRegValue));

CleanUp:
    if (FAILED(hr))
        SafeReleaseNULL(m_pNodeRegKeysSW);
	SafeReleaseNULL(pNodeRegKeys);
	SafeReleaseNULL(pNodeRegKeysHKLM);
	SafeReleaseNULL(pNodeRegValue);
	SafeReleaseNULL(pNodeRegValueText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddPlatform()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddPlatform(BSTR bstrName)
{
	LOG_Block("AddPlatform()");

	HRESULT		hr = E_FAIL;

	m_pNodePlatform = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PLATFORM);
	if (NULL == m_pNodePlatform) return hr;

	ReturnIfFail(SetAttribute(m_pNodePlatform, KEY_NAME, bstrName));
	ReturnIfFail(InsertNode(m_pNodeSystemInfo, m_pNodePlatform));
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddProcessor()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddProcessor(BSTR bstrProcessor)
{
	LOG_Block("AddProcessor()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeProcessor = NULL;
	IXMLDOMNode*	pNodeProcessorText = NULL;

	pNodeProcessor = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PROCESSORARCHITECTURE);
	if (NULL == pNodeProcessor) goto CleanUp;

	pNodeProcessorText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeProcessorText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeProcessorText, bstrProcessor));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeProcessor, pNodeProcessorText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeProcessor));

CleanUp:
	SafeReleaseNULL(pNodeProcessor);
	SafeReleaseNULL(pNodeProcessorText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddVersion()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddVersion(INT  iMajor /*= -1*/,
								   INT  iMinor /*= -1*/,
								   INT  iBuild /*= -1*/,
								   INT  iSPMajor /*= -1*/,
								   INT  iSPMinor /*= -1*/,
								   BSTR bstrTimeStamp /*= NULL*/)
{
	LOG_Block("AddVersion()");

	HRESULT			hr = E_FAIL;
	IXMLDOMNode*	pNodeVersion = NULL;

	//
	// create the <version> node
	//
	pNodeVersion = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_VERSION);
	if (NULL == pNodeVersion) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeVersion));

	//
	// set the "major" attribute
	//
	if (-1 != iMajor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_MAJOR, iMajor));
	}

	//
	// set the "minor" attribute
	//
	if (-1 != iMinor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_MINOR, iMinor));
	}

	//
	// set the "build" attribute
	//
	if (-1 != iBuild)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_BUILD, iBuild));
	}

	//
	// set the "servicePackMajor" attribute
	//
	if (-1 != iSPMajor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_SERVICEPACKMAJOR, iSPMajor));
	}

	//
	// set the "servicePackMinor" attribute
	//
	if (-1 != iSPMinor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_SERVICEPACKMINOR, iSPMinor));
	}

	//
	// set the "timestamp" attribute
	//
	if (NULL != bstrTimeStamp)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_TIMESTAMP, bstrTimeStamp));
	}

CleanUp:
	SafeReleaseNULL(pNodeVersion);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddSuite()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddSuite(BSTR bstrSuite)
{
	LOG_Block("AddSuite()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeSuite = NULL;
	IXMLDOMNode*	pNodeSuiteText = NULL;

	pNodeSuite = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_SUITE);
	if (NULL == pNodeSuite) goto CleanUp;

	pNodeSuiteText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeSuiteText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeSuiteText, bstrSuite));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeSuite, pNodeSuiteText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeSuite));

CleanUp:
	SafeReleaseNULL(pNodeSuite);
	SafeReleaseNULL(pNodeSuiteText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddProductType()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddProductType(BSTR bstrProductType)
{
	LOG_Block("AddProductType()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeProductType = NULL;
	IXMLDOMNode*	pNodeProductTypeText = NULL;

	pNodeProductType = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PRODUCTTYPE);
	if (NULL == pNodeProductType) goto CleanUp;

	pNodeProductTypeText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeProductTypeText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeProductTypeText, bstrProductType));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeProductType, pNodeProductTypeText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeProductType));

CleanUp:
	SafeReleaseNULL(pNodeProductType);
	SafeReleaseNULL(pNodeProductTypeText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddLocale()
//
// We need to pass back a handle to differentiate different <locale> node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddLocale(BSTR bstrContext, HANDLE_NODE* phNodeLocale)
{
	LOG_Block("AddLocale()");

	HRESULT		hr = E_FAIL;

	*phNodeLocale = CreateDOMNodeWithHandle(m_pDocSystemSpec, NODE_ELEMENT, KEY_LOCALE);
	if (HANDLE_NODE_INVALID == *phNodeLocale) return hr;

	hr = SetAttribute(m_ppNodeArray[*phNodeLocale], KEY_CONTEXT, bstrContext);
	if (FAILED(hr))
	{
	    SafeCloseHandleNode(*phNodeLocale);
	    LOG_ErrorMsg(hr);
	    return hr;
	}
	ReturnIfFail(InsertNode(m_pNodeSystemInfo, m_ppNodeArray[*phNodeLocale]));
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddLanguage()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddLanguage(HANDLE_NODE hNodeLocale, BSTR bstrLocale)
{
	LOG_Block("AddLanguage()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeLanguage = NULL;
	IXMLDOMNode*	pNodeLanguageText = NULL;

	pNodeLanguage = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_LANGUAGE);
	if (NULL == pNodeLanguage) goto CleanUp;

	pNodeLanguageText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeLanguageText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeLanguageText, bstrLocale));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeLanguage, pNodeLanguageText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeLocale], pNodeLanguage));

CleanUp:
	SafeReleaseNULL(pNodeLanguage);
	SafeReleaseNULL(pNodeLanguageText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDevice()
//
// We need to pass back a handle to differentiate different <device> node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddDevice(BSTR bstrDeviceInstance, /*= NULL - optional attribute*/
								  INT  iIsPrinter /*= -1*/, 
								  BSTR bstrProvider /*= NULL*/,
								  BSTR bstrMfgName /*= NULL*/,
								  BSTR bstrDriverName /*= NULL*/,
								  HANDLE_NODE* phNodeDevice)
{
	LOG_Block("AddDevice()");

	HRESULT			hr = E_FAIL;
	IXMLDOMNode*	pNodePrinterInfo = NULL;

	if (NULL == m_pNodeDevices)
	{
		//
		// create the <devices> node
		//
		m_pNodeDevices = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_DEVICES);
		if (NULL == m_pNodeDevices) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeSystemInfo, m_pNodeDevices));
	}

	//
	// add the <device> node
	//
	*phNodeDevice = CreateDOMNodeWithHandle(m_pDocSystemSpec, NODE_ELEMENT, KEY_DEVICE);
	if (HANDLE_NODE_INVALID == *phNodeDevice) goto CleanUp;

	if (NULL != bstrDeviceInstance && 0 < lstrlenW(bstrDeviceInstance))
	{
		//
		// set optional deviceInstance attribute of <device>
		//
		CleanUpIfFailedAndSetHrMsg(SetAttribute(m_ppNodeArray[*phNodeDevice], KEY_DEVICEINSTANCE, bstrDeviceInstance));
	}

	if (-1 != iIsPrinter)
	{
		//
		// set isPrinter attribute of <device>
		//
		CleanUpIfFailedAndSetHrMsg(SetAttribute(m_ppNodeArray[*phNodeDevice], KEY_ISPRINTER, iIsPrinter));

		//
		// Add a <printerInfo> node within <device>
		//
		pNodePrinterInfo = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PRINTERINFO);
		if (NULL != pNodePrinterInfo)
		{
			if (NULL != bstrProvider)
			{
				CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodePrinterInfo, KEY_DRIVERPROVIDER, bstrProvider));
			}
			if (NULL != bstrMfgName)
			{
				CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodePrinterInfo, KEY_MFGNAME, bstrMfgName));
			}
			if (NULL != bstrDriverName)
			{
				CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodePrinterInfo, KEY_DRIVERNAME, bstrDriverName));
			}
			CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeDevice], pNodePrinterInfo));
		}
	}

	//
	// insert to <devices>
	//
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeDevices, m_ppNodeArray[*phNodeDevice]));

CleanUp:
	SafeReleaseNULL(pNodePrinterInfo);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddHWID()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddHWID(HANDLE_NODE hNodeDevice,
								BOOL fIsCompatible,
								UINT iRank,
								BSTR bstrHWID,
								BSTR bstrDriverVer /*= NULL*/)
{
	LOG_Block("AddHWID()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeHWID = NULL;
	IXMLDOMNode*	pNodeHWIDText = NULL;
	BSTR bstrNameHWID = NULL;

	if (fIsCompatible)
	{
		bstrNameHWID = SysAllocString(L"compid");
	}
	else
	{
		bstrNameHWID = SysAllocString(L"hwid");
	}

	pNodeHWID = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, bstrNameHWID);
	if (NULL == pNodeHWID) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeHWID, KEY_RANK, iRank));
	if (NULL != bstrDriverVer)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeHWID, KEY_DRIVERVER, bstrDriverVer));
	}
	pNodeHWIDText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeHWIDText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeHWIDText, bstrHWID));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeHWID, pNodeHWIDText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeDevice], pNodeHWID));

CleanUp:
	SafeReleaseNULL(pNodeHWID);
	SafeReleaseNULL(pNodeHWIDText);
	SysFreeString(bstrNameHWID);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetSystemSpecBSTR()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::GetSystemSpecBSTR(BSTR *pbstrXmlSystemSpec)
{
	LOG_Block("GetSystemSpecBSTR()");

	//
	// convert XML DOC into BSTR 
	//
	HRESULT hr = m_pDocSystemSpec->get_xml(pbstrXmlSystemSpec);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemClass

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for SystemInfoClasses
/////////////////////////////////////////////////////////////////////////////
CXmlSystemClass::CXmlSystemClass()
 : m_pDocSystemClass(NULL)
{
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for SystemInfoClasses
/////////////////////////////////////////////////////////////////////////////
CXmlSystemClass::~CXmlSystemClass()
{
	SafeReleaseNULL(m_pDocSystemClass);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocument()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemClass::LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode)
{
	LOG_Block("LoadXMLDocument()");
	SafeReleaseNULL(m_pDocSystemClass);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocSystemClass, fOfflineMode);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetClasses()
//
// Return the bitmap of existence of all possible system info classes
/////////////////////////////////////////////////////////////////////////////
DWORD CXmlSystemClass::GetClasses()
{
	LOG_Block("GetClasses()");

	DWORD				dwResult = 0;
    IXMLDOMNodeList*	pNodeList = NULL;

	BSTR bstrNameComputerSystem = SysAllocString(L"classes/computerSystem");
	BSTR bstrNameRegKeys = SysAllocString(L"classes/regKeys");
	BSTR bstrNamePlatform = SysAllocString(L"classes/platform");
	BSTR bstrNameLocale = SysAllocString(L"classes/locale");
	BSTR bstrNameDevices = SysAllocString(L"classes/devices");

	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameComputerSystem);
	if (NULL != pNodeList)
	{
		dwResult |= COMPUTERSYSTEM;
		SafeReleaseNULL(pNodeList);
	}

	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameRegKeys);
	if (NULL != pNodeList)
	{
		dwResult |= REGKEYS;
		SafeReleaseNULL(pNodeList);
	}
	
	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNamePlatform);
	if (NULL != pNodeList)
	{
		dwResult |= PLATFORM;
		SafeReleaseNULL(pNodeList);
	}
	
	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameLocale);
	if (NULL != pNodeList)
	{
		dwResult |= LOCALE;
		SafeReleaseNULL(pNodeList);
	}

	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameDevices);
	if (NULL != pNodeList)
	{
		dwResult |= DEVICES;
		SafeReleaseNULL(pNodeList);
	}
	
	SysFreeString(bstrNameComputerSystem);
	SysFreeString(bstrNameRegKeys);
	SysFreeString(bstrNamePlatform);
	SysFreeString(bstrNameLocale);
	SysFreeString(bstrNameDevices);
	return dwResult;
}


/////////////////////////////////////////////////////////////////////////////
// CXmlCatalog

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for Catalog
/////////////////////////////////////////////////////////////////////////////
CXmlCatalog::CXmlCatalog()
 : m_pDocCatalog(NULL)
{
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for Catalog
/////////////////////////////////////////////////////////////////////////////
CXmlCatalog::~CXmlCatalog()
{
	SafeReleaseNULL(m_pDocCatalog);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocument()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode)
{
	LOG_Block("LoadXMLDocument()");
	SafeReleaseNULL(m_pDocCatalog);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocCatalog, fOfflineMode);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemCount()
//
// Gets a Count of How Many Items are in this Catalog
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemCount(LONG *plItemCount)
{
    LOG_Block("GetItemCount()");
    HRESULT hr = E_FAIL;
    IXMLDOMNodeList *pItemList = NULL;

    QuitIfNull(plItemCount);
    QuitIfNull(m_pDocCatalog);


	IXMLDOMNode	*pParentNode = NULL;
	CleanUpIfFailedAndSetHrMsg(m_pDocCatalog->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));	
	CleanUpIfFailedAndSetHrMsg(pParentNode->selectNodes(KEY_ITEM_SEARCH, &pItemList));
    if (NULL == pItemList) goto CleanUp;

    CleanUpIfFailedAndSetHrMsg(pItemList->get_length(plItemCount));

CleanUp:
	SafeReleaseNULL(pParentNode);
    SafeReleaseNULL(pItemList);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetProviders()
// 
// Find a list of <provider> node in catalog xml
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* CXmlCatalog::GetProviders()
{
    LOG_Block("GetProviders()");

	IXMLDOMNodeList*	pNodeList = NULL;
	
	pNodeList = FindDOMNodeList(m_pDocCatalog, KEY_CATALOG_PROVIDER);
	
	return pNodeList;
}


/////////////////////////////////////////////////////////////////////////////
// GetFirstProvider()
//
// Find the first provider in catalog xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetFirstProvider(HANDLE_NODE* phNodeProvider)
{
    LOG_Block("GetFirstProvider()");

	HANDLE_NODELIST hNodeListProvider = FindFirstDOMNode(m_pDocCatalog, KEY_CATALOG_PROVIDER, phNodeProvider);
	
	return hNodeListProvider;
}
	
	
/////////////////////////////////////////////////////////////////////////////
// GetNextProvider()
//
// Find the next provider in catalog xml doc
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetNextProvider(HANDLE_NODELIST hNodeListProvider, HANDLE_NODE* phNodeProvider)
{
    LOG_Block("GetNextProvider()");

	return FindNextDOMNode(hNodeListProvider, phNodeProvider);
}


/////////////////////////////////////////////////////////////////////////////
// GetFirstItem()
//
// Find the first item in provider (parent) node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetFirstItem(HANDLE_NODE hNodeProvider, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetFirstItem()");

	HANDLE_NODELIST hNodeListItem = FindFirstDOMNode(m_ppNodeArray[hNodeProvider], KEY_ITEM, phNodeItem);

    return hNodeListItem;
}
	
	
/////////////////////////////////////////////////////////////////////////////
// GetNextItem()
//
// Find the next item in provider (parent) node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetNextItem()");

	return FindNextDOMNode(hNodeListItem, phNodeItem);
}
	
/////////////////////////////////////////////////////////////////////////////
// GetFirstItemDependency()
//
// Find the first dependency item in Item Dependencies node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetFirstItemDependency(HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetFirstItemDependency");
    HRESULT hr;

    QuitIfNull(phNodeItem);

    IXMLDOMNode* pNodeDependencies = NULL;
    IXMLDOMNode* pNodeIdentity = NULL;
    HANDLE_NODELIST hNodeListItem = HANDLE_NODELIST_INVALID;
        
    hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_DEPENDENCIES, &pNodeDependencies);
    QuitIfFail(hr);

    hNodeListItem = FindFirstDOMNode(pNodeDependencies, KEY_IDENTITY, &pNodeIdentity);
    if (HANDLE_NODELIST_INVALID != hNodeListItem)
    {
        // We found at least one Identity in this Dependencies key, Try to find the matching
        // Item in the Catalog and if found return as the phNodeItem
        FindItemByIdentity(pNodeIdentity, phNodeItem);
    }

CleanUp:
    SafeReleaseNULL(pNodeIdentity);
    SafeReleaseNULL(pNodeDependencies);

    return hNodeListItem;
}


/////////////////////////////////////////////////////////////////////////////
// GetNextItemDependency()
//
// Find the next dependency item in the Item Dependencies node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetNextItemDependency(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetNextItemDependency");
    HRESULT hr;

    QuitIfNull(phNodeItem);
    
    IXMLDOMNode* pNodeIdentity = NULL;

    hr = FindNextDOMNode(hNodeListItem, &pNodeIdentity);
    // This function is supposed to return S_FALSE when no more items are available
    // but FindNextDOMNode returns E_FAIL when it can't find the next node. So we won't
    // look at the return.
    // CleanUpIfFailedAndMsg(hr); 

    if (NULL != pNodeIdentity)
    {
        // We found another Identity in this Dependencies Key
        hr = FindItemByIdentity(pNodeIdentity, phNodeItem);
    }
    else 
    {
        hr = S_FALSE; // indicate to caller there are no more identities.
    }

    SafeReleaseNULL(pNodeIdentity);
    return hr;
}

	
/////////////////////////////////////////////////////////////////////////////
// CloseItemList()
//
// Release the item nodelist
/////////////////////////////////////////////////////////////////////////////
void CXmlCatalog::CloseItemList(HANDLE_NODELIST hNodeListItem)
{
	SafeFindCloseHandle(hNodeListItem);
}


/////////////////////////////////////////////////////////////////////////////
// GetIdentity()
//
// Retrieve the unique name (identity) of the given provider or item
/////////////////////////////////////////////////////////////////////////////
//
// public version
//
HRESULT CXmlCatalog::GetIdentity(HANDLE_NODE hNode,
								 BSTR* pbstrName,
								 BSTR* pbstrPublisherName,
								 BSTR* pbstrGUID)
{
    LOG_Block("GetIdentity()");

	HRESULT		hr = E_FAIL;
	IXMLDOMNode*	pNodeIdentity = NULL;

	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNode], KEY_IDENTITY, &pNodeIdentity));
	hr = Get3IdentiStrFromIdentNode(pNodeIdentity, pbstrName, pbstrPublisherName, pbstrGUID);

CleanUp:
	SafeReleaseNULL(pNodeIdentity);
	return hr;
}




/////////////////////////////////////////////////////////////////////////////
// GetIdentityStr()
//
// Retrieve the string that can be used to uniquely identify an object
// based on its <identity> node.
//
// This function defines the logic about what components can be used
// to define the uniqueness of an item based on the 3 parts of data from
// GetIdentity().
//
// The created string will be language neutral. That is, it can not
// ensure the uniqueness for two items having the same <identity> node
// except different only on <langauge> part inside <identity>
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetIdentityStr(HANDLE_NODE hNode,
					BSTR* pbstrUniqIdentifierString)
{
	IXMLDOMNode* pIdentityNode = NULL;
	HRESULT hr = E_INVALIDARG;
	if (FindNode(m_ppNodeArray[hNode], KEY_IDENTITY, &pIdentityNode) && NULL != pIdentityNode)
	{
		hr = UtilGetUniqIdentityStr(pIdentityNode, pbstrUniqIdentifierString, 0x0);
		SafeReleaseNULL(pIdentityNode);
	}
	return hr;
}

HRESULT CXmlCatalog::GetIdentityStrForPing(HANDLE_NODE hNode,
                    BSTR* pbstrUniqIdentifierString)
{
	IXMLDOMNode* pIdentityNode = NULL;
	HRESULT hr = E_INVALIDARG;
	if (FindNode(m_ppNodeArray[hNode], KEY_IDENTITY, &pIdentityNode) && NULL != pIdentityNode)
	{
		//
		// first, based on OP team's requirement, we try to look for <itemId> in the identity tag.
		// if it's there, use use that. If not, we use the publisherName.itemname thing.
		//
		if (FAILED(hr = GetAttribute(pIdentityNode, KEY_ITEMID, pbstrUniqIdentifierString)) || NULL == *pbstrUniqIdentifierString)
		{
			// hr = UtilGetUniqIdentityStr(pIdentityNode, pbstrUniqIdentifierString, SKIP_SERVICEPACK_VER);
			hr = E_INVALIDARG;
		}
		
		SafeReleaseNULL(pIdentityNode);
	}
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// GetBSTRItemForCallback()
//
// Create an item node as the passed-in node, have child nodes identity and
// platform (anything uniquely idenitify this item) then output this 
// item node data as string, then delete the crated node
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetBSTRItemForCallback(HANDLE_NODE hItem, BSTR* pbstrXmlItemForCallback)
{
	HRESULT hr = E_INVALIDARG;
	IXMLDOMNode* pNewItemNode = NULL;
	IXMLDOMNode* pNewIdentityNode = NULL;
	IXMLDOMNode* pNewPlatformNode = NULL;
	IXMLDOMNode* pOldIdentityNode = NULL;
	IXMLDOMNode* pOldPlatformNode = NULL;
	IXMLDOMNode* p1 = NULL, *p2 = NULL;

	LOG_Block("CXmlCatalog::GetBSTRItemForCallback()");

	if (FAILED(hr = m_ppNodeArray[hItem]->cloneNode(VARIANT_FALSE, &pNewItemNode)) ||
		FAILED(hr = FindSingleDOMNode(m_ppNodeArray[hItem], KEY_IDENTITY, &pOldIdentityNode)) || 
		NULL == pOldIdentityNode ||
		FAILED(hr = pOldIdentityNode->cloneNode(VARIANT_TRUE, &pNewIdentityNode)) ||
		NULL == pNewIdentityNode ||
		FAILED(hr = pNewItemNode->appendChild(pNewIdentityNode, &p1)) || NULL == p1)	
	{
		if (S_FALSE == hr)
			hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// platform is optional
	//
	FindSingleDOMNode(m_ppNodeArray[hItem], KEY_PLATFORM, &pOldPlatformNode);
	if (pOldPlatformNode)
	{
		if (FAILED(hr = pOldPlatformNode->cloneNode(VARIANT_TRUE, &pNewPlatformNode)) ||
			NULL == pNewPlatformNode ||
			FAILED(hr = pNewItemNode->appendChild(pNewPlatformNode, &p2)) || NULL == p2)

		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}
	}
		
	pNewItemNode->get_xml(pbstrXmlItemForCallback);
	

CleanUp:
	SafeReleaseNULL(pOldIdentityNode);
	SafeReleaseNULL(pOldPlatformNode);
	SafeReleaseNULL(pNewIdentityNode);
	SafeReleaseNULL(pNewPlatformNode);
	SafeReleaseNULL(p1);
	SafeReleaseNULL(p2);
	SafeReleaseNULL(pNewItemNode);

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// IsPrinterDriver()
//
// Retrieves from the Catalog whether this Item is a Printer Driver
//
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlCatalog::IsPrinterDriver(HANDLE_NODE hNode)
{
    LOG_Block("IsPrinterDriver()");
    BOOL fRet = FALSE;
    HRESULT hr;

    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);

    int intIsPrinter = 0;
    GetAttribute(pNodeDevice, KEY_ISPRINTER, &intIsPrinter);

    if (1 == intIsPrinter)
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

CleanUp:
    SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////
// GetDriverInfo()
//
// Retrieves the Driver Information from the Catalog for this Item. Returns
// the Display Name and HWID for this driver - This is passed to the CDM 
// installer
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetDriverInfo(HANDLE_NODE hNode, 
                                   BSTR* pbstrHWID, 
                                   BSTR* pbstrDisplayName)
{
    HRESULT hr;
    LOG_Block("GetDriverInfo()");

    QuitIfNull(pbstrHWID);
    QuitIfNull(pbstrDisplayName);

    *pbstrHWID = NULL;
    *pbstrDisplayName = NULL;
    
    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;
    IXMLDOMNode* pNodeHWID = NULL;
    IXMLDOMNode* pNodeDescription = NULL;
    IXMLDOMNode* pNodeDescriptionText = NULL;
    IXMLDOMNode* pNodeTitle = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDevice, KEY_HWID, &pNodeHWID);
    CleanUpIfFailedAndMsg(hr);

    GetText(pNodeHWID, pbstrHWID);

    hr = FindSingleDOMNode(pNodeDetection, KEY_DESCRIPTION, &pNodeDescription);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescription, KEY_DESCRIPTIONTEXT, &pNodeDescriptionText);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescriptionText, KEY_TITLE, &pNodeTitle);
    CleanUpIfFailedAndMsg(hr);

    GetText(pNodeTitle, pbstrDisplayName);

CleanUp:
    if (FAILED(hr))
    {
        SafeSysFreeString(*pbstrHWID);
        SafeSysFreeString(*pbstrDisplayName);
    }
    SafeReleaseNULL(pNodeTitle);
    SafeReleaseNULL(pNodeDescriptionText);
    SafeReleaseNULL(pNodeDescription);
    SafeReleaseNULL(pNodeHWID);
    SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetPrinterDriverInfo()
//
// Retrieves the Printer Driver Information from the Catalog for this Item. 
// Returns the DriverName and the Architecture - This is passed to the CDM
// installer
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetPrinterDriverInfo(HANDLE_NODE hNode,
                                          BSTR* pbstrDriverName,
                                          BSTR* pbstrArchitecture)
{
    HRESULT hr;
    LOG_Block("GetPrinterDriverInfo()");

    QuitIfNull(pbstrDriverName);
    QuitIfNull(pbstrArchitecture);

    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;
    IXMLDOMNode* pNodePrinterInfo = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDevice, KEY_PRINTERINFO, &pNodePrinterInfo);
    CleanUpIfFailedAndMsg(hr);

    GetAttribute(pNodePrinterInfo, KEY_DRIVERNAME, pbstrDriverName);

    // NOTE: Currently the CatalogSchema site is not returning 
    // architecture for printers, and the schema doesn't require it
    // CDM is using a default string for now based on compile architecture
    // so we'll leave pbstrArchitecture NULL..

CleanUp:
    SafeReleaseNULL(pNodePrinterInfo);
    SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetDriverInfoEx()
//
// Combines functionality of IsPrinterDriver, GetDriverInfo, and
// GetPrinterDriverInfo plus retreives MfgName and DriverProvider.
// Used by FindMatchingDriver()
//
// If SUCCEEDES pbstrHWID, pbstrDriverVer, and pbstrDisplayName
//    are always returned.
// If SUCCEEDES && *pFIsPrinter == TRUE then pbstrDriverName,
//    pbstrDriverProvider, and pbstrMfgName are returned.
//
// Currently pbstrArchitecture is never returned.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetDriverInfoEx(	HANDLE_NODE hNode,
										BOOL* pfIsPrinter,
										BSTR* pbstrHWID,
										BSTR* pbstrDriverVer,
										BSTR* pbstrDisplayName,
                                        BSTR* pbstrDriverName,
										BSTR* pbstrDriverProvider,
										BSTR* pbstrMfgName,
                                        BSTR* pbstrArchitecture)
{
    HRESULT hr;
    LOG_Block("GetDriverInfoEx()");

    QuitIfNull(pbstrHWID);
	QuitIfNull(pbstrDriverVer);
	QuitIfNull(pbstrDisplayName);
	QuitIfNull(pbstrDriverName);
	QuitIfNull(pbstrDriverProvider);
	QuitIfNull(pbstrMfgName);
	QuitIfNull(pbstrArchitecture);
    
	*pbstrHWID = NULL;
	*pbstrDriverVer = NULL;
	*pbstrDisplayName = NULL;
	*pbstrDriverName = NULL;
	*pbstrDriverProvider = NULL;
	*pbstrMfgName = NULL;
	*pbstrArchitecture = NULL;
    
    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;
    IXMLDOMNode* pNodeHWID = NULL;
    IXMLDOMNode* pNodeDescription = NULL;
    IXMLDOMNode* pNodeDescriptionText = NULL;
    IXMLDOMNode* pNodeTitle = NULL;
    IXMLDOMNode* pNodePrinterInfo = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);
	//
	// Is it a printer?
	//
	int intIsPrinter = 0;
    GetAttribute(pNodeDevice, KEY_ISPRINTER, &intIsPrinter);

    if (1 == intIsPrinter)
    {
        *pfIsPrinter = TRUE;
    }
    else
    {
        *pfIsPrinter = FALSE;
    }
	//
	// HWID and Driver Description
	//
    hr = FindSingleDOMNode(pNodeDevice, KEY_HWID, &pNodeHWID);
    CleanUpIfFailedAndMsg(hr);

    hr = GetText(pNodeHWID, pbstrHWID);
    CleanUpIfFailedAndMsg(hr);

	hr = GetAttribute(pNodeHWID, KEY_DRIVERVER, pbstrDriverVer);
    CleanUpIfFailedAndMsg(hr);

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DESCRIPTION, &pNodeDescription);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescription, KEY_DESCRIPTIONTEXT, &pNodeDescriptionText);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescriptionText, KEY_TITLE, &pNodeTitle);
    CleanUpIfFailedAndMsg(hr);

    hr = GetText(pNodeTitle, pbstrDisplayName);
    CleanUpIfFailedAndMsg(hr);

	if (*pfIsPrinter)
	{
		//
		// Printer Attributes
		//
		hr = FindSingleDOMNode(pNodeDevice, KEY_PRINTERINFO, &pNodePrinterInfo);
		CleanUpIfFailedAndMsg(hr);

		hr = GetAttribute(pNodePrinterInfo, KEY_DRIVERNAME, pbstrDriverName);
		CleanUpIfFailedAndMsg(hr);

		hr = GetAttribute(pNodePrinterInfo, KEY_DRIVERPROVIDER, pbstrDriverProvider);
		CleanUpIfFailedAndMsg(hr);

		hr = GetAttribute(pNodePrinterInfo, KEY_MFGNAME, pbstrMfgName);
		CleanUpIfFailedAndMsg(hr);

		// NOTE: Currently the CatalogSchema site is not returning 
		// architecture for printers, and the schema doesn't require it
		// CDM is using a default string for now based on compile architecture
		// so we'll leave pbstrArchitecture NULL..
	}

CleanUp:
    if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrHWID);
		SafeSysFreeString(*pbstrDriverVer);
		SafeSysFreeString(*pbstrDisplayName);
		SafeSysFreeString(*pbstrDriverName);
		SafeSysFreeString(*pbstrDriverProvider);
		SafeSysFreeString(*pbstrMfgName);
		SafeSysFreeString(*pbstrArchitecture);
	}
    SafeReleaseNULL(pNodeTitle);
    SafeReleaseNULL(pNodeDescriptionText);
    SafeReleaseNULL(pNodeDescription);
    SafeReleaseNULL(pNodeHWID);
    SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);
	SafeReleaseNULL(pNodePrinterInfo);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetItemPlatformStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve the <platform> node from <identity> and
// convert the data inside <platform> into a string that can be used to
// uniquely identify a platform.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemFirstPlatformStr(HANDLE_NODE hNodeItem,
					BSTR* pbstrPlatform)
{
	HRESULT hr;

	IXMLDOMNode* pNodePlatform = NULL;

	LOG_Block("GetItemFirstPlatformStr");

	USES_IU_CONVERSION;

	//
	// get the first platform node from this item node
	//
	hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatform);
	CleanUpIfFailedAndMsg(hr);

	//
	// get platform data from this ndoe and convert it into string
	//
	hr = GetPlatformStrForPing(pNodePlatform, pbstrPlatform);

CleanUp:

	SafeReleaseNULL(pNodePlatform);

	//
	// since platform is not a required element in <item>, so we should not
	// return error if not found
	//
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
	{
		*pbstrPlatform = NULL;
		hr = S_FALSE;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// GetItemAllPlatformStr()
//
// The input node pointer points to an item node that has <platform> node(s).
// This function will retrieve every <platform> node from this item node and
// convert the data inside <platform> into a string that can be used to
// uniquely identify a platform.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemAllPlatformStr(HANDLE_NODE hNodeItem,
					BSTR** ppbPlatforms, UINT* pnPlatformCount)
{
	LOG_Block("GetItemAllPlatformStr");

	HRESULT hr;
	IXMLDOMNodeList*	pPlatformList = NULL;
	IXMLDOMElement*		pElement = NULL;
	IXMLDOMNode*		pNodePlatform = NULL;

	long				lCount = 0;
	int					i;
	BSTR*				pbstrPlatformList = NULL;

	//
	// get list of platform nodes
	//
	hr = m_ppNodeArray[hNodeItem]->QueryInterface(IID_IXMLDOMElement, (void**)&pElement);
	CleanUpIfFailedAndMsg(hr);
	hr = pElement->getElementsByTagName(KEY_PLATFORM, &pPlatformList);
	CleanUpIfFailedAndMsg(hr);

	hr = pPlatformList->get_length(&lCount);
	CleanUpIfFailedAndMsg(hr);

	if (0 == lCount)
	{
		goto CleanUp;
	}


	pbstrPlatformList = (BSTR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lCount * sizeof(BSTR*));
	CleanUpFailedAllocSetHrMsg(pbstrPlatformList);

	//
	// loop through each suite, if any
	//
	pPlatformList->reset();
	for (i = 0; i < lCount; i++)
	{
		hr = pPlatformList->get_item(i, &pNodePlatform);
		CleanUpIfFailedAndMsg(hr);
		if (pNodePlatform)
		{
			hr = pNodePlatform->get_text(&(pbstrPlatformList[i]));
			CleanUpIfFailedAndMsg(hr);
			pNodePlatform->Release();
			pNodePlatform = NULL;
		}
	}

	hr = S_OK;


CleanUp:
	SafeReleaseNULL(pNodePlatform);
	SafeReleaseNULL(pPlatformList);
	SafeReleaseNULL(pElement);

	if (SUCCEEDED(hr))
	{
		*pnPlatformCount = lCount;
		*ppbPlatforms = pbstrPlatformList;
	}
	else
	{
		if (NULL != pbstrPlatformList)
		{
			*pnPlatformCount = 0;
			//
			// release all possibly allocated memory
			//
			for (i = 0; i < lCount; i++)
			{
				SafeSysFreeString(pbstrPlatformList[i]);
			}
			HeapFree(GetProcessHeap(), 0, pbstrPlatformList);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemPlatformStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve the <platform> node from <identity> and
// convert the data inside <platform> into a string that can be used to
// uniquely identify a platform.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetPlatformStr(IXMLDOMNode* pNodePlatform,
					BSTR* pbstrPlatform)
{
	return UtilGetPlatformStr(pNodePlatform, pbstrPlatform, 0x0);
}

HRESULT CXmlCatalog::GetPlatformStrForPing(IXMLDOMNode* pNodePlatform,
					BSTR* pbstrPlatform)
{
	return UtilGetPlatformStr(pNodePlatform, pbstrPlatform, SKIP_SUITES | SKIP_SERVICEPACK_VER);
}


/////////////////////////////////////////////////////////////////////////////
//
// get data from a version node and convert them into a string with
// format: 
//			VersionStr   = <Version>[,<SvcPackVer>[,<timeStamp>]]
//			<Version>    = <Major>[.<Minor>[.<Build>]]
//			<SvcPackVer> = <Major>[.<minor>]
//
// Assumption:
//			pszVersion points to a buffer LARGE ENOUGH to store
//			any legal version number.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::getVersionStr(IXMLDOMNode* pNodeVersion, LPTSTR pszVersion)
{
	return UtilGetVersionStr(pNodeVersion, pszVersion, 0x0);
}

HRESULT CXmlCatalog::getVersionStrWithoutSvcPack(IXMLDOMNode* pNodeVersion, LPTSTR pszVersion)
{
	return UtilGetVersionStr(pNodeVersion, pszVersion, SKIP_SERVICEPACK_VER);
}



/////////////////////////////////////////////////////////////////////////////
// GetItemFirstLanguageStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve the first <language> node from <identity> 
// node 
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemFirstLanguageStr(HANDLE_NODE hNodeItem,
					BSTR* pbstrLanguage)
{
	LOG_Block("GetItemFirstLanguageStr");

	IXMLDOMNode* pNodeIdentity = NULL;
	IXMLDOMNode* pNodeLanguage = NULL;

	HRESULT hr = m_ppNodeArray[hNodeItem]->selectSingleNode(KEY_IDENTITY, &pNodeIdentity);
	CleanUpIfFailedAndMsg(hr);

	if (pNodeIdentity)
	{
		if (HANDLE_NODELIST_INVALID == FindFirstDOMNode(pNodeIdentity, KEY_LANGUAGE, &pNodeLanguage))
		{
			hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
			goto CleanUp;
		}
		else
		{
			hr = pNodeLanguage->get_text(pbstrLanguage);
			CleanUpIfFailedAndMsg(hr);
		}
	}

CleanUp:

	SafeReleaseNULL(pNodeLanguage);
	SafeReleaseNULL(pNodeIdentity);

	//
	// since language is not a required element in <identity>, so we should not
	// return error if not found
	//
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
	{
		*pbstrLanguage = NULL;
		hr = S_FALSE;
	}

	return hr;

}


/////////////////////////////////////////////////////////////////////////////
// GetItemAllLanguageStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve every <language> node from <identity> node and
// convert the data into an BSTR array to return.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemAllLanguageStr(HANDLE_NODE hNodeItem,
					BSTR** ppbstrLanguage, UINT* pnLangCount)
{
	LOG_Block("GetItemAllLanguageStr");

	HRESULT				hr;
	IXMLDOMNode*		pNodeIdentity = NULL;
	IXMLDOMNodeList*	pLanguageList = NULL;
	IXMLDOMElement*		pElement = NULL;
	IXMLDOMNode*		pNodeLanguage = NULL;

	long				lCount = 0;
	int					i;
	BSTR*				pbstrLanguageList = NULL;

	hr = m_ppNodeArray[hNodeItem]->selectSingleNode(KEY_IDENTITY, &pNodeIdentity);
	CleanUpIfFailedAndMsg(hr);

	//
	// get list of  nodes
	//
	hr = pNodeIdentity->QueryInterface(IID_IXMLDOMElement, (void**)&pElement);
	CleanUpIfFailedAndMsg(hr);
	hr = pElement->getElementsByTagName(KEY_LANGUAGE, &pLanguageList);
	CleanUpIfFailedAndMsg(hr);

	hr = pLanguageList->get_length(&lCount);
	CleanUpIfFailedAndMsg(hr);

	if (0 == lCount)
	{
		goto CleanUp;
	}


	pbstrLanguageList = (BSTR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lCount * sizeof(BSTR*));
	CleanUpFailedAllocSetHrMsg(pbstrLanguageList);

	//
	// loop through each suite, if any
	//
	pLanguageList->reset();
	for (i = 0; i < lCount; i++)
	{
		hr = pLanguageList->get_item(i, &pNodeLanguage);
		CleanUpIfFailedAndMsg(hr);
		if (pNodeLanguage)
		{
			hr = pNodeLanguage->get_text(&(pbstrLanguageList[i]));
			CleanUpIfFailedAndMsg(hr);
			pNodeLanguage->Release();
			pNodeLanguage = NULL;
		}
	}

	hr = S_OK;


CleanUp:
	SafeReleaseNULL(pNodeLanguage);
	SafeReleaseNULL(pLanguageList);
	SafeReleaseNULL(pElement);
	SafeReleaseNULL(pNodeIdentity);

	if (SUCCEEDED(hr))
	{
		*pnLangCount = lCount;
		*ppbstrLanguage = pbstrLanguageList;
	}
	else
	{

		if (NULL != pbstrLanguageList)
		{
			*pnLangCount = 0;
			//
			// release all possibly allocated memory
			//
			for (i = 0; i < lCount; i++)
			{
				SafeSysFreeString(pbstrLanguageList[i]);
			}
			HeapFree(GetProcessHeap(), 0, pbstrLanguageList);
		}
	}

	return hr;



}


/////////////////////////////////////////////////////////////////////////////
// GetItemFirstCodeBase()
//
// Find the first codebase (path) of the given item
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetItemFirstCodeBase(HANDLE_NODE hNodeItem,
												  BSTR* pbstrCodeBase,
												  BSTR* pbstrName,
												  BSTR* pbstrCRC,
												  BOOL* pfPatchAvailable,
												  LONG* plSize)
{
	LOG_Block("GetItemFirstCodeBase()");

	HRESULT		hr = E_FAIL;

	QuitIfNull(pbstrCodeBase);
	QuitIfNull(pbstrName);
	QuitIfNull(pbstrCRC);
	QuitIfNull(pfPatchAvailable);
	QuitIfNull(plSize);

	IXMLDOMNode*	pNodeInstall = NULL;
	IXMLDOMNode*	pNodeCodeBaseSize = NULL;

	HANDLE_NODE		hNodeCodeBase = HANDLE_NODE_INVALID;
	HANDLE_NODELIST hNodeListCodeBase = HANDLE_NODELIST_INVALID;

	*pbstrCodeBase = NULL;
	*pbstrName = NULL;
	*pbstrCRC = NULL;
	*pfPatchAvailable = FALSE;
	*plSize = -1;
	BSTR bstrSize = NULL;

	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLATION, &pNodeInstall));
	hNodeListCodeBase = FindFirstDOMNode(pNodeInstall, KEY_CODEBASE, &hNodeCodeBase);
	if (HANDLE_NODELIST_INVALID == hNodeListCodeBase) goto CleanUp;
	CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_HREF, pbstrCodeBase));
	CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_PATCHAVAILABLE, pfPatchAvailable));
	GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_CRC, pbstrCRC); // optional attribute, don't fail if its not there.
	GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_NAME, pbstrName);
	FindSingleDOMNode(m_ppNodeArray[hNodeCodeBase], KEY_SIZE, &pNodeCodeBaseSize);
	GetText(pNodeCodeBaseSize, &bstrSize);
	if (NULL != bstrSize)
	{
		*plSize = MyBSTR2L(bstrSize);
		SysFreeString(bstrSize);
	}

CleanUp:
	SafeReleaseNULL(pNodeInstall);
	SafeReleaseNULL(pNodeCodeBaseSize);
	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrCodeBase);
		SafeSysFreeString(*pbstrName);
		SafeSysFreeString(*pbstrCRC);
		*pfPatchAvailable = FALSE;
		*plSize = -1;
	}
	return hNodeListCodeBase;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemNextCodeBase()
//
// Find the next codebase (path) of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemNextCodeBase(HANDLE_NODELIST hNodeListCodeBase,
										 BSTR* pbstrCodeBase,
										 BSTR* pbstrName,
										 BSTR* pbstrCRC,
										 BOOL* pfPatchAvailable,
										 LONG* plSize)
{
    LOG_Block("GetItemNextCodeBase()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeCodeBaseSize = NULL;

	HANDLE_NODE		hNodeCodeBase = HANDLE_NODE_INVALID;

	if (NULL == pbstrCodeBase || NULL == pbstrName || NULL == pbstrCRC || NULL == pfPatchAvailable || NULL == plSize)
	{
		return E_INVALIDARG;
	}

	*pbstrCodeBase = NULL;
	*pbstrName = NULL;
	*pbstrCRC = NULL;
	*pfPatchAvailable = FALSE;
	*plSize = -1;
	BSTR bstrSize = NULL;
	
	if (SUCCEEDED(hr = FindNextDOMNode(hNodeListCodeBase, &hNodeCodeBase)))
	{
		CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_HREF, pbstrCodeBase));
		CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_PATCHAVAILABLE, pfPatchAvailable));
		GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_NAME, pbstrName);
		GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_CRC, pbstrCRC);
		FindSingleDOMNode(m_ppNodeArray[hNodeCodeBase], KEY_SIZE, &pNodeCodeBaseSize);
		GetText(pNodeCodeBaseSize, &bstrSize);
		if (NULL != bstrSize)
		{
			*plSize = MyBSTR2L(bstrSize);
		}
	}

CleanUp:
	SafeReleaseNULL(pNodeCodeBaseSize);
	SafeSysFreeString(bstrSize);
	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrCodeBase);
		SafeSysFreeString(*pbstrCRC);
		SafeSysFreeString(*pbstrName);
		*pfPatchAvailable = FALSE;
		*plSize = -1;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemInstallInfo()
//
// Retrieve the installation information of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemInstallInfo(HANDLE_NODE hNodeItem,
                                        BSTR* pbstrInstallerType,
										BOOL* pfExclusive,
                                        BOOL* pfReboot,
                                        LONG* plNumCommands)
{
    LOG_Block("GetItemInstallInfo()");

    HRESULT     hr = E_FAIL;

    QuitIfNull(pbstrInstallerType);
	QuitIfNull(pfExclusive);
    QuitIfNull(pfReboot);
    QuitIfNull(plNumCommands);
    *pbstrInstallerType = NULL;
    *plNumCommands = 0; // may not be any, so initialize to 0

    IXMLDOMNode*        pNodeInstall = NULL;
    IXMLDOMNodeList*    pNodeListCommands = NULL;

    CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLATION, &pNodeInstall));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_INSTALLERTYPE, pbstrInstallerType));
	CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_EXCLUSIVE, pfExclusive));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_NEEDSREBOOT, pfReboot));
    pNodeListCommands = FindDOMNodeList(pNodeInstall, KEY_COMMAND);
    if (NULL != pNodeListCommands)
    {
        CleanUpIfFailedAndSetHrMsg(pNodeListCommands->get_length(plNumCommands));
    }

CleanUp:
    if (FAILED(hr))
    {
        SafeSysFreeString(*pbstrInstallerType);
    }
    SafeReleaseNULL(pNodeInstall);
    SafeReleaseNULL(pNodeListCommands);
    return hr;
}

	
/////////////////////////////////////////////////////////////////////////////
// GetItemInstallCommand()
//
// Find the installation command and switches of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemInstallCommand(HANDLE_NODE hNodeItem,
                                           INT   iOrder,
                                           BSTR* pbstrCommandType,
                                           BSTR* pbstrCommand,
                                           BSTR* pbstrSwitches,
                                           BSTR* pbstrInfSection)
{
    LOG_Block("GetItemInstallCommand()");

    USES_IU_CONVERSION;

    HRESULT     hr = E_FAIL;

	QuitIfNull(pbstrCommandType);
	QuitIfNull(pbstrCommand);
	QuitIfNull(pbstrSwitches);
	QuitIfNull(pbstrInfSection);

	*pbstrCommandType = NULL;
	*pbstrCommand = NULL;
	*pbstrSwitches = NULL;
	*pbstrInfSection = NULL;

    IXMLDOMNode*    pNodeInstall = NULL;
    IXMLDOMNode*    pNodeCommand = NULL;
    IXMLDOMNode*    pNodeSwitches = NULL;
    BSTR bstrNameCommandTemp = SysAllocString(L"command[@order = ");

    TCHAR szCommand[64];

    hr = StringCchPrintfEx(szCommand, ARRAYSIZE(szCommand), NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%ls\"%d\"]"), bstrNameCommandTemp, iOrder);
    CleanUpIfFailedAndSetHrMsg(hr);

    BSTR bstrNameCommand = SysAllocString(T2OLE(szCommand));

    CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLATION, &pNodeInstall));
    CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeInstall, bstrNameCommand, &pNodeCommand));
    CleanUpIfFailedAndSetHrMsg(GetText(pNodeCommand, pbstrCommand));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeCommand, KEY_COMMANDTYPE, pbstrCommandType));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeCommand, KEY_INFINSTALL, pbstrInfSection));
    if (SUCCEEDED(FindSingleDOMNode(pNodeCommand, KEY_SWITCHES, &pNodeSwitches)))
	{
		CleanUpIfFailedAndSetHrMsg(GetText(pNodeSwitches, pbstrSwitches));
	}

CleanUp:
	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrCommandType);
		SafeSysFreeString(*pbstrCommand);
		SafeSysFreeString(*pbstrSwitches);
		SafeSysFreeString(*pbstrInfSection);
	}
    SafeReleaseNULL(pNodeInstall);
    SafeReleaseNULL(pNodeCommand);
    SafeReleaseNULL(pNodeSwitches);
    SysFreeString(bstrNameCommand);
    SysFreeString(bstrNameCommandTemp);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CloseItem()
//
// Release the item node
/////////////////////////////////////////////////////////////////////////////
void CXmlCatalog::CloseItem(HANDLE_NODE hNodeItem)
{
	SafeCloseHandleNode(hNodeItem);
}


/////////////////////////////////////////////////////////////////////////////
// GetTotalEstimatedSize()
//
// Get the Total Estimated Download Size of all Items based on Codebase Size
HRESULT CXmlCatalog::GetTotalEstimatedSize(LONG *plTotalSize)
{
    LOG_Block("GetTotalEstimatedSize()");

    HRESULT hr = E_FAIL;
    BSTR bstrCodebaseSize = NULL;
    IXMLDOMNodeList *pItemList = NULL;
    IXMLDOMNodeList *pCodebaseList = NULL;
    IXMLDOMNode *pNodeItem = NULL;
    IXMLDOMNode *pNodeInstall = NULL;
    IXMLDOMNode *pNodeCodebase = NULL;
    IXMLDOMNode *pNodeSize = NULL;
    LONG lItemCount = 0;
    LONG lCodebaseCount = 0;
    LONG lTotalSize = 0;

    QuitIfNull(plTotalSize);
    *plTotalSize = 0;

	IXMLDOMNode	*pParentNode = NULL;
	CleanUpIfFailedAndSetHrMsg(m_pDocCatalog->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));
	CleanUpIfFailedAndSetHrMsg(pParentNode->selectNodes(KEY_ITEM_SEARCH, &pItemList));
    if (NULL == pItemList) goto CleanUp;

    CleanUpIfFailedAndSetHrMsg(pItemList->get_length(&lItemCount));
    if (0 == lItemCount) goto CleanUp; // no items

    // Loop through each Item
    CleanUpIfFailedAndSetHrMsg(pItemList->nextNode(&pNodeItem));
    while (NULL != pNodeItem)
    {
        // Get Installation Element
        CleanUpIfFailedAndSetHrMsg(pNodeItem->selectSingleNode(KEY_INSTALLATION, &pNodeInstall));
        if (NULL == pNodeInstall) goto CleanUp;

        CleanUpIfFailedAndSetHrMsg(pNodeInstall->selectNodes(KEY_CODEBASE, &pCodebaseList));
        if (NULL == pCodebaseList) goto CleanUp;

        CleanUpIfFailedAndSetHrMsg(pCodebaseList->get_length(&lCodebaseCount));
        if (0 == lCodebaseCount) goto CleanUp; // must be at least 1 cab

        // Loop through each Codebase Getting the Size for Each one
        CleanUpIfFailedAndSetHrMsg(pCodebaseList->nextNode(&pNodeCodebase));
        while (NULL != pNodeCodebase)
        {
            // Get the Size Element
            CleanUpIfFailedAndSetHrMsg(pNodeCodebase->selectSingleNode(KEY_SIZE, &pNodeSize));
            if (NULL != pNodeSize)
            {
                pNodeSize->get_text(&bstrCodebaseSize);
                if (NULL != bstrCodebaseSize)
                {
                    // Add this Codebase's size to the total download size
                    lTotalSize += (DWORD) MyBSTR2L(bstrCodebaseSize);
                    SafeSysFreeString(bstrCodebaseSize);
                }
            }
            SafeReleaseNULL(pNodeSize);
            SafeReleaseNULL(pNodeCodebase);
            CleanUpIfFailedAndSetHrMsg(pCodebaseList->nextNode(&pNodeCodebase));
        }
        SafeReleaseNULL(pCodebaseList);
        SafeReleaseNULL(pNodeInstall);
        SafeReleaseNULL(pNodeItem);
        CleanUpIfFailedAndSetHrMsg(pItemList->nextNode(&pNodeItem)); // get the next Item Node
    }

    // Update the Total Size after completing.. if we fail anywhere through here
    // we'll return 0.
    *plTotalSize = lTotalSize;

CleanUp:
	SafeReleaseNULL(pParentNode);
    SafeReleaseNULL(pItemList);
    SafeReleaseNULL(pCodebaseList);
    SafeReleaseNULL(pNodeItem);
    SafeReleaseNULL(pNodeInstall);
    SafeReleaseNULL(pNodeCodebase);
    SafeReleaseNULL(pNodeSize);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindItemByIdentity()
//
// Input:
// pNodeIdentity - a pointer to an Identity Node to match against an Items
//                 identity in the Catalog. We will search through each item
//                 till we find a match with the supplied identity                 
//                 
// Output:
// phNodeItem    - Handle of the found Item
//                 
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::FindItemByIdentity(IXMLDOMNode* pNodeIdentity, HANDLE_NODE* phNodeItem)
{
    LOG_Block("FindItemByIdentity()");

    HRESULT hr = E_FAIL;

    IXMLDOMNode*    pNodeIdentityDes = NULL;
    
    *phNodeItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hNodeItem = HANDLE_NODE_INVALID;
    HANDLE_NODELIST hNodeList = HANDLE_NODELIST_INVALID;

    hNodeList = FindFirstDOMNode(m_pDocCatalog, KEY_ITEM_SEARCH, &hNodeItem);
    if (HANDLE_NODELIST_INVALID != hNodeList)
    {
        CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
        if (AreNodesEqual(pNodeIdentityDes, pNodeIdentity))
        {
            *phNodeItem = hNodeItem;
            goto CleanUp;
        }

        SafeReleaseNULL(pNodeIdentityDes);
        SafeReleaseNULL(m_ppNodeArray[hNodeItem]);

        while (SUCCEEDED(FindNextDOMNode(hNodeList, &hNodeItem)))
        {
            CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
            if (AreNodesEqual(pNodeIdentityDes, pNodeIdentity))
            {
                *phNodeItem = hNodeItem;
                goto CleanUp;
            }
            SafeReleaseNULL(pNodeIdentityDes);
            SafeReleaseNULL(m_ppNodeArray[hNodeItem]);
        }
    }

CleanUp:
    CloseItemList(hNodeList);
    SafeReleaseNULL(pNodeIdentityDes);

    if (HANDLE_NODE_INVALID == *phNodeItem)
    {
        LOG_Error(_T("Can't find the matching Item Node in Catalog"));
        hr = E_FAIL;
    }
    return hr;
}


/*
/////////////////////////////////////////////////////////////////////////////
// IfSameIdentity()
//
// Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlCatalog::IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2)
{
    LOG_Block("IfSameIdentity()");

    BOOL fResult = FALSE;
    BSTR bstrNameGUID = SysAllocString(L"guid");
    BSTR bstrNameIDName = SysAllocString(L"name");
    BSTR bstrNameIDPublisherName = SysAllocString(L"publisherName");
    BSTR bstrNameType = SysAllocString(L"type");
    BSTR bstrNameVersion = SysAllocString(L"version");
    BSTR bstrNameLanguage = SysAllocString(L"language");

    //
    // compare <guid> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameGUID))
    {
        goto CleanUp;
    }

    //
    // compare <publisherName> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameIDPublisherName))
    {
        goto CleanUp;
    }

    //
    // compare "name" attribute, this is a required attribute
    //
    if (!IfHasSameAttribute(pNodeIdentity1, pNodeIdentity2, bstrNameIDName, FALSE))
    {
        goto CleanUp;
    }

    //
    // compare <type> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameType))
    {
        goto CleanUp;
    }

    //
    // compare <version> node, which really means "file version" here
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameVersion))
    {
        goto CleanUp;
    }

    //
    // compare <language> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameLanguage))
    {
        goto CleanUp;
    }

    fResult = TRUE;

CleanUp:
    SysFreeString(bstrNameGUID);
    SysFreeString(bstrNameIDName);
    SysFreeString(bstrNameIDPublisherName);
    SysFreeString(bstrNameType);
    SysFreeString(bstrNameVersion);
    SysFreeString(bstrNameLanguage);
    if (!fResult)
    {
        LOG_XML(_T("Different <identity>\'s found."));
    }
    else
    {
        LOG_XML(_T("Same <identity>\'s found."));
    }
    return fResult;
}
*/

/////////////////////////////////////////////////////////////////////////////
// GetItemLanguage()
//
// Get the Language Entity from the Item Identity
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemLanguage(HANDLE_NODE hNodeItem, BSTR* pbstrLanguage)
{
    HRESULT hr = S_OK;
    if (HANDLE_NODE_INVALID == hNodeItem || NULL == pbstrLanguage)
    {
        return E_INVALIDARG;
    }

    IXMLDOMNode *pNodeIdentity = NULL;
    IXMLDOMNode *pNodeLanguage = NULL;
    
    hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentity);
    if (FAILED(hr))
        goto CleanUp;

    hr = FindSingleDOMNode(pNodeIdentity, KEY_LANGUAGE, &pNodeLanguage);
    if (FAILED(hr))
        goto CleanUp;

    hr = GetText(pNodeLanguage, pbstrLanguage);
    if (FAILED(hr))
        goto CleanUp;

CleanUp:
    SafeReleaseNULL(pNodeLanguage);
    SafeReleaseNULL(pNodeIdentity);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetCorpItemPlatformStr()
//
// Get the Simplified Platform String for an Item (uses the first available platform element)
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetCorpItemPlatformStr(HANDLE_NODE hNodeItem, BSTR* pbstrPlatformStr)
{
    HRESULT hr = S_OK;
    if (HANDLE_NODE_INVALID == hNodeItem || NULL == pbstrPlatformStr)
    {
        return E_INVALIDARG;
    }

    IXMLDOMNode *pNodePlatform = NULL;
    IXMLDOMNode *pNodePlatformArchitecture = NULL;
    IXMLDOMNode *pNodePlatformVersion = NULL;
    BSTR bstrPlatformName = NULL;
    BSTR bstrArchitecture = NULL;
    int iMajor = 0;
    int iMinor = 0;


    hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatform);
    if (FAILED(hr))
        goto CleanUp;

    hr = GetAttribute(pNodePlatform, KEY_NAME, &bstrPlatformName);
    if (FAILED(hr))
        goto CleanUp;

    hr = FindSingleDOMNode(pNodePlatform, KEY_PROCESSORARCHITECTURE, &pNodePlatformArchitecture);
    if (FAILED(hr))
        goto CleanUp;

    hr = FindSingleDOMNode(pNodePlatform, KEY_VERSION, &pNodePlatformVersion);
    if (FAILED(hr))
        goto CleanUp;

	if (NULL != bstrPlatformName && 0 != SysStringLen(bstrPlatformName))
    {
		if (CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
			bstrPlatformName, -1, L"VER_PLATFORM_WIN32_NT", -1))
		{
			// this is an NT platform
			hr = GetAttribute(pNodePlatformVersion, KEY_MAJOR, &iMajor);
			if (FAILED(hr))
				goto CleanUp;

			if (4 == iMajor)
			{
				// WinNT4
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_NT4);
			}
			else // 5 == iMajor
			{
				hr = GetAttribute(pNodePlatformVersion, KEY_MINOR, &iMinor);
				if (FAILED(hr))
					goto CleanUp;

				if (iMinor > 0)
				{
					hr = GetText(pNodePlatformArchitecture, &bstrArchitecture);
					if (FAILED(hr))
						goto CleanUp;
					// whistler
					if (CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						bstrArchitecture, -1, L"x86", -1))
					{
						// x86WinXP
						*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_X86WHI);
					}
					else
					{
						// ia64WinXP
						*pbstrPlatformStr = SysAllocString(CORP_PLATFROM_DIR_IA64WHI);
					}
				}
				else
				{
					// x86Win2k
					*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_NT5);
				}
			}
		}
		else // VER_PLATFORM_WIN32_WINDOWS
		{
			// this is a Win9x platform
			hr = GetAttribute(pNodePlatformVersion, KEY_MINOR, &iMinor);
			if (FAILED(hr))
				goto CleanUp;

			if (iMinor >= 90)
			{
				// x86WinME
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_WINME);
			}
			else if (iMinor > 0 && iMinor < 90)
			{
				// x86Win98
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_W98);
			}
			else
			{
				// x86Win95
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_W95);
			}
		}
	}

CleanUp:
    SysFreeString(bstrPlatformName);
    SysFreeString(bstrArchitecture);
    SafeReleaseNULL(pNodePlatformVersion);
    SafeReleaseNULL(pNodePlatformArchitecture);
    SafeReleaseNULL(pNodePlatform);
    return hr;
}




/////////////////////////////////////////////////////////////////////////////
// CXmlItems

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for Items; this is for write only
/////////////////////////////////////////////////////////////////////////////
CXmlItems::CXmlItems()
 : m_pDocItems(NULL),
   m_pNodeItems(NULL)
{
    LOG_Block("CXmlItems()");

	Init();
}


/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for Items; take TRUE for read, FALSE for write
/////////////////////////////////////////////////////////////////////////////
CXmlItems::CXmlItems(BOOL fRead)
 : m_pDocItems(NULL),
   m_pNodeItems(NULL)
{
    LOG_Block("CXmlItems(BOOL fRead)");

	//
	// for writing Items only
	//
	if (!fRead)
	{
		Init();
	}
}


/////////////////////////////////////////////////////////////////////////////
//
// Initialize XML DOC node pointers before writing
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::Init()
{
	LOG_Block("Init()");

 	HRESULT hr = CoCreateInstance(CLSID_DOMDocument,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IXMLDOMDocument,
								  (void **) &m_pDocItems);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		IXMLDOMNode*	pNodeXML = NULL;
		BSTR bstrNameSpaceSchema = NULL;

		//
		// create the <?xml version="1.0"?> node
		//
		pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
		if (NULL == pNodeXML) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

		//
		// process the iuident.txt to find the Items schema path
		//
		TCHAR szIUDir[MAX_PATH];
		TCHAR szIdentFile[MAX_PATH];
		LPTSTR pszItemsSchema = NULL;
		LPTSTR pszNameSpaceSchema = NULL;

		pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszItemsSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
		pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszNameSpaceSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
	
		GetIndustryUpdateDirectory(szIUDir);
		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		GetPrivateProfileString(IDENT_IUSCHEMA,
								IDENT_IUSCHEMA_ITEMS,
								_T(""),
								pszItemsSchema,
								INTERNET_MAX_URL_LENGTH,
								szIdentFile);

		if ('\0' == pszItemsSchema[0])
		{
			// no Items schema path specified in iuident.txt
			LOG_Error(_T("No schema path specified in iuident.txt for Items"));
			goto CleanUp;
		}
		
		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("x-schema:%s"), pszItemsSchema);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

		//
		// create the <items> node with the path of the schema
		//
		m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
		if (NULL == m_pNodeItems) goto CleanUp;
		
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));

CleanUp:
		SafeReleaseNULL(pNodeXML);
		SysFreeString(bstrNameSpaceSchema);
		SafeHeapFree(pszItemsSchema);
		SafeHeapFree(pszNameSpaceSchema);
	}
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for Items
/////////////////////////////////////////////////////////////////////////////
CXmlItems::~CXmlItems()
{
	SafeReleaseNULL(m_pNodeItems);
	SafeReleaseNULL(m_pDocItems);
}


/////////////////////////////////////////////////////////////////////////////
// Clear()
//
// Reset IXMLDOMDocument* for Items
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::Clear()
{
	SafeReleaseNULL(m_pNodeItems);
	SafeReleaseNULL(m_pDocItems);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocument()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::LoadXMLDocument(BSTR bstrXml)
{
	LOG_Block("LoadXMLDocument()");
	SafeReleaseNULL(m_pDocItems);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocItems);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocumentFile()
//
// Load an XML Document from the specified file
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::LoadXMLDocumentFile(BSTR bstrFilePath)
{
	LOG_Block("LoadXMLDocumentFile()");
	SafeReleaseNULL(m_pDocItems);
	HRESULT hr = LoadDocument(bstrFilePath, &m_pDocItems);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveXMLDocument()
//
// Save an XML Document to the specified location
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::SaveXMLDocument(BSTR bstrFilePath)
{
	LOG_Block("SaveXMLDocument()");
	HRESULT hr = SaveDocument(m_pDocItems, bstrFilePath);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddGlobalErrorCodeIfNoItems()
//
// Add the errorCode attribute for <items> if there's no <itemStatus> child node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlItems::AddGlobalErrorCodeIfNoItems(DWORD dwErrorCode)
{
	LOG_Block("AddGlobalErrorCodeIfNoItems()");

	HRESULT			hr = S_OK;
	IXMLDOMNode*	pNodeItem = NULL;
	HANDLE_NODE		hNodeItemStatus = HANDLE_NODE_INVALID;

	FindFirstDOMNode(m_pDocItems, KEY_ITEM_ITEMSTATUS, &hNodeItemStatus);
	if (HANDLE_NODE_INVALID == hNodeItemStatus)
	{
		//
		// set the "errorCode" attribute
		//
		FindFirstDOMNode(m_pDocItems, KEY_ITEMS, &pNodeItem);
		if (NULL != pNodeItem)
		{
			hr = SetAttribute(pNodeItem, KEY_ERRORCODE, dwErrorCode);
		}
	}
	
	SafeReleaseNULL(pNodeItem);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetFirstItem()
//
// Find the first item in Items xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlItems::GetFirstItem(HANDLE_NODE* phNodeItem)
{
	LOG_Block("GetFirstItem()");

	HANDLE_NODELIST hNodeListItem = FindFirstDOMNode(m_pDocItems, KEY_ITEM_ITEMSTATUS, phNodeItem);
	
	return hNodeListItem;
}

	
/////////////////////////////////////////////////////////////////////////////
// GetNextItem()
//
// Find the next item in Items xml doc
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetNextItem()");

	return FindNextDOMNode(hNodeListItem, phNodeItem);
}

	
/////////////////////////////////////////////////////////////////////////////
// CloseItemList()
//
// Release the item nodelist
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::CloseItemList(HANDLE_NODELIST hNodeListItem)
{
	SafeFindCloseHandle(hNodeListItem);
}


/////////////////////////////////////////////////////////////////////////////
// GetItemDownloadPath()
//
// Retrieve the download path of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetItemDownloadPath(HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath)
{
    LOG_Block("GetItemDownloadPath()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDownloadPath = NULL;

	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_DOWNLOADPATH, &pNodeDownloadPath));
	CleanUpIfFailedAndSetHrMsg(GetText(pNodeDownloadPath, pbstrDownloadPath));

CleanUp:
	SafeReleaseNULL(pNodeDownloadPath);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemDownloadPath()
//
// Retrieve the download path of the given item in catalog
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetItemDownloadPath(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath)
{
    LOG_Block("GetItemDownloadPath() for an item in catalog");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeItem = NULL;
	IXMLDOMNode*	pNodeDownloadPath = NULL;

	HANDLE_NODE	hNodeItemsItem = HANDLE_NODE_INVALID;

	if (NULL != (pNodeItem = pCatalog->GetDOMNodebyHandle(hNodeItem)))
	{
		hr = FindItem(pNodeItem, &hNodeItemsItem, TRUE);
	}
	else
	{
		LOG_Error(_T("Can't retrieve valid item node from catalog xml"));
		hr = E_FAIL;
		goto CleanUp;
	}
	
	if (FAILED(hr) || HANDLE_NODE_INVALID == hNodeItemsItem)
	{
		LOG_Error(_T("Can't find item from Items xml"));
		goto CleanUp;
	}
	
	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItemsItem], KEY_DOWNLOADPATH, &pNodeDownloadPath));
	CleanUpIfFailedAndSetHrMsg(GetText(pNodeDownloadPath, pbstrDownloadPath));

CleanUp:
	SafeReleaseNULL(pNodeDownloadPath);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CloseItem()
//
// Release the item node
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::CloseItem(HANDLE_NODE hNodeItem)
{
	SafeCloseHandleNode(hNodeItem);
}


/////////////////////////////////////////////////////////////////////////////
// FindItem()
//
// Input:
// pNodeItem	- the <itemStatus> node of the install items xml; we need
//                to find the corresponding <itemStatus> node in the existing 
//                items xml with the identical <identity>, <platform> and 
//                <client> nodes.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in the existing items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::FindItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem, BOOL fIdentityOnly /*= FALSE*/)
{
	LOG_Block("FindItem()");

	HRESULT		hr1, hr2, hr = E_FAIL;

	IXMLDOMNode*	pNodeIdentitySrc = NULL;
	IXMLDOMNode*	pNodeIdentityDes = NULL;
	IXMLDOMNode*	pNodePlatformSrc = NULL;
	IXMLDOMNode*	pNodePlatformDes = NULL;
	IXMLDOMNode*	pNodeClientSrc = NULL;
	IXMLDOMNode*	pNodeClientDes = NULL;

	*phNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODE	hNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODELIST	hNodeList = HANDLE_NODELIST_INVALID;

	hNodeList = FindFirstDOMNode(m_pDocItems, KEY_ITEM_ITEMSTATUS, &hNodeItem);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
		CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_IDENTITY, &pNodeIdentitySrc));
		if (AreNodesEqual(pNodeIdentityDes, pNodeIdentitySrc))
		{
			if (fIdentityOnly)
			{
				//
				// we now found the match
				//
				*phNodeItem = hNodeItem;
				goto CleanUp;
			}
			else
			{
				hr1 = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatformDes);
				hr2 = FindSingleDOMNode(pNodeItem, KEY_PLATFORM, &pNodePlatformSrc);
				if ((FAILED(hr1) && FAILED(hr2)) ||
					(SUCCEEDED(hr1) && SUCCEEDED(hr2) && AreNodesEqual(pNodePlatformDes, pNodePlatformSrc)))
				{
					CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_CLIENT, &pNodeClientDes));
					CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClientSrc));
					if (AreNodesEqual(pNodeClientDes, pNodeClientSrc))
					{
						//
						// we now found the match
						//
						*phNodeItem = hNodeItem;
						goto CleanUp;
					}
				}
			}
		}
		SafeReleaseNULL(pNodeClientDes);
		SafeReleaseNULL(pNodeClientSrc);
		SafeReleaseNULL(pNodePlatformDes);
		SafeReleaseNULL(pNodePlatformSrc);
		SafeReleaseNULL(pNodeIdentityDes);
		SafeReleaseNULL(pNodeIdentitySrc);
		SafeReleaseNULL(m_ppNodeArray[hNodeItem]);
		while (SUCCEEDED(FindNextDOMNode(hNodeList, &hNodeItem)))
		{
			CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
			CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_IDENTITY, &pNodeIdentitySrc));
			if (AreNodesEqual(pNodeIdentityDes, pNodeIdentitySrc))
			{
				if (fIdentityOnly)
				{
					//
					// we now found the match
					//
					*phNodeItem = hNodeItem;
					goto CleanUp;
				}
				else
				{
					hr1 = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatformDes);
					hr2 = FindSingleDOMNode(pNodeItem, KEY_PLATFORM, &pNodePlatformSrc);
					if ((FAILED(hr1) && FAILED(hr2)) ||
						(SUCCEEDED(hr1) && SUCCEEDED(hr2) && AreNodesEqual(pNodePlatformDes, pNodePlatformSrc)))
					{
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_CLIENT, &pNodeClientDes));
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClientSrc));
						if (AreNodesEqual(pNodeClientDes, pNodeClientSrc))
						{
							//
							// we now found the match
							//
							*phNodeItem = hNodeItem;
							break;
						}
					}
				}
			}
			SafeReleaseNULL(pNodeClientDes);
			SafeReleaseNULL(pNodeClientSrc);
			SafeReleaseNULL(pNodePlatformDes);
			SafeReleaseNULL(pNodePlatformSrc);
			SafeReleaseNULL(pNodeIdentityDes);
			SafeReleaseNULL(pNodeIdentitySrc);
			SafeReleaseNULL(m_ppNodeArray[hNodeItem]);
		}
	}

CleanUp:
	CloseItemList(hNodeList);
	SafeReleaseNULL(pNodeClientDes);
	SafeReleaseNULL(pNodeClientSrc);
	SafeReleaseNULL(pNodePlatformDes);
	SafeReleaseNULL(pNodePlatformSrc);
	SafeReleaseNULL(pNodeIdentityDes);
	SafeReleaseNULL(pNodeIdentitySrc);
	if (HANDLE_NODE_INVALID == *phNodeItem)
	{
		LOG_Error(_T("Can't find the identical item node in existing Items xml"));
		hr = E_FAIL;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindItem()
//
// Input:
// pCatalog		- the pointer to the CXmlCatalog object
// hNodeItem	- the handle of the <item> node of the catalog xml; we need
//                to find the corresponding <itemStatus> node in the existing 
//                items xml with the identical <identity>, <platform> and 
//                <client> nodes.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::FindItem(CXmlCatalog* pCatalog,
							HANDLE_NODE hNodeItem,
							HANDLE_NODE* phNodeItem)
{
	LOG_Block("FindItem() by handle");

	IXMLDOMNode*	pNode = NULL;

	if (NULL != (pNode = pCatalog->GetDOMNodebyHandle(hNodeItem)))
	{
		return FindItem(pNode, phNodeItem, TRUE);
	}
	LOG_Error(_T("Can't retrieve valid item node from catalog xml"));
	return E_FAIL;
}

	
/*
/////////////////////////////////////////////////////////////////////////////
// IfSameClientInfo()
//
// Return TRUE if the two <client> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlItems::IfSameClientInfo(IXMLDOMNode* pNodeClient1, IXMLDOMNode* pNodeClient2)
{
    LOG_Block("IfSameClientInfo()");

	BSTR bstrText1 = NULL, bstrText2 = NULL;
	BOOL fResult = FALSE;

	GetText(pNodeClient1, &bstrText1);
	GetText(pNodeClient2, &bstrText2);

	if (NULL != bstrText1 && NULL != bstrText2)
	{
		fResult = CompareBSTRsEqual(bstrText1, bstrText2);
	}

	SysFreeString(bstrText1);
	SysFreeString(bstrText2);
	if (!fResult)
	{
		LOG_XML(_T("Different <client>\'s found."));
	}
	else
	{
		LOG_XML(_T("Same <client>\'s found."));
	}
	return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// IfSameIdentity()
//
// Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlItems::IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2)
{
    LOG_Block("IfSameIdentity()");

	BOOL fResult = FALSE;
	BSTR bstrNameGUID = SysAllocString(L"guid");
	BSTR bstrNameIDName = SysAllocString(L"name");
	BSTR bstrNameIDPublisherName = SysAllocString(L"publisherName");
	BSTR bstrNameType = SysAllocString(L"type");
	BSTR bstrNameVersion = SysAllocString(L"version");
	BSTR bstrNameLanguage = SysAllocString(L"language");

	//
	// compare <guid> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameGUID))
	{
		goto CleanUp;
	}

	//
	// compare <publisherName> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameIDPublisherName))
	{
		goto CleanUp;
	}

	//
	// compare "name" attribute, this is a required attribute
	//
	if (!IfHasSameAttribute(pNodeIdentity1, pNodeIdentity2, bstrNameIDName, FALSE))
	{
		goto CleanUp;
	}

	//
	// compare <type> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameType))
	{
		goto CleanUp;
	}

	//
	// compare <version> node, which really means "file version" here
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameVersion))
	{
		goto CleanUp;
	}

	//
	// compare <language> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameLanguage))
	{
		goto CleanUp;
	}

	fResult = TRUE;

CleanUp:
	SysFreeString(bstrNameGUID);
	SysFreeString(bstrNameIDName);
	SysFreeString(bstrNameIDPublisherName);
	SysFreeString(bstrNameType);
	SysFreeString(bstrNameVersion);
	SysFreeString(bstrNameLanguage);
	if (!fResult)
	{
		LOG_XML(_T("Different <identity>\'s found."));
	}
	else
	{
		LOG_XML(_T("Same <identity>\'s found."));
	}
	return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// IfSamePlatform()
//
// Return TRUE if the two <platform> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlItems::IfSamePlatform(IXMLDOMNode* pNodePlatform1, IXMLDOMNode* pNodePlatform2)
{
    LOG_Block("IfSamePlatform()");

	HRESULT		hr1 = S_OK, hr2 = S_OK;
	BSTR		bstrPlatform1 = NULL, bstrPlatform2 = NULL;
	BOOL		fResult = FALSE;

	hr1 = pNodePlatform1->get_xml(&bstrPlatform1);
	hr2 = pNodePlatform2->get_xml(&bstrPlatform2);

	if (FAILED(hr1) || FAILED(hr2) || !CompareBSTRsEqual(bstrPlatform1, bstrPlatform2))
		goto CleanUp;

	fResult = TRUE;

CleanUp:
	SysFreeString(bstrPlatform1);
	SysFreeString(bstrPlatform2);
	return fResult;
}
*/


/////////////////////////////////////////////////////////////////////////////
// MergeItemDownloaded()
//
// Insert items with download history into existing history (insert in front)
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::MergeItemDownloaded(CXmlItems *pHistoryDownload)
{
	LOG_Block("MergeItemDownloaded()");

	HRESULT		hr = S_OK;

	IXMLDOMNode*		pNodeItem = NULL;
	IXMLDOMNode*		pNodeItemNew = NULL;
	IXMLDOMNode*		pNodeItemRef = NULL;
	IXMLDOMNode*		pNodeXML = NULL;
	BSTR bstrNameSpaceSchema = NULL;
	LPTSTR pszItemsSchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	HANDLE_NODE	hNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODELIST	hNodeListItem = HANDLE_NODELIST_INVALID;

	hNodeListItem = pHistoryDownload->GetFirstItem(&hNodeItem);
	if (HANDLE_NODELIST_INVALID != hNodeListItem)
	{
		//
		// if this is the first time writing history
		// (e.g. the log file does not exist yet), do
		// initialization for m_pDocItems here...
		//
		if (NULL == m_pDocItems)
		{

 			hr = CoCreateInstance(CLSID_DOMDocument,
										  NULL,
										  CLSCTX_INPROC_SERVER,
										  IID_IXMLDOMDocument,
										  (void **) &m_pDocItems);
			if (FAILED(hr))
			{
				LOG_ErrorMsg(hr);
			}
			else
			{
				//
				// create the <?xml version="1.0"?> node
				//
				pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
				if (NULL == pNodeXML) goto CleanUp;

				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

				//
				// process the iuident.txt to find the Items schema path
				//
				TCHAR szIUDir[MAX_PATH];
				TCHAR szIdentFile[MAX_PATH];

				pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszItemsSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
				pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszNameSpaceSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
	
				GetIndustryUpdateDirectory(szIUDir);
        		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}

				GetPrivateProfileString(IDENT_IUSCHEMA,
										IDENT_IUSCHEMA_ITEMS,
										_T(""),
										pszItemsSchema,
										INTERNET_MAX_URL_LENGTH,
										szIdentFile);

				if ('\0' == pszItemsSchema[0])
				{
					// no Items schema path specified in iuident.txt
					LOG_Error(_T("No schema path specified in iuident.txt for Items"));
					goto CleanUp;
				}
				
        		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
        		                       _T("x-schema:%s"), pszItemsSchema);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}
				
				bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

				//
				// create the <items> node with the path of the schema
				//
				m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
				if (NULL == m_pNodeItems) goto CleanUp;
				
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));
			}
		}
		else
		{
		    SafeReleaseNULL(m_pNodeItems);
			FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &m_pNodeItems);
		}

		if (NULL != m_pNodeItems)
		{
			if (NULL != (pNodeItem = pHistoryDownload->GetDOMNodebyHandle(hNodeItem)))
			{
				CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
				CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
//				SafeReleaseNULL(pNodeItem);
				SafeReleaseNULL(pNodeItemNew);
				SafeReleaseNULL(pNodeItemRef);
			}
			while (SUCCEEDED(pHistoryDownload->GetNextItem(hNodeListItem, &hNodeItem)))
			{
				if (NULL != (pNodeItem = pHistoryDownload->GetDOMNodebyHandle(hNodeItem)))
				{
					CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
					CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
//					SafeReleaseNULL(pNodeItem);
					SafeReleaseNULL(pNodeItemNew);
					SafeReleaseNULL(pNodeItemRef);
				}
			}
		}
	}

CleanUp:
	pHistoryDownload->CloseItemList(hNodeListItem);
//	SafeReleaseNULL(pNodeItem);
	SafeReleaseNULL(pNodeItemNew);
	SafeReleaseNULL(pNodeItemRef);
	SafeReleaseNULL(pNodeXML);
	SysFreeString(bstrNameSpaceSchema);
	SafeHeapFree(pszItemsSchema);
	SafeHeapFree(pszNameSpaceSchema);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// UpdateItemInstalled()
//
// Update items with installation history in existing history
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::UpdateItemInstalled(CXmlItems *pHistoryInstall)
{
	LOG_Block("UpdateItemInstalled()");

	USES_IU_CONVERSION;

	HRESULT		hr = S_OK;

	IXMLDOMNode*		pNodeItem = NULL;
	IXMLDOMNode*		pNodeItemNew = NULL;
	IXMLDOMNode*		pNodeItemRef = NULL;
	IXMLDOMNode*		pNodeItemExist = NULL;
	IXMLDOMNode*		pNodeInstall = NULL;
	IXMLDOMNode*		pNodeInstallExist = NULL;
	IXMLDOMNode*		pNodeInstallNew = NULL;
	IXMLDOMNode*		pNodeInstallOut = NULL;
	IXMLDOMNode*		pNodeXML = NULL;
	BSTR bstrInstallStatusExist = NULL;
	BSTR bstrInstallStatusNew = NULL;
	BSTR bstrTimeStamp = NULL;
	BSTR bstrNameSpaceSchema = NULL;
	LPTSTR pszItemsSchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	HANDLE_NODE	hNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODE	hNodeItemExist = HANDLE_NODE_INVALID;
	HANDLE_NODELIST	hNodeListItem = HANDLE_NODELIST_INVALID;

	hNodeListItem = pHistoryInstall->GetFirstItem(&hNodeItem);
	if (HANDLE_NODELIST_INVALID != hNodeListItem)
	{
		//
		// if this is the first time writing history
		// (e.g. the log file does not exist yet), do
		// initialization for m_pDocItems here...
		//
		if (NULL == m_pDocItems)
		{

 			hr = CoCreateInstance(CLSID_DOMDocument,
										  NULL,
										  CLSCTX_INPROC_SERVER,
										  IID_IXMLDOMDocument,
										  (void **) &m_pDocItems);
			if (FAILED(hr))
			{
				LOG_ErrorMsg(hr);
			}
			else
			{
				//
				// create the <?xml version="1.0"?> node
				//
				pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
				if (NULL == pNodeXML) goto CleanUp;

				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

				//
				// process the iuident.txt to find the Items schema path
				//
				TCHAR szIUDir[MAX_PATH];
				TCHAR szIdentFile[MAX_PATH];

				pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszItemsSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
				pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszNameSpaceSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
	
				GetIndustryUpdateDirectory(szIUDir);
        		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}

				GetPrivateProfileString(IDENT_IUSCHEMA,
										IDENT_IUSCHEMA_ITEMS,
										_T(""),
										pszItemsSchema,
										INTERNET_MAX_URL_LENGTH,
										szIdentFile);

				if ('\0' == pszItemsSchema[0])
				{
					// no Items schema path specified in iuident.txt
					LOG_Error(_T("No schema path specified in iuident.txt for Items"));
					goto CleanUp;
				}

        		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
        		                       _T("x-schema:%s"), pszItemsSchema);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}
				
				bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

				//
				// create the <items> node with the path of the schema
				//
				m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
				if (NULL == m_pNodeItems) goto CleanUp;
				
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));
			}
		}
		else
		{
		    SafeReleaseNULL(m_pNodeItems);
			CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &m_pNodeItems));
		}

		if (NULL != (pNodeItem = pHistoryInstall->GetDOMNodebyHandle(hNodeItem)))
		{
			if (SUCCEEDED(FindItem(pNodeItem, &hNodeItemExist)))
			{
				//
				// successfully found the match
				//
				if (NULL != (pNodeItemExist = GetDOMNodebyHandle(hNodeItemExist)))
				{
					CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_INSTALLSTATUS, &pNodeInstall));			
					FindSingleDOMNode(pNodeItemExist, KEY_INSTALLSTATUS, &pNodeInstallExist);
					if (NULL != pNodeInstallExist)
					{
						//
						// found the item already with installStatus; now find out if we want to update
						// or append the installStatus
						//
						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstallExist, KEY_VALUE, &bstrInstallStatusExist));
						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_VALUE, &bstrInstallStatusNew));		
						if (CSTR_EQUAL == WUCompareStringI(OLE2T(bstrInstallStatusExist), _T("IN_PROGRESS")) &&
							CSTR_EQUAL != WUCompareStringI(OLE2T(bstrInstallStatusNew), _T("IN_PROGRESS")))
						{
							//
							// this entry is an exclusive item with "IN_PROGRESS" installStatus and we found its 
							// updated installStatus, we need to update its installStatus
							//
							LOG_Out(_T("Update the exclusive item's installStatus"));
							CleanUpIfFailedAndSetHrMsg(pNodeItemExist->removeChild(pNodeInstallExist, &pNodeInstallOut));
							CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
							CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
							CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
							SafeSysFreeString(bstrTimeStamp);
						}
						else
						{							
							//
							// in this case we append a copy of this item with the new installStatus, since
							// this comes from a separate install operation
							//
							LOG_Out(_T("This item was installed again, add an entry of this item into history \
										for the new installation status only."));
							CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
							CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
							CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
						}
						SafeSysFreeString(bstrInstallStatusExist);
						SafeSysFreeString(bstrInstallStatusNew);
					}
					else
					{
						//
						// found the item without installStatus, update the entry with the installStatus
						// and update the timeStamp with its installation timeStamp
						//
						CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
						CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
						CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
						SafeSysFreeString(bstrTimeStamp);
					}
				}
			}
			else
			{
				//
				// no match found, this item was not downloaded through IU,
				// append this item with the install status
				//
				LOG_Out(_T("Can't find the downloaded item in existing history. This item was not downloaded \
							through IU. Add the item into history for installation status only."));
				CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
				CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
			}
//			SafeReleaseNULL(pNodeItem);
//			SafeReleaseNULL(pNodeItemExist);
			SafeReleaseNULL(pNodeItemNew);
			SafeReleaseNULL(pNodeItemRef);
			SafeReleaseNULL(pNodeInstall);
			SafeReleaseNULL(pNodeInstallExist);
			SafeReleaseNULL(pNodeInstallNew);
			SafeReleaseNULL(pNodeInstallOut);
		}
		while (SUCCEEDED(pHistoryInstall->GetNextItem(hNodeListItem, &hNodeItem)))
		{
			if (NULL != (pNodeItem = pHistoryInstall->GetDOMNodebyHandle(hNodeItem)))
			{
				if (SUCCEEDED(FindItem(pNodeItem, &hNodeItemExist)))
				{
					//
					// successfully found the match
					//
					if (NULL != (pNodeItemExist = GetDOMNodebyHandle(hNodeItemExist)))
					{
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_INSTALLSTATUS, &pNodeInstall));			
						FindSingleDOMNode(pNodeItemExist, KEY_INSTALLSTATUS, &pNodeInstallExist);
						if (NULL != pNodeInstallExist)
						{
							//
							// found the item already with installStatus; now find out if we want to update
							// or append the installStatus
							//
							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstallExist, KEY_VALUE, &bstrInstallStatusExist));
							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_VALUE, &bstrInstallStatusNew));
							if (CSTR_EQUAL == WUCompareStringI(OLE2T(bstrInstallStatusExist), _T("IN_PROGRESS")) &&
								CSTR_EQUAL != WUCompareStringI(OLE2T(bstrInstallStatusNew), _T("IN_PROGRESS")))
							{
								//
								// this entry is an exclusive item with "IN_PROGRESS" installStatus and we found its 
								// updated installStatus, we need to update its installStatus
								//
								LOG_Out(_T("Update the exclusive item's installStatus"));
								CleanUpIfFailedAndSetHrMsg(pNodeItemExist->removeChild(pNodeInstallExist, &pNodeInstallOut));
								CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
								CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

								CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
								CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
								SafeSysFreeString(bstrTimeStamp);
							}
							else
							{							
								//
								// in this case we append a copy of this item with the new installStatus, since
								// this comes from a separate install operation
								//
								LOG_Out(_T("This item was installed again, add an entry of this item into history \
											for the new installation status only."));
								CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
								CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
								CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
							}
							SafeSysFreeString(bstrInstallStatusExist);
							SafeSysFreeString(bstrInstallStatusNew);
						}
						else
						{
							//
							// found the item without installStatus, update the entry with the installStatus
							// and update the timeStamp with its installation timeStamp
							//
							CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
							CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
							CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
							SafeSysFreeString(bstrTimeStamp);
						}
					}
				}
				else
				{
					//
					// no match found, this item was not downloaded through IU,
					// append this item with the install status
					//
					LOG_Out(_T("Can't find the downloaded item in existing history. This item was not downloaded \
								through IU. Add the item into history for installation status only."));
					CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
					CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
				}
//				SafeReleaseNULL(pNodeItem);
//				SafeReleaseNULL(pNodeItemExist);
				SafeReleaseNULL(pNodeItemNew);
				SafeReleaseNULL(pNodeItemRef);
				SafeReleaseNULL(pNodeInstall);
				SafeReleaseNULL(pNodeInstallExist);
				SafeReleaseNULL(pNodeInstallNew);
				SafeReleaseNULL(pNodeInstallOut);
			}
		}
	}

CleanUp:
	pHistoryInstall->CloseItemList(hNodeListItem);
//	SafeReleaseNULL(pNodeItem);
//	SafeReleaseNULL(pNodeItemExist);
	SafeReleaseNULL(pNodeItemNew);
	SafeReleaseNULL(pNodeItemRef);
	SafeReleaseNULL(pNodeInstall);
	SafeReleaseNULL(pNodeInstallExist);
	SafeReleaseNULL(pNodeInstallNew);
	SafeReleaseNULL(pNodeInstallOut);
	SafeReleaseNULL(pNodeXML);
	SysFreeString(bstrInstallStatusExist);
	SysFreeString(bstrInstallStatusNew);
	SysFreeString(bstrTimeStamp);
	SysFreeString(bstrNameSpaceSchema);
	SafeHeapFree(pszItemsSchema);
	SafeHeapFree(pszNameSpaceSchema);
	return hr;
}

	
/////////////////////////////////////////////////////////////////////////////
// UpdateItemInstallStatus()
//
// Update the install status of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::UpdateItemInstallStatus(HANDLE_NODE hNodeItem,
											 BSTR bstrValue,
											 INT iNeedsReboot /*= -1*/,
											 DWORD dwErrorCode /*= 0*/)
{
	LOG_Block("UpdateItemInstallStatus()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeInstallStatus = NULL;

	//
	// get the <installStatus> node
	//
	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLSTATUS, &pNodeInstallStatus));

	//
	// set the "value" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_VALUE, bstrValue));

	//
	// set the "needsReboot" attribute
	//
	if (-1 != iNeedsReboot)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_NEEDSREBOOT, iNeedsReboot));
	}

	//
	// set the "errorCode" attribute
	//
	if (0 != dwErrorCode)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_ERRORCODE, dwErrorCode));
	}

CleanUp:
	SafeReleaseNULL(pNodeInstallStatus);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddItem()
//
// Input:
// pNodeItem	- the <item> node of the catalog xml; we need to read
//				  <identity> node, <description> node and <platform> nodes
//                from it and write to the items xml.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem)
{
	LOG_Block("AddItem()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeIndentity = NULL;
	IXMLDOMNode*	pNodeIndentityNew = NULL;
	IXMLDOMNode*	pNodeDescription = NULL;
	IXMLDOMNode*	pNodeDescriptionNew = NULL;
	IXMLDOMNode*	pNodePlatform = NULL;
	IXMLDOMNode*	pNodePlatformNew = NULL;

	HANDLE_NODELIST	hNodeList = HANDLE_NODELIST_INVALID;

	*phNodeItem = CreateDOMNodeWithHandle(m_pDocItems, NODE_ELEMENT, KEY_ITEMSTATUS);
	if (HANDLE_NODE_INVALID == *phNodeItem) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, m_ppNodeArray[*phNodeItem]));

	hNodeList = FindFirstDOMNode(pNodeItem, KEY_IDENTITY, &pNodeIndentity);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeFindCloseHandle(hNodeList);
		CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeIndentity, m_pDocItems, &pNodeIndentityNew));
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodeIndentityNew));
	}

	hNodeList = FindFirstDOMNode(pNodeItem, KEY_DESCRIPTION, &pNodeDescription);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeFindCloseHandle(hNodeList);
		CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeDescription, m_pDocItems, &pNodeDescriptionNew));
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodeDescriptionNew));
	}

	hNodeList = FindFirstDOMNode(pNodeItem, KEY_PLATFORM, &pNodePlatform);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(CopyNode(pNodePlatform, m_pDocItems, &pNodePlatformNew));
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodePlatformNew));
		SafeReleaseNULL(pNodePlatform);
		SafeReleaseNULL(pNodePlatformNew);
		while (SUCCEEDED(FindNextDOMNode(hNodeList, &pNodePlatform)))
		{
			CleanUpIfFailedAndSetHrMsg(CopyNode(pNodePlatform, m_pDocItems, &pNodePlatformNew));
			CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodePlatformNew));
			SafeReleaseNULL(pNodePlatform);
			SafeReleaseNULL(pNodePlatformNew);
		}
	}

CleanUp:
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeFindCloseHandle(hNodeList);
	}
	SafeReleaseNULL(pNodeIndentity);
	SafeReleaseNULL(pNodeIndentityNew);
	SafeReleaseNULL(pNodeDescription);
	SafeReleaseNULL(pNodeDescriptionNew);
	SafeReleaseNULL(pNodePlatform);
	SafeReleaseNULL(pNodePlatformNew);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddItem()
//
// Input:
// pCatalog		- the pointer to the CXmlCatalog object
// hNodeItem	- the handle of the <item> node of the catalog xml; we need
//				  to read <identity> node, <description> node and <platform>
//                nodes from it and write to the items xml.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddItem(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem)
{
	LOG_Block("AddItem() by handle");

	IXMLDOMNode*	pNode = NULL;

	if (NULL != (pNode = pCatalog->GetDOMNodebyHandle(hNodeItem)))
	{
		return AddItem(pNode, phNodeItem);
	}
	LOG_Error(_T("Can't retrieve valid item node from catalog xml"));
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// AddTimeStamp()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddTimeStamp(HANDLE_NODE hNodeItem)
{
	LOG_Block("AddTimeStamp()");

	USES_IU_CONVERSION;

	HRESULT		hr = E_FAIL;

	TCHAR szTimestamp[32];
	SYSTEMTIME stTimestamp;
	BSTR bstrTimeStamp = NULL;
	GetLocalTime(&stTimestamp);

	hr = StringCchPrintfEx(szTimestamp, ARRAYSIZE(szTimestamp), NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%4d-%02d-%02dT%02d:%02d:%02d"), // "ISO 8601" format for "datatime" datatype in xml
                           stTimestamp.wYear,
                           stTimestamp.wMonth,
                           stTimestamp.wDay,
                           stTimestamp.wHour,
                           stTimestamp.wMinute,
                           stTimestamp.wSecond);
	CleanUpIfFailedAndSetHrMsg(hr);
	
	bstrTimeStamp = SysAllocString(T2OLE(szTimestamp));

	//
	// set the "timestamp" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(m_ppNodeArray[hNodeItem], KEY_TIMESTAMP, bstrTimeStamp));

CleanUp:
	SysFreeString(bstrTimeStamp);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDetectResult()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddDetectResult(HANDLE_NODE hNodeItem,
								   INT iInstalled    /*= -1*/,
								   INT iUpToDate     /*= -1*/,
								   INT iNewerVersion /*= -1*/,
								   INT iExcluded     /*= -1*/,
								   INT iForce        /*= -1*/,
								   INT iComputerSystem /* = -1 */)
{
	LOG_Block("AddDetectResult()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDetectResult = NULL;

	//
	// create the <detectResult> node
	//
	pNodeDetectResult = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DETECTRESULT);
	if (NULL == pNodeDetectResult) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeDetectResult));

	//
	// set the "installed" attribute
	//
	if (-1 != iInstalled)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_INSTALLED, iInstalled));
	}

	//
	// set the "upToDate" attribute
	//
	if (-1 != iUpToDate)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_UPTODATE, iUpToDate));
	}

	//
	// set the "newerVersion" attribute
	//
	if (-1 != iNewerVersion)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_NEWERVERSION, iNewerVersion));
	}

	//
	// set the "excluded" attribute
	//
	if (-1 != iExcluded)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_EXCLUDED, iExcluded));
	}

	//
	// set the "force" attribute
	//
	if (-1 != iForce)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_FORCE, iForce));
	}

	//
	// set computerSystem attribute
	//
	if (-1 != iComputerSystem)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_COMPUTERSYSTEM, iComputerSystem));
	}


CleanUp:
	SafeReleaseNULL(pNodeDetectResult);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDownloadStatus()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddDownloadStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, DWORD dwErrorCode /*= 0*/)
{
	LOG_Block("AddDownloadStatus()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDownloadStatus = NULL;

	//
	// create the <downloadStatus> node
	//
	pNodeDownloadStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DOWNLOADSTATUS);
	if (NULL == pNodeDownloadStatus) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeDownloadStatus));

	//
	// set the "value" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDownloadStatus, KEY_VALUE, bstrValue));

	//
	// set the "errorCode" attribute
	//
	if (0 != dwErrorCode)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDownloadStatus, KEY_ERRORCODE, dwErrorCode));
	}

CleanUp:
	SafeReleaseNULL(pNodeDownloadStatus);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDownloadPath()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddDownloadPath(HANDLE_NODE hNodeItem, BSTR bstrDownloadPath)
{
	LOG_Block("AddDownloadPath()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDownloadPath = NULL;
	IXMLDOMNode*	pNodeDownloadPathText = NULL;

	pNodeDownloadPath = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DOWNLOADPATH);
	if (NULL == pNodeDownloadPath) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeDownloadPath));

	pNodeDownloadPathText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
	if (NULL == pNodeDownloadPathText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeDownloadPathText, bstrDownloadPath));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeDownloadPath, pNodeDownloadPathText));

CleanUp:
	SafeReleaseNULL(pNodeDownloadPath);
	SafeReleaseNULL(pNodeDownloadPathText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddInstallStatus()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddInstallStatus(HANDLE_NODE hNodeItem,
									  BSTR bstrValue,
									  BOOL fNeedsReboot,
									  DWORD dwErrorCode /*= 0*/)
{
	LOG_Block("AddInstallStatus()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeInstallStatus = NULL;

	//
	// create the <installStatus> node
	//
	pNodeInstallStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_INSTALLSTATUS);
	if (NULL == pNodeInstallStatus) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeInstallStatus));

	//
	// set the "value" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_VALUE, bstrValue));

	//
	// set the "needsReboot" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_NEEDSREBOOT, fNeedsReboot));

	//
	// set the "errorCode" attribute
	//
	if (0 != dwErrorCode)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_ERRORCODE, dwErrorCode));
	}

CleanUp:
	SafeReleaseNULL(pNodeInstallStatus);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddClientInfo()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddClientInfo(HANDLE_NODE hNodeItem, BSTR bstrClient)
{
	LOG_Block("AddClientInfo()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeClient = NULL;
	IXMLDOMNode*	pNodeClientText = NULL;

	pNodeClient = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_CLIENT);
	if (NULL == pNodeClient) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeClient));

	pNodeClientText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
	if (NULL == pNodeClientText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeClientText, bstrClient));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeClient, pNodeClientText));

CleanUp:
	SafeReleaseNULL(pNodeClient);
	SafeReleaseNULL(pNodeClientText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// MigrateV3History()
//
// Migrate V3 History: Consumer history only.
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::MigrateV3History(LPCTSTR pszHistoryFilePath)
{
	LOG_Block("MigrateV3History()");

	HRESULT		hr = S_OK;

	IXMLDOMNode*	pNodeXML = NULL;
	IXMLDOMNode*	pNodeItemStatus = NULL;
	IXMLDOMNode*	pNodeIdentity = NULL;
	IXMLDOMNode*	pNodeDescription = NULL;
	IXMLDOMNode*	pNodeDescriptionText = NULL;
	IXMLDOMNode*	pNodeTitle = NULL;
	IXMLDOMNode*	pNodeTitleText = NULL;
	IXMLDOMNode*	pNodeVersion = NULL;
	IXMLDOMNode*	pNodeVersionText = NULL;
	IXMLDOMNode*	pNodeInstallStatus = NULL;
	IXMLDOMNode*	pNodeClient = NULL;
	IXMLDOMNode*	pNodeClientText = NULL;
	BSTR bstrNameSpaceSchema = NULL, bstrStatus = NULL, bstrString = NULL;
	LPTSTR pszItemsSchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	CV3AppLog V3History(pszHistoryFilePath);
	char szLineType[32];
	char szTemp[32];
	char szDate[32];
	char szTime[32];
	char szPUID[32];		// puid - migrate to <identity "name">
	char szTitle[256];		// title - migrate to <description>-><descriptionText>-><title>
	char szVersion[40];		// version - migrate to <identity>-><version>
	char szTimeStamp[32];	// timestamp - migrate to <itemStatus "timestamp">
	char szResult[16];		// result - migrate to <installStatus "value">
	char szErrCode[16];		// errorcode - migrate to <installStatus "errorCode">

	USES_IU_CONVERSION;

	V3History.StartReading();
	while (V3History.ReadLine())
	{
	    SafeSysFreeString(bstrString);
		// get line type (first field)
		V3History.CopyNextField(szLineType, ARRAYSIZE(szLineType));
		if ((_stricmp(szLineType, LOG_V3CAT) == 0) || (_stricmp(szLineType, LOG_V3_2) == 0)) 
		{
			// get "puid" field
			V3History.CopyNextField(szPUID, ARRAYSIZE(szPUID));

			// get "operation" field: installed/uninstalled
			// we only migrate installed item
			V3History.CopyNextField(szTemp, ARRAYSIZE(szTemp));
			if (0 != _stricmp(szTemp, LOG_INSTALL))
				continue;

			//
			// now we start to create <itemStatus> node for this item
			//
			if (NULL == m_pDocItems)
			{
				//
				// we don't have IU history file yet
				//
 				hr = CoCreateInstance(CLSID_DOMDocument,
											  NULL,
											  CLSCTX_INPROC_SERVER,
											  IID_IXMLDOMDocument,
											  (void **) &m_pDocItems);
				if (FAILED(hr))
				{
					LOG_ErrorMsg(hr);
				}
				else
				{
					//
					// create the <?xml version="1.0"?> node
					//
					pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
					if (NULL == pNodeXML) goto CleanUp;

					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

					//
					// process the iuident.txt to find the Items schema path
					//
					TCHAR szIUDir[MAX_PATH];
					TCHAR szIdentFile[MAX_PATH];

					pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
					if (NULL == pszItemsSchema)
					{
						hr = E_OUTOFMEMORY;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
					pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
					if (NULL == pszNameSpaceSchema)
					{
						hr = E_OUTOFMEMORY;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
		
					GetIndustryUpdateDirectory(szIUDir);
            		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
            		if (FAILED(hr))
            		{
            			LOG_ErrorMsg(hr);
            			goto CleanUp;
            		}

					GetPrivateProfileString(IDENT_IUSCHEMA,
											IDENT_IUSCHEMA_ITEMS,
											_T(""),
											pszItemsSchema,
											INTERNET_MAX_URL_LENGTH,
											szIdentFile);

					if ('\0' == pszItemsSchema[0])
					{
						// no Items schema path specified in iuident.txt
						LOG_Error(_T("No schema path specified in iuident.txt for Items"));
						goto CleanUp;
					}

            		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
            		                       _T("x-schema:%s"), pszItemsSchema);
            		if (FAILED(hr))
            		{
            			LOG_ErrorMsg(hr);
            			goto CleanUp;
            		}

					bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

					//
					// create the <items> node with the path of the schema
					//
					m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
					if (NULL == m_pNodeItems) goto CleanUp;
					
					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));
				}
			}
			else
			{
			    SafeReleaseNULL(m_pNodeItems);
				FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &m_pNodeItems);
			}
			
			// create <itemStatus> node
			pNodeItemStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMSTATUS);
			if (NULL == pNodeItemStatus) continue;
			SkipIfFail(InsertNode(m_pNodeItems, pNodeItemStatus));
		
			// create <client> node
			pNodeClient = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_CLIENT);
			if (NULL == pNodeClient) continue;
			pNodeClientText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
			if (NULL == pNodeClientText) continue;
			BSTR bstrV3Client = SysAllocString(C_V3_CLIENTINFO);
			SkipIfFail(SetValue(pNodeClientText, bstrV3Client));
			SkipIfFail(InsertNode(pNodeClient, pNodeClientText));
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeClient));
			SafeSysFreeString(bstrV3Client);

			// create <identity> node
			pNodeIdentity = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_IDENTITY);
			if (NULL == pNodeIdentity) continue;
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeIdentity));
			
			// set the "name" attribute for <identity>
			bstrString = SysAllocString(A2OLE(szPUID));
			SkipIfFail(SetAttribute(pNodeIdentity, KEY_NAME, bstrString));
			// set the "itemID" attribute for <identity>
			SkipIfFail(SetAttribute(pNodeIdentity, KEY_ITEMID, bstrString));
			SafeSysFreeString(bstrString);

			// get "title" field
			V3History.CopyNextField(szTitle, ARRAYSIZE(szTitle));
			
			// create <description> node
			pNodeDescription = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DESCRIPTION);
			if (NULL == pNodeDescription) continue;
			SkipIfFail(SetAttribute(pNodeDescription, KEY_HIDDEN, 0));
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeDescription));

			// create <descriptionText> node
			pNodeDescriptionText = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DESCRIPTIONTEXT);
			if (NULL == pNodeDescriptionText) continue;
			SkipIfFail(InsertNode(pNodeDescription, pNodeDescriptionText));

			// create <title> node
			pNodeTitle = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_TITLE);
			if (NULL == pNodeTitle) continue;
			pNodeTitleText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
			if (NULL == pNodeTitleText) continue;
			bstrString = SysAllocString(A2OLE(szTitle));
			SkipIfFail(SetValue(pNodeTitleText, bstrString));
			SkipIfFail(InsertNode(pNodeTitle, pNodeTitleText));
			SkipIfFail(InsertNode(pNodeDescriptionText, pNodeTitle));
			SafeSysFreeString(bstrString);

			// get "version" field
			V3History.CopyNextField(szVersion, ARRAYSIZE(szVersion));

			// create <version> node
			pNodeVersion = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_VERSION);
			if (NULL == pNodeVersion) continue;

			pNodeVersionText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
			if (NULL == pNodeVersionText) continue;
			bstrString = SysAllocString(A2OLE(szVersion));
			SkipIfFail(SetValue(pNodeVersionText, bstrString));
			SkipIfFail(InsertNode(pNodeVersion, pNodeVersionText));
			SkipIfFail(InsertNode(pNodeIdentity, pNodeVersion));
			SafeSysFreeString(bstrString);

			// get timestamp
			if ((_stricmp(szLineType, LOG_V3_2) == 0))
			{
				// read the timestamp and convert to "ISO 8601" format for "datatime" datatype in xml:
				// for example, 2001-05-01T18:30:00
				// so we only need to replace the space with 'T'
 
				// timestamp
				V3History.CopyNextField(szTimeStamp, ARRAYSIZE(szTimeStamp));
				char *p = strchr(szTimeStamp, ' ');
				if (NULL != p) // if (NULL == p): there's no space then leave it as is to pass into SetAttribute
				{
				    *p = 'T';
				}
			}
			else 
			{
				// V3 Beta had two fields for date and time, we need read both these fields:

				// date
				V3History.CopyNextField(szDate, ARRAYSIZE(szDate));

				// time
				V3History.CopyNextField(szTime, ARRAYSIZE(szTime));
				hr = StringCchPrintfExA(szTimeStamp, ARRAYSIZE(szTimeStamp), NULL, NULL, MISTSAFE_STRING_FLAGS,
				                        "%sT%s", szDate, szTime);
				SkipIfFail(hr);
			}
			// set the "timestamp" attribute for <itemStatus>
			bstrString = SysAllocString(A2OLE(szTimeStamp));
			SkipIfFail(SetAttribute(pNodeItemStatus, KEY_TIMESTAMP, bstrString));
			SafeSysFreeString(bstrString);

			// skip the "record type" field
			V3History.CopyNextField(szTemp, ARRAYSIZE(szTemp));

			// get "result" field
			V3History.CopyNextField(szResult, ARRAYSIZE(szResult));

			// create <InstallStatus> node
			pNodeInstallStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_INSTALLSTATUS);
			if (NULL == pNodeInstallStatus) continue;
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeInstallStatus));

			// set the "value" attribute for <installStatus>
			if (_stricmp(szResult, LOG_SUCCESS) == 0)
			{
				bstrStatus = SysAllocString(L"COMPLETE");
			}
			else if (_stricmp(szTemp, LOG_STARTED) == 0)
			{
				bstrStatus = SysAllocString(L"IN_PROGRESS");
			}
			else
			{
				bstrStatus = SysAllocString(L"FAILED");
			}
			SkipIfFail(SetAttribute(pNodeInstallStatus, KEY_VALUE, bstrStatus));
			
			if (_stricmp(szResult, LOG_SUCCESS) != 0)
			{
				// get "error code" field
				V3History.CopyNextField(szErrCode, ARRAYSIZE(szErrCode));

				// set the "errorCode" attribute for <installStatus>
				SkipIfFail(SetAttribute(pNodeInstallStatus, KEY_ERRORCODE,  atoh(szErrCode)));
			}
		}

	}
	V3History.StopReading();

CleanUp:
	
	SafeReleaseNULL(pNodeXML);
	SafeReleaseNULL(pNodeItemStatus);
	SafeReleaseNULL(pNodeIdentity);
	SafeReleaseNULL(pNodeDescriptionText);
	SafeReleaseNULL(pNodeTitle);
	SafeReleaseNULL(pNodeTitleText);
	SafeReleaseNULL(pNodeVersion);
	SafeReleaseNULL(pNodeVersionText);
	SafeReleaseNULL(pNodeInstallStatus);
	SafeReleaseNULL(pNodeClient);
	SafeReleaseNULL(pNodeClientText);
	SysFreeString(bstrString);
	SysFreeString(bstrNameSpaceSchema);
	SysFreeString(bstrStatus);
	SafeHeapFree(pszItemsSchema);
	SafeHeapFree(pszNameSpaceSchema);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemsBSTR()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetItemsBSTR(BSTR *pbstrXmlItems)
{
	LOG_Block("GetItemsBSTR()");

	if (NULL == m_pDocItems)
	{
		*pbstrXmlItems = NULL;
		return S_OK;
	}

	//
	// convert XML DOC into BSTR 
	//
	HRESULT hr = m_pDocItems->get_xml(pbstrXmlItems);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetFilteredHistoryBSTR()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetFilteredHistoryBSTR(BSTR bstrBeginDateTime,
											BSTR bstrEndDateTime,
											BSTR bstrClient,
											BSTR *pbstrXmlHistory)
{
	LOG_Block("GetFilteredHistoryBSTR()");

	USES_IU_CONVERSION;

	HRESULT		hr = S_OK;

	IXMLDOMNode*	pNodeItems = NULL;
	IXMLDOMNode*	pNodeItem = NULL;
	IXMLDOMNode*	pNodeItemOut = NULL;
	IXMLDOMNode*	pNodeClient = NULL;
	BSTR bstrTimeStamp = NULL;
	BSTR bstrClientInfo = NULL;
	BOOL fOutOfRange = FALSE;

	HANDLE_NODELIST	hNodeList = HANDLE_NODELIST_INVALID;

	if (NULL == pbstrXmlHistory)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}	
	
	if (NULL != m_pDocItems)
	{
		if (SUCCEEDED(FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &pNodeItems)))
		{
			hNodeList = FindFirstDOMNode(pNodeItems, KEY_ITEMSTATUS, &pNodeItem);
			if (HANDLE_NODELIST_INVALID != hNodeList)
			{
				CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
				if (NULL != bstrTimeStamp)
				{
					if ((NULL != bstrBeginDateTime) && (0 != SysStringLen(bstrBeginDateTime)) &&
						(CompareBSTRs(bstrTimeStamp, bstrBeginDateTime) < 0))
					{
						//
						// remove the item whose timestamp is out of range;
						// set the flag to ignore the timestamp comparison for the rest of nodes
						//
						CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
						fOutOfRange = TRUE;
					}
					else if ((NULL != bstrEndDateTime) && (0 != SysStringLen(bstrEndDateTime)) &&
							 (CompareBSTRs(bstrTimeStamp, bstrEndDateTime) > 0))
					{
						//
						// remove the item whose timestamp is out of range
						//
						CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
					}
					else
					{
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClient));
						CleanUpIfFailedAndSetHrMsg(GetText(pNodeClient, &bstrClientInfo));
						if ((NULL != bstrClient) && (0 != SysStringLen(bstrClient)) &&
							(WUCompareStringI(OLE2T(bstrClientInfo), OLE2T(bstrClient)) != CSTR_EQUAL))
						{
							//
							// remove the item whose clieninfo does not match what we need
							//
							CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
						}
					}
				}
				SafeReleaseNULL(pNodeItem);
				SafeReleaseNULL(pNodeItemOut);
				SafeReleaseNULL(pNodeClient);
				SafeSysFreeString(bstrTimeStamp);
				SafeSysFreeString(bstrClientInfo);
				while (SUCCEEDED(FindNextDOMNode(hNodeList, &pNodeItem)))
				{
					if (fOutOfRange)
					{
						//
						// remove the item whose timestamp is out of range
						//
						CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
					}
					else
					{
						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
						if (NULL != bstrTimeStamp)
						{
							if ((NULL != bstrBeginDateTime) && (0 != SysStringLen(bstrBeginDateTime)) &&
								(CompareBSTRs(bstrTimeStamp, bstrBeginDateTime) < 0))
							{
								//
								// remove the item whose timestamp is out of range;
								// set the flag to ignore the timestamp comparison for the rest of nodes
								//
								CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
								fOutOfRange = TRUE;
							}
							else if ((NULL != bstrEndDateTime) && (0 != SysStringLen(bstrEndDateTime)) &&
									 (CompareBSTRs(bstrTimeStamp, bstrEndDateTime) > 0))
							{
								//
								// remove the item whose timestamp is out of range
								//
								CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
							}
							else
							{
								CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClient));
								CleanUpIfFailedAndSetHrMsg(GetText(pNodeClient, &bstrClientInfo));
								if ((NULL != bstrClient) && (0 != SysStringLen(bstrClient)) &&
									(WUCompareStringI(OLE2T(bstrClientInfo), OLE2T(bstrClient)) != CSTR_EQUAL))
								{
									//
									// remove the item whose clieninfo does not match what we need
									//
									CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
								}
							}
						}
					}
					SafeReleaseNULL(pNodeItem);
					SafeReleaseNULL(pNodeItemOut);
					SafeReleaseNULL(pNodeClient);
					SafeSysFreeString(bstrTimeStamp);
					SafeSysFreeString(bstrClientInfo);
				}
			}
		}
	}

CleanUp:
	CloseItemList(hNodeList);
	SafeReleaseNULL(pNodeItems);
	SafeReleaseNULL(pNodeItem);
	SafeReleaseNULL(pNodeItemOut);
	SafeReleaseNULL(pNodeClient);
	SysFreeString(bstrTimeStamp);
	SysFreeString(bstrClientInfo);
	if (SUCCEEDED(hr))
	{
		hr = GetItemsBSTR(pbstrXmlHistory);
	}
	return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CXmlClientInfo


CXmlClientInfo::CXmlClientInfo()
: m_pDocClientInfo(NULL)
{

}

CXmlClientInfo::~CXmlClientInfo()
{
	SafeReleaseNULL(m_pDocClientInfo);
}

//
// load and parse and validate an XML document from string
//
HRESULT CXmlClientInfo::LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode)
{
    LOG_Block("CXmlClientInfo::LoadXMLDocument()");

    SafeReleaseNULL(m_pDocClientInfo);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocClientInfo, fOfflineMode);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}

//
// retrieve client name attribute
//
HRESULT CXmlClientInfo::GetClientName(BSTR* pbstrClientName)
{
	HRESULT hr= E_UNEXPECTED;

	IXMLDOMElement* pElement = NULL;
	BSTR bstrTagName = NULL;
	VARIANT vAttr;
	VariantInit(&vAttr);

	LOG_Block("GetClientName()");

	if (NULL == pbstrClientName)
	{
		return E_INVALIDARG;
	}

	if (NULL == m_pDocClientInfo)
	{
		return hr;
	}

	hr = m_pDocClientInfo->get_documentElement(&pElement);
	CleanUpIfFailedAndMsg(hr);
	if (NULL == pElement)
	{
		//
		// no root element
		//
		hr = E_INVALIDARG;		// clientInfo is bad! return this error back to caller
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	hr = pElement->get_tagName(&bstrTagName);
	CleanUpIfFailedAndMsg(hr);

	if (!CompareBSTRsEqual(bstrTagName, KEY_CLIENTINFO))
	{
		//
		// root is not clientInfo
		//
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	hr = pElement->getAttribute(KEY_CLIENTNAME, &vAttr);
	CleanUpIfFailedAndMsg(hr);

	if (VT_BSTR == vAttr.vt)
	{
		*pbstrClientName = SysAllocString(vAttr.bstrVal);
	}
	else
	{
		hr = E_FAIL;
		CleanUpIfFailedAndMsg(hr);
	}

CleanUp:
	SafeReleaseNULL(pElement);
	if (bstrTagName)
	{
		SysFreeString(bstrTagName);
		bstrTagName = NULL;
	}
	VariantClear(&vAttr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\v3applog.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    v3applog.h
//
//  Purpose: Reading WindowsUpdate V3 history logging 
//
//  History: 22-Feb-99   YAsmi    Created
//			 02-May-01   JHou	  Modified
//
//=======================================================================

#ifndef _APPLOG_H_
#define _APPLOG_H_

#define LOG_FIELD_SEPARATOR    "|"


class CV3AppLog
{
public:
	CV3AppLog(LPCTSTR pszLogFileName = NULL);    
	~CV3AppLog();

	void SetLogFile(LPCTSTR pszLogFileName);

	//
	// reading
	//
	void StartReading();
	BOOL ReadLine();
	BOOL CopyNextField(LPSTR pszBuf, int cBufSize);
	void StopReading();

private:
	void CheckBuf(DWORD dwSize);

	LPTSTR m_pszLogFN;

	LPSTR m_pFileBuf;
	LPSTR m_pFieldBuf;
	LPSTR m_pLine;

	DWORD m_dwFileSize;
	DWORD m_dwBufLen;
	DWORD m_dwFileOfs;
};

#endif // _APPLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\acpi.c ===
/*** acpi.c - ACPI VXD to provide table access IOCTLs
 *
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 *	10/06/98		YanL		Modified to be used in WUBIOS.VXD
 */

#include "wubiosp.h"

/*** Function prototypes
 */

PRSDT CM_LOCAL FindRSDT(DWORD* pdwRSDTAddr);
BYTE CM_LOCAL CheckSum(PBYTE pb, DWORD dwLen);
#ifdef TRACING
PSZ CM_LOCAL SigStr(DWORD dwSig);
#endif

#pragma CM_PAGEABLE_DATA
#pragma CM_PAGEABLE_CODE


/***LP  FindRSDT - Find the RSDT
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns the RSDT pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PRSDT CM_LOCAL FindRSDT(DWORD* pdwRSDTAddr)
{
    TRACENAME("FINDRSDT")
    PRSDT pRSDT = NULL;
    PBYTE pbROM;

    ENTER(2, ("FindRSDT()\n"));

    if ((pbROM = (PBYTE)_MapPhysToLinear(RSDP_SEARCH_RANGE_BEGIN,
                                         RSDP_SEARCH_RANGE_LENGTH, 0)) !=
        (PBYTE)0xffffffff)
    {
        PBYTE pbROMEnd;
        DWORD dwRSDTAddr = 0;

        pbROMEnd = pbROM + RSDP_SEARCH_RANGE_LENGTH - RSDP_SEARCH_INTERVAL;
        while (pbROM != NULL)
        {
            if ((((PRSDP)pbROM)->Signature == RSDP_SIGNATURE) &&
                (CheckSum(pbROM, sizeof(RSDP)) == 0))
            {
                dwRSDTAddr = ((PRSDP)pbROM)->RsdtAddress;
                if (((pbROM = (PBYTE)_MapPhysToLinear(dwRSDTAddr,
                                                      sizeof(DESCRIPTION_HEADER),
                                                      0)) ==
                     (PBYTE)0xffffffff) ||
                    (((PDESCRIPTION_HEADER)pbROM)->Signature != RSDT_SIGNATURE))
                {
                    pbROM = NULL;
                }
                break;
            }
            else
            {
                pbROM += RSDP_SEARCH_INTERVAL;
                if (pbROM > pbROMEnd)
                {
                    pbROM = NULL;
                }
            }
        }

        if (pbROM != NULL)
        {
            DWORD dwLen = ((PDESCRIPTION_HEADER)pbROM)->Length;

            pRSDT = (PRSDT)_MapPhysToLinear(dwRSDTAddr, dwLen, 0);
            if ((pRSDT == (PRSDT)0xffffffff) ||
                (CheckSum((PBYTE)pRSDT, dwLen) != 0))
            {
                pRSDT = NULL;
            }
			*pdwRSDTAddr = dwRSDTAddr;
        }
    }

    EXIT(2, ("FindRSDT=%x\n", pRSDT));
    return pRSDT;
}       //FindRSDT

/***LP  AcpiFindTable - Find an ACPI Table
 *
 *  ENTRY
 *      dwSig - signature of the table
 *      pdwLen -> to hold length of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns physical address of table
 *  EXIT-FAILURE
 *      returns 0
 */

DWORD CM_INTERNAL AcpiFindTable(DWORD dwSig, PDWORD pdwLen)
{
    TRACENAME("AcpiFindTable")
    DWORD dwPhyAddr = 0;
    static PRSDT pRSDT = (PRSDT)0xffffffff;
    static DWORD dwRSDTAddr;

    ENTER(2, ("AcpiFindTable(Sig=%s,pdwLen=%x)\n", SigStr(dwSig), pdwLen));

    if (pRSDT == (PRSDT)0xffffffff)
    {
        pRSDT = FindRSDT(&dwRSDTAddr);
    }

    if (pRSDT != NULL)
    {
        PDESCRIPTION_HEADER pdh = NULL;

        if (dwSig == RSDT_SIGNATURE)
		{
			*pdwLen = ((PDESCRIPTION_HEADER)pRSDT)->Length;
			dwPhyAddr = dwRSDTAddr;
		}
        else if (dwSig == DSDT_SIGNATURE)
        {
            DWORD dwLen;
            PFADT pFADT;

            if (((dwPhyAddr = AcpiFindTable(FADT_SIGNATURE, &dwLen)) != 0) &&
                ((pFADT = (PFADT)_MapPhysToLinear(dwPhyAddr, dwLen, 0)) !=
                 (PFADT)0xffffffff))
            {
                dwPhyAddr = pFADT->dsdt;
                if ((pdh = (PDESCRIPTION_HEADER)_MapPhysToLinear(
                                                    dwPhyAddr,
                                                    sizeof(DESCRIPTION_HEADER),
                                                    0)) ==
                    (PDESCRIPTION_HEADER)0xffffffff)
                {
                    dwPhyAddr = 0;
                }
            }
            else
            {
                dwPhyAddr = 0;
            }
        }
        else
        {
            int i, iNumTables = NumTableEntriesFromRSDTPointer(pRSDT);

            for (i = 0; i < iNumTables; ++i)
            {
                dwPhyAddr = pRSDT->Tables[i];
                if (((pdh = (PDESCRIPTION_HEADER)_MapPhysToLinear(
                                                    dwPhyAddr,
                                                    sizeof(DESCRIPTION_HEADER),
                                                    0)) 
					!= (PDESCRIPTION_HEADER)0xffffffff))
				{
					if (pdh->Signature == dwSig && (CheckSum((PBYTE)pdh, pdh->Length) == 0) )
					{
						break;
					}
                }
            }

            if (i >= iNumTables)
            {
                dwPhyAddr = 0;
            }
        }

        if ((dwPhyAddr != 0) && (pdwLen != NULL))
        {
            *pdwLen = pdh->Length;
        }
    }

    EXIT(2, ("AcpiFindTable=%x (Len=%x)\n", dwPhyAddr, pdwLen? *pdwLen: 0));
    return dwPhyAddr;
}       //AcpiFindTable

/***LP  AcpiCopyROM - Copy ROM memory to buffer
 *
 *  ENTRY
 *      dwPhyAddr - physical address of ROM location
 *      pbBuff -> buffer
 *      dwLen - buffer length
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL AcpiCopyROM(DWORD dwPhyAddr, PBYTE pbBuff, DWORD dwLen)
{
    TRACENAME("AcpiCopyROM")
    PBYTE pbROM;

    ENTER(2, ("AcpiCopyROM(PhyAddr=%x,pbBuff=%x,Len=%x)\n",
              dwPhyAddr, pbBuff, dwLen));

    if ((pbROM = (PBYTE)_MapPhysToLinear(dwPhyAddr, dwLen, 0)) !=
        (PBYTE)0xffffffff)
    {
        memcpy(pbBuff, pbROM, dwLen);
    }

    EXIT(2, ("AcpiCopyROM!\n"));
}       //AcpiCopyROM

#ifdef TRACING
/***LP  SigStr - return string of DWORD signature
 *
 *  ENTRY
 *      dwSig - signature
 *
 *  EXIT
 *      returns signature string
 */

PSZ CM_LOCAL SigStr(DWORD dwSig)
{
    static char szSig[sizeof(DWORD) + 1] = {0};

    memcpy(szSig, &dwSig, sizeof(DWORD));

    return (PSZ)szSig;
}       //SigStr
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\control.c ===
/*** control.c - System Control Message Support
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#include "wubiosp.h"

#pragma CM_PAGEABLE_DATA
#pragma CM_PAGEABLE_CODE

/***EP  WUBIOS_IOCtrl - Win32 Device IO Control entry point
 *
 *  ENTRY
 *      pioc -> DIOC structure
 *
 *  EXIT-SUCCESS
 *      returns ERROR_SUCCESS
 *  EXIT-FAILURE
 *      returns ERROR_*
 */

CM_VXD_RESULT CM_SYSCTRL WUBIOS_IOCtrl(PDIOCPARAMETERS pdioc)
{
    TRACENAME("WUBIOS_IOCtrl")
    CM_VXD_RESULT rc = ERROR_SUCCESS;

    ENTER(1, ("WUBIOS_IOCtrl(hVM=%lx,hDev=%lx,Code=%lx)\n",
              pdioc->VMHandle, pdioc->hDevice, pdioc->dwIoControlCode));

    switch (pdioc->dwIoControlCode)
    {
        case WUBIOCTL_GET_VERSION:
            if ((pdioc->cbOutBuffer < sizeof(DWORD)) || (pdioc->lpvOutBuffer == NULL))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetVersion"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                PVMMDDB pddb = (PVMMDDB)pdioc->Internal2;

                *((PDWORD)pdioc->lpvOutBuffer) =
                    (pddb->DDB_Dev_Major_Version << 8) |
                    pddb->DDB_Dev_Minor_Version;

                if (pdioc->lpcbBytesReturned != NULL)
                    *((PDWORD)pdioc->lpcbBytesReturned) = sizeof(DWORD);
            }
            break;
        case WUBIOCTL_GET_ACPI_TABINFO:
            if ((pdioc->lpvOutBuffer == NULL) ||
                (pdioc->cbOutBuffer != sizeof(ACPITABINFO)))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetTabInfo"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                PACPITABINFO pTabInfo = (PACPITABINFO)pdioc->lpvOutBuffer;

                if ((pTabInfo->dwPhyAddr = AcpiFindTable(pTabInfo->dwTabSig, NULL)) != 0)
                {
                    AcpiCopyROM(pTabInfo->dwPhyAddr, (PBYTE)&pTabInfo->dh, sizeof(pTabInfo->dh));
                }
                else
                {
                    DBG_ERR(("WUBIOS_IOCtrl: failed to get table info"));
                    rc = ERROR_GEN_FAILURE;
                }
            }
            break;

        case WUBIOCTL_GET_ACPI_TABLE:
            if ((pdioc->lpvInBuffer == NULL) || (pdioc->lpvOutBuffer == NULL) || (pdioc->cbOutBuffer == 0))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetTable"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                AcpiCopyROM((DWORD)pdioc->lpvInBuffer, (PBYTE)pdioc->lpvOutBuffer, pdioc->cbOutBuffer);
            }
            break;
		case WUBIOCTL_GET_SMB_STRUCTSIZE:
            if ((pdioc->cbOutBuffer < sizeof(DWORD)) || (pdioc->lpvOutBuffer == NULL))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on WUBIOCTL_GET_SMB_TABSIZE"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
				*((PDWORD)(pdioc->lpvOutBuffer)) = SmbStructSize();
            }
			break;

		case WUBIOCTL_GET_SMB_STRUCT:
            if ((pdioc->lpvInBuffer == NULL) || (pdioc->lpvOutBuffer == NULL) || (pdioc->cbOutBuffer == 0))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetTable"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                rc = SmbCopyStruct((DWORD)pdioc->lpvInBuffer, (PBYTE)pdioc->lpvOutBuffer, pdioc->cbOutBuffer);
            }
			break;
		case WUBIOCTL_GET_PNP_OEMID:
            if ((pdioc->cbOutBuffer < sizeof(DWORD)) || (pdioc->lpvOutBuffer == NULL))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on WUBIOCTL_GET_PNP_OEMID"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
				*((PDWORD)(pdioc->lpvOutBuffer)) = PnpOEMID();
            }
			break;
		default:
			;
    }

    EXIT(1, ("WUBIOS_IOCtrl=%x\n", rc));
    return rc;
}       //WUBIOS_IOCtrl

/***LP  CheckSum - Calculate checksum of a buffer
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length of buffer
 *
 *  EXIT
 *      returns checksum
 */

BYTE CM_INTERNAL CheckSum(PBYTE pb, DWORD dwLen)
{
    TRACENAME("CHECKSUM")
    BYTE bChkSum = 0;

    ENTER(3, ("CheckSum(pb=%x,Len=%x)\n", pb, dwLen));

    while (dwLen > 0)
    {
        bChkSum = (BYTE)(bChkSum + *pb);
        pb++;
        dwLen--;
    }

    EXIT(3, ("CheckSum=%x\n", bChkSum));
    return bChkSum;
}       //CheckSum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\smbios.c ===
/*** smbios.c - System Management BIOS support
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#include "wubiosp.h"

/*** Function prototypes
 */
PPNPBIOSINIT CM_LOCAL GetPNPBIOSINIT(void);
PSMBIOSENTRY CM_LOCAL GetSMBIOSENTRY(void);
PBYTE CM_LOCAL NextTable(PBYTE pMem);

#pragma CM_PAGEABLE_DATA

 /*** Globals
 */
static PSMBIOSENTRY g_pSMBIOS = (PSMBIOSENTRY)0xffffffff;


#pragma CM_PAGEABLE_CODE

 /*** SmbStructSize - Init SMBIOS and return max table size
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      TRUE
 *  EXIT-FAILURE
 *      FALSE
 *
 *
 */
DWORD CM_INTERNAL SmbStructSize(void)
{
    TRACENAME("SmbStructSize")

	DWORD dwMaxTableSize = 0;

	ENTER(2, ("SmbStructSize()\n"));

	if ((PSMBIOSENTRY)0xffffffff == g_pSMBIOS)
	{
		// Find Struct
		g_pSMBIOS = GetSMBIOSENTRY();
	}
	if (g_pSMBIOS)
	{
		dwMaxTableSize = (DWORD)(g_pSMBIOS->wMaxStructSize);
	}

	EXIT(2, ("SmbStructSize()=%x\n", dwMaxTableSize));
	
	return dwMaxTableSize;
}

 /*** SmbCopyStruct - Do BIOS init
 *
 *  ENTRY
 *      dwType - Structure type (from SMBIOS spec)
 *      pbBuff -> buffer
 *      dwLen - buffer length
 *
 *  EXIT
 *      None
 *
 */
CM_VXD_RESULT CM_INTERNAL SmbCopyStruct(DWORD dwType, PBYTE pbBuff, DWORD dwLen)
{
    TRACENAME("SmbCopyStruct")
    
	CM_VXD_RESULT rc = ERROR_GEN_FAILURE;
	
	ENTER(2, ("SmbCopyStruct()\n"));
	
	if ((PSMBIOSENTRY)0xffffffff == g_pSMBIOS)
	{
		// Find Struct
		g_pSMBIOS = GetSMBIOSENTRY();
	}
	// Check if we are inited
	if ( 0 != g_pSMBIOS && (DWORD)(g_pSMBIOS->wMaxStructSize) <= dwLen) 
	{

		// Map table
		PBYTE pTable = _MapPhysToLinear(g_pSMBIOS->dwStructTableAddress, g_pSMBIOS->wStructTableLength, 0);
		if ((PBYTE)0xffffffff != pTable)
		{
			WORD wTblCounter = g_pSMBIOS->wNumberOfStructs;
			while (wTblCounter --)
			{
				PBYTE pNextTable = NextTable(pTable);
				if ((BYTE)dwType == ((PSMBIOSHEADER)pTable)->bType)
				{
					// Do copy
				    memcpy(pbBuff, pTable, pNextTable - pTable);
					rc = ERROR_SUCCESS;
					//break;
				}
				pTable = pNextTable;
			}
		}
	}
    
	EXIT(2, ("SmbCopyStruct()=%x\n", rc));
	return rc;
}

 /*** PnpOEMID - Find PNPBIOSINIT and extract OEM id From it
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      DWORD id
 *  EXIT-FAILURE
 *      0
 *
 *
 */
DWORD CM_INTERNAL PnpOEMID(void)
{
    TRACENAME("PnpOEMID")

    static PPNPBIOSINIT pPnPBIOS = (PPNPBIOSINIT)0xffffffff;

	DWORD dwID = 0;
	ENTER(2, ("PnpOEMID()\n"));

    if ((PPNPBIOSINIT)0xffffffff == pPnPBIOS)
    {
        pPnPBIOS = GetPNPBIOSINIT();
    }
	if (pPnPBIOS)
	{
		dwID = pPnPBIOS->dwOEMID;
	}
    
	EXIT(2, ("PnpOEMID() dwID = %08X\n", dwID));
	
	return dwID;
}


 /*** GetInitTable - Find PNPBIOSINIT structure
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns the PNPBIOSINIT pointer
 *  EXIT-FAILURE
 *      returns NULL
 *
 *
 */
PPNPBIOSINIT CM_LOCAL GetPNPBIOSINIT(void)
{
    TRACENAME("GetPNPBIOSINIT")
	
	PPNPBIOSINIT pInitTableRet = NULL;
	PBYTE pMem;

    ENTER(2, ("GetPNPBIOSINIT()\n"));

	// Map start address
	pMem = _MapPhysToLinear(SMBIOS_SEARCH_RANGE_BEGIN, SMBIOS_SEARCH_RANGE_LENGTH, 0);

    if (pMem != (PBYTE)0xffffffff)
	{
		// Loop counter;
		int  nCounter = SMBIOS_SEARCH_RANGE_LENGTH / SMBIOS_SEARCH_INTERVAL;

		CM_FOREVER 
		{
			PPNPBIOSINIT pInitTable = (PPNPBIOSINIT)pMem;
			if ((PNP_SIGNATURE == pInitTable->dwSignature) && (0 == CheckSum(pMem, pInitTable->bLength)))
			{
				// Check length
				if (pInitTable->bLength<sizeof(PNPBIOSINIT)) 
				{
					DBG_ERR(("PnP BIOS Structure size %2X is less than %2X", 
						pInitTable->bLength, sizeof(PNPBIOSINIT)));
					break;
				}
				// Check version
				if (pInitTable->bRevision<0x10)
				{
					DBG_ERR(("PnP BIOS Revision %2X is less than 1.0", 
						pInitTable->bRevision));
					break;
				}
				pInitTableRet = pInitTable;
				break;
			}
			pMem += SMBIOS_SEARCH_INTERVAL;

			if ((--nCounter)==0)
			{
				DBG_ERR(("Could not find BIOS Init structure"));
				break;
			}
		}
	}
    EXIT(2, ("GetPNPBIOSINIT() pInitTable = %08X\n", pInitTableRet));
	return pInitTableRet;
}

 /*** GetInitTable - Find SMBIOSENTRY structure
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns the SMBIOSENTRY pointer
 *  EXIT-FAILURE
 *      returns NULL
 *
 *
 */
PSMBIOSENTRY CM_LOCAL GetSMBIOSENTRY(void)
{
    TRACENAME("GetSMBIOSENTRY")
	
	PSMBIOSENTRY pEntryTableRet = NULL;
	PBYTE pMem;

    ENTER(2, ("GetSMBIOSENTRY()\n"));

	// Map start address
	pMem = _MapPhysToLinear(SMBIOS_SEARCH_RANGE_BEGIN, SMBIOS_SEARCH_RANGE_LENGTH, 0);
	

    if (pMem != (PBYTE)0xffffffff)
	{
		// Loop counter;
		int nCounter = SMBIOS_SEARCH_RANGE_LENGTH / SMBIOS_SEARCH_INTERVAL;

		CM_FOREVER 
		{
			PSMBIOSENTRY pEntryTable = (PSMBIOSENTRY)pMem;
			if ((SM_SIGNATURE == pEntryTable->dwSignature) && (0 == CheckSum(pMem, pEntryTable->bLength)))
			{
				// Check length
				if (pEntryTable->bLength<sizeof(SMBIOSENTRY)) 
				{
					DBG_ERR(("SMBIOS Structure size %2X is less than %2X", 
						pEntryTable->bLength, sizeof(SMBIOSENTRY)));
					break;
				}
				pEntryTableRet = pEntryTable;
				break;
			}
			pMem += SMBIOS_SEARCH_INTERVAL;

			if ((--nCounter)==0)
			{
				DBG_ERR(("Could not find BIOS Init structure"));
				break;
			}
		}
	}
    EXIT(2, ("GetSMBIOSENTRY()\n"));
	return pEntryTableRet;
}

PBYTE CM_LOCAL NextTable(PBYTE pMem)
{
	pMem += ((PSMBIOSHEADER)pMem)->bLength;
	while ( *(PWORD)pMem)
		pMem ++;
	return pMem + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\main.asm ===
PAGE 58,132
;******************************************************************************
TITLE main.asm - WindowsUpdate BIOS Scanning VxD
;******************************************************************************
;
;   Title:	main.asm - WindowsUpdate BIOS Scanning VxD
;
;  Author:     Yan Leshinsky (YanL)
;  Created     10/04/98
;
;  MODIFICATION HISTORY
;
;
;  DESCRIPTION:
;
;******************************************************************************


	.386p

;******************************************************************************
;			      I N C L U D E S
;******************************************************************************

	.XLIST
	INCLUDE vmm.inc
	.LIST


;******************************************************************************
;		 V I R T U A L	 D E V I C E   D E C L A R A T I O N
;******************************************************************************

Declare_Virtual_Device WUBIOS, 1, 0, WUBIOS_Control, UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER


VXD_LOCKED_CODE_SEG

;******************************************************************************
;
;   WUBIOS_Control
;
;   DESCRIPTION:
;	Control procedure for device driver.
;
;   ENTRY:
;	EAX = Control call ID
;
;   EXIT:
;	If carry clear then
;	    Successful
;	else
;	    Control call failed
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc WUBIOS_Control

	Control_Dispatch W32_DEVICEIOCONTROL, WUBIOS_IOCtrl, sCall, <esi>
IFDEF DEBUG
	Control_Dispatch DEBUG_QUERY, WUBIOS_Debug, sCall
ENDIF
	clc
	ret

EndProc WUBIOS_Control

VXD_LOCKED_CODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\debug.c ===
/*** debug.c - Debug functions
 *
 *  This module contains all the debug functions.
 *
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 *	10/06/98		YanL		Modified to be used in WUBIOS.VXD
*/

#include "wubiosp.h"

//Miscellaneous Constants
#ifdef TRACING
#define MAX_TRIG_PTS            10
#define MAX_TRIGPT_LEN          31
#define TF_TRIG_MODE            0x00000001
#endif

//Local function prototypes
#ifdef TRACING
VOID CM_LOCAL TraceIndent(VOID);
BOOL CM_LOCAL IsTrigPt(char *pszProcName);
PCHAR CM_LOCAL InStr(PCHAR pszStr, PCHAR pszSubStr);
VOID CM_INTERNAL DebugSetTraceLevel(VOID);
VOID CM_INTERNAL DebugToggleTrigMode(VOID);
VOID CM_INTERNAL DebugClearTrigPts(VOID);
VOID CM_INTERNAL DebugAddTrigPt(VOID);
VOID CM_INTERNAL DebugZapTrigPt(VOID);
PCHAR CM_LOCAL GetString(PCHAR pszPrompt, PCHAR pszBuff, BYTE bcLen, BOOL fUpper);
#endif

//Local Data
#ifdef TRACING
#pragma CM_DEBUG_DATA
int giTraceLevel = 3, giIndent = 0;
char aszTrigPtBuff[MAX_TRIG_PTS][MAX_TRIGPT_LEN + 1] = {0};
DWORD dwfTrace = 0, dwcTriggers = 0;
#endif

#ifdef DEBUGGER
#pragma CM_DEBUG_DATA
CMDDC DebugCmds[] =
{
  #ifdef TRACING
    {'t', DebugSetTraceLevel,  "set Trace level     ", "Set Trace Level"},
    {'g', DebugToggleTrigMode, "toGgle trigger mode ", "Toggle Trace Trigger mode"},
    {'x', DebugClearTrigPts,   "clear trigger points", "Clear all trace trigger points"},
    {'y', DebugAddTrigPt,      "add trigger point   ", "Add a trace trigger point"},
    {'z', DebugZapTrigPt,      "Zap trigger point   ", "Delete a trace trigger point"},
  #endif
    {'q', NULL,                "Quit                ", "Quit the debugger"},
    {'\0'}
};
#endif  //ifdef DEBUGGER

#ifdef TRACING
#pragma CM_DEBUG_DATA
#pragma CM_DEBUG_CODE
/***LP  TraceIndent - Indent trace output
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_LOCAL TraceIndent(VOID)
{
    int i;

    CMDD(WARNNAME ":");
    for (i = 0; i < giIndent; i++)
    {
        CMDD("..");
    }
}       //TraceIndent

/***LP  IsTraceOn - Determine if tracing is on for the given procedure
 *
 *  ENTRY
 *      n - trace level
 *      pszProcName -> procedure name
 *      fEnter - TRUE if EnterProc trace
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL CM_LOCAL IsTraceOn(BYTE n, char *pszProcName, BOOL fEnter)
{
    BOOL rc = FALSE;

    if ((dwfTrace & TF_TRIG_MODE) && IsTrigPt(pszProcName))
    {
        if (fEnter)
            dwcTriggers++;
        else
            dwcTriggers--;
        rc = TRUE;
    }
    else if ((n <= giTraceLevel) &&
             (!(dwfTrace & TF_TRIG_MODE) || (dwcTriggers > 0)))
    {
        rc = TRUE;
    }

    if (rc == TRUE)
        TraceIndent();

    return rc;
}       //IsTraceOn

/***LP  IsTrigPt - Find the procedure name in the TrigPt buffer
 *
 *  ENTRY
 *      pszProcName -> procedure name
 *
 *  EXIT-SUCCESS
 *      returns TRUE - matched whole or partial name in the TrigPt buffer
 *  EXIT-FAILURE
 *      returns FALSE - no match
 */

BOOL CM_LOCAL IsTrigPt(char *pszProcName)
{
    BOOL rc = FALSE;
    BYTE i;

    for (i = 0; (rc == FALSE) && (i < MAX_TRIG_PTS); ++i)
    {
        if (InStr(pszProcName, &aszTrigPtBuff[i][0]) != NULL)
            rc = TRUE;
    }

    return rc;
}       //IsTrigPt

/***LP  InStr - Match a sub-string in a given string
 *
 *  ENTRY
 *      pszStr -> string
 *      pszSubStr -> sub-string
 *
 *  EXIT-SUCCESS
 *      returns pointer to the string where the substring is found
 *  EXIT-FAILURE
 *      returns NULL
 */

PCHAR CM_LOCAL InStr(PCHAR pszStr, PCHAR pszSubStr)
{
    PCHAR psz = NULL;
    BYTE bcStrLen = (BYTE)_lstrlen(pszStr);
    BYTE bcSubStrLen = (BYTE)_lstrlen(pszSubStr);

    _asm
    {
        cld
        mov edi,pszStr

    Next:
        mov esi,pszSubStr
        movzx ecx,BYTE PTR bcStrLen
        lodsb
        repne scasb
        jnz NotFound

        movzx ecx,BYTE PTR bcSubStrLen
        repe cmpsb
        jne Next

        movzx ecx,BYTE PTR bcSubStrLen
        sub edi,ecx
        mov psz,edi

    NotFound:
    }

    return psz;
}       //InStr
#endif  //ifdef TRACING

#ifdef DEBUGGER
#pragma CM_DEBUG_DATA
#pragma CM_DEBUG_CODE
/***EP  WUBIOS_Debug - Debugger entry point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_SYSCTRL WUBIOS_Debug(VOID)
{
    CMDMenu(WARNNAME, DebugCmds);
}       //WUBIOS_Debug

#ifdef TRACING
/***LP  DebugSetTraceLevel - Set Trace Level
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugSetTraceLevel(VOID)
{
    CMDD("\n");
    giTraceLevel = (int)CMDReadNumber("Trace Level", 1, FALSE);
    CMDD("\n\n");
}       //DebugSetTraceLevel

/***LP  DebugToggleTrigMode - Toggle Trace Trigger mode
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugToggleTrigMode(VOID)
{
    dwfTrace ^= TF_TRIG_MODE;
    if (!(dwfTrace & TF_TRIG_MODE))
        dwcTriggers = 0;
    CMDD("\nTrace Trigger Mode is %s\n\n",
         (dwfTrace & TF_TRIG_MODE)? "On": "Off");
}       //DebugToggleTrigMode

/***LP  DebugClearTrigPts - Clear all trace trigger points
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugClearTrigPts(VOID)
{
    BYTE i;

    for (i = 0; i < MAX_TRIG_PTS; ++i)
        aszTrigPtBuff[i][0] = '\0';

    CMDD("\n");
}       //DebugClearTrigPts

/***LP  DebugAddTrigPt - Add a trace trigger point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugAddTrigPt(VOID)
{
    char szTrigPt[MAX_TRIGPT_LEN + 1];
    BYTE i;

    CMDD("\n");
    GetString("Trigger Point", szTrigPt, sizeof(szTrigPt), TRUE);
    CMDD("\n");
    for (i = 0; i < MAX_TRIG_PTS; ++i)
    {
        if (aszTrigPtBuff[i][0] == '\0')
        {
            _lstrcpyn(aszTrigPtBuff[i], szTrigPt, MAX_TRIGPT_LEN + 1);
            break;
        }
    }

    if (i == MAX_TRIG_PTS)
        CMDD("No free trigger point.\n");

    CMDD("\n");
}       //DebugAddTrigPt

/***LP  DebugZapTrigPt - Delete a trace trigger point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugZapTrigPt(VOID)
{
    BYTE i, bcTrigPts;

    CMDD("\n");
    for (i = 0, bcTrigPts = 0; i < MAX_TRIG_PTS; ++i)
    {
        if (aszTrigPtBuff[i][0] != '\0')
        {
            CMDD("%2d: %s\n", i, &aszTrigPtBuff[i][0]);
            bcTrigPts++;
        }
    }

    if (bcTrigPts > 0)
    {
        CMDD("\n");
        i = (BYTE)CMDReadNumber("Trigger Point", 1, FALSE);
        CMDD("\n");

        if ((i < MAX_TRIG_PTS) && (aszTrigPtBuff[i][0] != '\0'))
            aszTrigPtBuff[i][0] = '\0';
        else
            CMDD("Invalid Trace Trigger Point.\n");
    }
    else
        CMDD("No Trace Trigger Point set.\n");

    CMDD("\n");
}       //DebugZapTrigPt

/***LP  GetString - Read a string from the debug terminal
 *
 *  ENTRY
 *      pszPrompt -> prompt string
 *      pszBuff -> buffer to hold the string
 *      bcLen - buffer length
 *      fUpper - TRUE if convert to upper case
 *
 *  EXIT
 *      always returns pszBuff
 */

PCHAR CM_LOCAL GetString(PCHAR pszPrompt, PCHAR pszBuff, BYTE bcLen, BOOL fUpper)
{
    BYTE i, ch;

    CMDD("%s: ", pszPrompt);
    for (i = 0; i < bcLen - 1; ++i)
    {
        ch = CMDInChar();

        if ((ch == '\r') || (ch == '\n'))
            break;
        else if (ch == '\b')
        {
            if (i > 0)
                i -= 2;
        }
        else if (fUpper && (ch >= 'a') && (ch <= 'z'))
            pszBuff[i] = (BYTE)(ch - 'a' + 'A');
        else if ((ch < ' ') || (ch > '~'))
        {
            ch = '\a';          //change it to a BELL character
            i--;                //don't store it
        }
        else
            pszBuff[i] = ch;

        CMDD("%c", ch);
    }
    pszBuff[i] = '\0';

    return pszBuff;
}       //GetString
#endif  //ifdef TRACING
#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\wubiosp.h ===
/*** wubiosp.h - WindowsUpdate BIOS Scanning VxD Private Definitions
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _WUBIOSP_H
#define _WUBIOSP_H

/*XLATOFF*/
#define CM_PERFORMANCE_INFO
#include <basedef.h>
#include <vmm.h>
#define USECMDWRAPPERS
#include <vxdwraps.h>
#include <configmg.h>
#include <vwin32.h>
#include <winerror.h>
#include "wubios.h"
/*XLATON*/

/*** Build Options
 */

#ifdef DEBUG
  #define TRACING
  #define DEBUGGER
#endif  //DEBUG

/*** Constants
 */

#define WARNNAME                "WUBIOS"

/*XLATOFF*/
#pragma intrinsic(memcpy)

/*** Global Data
 */

#ifdef TRACING
extern int giIndent;
#endif

/*** Macros
 */

#define DEREF(x)        ((x) = (x))

#ifdef TRACING
  BOOL CM_LOCAL IsTraceOn(BYTE n, char *pszProcName, BOOL fEnter);
  #define TRACENAME(s)  char *pszTraceName = s;
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, pszTraceName, TRUE))       \
                                CMDD p;                                 \
                            ++giIndent;                                 \
                        }
  #define EXIT(n,p)     {                                               \
                            --giIndent;                                 \
                            if (IsTraceOn(n, pszTraceName, FALSE))      \
                                CMDD p;                                 \
                        }
#else
  #define TRACENAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif  //TRACING

#ifdef DEBUGGER
VOID CM_SYSCTRL WUBIOS_Debug(VOID);
#endif

#ifdef DEBUG
  #define DBG_PRINTF(str)   _Debug_Printf_Service##str
  #define DBG_WARN(str)  {                              \
        _Debug_Printf_Service(WARNNAME ":WARNS:");      \
        _Debug_Printf_Service##str;                     \
        _Debug_Printf_Service("\n");                    \
  }
  #define DBG_ERR(str)  {                               \
        _Debug_Printf_Service(WARNNAME ":ERROR:");      \
        _Debug_Printf_Service##str;                     \
        _Debug_Printf_Service("\n");                    \
        _asm int 3                                      \
  }
  #define ASSERT(x)     if (!(x))                                           \
                            DBG_ERR(("Assertion failed: file %s, line %d",  \
                                     __FILE__, __LINE__))
#else
  #define DBG_PRINTF(str)
  #define DBG_WARN(str)
  #define DBG_ERR(str)
  #define ASSERT(x)
#endif  //DEBUG
/*XLATON*/


/*** Functions prototipes
 */
CM_VXD_RESULT CM_SYSCTRL WUBIOS_IOCtrl(PDIOCPARAMETERS pdioc);
BYTE CM_INTERNAL CheckSum(PBYTE pb, DWORD dwLen);

/*** ACPI
 */
DWORD CM_INTERNAL AcpiFindTable(DWORD dwSig, PDWORD pdwLen);
VOID CM_INTERNAL AcpiCopyROM(DWORD dwPhyAddr, PBYTE pbBuff, DWORD dwLen);


/*** SMBIOS 
 */
DWORD CM_INTERNAL SmbStructSize(void);
CM_VXD_RESULT CM_INTERNAL SmbCopyStruct(DWORD dwType, PBYTE pbBuff, DWORD dwLen);
DWORD CM_INTERNAL PnpOEMID(void);
#endif  //ifndef _ACPITABP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\basedef.h ===
/***    BASEDEF.H
 *
 *      Basic constants and types for the VMM and VxDs
 *      Copyright (c) 1988,1989 Microsoft Corporation
 *
 *      NOBASEDEFS turns off the base definations
 */

#ifndef NOBASEDEFS
#define NOBASEDEFS

/*
 *  No warnings generated on non-standard usuage such as double
 *  slash for comments
 */
#pragma warning (disable:4206)
#pragma warning (disable:4214)
#pragma warning (disable:4201)
#pragma warning (disable:4505)
#pragma warning (disable:4514)
#pragma warning (disable:4001)

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE	1
#endif
#ifndef NULL
#define NULL    '\0'                    // Null pointer
#endif

#define CDECL   _cdecl
#define PASCAL  _pascal
#define VOID    void
#define CONST   const
#define VOLATILE volatile

typedef int INT;                        // i
typedef unsigned int UINT;              // u
typedef int BOOL;                       // f

typedef unsigned char BYTE;             // b
typedef unsigned short WORD;            // w
typedef unsigned long DWORD;            // dw

#ifndef _H2INC

typedef struct qword_s {                /* qword */
   DWORD qword_lo;
   DWORD qword_hi;
} QWORD;				// qw

#endif

#ifndef	_NTDEF_

typedef char CHAR;                      // ch
typedef unsigned char UCHAR;            // uch
typedef short SHORT;                    // s
typedef unsigned short USHORT;          // us
typedef long LONG;                      // l
typedef unsigned long ULONG;            // ul

typedef UCHAR *PSZ;                     // psz
typedef VOID *PVOID;                    // p
typedef PVOID *PPVOID;                  // pp

/*XLATOFF*/

#if (_MSC_VER >= 900)

#if (!defined(MIDL_PASS) || defined(__midl))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
struct _LARGE_INTEGER {
#else // MIDL_PASS
union _LARGE_INTEGER {
    struct _LARGE_INTERGER1 {
        ULONG LowPart;
        LONG HighPart;
    };
    struct _LARGE_INTERGER2 {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
};

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER LARGE_INTEGER;
#else
typedef union _LARGE_INTEGER LARGE_INTEGER;
#endif

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
struct _ULARGE_INTEGER {
#else // MIDL_PASS
union _ULARGE_INTEGER {
    struct _LARGE_INTERGER3 {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct _LARGE_INTERGER4 {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
};

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER ULARGE_INTEGER;
#else
typedef union _ULARGE_INTEGER ULARGE_INTEGER;
#endif

typedef ULARGE_INTEGER *PULARGE_INTEGER;

#else	// of MSC_VER > 900

#ifndef _H2INC

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef struct _ULARGE_INTEGER {
	ULONG LowPart;
	ULONG HighPart;
} ULARGE_INTEGER;

#endif 

#endif 

/*XLATON*/

#else

typedef PVOID *PPVOID;                  // pp

#endif 

typedef INT *PINT;                      // pi
typedef UINT *PUINT;                    // pu
typedef BYTE *PBYTE;                    // pb
typedef WORD *PWORD;                    // pw
typedef DWORD *PDWORD;                  // pdw
typedef CHAR *PCHAR;                    // pch
typedef SHORT *PSHORT;                  // ps
typedef LONG *PLONG;                    // pl
typedef UCHAR *PUCHAR;                  // puch
typedef USHORT *PUSHORT;                // pus
typedef ULONG *PULONG;                  // pul
typedef BOOL *PBOOL;                    // pf

typedef UCHAR SZ[];                     // sz
typedef UCHAR SZZ[];                    // szz
typedef UCHAR *PSZZ;                    // pszz

typedef USHORT SEL;                     // sel
typedef SEL *PSEL;                      // psel

typedef ULONG PPHYS;                    // pphys

typedef (*PFN)();                       // pfn
typedef PFN *PPFN;                      // ppfn

typedef PVOID HANDLE;                   // h
typedef HANDLE *PHANDLE;                // ph

typedef ULONG HTIMEOUT;			// timeout handle
typedef ULONG CMS;			// count of milliseconds

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))

#endif // NOBASEDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\pshpack1.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\configmg.h ===
/*****************************************************************************
 *
 *	(C) Copyright MICROSOFT Corp., 1993
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *	Date:		02-Feb-1993
 *
 *	Authors:	PYS & RAL
 *
 *------------------------------------------------------------------------------
 *
 *	Change log:
 *
 *	   DATE     REV DESCRIPTION
 *	----------- --- -----------------------------------------------------------
 *	02-Feb-1993 PYS Original
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#ifdef	WIN40COMPAT

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#define	ASD_SUPPORT		1
#define	ASSERT_STRING_SUPPORT	1

#else

#define	CONFIGMG_VERSION	0x040A

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x000A

#define	ASD_SUPPORT		0
#define	ASSERT_STRING_SUPPORT	0

#endif

#define	CONFIGMG_W32IOCTL_RANGE	0x80000000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

#ifdef	GOLDEN
#ifndef	DEBUG
#define	CM_GOLDEN_RETAIL
#endif
#endif

/*XLATOFF*/
#include <pshpack1.h>
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"None", \
	"Mem ", \
	"IO  ", \
	"DMA ", \
	"IRQ ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32
#define	fMD_Pref		4		// Memory range is Prefetch
#define	fMD_CombinedWrite	8		// Memory range is write combineable (no effect, for WDM only)
#define	fMD_Cacheable		0x10		// Memory range is cacheable (no effect, for WDM only)

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0x0003		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share_Bit		0			// IRQ can be shared
#define	fIRQD_Share		1			// IRQ can be shared
#define	fIRQD_Level_Bit		1			// IRQ is level (PCI)
#define	fIRQD_Level		2			// IRQ is level (PCI)
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_HARDWIRED		0x0000E000
#define	LCPRI_IMPOSSIBLE	0x0000F000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#define CM_FIRST_BOOT_START     0x00000001
#define CM_FIRST_BOOT           0x00000002
#define CM_FIRST_BOOT_FINISH    0x00000004
#define CM_QUEUE_REBOOT_START   0x00000008
#define CM_QUEUE_REBOOT_FINISH  0x00000010
#define CM_INSTALL_MEDIA_READY  0x00000020

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
//
// 4.0 OPK2 Services
//
CONFIGMG_Service	(_CONFIGMG_Change_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reprocess_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Assert_Structure, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Discard_Boot_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Dependent_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Dependent_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Refilter_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Merge_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Substract_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_DevNode_PowerState, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_PowerState, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_DevNode_PowerCapabilities, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_PowerCapabilities, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Set_Log_Conf_Priority, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Support_Share_Irq, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent_Structure, VxD_CODE)
//
// 4.1 Services
//
CONFIGMG_Service	(_CONFIGMG_Register_DevNode_For_Idle_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CM_To_ISAPNP, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Detect_Resource_Conflict, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Interface_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Interface_List_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Conflict_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Remove_DevNode_Property, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Interface, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_System_Device_Power_State_Mapping, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Arbitrator_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Waking_Up_From_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_DevNode_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Interface_Alias, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"_CONFIGMG_Get_Version", \
	"_CONFIGMG_Initialize", \
	"_CONFIGMG_Locate_DevNode", \
	"_CONFIGMG_Get_Parent", \
	"_CONFIGMG_Get_Child", \
	"_CONFIGMG_Get_Sibling", \
	"_CONFIGMG_Get_Device_ID_Size", \
	"_CONFIGMG_Get_Device_ID", \
	"_CONFIGMG_Get_Depth", \
	"_CONFIGMG_Get_Private_DWord", \
	"_CONFIGMG_Set_Private_DWord", \
	"_CONFIGMG_Create_DevNode", \
	"_CONFIGMG_Query_Remove_SubTree", \
	"_CONFIGMG_Remove_SubTree", \
	"_CONFIGMG_Register_Device_Driver", \
	"_CONFIGMG_Register_Enumerator", \
	"_CONFIGMG_Register_Arbitrator", \
	"_CONFIGMG_Deregister_Arbitrator", \
	"_CONFIGMG_Query_Arbitrator_Free_Size", \
	"_CONFIGMG_Query_Arbitrator_Free_Data", \
	"_CONFIGMG_Sort_NodeList", \
	"_CONFIGMG_Yield", \
	"_CONFIGMG_Lock", \
	"_CONFIGMG_Unlock", \
	"_CONFIGMG_Add_Empty_Log_Conf", \
	"_CONFIGMG_Free_Log_Conf", \
	"_CONFIGMG_Get_First_Log_Conf", \
	"_CONFIGMG_Get_Next_Log_Conf", \
	"_CONFIGMG_Add_Res_Des", \
	"_CONFIGMG_Modify_Res_Des", \
	"_CONFIGMG_Free_Res_Des", \
	"_CONFIGMG_Get_Next_Res_Des", \
	"_CONFIGMG_Get_Performance_Info", \
	"_CONFIGMG_Get_Res_Des_Data_Size", \
	"_CONFIGMG_Get_Res_Des_Data", \
	"_CONFIGMG_Process_Events_Now", \
	"_CONFIGMG_Create_Range_List", \
	"_CONFIGMG_Add_Range", \
	"_CONFIGMG_Delete_Range", \
	"_CONFIGMG_Test_Range_Available", \
	"_CONFIGMG_Dup_Range_List", \
	"_CONFIGMG_Free_Range_List", \
	"_CONFIGMG_Invert_Range_List", \
	"_CONFIGMG_Intersect_Range_List", \
	"_CONFIGMG_First_Range", \
	"_CONFIGMG_Next_Range", \
	"_CONFIGMG_Dump_Range_List", \
	"_CONFIGMG_Load_DLVxDs", \
	"_CONFIGMG_Get_DDBs", \
	"_CONFIGMG_Get_CRC_CheckSum", \
	"_CONFIGMG_Register_DevLoader", \
	"_CONFIGMG_Reenumerate_DevNode", \
	"_CONFIGMG_Setup_DevNode", \
	"_CONFIGMG_Reset_Children_Marks", \
	"_CONFIGMG_Get_DevNode_Status", \
	"_CONFIGMG_Remove_Unmarked_Children", \
	"_CONFIGMG_ISAPNP_To_CM", \
	"_CONFIGMG_CallBack_Device_Driver", \
	"_CONFIGMG_CallBack_Enumerator", \
	"_CONFIGMG_Get_Alloc_Log_Conf", \
	"_CONFIGMG_Get_DevNode_Key_Size", \
	"_CONFIGMG_Get_DevNode_Key", \
	"_CONFIGMG_Read_Registry_Value", \
	"_CONFIGMG_Write_Registry_Value", \
	"_CONFIGMG_Disable_DevNode", \
	"_CONFIGMG_Enable_DevNode", \
	"_CONFIGMG_Move_DevNode", \
	"_CONFIGMG_Set_Bus_Info", \
	"_CONFIGMG_Get_Bus_Info", \
	"_CONFIGMG_Set_HW_Prof", \
	"_CONFIGMG_Recompute_HW_Prof", \
	"_CONFIGMG_Query_Change_HW_Prof", \
	"_CONFIGMG_Get_Device_Driver_Private_DWord", \
	"_CONFIGMG_Set_Device_Driver_Private_DWord", \
	"_CONFIGMG_Get_HW_Prof_Flags", \
	"_CONFIGMG_Set_HW_Prof_Flags", \
	"_CONFIGMG_Read_Registry_Log_Confs", \
	"_CONFIGMG_Run_Detection", \
	"_CONFIGMG_Call_At_Appy_Time", \
	"_CONFIGMG_Fail_Change_HW_Prof", \
	"_CONFIGMG_Set_Private_Problem", \
	"_CONFIGMG_Debug_DevNode", \
	"_CONFIGMG_Get_Hardware_Profile_Info", \
	"_CONFIGMG_Register_Enumerator_Function", \
	"_CONFIGMG_Call_Enumerator_Function", \
	"_CONFIGMG_Add_ID", \
	"_CONFIGMG_Find_Range", \
	"_CONFIGMG_Get_Global_State", \
	"_CONFIGMG_Broadcast_Device_Change_Message", \
	"_CONFIGMG_Call_DevNode_Handler", \
	"_CONFIGMG_Remove_Reinsert_All", \
	"_CONFIGMG_Change_DevNode_Status", \
	"_CONFIGMG_Reprocess_DevNode", \
	"_CONFIGMG_Assert_Structure", \
	"_CONFIGMG_Discard_Boot_Log_Conf", \
	"_CONFIGMG_Set_Dependent_DevNode", \
	"_CONFIGMG_Get_Dependent_DevNode", \
	"_CONFIGMG_Refilter_DevNode", \
	"_CONFIGMG_Merge_Range_List", \
	"_CONFIGMG_Substract_Range_List", \
	"_CONFIGMG_Set_DevNode_PowerState", \
	"_CONFIGMG_Get_DevNode_PowerState", \
	"_CONFIGMG_Set_DevNode_PowerCapabilities", \
	"_CONFIGMG_Get_DevNode_PowerCapabilities", \
	"_CONFIGMG_Read_Range_List", \
	"_CONFIGMG_Write_Range_List", \
	"_CONFIGMG_Get_Set_Log_Conf_Priority", \
	"_CONFIGMG_Support_Share_Irq", \
	"_CONFIGMG_Get_Parent_Structure", \
	"_CONFIGMG_Register_For_Idle_Detection", \
	"_CONFIGMG_CM_To_ISAPNP", \
	"_CONFIGMG_Get_DevNode_Handler", \
	"_CONFIGMG_Detect_Resource_Conflict", \
	"_CONFIGMG_Get_Device_Interface_List", \
	"_CONFIGMG_Get_Device_Interface_List_Size", \
	"_CONFIGMG_Get_Conflict_Info", \
	"_CONFIGMG_Add_Remove_DevNode_Property", \
	"_CONFIGMG_CallBack_At_Appy_Time", \
	"_CONFIGMG_Register_Device_Interface", \
	"_CONFIGMG_System_Device_Power_State_Mapping", \
	"_CONFIGMG_Get_Arbitrator_Info", \
	"_CONFIGMG_Waking_Up_From_DevNode", \
	"_CONFIGMG_Set_DevNode_Problem", \
	"_CONFIGMG_Get_Device_Interface_Alias", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	PRIORITY	CMFAR	*PPRIORITY;	// Pointer to a priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

#ifdef	_NTDDK_
typedef	DEVICE_POWER_STATE	PSMAPPING[PowerSystemMaximum];
#else
typedef	VOID			PSMAPPING;
#endif

typedef	PSMAPPING	CMFAR	*PPSMAPPING;

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

/****************************************************************************
 *
 * Arbitration list structures (they must be key in sync with CONFIGMG's
 * local.h own structure).
 *
 ***************************************************************************/
typedef	struct nodelist_s	NODELIST;
typedef	NODELIST		CMFAR *PNODELIST;
typedef	PNODELIST		CMFAR *PPNODELIST;

struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	DEVNODE			nl_ItsDevNode;		// The dev node it represent
	LOG_CONF	 	nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct nodelist_s	*nlh_Head;		// First node element
	struct nodelist_s	*nlh_Tail;		// Last node element
};

typedef	struct nodelistheader_s	NODELISTHEADER;
typedef	NODELISTHEADER		CMFAR *PNODELISTHEADER;

/*XLATOFF*/
struct	arbitfree_s {
	PFARVOID		af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};
/*XLATON*/
/* ASM
arbitfree_s 	STRUC
	af_PointerToInfo	dd	?
	af_SizeOfInfo		dd	?
arbitfree_s 	ENDS
*/
typedef	struct	arbitfree_s	ARBITFREE;
typedef	ARBITFREE		CMFAR *PARBITFREE;

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, PNODELISTHEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPES
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040
#define	BusType_ACPI		0x00000080
#define	BusType_IDE		0x00000100
#define	BusType_MF		0x00000200

/****************************************************************************
 *
 *				CONFIGURATION MANAGER STRUCTURE TYPES
 *
 ***************************************************************************/
#define	CMAS_UNKNOWN		0x00000000
#define	CMAS_DEVNODE		0x00000001
#define	CMAS_LOG_CONF		0x00000002
#define	CMAS_RES_DES		0x00000003
#define	CMAS_RANGELIST_HEADER	0x00000004
#define	CMAS_RANGELIST		0x00000005
#define	CMAS_NODELIST_HEADER	0x00000006
#define	CMAS_NODELIST		0x00000007
#define	CMAS_INTERNAL_RES_DES	0x00000008
#define	CMAS_ARBITRATOR		0x00000009

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS			0x00000000
#define	CR_DEFAULT			0x00000001
#define	CR_OUT_OF_MEMORY		0x00000002
#define	CR_INVALID_POINTER		0x00000003
#define	CR_INVALID_FLAG			0x00000004
#define	CR_INVALID_DEVNODE		0x00000005
#define	CR_INVALID_RES_DES		0x00000006
#define	CR_INVALID_LOG_CONF		0x00000007
#define	CR_INVALID_ARBITRATOR		0x00000008
#define	CR_INVALID_NODELIST		0x00000009
#define	CR_DEVNODE_HAS_REQS		0x0000000A
#define	CR_INVALID_RESOURCEID		0x0000000B
#define	CR_DLVXD_NOT_FOUND		0x0000000C
#define	CR_NO_SUCH_DEVNODE		0x0000000D
#define	CR_NO_MORE_LOG_CONF		0x0000000E
#define	CR_NO_MORE_RES_DES		0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE		0x00000010
#define	CR_INVALID_RANGE_LIST		0x00000011
#define	CR_INVALID_RANGE		0x00000012
#define	CR_FAILURE			0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV		0x00000014
#define	CR_CREATE_BLOCKED		0x00000015
#define	CR_NOT_A_GOOD_TIME		0x00000016
#define	CR_REMOVE_VETOED		0x00000017
#define	CR_APM_VETOED			0x00000018
#define	CR_INVALID_LOAD_TYPE		0x00000019
#define	CR_BUFFER_SMALL			0x0000001A
#define	CR_NO_ARBITRATOR		0x0000001B
#define	CR_NO_REGISTRY_HANDLE		0x0000001C
#define	CR_REGISTRY_ERROR		0x0000001D
#define	CR_INVALID_DEVICE_ID		0x0000001E
#define	CR_INVALID_DATA			0x0000001F
#define	CR_INVALID_API			0x00000020
#define	CR_DEVLOADER_NOT_READY		0x00000021
#define	CR_NEED_RESTART			0x00000022
#define	CR_NO_MORE_HW_PROFILES		0x00000023
#define	CR_DEVICE_NOT_THERE		0x00000024
#define	CR_NO_SUCH_VALUE		0x00000025
#define	CR_WRONG_TYPE			0x00000026
#define	CR_INVALID_PRIORITY		0x00000027
#define	CR_NOT_DISABLEABLE		0x00000028
#define	CR_FREE_RESOURCES		0x00000029
#define	CR_QUERY_VETOED			0x0000002A
#define	CR_CANT_SHARE_IRQ		0x0000002B
//
// 4.0 OPK2 results
//
#define	CR_NO_DEPENDENT			0x0000002C
//
// 4.1 OPK2 results
//
#define	CR_SAME_RESOURCES		0x0000002D
#define	CR_ALREADY_SUCH_DEPENDENT	0x0000002E
#define	NUM_CR_RESULTS			0x0000002F

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_A_GOOD_TIME", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_NO_MORE_HW_PROFILES", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_FREE_RESOURCES", \
	"CR_QUERY_VETOED", \
	"CR_CANT_SHARE_IRQ", \
	"CR_NO_DEPENDENT", \
	"CR_SAME_RESOURCES", \
	"CR_ALREADY_SUCH_DEPENDENT", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_ASD_FAILED			0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	CM_PROB_FAILED_INSTALL			0x0000001C
#define	CM_PROB_HARDWARE_DISABLED		0x0000001D
#define	CM_PROB_CANT_SHARE_IRQ			0x0000001E

//
// 4.0 OPK2 Problems
//
#define	CM_PROB_DEPENDENT_PROBLEM		0x0000001F

//
// 4.1 Problems
//
#define CM_PROB_INSTALL_MEDIA_NOT_READY		0x00000020
#define CM_PROB_HARDWARE_MALFUNCTION		0x00000021
#define NUM_CM_PROB				0x00000022

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"ASD check failed", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
	"Failed install", \
	"Hardware Disabled", \
	"Can't share IRQ", \
	"Dependent failed", \
	"Install media not ready", \
	"Hardware malfunction", \
};

/*XLATON*/

//
// Flags to be passed in the various APIs
//

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_BITS			0x00000000

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_LOCK_UNLOCK_NORMAL			0x00000000
#define	CM_LOCK_UNLOCK_JUST_DEVNODES_CHANGED	0x00000001
#define	CM_LOCK_UNLOCK_BITS			0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_ADD_PARENT_INSTANCE	0x00000002
#define	CM_CREATE_DEVNODE_BITS			0x00000003

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_SYNCHRONOUS	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_ASYNCHRONOUS	0x00000004
#define	CM_REGISTER_DEVICE_DRIVER_ACPI_APM	0x00000008
#define	CM_REGISTER_DEVICE_DRIVER_LOAD_DRIVER	0x00000010
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x0000001F

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_ACPI_APM		0x00000002
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000003

#define	CM_REGISTER_ARBITRATOR_GLOBAL		0x00000001
#define	CM_REGISTER_ARBITRATOR_LOCAL		0x00000000
#define	CM_REGISTER_ARBITRATOR_MYSELF		0x00000002
#define	CM_REGISTER_ARBITRATOR_NOT_MYSELF	0x00000000
#define	CM_REGISTER_ARBITRATOR_CONFLICT_FREE	0x00000004
#define	CM_REGISTER_ARBITRATOR_CAN_CONFLICT	0x00000000
#define	CM_REGISTER_ARBITRATOR_PARTIAL		0x00000008
#define	CM_REGISTER_ARBITRATOR_COMPLETE		0x00000000
#define	CM_REGISTER_ARBITRATOR_PARTIAL_RES_DES	0x00000010
#define	CM_REGISTER_ARBITRATOR_PARTIAL_DEVNODE	0x00000000
#define	CM_REGISTER_ARBITRATOR_BITS		0x0000001F

#define	CM_QUERY_REMOVE_UI_OK			0x00000000
#define	CM_QUERY_REMOVE_UI_NOT_OK		0x00000001
#define	CM_QUERY_REMOVE_BITS			0x00000001

#define	CM_REMOVE_UI_OK				0x00000000
#define	CM_REMOVE_UI_NOT_OK			0x00000001
#define	CM_REMOVE_BITS				0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_WRITE_LOG_CONFS		0x00000002
#define	CM_SETUP_PROP_CHANGE			0x00000003
#define	CM_SETUP_BITS				0x00000003

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_BUS_INFO_DONT_RETURN_MF_INFO	0x00000000
#define	CM_GET_BUS_INFO_RETURN_MF_INFO		0x00000001
#define	CM_GET_BUS_INFO_FLAGS			0x00000001

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_DUMP_RANGE_NORMAL			0x00000000
#define	CM_DUMP_RANGE_JUST_LIST			0x00000001
#define	CM_DUMP_RANGE_BITS			0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_HARDWARE			0x00000002	// Don't ask the driver, and won't be restarteable
#define	CM_DISABLE_BITS				0x00000003	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define CM_DETECT_TOPBUSONLY			0x00000008	// detect only top level bus
#define CM_DETECT_VERIFYONLY			0x00000010	// verify, dont detect
#define CM_DETECT_EXCLENUMDEVS			0x00000020	// exclude enum devs
#define CM_DETECT_DOUI				0x00000040	// detect all HW
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

#define	CM_BROADCAST_SEND			0x00000000
#define	CM_BROADCAST_QUERY			0x00000001
#define	CM_BROADCAST_BITS			0x00000001

#define	CM_CALL_HANDLER_ENUMERATOR		0x00000000
#define	CM_CALL_HANDLER_DEVICE_DRIVER		0x00000001
#define	CM_CALL_HANDLER_BITS			0x00000001

#define	CM_GLOBAL_STATE_CAN_DO_UI		0x00000001
#define	CM_GLOBAL_STATE_ON_BIG_STACK		0x00000002
#define	CM_GLOBAL_STATE_SERVICES_AVAILABLE	0x00000004
#define	CM_GLOBAL_STATE_SHUTING_DOWN		0x00000008
#define	CM_GLOBAL_STATE_DETECTION_PENDING	0x00000010
#define	CM_GLOBAL_STATE_ON_BATTERY		0x00000020
#define	CM_GLOBAL_STATE_SUSPEND_PHASE		0x00000040
#define	CM_GLOBAL_STATE_SUSPEND_LOCKED_PHASE	0x00000080
#define	CM_GLOBAL_STATE_REBALANCE		0x00000100
#define	CM_GLOBAL_STATE_LOGGING_ON		0x00000200

#define	CM_REMOVE_REINSERT_ALL_REMOVE		0x00000000
#define	CM_REMOVE_REINSERT_ALL_REINSERT		0x00000001
#define	CM_REMOVE_REINSERT_ALL_BITS		0x00000001

#define	CM_CHANGE_DEVNODE_STATUS_REMOVE_FLAGS	0x00000000
#define	CM_CHANGE_DEVNODE_STATUS_ADD_FLAGS	0x00000001
#define	CM_CHANGE_DEVNODE_STATUS_BITS		0x00000001

#define	CM_REPROCESS_DEVNODE_ASYNCHRONOUS	0x00000000
#define	CM_REPROCESS_DEVNODE_SYNCHRONOUS	0x00000001
#define	CM_REPROCESS_DEVNODE_BITS		0x00000001

//
// SET_DEVNODE_POWERSTATE_PERSISTANT is ignored in 4.1. You need to call
// Set_DevNode_Property(CM_PROPERTY_ARM_WAKEUP).
//
//#define CM_SET_DEVNODE_POWERSTATE_PERSISTANT    0x00000001
#define CM_SET_DEVNODE_POWERSTATE_BITS          0x00000001

#define CM_POWERSTATE_D0                        0x00000001
#define CM_POWERSTATE_D1			0x00000002
#define CM_POWERSTATE_D2                        0x00000004
#define CM_POWERSTATE_D3                        0x00000008
#define CM_POWERSTATE_BITS                      0x0000000f

#define	CM_CAPABILITIES_NORMAL			0x00000000
#define	CM_CAPABILITIES_FOR_WAKEUP		0x00000001
#define	CM_CAPABILITIES_OVERRIDE		0x00000002	// Should be used by ACPI only
#define	CM_CAPABILITIES_MERGE			0x00000000
#define	CM_GET_CAPABILITIES_BITS		0x00000001
#define	CM_SET_CAPABILITIES_BITS		0x00000003

#define	CM_CM_TO_ISAPNP_NORMAL			0x00000000
#define	CM_CM_TO_ISAPNP_FAIL_NUL_TAGS		0x00000001
#define	CM_CM_TO_ISAPNP_BITS			0x00000001

#define	CM_SET_DEPENDENT_DEVNODE_ADD		0x00000000
#define	CM_SET_DEPENDENT_DEVNODE_REMOVE		0x00000001
#define	CM_SET_DEPENDENT_DEVNODE_BITS		0x00000001

#define	CM_GET_DEVNODE_HANDLER_CONFIG		0x00000000
#define	CM_GET_DEVNODE_HANDLER_ENUM		0x00000001
#define	CM_GET_DEVNODE_HANDLER_BITS		0x00000001

#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT		0x00000000  // only currently 'live' devices
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES	0x00000001  // all registered devices, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS		0x00000001

#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_ADD		0x00000000
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_REMOVE		0x00000001
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_NEEDS_LOCKING	0x00000002
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_ARM_WAKEUP	0x00000004
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_LIGHT_SLEEP	0x00000008
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_BITS		0x0000000F

#define	CM_SYSTEM_DEVICE_POWER_STATE_MAPPING_GET	0x00000000
#define	CM_SYSTEM_DEVICE_POWER_STATE_MAPPING_SET	0x00000001
#define	CM_SYSTEM_DEVICE_POWER_STATE_MAPPING_BITS	0x00000001

#define	CM_WAKING_UP_FROM_DEVNODE_ASYNCHRONOUS		0x00000000
#define	CM_WAKING_UP_FROM_DEVNODE_SYNCHRONOUS		0x00000001
#define	CM_WAKING_UP_FROM_DEVNODE_BITS			0x00000001

#define	CM_GET_LOG_CONF_PRIORITY			0x00000000
#define	CM_SET_LOG_CONF_PRIORITY			0x00000001
#define	CM_GET_SET_LOG_CONF_PRIORITY_BITS		0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.
#define	CONFIG_PROP_CHANGE	0x00000010	// The property page is exiting.
#define	CONFIG_PRIVATE		0x00000011	// Someone called Call_Handler.
#define	CONFIG_PRESHUTDOWN	0x00000012	// We are shutting down
#define	CONFIG_BEGIN_PNP_MODE	0x00000013	// We will start configuring PNP devs.
#define	CONFIG_LOCK		0x00000014	// Gets call during suspend
#define	CONFIG_UNLOCK		0x00000015	// Gets call during resume
#define CONFIG_IRP		0x00000016	// IRP from WDM driver
#define	CONFIG_WAKEUP		0x00000017	// Please arm/disarm the wake up.
#define	CONFIG_WAKEUP_CALLBACK	0x00000018	// You are waking up

#define	NUM_CONFIG_COMMANDS	0x00000019	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
	"CONFIG_PROP_CHANGE", \
	"CONFIG_PRIVATE", \
	"CONFIG_PRESHUTDOWN", \
	"CONFIG_BEGIN_PNP_MODE", \
	"CONFIG_LOCK", \
	"CONFIG_UNLOCK", \
	"CONFIG_IRP", \
	"CONFIG_WAKEUP", \
	"CONFIG_WAKEUP_CALLBACK", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001
#define	CONFIG_START_SHUTDOWN_START			0x00000002

#define NUM_START_COMMANDS				0x00000003

/*XLATOFF*/

#define DEBUG_START_NAMES \
char	CMFAR *lpszStartName[NUM_START_COMMANDS] = \
{ \
    	"DYNAMIC_START", \
	"FIRST_START", \
	"SHUTDOWN_START", \
};

/*XLATON*/

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

#define NUM_STOP_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_STOP_NAMES \
char	CMFAR *lpszStopName[NUM_STOP_COMMANDS] = \
{ \
    	"DYNAMIC_STOP", \
	"HAS_PROBLEM", \
};

/*XLATON*/

//
// For both CONFIG_REMOVE, CONFIG_PREREMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_SHUTDOWN_OFF				0x00000000
#define	CONFIG_SHUTDOWN_REBOOT				0x00000001

#define NUM_REMOVE_COMMANDS				0x00000003

/*XLATOFF*/

#define DEBUG_REMOVE_NAMES \
char	CMFAR *lpszRemoveName[NUM_REMOVE_COMMANDS] = \
{ \
    	"DYNAMIC", \
	"SHUTDOWN", \
	"REBOOT", \
};

/*XLATON*/

#define	CONFIG_ENUMERATE_DYNAMIC			0x00000000
#define	CONFIG_ENUMERATE_FIRST_TIME			0x00000001

#define NUM_ENUMERATE_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_ENUMERATE_NAMES \
char	CMFAR *lpszEnumerateName[NUM_ENUMERATE_COMMANDS] = \
{ \
    	"DYNAMIC", \
	"FIRST_TIME", \
};

/*XLATON*/

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define NUM_TEST_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_TEST_NAMES \
char	CMFAR *lpszTestName[NUM_TEST_COMMANDS] = \
{ \
    	"CAN_STOP", \
	"CAN_REMOVE", \
};

/*XLATON*/

//
// APM changed drastically in 4.1. We do not send the old APM message at all.
// Enumerators/Device Driver
//
//
// APM messages have a flag part (the high part) as well as message number
// part (the low part).
//
#define	CONFIG_APM_FLAGS_MASK				0xFFFFF000

//
// APM flags
//
#define	CONFIG_APM_UI_IS_ALLOWED			0x80000000
#define	CONFIG_APM_SUSPEND_PHASE			0x40000000
#define	CONFIG_APM_SUSPEND_LOCKED_PHASE			0x20000000
#define	CONFIG_APM_ARM_WAKEUP				0x10000000
#define	CONFIG_APM_RESUME_CRITICAL			0x08000000

#define	CONFIG_APM_QUERY_D1				0x00000000
#define	CONFIG_APM_QUERY_D2				0x00000001
#define	CONFIG_APM_QUERY_D3				0x00000002
#define	CONFIG_APM_FAILED_D1				0x00000003
#define	CONFIG_APM_FAILED_D2				0x00000004
#define	CONFIG_APM_FAILED_D3				0x00000005
#define	CONFIG_APM_SET_D0				0x00000006
#define	CONFIG_APM_SET_D1				0x00000007
#define	CONFIG_APM_SET_D2				0x00000008
#define	CONFIG_APM_SET_D3				0x00000009

//
// Normally you shouldn't listen to the resume ones unless you care about
// behing turned on right away on resume.
//
#define	CONFIG_APM_RESUME_D0				0x0000000A
#define	CONFIG_APM_RESUME_D1				0x0000000B
#define	CONFIG_APM_RESUME_D2				0x0000000C
#define	CONFIG_APM_RESUME_D3				0x0000000D

//
// Only NTKern should listen to the following ones.
//
#define	CONFIG_APM_QUERY_S1				0x0000000E
#define	CONFIG_APM_QUERY_S2				0x0000000F
#define	CONFIG_APM_QUERY_S3				0x00000010
#define	CONFIG_APM_QUERY_S4				0x00000011
#define	CONFIG_APM_QUERY_S5				0x00000012
#define	CONFIG_APM_SET_S0				0x00000013
#define	CONFIG_APM_SET_S1				0x00000014
#define	CONFIG_APM_SET_S2				0x00000015
#define	CONFIG_APM_SET_S3				0x00000016
#define	CONFIG_APM_SET_S4				0x00000017
#define	CONFIG_APM_SET_S5				0x00000018

#define NUM_APM_COMMANDS				0x00000019

/*XLATOFF*/

#define DEBUG_APM_NAMES \
char	CMFAR *lpszAPMName[NUM_APM_COMMANDS] = \
{ \
    	"QUERY_D1", \
	"QUERY_D2", \
	"QUERY_D3", \
	"FAILED_D1", \
	"FAILED_D2", \
	"FAILED_D3", \
	"SET_D0", \
	"SET_D1", \
	"SET_D2", \
	"SET_D3", \
	"RESUME_D0", \
	"RESUME_D1", \
	"RESUME_D2", \
	"RESUME_D3", \
	"QUERY_S1", \
	"QUERY_S2", \
	"QUERY_S3", \
	"QUERY_S4", \
	"QUERY_S5", \
	"SET_S0", \
	"SET_S1", \
	"SET_S2", \
	"SET_S3", \
	"SET_S4", \
	"SET_S5", \
};

/*XLATON*/

#define	CONFIG_WAKEUP_ARM				0x00000000
#define	CONFIG_WAKEUP_DISABLE				0x00000001

#define NUM_WAKEUP_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_WAKEUP_NAMES \
char	CMFAR *lpszWakeupName[NUM_WAKEUP_COMMANDS] = \
{ \
    	"ARM", \
	"DISABLE", \
};

/*XLATON*/

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makes no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	4.0 OPK2 Messages
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_QUERY_ARBITRATE - Ask if arbitrator arbitrates this node
 *
 *	DESC:	Local partial arbitrator is passed a one devnode nodelist,
 *		and returns whether it arbitrates for that devnode.
 *
 *	EXIT:	CR_SUCCESS if arbitrator wants to arbitrate this node.
 *		CR_FAILURE if the arbitrator does not arbitrate this node.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_ADD_RESERVE - Tell the arbitrator it should reserve this alloc
 *
 *	DESC:	In 4.0, arbitrators were learning reserve resources
 *		(resources that would be given only during a second pass)
 *		when called with ARB_RETEST/FORCE_ALLOC. However, we can
 *		ARB_RETEST_ALLOC during rebalance, so with 4.0 OPK2 we send a
 *		specific message telling the arbitrator that the resources
 *		in the test_alloc are for a FORCED or BOOT LOG_CONF and thus
 *		should be marked to be given only in a second pass during
 *		an ARB_TEST_ALLOC. This is for optimization only: to avoid
 *		rebalance.
 *
 *	EXIT:	CR_SUCCESS if the arbitrator understand this message and did
 *		something about it.
 *		CR_FAILURE if nothing was done.
 *
 *	CR_DEFAULT is CR_FAILURE.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_WRITE_RESERVE - Tell the arbitrator it should save the reserve
 *		list in the registry
 *
 *	DESC:	If an arbitrator returns CR_SUCCESS to ARB_SET_RESERVE, it
 *		will be called later on to save the reserve list.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_BEGIN_PNP_MODE - Tell the arbitrator that PNP mode is about to be
 *      started.
 *
 *	DESC:	If an arbitrator returns CR_SUCCESS, it understood the message and
 *		performed some action accordingly.
 *
 *	EXIT:	CR_SUCCESS if the arbitrator understand this message and did
 *		something about it.
 *		CR_FAILURE if nothing was done.
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC.
#define	ARB_QUERY_ARBITRATE	0x00000007	// Check if wants to arbitrate.
#define	ARB_ADD_RESERVE		0x00000008	// Mark alloc as reserved.
#define	ARB_WRITE_RESERVE	0x00000009	// Save reserve in registry.
#define	ARB_BEGIN_PNP_MODE  	0x0000000A  	// Tell the arb the start of PNP mode.
#define	ARB_APPLY_ALLOC  	0x0000000B  	// Called after the stop of the rebalance.
#define	NUM_ARB_COMMANDS	0x0000000C	// Number of arb commands.

/*XLATOFF*/
#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
	"ARB_QUERY_ARBITRATE",\
	"ARB_ADD_RESERVE",\
	"ARB_WRITE_RESERVE",\
	"ARB_BEGIN_PNP_MODE",\
	"ARB_APPLY_ALLOC",\
};
/*XLATON*/

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	can be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config start
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed
//
// 4.0 OPK2 Flags
//
#define	DN_NOT_FIRST_TIMEE	0x00080000	// S: Has received a config enumerate
#define	DN_STOP_FREE_RES	0x00100000	// S: When child is stopped, free resources
#define	DN_REBAL_CANDIDATE	0x00200000	// S: Don't skip during rebalance
#define	DN_BAD_PARTIAL		0x00400000	// S: This devnode's log_confs do not have same resources
#define	DN_NT_ENUMERATOR	0x00800000	// S: This devnode's is an NT enumerator
#define	DN_NT_DRIVER		0x01000000	// S: This devnode's is an NT driver
//
// 4.1 Flags
//
#define	DN_NEEDS_LOCKING	0x02000000	// S: Devnode need lock resume processing
#define	DN_ARM_WAKEUP		0x04000000	// S: Devnode can be the wakeup device
#define	DN_APM_ENUMERATOR	0x08000000	// S: APM aware enumerator
#define	DN_APM_DRIVER		0x10000000	// S: APM aware driver
#define	DN_SILENT_INSTALL	0x20000000	// S: Silent install
#define	DN_NO_SHOW_IN_DM	0x40000000	// S: No show in device manager
#define	DN_BOOT_LOG_PROB	0x80000000	// S: Had a problem during preassignment of boot log conf

#define	DN_CHANGEABLE_FLAGS	0x79BB62E0

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000020	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
	"fe", \
	"sf", \
	"rc", \
	"bp", \
	"ze", \
	"zd", \
	"nl", \
	"wk", \
	"ae", \
	"ad", \
	"si", \
	"ns", \
	"bl", \
};

typedef ULONG			VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctWalk;
CMTIME		ctGarbageCollection;
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctAppyTime;
CMTIME		ctSyncAppyTime;
CMTIME		ctAsyncAppyTime;
CMTIME		ctAsyncWorker;
CMTIME		ctWaitForAppy;
CMTIME		ctWaitForWorker;
CMTIME		ctWaitForWorkers;
CMTIME		ctReceiveMessage;
CMTIME		ctRegistryOpen;
CMTIME		ctRegistryCreate;
CMTIME		ctRegistryClose;
CMTIME		ctRegistryRead;
CMTIME		ctRegistryWrite;
CMTIME		ctRegistryEnumKey;
CMTIME		ctRegistryEnumValue;
CMTIME		ctRegistryFlush;
CMTIME		ctRegistryDelete;
CMTIME		ctRegistryOther;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctHeap;
CMTIME		ctAssertRange;
CMTIME		ctASD;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	REALMODE_LOG_CONF	0x00000005	// Specifies the Realmode Log Conf.
#define	NEW_ALLOC_LOG_CONF	0x00000006	// Specifies the Old Alloc Log Conf.
#define	NUM_LOG_CONF		0x00000007	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
	"REALMODE_LOG_CONF",\
	"NEW_ALLOC_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
	WORD			IRQA_Level;
	WORD			IRQA_Unused;
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
CM_LOCKABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_LOCKABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_LOCKABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_LOCKABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
CM_LOCKABLE_CODE_SEG	TEXTEQU	<VxD_LOCKABLE_CODE_SEG>
CM_LOCKABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKABLE_CODE_ENDS>
CM_LOCKABLE_DATA_SEG	TEXTEQU	<VxD_LOCKABLE_CODE_SEG>
CM_LOCKABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKABLE_CODE_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name (OEM format)
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUGBUG(d, id, msg)	message("BUGBUG: "##d##", "##id##": "##msg)

#define	CM_DEREF(var)		{var=var;}

#ifndef	DEBUG

#define	CM_WARN1(strings)
#define	CM_WARN2(strings)
#define	CM_ERROR(strings)

#else

#ifndef	MAXDEBUG

#define	CM_WARN1(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " WARNS: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}
#define	CM_WARN2(strings)
#define	CM_ERROR(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " ERROR: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}

#else

#define	CM_WARN1(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " WARNS: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}
#define	CM_WARN2(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " WARNS: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}
#define	CM_ERROR(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " ERROR: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define CM_LOCKABLE_CODE	VxD_LOCKED_CODE_SEG
#define CM_LOCKABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#undef	CURSEG
#define	CURSEG()		LCODE

#define	CM_HEAPFLAGS		(HEAPZEROINIT)

#else

#define CM_LOCKABLE_CODE	VxD_LOCKABLE_CODE_SEG
#define CM_LOCKABLE_DATA	VxD_LOCKABLE_DATA_SEG
#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#undef	CURSEG
#define	CURSEG()		CCODE

#define	CM_HEAPFLAGS		(HEAPSWAP|HEAPZEROINIT)

#endif

#ifndef	CM_GOLDEN_RETAIL

#define	CM_DEBUGGER_USE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_DEBUGGER_USE_DATA	VxD_LOCKED_DATA_SEG

#else

#define	CM_DEBUGGER_USE_CODE	CM_LOCKABLE_CODE
#define	CM_DEBUGGER_USE_DATA	CM_LOCKABLE_DATA

#endif

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL
#define	CM_INLINE		_inline

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL {\
_asm	popfd	\
}

#ifndef NEC_98
#define	CM_PIC_MASTER	0x21
#define	CM_PIC_SLAVE	0xA1
#else
#define	CM_PIC_MASTER	0x02
#define	CM_PIC_SLAVE	0x0A
#endif

#define	CM_MASK_PIC(wPICMask) { \
_asm	in	al, CM_PIC_SLAVE \
_asm	mov	ah, al \
_asm	in	al, CM_PIC_MASTER \
_asm	mov	word ptr [wPICMask], ax \
_asm	or	al, 0xff \
_asm	out	CM_PIC_SLAVE, al \
_asm	out	CM_PIC_MASTER, al \
}

#define	CM_LOCK_PIC(dwEFlags, wPICMask) { \
{_asm	pushfd \
_asm	pop	[dwEFlags] \
_asm	cli	\
}; CM_MASK_PIC(wPICMask); \
}

#define	CM_UNMASK_PIC(wPICMask) { \
_asm	mov	ax, word ptr [wPICMask] \
_asm	out	CM_PIC_MASTER, al \
_asm	mov	al, ah \
_asm	out	CM_PIC_SLAVE, al \
}

#define	CM_UNLOCK_PIC(dwEFlags, wPICMask) { \
CM_UNMASK_PIC(wPICMask); \
{ _asm	push	[dwEFlags] \
_asm	popfd }\
}

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

#ifdef	IS_32

#include <vwin32.h>

struct	_WIN32CMIOCTLPACKET {
	DWORD	dwStack;
	DWORD	dwServiceNumber;
};

typedef	struct	_WIN32CMIOCTLPACKET	WIN32CMIOCTLPACKET;
typedef	WIN32CMIOCTLPACKET		*PWIN32CMIOCTLPACKET;

#ifdef	CM_USE_OPEN_SERVICE

CONFIGRET WINAPI
WIN32CMIOCTLHandler(PWIN32CMIOCTLPACKET pPacket);

CONFIGRET WINAPI
CMWorker(DWORD dwStack, DWORD dwServiceNumber);

BOOL WINAPI
CM_Open(VOID);

VOID WINAPI
CM_Close(VOID);

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _cdecl \
CM_##Function##Parameters \
{ \
	DWORD	dwStack; \
	_asm	{mov	dwStack, ebp}; \
	dwStack+=8; \
	return(CMWorker(dwStack, CONFIGMG_W32IOCTL_RANGE+(GetVxDServiceOrdinal(_CONFIGMG_##Function) & 0xFFFF))); \
}

#define	CM_IS_FILE_PROVIDING_SERVICES \
HANDLE	hCONFIGMG=INVALID_HANDLE_VALUE; \
BOOL WINAPI \
CM_Open(VOID) \
{ \
	hCONFIGMG=CreateFile(	"\\\\.\\CONFIGMG", \
				GENERIC_READ|GENERIC_WRITE, \
				FILE_SHARE_READ|FILE_SHARE_WRITE, \
				NULL, OPEN_EXISTING, 0, NULL); \
	if (hCONFIGMG==INVALID_HANDLE_VALUE) \
		return(FALSE); \
	return(CM_Get_Version()>=0x400); \
} \
VOID WINAPI \
CM_Close(VOID) \
{ \
	CloseHandle(hCONFIGMG); \
 \
	hCONFIGMG==INVALID_HANDLE_VALUE; \
} \
CONFIGRET WINAPI \
WIN32CMIOCTLHandler(PWIN32CMIOCTLPACKET pPacket) \
{ \
	CONFIGRET	crReturnValue=CR_FAILURE; \
	DWORD		dwReturnSize=0; \
	if (!DeviceIoControl(	hCONFIGMG, \
				pPacket->dwServiceNumber, \
				&(pPacket->dwStack), \
				sizeof(pPacket->dwStack), \
				&crReturnValue, \
				sizeof(crReturnValue), \
				&dwReturnSize, \
				NULL)) \
		return(CR_FAILURE); \
	if (dwReturnSize!=sizeof(crReturnValue)) \
		return(CR_FAILURE); \
	return(crReturnValue); \
} \
CONFIGRET WINAPI \
CMWorker(DWORD dwStack, DWORD dwServiceNumber) \
{ \
	WIN32CMIOCTLPACKET	Packet; \
	Packet.dwStack=dwStack; \
	Packet.dwServiceNumber=dwServiceNumber; \
	return(WIN32CMIoctlHandler(&Packet)); \
}

#else	// ifdef CM_USE_OPEN_SERVICE

CONFIGRET static WINAPI
WIN32CMIOCTLHandler(PWIN32CMIOCTLPACKET pPacket)
{
	HANDLE		hCONFIGMG;
	CONFIGRET	crReturnValue=CR_FAILURE;
	DWORD		dwReturnSize=0;

	hCONFIGMG=CreateFile(	"\\\\.\\CONFIGMG",
				GENERIC_READ|GENERIC_WRITE,
				FILE_SHARE_READ|FILE_SHARE_WRITE,
				NULL, OPEN_EXISTING, 0, NULL);

	if (hCONFIGMG==INVALID_HANDLE_VALUE)
		return(CR_FAILURE);

	if (!DeviceIoControl(	hCONFIGMG,
				pPacket->dwServiceNumber,
				&(pPacket->dwStack),
				sizeof(pPacket->dwStack),
				&crReturnValue,
				sizeof(crReturnValue),
				&dwReturnSize,
				NULL))
		crReturnValue=CR_FAILURE;

	CloseHandle(hCONFIGMG);

	if (dwReturnSize!=sizeof(crReturnValue))
		crReturnValue=CR_FAILURE;

	return(crReturnValue);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _cdecl \
CM_##Function##Parameters \
{ \
	WIN32CMIOCTLPACKET	Packet; \
	DWORD			dwStack; \
	_asm	{mov	dwStack, ebp}; \
	dwStack+=8; \
	Packet.dwStack=dwStack; \
	Packet.dwServiceNumber=CONFIGMG_W32IOCTL_RANGE+(GetVxDServiceOrdinal(_CONFIGMG_##Function) & 0xFFFF); \
	return(WIN32CMIOCTLHandler(&Packet)); \
}

#endif	// ifdef CM_USE_OPEN_SERVICE

#else	// IS_32

#ifdef	CM_USE_OPEN_SERVICE

extern	DWORD	CMEntryPoint;

BOOL
CM_Open(void);

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if (CMEntryPoint==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#define	CM_IS_FILE_PROVIDING_SERVICES \
DWORD	CMEntryPoint=0; \
BOOL \
CM_Open(void) \
{ \
	_asm	{push	bx}; \
	_asm	{push	es}; \
	_asm	{push	di}; \
	_asm	{xor	di, di}; \
	_asm	{mov	ax, 0x1684}; \
	_asm	{mov	bx, 0x33}; \
	_asm	{mov	es, di}; \
	_asm	{int	0x2f}; \
	_asm	{mov	word ptr [CMEntryPoint+2], es}; \
	_asm	{mov	word ptr [CMEntryPoint], di}; \
	_asm	{pop	di}; \
	_asm	{pop	es}; \
	_asm	{pop	bx}; \
	if (!CMEntryPoint) \
		return(FALSE); \
	return(CM_Get_Version()>=0x400); \
}

#else	// ifdef CM_USE_OPEN_SERVICE

DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#endif	// ifdef CM_USE_OPEN_SERVICE

#endif	// IS_32

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#define	CM_Get_Version	CONFIGMG_Get_Version

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (PNODELISTHEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (DEVNODE dnDevnode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))
MAKE_CM_HEADER(Find_Range, (PFARULONG pulStart, ULONG ulStart, ULONG ulLength, ULONG ulAlignment, ULONG ulEnd, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Global_State, (PFARULONG pulState, ULONG ulFlags))
MAKE_CM_HEADER(Broadcast_Device_Change_Message, (ULONG ulwParam, PFARVOID plParam, ULONG ulFlags))
MAKE_CM_HEADER(Call_DevNode_Handler, (DEVNODE dnDevNode, ULONG ulPrivate, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Reinsert_All, (ULONG ulFlags))
//
// 4.0 OPK2 Services
//
MAKE_CM_HEADER(Change_DevNode_Status, (DEVNODE dnDevNode, ULONG ulStatus, ULONG ulFlags))
MAKE_CM_HEADER(Reprocess_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Assert_Structure, (PFARULONG pulPointerType, DWORD dwData, ULONG ulFlags))
MAKE_CM_HEADER(Discard_Boot_Log_Conf, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Dependent_DevNode, (DEVNODE dnDependOnDevNode, DEVNODE dnDependingDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Dependent_DevNode, (PDEVNODE dnDependOnDevNode, DEVNODE dnDependingDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Refilter_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_DevNode_PowerState, (DEVNODE dnDevNode, ULONG ulPowerState, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_PowerState, (DEVNODE dnDevNode, PFARULONG pulPowerState, ULONG ulFlags))
MAKE_CM_HEADER(Set_DevNode_PowerCapabilities, (DEVNODE dnDevNode, ULONG ulPowerCapabilities, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_PowerCapabilities, (DEVNODE dnDevNode, PFARULONG pulPowerCapabilities, ULONG ulFlags))
MAKE_CM_HEADER(Substract_Range_List, (RANGE_LIST rlhFrom, RANGE_LIST rlhWith, RANGE_LIST rlhDifference, ULONG ulFlags))
MAKE_CM_HEADER(Merge_Range_List, (RANGE_LIST rlh1, RANGE_LIST rlh2, RANGE_LIST rlhTotal, ULONG ulFlags))
MAKE_CM_HEADER(Read_Range_List, (PFARCHAR pszKeyName, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Write_Range_List, (PFARCHAR pszKeyName, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Set_Log_Conf_Priority, (PPRIORITY pPriority, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Support_Share_Irq, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent_Structure, (PFARULONG pulParentStructure, RES_DES CurrentResDesOrLogConf, ULONG ulFlags))
//
// 4.1 Services
//
MAKE_CM_HEADER(Register_DevNode_For_Idle_Detection, (DEVNODE dnDevNode, ULONG ulConservationTime, ULONG ulPerformanceTime, PFARULONG pulCounterVariable, ULONG ulState, ULONG ulFlags))
MAKE_CM_HEADER(CM_To_ISAPNP, (LOG_CONF lcLogConf, PFARVOID pCurrentResources, PFARVOID pNewResources, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Handler, (DEVNODE dnDevNode, PFARULONG pAddress, ULONG ulFlags))
MAKE_CM_HEADER(Detect_Resource_Conflict, (DEVNODE dnDevNode, RESOURCEID ResourceID, PFARVOID pResourceData, ULONG ulResourceLen, PFARCHAR pfConflictDetected, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Interface_List, (PFARVOID pInterfaceGuid, PFARCHAR pDeviceID, PFARCHAR pBuffer, ULONG ulBufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Interface_List_Size, (PFARULONG pulLen, PFARVOID pInterfaceGuid, PFARCHAR pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Conflict_Info, (DEVNODE dnDevNode, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Add_Remove_DevNode_Property, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Interface, (DEVNODE dnDevNode, PFARVOID pInterfaceGuid, PFARCHAR pReference, PFARCHAR pInterfaceDevice, PFARULONG pulLen, ULONG ulFlags))
MAKE_CM_HEADER(System_Device_Power_State_Mapping, (DEVNODE dnDevNode, PPSMAPPING pPSMapping, ULONG ulFlags))
MAKE_CM_HEADER(Get_Arbitrator_Info, (PFARULONG pInfo, PDEVNODE pdnDevNode, DEVNODE dnDevNode, RESOURCEID ResourceID, PFARVOID pResourceData, ULONG ulResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Waking_Up_From_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_DevNode_Problem, (DEVNODE dnDevNode, ULONG ulProblem, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Interface_Alias, (PFARCHAR pDeviceInterface, PFARVOID pAliasInterfaceGuid, PFARCHAR pAliasDeviceInterface, PFARULONG pulLen, ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

/*XLATOFF*/
#include <poppack.h>
/*XLATON*/

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\poppack.h ===
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\vmmreg.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1993
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 *   Date:	03-June-1993
 *
 *   Author:	Nagara
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already
#define REG_SZ		0x0001
#endif
#ifndef REG_BINARY	// define only if not there already
#define REG_BINARY	0x0003
#endif
#ifndef REG_DWORD	// define only if not there already
#define	REG_DWORD	0x0004
#endif


#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#endif

#ifndef ERROR_REGISTRY_IO_FAILED
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif 


#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID pvKeyContext, PVALCONTEXT pvalcontextValues, DWORD cvalcontextValues, PVOID pbData, DWORD * pcbData, DWORD dwReserved);

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;		// Only PROVIDER_KEEPS_VALUE_LENGTH for now.
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push cpvalueValueInfo
    _asm push ppvalueValueInfo
    _asm push pprovHandlerInfo
    _asm push pvKeyContext
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegQueryMultipleValues (VMMHKEY hKey, PVOID val_list, DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryMultipleValues);
    _asm add  esp, 5*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\vwin32.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp.  All Rights Reserved, 1989-1995
 *
 *   Title: vwin32.h -
 *
 *   Version:   4.00
 *
 *   Date:  24-May-1993
 *
 ******************************************************************************/

/*INT32*/

#ifndef _VWIN32_H_
#define _VWIN32_H_

#define THREAD_TYPE_WIN32 VWIN32_DEVICE_ID

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service  Declare_Service
#define VWIN32_StdCall_Service Declare_SCService
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service  (VWIN32_Get_Version, LOCAL)
VWIN32_Service  (VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service  (_VWIN32_QueueUserApc)
VWIN32_Service  (_VWIN32_Get_Thread_Context)
VWIN32_Service  (_VWIN32_Set_Thread_Context)
VWIN32_Service  (_VWIN32_CopyMem, LOCAL)
VWIN32_Service  (_VWIN32_Npx_Exception)
VWIN32_Service  (_VWIN32_Emulate_Npx)
VWIN32_Service  (_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service  (VWIN32_EnterCrstR0)
VWIN32_Service  (VWIN32_LeaveCrstR0)
VWIN32_Service  (_VWIN32_FaultPopup)
VWIN32_Service  (VWIN32_GetContextHandle)
VWIN32_Service  (VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_SetWin32Event)
VWIN32_Service  (_VWIN32_PulseWin32Event)
VWIN32_Service  (_VWIN32_ResetWin32Event)
VWIN32_Service  (_VWIN32_WaitSingleObject)
VWIN32_Service  (_VWIN32_WaitMultipleObjects)
VWIN32_Service  (_VWIN32_CreateRing0Thread)
VWIN32_Service  (_VWIN32_CloseVxDHandle)
VWIN32_Service  (VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service  (VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service  (VWIN32_BlueScreenPopup)
VWIN32_Service  (VWIN32_TerminateApp)
VWIN32_Service  (_VWIN32_QueueKernelAPC)
VWIN32_Service  (VWIN32_SysErrorBox)
VWIN32_Service  (_VWIN32_IsClientWin32)
VWIN32_Service  (VWIN32_IFSRIPWhenLev2Taken, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Event)
VWIN32_Service  (_VWIN32_InitWin32Mutex)
VWIN32_Service  (_VWIN32_ReleaseWin32Mutex)
VWIN32_Service  (_VWIN32_BlockThreadEx)
VWIN32_Service  (VWIN32_GetProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Semaphore)
VWIN32_Service  (_VWIN32_SignalWin32Sem)
VWIN32_Service  (_VWIN32_QueueUserApcEx)
VWIN32_Service	(_VWIN32_OpenVxDHandle)
VWIN32_Service	(_VWIN32_CloseWin32Handle)
VWIN32_Service	(_VWIN32_AllocExternalHandle)
VWIN32_Service	(_VWIN32_UseExternalHandle)
VWIN32_Service	(_VWIN32_UnuseExternalHandle)
VWIN32_StdCall_Service	(KeInitializeTimer, 1)
VWIN32_StdCall_Service	(KeSetTimer, 4)
VWIN32_StdCall_Service	(KeCancelTimer, 1)
VWIN32_StdCall_Service	(KeReadStateTimer, 1)
VWIN32_Service	(_VWIN32_ReferenceObject)
VWIN32_Service	(_VWIN32_GetExternalHandle)
VWIN32_StdCall_Service	(VWIN32_ConvertNtTimeout, 1)
VWIN32_Service	(_VWIN32_SetWin32EventBoostPriority)
VWIN32_Service	(_VWIN32_GetRing3Flat32Selectors)
VWIN32_Service	(_VWIN32_GetCurThreadCondition)
VWIN32_Service  (VWIN32_Init_FP)
VWIN32_StdCall_Service  (R0SetWaitableTimer, 5)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)      // turn on not enough params warning

PVOID VXDINLINE
VWIN32OpenVxDHandle(ULONG Handle,ULONG dwType)
{
    PVOID ul;
    
    _asm push [dwType]
    _asm push [Handle]
    VxDCall(_VWIN32_OpenVxDHandle)
    _asm add esp, 8
    _asm mov [ul], eax
	    
    return(ul);
}

WORD VXDINLINE
VWIN32_Get_Version(VOID)
{
	WORD	w;
	VxDCall(VWIN32_Get_Version);
	_asm mov [w], ax
	return(w);
}

/*XLATON*/

#endif // Not_VxD

//
// For _VWIN32_GetCurThreadCondition
//
#define	THREAD_CONDITION_DOS_BOX		0x00000000l
#define	THREAD_CONDITION_V86_NEST		0x00000001l
#define	THREAD_CONDITION_WDM			0x00000002l
#define	THREAD_CONDITION_INDETERMINATE		0x00000003l
#define	THREAD_CONDITION_LOCKED_STACK		0x00000004l
#define	THREAD_CONDITION_PURE_WIN16		0x00000005l
#define	THREAD_CONDITION_THUNKED_WIN16		0x00000006l
#define	THREAD_CONDITION_THUNKED_WIN32		0x00000007l
#define	THREAD_CONDITION_PURE_WIN32		0x00000008l
#define	THREAD_CONDITION_APPY_TIME		0x00000009l
#define	THREAD_CONDITION_RING0_APPY_TIME	0x0000000Al
#define	THREAD_CONDITION_EXIT			0x0000000Bl
#define	THREAD_CONDITION_INVALID_FLAGS		0xFFFFFFFFl

#define	THREAD_CONDITION_NORMAL_FLAGS		0x00000000l

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

#define SEB_ANSI    0x4000      // ANSI strings if set on vseb_b1
#define SEB_TERMINATE   0x2000      // forces termination if button pressed

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC        0x00000001
#define KERNEL_APC_STATIC       0x00000002
#define KERNEL_APC_WAKE         0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams   {
    DWORD   Internal1;      // ptr to client regs
    DWORD   VMHandle;       // VM handle
    DWORD   Internal2;      // DDB
    DWORD   dwIoControlCode;
    DWORD   lpvInBuffer;
    DWORD   cbInBuffer;
    DWORD   lpvOutBuffer;
    DWORD   cbOutBuffer;
    DWORD   lpcbBytesReturned;
    DWORD   lpoOverlapped;
    DWORD   hDevice;
    DWORD   tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define VWIN32_DIOC_DOS_IOCTL       1
#define VWIN32_DIOC_DOS_INT25       2
#define VWIN32_DIOC_DOS_INT26       3
#define VWIN32_DIOC_DOS_INT13       4
#define VWIN32_DIOC_SIMCTRLC        5
#define VWIN32_DIOC_DOS_DRIVEINFO   6
#define VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;      
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif

//  Parameters for _VWIN32_OpenVxDHandle to validate the Win32 handle type.
#define OPENVXD_TYPE_SEMAPHORE  0
#define OPENVXD_TYPE_EVENT      1
#define OPENVXD_TYPE_MUTEX      2
#define	OPENVXD_TYPE_ANY	3
  

//
//  Object type table declaration for _VWIN32_AllocExternalHandle
//
/*XLATOFF*/
#define R0OBJCALLBACK           __stdcall
typedef VOID    (R0OBJCALLBACK *R0OBJFREE)(PVOID pR0ObjBody);
typedef PVOID   (R0OBJCALLBACK *R0OBJDUP)(PVOID pR0ObjBody, DWORD hDestProc);
/*XLATON*/
/* ASM
R0OBJFREE   TYPEDEF     DWORD
R0OBJDUP    TYPEDEF     DWORD
*/

typedef struct _R0OBJTYPETABLE {
    DWORD       ott_dwSize;             //  sizeof(R0OBJTYPETABLE)
    R0OBJFREE   ott_pfnFree;            //  called by Win32 CloseHandle
    R0OBJDUP    ott_pfnDup;             //  called by Win32 DuplicateHandle
} R0OBJTYPETABLE, *PR0OBJTYPETABLE;
/* ASM
R0OBJTYPETABLE  typedef _R0OBJTYPETABLE;
*/

#define R0EHF_INHERIT   0x00000001      //  Handle is inheritable
#define R0EHF_GLOBAL    0x00000002      //  Handle is valid in all contexts

#endif  // _VWIN32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\vmm.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:	1.00
 *
 *   Date:  05-May-1988
 *
 *   Author:	RAL
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *   DATE    REV DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *   05-May-1988 RAL Original
 *   13-Nov-1991 PBS C version
 *   17-Dec-1993     Adds East Asia VxDs identifiers
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.	Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE	    0	    // False
#define VMM_TRUE    (~FALSE)	// The opposite of False!

#define DEBLEVELRETAIL	0
#define DEBLEVELNORMAL	1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#define WIN403SERVICES		/*OPK-3 Services*/
#endif

#ifndef WIN40COMPAT
#define WIN41SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef	NEWSTRUCTS	; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *	    EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID	    0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID	    0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID	    0x0000A
#define VSD_DEVICE_ID	    0x0000B
#define VMD_DEVICE_ID	    0x0000C
#define VKD_DEVICE_ID	    0x0000D
#define VCD_DEVICE_ID	    0x0000E
#define VPD_DEVICE_ID	    0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID	    0x0001B
#define VDD2_DEVICE_ID	    0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID	    0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID	    0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID	    0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID	0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID 	0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID	0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID	0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID	0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS	*/
/* #define VNB_DEVICE_ID	   0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID	   0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID	*/

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID	    0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID	   0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F	/* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID	    0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID	    0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */
#define DDS_DEVICE_ID	    0x0004A /* Device driver services */
#define NTKERN_DEVICE_ID    0x0004B /* NT kernel device id */
#define VDOSKEYD_DEVICE_ID  0x0004B /* DOSKEY device id */
#define ACPI_DEVICE_ID      0x0004C /* Advanced Configuration and Power Interfacec */
#define UDF_DEVICE_ID       0x0004D /* UDF FSD device id */
#define SMCLIB_DEVICE_ID    0x0004E /* Smart Card port driver */

/*
 *   East Asia DOS support VxD ID
 */

#define ETEN_Device_ID	    0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID	    0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.	Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER	    0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER	0x000000000 /*	but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER		0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER	    0x014000000
#define VWIN32_INIT_ORDER   0x014100000
#define VXDLDR_INIT_ORDER   0x016000000
#define NTKERN_INIT_ORDER   0x016200000 /* Must be after VxDLdr and before configmg */

#define CONFIGMG_INIT_ORDER 0x016400000	/* Must now be before enumerators */
#define ENUMERATOR_INIT_ORDER	0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER	    ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define ACPI_INIT_ORDER     ENUMERATOR_INIT_ORDER+2 /* To simplify reenumeration */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER	    0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER	    0x028000000
#define VSD_INIT_ORDER	    0x02C000000

#define VCD_INIT_ORDER	    0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER	    0x034000000
#define VKD_INIT_ORDER	    0x038000000
#define VPD_INIT_ORDER	    0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER	0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER	0x080000000
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order	    0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER	    0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;	    /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;		/* Client's EDI */
    ULONG Pushad_ESI;		/* Client's ESI */
    ULONG Pushad_EBP;		/* Client's EBP */
    ULONG Pushad_ESP;		/* ESP before pushad */
    ULONG Pushad_EBX;		/* Client's EBX */
    ULONG Pushad_EDX;		/* Client's EDX */
    ULONG Pushad_ECX;		/* Client's ECX */
    ULONG Pushad_EAX;		/* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)	// turn off redefinition warning

typedef unsigned char	UCHAR;
typedef unsigned short	USHORT;

#pragma warning (default:4209)	// turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)	__##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define Declare_SCService(service, args, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG	    code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG	    data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG	code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG	data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DB1CODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DB2DATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG	code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG	code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG	code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG	code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG	code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG	code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG	code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG	code_seg("LOCKABLE", "LOCKABLECODE")
#define VxD_LOCKABLE_DATA_SEG	data_seg("LOCKABLE_DATA", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =	1
??_ICODE    =	2
??_PCODE    =	3
??_SCODE    =	4
??_DBOCODE  =	5
??_16ICODE  =	6
??_RCODE    =	7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE	equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF	MASM6
_FLAT	EQU FLAT
ELSE
_FLAT	EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT	    ENDS

_TEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT	    ENDS

;*  32 bit pageable code
_PTEXT	    SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT	    ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB	<classname>
    segname	SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname	SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
	ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB	<grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM		;; End for each segment

    ENDM

MakeCodeSeg <L0CKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***	DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_L0CKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_L0CKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***	DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***	CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
	extrn	name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***	MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***	MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or	??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT	    ENDS

;*  32 bit locked data
_LDATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA	    ENDS

_DATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA	    ENDS

;*  32 bit pageable data
_PDATA	    SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA	    ENDS

;*  32 Bit initialization data
_IDATA	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA	    ENDS

;*  Created by C8
_BSS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS	    ENDS

CONST	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST	    ENDS

_TLS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS	    ENDS

;*  32 Bit static code for DL-VxDs
_STEXT	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT	    ENDS

;*  32 Bit static data for DL-VxDs
_SDATA	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA	    ENDS

;*	dummy segment for IsDebugOnlyLoaded
_DB0START   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB0START   ENDS

;*	32 bit debug only code; loaded only if debugger is present
_DB1CODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB1CODE    ENDS

;*	32 bit debug only data; loaded only if debugger is present
_DB2DATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB2DATA    ENDS

if DEBLEVEL
;*  Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*  32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*  End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE	    SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE	    ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DB0START, _DB1CODE, _DB2DATA
IF DEBLEVEL
_PGROUP   GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;	. . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table	VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1		; Only in module where table is
;   INCLUDE	VxD.INC 	; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF	Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID	= 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName	Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName	MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table


Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition, StdCallBytes, fastcall
LOCAL $$&Procedure, extrnproc, tableproc

  extrnproc MACRO
    IFNB <fastcall>
      IFB <StdCallBytes>
	.err	;StdCallBytes required
      ENDIF
      EXTRN @&&Procedure&&@&&StdCallBytes:NEAR
    ELSE
      IFNB <StdCallBytes>
	EXTRN _&&Procedure&&@&&StdCallBytes:NEAR
      ELSE
	EXTRN Procedure:NEAR
      ENDIF
    ENDIF
    ENDM

  tableproc MACRO
    IFNB <fastcall>
      dd  OFFSET32 @&&Procedure&&@&&StdCallBytes
    ELSE
      IFNB <StdCallBytes>
	dd  OFFSET32 _&&Procedure&&@&&StdCallBytes
      ELSE
	dd  OFFSET32 Procedure
      ENDIF
    ENDIF
    ENDM

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	extrnproc
      ELSE
	tableproc
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     IFNB <fastcall>
    PUBLIC __&&Procedure
     __&&Procedure LABEL DWORD
     ENDIF
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
    $$&&Procedure extern
       ELSE
	extrnproc
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
	tableproc
      ENDIF

	  IFDEF Device_Name&_Name_Based
	@@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
	  ELSE
	@@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	  ENDIF
  ELSE
    dd	0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    Purge extrnproc
    Purge tableproc
    ENDM

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4
    ??_standardccall&&_Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4, TRUE
    ??_fastcall&&_Procedure = Args
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF	Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM

ENDIF

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_standardccall_&&Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_fastcall_&&Procedure = Args
    ENDM

ENDIF

    ENDM


;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal	macro	reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress	macro	reg,service
    mov reg,OFFSET32 service
    endm


;***	Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.	If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName	- the name of the VxD; it is assumed
;		  that a corresponding Device_ID is
;		  also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;	accepts a service name as its only parameter.
;	This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd	csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
	.erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
	dd  OFFSET32 Name,cparm&&Name
    endif
	@32&&Name equ	((VxDName&_Device_ID SHL 16) + ??w32svcno)
	??w32svcno = ??w32svcno + 1
	ENDM
    ENDM


;***	End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName	- the same name passed to
;		  Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***	Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name	- the service name
;	cParms	    - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***	Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service	- the name of the service
;	CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)	service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp	VxDJmp

#define SERVICE 	__cdecl
#define ASYNC_SERVICE	__cdecl
#define WIN32_SERVICE	void __stdcall

#ifndef FASTCALL
#define FASTCALL	__fastcall
#endif
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
	ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status; 	/* VM status flags */
    ULONG CB_High_Linear;	/* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56	/* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT	0x00	/* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE	(1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT	0x01	/* VM runs in background */
#define VMSTAT_BACKGROUND	(1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING 	(1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT	0x03	/* VM not scheduled */
#define VMSTAT_SUSPENDED	(1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE	(1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC		(1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP		(1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32 	(1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC 	(1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09	/* High pri background */
#define VMSTAT_HIGH_PRI_BACK	(1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED		(1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT	0x0B	/* Woke up after blocked */
#define VMSTAT_AWAKENING	(1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT	0x0C	/* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT	VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86	(1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D	/* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED	(1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E	/* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT	(1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT 	0x0F	/* VM has released time slice */
#define VMSTAT_IDLE		(1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING		(1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11	/* VM suspended by */
#define VMSTAT_TS_SUSPENDED	(1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT	0x12	/* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI	(1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;		/* Thread status flags */
    ULONG   TCB_Reserved1;	/* Used internally by VMM */
    ULONG   TCB_Reserved2;	/* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;	/* Client registers of thread */
    ULONG   TCB_VMHandle;	/* VM that thread is part of */
    USHORT  TCB_ThreadId;	/* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;	    /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;	    /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;	/* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;		/* reusable; for dword align */
    UCHAR   TCB_pad2;		/* reusable; for dword align */
    UCHAR   TCB_extErrLocus;	    /* extended error Locus */
    USHORT  TCB_extErr; 	/* extended error Code */
    UCHAR   TCB_extErrAction;	    /*	    "   "   Action */
    UCHAR   TCB_extErrClass;	    /*	    "   "   Class */
    ULONG   TCB_extErrPtr;	/*	"   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD	    0x42434854	  // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT	    0x03   // Thread not scheduled
#define THFLAG_SUSPENDED		   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE		   (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION		   (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED		   (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD		   (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_ASYNC_THREAD_BIT	    0x1F   // thread is asynchronous
#define THFLAG_ASYNC_THREAD	       	   (1L << THFLAG_ASYNC_THREAD_BIT)
#define THFLAG_CHARSET_BITS	0x10   // Default character set
#define THFLAG_CHARSET_MASK	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI	       (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM	       (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE		   (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED 	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES 	   (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13	 // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE		 (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;		// faulting EIP
    WORD  VMFI_CS;		// faulting CS
    WORD  VMFI_Ints;		// interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *		V M M	S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#define VMM_StdCall_Service Declare_SCService
#define VMM_FastCall_Service Declare_SCService
#pragma warning (disable:4003)	    // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)	// MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

//
// Flags affecting the returned block
//

#define HEAPZEROINIT        0x00000001
#define HEAPZEROREINIT      0x00000002
#define HEAPNOCOPY          0x00000004

//
// Alignment flags
//

#define HEAPALIGN_SHIFT     16
#define HEAPALIGN_MASK      0x000F0000

#define HEAPALIGN_4         0x00000000                // dword aligned
#define HEAPALIGN_8         0x00000000                // quadword aligned
#define HEAPALIGN_16        0x00000000                // paragraph aligned
#define HEAPALIGN_32        0x00010000                // etc.
#define HEAPALIGN_64        0x00020000
#define HEAPALIGN_128       0x00030000
#define HEAPALIGN_256       0x00040000
#define HEAPALIGN_512       0x00050000
#define HEAPALIGN_1K        0x00060000
#define HEAPALIGN_2K        0x00070000
#define HEAPALIGN_4K        0x00080000
#define HEAPALIGN_8K        0x00090000
#define HEAPALIGN_16K       0x000A0000
#define HEAPALIGN_32K       0x000B0000
#define HEAPALIGN_64K       0x000C0000
#define HEAPALIGN_128K      0x000D0000

//
// Flags indicating which system heap to use.  There are four bits reserved
// to identify the heap to use.  Four are currently defined by the system.
//

#define HEAPTYPESHIFT       8
#define HEAPTYPEMASK        0x00000700

#define HEAPLOCKEDHIGH      0x00000000
#define HEAPLOCKEDIFDP      0x00000100
#define HEAPSWAP            0x00000200
#define HEAPINIT            0x00000400  // will be automatically freed after
                                        // init complete

//
// other flags
//

#define HEAPCLEAN           0x00000800
#define HEAPCONTIG          0x00001000  // memory must be physically contiguous
#define HEAPFORGET          0x00002000  // this memory will never be freed

//
// Combinations of flags understood by HeapAllocateEx
//

#define HEAPLOCKEDLOW       0x00000300
#define HEAPSYSVM           0x00000500
#define HEAPPREEMPT         0x00000600  // code in this heap is preemptable

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT		0x00000001
#define PAGEUSEALIGN		0x00000002
#define PAGECONTIG		0x00000004
#define PAGEFIXED		0x00000008
#define PAGEDEBUGNULFAULT	0x00000010
#define PAGEZEROREINIT		0x00000020
#define PAGENOCOPY		0x00000040
#define PAGELOCKED		0x00000080
#define PAGELOCKEDIFDP		0x00000100
#define PAGESETV86PAGEABLE	0x00000200
#define PAGECLEARV86PAGEABLE	0x00000400
#define PAGESETV86INTSLOCKED	0x00000800
#define PAGECLEARV86INTSLOCKED	0x00001000
#define PAGEMARKPAGEOUT 	0x00002000
#define PAGEPDPSETBASE		0x00004000
#define PAGEPDPCLEARBASE	0x00008000
#define PAGEDISCARD		0x00010000
#define PAGEPDPQUERYDIRTY	0x00020000
#define PAGEMAPFREEPHYSREG	0x00040000
#define PAGEPHYSONLY		0x04000000
//efine PAGEDONTUSE		0x08000000  // ;Internal
#define PAGENOMOVE		0x10000000
#define PAGEMAPGLOBAL		0x40000000
#define PAGEMARKDIRTY		0x80000000

/****************************************************
 *
 *	Flags for _PhysIntoV86,
 *	_MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP	0x00000001

/****************************************************
 *
 *	Flags for MapPhysToLinear
 *
 *
 ***************************************************/

#define	MPL_NonCached			0x00000000
#define	MPL_HardwareCoherentCached	0x00000001
#define	MPL_FrameBufferCached		0x00000002
#define	MPL_Cached			0x00000004

// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
*   Flag equates for _Allocate_GDT_Selector
*/
#define ALLOCFROMEND    0x40000000


/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL	0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE	0x00000002
#define MMGRHMADISABLE	0x00000004
#define MMGRHMAQUERY	0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT	    0
#define LF_ASYNC	(1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP	(1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR	    (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP 	(LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area)
VMM_Service (_Free_Temp_V86_Data_Area)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign	    0x00000001
#define GVDADWordAlign	    0x00000002
#define GVDAParaAlign	    0x00000004
#define GVDAPageAlign	    0x00000008
#define GVDAInstance	    0x00000100
#define GVDAZeroInit	    0x00000200
#define GVDAReclaim	0x00000400
#define GVDAInquire	0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE	    260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT	0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT	0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT	0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT	0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT	0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)
#define GMIF_80586_BIT  0x15
#define GMIF_80586  (1 << GMIF_80586_BIT)
#define GMIF_4MEGPG_BIT 0x16                // cpu supports 4 meg pages
#define GMIF_4MEGPG (1 << GMIF_4MEGPG_BIT)
#define GMIF_RDTSC_BIT 0x17
#define GMIF_RDTSC ( 1 << GMIF_RDTSC_BIT )

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *	    D E B U G G I N G	E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)	// Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)	// for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz	@@Test_DBCS_Lead_Byte - 100D1h	 ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT	 0x0001 // physical memory that must be swapped out
				// and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY	    0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS	 0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001	/* Privledged instruction */
#define GSDVME_INVALINST    0x00010002	/* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003	/* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004	/* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005	/* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006	/* User requested NUKE of VM */
#define GSDVME_DEVNUKE	    0x00010007	/* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008	/* Device specific problem:
			 *   invalid hardware fiddling
			 *   by VM (invalid I/O)
			 */
#define GSDVME_NUKENOMSG    0x00010009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */
#define GSDVME_OKNUKEMASK   0x80000000	/* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001	/* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002	/* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003	/* XMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004	/* EMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005	/* Hi DOS V86 mem   - DOSMGR
			 *	     V86MMGR
			 */
#define GSDVME_INSMEMVID    0x00020006	/* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007	/* Base VM mem	   - VMM
			 *   CB, Inst Buffer
			 */
#define GSDVME_INSMEMDEV    0x00020008	/* Couldn't alloc base VM
			 * memory for device.
			 */
#define GSDVME_CRTNOMSG     0x00020009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001	/* Page directory entry not-present */
#define IPF_V86PG   0x00000002	/* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004	/* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008	/* page has invalid not present type */
#define IPF_PGERR   0x00000010	/* pageswap device failure */
#define IPF_REFLT   0x00000020	/* re-entrant page fault */
#define IPF_VMM     0x00000040	/* Page fault caused by a VxD */
#define IPF_PM	    0x00000080	/* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100	/* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT	0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)	// Debugging only
VMM_Service (Disable_Touch_1st_Meg)	// Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz	 @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT	    0
#define DFS_LOG 	    (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT 	1
#define DFS_PROFILE	    (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT	2
#define DFS_TEST_CLD		(1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT	    3
#define DFS_NEVER_REENTER	(1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT	    4
#define DFS_TEST_REENTER	(1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT	    5
#define DFS_NOT_SWAPPING	(1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT	6
#define DFS_TEST_BLOCK		(1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES   0xFFFFFF80

#define DFS_EXIT_NOBLOCK	(DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC  (DFS_RARE_SERVICES+1)
#define DFS_WIMP_DEBUG      (DFS_RARE_SERVICES+2)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define MUTEX_MUST_COMPLETE	1L
#define MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND	    1L
#define THREAD_TERM_STATUS_NUKE_PEND	    2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE	0	/* no data instanced in range */
#define INSTINFO_SOME	1	/* some data instanced in range */
#define INSTINFO_ALL	2	/* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ	    // define only if not there already

#define REG_SZ	    0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT	0x80000000
#define HKEY_CURRENT_USER	0x80000001
#define HKEY_LOCAL_MACHINE	0x80000002
#define HKEY_USERS		0x80000003
#define HKEY_PERFORMANCE_DATA	0x80000004
#define HKEY_CURRENT_CONFIG	0x80000005
#define HKEY_DYN_DATA		0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE	0	/* no pages in the specified range exist */
#define PHYSINFO_SOME	1	/* some pages in the specified range exist */
#define PHYSINFO_ALL	2	/* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM	0
#define REGTYPE_CLASS	1
#define REGTYPE_VXD	2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN		    0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD	    0x00000000
#define ASSERT_RANGE_NULL_OK	    0x00000001
#define ASSERT_RANGE_IS_ASCIIZ	    0x00000002
#define ASSERT_RANGE_IS_NOT_ASCIIZ  0x00000000
#define ASSERT_RANGE_NO_DEBUG	    0x80000000
#define ASSERT_RANGE_BITS	    0x80000003

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN		0x00000001
#define BOOT_DOSCLEAN		0x00000002
#define BOOT_NETCLEAN		0x00000004
#define BOOT_INTERACTIVE	0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

#ifdef WIN403SERVICES

//
// 4.03 Services
//

/*MACROS*/
VMM_Service (_PageOutPages)
/*ENDMACROS*/

// Flag definitions for _PageOutPages

#define PAGEOUT_PRIVATE 0x00000001
#define PAGEOUT_SHARED	0x00000002
#define PAGEOUT_SYSTEM	0x00000004
#define PAGEOUT_REGION	0x00000008
#define PAGEOUT_ALL	(PAGEOUT_PRIVATE | PAGEOUT_SHARED | PAGEOUT_SYSTEM)

/*MACROS*/
VMM_Service (_Call_On_My_Not_Flat_Stack)
VMM_Service (_LinRegionLock)
VMM_Service (_LinRegionUnLock)
VMM_Service (_AttemptingSomethingDangerous)
VMM_Service (_Vsprintf)
VMM_Service (_Vsprintfw)
VMM_Service (Load_FS_Service)
VMM_Service (Assert_FS_Service)
VMM_StdCall_Service (ObsoleteRtlUnwind, 4)		
VMM_StdCall_Service (ObsoleteRtlRaiseException, 1)
VMM_StdCall_Service (ObsoleteRtlRaiseStatus, 1)		

VMM_StdCall_Service (ObsoleteKeGetCurrentIrql, 0)
VMM_FastCall_Service (ObsoleteKfRaiseIrql, 1)
VMM_FastCall_Service (ObsoleteKfLowerIrql, 1)

VMM_Service (_Begin_Preemptable_Code)
VMM_Service (_End_Preemptable_Code)
VMM_FastCall_Service (Set_Preemptable_Count, 1)

VMM_StdCall_Service (ObsoleteKeInitializeDpc, 3)
VMM_StdCall_Service (ObsoleteKeInsertQueueDpc, 3)
VMM_StdCall_Service (ObsoleteKeRemoveQueueDpc, 1)

VMM_StdCall_Service (HeapAllocateEx, 4)
VMM_StdCall_Service (HeapReAllocateEx, 5)
VMM_StdCall_Service (HeapGetSizeEx, 2)
VMM_StdCall_Service (HeapFreeEx, 2)
VMM_Service (_Get_CPUID_Flags)
VMM_StdCall_Service (KeCheckDivideByZeroTrap, 1)

/*ENDMACROS*/

#endif /* WIN403SERVICES */

#ifdef	WIN41SERVICES

/*MACROS*/
VMM_Service (_RegisterGARTHandler)
VMM_Service (_GARTReserve)
VMM_Service (_GARTCommit)
VMM_Service (_GARTUnCommit)
VMM_Service (_GARTFree)
VMM_Service (_GARTMemAttributes)
VMM_StdCall_Service (KfRaiseIrqlToDpcLevel, 0)
VMM_Service (VMMCreateThreadEx)
VMM_Service (_FlushCaches)
/*ENDMACROS*/

/*
 * Flags for the VMM GART services.
 * WARNING: THESE FLAGS SHOULD HAVE SAME VALUE AS THE VMM FLAGS DEFINED IN PCI.H
 * IF YOU CHANGE THE VALUE AT EITHER PLACE, YOU NEED TO UPDATE THE OTHER.
 */
#define	PG_UNCACHED		0x00000001		// Uncached memory
#define	PG_WRITECOMBINED	0x00000002		// Write combined memory

/*
 * Flags for the FlushCaches service.
 */
#define FLUSHCACHES_NORMAL              0x00000000
#define FLUSHCACHES_GET_CACHE_LINE_PTR  0x00000001
#define FLUSHCACHES_GET_CACHE_SIZE_PTR  0x00000002
#define FLUSHCACHES_TAKE_OVER           0x00000003
#define FLUSHCACHES_FORCE_PAGES_OUT     0x00000004
#define FLUSHCACHES_LOCK_LOCKABLE       0x00000005
#define FLUSHCACHES_UNLOCK_LOCKABLE     0x00000006

/*MACROS*/
VMM_Service (Set_Thread_Win32_Pri_NoYield)
VMM_Service (_FlushMappedCacheBlock)
VMM_Service (_ReleaseMappedCacheBlock)
VMM_Service (Run_Preemptable_Events)
VMM_Service (_MMPreSystemExit)
VMM_Service (_MMPageFileShutDown)
VMM_Service (_Set_Global_Time_Out_Ex)

VMM_Service (Query_Thread_Priority)

/*ENDMACROS*/

#endif /* WIN41SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning

#ifndef try
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#ifndef exception_code
#define exception_code			__exception_code
#endif
#endif

#ifndef EXCEPTION_EXECUTE_HANDLER
#define EXCEPTION_EXECUTE_HANDLER	1
#define EXCEPTION_CONTINUE_SEARCH	0
#define EXCEPTION_CONTINUE_EXECUTION	-1
#endif
/*XLATON*/

#define COMNFS_FLAT	0xFFFFFFFF

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM		0x00000001
#define RS_RESTORE		0x00000002
#define RS_DOSARENA		0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;			// low (< 1meg) address of item
    ULONG   RS_Bytes;			// size of item in bytes
    ULONG   RS_CallBack;		// callback, if any (zero if none)
    ULONG   RS_RefData; 		// reference data for callback, if any
    ULONG   RS_HookTable;		// real-mode hook table (zero if none)
    ULONG   RS_Flags;			// 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;	/* # pages in linear address space */
    ULONG DIPhys_Count; 	/* Count of phys pages */
    ULONG DIFree_Count; 	/* Count of free phys pages */
    ULONG DIUnlock_Count;	/* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;	/* Base of pageable address space */
    ULONG DILin_Total_Free;	/* Total Count of free linear pages */

    /*
     *	The following 5 fields are all running totals, kept from the time
     *	the system was started
     */
    ULONG DIPage_Faults;	/* total page faults */
    ULONG DIPage_Ins;		/* calls to pagers to page in a page */
    ULONG DIPage_Outs;		/* calls to pagers to page out a page*/
    ULONG DIPage_Discards;	/* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;	/* instance page faults */

    ULONG DIPagingFileMax;	/* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;	/* # of pages of paging file currently in use */

    ULONG DICommit_Count;	/* Total committed memory, in pages */

    ULONG DIReserved[2];	/* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;	    /* INIT <0> RESERVED */
    ULONG InstLinkB;	    /* INIT <0> RESERVED */
    ULONG InstLinAddr;	    /* Linear address of start of block */
    ULONG InstSize;	    /* Size of block in bytes */
    ULONG InstType;	    /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD	0x100	/* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD	0x200	/* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD	0x400	/* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;	    /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;	    /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400	/* anywhere in private arena */
#define PR_SHARED   0x80060000	/* anywhere in shared arena */
#define PR_SYSTEM   0x80080000	/* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008	/* don't move during PageReAllocate */
#define PR_4MEG     0x00000001	/* allocate on 4mb boundary */
#define PR_STATIC   0x00000010	/* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001	/* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002	/* swappable uninitialized pages */
#define PD_FIXEDZERO	0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004	/* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008	/* pages are permanently locked */
#define PC_LOCKED   0x00000080	/* pages are made present and locked*/
#define PC_LOCKEDIFDP	0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE	0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000	/* make the pages ring 3 accessible */
#define PC_INCR     0x40000000	/* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000	/* make pages initially present */
#define PC_STATIC   0x20000000	/* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000	/* make pages initially dirty */
#define PC_CACHEDIS 0x00100000  /* Allocate uncached pages - new for WDM */
#define PC_CACHEWT  0x00080000  /* Allocate write through cache pages - new for WDM */
#define PC_PAGEFLUSH 0x00008000 /* Touch device mapped pages on alloc - new for WDM */

#ifdef WRITE_WATCH
#define PC_WRITE_WATCH 0x00200000 /* to request write_watch in this region */
#endif // WRITE_WATCH

/* PageCommitContig additional flags */
#define PCC_ZEROINIT	0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000	/* don't map to any linear address */


/*MTRR type flags */
#define MTRR_UC 0
#define MTRR_WC 1
#define	MTRR_WT 4
#define	MTRR_WP 5
#define	MTRR_WB 6

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS	       0x01
#define PAGE_READONLY	       0x02
#define PAGE_READWRITE	       0x04
#define MEM_COMMIT	     0x1000
#define MEM_RESERVE	     0x2000
#define MEM_FREE	    0x10000
#define MEM_PRIVATE	    0x20000
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *	clean - page has not been written to since its last page out
 *	dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *	virgin - page has never been written to since it was committed
 *	tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *	For 32-bit EXE code or read-only data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = 0
 *	  pd_cleanout = 0
 *	  pd_dirtyout = 0
 *	  pd_virginfree = 0
 *    pd_taintedfree = 0
 *    pd_dirty = 0
 *	  pd_type = PD_PAGERONLY
 *
 *	For 32-bit EXE writeable data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 *
 *	For zero-initialized swappable data:
 *
 *	  pd_virginin = routine to zero-fill a page
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *	The following four fields are entry points in the pager which
     *	we call to page in or page out a page.	The following parameters
     *	are passed to the pager during these calls:
     *
     *	ppagerdata - pointer to the pager-specific dword of data
     *		 stored with the virtual page.	The pager is
     *		 free to modify the contents of this dword
     *		 DURING the page in or out, but not afterwards.
     *
     *	ppage - pointer to page going in or out (a ring 0 alias
     *	    to the physical page).  The pager should use this
     *	    address to access the contents of the page.
     *
     *	faultpage - faulting linear page number for page-ins, -1 for
     *		page-outs.  This address should not be accessed
     *		by the pager.  It is provided for information
     *		only.  Note that a single page can be mapped at
     *		more than one linear address because of the
     *		MapIntoV86 and LinMapIntoV86 services.
     *
     *	The pager should return non-0 if the page was successfully
     *	paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *	The pd_*free routines are used to inform the pager when the last
     *	reference to a virtual page controlled by the pager is
     *	decommitted.  A common use of this notification is to
     *	free space in a backing file, or write the page contents
     *	into the backing file.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions, but no return value is recognized.  The "ppage"
     *	and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *	The pd_dirty routine is used to inform the pager when the
     *	memory manager detects that a page has been written to.  The memory
     *	manager does not detect the write at the instant it occurs, so
     *	the pager should not depend upon prompt notification.  A common
     *	use of this notification might be to invalidate cached data.
     *	If the page was dirtied in more than one memory context,
     *	the pager's pd_dirty routine will be called once for each
     *	context.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions except that the "ppage" parameter isn't valid and
     *	no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *	The pd_type field gives the sytem information about the
     *	overcommit characteristics of pages controlled by this pager.
     *	The following are allowable values for the field:
     *
     *	PD_SWAPPER - under some conditions, pages of this type
     *	    may be paged out into the swap file
     *	PD_PAGERONLY - pages controlled by this pager will never
     *	    be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *	    functions perform nested excecution or block using the
     *	    BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *	    specified if the pager does any sort of file i/o to anything
     *	    other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER  0	/* pages need direct accounting in swap file */
#define PD_PAGERONLY	1   /* pages will never be swapped */
#define PD_NESTEXEC 2	/* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

/* XLATOFF */    
#ifndef PAGE
#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#endif
/* XLATON */

#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR	    ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR	    ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR	    ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR	    ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR	((ULONG) 0x003fffff)
#define MINDOSLADDR	((ULONG) 0x00000000)

#define MAXSYSTEMPAGE	    (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE	    (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE	    (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE	    (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE	    (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE	    (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE	(MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE	(MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE	(1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED	(1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM	(1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS		(1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE	(1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED	(1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM	(1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS		(1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC	(max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC	(max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar	EQU NEAR PTR
ELSE
DebFar	EQU SHORT
ENDIF
*/

#define ASD_MAX_REF_DATA    256	    // If bigger than this, a checksum is used

struct	_vmmguid {
unsigned long Data1;
unsigned short Data2;
unsigned short Data3;
unsigned char Data4[8];
};

typedef struct _vmmguid VMMGUID;
typedef VMMGUID     *VMMREFIID;

typedef DWORD		ASD_RESULT;

#define ASD_ERROR_NONE	    0x00000000
#define ASD_CHECK_FAIL	    0x00000001	// The flag is set that this failed before
#define ASD_CHECK_SUCCESS   0x00000002	// The flag is set that this succeeded before
#define ASD_CHECK_UNKNOWN   0x00000003	// No flag is set
#define ASD_ERROR_BAD_TIME  0x00000004	// Under cli
#define ASD_REGISTRY_ERROR  0x00000005	// Unknown registry error
#define ASD_CLEAN_BOOT	    0x00000006	// Clean booting fails everything
#define ASD_OUT_OF_MEMORY   0x00000007	// Ran out of memory (extremely rare)
#define ASD_FILE_ERROR	    0x00000008	// Int 21 to flush the info file failed
#define ASD_ALREADY_SET     0x00000009	// ASD_CHECK* done twice on same vgOperation/pRefData
#define ASD_MISSING_CHECK   0x0000000A	// ASD_DONE* on something not set
#define ASD_BAD_PARAMETER   0x0000000B	// Invalid operation, refiid or ref pointer

#define ASD_OP_CHECK_AND_WRITE_FAIL_IF_UNKNOWN	0x00000000
#define ASD_OP_CHECK_AND_ALWAYS_WRITE_FAIL	0x00000001
#define ASD_OP_CHECK				0x00000002
#define ASD_OP_DONE_AND_SET_SUCCESS		0x00000003
#define ASD_OP_SET_FAIL 			0x00000004
#define ASD_OP_SET_SUCCESS			0x00000005
#define ASD_OP_SET_UNKNOWN			0x00000006
#define ASD_OP_DONE				0x00000007

#define ASD_FLAG_STRING     0x00000001

#ifndef Not_VxD

/******************************************************************************
 *
 *	     EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.	Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000	/* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT	0x0001	    /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.	Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE	    0x0002	/* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT	0x0003	    /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */
#define SYS_VM_TERMINATE    0x0004	/* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT	0x0005	    /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.	SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006	/* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM	0x0007

/*
 *  Second phase of Create_VM.	EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT 	0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE	    0x000A	/* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.	VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B	/* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.	EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM	0x000C	    /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00	/* VM was crashed */
#define VNE_CRASHED	(1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT	    0x01	/* VM was destroyed while active */
#define VNE_NUKED	(1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02	/* Some device failed Create_VM */
#define VNE_CREATEFAIL	    (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03	/* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL	    (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04	/* Some device failed VM_Init */
#define VNE_INITFAIL	    (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT	    0x05
#define VNE_CLOSED	(1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND	0x000D	    /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME	0x000E	    /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.	Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012	/* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY	    0x0013	/* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY	0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP	    0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT	0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP	0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY	0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *	  CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT	0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD	0x001D

/*
 *  Second phase of creating a thread.	EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT	0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * BUGBUG: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN	DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2	    0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2	    0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2	0x0029
#define VM_SUSPEND2	0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2	0x002C
#define DEVICE_REBOOT_NOTIFY2	0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER	0x0030

#define KERNEL32_INITIALIZED	0x0031

#define KERNEL32_SHUTDOWN	0x0032

#define CREATE_PROCESS		0x0033
#define DESTROY_PROCESS 	0x0034

#ifndef WIN40COMPAT
#define SYS_DYNAMIC_DEVICE_REINIT 0x0035
#endif
#define SYS_POWER_DOWN		0x0036

#define MAX_SYSTEM_CONTROL	0x0036

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL 0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

		    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
		    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT	    0x10000000
		    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
		    /* INIT_COMPLETE is broadcast */
		    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
		    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
		    /* All initialization completed */
		    /* System running normally */
		    /* System shutdown initiated */
		    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
		    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
		    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT	    0xE0000000
		    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
		    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
		    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
		    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
		    /* Return to real mode */
		    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
		    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT	    0xFFFFF000
		    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU	    0xFFFFFF00
		    /* REBOOT_PROCESSOR is broadcast */
		    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC		; Used outside this module (default)
;   LOCAL		; Local to this module
;   HIGH_FREQ		; DWORD align procedure
;   SERVICE		; Routine is called via VxDCall
;   ASYNC_SERVICE	    ; Same as "SERVICE" plus routine can
;		    ;	be called under interrupt.
;   HOOK_PROC		; Proc is a handler installed with
;		    ;	with a call to Hook_xxx_Fault
;		    ;	or Hook_Device_Service.  The
;		    ;	following parameter must be
;		    ;	the label of a DWORD location
;		    ;	which will hold the ptr to next
;		    ;	hook proc. e.g.
;
;		   ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG		; Disable Queue_Out call logging
;   NO_PROFILE		; Disable DynaLink profile counts
;   NO_TEST_CLD 	; Disable direction flag check
;
;   TEST_BLOCK		; Trap if in NOBLOCK state
;		    ;  (default if in pageable code seg)
;   TEST_REENTER	    ; Trap if Get_VMM_Reenter_Count != 0
;		    ;  (default for non-async services)
;   NEVER_REENTER	    ; Trap if VMM has been reentered
;   NOT_SWAPPING	    ; Trap if this thread is swapping
;
;   NO_PROLOG		; Disable all prolog tests
;
;   ESP 	    ; Use ESP instead of EBP for stack
;		    ;  frame base
;   PCALL		; pascal calling convention
;   SCALL		; stdcall calling convention
;   FASTCALL		; stdcall, but first 2 parameters are passed in ECX & EDX
;   CCALL		; "C" calling convention
;   ICALL		; default calling convention
;   W32SVC		; Win32 service
;
;   segment type	    ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type	    ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1	;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed	equ 2	    ;; ArgVars were used
??_pf_Entered	equ 4	    ;; EnterProc performed
??_pf_Left  equ 8	;; LeaveProc performed
??_pf_Returned	equ    16		;; Return performed

??_pushed	=	0		;; For WIN31COMPAT
??_align    =	0	;; For WIN31COMPAT
??_ends     equ <>	;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0	    ;; local frame base
    ??_aframe = 0	    ;; argument frame base
    ??_taframe = 0	    ;; true argument frame base
    ??_initaframe = 0	    ;; initial aframe value
    ??_numargs = 0	    ;; number of argvars
    ??_numlocals = 0	    ;; number of localvars
    ??_numlocalsymbols = 0	;; number of local symbols
    ??_procflags = 0	    ;; misc. Enter/LeaveProc flags
    ??_esp = 0		;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0	    ;; number of bytes pushed
    ??_align = 0	    ;; set if proc should be dword aligned
    ??_hook = 0 	;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG	    ;; logging on by default
    ??_profile = DFS_PROFILE	;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD	;; test that direction is clear
ELSE
    ??_log = 0		;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE	;; service profiling on by default
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
    ??_test_cld = 0	    ;; test that direction is clear
ENDIF
    ??_might_block = 0	    ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0	;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0	;; use a prolog by default
    ??_public = 1	    ;; everything's public by default
    ??_cleanoff = 0	    ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_fastcall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0		;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
	if ??_hookarg
	??_hookarg = 0
	??_hookvar equ <arg>
	elseifdef ?&&arg&&_BeginProc
	    ?&&arg&&_BeginProc
	elseifdef VxD_&&arg&&_CODE_SEG
	??_ends textequ <VxD_&&arg&&_CODE_ENDS>
	VxD_&&arg&&_CODE_SEG
	else
	.err <Bad param "&arg" to BeginProc>
	endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
    ife ??_service
	ifndef profileall
	  ??_profile = 0      ;; only services can be profiled
	endif
	ifdef VMMSYS
	??_prolog_disabled = 1
	endif
    else
	??_test_cld = DFS_TEST_CLD
    endif	; ife ??_service

    ife ?_16ICODE
	??_prolog_disabled = 1
    else
    ife ?_RCODE 	    ;; if real-mode code segment
	??_prolog_disabled = 1	;; don't do anything stupid
    else		;; else protected mode code segment
	ife ?_PCODE	;; if swappable code
	??_might_block = DFS_TEST_BLOCK
	endif
	if ??_service
	ife ??_async_service
	    ??_test_reenter = DFS_TEST_REENTER
	endif
	endif
    endif	; ife ?_RCODE
    endif	; ife ?_16ICODE
    endif   ; Not_VxD

    if ??_esp
    ;; just return address on stack
    ??_basereg equ <esp+??_pushed>
    ??_initaframe = 4
    else
    ;; ret addr and EBP on stack
    ??_basereg equ <ebp>
    ??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall or ??_fastcall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
	 ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
	??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

    if ??_hook
	if ??_align
	Dword_Align
	endif
	prelabeldata:
	ifndef ??_hookvar
	.err <HOOK_PROC requires next arg to be name of dword location>
	endif
	jmp short Name
	jmp [??_hookvar]
	ifdef DEBUG
	Profile_Data dd  0
	endif
	if ??_align
	.errnz ($ - prelabeldata) mod 4
	endif
    endif

    ifdef DEBUG
	?prolog_&Name label near
	if (??_service OR ??_profile) AND (??_hook EQ 0)
	jmp short Name
	if ??_align
	Dword_Align	; This also aligns the proc
	endif		;   since Profile_Data is a dd

	IF ?_ICODE
	ifdef profileall
	  ?ProfileHeader_BeginProc Profile_Data, %@filename
	else
	  Profile_Data dd 0
	endif
	ELSE
	  Profile_Data dd 0
	ENDIF

	endif
    endif

    if ??_align
	Dword_Align
    endif

    endif   ; Not_VxD

    Name proc near	;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;	     Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall or ??_fastcall    ;; if no munging
	if ??_public
	    public Name
	else
	    ifdef DEBUG
		% ?merge @FileName,$,Name,:
		% ?merge public,,,,,@FileName,$,Name
	    endif
	endif
    endif
    if ??_ccall
	if ??_public
	    _&Name equ Name
	ifdef Not_VxD
	 public C Name
	else
		 public _&Name
	endif
	endif
    endif
    if ??_pcall
	if ??_public
	    ?toupper Name
	    ?merge  public,,,,%?upper
	endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;	     DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service

    ife ??_scall or ??_fastcall
    ?_BeginProc_Debug_Prologue
    endif

    ;; Phase 7:  Post-label code
    ;;	     <none>
endm

?_BeginProc_Debug_Prologue MACRO
    ifndef Not_VxD
    ifdef DEBUG
	if ??_dfs EQ DFS_LOG
	VMMCall Log_Proc_Call	;; no test, just log
	else
	if ??_dfs EQ DFS_TEST_REENTER
	VMMCall Test_Reenter	;; no log, just reenter
	else
	if ??_dfs or ?_LOCKABLECODE eq 0
	ifdef WIN31COMPAT
	    if ??_dfs AND DFS_LOG
	    VMMCall Log_Proc_Call
	    endif
	    if ??_dfs AND DFS_TEST_REENTER
	    VMMCall Test_Reenter
	    endif
	else
	    ife ?_LOCKABLECODE
	    ifdef ??_debug_flags
	    push    ??_debug_flags
	    if ??_dfs
	    pushfd
	    or	dword ptr [esp+4],??_dfs
	    popfd
	    endif
	    VMMCall _Debug_Flags_Service
	    elseif ??_dfs
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	    else
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	endif
	else
	  ifdef profileall
	IncProfileCount
	  endif
	endif		;if ??_dfs
	endif		; if ??_dfs EQ DFS_TEST_REENTER
	endif		; if ??_dfs EQ DFS_LOG
    endif ; DEBUG
    endif ; Not_VxD
ENDM

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
    .erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
    .erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?FASTCALL_BeginProc macro
    ??_fastcall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
	inc dword ptr [??_name-4]
    else
	ifndef profileall
	.err <IncProfileCount can be used only in services.>
	endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***	ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;	 to indicate that the argument will not be used
;	 by the procedure.
;

ArgVar	macro	name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
	?mkarg	<name>, <length>, <used>, %??_numargs
    else
	?arg <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg	macro	name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
	?argvar <name>, <length>, <used>
	&endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro	name,length,used
    local   a
    a = ??_taframe
    ??_aframe =  ??_aframe + 4
    ??_taframe =  ??_taframe + 4
    ifidni  <length>,<BYTE>
	?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
	?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
	?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
	?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
	??_aframe =  ??_aframe - 4 + ((length + 3)/4)*4
	??_taframe =  ??_taframe - 4 + ((length + 3)/4)*4
	?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

?arg macro   name,length,used
  if ??_fastcall
    if ??_numargs le 2
      if length gt 4
	.err <First 2 parameters are dwords (ecx,edx) for fastcall functions>
      endif
      ??_aframe =  ??_aframe + 4
      if ??_numargs eq 1
	?merge ecx_,name,,,equ,ecx
      else
	?merge edx_,name,,,equ,edx
      endif
    else
      ?argvar name, length, used
    endif
  else
    ?argvar name, length, used
  endif
endm

;***	?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
	name equ _inaccessible_NOTUSED_
    else
	name equ value
	??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***	LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;	 to suppress the usual padding and aligning of variables
;	 PACK is typically used when declaring a bunch of
;	 byte or word variables.  Make sure that the total
;	 size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
	??_pad = 0
    endif
    ifidni  <length>,<BYTE>
	??_frame = ??_frame + 1 + 3 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
	??_frame =  ??_frame + 2 + 2 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
	??_frame = ??_frame + 4
	a = ??_frame
	?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
	name equ dword ptr [??_basereg-a]
	name&l equ word ptr [??_basereg-a]
	name&ll equ byte ptr [??_basereg-a]
	name&lh equ byte ptr [??_basereg-a+1]
	name&h equ word ptr [??_basereg-a+2]
	name&hl equ byte ptr [??_basereg-a+2]
	name&hh equ byte ptr [??_basereg-a+3]
    else
	??_frame =  ??_frame + ((length + 3)/4)*4
	a = ??_frame
	?deflocal <name>
	name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
	??_numlocalsymbols = ??_numlocalsymbols + 1
	?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
	name	equ <__inaccessible__NOTINSCOPE__>
	&endm
    endm
    .xcref  ?dodeflocal

;***	EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	_,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,_,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_fastcall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	@,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,@,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_pcall
	??_aframe = 0
	?count = ??_numargs
	rept	??_numargs
	    ?invprg <?MKA>,%?count
	    ?count = ?count - 1
	endm
    endif
    ??_fleave = FALSE
    if ??_esp
	if  ??_frame
	    sub esp, ??_frame
	    ??_pushed = ??_pushed + ??_frame
	    ??_fleave = VMM_TRUE
	endif
    else
	if  ??_frame eq 0
	    if (??_taframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
		ifdef DEBUG
		    push    ebp
		    mov ebp,esp
		    ??_fleave = VMM_TRUE
		endif
	    else
		push	ebp
		mov ebp,esp
		??_fleave = VMM_TRUE
	    endif
	else
	    enter   ??_frame, 0
	    ??_fleave = VMM_TRUE
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***	LeaveProc - removes stack frame on exit
;
;   NOTE:   If there are localvar and ESP kind of stack frame
;	LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;	flag is given.	PRESERVE_FLAGS generates bigger, slower
;	code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;	 the internal stack depth for the local frame.	This is
;	 to allow jumping around the LeaveProc/Return to code
;	 after the LeaveProc/Return to use args/local variables,
;	 but code that uses the stack frame executed after the
;	 LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
	if ??_esp
	    ifidni <flags>,<PRESERVE_FLAGS>
		lea esp,[esp + ??_frame]
	    else
		add esp,??_frame
	    endif
	else
	    leave
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***	Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return	macro
    if	??_cleanoff OR ??_w32svc
	if  ??_w32svc AND (??_taframe LT 8)
	    ret 8
	else
	    ret ??_taframe
	endif
    else
	ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***	EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp		;; Masm will provide error msg for us
if ??_w32svc
    if ??_taframe lt 8
	cparm&Name equ 0
    else
	cparm&Name equ (??_taframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi	<Flag>,<NOCHECK>
    if ??_pushed ne 0
	%out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
	ife ??_procflags AND ??_pf_Entered
	    %out Warning: ArgVar/LocalVar without EnterProc in Name
	endif
	ife ??_procflags AND ??_pf_Left
	    %out Warning: ArgVar/LocalVar without LeaveProc in Name
	endif
	ife ??_procflags AND ??_pf_Returned
	    %out Warning: ArgVar/LocalVar without Return in Name
	endif
    endif
endif
ifdifi	<Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
	?count = ?count + 1
	?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***	cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall	macro	name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    ifdef ??_nonstandardccall_&name
    PushCParams <arglst>, <FAST>
    else
    PushCParams <arglst>, <flags>
    endif
    call    name
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    endm
    .xcref  cCall

;***	pCall - pascal call
;
;   Arguments pushed in pascal order, callee cleans stack
;

pCall	macro	name, arglst
    local   ??saved
    ife .TYPE name
	?toupper name
    else
	?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
	push	x
	??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***	sCall - standard call
;
;   Arguments pushed in "C" order, callee cleans stack,
;   @argc appended to name
;

sCall	macro	name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  _, name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***	fCall - fastcall call
;
;   Arguments pushed in "C" order (except first two parms,
;   which are passed in ECX and EDX), callee cleans stack, and
;   @argc appended to name.
;
;   The only useful value for flags is PRESERVE_FLAGS,
;   which can also be achieved by simply declaring the function
;   as non-standard, like so:
;
;	DeclareNonstandardCcallService <functionname>
;

fCall	macro	name, arglst, flags
    local   ??saved
    ??saved = ??_pushed
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <FASTCALL>
    ?scall  @, name, %(??_argc * 4)
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    ??_pushed = ??saved
    endm
    .xcref  fCall

;***	iCall - internal routine call
;
;   Set to whatever type we want to use as a default.

iCall	equ <sCall>

;***	PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;	the word FAST if we should prefer speed over size
;
;	The default flag is SMALL, unless the current procedure
;	is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF	STANDARD_CCALL
NONSTANDARD_CCALL = 1		;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    LOCAL ??_pushedargs

    ??_argc = 0 	;; number of dwords on stack (global)
IFDEF	NONSTANDARD_CCALL
    ??_popargs = 0		;; establish default
ELSE
    ??_popargs = ??_align EQ 0	;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
	??_popargs = 1		;; size, not speed
    elseifidni <flags>, <FAST>
	??_popargs = 0		;; speed, not size
    elseifidni <flags>, <FASTCALL>
	??_popargs = 0		;; speed, not size
    endif

    irp x,<arglst>
	??_argc = ??_argc + 1
	ifidni <flags>, <FASTCALL>
	  if ??_argc eq 1
	    ifdifi <x>, <ecx>
	      .err <first parameter must be ECX for fastcall functions>
	    endif
	  elseif ??_argc eq 2
	    ifdifi <x>, <edx>
	      .err <first parameter must be EDX for fastcall functions>
	    endif
	  else
	    ?marg   <x>,%??_argc
	  endif
	else
	  ?marg   <x>,%??_argc
	endif
    endm
    ?count = ??_argc
    ifidni <flags>, <FASTCALL>
      ??_pushedargs = ??_argc-2
    else
      ??_pushedargs = ??_argc
    endif
    if ??_pushedargs GT 0
      rept    ??_argc
	?invprg <?AM>,%?count
	?count = ?count - 1
      endm
    endif
    endm

;***	ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;   If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;   This will generate bigger, slower code, so use it only when
;   necessary.

ClearCParams macro fPreserveFlags
    if	??_argc ne 0
	if (??_popargs) AND (??_argc LE 2)
	  rept ??_argc
	  pop ecx
	  endm
	elseifidni <fPreserveFlags>, <PRESERVE_FLAGS>
	  lea esp, [esp][??_argc * 4]
	else
	  add esp,??_argc * 4
	endif
    endif
    ??_pushed = ??_pushed - (??_argc * 4)
    endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg	macro	name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
	push	name
	??_pushed = ??_pushed + 4
	&endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro	name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall	macro	prefix, name1, name2
    CondExtern prefix&name1&@&name2, near
    call    prefix&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge	macro	l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
	if '&x' GE 'a'
	  if '&x' LE 'z'
	?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
	?upper catstr ?upper,?t1
	  else
	?upper catstr ?upper,<&x>
	  endif
	else
	  ?upper catstr ?upper,<&x>
	endif
      endm
    endm
    .xcref

;***	CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
	ifndef name
	externdef name:dist
	endif
    else
	if2
	ifndef name
	    extrn name:dist
	endif
	endif
    endif
endm

;***	SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro	reglist 	;; push those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    pushfd
	    ??_pushed = ??_pushed + 4
	else
	ifidni <reg>, <ad>
	    pushad
	    ??_pushed = ??_pushed + SIZE Pushad_Struc
	else
	    push    reg
	    ??_pushed = ??_pushed + 4
	endif
	endif
    endm
endm

;***	RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist	;; pop those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    popfd
	    ??_pushed = ??_pushed - 4
	else
	ifidni <reg>, <ad>
	    popad
	    ??_pushed = ??_pushed - SIZE Pushad_Struc
	else
	    pop reg
	    ??_pushed = ??_pushed - 4
	endif
	endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.	Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db	'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd	OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd	0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *	   S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST	0x00000010
#define HIGH_PRI_DEVICE_BOOST	0x00001000
#define CRITICAL_SECTION_BOOST	0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S	 F O R	 C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT	    0
#define PEF_WAIT_FOR_STI	(1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT	    1
#define PEF_WAIT_NOT_CRIT	(1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT	    2
#define PEF_DONT_UNBOOST	(1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT	    3
#define PEF_ALWAYS_SCHED	(1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT	4
#define PEF_TIME_OUT		(1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT	(1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT	6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT	7
#define PEF_WAIT_IN_PM		(1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT	    8
#define PEF_THREAD_EVENT	(1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT	    10
#define PEF_RING0_EVENT 	(1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	11
#define PEF_WAIT_CRIT	    (1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM    (1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST    (1 << PEF_PROCESS_LAST_BIT)

#define PEF_WAIT_PREEMPTABLE_BIT    14
#define PEF_WAIT_PREEMPTABLE (1 << PEF_WAIT_PREEMPTABLE_BIT)

#define PEF_WAIT_FOR_PASSIVE_BIT	    15
#define	PEF_WAIT_FOR_PASSIVE     (1 << PEF_WAIT_FOR_PASSIVE_BIT)

//
// The next two are equivalent of SHELL_Call_At_Appy_Time and ExQueueWorkItem,
// they are mostly to be used by _Set_Global_Time_Out_Ex. No other flag can be
// set with them. Note that the dispatching of the callback of these two new
// PEF (with both Call_Restricted_Event and _Set_Global_Time_Out_Ex) follow
// the original convention but EDX (the ref data) is CDECL pushed/pop on the
// stack, so that the callback function can be a standard
// VOID CDECL FOO(ULONG BAR);
//
	
#define PEF_WAIT_FOR_APPY_BIT	    16
#define	PEF_WAIT_FOR_APPY     (1 << PEF_WAIT_FOR_APPY_BIT)

#define PEF_WAIT_FOR_WORKER_BIT	    17
#define	PEF_WAIT_FOR_WORKER     (1 << PEF_WAIT_FOR_WORKER_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT	     PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK	 PEF_WAIT_NOT_NESTED_EXEC

//
// If you may want to call CONFIGMG synchronously at some point.
//
#define	PEF_WAIT_FOR_CONFIGMG_CALLABLE	PEF_WAIT_FOR_WORKER

//
// If you will want to call CONFIGMG synchronously (slower callback, but no
// context switch in CONFIGMG).
//
#define	PEF_WAIT_FOR_CONFIGMG_QUICK	PEF_WAIT_FOR_APPY

/******************************************************************************
 *	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *			     E N T E R _ M U T E X
 *	       A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT	0
#define BLOCK_SVC_INTS		(1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT	1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT	    2
#define BLOCK_ENABLE_INTS	(1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT		3
#define BLOCK_POLL	    (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT		4
#define BLOCK_THREAD_IDLE		(1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT	5
#define BLOCK_FORCE_SVC_INTS	    (1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;		/* Client's EDI */
    ULONG Client_ESI;		/* Client's ESI */
    ULONG Client_EBP;		/* Client's EBP */
    ULONG Client_res0;		/* ESP at pushall */
    ULONG Client_EBX;		/* Client's EBX */
    ULONG Client_EDX;		/* Client's EDX */
    ULONG Client_ECX;		/* Client's ECX */
    ULONG Client_EAX;		/* Client's EAX */
    ULONG Client_Error; 	/* Dword error code */
    ULONG Client_EIP;		/* EIP */
    USHORT Client_CS;		/* CS */
    USHORT Client_res1; 	/*   (padding) */
    ULONG Client_EFlags;	/* EFLAGS */
    ULONG Client_ESP;		/* ESP */
    USHORT Client_SS;		/* SS */
    USHORT Client_res2; 	/*   (padding) */
    USHORT Client_ES;		/* ES */
    USHORT Client_res3; 	/*   (padding) */
    USHORT Client_DS;		/* DS */
    USHORT Client_res4; 	/*   (padding) */
    USHORT Client_FS;		/* FS */
    USHORT Client_res5; 	/*   (padding) */
    USHORT Client_GS;		/* GS */
    USHORT Client_res6; 	/*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;		/* Client's DI */
    USHORT Client_res13;	/*   (padding) */
    USHORT Client_SI;		/* Client's SI */
    USHORT Client_res14;	/*   (padding) */
    USHORT Client_BP;		/* Client's BP */
    USHORT Client_res15;	/*   (padding) */
    ULONG Client_res16; 	/* ESP at pushall */
    USHORT Client_BX;		/* Client's BX */
    USHORT Client_res17;	/*   (padding) */
    USHORT Client_DX;		/* Client's DX */
    USHORT Client_res18;	/*   (padding) */
    USHORT Client_CX;		/* Client's CX */
    USHORT Client_res19;	/*   (padding) */
    USHORT Client_AX;		/* Client's AX */
    USHORT Client_res20;	/*   (padding) */
    ULONG Client_res21; 	/* Dword error code */
    USHORT Client_IP;		/* Client's IP */
    USHORT Client_res22;	/*   (padding) */
    ULONG Client_res23; 	/* CS */
    USHORT Client_Flags;	/* Client's flags (low) */
    USHORT Client_res24;	/*   (padding) */
    USHORT Client_SP;		/* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];	/* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;		/* Client's BL */
    UCHAR Client_BH;		/* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;		/* Client's DL */
    UCHAR Client_DH;		/* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;		/* Client's CL */
    UCHAR Client_CH;		/* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;		/* Client's AL */
    UCHAR Client_AH;		/* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc	  CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0	/* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT	0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;   Declare services as conforming to the C calling convention
;   for parameter-passing, but *not* conforming to the C calling
;   convention for register usage.
;
;   Services which do not use the C calling convention for
;   parameter-passing need not be declared as nonstandard.
;
;   arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
    irp x,<arglst>
	??_nonstandardccall_&&x = 1
    endm
endm

;
; The following VMM services are nonstandard:
;	_BlockOnID and _LocalizeSprintf modify no registers except flags.
;	_SetLastV86Page modifies no registers except EAX and flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints	; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd	OFFSET32 vt[sn+jf]
ENDM

GenDD	MACRO	P, vid, snum, jflag
    LOCAL   vtable
IFDEF	@@VxDName&vid
    Deftable	vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd	@@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)

    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

VxDJmp	MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

WDMCall MACRO P, Param, flags
    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    mov	eax,WDM@@&P
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

WDMJmp	MACRO P, Param
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to WDMJmp>
    endif
    mov	eax, WDM@@&P+WDM_DL_Jmp_Mask
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ENDM

WDM_DL_Jmp_Mask	EQU	80000000h
WDM_DL_Jmp_Bit	EQU	31

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;VxD_LOCKED_CODE_SEG	defines start of always present code segment
;VxD_LOCKED_CODE_ENDS	defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG	defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT	 ENDS
	ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT	 ENDS
	ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DB1CODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
	ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DB1CODE    ENDS
	ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT	ENDS
	ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
	ENDM


;   Protected mode initialization data

VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
	ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
	ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA	 ENDS
	ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT	 ENDS
	ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA	 ENDS
	ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DB2DATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DB2DATA    ENDS
	ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
	  ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
	   ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
	  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
	   ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A	    /* 3.10 */
#else  // WIN31COMPAT

#ifdef WIN40COMPAT
#define DDK_VERSION 0x400	    /* 4.00 */
#else  // WIN40COMPAT

#define DDK_VERSION 0x40A	    /*Memphis is 4.1 */

#endif // WIN40COMPAT

#endif // WIN31COMPAT

#endif // DDK_VERSION

struct VxD_Desc_Block {
    ULONG DDB_Next;	    /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;	/* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;		/* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];		/* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;	/* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;	/* Offset of control procedure */
    ULONG DDB_V86_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;	    /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;	    /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;	/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;	/* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;	/* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;	/* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block	    *PVMMDDB;
typedef PVMMDDB 	    *PPVMMDDB;

#ifndef Not_VxD

/* XLATOFF */

typedef (_cdecl * VXD_C_SERVICE)();
typedef VXD_C_SERVICE VXD_SERVICE_TABLE[];

#define	Declare_Virtual_Device(quote_name, name, ctrl_proc, device_num, init_order, V86_proc, PM_proc, ref_data) \
struct VxD_Desc_Block name##_DDB={ \
0, \
0, \
device_num, \
DDK_VERSION >> 8, \
DDK_VERSION & 0XFF, \
0, \
quote_name, \
init_order, \
(ULONG)ctrl_proc, \
(ULONG)V86_proc, \
(ULONG)PM_proc, \
0, \
0, \
ref_data, \
0, \
0, \
0, \
0, \
sizeof(struct VxD_Desc_Block), \
'Rsv1', \
'Rsv2', \
'Rsv3' \
};

#define	Declare_Virtual_Device_With_Table(quote_name, name, ctrl_proc, device_num, init_order, V86_proc, PM_proc, ref_data, table_ptr) \
struct VxD_Desc_Block name##_DDB={ \
0, \
DDK_VERSION, \
device_num, \
DDK_VERSION >> 8, \
DDK_VERSION & 0XFF, \
0, \
quote_name, \
init_order, \
(ULONG)ctrl_proc, \
(ULONG)V86_proc, \
(ULONG)PM_proc, \
0, \
0, \
ref_data, \
(ULONG)table_ptr, \
(ULONG)(sizeof(table_ptr)/sizeof(VXD_C_SERVICE)), \
0, \
0, \
sizeof(struct VxD_Desc_Block), \
'Rsv1', \
'Rsv2', \
'Rsv3' \
};

/* XLATON */

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE	    (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE	    (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT	    14
#define DDB_HAS_WIN32_SVCS	(1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT	15
#define DDB_DYNAMIC_VXD 	(1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED	    (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB	<Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
	Ref_Data_Offset EQU 0
ELSE
	Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db	0dh, 0ah, 'D_E_B_U_G===>'
	db	"&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
	     OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
	     ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd	OFFSET32 ??_cd_&&num
ELSE
    dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc 	    ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz	Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT	0x014

#define OUTPUT_BIT  2
#define OUTPUT	    (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT	4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT	5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO	    (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT	7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT	8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT	0x10		/* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb	In_Proc
ELSE
    je	Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw	Table_Name&_Entries
ELSE
    dw	?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw	Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw	Port
    dd	OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
	ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a return.  If non-debugging version then the
;	   specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   CallJmp -- Call procedure then jump to label.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a jmp.  If non-debugging version then the desired return
;          address will be pushed on the stack and the specified label will
;          be jumped to.
;
;   PARAMETERS:
;   Function_Name = Procedure to be called
;   Return_Label  = Address to return to
;
;   EXIT:
;
;------------------------------------------------------------------------------
EndDoc

CallJmp MACRO Function_Name, Return_Label
IFDEF DEBUG
    call    Function_Name
    jmp     Return_Label
ELSE
    push    Return_Label
    jmp     Function_Name
ENDIF
    ENDM


BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF	DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
	VMMCall _ExecVxDIntMustComplete
    ENDM

Load_FS 	macro
	VMMCall Load_FS_Service
endm
*/

/*XLATOFF*/
#define Load_FS VMMCall(Load_FS_Service)
/*XLATON*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0	/* loaded */
#define DUPLICATE_DEVICE_ID	(1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1	/* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F	    (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT	    2	/* in the INT 2F device list */
#define LOADING_FROM_INT2F	(1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK	    0	/* load protected mode portion */
#define ABORT_DEVICE_LOAD   1	/* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2	/* fatal-error: abort load of Win386 */
#define DEVICE_NOT_NEEDED   3	/* don't load protected mode portion */
				/* b/c the driver's presence is not needed */



#define NO_FAIL_MESSAGE_BIT 15	/* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0	/* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING	1   /* search for next string */
#define LDRSRV_RESERVED 	2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3	/* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT	4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5	/* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6	/* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO	    7	/* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey	0x100
#define LDRSRV_RegCreateKey	0x101
#define LDRSRV_RegCloseKey	0x102
#define LDRSRV_RegDeleteKey	0x103
#define LDRSRV_RegSetValue	0x104
#define LDRSRV_RegQueryValue	    0x105
#define LDRSRV_RegEnumKey	0x106
#define LDRSRV_RegDeleteValue	    0x107
#define LDRSRV_RegEnumValue	0x108
#define LDRSRV_RegQueryValueEx	    0x109
#define LDRSRV_RegSetValueEx	    0x10A
#define LDRSRV_RegFlushKey	0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT	1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED	2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE	    3	/* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*	    Also Init type objects should be added to the second part of the
*	    list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ	-1

#define LCODE_OBJ	0x01
#define LDATA_OBJ	0x02
#define PCODE_OBJ	0x03
#define PDATA_OBJ	0x04
#define SCODE_OBJ	0x05
#define SDATA_OBJ	0x06
#define CODE16_OBJ	0x07
#define LMSG_OBJ	0x08
#define PMSG_OBJ	0x09

#define DBOC_OBJ    0x0B
#define DBOD_OBJ    0x0C

#define PLCODE_OBJ	0x0D
#define PPCODE_OBJ	0x0F

#define ICODE_OBJ	0x11
#define IDATA_OBJ	0x12
#define ICODE16_OBJ	0x13
#define IMSG_OBJ	0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *	Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT	    0	/* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT	    1	/* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT	    2	/* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT	    3	/* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT	    4	/* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT	    31	/* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT	    0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT	    2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT	    4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT	    6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT	    7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT	    8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT	    9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT	    10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT	    11	/* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT	    14	/* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT	    16	/* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT	    17	/* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT	    18	/* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19	/* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20	/* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *		PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE	    0x1000	/* page size */

/******************************************************************************
 *
 *		PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES	    (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER	    (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC	    (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM	    0
#define PG_SYS	    1
#define PG_RESERVED1	2
#define PG_PRIVATE  3
#define PG_RESERVED2	4
#define PG_RELOCK   5	    /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES	    0x080	/* present in memory */
#define D_NOTPRES   0	    /* not present in memory */

#define D_DPL0	    0	    /* Ring 0 */
#define D_DPL1	    0x020	/* Ring 1 */
#define D_DPL2	    0x040	/* Ring 2 */
#define D_DPL3	    0x060	/* Ring 3 */

#define D_SEG	    0x010	/* Segment descriptor */
#define D_CTRL	    0	    /* Control descriptor */

#define D_GRAN_BYTE 0x000	/* Segment length is byte granular */
#define D_GRAN_PAGE 0x080	/* Segment length is page granular */
#define D_DEF16     0x000	/* Default operation size is 16 bits */
#define D_DEF32     0x040	/* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE	    0x08	/* code */
#define D_DATA	    0	    /* data */

#define D_X	0	/* if code, exec only */
#define D_RX	    0x02	/* if code, readable */
#define D_C	0x04	    /* if code, conforming */

#define D_R	0	/* if data, read only */
#define D_W	0x02	    /* if data, writable */
#define D_ED	    0x04	/* if data, expand down */

#define D_ACCESSED  1	    /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE	(D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK	0xFFF8	    /* selector index */
#define SEL_LOW_MASK	0xF8	    /* mask for low byte of sel indx */
#define TABLE_MASK  0x04	/* table bit */
#define RPL_MASK    0x03	/* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()	{__asm cli}

#define SAVE_FLAGS(flags) {\
    {__asm pushfd}; \
    {__asm pop flags}}

#define RESTORE_FLAGS(flags) {\
    {__asm push flags}; \
    {__asm popfd}}

#define IO_Delay() {\
    {__asm _emit 0xeb __asm _emit 0x00}; \
    }

#define Touch_Register(Register) {_asm xor Register, Register}

typedef DWORD	HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)	// turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;	// count of milliseconds

#pragma warning (default:4209)	// turn on redefine warning (with basedef.h)

typedef DWORD	VMM_SEMAPHORE;

typedef struct _HEAP_ALLOCATE_INFO {
    DWORD   StructSize;
    PVOID   CallerAddress;
    ULONG   Tag;
} HEAP_ALLOCATE_INFO, *PHEAP_ALLOCATE_INFO;

PVOID
_stdcall
HeapAllocateEx(
    ULONG cBytes,
    PVOID Reserved,
    PHEAP_ALLOCATE_INFO AllocateInfo,
    ULONG Flags
    );

VOID
_stdcall
HeapFreeEx(
    PVOID MemBlk,
    PVOID Reserved
    );

#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\vmm.inc ===
ifndef _VMM_
_VMM_	EQU	1
FALSE	EQU	0
VMM_TRUE	EQU	(NOT FALSE)
DEBLEVELRETAIL	EQU	0
DEBLEVELNORMAL	EQU	1
DEBLEVELMAX	EQU	2
ifndef DEBLEVEL
ifdef DEBUG
DEBLEVEL	EQU	DEBLEVELNORMAL
else
DEBLEVEL	EQU	DEBLEVELRETAIL
endif
endif
ifndef WIN31COMPAT
WIN40SERVICES	EQU	1
WIN403SERVICES	EQU	1
endif
ifndef WIN40COMPAT
WIN41SERVICES	EQU	1
endif
ifdef MASM6
ifndef NO_MASM6_OPTIONS



    option oldmacros
ifndef	NEWSTRUCTS
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif




IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF

UNDEFINED_DEVICE_ID	EQU	00000H
VMM_DEVICE_ID	EQU	00001H
DEBUG_DEVICE_ID	EQU	00002H
VPICD_DEVICE_ID	EQU	00003H
VDMAD_DEVICE_ID	EQU	00004H
VTD_DEVICE_ID	EQU	00005H
V86MMGR_DEVICE_ID	EQU	00006H
PAGESWAP_DEVICE_ID	EQU	00007H
PARITY_DEVICE_ID	EQU	00008H
REBOOT_DEVICE_ID	EQU	00009H
VDD_DEVICE_ID	EQU	0000AH
VSD_DEVICE_ID	EQU	0000BH
VMD_DEVICE_ID	EQU	0000CH
VKD_DEVICE_ID	EQU	0000DH
VCD_DEVICE_ID	EQU	0000EH
VPD_DEVICE_ID	EQU	0000FH
BLOCKDEV_DEVICE_ID	EQU	00010H
VMCPD_DEVICE_ID	EQU	00011H
EBIOS_DEVICE_ID	EQU	00012H
BIOSXLAT_DEVICE_ID	EQU	00013H
VNETBIOS_DEVICE_ID	EQU	00014H
DOSMGR_DEVICE_ID	EQU	00015H
WINLOAD_DEVICE_ID	EQU	00016H
SHELL_DEVICE_ID	EQU	00017H
VMPOLL_DEVICE_ID	EQU	00018H
VPROD_DEVICE_ID	EQU	00019H
DOSNET_DEVICE_ID	EQU	0001AH
VFD_DEVICE_ID	EQU	0001BH
VDD2_DEVICE_ID	EQU	0001CH
WINDEBUG_DEVICE_ID	EQU	0001DH
TSRLOAD_DEVICE_ID	EQU	0001EH
BIOSHOOK_DEVICE_ID	EQU	0001FH
INT13_DEVICE_ID	EQU	00020H
PAGEFILE_DEVICE_ID	EQU	00021H
SCSI_DEVICE_ID	EQU	00022H
MCA_POS_DEVICE_ID	EQU	00023H
SCSIFD_DEVICE_ID	EQU	00024H
VPEND_DEVICE_ID	EQU	00025H
APM_DEVICE_ID	EQU	00026H
VPOWERD_DEVICE_ID	EQU	APM_DEVICE_ID
VXDLDR_DEVICE_ID	EQU	00027H
NDIS_DEVICE_ID	EQU	00028H
BIOS_EXT_DEVICE_ID	EQU	00029H
VWIN32_DEVICE_ID	EQU	0002AH
VCOMM_DEVICE_ID	EQU	0002BH
SPOOLER_DEVICE_ID	EQU	0002CH
WIN32S_DEVICE_ID	EQU	0002DH
DEBUGCMD_DEVICE_ID	EQU	0002EH
CONFIGMG_DEVICE_ID	EQU	00033H
DWCFGMG_DEVICE_ID	EQU	00034H
SCSIPORT_DEVICE_ID	EQU	00035H
VFBACKUP_DEVICE_ID	EQU	00036H
ENABLE_DEVICE_ID	EQU	00037H
VCOND_DEVICE_ID	EQU	00038H
ISAPNP_DEVICE_ID	EQU	0003CH
BIOS_DEVICE_ID	EQU	0003DH
IFSMgr_Device_ID	EQU	00040H
VCDFSD_DEVICE_ID	EQU	00041H
MRCI2_DEVICE_ID	EQU	00042H
PCI_DEVICE_ID	EQU	00043H
PELOADER_DEVICE_ID	EQU	00044H
EISA_DEVICE_ID	EQU	00045H
DRAGCLI_DEVICE_ID	EQU	00046H
DRAGSRV_DEVICE_ID	EQU	00047H
PERF_DEVICE_ID	EQU	00048H
AWREDIR_DEVICE_ID	EQU	00049H
DDS_DEVICE_ID	EQU	0004AH
NTKERN_DEVICE_ID	EQU	0004BH
VDOSKEYD_DEVICE_ID	EQU	0004BH
ACPI_DEVICE_ID	EQU	0004CH
UDF_DEVICE_ID	EQU	0004DH
SMCLIB_DEVICE_ID	EQU	0004EH
ETEN_Device_ID	EQU	00060H
CHBIOS_Device_ID	EQU	00061H
VMSGD_Device_ID	EQU	00062H
VPPID_Device_ID	EQU	00063H
VIME_Device_ID	EQU	00064H
VHBIOSD_Device_ID	EQU	00065H
BASEID_FOR_NAMEBASEDVXD	EQU	0f000H
BASEID_FOR_NAMEBASEDVXD_MASK	EQU	0fffH
VMM_INIT_ORDER	EQU	000000000H
DEBUG_INIT_ORDER	EQU	000000000H
DEBUGCMD_INIT_ORDER	EQU	000000000H
PERF_INIT_ORDER	EQU	000900000H
APM_INIT_ORDER	EQU	001000000H
VPOWERD_INIT_ORDER	EQU	APM_INIT_ORDER
BIOSHOOK_INIT_ORDER	EQU	006000000H
VPROD_INIT_ORDER	EQU	008000000H
VPICD_INIT_ORDER	EQU	00C000000H
VTD_INIT_ORDER	EQU	014000000H
VWIN32_INIT_ORDER	EQU	014100000H
VXDLDR_INIT_ORDER	EQU	016000000H
NTKERN_INIT_ORDER	EQU	016200000H
CONFIGMG_INIT_ORDER	EQU	016400000H
ENUMERATOR_INIT_ORDER	EQU	016800000H
ISAPNP_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
EISA_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
PCI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
BIOS_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+1
ACPI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+2
VCDFSD_INIT_ORDER	EQU	016F00000H
IOS_INIT_ORDER	EQU	017000000H
PAGEFILE_INIT_ORDER	EQU	018000000H
PAGESWAP_INIT_ORDER	EQU	01C000000H
PARITY_INIT_ORDER	EQU	020000000H
REBOOT_INIT_ORDER	EQU	024000000H
EBIOS_INIT_ORDER	EQU	026000000H
VDD_INIT_ORDER	EQU	028000000H
VSD_INIT_ORDER	EQU	02C000000H
VCD_INIT_ORDER	EQU	030000000H
COMMDRVR_INIT_ORDER	EQU	(VCD_INIT_ORDER-1)
PRTCL_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-2)
MODEM_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-3)
PORT_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-4)
VMD_INIT_ORDER	EQU	034000000H
VKD_INIT_ORDER	EQU	038000000H
VPD_INIT_ORDER	EQU	03C000000H
BLOCKDEV_INIT_ORDER	EQU	040000000H
MCA_POS_INIT_ORDER	EQU	041000000H
SCSIFD_INIT_ORDER	EQU	041400000H
SCSIMASTER_INIT_ORDER	EQU	041800000H
INT13_INIT_ORDER	EQU	042000000H
VMCPD_INIT_ORDER	EQU	048000000H
BIOSXLAT_INIT_ORDER	EQU	050000000H
VNETBIOS_INIT_ORDER	EQU	054000000H
DOSMGR_INIT_ORDER	EQU	058000000H
DOSNET_INIT_ORDER	EQU	05C000000H
WINLOAD_INIT_ORDER	EQU	060000000H
VMPOLL_INIT_ORDER	EQU	064000000H
UNDEFINED_INIT_ORDER	EQU	080000000H
VCOND_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
WINDEBUG_INIT_ORDER	EQU	081000000H
VDMAD_INIT_ORDER	EQU	090000000H
V86MMGR_INIT_ORDER	EQU	0A0000000H
IFSMgr_Init_Order	EQU	10000H+V86MMGR_Init_Order
FSD_Init_Order	EQU	00100H+IFSMgr_Init_Order
VFD_INIT_ORDER	EQU	50000H+IFSMgr_Init_Order
UNDEF_TOUCH_MEM_INIT_ORDER	EQU	0A8000000H
SHELL_INIT_ORDER	EQU	0B0000000H






IO_Delay    macro
jmp $+2
ENDM

VXD_FAILURE	EQU	0
VXD_SUCCESS	EQU	1

Pushad_Struc	STRUC
Pushad_EDI	DD	?
Pushad_ESI	DD	?
Pushad_EBP	DD	?
Pushad_ESP	DD	?
Pushad_EBX	DD	?
Pushad_EDX	DD	?
Pushad_ECX	DD	?
Pushad_EAX	DD	?
Pushad_Struc	ENDS
ifndef Not_VxD
??_CUR_CODE_SEG = 0

??_LCODE    =	1
??_ICODE    =	2
??_PCODE    =	3
??_SCODE    =	4
??_DBOCODE  =	5
??_16ICODE  =	6
??_RCODE    =	7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE	equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS





IFDEF	MASM6
_FLAT	EQU FLAT
ELSE
_FLAT	EQU USE32
ENDIF


_LTEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT	    ENDS

_TEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT	    ENDS


_PTEXT	    SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT	    ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>

IFNB	<classname>
    segname	SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname	SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
	ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB	<grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM

    ENDM

MakeCodeSeg <L0CKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM











DefLockableCodeBegin MACRO name, private
VxD_L0CKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_L0CKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM









DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_LOCKABLE_END_CODE_ENDS
    ENDM





CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
	extrn	name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM






MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM






MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or	??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM



_ITEXT	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT	    ENDS


_LDATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA	    ENDS

_DATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA	    ENDS


_PDATA	    SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA	    ENDS


_IDATA	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA	    ENDS


_BSS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS	    ENDS

CONST	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST	    ENDS

_TLS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS	    ENDS


_STEXT	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT	    ENDS


_SDATA	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA	    ENDS


_DB0START   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB0START   ENDS


_DB1CODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB1CODE    ENDS


_DB2DATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB2DATA    ENDS

if DEBLEVEL

_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS


_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS


_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif


_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS


_RCODE	    SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE	    ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DB0START, _DB1CODE, _DB2DATA
IF DEBLEVEL
_PGROUP   GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc





































EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF	Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID	= 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName	Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName	MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table


Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition, StdCallBytes, fastcall
LOCAL $$&Procedure, extrnproc, tableproc

  extrnproc MACRO
    IFNB <fastcall>
      IFB <StdCallBytes>
	.err
      ENDIF
      EXTRN @&&Procedure&&@&&StdCallBytes:NEAR
    ELSE
      IFNB <StdCallBytes>
	EXTRN _&&Procedure&&@&&StdCallBytes:NEAR
      ELSE
	EXTRN Procedure:NEAR
      ENDIF
    ENDIF
    ENDM

  tableproc MACRO
    IFNB <fastcall>
      dd  OFFSET32 @&&Procedure&&@&&StdCallBytes
    ELSE
      IFNB <StdCallBytes>
	dd  OFFSET32 _&&Procedure&&@&&StdCallBytes
      ELSE
	dd  OFFSET32 Procedure
      ENDIF
    ENDIF
    ENDM

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	extrnproc
      ELSE
	tableproc
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     IFNB <fastcall>
    PUBLIC __&&Procedure
     __&&Procedure LABEL DWORD
     ENDIF
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
    $$&&Procedure extern
       ELSE
	extrnproc
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
	tableproc
      ENDIF

	  IFDEF Device_Name&_Name_Based
	@@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
	  ELSE
	@@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	  ENDIF
  ELSE
    dd	0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    Purge extrnproc
    Purge tableproc
    ENDM

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4
    ??_standardccall&&_Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4, TRUE
    ??_fastcall&&_Procedure = Args
    ENDM

ELSE



IFDEF	Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM

ENDIF

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_standardccall_&&Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_fastcall_&&Procedure = Args
    ENDM

ENDIF

    ENDM




End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal	macro	reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress	macro	reg,service
    mov reg,OFFSET32 service
    endm


















Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd	csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
	.erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
	dd  OFFSET32 Name,cparm&&Name
    endif
	@32&&Name equ	((VxDName&_Device_ID SHL 16) + ??w32svcno)
	??w32svcno = ??w32svcno + 1
	ENDM
    ENDM










End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM











Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM












Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM







Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
	ENDM


BeginDoc

















EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h


cb_s	STRUC
CB_VM_Status	DD	?
CB_High_Linear	DD	?
CB_Client_Pointer	DD	?
CB_VMID	DD	?
CB_Signature	DD	?
cb_s	ENDS
VMCB_ID	EQU	62634D56H
VMSTAT_EXCLUSIVE_BIT	EQU	00H
VMSTAT_EXCLUSIVE	EQU	(1 SHL VMSTAT_EXCLUSIVE_BIT)
VMSTAT_BACKGROUND_BIT	EQU	01H
VMSTAT_BACKGROUND	EQU	(1 SHL VMSTAT_BACKGROUND_BIT)
VMSTAT_CREATING_BIT	EQU	02H
VMSTAT_CREATING	EQU	(1 SHL VMSTAT_CREATING_BIT)
VMSTAT_SUSPENDED_BIT	EQU	03H
VMSTAT_SUSPENDED	EQU	(1 SHL VMSTAT_SUSPENDED_BIT)
VMSTAT_NOT_EXECUTEABLE_BIT	EQU	04H
VMSTAT_NOT_EXECUTEABLE	EQU	(1 SHL VMSTAT_NOT_EXECUTEABLE_BIT)
VMSTAT_PM_EXEC_BIT	EQU	05H
VMSTAT_PM_EXEC	EQU	(1 SHL VMSTAT_PM_EXEC_BIT)
VMSTAT_PM_APP_BIT	EQU	06H
VMSTAT_PM_APP	EQU	(1 SHL VMSTAT_PM_APP_BIT)
VMSTAT_PM_USE32_BIT	EQU	07H
VMSTAT_PM_USE32	EQU	(1 SHL VMSTAT_PM_USE32_BIT)
VMSTAT_VXD_EXEC_BIT	EQU	08H
VMSTAT_VXD_EXEC	EQU	(1 SHL VMSTAT_VXD_EXEC_BIT)
VMSTAT_HIGH_PRI_BACK_BIT	EQU	09H
VMSTAT_HIGH_PRI_BACK	EQU	(1 SHL VMSTAT_HIGH_PRI_BACK_BIT)
VMSTAT_BLOCKED_BIT	EQU	0AH
VMSTAT_BLOCKED	EQU	(1 SHL VMSTAT_BLOCKED_BIT)
VMSTAT_AWAKENING_BIT	EQU	0BH
VMSTAT_AWAKENING	EQU	(1 SHL VMSTAT_AWAKENING_BIT)
VMSTAT_PAGEABLEV86BIT	EQU	0CH
VMSTAT_PAGEABLEV86_BIT	EQU	VMSTAT_PAGEABLEV86BIT
VMSTAT_PAGEABLEV86	EQU	(1 SHL VMSTAT_PAGEABLEV86BIT)
VMSTAT_V86INTSLOCKEDBIT	EQU	0DH
VMSTAT_V86INTSLOCKED_BIT	EQU	VMSTAT_V86INTSLOCKEDBIT
VMSTAT_V86INTSLOCKED	EQU	(1 SHL VMSTAT_V86INTSLOCKEDBIT)
VMSTAT_IDLE_TIMEOUT_BIT	EQU	0EH
VMSTAT_IDLE_TIMEOUT	EQU	(1 SHL VMSTAT_IDLE_TIMEOUT_BIT)
VMSTAT_IDLE_BIT	EQU	0FH
VMSTAT_IDLE	EQU	(1 SHL VMSTAT_IDLE_BIT)
VMSTAT_CLOSING_BIT	EQU	10H
VMSTAT_CLOSING	EQU	(1 SHL VMSTAT_CLOSING_BIT)
VMSTAT_TS_SUSPENDED_BIT	EQU	11H
VMSTAT_TS_SUSPENDED	EQU	(1 SHL VMSTAT_TS_SUSPENDED_BIT)
VMSTAT_TS_MAXPRI_BIT	EQU	12H
VMSTAT_TS_MAXPRI	EQU	(1 SHL VMSTAT_TS_MAXPRI_BIT)
VMSTAT_USE32_MASK	EQU	(VMSTAT_PM_USE32 OR VMSTAT_VXD_EXEC)

tcb_s	STRUC
TCB_Flags	DD	?
TCB_Reserved1	DD	?
TCB_Reserved2	DD	?
TCB_Signature	DD	?
TCB_ClientPtr	DD	?
TCB_VMHandle	DD	?
TCB_ThreadId	DW	?
TCB_PMLockOrigSS	DW	?
TCB_PMLockOrigESP	DD	?
TCB_PMLockOrigEIP	DD	?
TCB_PMLockStackCount	DD	?
TCB_PMLockOrigCS	DW	?
TCB_PMPSPSelector	DW	?
TCB_ThreadType	DD	?
TCB_pad1	DW	?
TCB_pad2	DB	?
TCB_extErrLocus	DB	?
TCB_extErr	DW	?
TCB_extErrAction	DB	?
TCB_extErrClass	DB	?
TCB_extErrPtr	DD	?
tcb_s	ENDS
SCHED_OBJ_ID_THREAD	EQU	42434854H
THFLAG_SUSPENDED_BIT	EQU	03H
THFLAG_SUSPENDED	EQU	(1 SHL THFLAG_SUSPENDED_BIT)
THFLAG_NOT_EXECUTEABLE_BIT	EQU	04H
THFLAG_NOT_EXECUTEABLE	EQU	(1 SHL THFLAG_NOT_EXECUTEABLE_BIT)
THFLAG_THREAD_CREATION_BIT	EQU	08H
THFLAG_THREAD_CREATION	EQU	(1 SHL THFLAG_THREAD_CREATION_BIT)
THFLAG_THREAD_BLOCKED_BIT	EQU	0AH
THFLAG_THREAD_BLOCKED	EQU	(1 SHL THFLAG_THREAD_BLOCKED_BIT)
THFLAG_RING0_THREAD_BIT	EQU	1CH
THFLAG_RING0_THREAD	EQU	(1 SHL THFLAG_RING0_THREAD_BIT)
THFLAG_ASYNC_THREAD_BIT	EQU	1FH
THFLAG_ASYNC_THREAD	EQU	(1 SHL THFLAG_ASYNC_THREAD_BIT)
THFLAG_CHARSET_BITS	EQU	10H
THFLAG_CHARSET_MASK	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_ANSI	EQU	(0 SHL THFLAG_CHARSET_BITS)
THFLAG_OEM	EQU	(1 SHL THFLAG_CHARSET_BITS)
THFLAG_UNICODE	EQU	(2 SHL THFLAG_CHARSET_BITS)
THFLAG_RESERVED	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_EXTENDED_HANDLES_BIT	EQU	12H
THFLAG_EXTENDED_HANDLES	EQU	(1 SHL THFLAG_EXTENDED_HANDLES_BIT)
THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT	EQU	13H
THFLAG_OPEN_AS_IMMOVABLE_FILE	EQU	(1 SHL THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

pmcb_s	STRUC
PMCB_Flags	DD	?
PMCB_Parent	DD	?
pmcb_s	ENDS

VMFaultInfo	STRUC
VMFI_EIP	DD	?
VMFI_CS	DW	?
VMFI_Ints	DW	?
VMFaultInfo	ENDS
Begin_Service_Table VMM, VMM
VMM_Service  Get_VMM_Version, LOCAL
VMM_Service  Get_Cur_VM_Handle
VMM_Service  Test_Cur_VM_Handle
VMM_Service  Get_Sys_VM_Handle
VMM_Service  Test_Sys_VM_Handle
VMM_Service  Validate_VM_Handle
VMM_Service  Get_VMM_Reenter_Count
VMM_Service  Begin_Reentrant_Execution
VMM_Service  End_Reentrant_Execution
VMM_Service  Install_V86_Break_Point
VMM_Service  Remove_V86_Break_Point
VMM_Service  Allocate_V86_Call_Back
VMM_Service  Allocate_PM_Call_Back
VMM_Service  Call_When_VM_Returns
VMM_Service  Schedule_Global_Event
VMM_Service  Schedule_VM_Event
VMM_Service  Call_Global_Event
VMM_Service  Call_VM_Event
VMM_Service  Cancel_Global_Event
VMM_Service  Cancel_VM_Event
VMM_Service  Call_Priority_VM_Event
VMM_Service  Cancel_Priority_VM_Event
VMM_Service  Get_NMI_Handler_Addr
VMM_Service  Set_NMI_Handler_Addr
VMM_Service  Hook_NMI_Event
VMM_Service  Call_When_VM_Ints_Enabled
VMM_Service  Enable_VM_Ints
VMM_Service  Disable_VM_Ints
VMM_Service  Map_Flat
VMM_Service  Map_Lin_To_VM_Addr
VMM_Service  Adjust_Exec_Priority
VMM_Service  Begin_Critical_Section
VMM_Service  End_Critical_Section
VMM_Service  End_Crit_And_Suspend
VMM_Service  Claim_Critical_Section
VMM_Service  Release_Critical_Section
VMM_Service  Call_When_Not_Critical
VMM_Service  Create_Semaphore
VMM_Service  Destroy_Semaphore
VMM_Service  Wait_Semaphore
VMM_Service  Signal_Semaphore
VMM_Service  Get_Crit_Section_Status
VMM_Service  Call_When_Task_Switched
VMM_Service  Suspend_VM
VMM_Service  Resume_VM
VMM_Service  No_Fail_Resume_VM
VMM_Service  Nuke_VM
VMM_Service  Crash_Cur_VM
VMM_Service  Get_Execution_Focus
VMM_Service  Set_Execution_Focus
VMM_Service  Get_Time_Slice_Priority
VMM_Service  Set_Time_Slice_Priority
VMM_Service  Get_Time_Slice_Granularity
VMM_Service  Set_Time_Slice_Granularity
VMM_Service  Get_Time_Slice_Info
VMM_Service  Adjust_Execution_Time
VMM_Service  Release_Time_Slice
VMM_Service  Wake_Up_VM
VMM_Service  Call_When_Idle
VMM_Service  Get_Next_VM_Handle
VMM_Service  Set_Global_Time_Out
VMM_Service  Set_VM_Time_Out
VMM_Service  Cancel_Time_Out
VMM_Service  Get_System_Time
VMM_Service  Get_VM_Exec_Time
VMM_Service  Hook_V86_Int_Chain
VMM_Service  Get_V86_Int_Vector
VMM_Service  Set_V86_Int_Vector
VMM_Service  Get_PM_Int_Vector
VMM_Service  Set_PM_Int_Vector
VMM_Service  Simulate_Int
VMM_Service  Simulate_Iret
VMM_Service  Simulate_Far_Call
VMM_Service  Simulate_Far_Jmp
VMM_Service  Simulate_Far_Ret
VMM_Service  Simulate_Far_Ret_N
VMM_Service  Build_Int_Stack_Frame
VMM_Service  Simulate_Push
VMM_Service  Simulate_Pop
VMM_Service  _HeapAllocate
VMM_Service  _HeapReAllocate
VMM_Service  _HeapFree
VMM_Service  _HeapGetSize
HEAPZEROINIT	EQU	00000001H
HEAPZEROREINIT	EQU	00000002H
HEAPNOCOPY	EQU	00000004H
HEAPALIGN_SHIFT	EQU	16
HEAPALIGN_MASK	EQU	000F0000H
HEAPALIGN_4	EQU	00000000H
HEAPALIGN_8	EQU	00000000H
HEAPALIGN_16	EQU	00000000H
HEAPALIGN_32	EQU	00010000H
HEAPALIGN_64	EQU	00020000H
HEAPALIGN_128	EQU	00030000H
HEAPALIGN_256	EQU	00040000H
HEAPALIGN_512	EQU	00050000H
HEAPALIGN_1K	EQU	00060000H
HEAPALIGN_2K	EQU	00070000H
HEAPALIGN_4K	EQU	00080000H
HEAPALIGN_8K	EQU	00090000H
HEAPALIGN_16K	EQU	000A0000H
HEAPALIGN_32K	EQU	000B0000H
HEAPALIGN_64K	EQU	000C0000H
HEAPALIGN_128K	EQU	000D0000H
HEAPTYPESHIFT	EQU	8
HEAPTYPEMASK	EQU	00000700H
HEAPLOCKEDHIGH	EQU	00000000H
HEAPLOCKEDIFDP	EQU	00000100H
HEAPSWAP	EQU	00000200H
HEAPINIT	EQU	00000400H
HEAPCLEAN	EQU	00000800H
HEAPCONTIG	EQU	00001000H
HEAPFORGET	EQU	00002000H
HEAPLOCKEDLOW	EQU	00000300H
HEAPSYSVM	EQU	00000500H
HEAPPREEMPT	EQU	00000600H
VMM_Service  _PageAllocate
VMM_Service  _PageReAllocate
VMM_Service  _PageFree
VMM_Service  _PageLock
VMM_Service  _PageUnLock
VMM_Service  _PageGetSizeAddr
VMM_Service  _PageGetAllocInfo
VMM_Service  _GetFreePageCount
VMM_Service  _GetSysPageCount
VMM_Service  _GetVMPgCount
VMM_Service  _MapIntoV86
VMM_Service  _PhysIntoV86
VMM_Service  _TestGlobalV86Mem
VMM_Service  _ModifyPageBits
VMM_Service  _CopyPageTable
VMM_Service  _LinMapIntoV86
VMM_Service  _LinPageLock
VMM_Service  _LinPageUnLock
VMM_Service  _SetResetV86Pageable
VMM_Service  _GetV86PageableArray
VMM_Service  _PageCheckLinRange
VMM_Service  _PageOutDirtyPages
VMM_Service  _PageDiscardPages
PAGEZEROINIT	EQU	00000001H
PAGEUSEALIGN	EQU	00000002H
PAGECONTIG	EQU	00000004H
PAGEFIXED	EQU	00000008H
PAGEDEBUGNULFAULT	EQU	00000010H
PAGEZEROREINIT	EQU	00000020H
PAGENOCOPY	EQU	00000040H
PAGELOCKED	EQU	00000080H
PAGELOCKEDIFDP	EQU	00000100H
PAGESETV86PAGEABLE	EQU	00000200H
PAGECLEARV86PAGEABLE	EQU	00000400H
PAGESETV86INTSLOCKED	EQU	00000800H
PAGECLEARV86INTSLOCKED	EQU	00001000H
PAGEMARKPAGEOUT	EQU	00002000H
PAGEPDPSETBASE	EQU	00004000H
PAGEPDPCLEARBASE	EQU	00008000H
PAGEDISCARD	EQU	00010000H
PAGEPDPQUERYDIRTY	EQU	00020000H
PAGEMAPFREEPHYSREG	EQU	00040000H
PAGEPHYSONLY	EQU	04000000H
PAGENOMOVE	EQU	10000000H
PAGEMAPGLOBAL	EQU	40000000H
PAGEMARKDIRTY	EQU	80000000H
MAPV86_IGNOREWRAP	EQU	00000001H
MPL_NonCached	EQU	00000000H
MPL_HardwareCoherentCached	EQU	00000001H
MPL_FrameBufferCached	EQU	00000002H
MPL_Cached	EQU	00000004H
VMM_Service  _GetNulPageHandle
VMM_Service  _GetFirstV86Page
VMM_Service  _MapPhysToLinear
VMM_Service  _GetAppFlatDSAlias
VMM_Service  _SelectorMapFlat
VMM_Service  _GetDemandPageInfo
VMM_Service  _GetSetPageOutCount
GSPOC_F_GET	EQU	00000001H
VMM_Service  Hook_V86_Page
VMM_Service  _Assign_Device_V86_Pages
VMM_Service  _DeAssign_Device_V86_Pages
VMM_Service  _Get_Device_V86_Pages_Array
VMM_Service  MMGR_SetNULPageAddr
VMM_Service  _Allocate_GDT_Selector
VMM_Service  _Free_GDT_Selector
VMM_Service  _Allocate_LDT_Selector
VMM_Service  _Free_LDT_Selector
VMM_Service  _BuildDescriptorDWORDs
VMM_Service  _GetDescriptor
VMM_Service  _SetDescriptor
ALLOCFROMEND	EQU	40000000H
BDDEXPLICITDPL	EQU	00000001H
ALDTSPECSEL	EQU	00000001H
VMM_Service  _MMGR_Toggle_HMA
MMGRHMAPHYSICAL	EQU	00000001H
MMGRHMAENABLE	EQU	00000002H
MMGRHMADISABLE	EQU	00000004H
MMGRHMAQUERY	EQU	00000008H
VMM_Service  Get_Fault_Hook_Addrs
VMM_Service  Hook_V86_Fault
VMM_Service  Hook_PM_Fault
VMM_Service  Hook_VMM_Fault
VMM_Service  Begin_Nest_V86_Exec
VMM_Service  Begin_Nest_Exec
VMM_Service  Exec_Int
VMM_Service  Resume_Exec
VMM_Service  End_Nest_Exec
VMM_Service  Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service  Get_Cur_PM_App_CB
VMM_Service  Set_V86_Exec_Mode
VMM_Service  Set_PM_Exec_Mode
VMM_Service  Begin_Use_Locked_PM_Stack
VMM_Service  End_Use_Locked_PM_Stack
VMM_Service  Save_Client_State
VMM_Service  Restore_Client_State
VMM_Service  Exec_VxD_Int
VMM_Service  Hook_Device_Service
VMM_Service  Hook_Device_V86_API
VMM_Service  Hook_Device_PM_API
VMM_Service  System_Control
VMM_Service  Simulate_IO
VMM_Service  Install_Mult_IO_Handlers
VMM_Service  Install_IO_Handler
VMM_Service  Enable_Global_Trapping
VMM_Service  Enable_Local_Trapping
VMM_Service  Disable_Global_Trapping
VMM_Service  Disable_Local_Trapping
VMM_Service  List_Create
VMM_Service  List_Destroy
VMM_Service  List_Allocate
VMM_Service  List_Attach
VMM_Service  List_Attach_Tail
VMM_Service  List_Insert
VMM_Service  List_Remove
VMM_Service  List_Deallocate
VMM_Service  List_Get_First
VMM_Service  List_Get_Next
VMM_Service  List_Remove_First
LF_ASYNC_BIT	EQU	0
LF_ASYNC	EQU	(1 SHL LF_ASYNC_BIT)
LF_USE_HEAP_BIT	EQU	1
LF_USE_HEAP	EQU	(1 SHL LF_USE_HEAP_BIT)
LF_ALLOC_ERROR_BIT	EQU	2
LF_ALLOC_ERROR	EQU	(1 SHL LF_ALLOC_ERROR_BIT)
LF_SWAP	EQU	(LF_USE_HEAP+(1 SHL 3))
VMM_Service  _AddInstanceItem
VMM_Service  _Allocate_Device_CB_Area
VMM_Service  _Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service  _Allocate_Temp_V86_Data_Area
VMM_Service  _Free_Temp_V86_Data_Area
GVDAWordAlign	EQU	00000001H
GVDADWordAlign	EQU	00000002H
GVDAParaAlign	EQU	00000004H
GVDAPageAlign	EQU	00000008H
GVDAInstance	EQU	00000100H
GVDAZeroInit	EQU	00000200H
GVDAReclaim	EQU	00000400H
GVDAInquire	EQU	00000800H
GVDAHighSysCritOK	EQU	00001000H
GVDAOptInstance	EQU	00002000H
GVDAForceLow	EQU	00004000H
TVDANeedTilInitComplete	EQU	00000001H
VMM_Service  Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service  Convert_Decimal_String, VMM_ICODE
VMM_Service  Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service  Convert_Fixed_Point_String, VMM_ICODE
VMM_Service  Get_Profile_Hex_Int, VMM_ICODE
VMM_Service  Convert_Hex_String, VMM_ICODE
VMM_Service  Get_Profile_Boolean, VMM_ICODE
VMM_Service  Convert_Boolean_String, VMM_ICODE
VMM_Service  Get_Profile_String, VMM_ICODE
VMM_Service  Get_Next_Profile_String, VMM_ICODE
VMM_Service  Get_Environment_String, VMM_ICODE
VMM_Service  Get_Exec_Path, VMM_ICODE
VMM_Service  Get_Config_Directory, VMM_ICODE
VMM_Service  OpenFile, VMM_ICODE
VMM_OPENFILE_BUF_SIZE	EQU	260
VMM_Service  Get_PSP_Segment, VMM_ICODE
VMM_Service  GetDOSVectors, VMM_ICODE
VMM_Service  Get_Machine_Info
GMIF_80486_BIT	EQU	10H
GMIF_80486	EQU	(1 SHL GMIF_80486_BIT)
GMIF_PCXT_BIT	EQU	11H
GMIF_PCXT	EQU	(1 SHL GMIF_PCXT_BIT)
GMIF_MCA_BIT	EQU	12H
GMIF_MCA	EQU	(1 SHL GMIF_MCA_BIT)
GMIF_EISA_BIT	EQU	13H
GMIF_EISA	EQU	(1 SHL GMIF_EISA_BIT)
GMIF_CPUID_BIT	EQU	14H
GMIF_CPUID	EQU	(1 SHL GMIF_CPUID_BIT)
GMIF_80586_BIT	EQU	15H
GMIF_80586	EQU	(1 SHL GMIF_80586_BIT)
GMIF_4MEGPG_BIT	EQU	16H
GMIF_4MEGPG	EQU	(1 SHL GMIF_4MEGPG_BIT)
GMIF_RDTSC_BIT	EQU	17H
GMIF_RDTSC	EQU	(1 SHL GMIF_RDTSC_BIT)
VMM_Service  GetSet_HMA_Info
VMM_Service  Set_System_Exit_Code
VMM_Service  Fatal_Error_Handler
VMM_Service  Fatal_Memory_Error
VMM_Service  Update_System_Clock
VMM_Service  Test_Debug_Installed
VMM_Service  Out_Debug_String
VMM_Service  Out_Debug_Chr
VMM_Service  In_Debug_Chr
VMM_Service  Debug_Convert_Hex_Binary
VMM_Service  Debug_Convert_Hex_Decimal
VMM_Service  Debug_Test_Valid_Handle
VMM_Service  Validate_Client_Ptr
VMM_Service  Test_Reenter
VMM_Service  Queue_Debug_String
VMM_Service  Log_Proc_Call
VMM_Service  Debug_Test_Cur_VM
VMM_Service  Get_PM_Int_Type
VMM_Service  Set_PM_Int_Type
VMM_Service  Get_Last_Updated_System_Time
VMM_Service  Get_Last_Updated_VM_Exec_Time
VMM_Service  Test_DBCS_Lead_Byte
.errnz	@@Test_DBCS_Lead_Byte - 100D1h

VMM_Service  _AddFreePhysPage, VMM_ICODE
VMM_Service  _PageResetHandlePAddr
VMM_Service  _SetLastV86Page, VMM_ICODE
VMM_Service  _GetLastV86Page
VMM_Service  _MapFreePhysReg
VMM_Service  _UnmapFreePhysReg
VMM_Service  _XchgFreePhysReg
VMM_Service  _SetFreePhysRegCalBk, VMM_ICODE
VMM_Service  Get_Next_Arena, VMM_ICODE
VMM_Service  Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service  Get_Debug_Options, VMM_ICODE
AFPP_SWAPOUT	EQU	0001H
PCP_CHANGEPAGER	EQU	1H
PCP_CHANGEPAGERDATA	EQU	2H
PCP_VIRGINONLY	EQU	4H
GNA_HIDOSLINKED	EQU	0002H
GNA_ISHIGHDOS	EQU	0004H
VMM_Service  Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service  _GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service  _Add_Global_V86_Data_Area, VMM_ICODE
VMM_Service  GetSetDetailedVMError
GSDVME_PRIVINST	EQU	00010001H
GSDVME_INVALINST	EQU	00010002H
GSDVME_INVALPGFLT	EQU	00010003H
GSDVME_INVALGPFLT	EQU	00010004H
GSDVME_INVALFLT	EQU	00010005H
GSDVME_USERNUKE	EQU	00010006H
GSDVME_DEVNUKE	EQU	00010007H
GSDVME_DEVNUKEHDWR	EQU	00010008H
GSDVME_NUKENOMSG	EQU	00010009H
GSDVME_OKNUKEMASK	EQU	80000000H
GSDVME_INSMEMV86	EQU	00020001H
GSDVME_INSV86SPACE	EQU	00020002H
GSDVME_INSMEMXMS	EQU	00020003H
GSDVME_INSMEMEMS	EQU	00020004H
GSDVME_INSMEMV86HI	EQU	00020005H
GSDVME_INSMEMVID	EQU	00020006H
GSDVME_INSMEMVM	EQU	00020007H
GSDVME_INSMEMDEV	EQU	00020008H
GSDVME_CRTNOMSG	EQU	00020009H
VMM_Service  Is_Debug_Chr
VMM_Service  Clear_Mono_Screen
VMM_Service  Out_Mono_Chr
VMM_Service  Out_Mono_String
VMM_Service  Set_Mono_Cur_Pos
VMM_Service  Get_Mono_Cur_Pos
VMM_Service  Get_Mono_Chr
VMM_Service  Locate_Byte_In_ROM, VMM_ICODE
VMM_Service  Hook_Invalid_Page_Fault
VMM_Service  Unhook_Invalid_Page_Fault
IPF_PGDIR	EQU	00000001H
IPF_V86PG	EQU	00000002H
IPF_V86PGH	EQU	00000004H
IPF_INVTYP	EQU	00000008H
IPF_PGERR	EQU	00000010H
IPF_REFLT	EQU	00000020H
IPF_VMM	EQU	00000040H
IPF_PM	EQU	00000080H
IPF_V86	EQU	00000100H
VMM_Service  Set_Delete_On_Exit_File
VMM_Service  Close_VM
CVF_CONTINUE_EXEC_BIT	EQU	0
CVF_CONTINUE_EXEC	EQU	(1 SHL CVF_CONTINUE_EXEC_BIT)
VMM_Service  Enable_Touch_1st_Meg
VMM_Service  Disable_Touch_1st_Meg
VMM_Service  Install_Exception_Handler
VMM_Service  Remove_Exception_Handler
VMM_Service  Get_Crit_Status_No_Block

.errnz	 @@Get_Crit_Status_No_Block - 100F1h

ifdef WIN40SERVICES
VMM_Service  _GetLastUpdatedThreadExecTime
VMM_Service  _Trace_Out_Service
VMM_Service  _Debug_Out_Service
VMM_Service  _Debug_Flags_Service
endif
DFS_LOG_BIT	EQU	0
DFS_LOG	EQU	(1 SHL DFS_LOG_BIT)
DFS_PROFILE_BIT	EQU	1
DFS_PROFILE	EQU	(1 SHL DFS_PROFILE_BIT)
DFS_TEST_CLD_BIT	EQU	2
DFS_TEST_CLD	EQU	(1 SHL DFS_TEST_CLD_BIT)
DFS_NEVER_REENTER_BIT	EQU	3
DFS_NEVER_REENTER	EQU	(1 SHL DFS_NEVER_REENTER_BIT)
DFS_TEST_REENTER_BIT	EQU	4
DFS_TEST_REENTER	EQU	(1 SHL DFS_TEST_REENTER_BIT)
DFS_NOT_SWAPPING_BIT	EQU	5
DFS_NOT_SWAPPING	EQU	(1 SHL DFS_NOT_SWAPPING_BIT)
DFS_TEST_BLOCK_BIT	EQU	6
DFS_TEST_BLOCK	EQU	(1 SHL DFS_TEST_BLOCK_BIT)
DFS_RARE_SERVICES	EQU	0FFFFFF80H
DFS_EXIT_NOBLOCK	EQU	(DFS_RARE_SERVICES+0)
DFS_ENTER_NOBLOCK	EQU	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)
DFS_TEST_NEST_EXEC	EQU	(DFS_RARE_SERVICES+1)
DFS_WIMP_DEBUG	EQU	(DFS_RARE_SERVICES+2)
ifdef WIN40SERVICES
VMM_Service  VMMAddImportModuleName
VMM_Service  VMM_Add_DDB
VMM_Service  VMM_Remove_DDB
VMM_Service  Test_VM_Ints_Enabled
VMM_Service  _BlockOnID
VMM_Service  Schedule_Thread_Event
VMM_Service  Cancel_Thread_Event
VMM_Service  Set_Thread_Time_Out
VMM_Service  Set_Async_Time_Out
VMM_Service  _AllocateThreadDataSlot
VMM_Service  _FreeThreadDataSlot
MUTEX_MUST_COMPLETE	EQU	1
MUTEX_NO_CLEANUP_THREAD_STATE	EQU	2
VMM_Service  _CreateMutex
VMM_Service  _DestroyMutex
VMM_Service  _GetMutexOwner
VMM_Service  Call_When_Thread_Switched
VMM_Service  VMMCreateThread
VMM_Service  _GetThreadExecTime
VMM_Service  VMMTerminateThread
VMM_Service  Get_Cur_Thread_Handle
VMM_Service  Test_Cur_Thread_Handle
VMM_Service  Get_Sys_Thread_Handle
VMM_Service  Test_Sys_Thread_Handle
VMM_Service  Validate_Thread_Handle
VMM_Service  Get_Initial_Thread_Handle
VMM_Service  Test_Initial_Thread_Handle
VMM_Service  Debug_Test_Valid_Thread_Handle
VMM_Service  Debug_Test_Cur_Thread
VMM_Service  VMM_GetSystemInitState
VMM_Service  Cancel_Call_When_Thread_Switched
VMM_Service  Get_Next_Thread_Handle
VMM_Service  Adjust_Thread_Exec_Priority
VMM_Service  _Deallocate_Device_CB_Area
VMM_Service  Remove_IO_Handler
VMM_Service  Remove_Mult_IO_Handlers
VMM_Service  Unhook_V86_Int_Chain
VMM_Service  Unhook_V86_Fault
VMM_Service  Unhook_PM_Fault
VMM_Service  Unhook_VMM_Fault
VMM_Service  Unhook_Device_Service
VMM_Service  _PageReserve
VMM_Service  _PageCommit
VMM_Service  _PageDecommit
VMM_Service  _PagerRegister
VMM_Service  _PagerQuery
VMM_Service  _PagerDeregister
VMM_Service  _ContextCreate
VMM_Service  _ContextDestroy
VMM_Service  _PageAttach
VMM_Service  _PageFlush
VMM_Service  _SignalID
VMM_Service  _PageCommitPhys
VMM_Service  _Register_Win32_Services
VMM_Service  Cancel_Call_When_Not_Critical
VMM_Service  Cancel_Call_When_Idle
VMM_Service  Cancel_Call_When_Task_Switched
VMM_Service  _Debug_Printf_Service
VMM_Service  _EnterMutex
VMM_Service  _LeaveMutex
VMM_Service  Simulate_VM_IO
VMM_Service  Signal_Semaphore_No_Switch
VMM_Service  _ContextSwitch
VMM_Service  _PageModifyPermissions
VMM_Service  _PageQuery
VMM_Service  _EnterMustComplete
VMM_Service  _LeaveMustComplete
VMM_Service  _ResumeExecMustComplete
THREAD_TERM_STATUS_CRASH_PEND	EQU	1
THREAD_TERM_STATUS_NUKE_PEND	EQU	2
THREAD_TERM_STATUS_SUSPEND_PEND	EQU	4
VMM_Service  _GetThreadTerminationStatus
VMM_Service  _GetInstanceInfo
INSTINFO_NONE	EQU	0
INSTINFO_SOME	EQU	1
INSTINFO_ALL	EQU	2
VMM_Service  _ExecIntMustComplete
VMM_Service  _ExecVxDIntMustComplete
VMM_Service  Begin_V86_Serialization
VMM_Service  Unhook_V86_Page
VMM_Service  VMM_GetVxDLocationList
VMM_Service  VMM_GetDDBList
VMM_Service  Unhook_NMI_Event
VMM_Service  Get_Instanced_V86_Int_Vector
VMM_Service  Get_Set_Real_DOS_PSP
GSRDP_Set	EQU	0001H
VMM_Service  Call_Priority_Thread_Event
VMM_Service  Get_System_Time_Address
VMM_Service  Get_Crit_Status_Thread
VMM_Service  Get_DDB
VMM_Service  Directed_Sys_Control
VMM_Service  _RegOpenKey
VMM_Service  _RegCloseKey
VMM_Service  _RegCreateKey
VMM_Service  _RegDeleteKey
VMM_Service  _RegEnumKey
VMM_Service  _RegQueryValue
VMM_Service  _RegSetValue
VMM_Service  _RegDeleteValue
VMM_Service  _RegEnumValue
VMM_Service  _RegQueryValueEx
VMM_Service  _RegSetValueEx
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
VMM_Service  _CallRing3
VMM_Service  Exec_PM_Int
VMM_Service  _RegFlushKey
VMM_Service  _PageCommitContig
VMM_Service  _GetCurrentContext
VMM_Service  _LocalizeSprintf
VMM_Service  _LocalizeStackSprintf
VMM_Service  Call_Restricted_Event
VMM_Service  Cancel_Restricted_Event
VMM_Service  Register_PEF_Provider, VMM_ICODE
VMM_Service  _GetPhysPageInfo
VMM_Service  _RegQueryInfoKey
VMM_Service  MemArb_Reserve_Pages
PHYSINFO_NONE	EQU	0
PHYSINFO_SOME	EQU	1
PHYSINFO_ALL	EQU	2
VMM_Service  Time_Slice_Sys_VM_Idle
VMM_Service  Time_Slice_Sleep
VMM_Service  Boost_With_Decay
VMM_Service  Set_Inversion_Pri
VMM_Service  Reset_Inversion_Pri
VMM_Service  Release_Inversion_Pri
VMM_Service  Get_Thread_Win32_Pri
VMM_Service  Set_Thread_Win32_Pri
VMM_Service  Set_Thread_Static_Boost
VMM_Service  Set_VM_Static_Boost
VMM_Service  Release_Inversion_Pri_ID
VMM_Service  Attach_Thread_To_Group
VMM_Service  Detach_Thread_From_Group
VMM_Service  Set_Group_Static_Boost
VMM_Service  _GetRegistryPath, VMM_ICODE
VMM_Service  _GetRegistryKey
REGTYPE_ENUM	EQU	0
REGTYPE_CLASS	EQU	1
REGTYPE_VXD	EQU	2
REGKEY_OPEN	EQU	0
REGKEY_CREATE_IFNOTEXIST	EQU	1
ASSERT_RANGE_NULL_BAD	EQU	00000000H
ASSERT_RANGE_NULL_OK	EQU	00000001H
ASSERT_RANGE_IS_ASCIIZ	EQU	00000002H
ASSERT_RANGE_IS_NOT_ASCIIZ	EQU	00000000H
ASSERT_RANGE_NO_DEBUG	EQU	80000000H
ASSERT_RANGE_BITS	EQU	80000003H
VMM_Service  Cleanup_Thread_State
VMM_Service  _RegRemapPreDefKey
VMM_Service  End_V86_Serialization
VMM_Service  _Assert_Range
VMM_Service  _Sprintf
VMM_Service  _PageChangePager
VMM_Service  _RegCreateDynKey
VMM_Service  _RegQueryMultipleValues
VMM_Service  Boost_Thread_With_VM
BOOT_CLEAN	EQU	00000001H
BOOT_DOSCLEAN	EQU	00000002H
BOOT_NETCLEAN	EQU	00000004H
BOOT_INTERACTIVE	EQU	00000008H
VMM_Service  Get_Boot_Flags
VMM_Service  Set_Boot_Flags
VMM_Service  _lstrcpyn
VMM_Service  _lstrlen
VMM_Service  _lmemcpy
VMM_Service  _GetVxDName
VMM_Service  Force_Mutexes_Free
VMM_Service  Restore_Forced_Mutexes
VMM_Service  _AddReclaimableItem
VMM_Service  _SetReclaimableItem
VMM_Service  _EnumReclaimableItem
VMM_Service  Time_Slice_Wake_Sys_VM
VMM_Service  VMM_Replace_Global_Environment
VMM_Service  Begin_Non_Serial_Nest_V86_Exec
VMM_Service  Get_Nest_Exec_Status
VMM_Service  Open_Boot_Log
VMM_Service  Write_Boot_Log
VMM_Service  Close_Boot_Log
VMM_Service  EnableDisable_Boot_Log
VMM_Service  _Call_On_My_Stack
VMM_Service  Get_Inst_V86_Int_Vec_Base
VMM_Service  _lstrcmpi
VMM_Service  _strupr
VMM_Service  Log_Fault_Call_Out
VMM_Service  _AtEventTime
endif
ifdef WIN403SERVICES
VMM_Service  _PageOutPages
PAGEOUT_PRIVATE	EQU	00000001H
PAGEOUT_SHARED	EQU	00000002H
PAGEOUT_SYSTEM	EQU	00000004H
PAGEOUT_REGION	EQU	00000008H
PAGEOUT_ALL	EQU	(PAGEOUT_PRIVATE OR PAGEOUT_SHARED OR PAGEOUT_SYSTEM)
VMM_Service  _Call_On_My_Not_Flat_Stack
VMM_Service  _LinRegionLock
VMM_Service  _LinRegionUnLock
VMM_Service  _AttemptingSomethingDangerous
VMM_Service  _Vsprintf
VMM_Service  _Vsprintfw
VMM_Service  Load_FS_Service
VMM_Service  Assert_FS_Service
VMM_StdCall_Service  ObsoleteRtlUnwind, 4
VMM_StdCall_Service  ObsoleteRtlRaiseException, 1
VMM_StdCall_Service  ObsoleteRtlRaiseStatus, 1
VMM_StdCall_Service  ObsoleteKeGetCurrentIrql, 0
VMM_FastCall_Service  ObsoleteKfRaiseIrql, 1
VMM_FastCall_Service  ObsoleteKfLowerIrql, 1
VMM_Service  _Begin_Preemptable_Code
VMM_Service  _End_Preemptable_Code
VMM_FastCall_Service  Set_Preemptable_Count, 1
VMM_StdCall_Service  ObsoleteKeInitializeDpc, 3
VMM_StdCall_Service  ObsoleteKeInsertQueueDpc, 3
VMM_StdCall_Service  ObsoleteKeRemoveQueueDpc, 1
VMM_StdCall_Service  HeapAllocateEx, 4
VMM_StdCall_Service  HeapReAllocateEx, 5
VMM_StdCall_Service  HeapGetSizeEx, 2
VMM_StdCall_Service  HeapFreeEx, 2
VMM_Service  _Get_CPUID_Flags
VMM_StdCall_Service  KeCheckDivideByZeroTrap, 1
endif
ifdef	WIN41SERVICES
VMM_Service  _RegisterGARTHandler
VMM_Service  _GARTReserve
VMM_Service  _GARTCommit
VMM_Service  _GARTUnCommit
VMM_Service  _GARTFree
VMM_Service  _GARTMemAttributes
VMM_StdCall_Service  KfRaiseIrqlToDpcLevel, 0
VMM_Service  VMMCreateThreadEx
VMM_Service  _FlushCaches
PG_UNCACHED	EQU	00000001H
PG_WRITECOMBINED	EQU	00000002H
FLUSHCACHES_NORMAL	EQU	00000000H
FLUSHCACHES_GET_CACHE_LINE_PTR	EQU	00000001H
FLUSHCACHES_GET_CACHE_SIZE_PTR	EQU	00000002H
FLUSHCACHES_TAKE_OVER	EQU	00000003H
FLUSHCACHES_FORCE_PAGES_OUT	EQU	00000004H
FLUSHCACHES_LOCK_LOCKABLE	EQU	00000005H
FLUSHCACHES_UNLOCK_LOCKABLE	EQU	00000006H
VMM_Service  Set_Thread_Win32_Pri_NoYield
VMM_Service  _FlushMappedCacheBlock
VMM_Service  _ReleaseMappedCacheBlock
VMM_Service  Run_Preemptable_Events
VMM_Service  _MMPreSystemExit
VMM_Service  _MMPageFileShutDown
VMM_Service  _Set_Global_Time_Out_Ex
VMM_Service  Query_Thread_Priority
endif
End_Service_Table VMM, VMM
COMNFS_FLAT	EQU	0FFFFFFFFH
RS_RECLAIM	EQU	00000001H
RS_RESTORE	EQU	00000002H
RS_DOSARENA	EQU	00000004H

ReclaimStruc	STRUC
RS_Linear	DD	?
RS_Bytes	DD	?
RS_CallBack	DD	?
RS_RefData	DD	?
RS_HookTable	DD	?
RS_Flags	DD	?
ReclaimStruc	ENDS

frmtx	STRUC
frmtx_pfrmtxNext	DD	?
frmtx_hmutex	DD	?
frmtx_cEnterCount	DD	?
frmtx_pthcbOwner	DD	?
frmtx_htimeout	DD	?
frmtx	ENDS

vmmfrinfo	STRUC
vmmfrinfo_frmtxDOS	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxV86	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxOther	DB	SIZE frmtx DUP (?)
vmmfrinfo	ENDS

DemandInfoStruc	STRUC
DILin_Total_Count	DD	?
DIPhys_Count	DD	?
DIFree_Count	DD	?
DIUnlock_Count	DD	?
DILinear_Base_Addr	DD	?
DILin_Total_Free	DD	?
DIPage_Faults	DD	?
DIPage_Ins	DD	?
DIPage_Outs	DD	?
DIPage_Discards	DD	?
DIInstance_Faults	DD	?
DIPagingFileMax	DD	?
DIPagingFileInUse	DD	?
DICommit_Count	DD	?
DIReserved	DD	2 DUP (?)
DemandInfoStruc	ENDS

InstDataStruc	STRUC
InstLinkF	DD	0
InstLinkB	DD	0
InstLinAddr	DD	?
InstSize	DD	?
InstType	DD	?
InstDataStruc	ENDS
INDOS_FIELD	EQU	100H
ALWAYS_FIELD	EQU	200H
OPTIONAL_FIELD	EQU	400H

IPF_Data	STRUC
IPF_LinAddr	DD	?
IPF_MapPageNum	DD	?
IPF_PTEEntry	DD	?
IPF_FaultingVM	DD	?
IPF_Flags	DD	?
IPF_Data	ENDS

Exception_Handler_Struc	STRUC
EH_Reserved	DD	?
EH_Start_EIP	DD	?
EH_End_EIP	DD	?
EH_Handler	DD	?
Exception_Handler_Struc	ENDS
PR_PRIVATE	EQU	80000400H
PR_SHARED	EQU	80060000H
PR_SYSTEM	EQU	80080000H
PR_FIXED	EQU	00000008H
PR_4MEG	EQU	00000001H
PR_STATIC	EQU	00000010H
PD_ZEROINIT	EQU	00000001H
PD_NOINIT	EQU	00000002H
PD_FIXEDZERO	EQU	00000003H
PD_FIXED	EQU	00000004H
PC_FIXED	EQU	00000008H
PC_LOCKED	EQU	00000080H
PC_LOCKEDIFDP	EQU	00000100H
PC_WRITEABLE	EQU	00020000H
PC_USER	EQU	00040000H
PC_INCR	EQU	40000000H
PC_PRESENT	EQU	80000000H
PC_STATIC	EQU	20000000H
PC_DIRTY	EQU	08000000H
PC_CACHEDIS	EQU	00100000H
PC_CACHEWT	EQU	00080000H
PC_PAGEFLUSH	EQU	00008000H
ifdef WRITE_WATCH
PC_WRITE_WATCH	EQU	00200000H
endif
PCC_ZEROINIT	EQU	00000001H
PCC_NOLIN	EQU	10000000H
MTRR_UC	EQU	0
MTRR_WC	EQU	1
MTRR_WT	EQU	4
MTRR_WP	EQU	5
MTRR_WB	EQU	6
ifndef _WINNT_

_MEMORY_BASIC_INFORMATION	STRUC
mbi_BaseAddress	DD	?
mbi_AllocationBase	DD	?
mbi_AllocationProtect	DD	?
mbi_RegionSize	DD	?
mbi_State	DD	?
mbi_Protect	DD	?
mbi_Type	DD	?
_MEMORY_BASIC_INFORMATION	ENDS
PAGE_NOACCESS	EQU	01H
PAGE_READONLY	EQU	02H
PAGE_READWRITE	EQU	04H
MEM_COMMIT	EQU	1000H
MEM_RESERVE	EQU	2000H
MEM_FREE	EQU	10000H
MEM_PRIVATE	EQU	20000H
endif

pd_s	STRUC
pd_virginin	DD	?
pd_taintedin	DD	?
pd_cleanout	DD	?
pd_dirtyout	DD	?
pd_virginfree	DD	?
pd_taintedfree	DD	?
pd_dirty	DD	?
pd_type	DD	?
pd_s	ENDS
PD_SWAPPER	EQU	0
PD_PAGERONLY	EQU	1
PD_NESTEXEC	EQU	2
endif
PAGESHIFT	EQU	12
PAGESIZE	EQU	(1 SHL PAGESHIFT)
PAGEMASK	EQU	(PAGESIZE-1)
MAXSYSTEMLADDR	EQU	(0ffbfffffH)
MINSYSTEMLADDR	EQU	(0c0000000H)
MAXSHAREDLADDR	EQU	(0bfffffffH)
MINSHAREDLADDR	EQU	(80000000H)
MAXPRIVATELADDR	EQU	(7fffffffH)
MINPRIVATELADDR	EQU	(00400000H)
MAXDOSLADDR	EQU	(003fffffH)
MINDOSLADDR	EQU	(00000000H)
MAXSYSTEMPAGE	EQU	(MAXSYSTEMLADDR SHR PAGESHIFT)
MINSYSTEMPAGE	EQU	(MINSYSTEMLADDR SHR PAGESHIFT)
MAXSHAREDPAGE	EQU	(MAXSHAREDLADDR SHR PAGESHIFT)
MINSHAREDPAGE	EQU	(MINSHAREDLADDR SHR PAGESHIFT)
MAXPRIVATEPAGE	EQU	(MAXPRIVATELADDR SHR PAGESHIFT)
MINPRIVATEPAGE	EQU	(MINPRIVATELADDR SHR PAGESHIFT)
MAXDOSPAGE	EQU	(MAXDOSLADDR SHR PAGESHIFT)
MINDOSPAGE	EQU	(MINDOSLADDR SHR PAGESHIFT)
CBPRIVATE	EQU	(1+MAXPRIVATELADDR-MINPRIVATELADDR)
CBSHARED	EQU	(1+MAXSHAREDLADDR-MINSHAREDLADDR)
CBSYSTEM	EQU	(1+MAXSYSTEMLADDR-MINSYSTEMLADDR)
CBDOS	EQU	(1+MAXDOSLADDR-MINDOSLADDR)
CPGPRIVATE	EQU	(1+MAXPRIVATEPAGE-MINPRIVATEPAGE)
CPGSHARED	EQU	(1+MAXSHAREDPAGE-MINSHAREDPAGE)
CPGSYSTEM	EQU	(1+MAXSYSTEMPAGE-MINSYSTEMPAGE)
CPGDOS	EQU	(1+MAXDOSPAGE-MINDOSPAGE)
IFDEF DEBUG
DebFar	EQU NEAR PTR
ELSE
DebFar	EQU SHORT
ENDIF

ASD_MAX_REF_DATA	EQU	256

_vmmguid	STRUC
Data1	DD	?
Data2	DW	?
Data3	DW	?
Data4	DB	8 DUP (?)
_vmmguid	ENDS
ASD_ERROR_NONE	EQU	00000000H
ASD_CHECK_FAIL	EQU	00000001H
ASD_CHECK_SUCCESS	EQU	00000002H
ASD_CHECK_UNKNOWN	EQU	00000003H
ASD_ERROR_BAD_TIME	EQU	00000004H
ASD_REGISTRY_ERROR	EQU	00000005H
ASD_CLEAN_BOOT	EQU	00000006H
ASD_OUT_OF_MEMORY	EQU	00000007H
ASD_FILE_ERROR	EQU	00000008H
ASD_ALREADY_SET	EQU	00000009H
ASD_MISSING_CHECK	EQU	0000000AH
ASD_BAD_PARAMETER	EQU	0000000BH
ASD_OP_CHECK_AND_WRITE_FAIL_IF_UNKNOWN	EQU	00000000H
ASD_OP_CHECK_AND_ALWAYS_WRITE_FAIL	EQU	00000001H
ASD_OP_CHECK	EQU	00000002H
ASD_OP_DONE_AND_SET_SUCCESS	EQU	00000003H
ASD_OP_SET_FAIL	EQU	00000004H
ASD_OP_SET_SUCCESS	EQU	00000005H
ASD_OP_SET_UNKNOWN	EQU	00000006H
ASD_OP_DONE	EQU	00000007H
ASD_FLAG_STRING	EQU	00000001H
ifndef Not_VxD
SYS_CRITICAL_INIT	EQU	0000H
DEVICE_INIT	EQU	0001H
INIT_COMPLETE	EQU	0002H
SYS_VM_INIT	EQU	0003H
SYS_VM_TERMINATE	EQU	0004H
SYSTEM_EXIT	EQU	0005H
SYS_CRITICAL_EXIT	EQU	0006H
CREATE_VM	EQU	0007H
VM_CRITICAL_INIT	EQU	0008H
VM_INIT	EQU	0009H
VM_TERMINATE	EQU	000AH
VM_NOT_EXECUTEABLE	EQU	000BH
DESTROY_VM	EQU	000CH
VNE_CRASHED_BIT	EQU	00H
VNE_CRASHED	EQU	(1 SHL VNE_CRASHED_BIT)
VNE_NUKED_BIT	EQU	01H
VNE_NUKED	EQU	(1 SHL VNE_NUKED_BIT)
VNE_CREATEFAIL_BIT	EQU	02H
VNE_CREATEFAIL	EQU	(1 SHL VNE_CREATEFAIL_BIT)
VNE_CRINITFAIL_BIT	EQU	03H
VNE_CRINITFAIL	EQU	(1 SHL VNE_CRINITFAIL_BIT)
VNE_INITFAIL_BIT	EQU	04H
VNE_INITFAIL	EQU	(1 SHL VNE_INITFAIL_BIT)
VNE_CLOSED_BIT	EQU	05H
VNE_CLOSED	EQU	(1 SHL VNE_CLOSED_BIT)
VM_SUSPEND	EQU	000DH
VM_RESUME	EQU	000EH
SET_DEVICE_FOCUS	EQU	000FH
BEGIN_MESSAGE_MODE	EQU	0010H
END_MESSAGE_MODE	EQU	0011H
REBOOT_PROCESSOR	EQU	0012H
QUERY_DESTROY	EQU	0013H
DEBUG_QUERY	EQU	0014H
BEGIN_PM_APP	EQU	0015H
BPA_32_BIT	EQU	01H
BPA_32_BIT_FLAG	EQU	1
END_PM_APP	EQU	0016H
DEVICE_REBOOT_NOTIFY	EQU	0017H
CRIT_REBOOT_NOTIFY	EQU	0018H
CLOSE_VM_NOTIFY	EQU	0019H
CVNF_CRIT_CLOSE_BIT	EQU	0
CVNF_CRIT_CLOSE	EQU	(1 SHL CVNF_CRIT_CLOSE_BIT)
POWER_EVENT	EQU	001AH
SYS_DYNAMIC_DEVICE_INIT	EQU	001BH
SYS_DYNAMIC_DEVICE_EXIT	EQU	001CH
CREATE_THREAD	EQU	001DH
THREAD_INIT	EQU	001EH
TERMINATE_THREAD	EQU	001FH
THREAD_Not_Executeable	EQU	0020H
DESTROY_THREAD	EQU	0021H
PNP_NEW_DEVNODE	EQU	0022H
W32_DEVICEIOCONTROL	EQU	0023H
DIOC_GETVERSION	EQU	0H
DIOC_OPEN	EQU	DIOC_GETVERSION
DIOC_CLOSEHANDLE	EQU	-1
SYS_VM_TERMINATE2	EQU	0024H
SYSTEM_EXIT2	EQU	0025H
SYS_CRITICAL_EXIT2	EQU	0026H
VM_TERMINATE2	EQU	0027H
VM_NOT_EXECUTEABLE2	EQU	0028H
DESTROY_VM2	EQU	0029H
VM_SUSPEND2	EQU	002AH
END_MESSAGE_MODE2	EQU	002BH
END_PM_APP2	EQU	002CH
DEVICE_REBOOT_NOTIFY2	EQU	002DH
CRIT_REBOOT_NOTIFY2	EQU	002EH
CLOSE_VM_NOTIFY2	EQU	002FH
GET_CONTENTION_HANDLER	EQU	0030H
KERNEL32_INITIALIZED	EQU	0031H
KERNEL32_SHUTDOWN	EQU	0032H
CREATE_PROCESS	EQU	0033H
DESTROY_PROCESS	EQU	0034H
ifndef WIN40COMPAT
SYS_DYNAMIC_DEVICE_REINIT	EQU	0035H
endif
SYS_POWER_DOWN	EQU	0036H
MAX_SYSTEM_CONTROL	EQU	0036H
BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	70000000H
END_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	7FFFFFFFH
endif
SYSSTATE_PRESYSCRITINIT	EQU	00000000H
SYSSTATE_PREDEVICEINIT	EQU	10000000H
SYSSTATE_PREINITCOMPLETE	EQU	20000000H
SYSSTATE_VXDINITCOMPLETED	EQU	40000000H
SYSSTATE_KERNEL32INITED	EQU	50000000H
SYSSTATE_KERNEL32TERMINATED	EQU	0A0000000H
SYSSTATE_PRESYSVMTERMINATE	EQU	0B0000000H
SYSSTATE_PRESYSTEMEXIT	EQU	0E0000000H
SYSSTATE_PRESYSTEMEXIT2	EQU	0E4000000H
SYSSTATE_PRESYSCRITEXIT	EQU	0F0000000H
SYSSTATE_PRESYSCRITEXIT2	EQU	0F4000000H
SYSSTATE_POSTSYSCRITEXIT2	EQU	0FFF00000H
SYSSTATE_PREDEVICEREBOOT	EQU	0FFFF0000H
SYSSTATE_PRECRITREBOOT	EQU	0FFFFF000H
SYSSTATE_PREREBOOTCPU	EQU	0FFFFFF00H
BeginDoc












































































EndDoc












??_pf_Check equ 1
??_pf_ArgsUsed	equ 2
??_pf_Entered	equ 4
??_pf_Left  equ 8
??_pf_Returned	equ    16

??_pushed	=	0
??_align    =	0
??_ends     equ <>

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0
    ??_aframe = 0
    ??_taframe = 0
    ??_initaframe = 0
    ??_numargs = 0
    ??_numlocals = 0
    ??_numlocalsymbols = 0
    ??_procflags = 0
    ??_esp = 0
    ??_pushed = 0
    ??_align = 0
    ??_hook = 0
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG
    ??_profile = DFS_PROFILE
    ??_test_cld = DFS_TEST_CLD
ELSE
    ??_log = 0
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
    ??_test_cld = 0
ENDIF
    ??_might_block = 0
    ??_test_reenter = 0
    ??_never_reenter = 0
    ??_not_swapping = 0
    ??_prolog_disabled = 0
    ??_public = 1
    ??_cleanoff = 0
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_fastcall = 0
    ??_w32svc = 0
    ??_fleave = FALSE

    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>


    irp arg, <P1, P2, P3, P4, P5, P6, P7>
	if ??_hookarg
	??_hookarg = 0
	??_hookvar equ <arg>
	elseifdef ?&&arg&&_BeginProc
	    ?&&arg&&_BeginProc
	elseifdef VxD_&&arg&&_CODE_SEG
	??_ends textequ <VxD_&&arg&&_CODE_ENDS>
	VxD_&&arg&&_CODE_SEG
	else
	.err <Bad param "&arg" to BeginProc>
	endif
    endm


    ifndef Not_VxD
    ife ??_service
	ifndef profileall
	  ??_profile = 0
	endif
	ifdef VMMSYS
	??_prolog_disabled = 1
	endif
    else
	??_test_cld = DFS_TEST_CLD
    endif

    ife ?_16ICODE
	??_prolog_disabled = 1
    else
    ife ?_RCODE
	??_prolog_disabled = 1
    else
	ife ?_PCODE
	??_might_block = DFS_TEST_BLOCK
	endif
	if ??_service
	ife ??_async_service
	    ??_test_reenter = DFS_TEST_REENTER
	endif
	endif
    endif
    endif
    endif

    if ??_esp

    ??_basereg equ <esp+??_pushed>
    ??_initaframe = 4
    else

    ??_basereg equ <ebp>
    ??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall or ??_fastcall


    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
	 ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
	??_dfs = 0
    endif



    ifndef Not_VxD

    if ??_hook
	if ??_align
	Dword_Align
	endif
	prelabeldata:
	ifndef ??_hookvar
	.err <HOOK_PROC requires next arg to be name of dword location>
	endif
	jmp short Name
	jmp [??_hookvar]
	ifdef DEBUG
	Profile_Data dd  0
	endif
	if ??_align
	.errnz ($ - prelabeldata) mod 4
	endif
    endif

    ifdef DEBUG
	?prolog_&Name label near
	if (??_service OR ??_profile) AND (??_hook EQ 0)
	jmp short Name
	if ??_align
	Dword_Align
	endif

	IF ?_ICODE
	ifdef profileall
	  ?ProfileHeader_BeginProc Profile_Data, %@filename
	else
	  Profile_Data dd 0
	endif
	ELSE
	  Profile_Data dd 0
	ENDIF

	endif
    endif

    if ??_align
	Dword_Align
    endif

    endif

    Name proc near



    ife ??_pcall or ??_ccall or ??_scall or ??_fastcall
	if ??_public
	    public Name
	else
	    ifdef DEBUG
		% ?merge @FileName,$,Name,:
		% ?merge public,,,,,@FileName,$,Name
	    endif
	endif
    endif
    if ??_ccall
	if ??_public
	    _&Name equ Name
	ifdef Not_VxD
	 public C Name
	else
		 public _&Name
	endif
	endif
    endif
    if ??_pcall
	if ??_public
	    ?toupper Name
	    ?merge  public,,,,%?upper
	endif
    endif



    ife ??_scall or ??_fastcall
    ?_BeginProc_Debug_Prologue
    endif



endm

?_BeginProc_Debug_Prologue MACRO
    ifndef Not_VxD
    ifdef DEBUG
	if ??_dfs EQ DFS_LOG
	VMMCall Log_Proc_Call
	else
	if ??_dfs EQ DFS_TEST_REENTER
	VMMCall Test_Reenter
	else
	if ??_dfs or ?_LOCKABLECODE eq 0
	ifdef WIN31COMPAT
	    if ??_dfs AND DFS_LOG
	    VMMCall Log_Proc_Call
	    endif
	    if ??_dfs AND DFS_TEST_REENTER
	    VMMCall Test_Reenter
	    endif
	else
	    ife ?_LOCKABLECODE
	    ifdef ??_debug_flags
	    push    ??_debug_flags
	    if ??_dfs
	    pushfd
	    or	dword ptr [esp+4],??_dfs
	    popfd
	    endif
	    VMMCall _Debug_Flags_Service
	    elseif ??_dfs
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	    else
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	endif
	else
	  ifdef profileall
	IncProfileCount
	  endif
	endif
	endif
	endif
    endif
    endif
ENDM






?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
    .erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
    .erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?FASTCALL_BeginProc macro
    ??_fastcall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
	inc dword ptr [??_name-4]
    else
	ifndef profileall
	.err <IncProfileCount can be used only in services.>
	endif
    endif
endm
else
IncProfileCount macro
endm
endif
















ArgVar	macro	name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
	?mkarg	<name>, <length>, <used>, %??_numargs
    else
	?arg <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg	macro	name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
	?argvar <name>, <length>, <used>
	&endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro	name,length,used
    local   a
    a = ??_taframe
    ??_aframe =  ??_aframe + 4
    ??_taframe =  ??_taframe + 4
    ifidni  <length>,<BYTE>
	?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
	?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
	?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
	?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
	??_aframe =  ??_aframe - 4 + ((length + 3)/4)*4
	??_taframe =  ??_taframe - 4 + ((length + 3)/4)*4
	?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

?arg macro   name,length,used
  if ??_fastcall
    if ??_numargs le 2
      if length gt 4
	.err <First 2 parameters are dwords (ecx,edx) for fastcall functions>
      endif
      ??_aframe =  ??_aframe + 4
      if ??_numargs eq 1
	?merge ecx_,name,,,equ,ecx
      else
	?merge edx_,name,,,equ,edx
      endif
    else
      ?argvar name, length, used
    endif
  else
    ?argvar name, length, used
  endif
endm






?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
	name equ _inaccessible_NOTUSED_
    else
	name equ value
	??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm



















LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
	??_pad = 0
    endif
    ifidni  <length>,<BYTE>
	??_frame = ??_frame + 1 + 3 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
	??_frame =  ??_frame + 2 + 2 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
	??_frame = ??_frame + 4
	a = ??_frame
	?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
	name equ dword ptr [??_basereg-a]
	name&l equ word ptr [??_basereg-a]
	name&ll equ byte ptr [??_basereg-a]
	name&lh equ byte ptr [??_basereg-a+1]
	name&h equ word ptr [??_basereg-a+2]
	name&hl equ byte ptr [??_basereg-a+2]
	name&hh equ byte ptr [??_basereg-a+3]
    else
	??_frame =  ??_frame + ((length + 3)/4)*4
	a = ??_frame
	?deflocal <name>
	name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
	??_numlocalsymbols = ??_numlocalsymbols + 1
	?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
	name	equ <__inaccessible__NOTINSCOPE__>
	&endm
    endm
    .xcref  ?dodeflocal



EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	_,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,_,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_fastcall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	@,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,@,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_pcall
	??_aframe = 0
	?count = ??_numargs
	rept	??_numargs
	    ?invprg <?MKA>,%?count
	    ?count = ?count - 1
	endm
    endif
    ??_fleave = FALSE
    if ??_esp
	if  ??_frame
	    sub esp, ??_frame
	    ??_pushed = ??_pushed + ??_frame
	    ??_fleave = VMM_TRUE
	endif
    else
	if  ??_frame eq 0
	    if (??_taframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
		ifdef DEBUG
		    push    ebp
		    mov ebp,esp
		    ??_fleave = VMM_TRUE
		endif
	    else
		push	ebp
		mov ebp,esp
		??_fleave = VMM_TRUE
	    endif
	else
	    enter   ??_frame, 0
	    ??_fleave = VMM_TRUE
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm















LeaveProc macro flags
    if ??_fleave
	if ??_esp
	    ifidni <flags>,<PRESERVE_FLAGS>
		lea esp,[esp + ??_frame]
	    else
		add esp,??_frame
	    endif
	else
	    leave
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm







Return	macro
    if	??_cleanoff OR ??_w32svc
	if  ??_w32svc AND (??_taframe LT 8)
	    ret 8
	else
	    ret ??_taframe
	endif
    else
	ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm




EndProc macro Name, Flag
    Name endp
if ??_w32svc
    if ??_taframe lt 8
	cparm&Name equ 0
    else
	cparm&Name equ (??_taframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi	<Flag>,<NOCHECK>
    if ??_pushed ne 0
	%out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
	ife ??_procflags AND ??_pf_Entered
	    %out Warning: ArgVar/LocalVar without EnterProc in Name
	endif
	ife ??_procflags AND ??_pf_Left
	    %out Warning: ArgVar/LocalVar without LeaveProc in Name
	endif
	ife ??_procflags AND ??_pf_Returned
	    %out Warning: ArgVar/LocalVar without Return in Name
	endif
    endif
endif
ifdifi	<Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
	?count = ?count + 1
	?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm







cCall	macro	name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    ifdef ??_nonstandardccall_&name
    PushCParams <arglst>, <FAST>
    else
    PushCParams <arglst>, <flags>
    endif
    call    name
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    endm
    .xcref  cCall






pCall	macro	name, arglst
    local   ??saved
    ife .TYPE name
	?toupper name
    else
	?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
	push	x
	??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall







sCall	macro	name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  _, name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall














fCall	macro	name, arglst, flags
    local   ??saved
    ??saved = ??_pushed
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <FASTCALL>
    ?scall  @, name, %(??_argc * 4)
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    ??_pushed = ??saved
    endm
    .xcref  fCall





iCall	equ <sCall>














IFNDEF	STANDARD_CCALL
NONSTANDARD_CCALL = 1
ENDIF

PushCParams macro arglst, flags
    LOCAL ??_pushedargs

    ??_argc = 0
IFDEF	NONSTANDARD_CCALL
    ??_popargs = 0
ELSE
    ??_popargs = ??_align EQ 0
ENDIF
    ifidni  <flags>, <SMALL>
	??_popargs = 1
    elseifidni <flags>, <FAST>
	??_popargs = 0
    elseifidni <flags>, <FASTCALL>
	??_popargs = 0
    endif

    irp x,<arglst>
	??_argc = ??_argc + 1
	ifidni <flags>, <FASTCALL>
	  if ??_argc eq 1
	    ifdifi <x>, <ecx>
	      .err <first parameter must be ECX for fastcall functions>
	    endif
	  elseif ??_argc eq 2
	    ifdifi <x>, <edx>
	      .err <first parameter must be EDX for fastcall functions>
	    endif
	  else
	    ?marg   <x>,%??_argc
	  endif
	else
	  ?marg   <x>,%??_argc
	endif
    endm
    ?count = ??_argc
    ifidni <flags>, <FASTCALL>
      ??_pushedargs = ??_argc-2
    else
      ??_pushedargs = ??_argc
    endif
    if ??_pushedargs GT 0
      rept    ??_argc
	?invprg <?AM>,%?count
	?count = ?count - 1
      endm
    endif
    endm
















ClearCParams macro fPreserveFlags
    if	??_argc ne 0
	if (??_popargs) AND (??_argc LE 2)
	  rept ??_argc
	  pop ecx
	  endm
	elseifidni <fPreserveFlags>, <PRESERVE_FLAGS>
	  lea esp, [esp][??_argc * 4]
	else
	  add esp,??_argc * 4
	endif
    endif
    ??_pushed = ??_pushed - (??_argc * 4)
    endm



?marg	macro	name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
	push	name
	??_pushed = ??_pushed + 4
	&endm
    endm
    .xcref  ?marg



?invprg macro	name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg



?scall	macro	prefix, name1, name2
    CondExtern prefix&name1&@&name2, near
    call    prefix&name1&@&name2
    endm
    .xcref  ?scall



?merge	macro	l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm



?toupper macro s
      ?upper equ <>
      irpc x,<s>
	if '&x' GE 'a'
	  if '&x' LE 'z'
	?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
	?upper catstr ?upper,?t1
	  else
	?upper catstr ?upper,<&x>
	  endif
	else
	  ?upper catstr ?upper,<&x>
	endif
      endm
    endm
    .xcref






CondExtern macro name,dist
    ifdef MASM6
	ifndef name
	externdef name:dist
	endif
    else
	if2
	ifndef name
	    extrn name:dist
	endif
	endif
    endif
endm



SaveReg macro	reglist
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    pushfd
	    ??_pushed = ??_pushed + 4
	else
	ifidni <reg>, <ad>
	    pushad
	    ??_pushed = ??_pushed + SIZE Pushad_Struc
	else
	    push    reg
	    ??_pushed = ??_pushed + 4
	endif
	endif
    endm
endm







RestoreReg macro     reglist
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    popfd
	    ??_pushed = ??_pushed - 4
	else
	ifidni <reg>, <ad>
	    popad
	    ??_pushed = ??_pushed - SIZE Pushad_Struc
	else
	    pop reg
	    ??_pushed = ??_pushed - 4
	endif
	endif
    endm
endm

ifdef DEBUG
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db	'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd	OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd	0
VxD_DATA_ENDS
endif
endm


endif
ifndef Not_VxD
RESERVED_LOW_BOOST	EQU	00000001H
CUR_RUN_VM_BOOST	EQU	00000004H
LOW_PRI_DEVICE_BOOST	EQU	00000010H
HIGH_PRI_DEVICE_BOOST	EQU	00001000H
CRITICAL_SECTION_BOOST	EQU	00100000H
TIME_CRITICAL_BOOST	EQU	00400000H
RESERVED_HIGH_BOOST	EQU	40000000H
PEF_WAIT_FOR_STI_BIT	EQU	0
PEF_WAIT_FOR_STI	EQU	(1 SHL PEF_WAIT_FOR_STI_BIT)
PEF_WAIT_NOT_CRIT_BIT	EQU	1
PEF_WAIT_NOT_CRIT	EQU	(1 SHL PEF_WAIT_NOT_CRIT_BIT)
PEF_DONT_UNBOOST_BIT	EQU	2
PEF_DONT_UNBOOST	EQU	(1 SHL PEF_DONT_UNBOOST_BIT)
PEF_ALWAYS_SCHED_BIT	EQU	3
PEF_ALWAYS_SCHED	EQU	(1 SHL PEF_ALWAYS_SCHED_BIT)
PEF_TIME_OUT_BIT	EQU	4
PEF_TIME_OUT	EQU	(1 SHL PEF_TIME_OUT_BIT)
PEF_WAIT_NOT_HW_INT_BIT	EQU	5
PEF_WAIT_NOT_HW_INT	EQU	(1 SHL PEF_WAIT_NOT_HW_INT_BIT)
PEF_WAIT_NOT_NESTED_EXEC_BIT	EQU	6
PEF_WAIT_NOT_NESTED_EXEC	EQU	(1 SHL PEF_WAIT_NOT_NESTED_EXEC_BIT)
PEF_WAIT_IN_PM_BIT	EQU	7
PEF_WAIT_IN_PM	EQU	(1 SHL PEF_WAIT_IN_PM_BIT)
PEF_THREAD_EVENT_BIT	EQU	8
PEF_THREAD_EVENT	EQU	(1 SHL PEF_THREAD_EVENT_BIT)
PEF_WAIT_FOR_THREAD_STI_BIT	EQU	9
PEF_WAIT_FOR_THREAD_STI	EQU	(1 SHL PEF_WAIT_FOR_THREAD_STI_BIT)
PEF_RING0_EVENT_BIT	EQU	10
PEF_RING0_EVENT	EQU	(1 SHL PEF_RING0_EVENT_BIT)
PEF_WAIT_CRIT_BIT	EQU	11
PEF_WAIT_CRIT	EQU	(1 SHL PEF_WAIT_CRIT_BIT)
PEF_WAIT_CRIT_VM_BIT	EQU	12
PEF_WAIT_CRIT_VM	EQU	(1 SHL PEF_WAIT_CRIT_VM_BIT)
PEF_PROCESS_LAST_BIT	EQU	13
PEF_PROCESS_LAST	EQU	(1 SHL PEF_PROCESS_LAST_BIT)
PEF_WAIT_PREEMPTABLE_BIT	EQU	14
PEF_WAIT_PREEMPTABLE	EQU	(1 SHL PEF_WAIT_PREEMPTABLE_BIT)
PEF_WAIT_FOR_PASSIVE_BIT	EQU	15
PEF_WAIT_FOR_PASSIVE	EQU	(1 SHL PEF_WAIT_FOR_PASSIVE_BIT)
PEF_WAIT_FOR_APPY_BIT	EQU	16
PEF_WAIT_FOR_APPY	EQU	(1 SHL PEF_WAIT_FOR_APPY_BIT)
PEF_WAIT_FOR_WORKER_BIT	EQU	17
PEF_WAIT_FOR_WORKER	EQU	(1 SHL PEF_WAIT_FOR_WORKER_BIT)
PEF_WAIT_NOT_TIME_CRIT_BIT	EQU	PEF_WAIT_NOT_HW_INT_BIT
PEF_WAIT_NOT_TIME_CRIT	EQU	PEF_WAIT_NOT_HW_INT
PEF_WAIT_NOT_PM_LOCKED_STACK_BIT	EQU	PEF_WAIT_NOT_NESTED_EXEC_BIT
PEF_WAIT_NOT_PM_LOCKED_STACK	EQU	PEF_WAIT_NOT_NESTED_EXEC
PEF_WAIT_FOR_CONFIGMG_CALLABLE	EQU	PEF_WAIT_FOR_WORKER
PEF_WAIT_FOR_CONFIGMG_QUICK	EQU	PEF_WAIT_FOR_APPY
BLOCK_SVC_INTS_BIT	EQU	0
BLOCK_SVC_INTS	EQU	(1 SHL BLOCK_SVC_INTS_BIT)
BLOCK_SVC_IF_INTS_LOCKED_BIT	EQU	1
BLOCK_SVC_IF_INTS_LOCKED	EQU	(1 SHL BLOCK_SVC_IF_INTS_LOCKED_BIT)
BLOCK_ENABLE_INTS_BIT	EQU	2
BLOCK_ENABLE_INTS	EQU	(1 SHL BLOCK_ENABLE_INTS_BIT)
BLOCK_POLL_BIT	EQU	3
BLOCK_POLL	EQU	(1 SHL BLOCK_POLL_BIT)
BLOCK_THREAD_IDLE_BIT	EQU	4
BLOCK_THREAD_IDLE	EQU	(1 SHL BLOCK_THREAD_IDLE_BIT)
BLOCK_FORCE_SVC_INTS_BIT	EQU	5
BLOCK_FORCE_SVC_INTS	EQU	(1 SHL BLOCK_FORCE_SVC_INTS_BIT)

Client_Reg_Struc	STRUC
Client_EDI	DD	?
Client_ESI	DD	?
Client_EBP	DD	?
Client_res0	DD	?
Client_EBX	DD	?
Client_EDX	DD	?
Client_ECX	DD	?
Client_EAX	DD	?
Client_Error	DD	?
Client_EIP	DD	?
Client_CS	DW	?
Client_res1	DW	?
Client_EFlags	DD	?
Client_ESP	DD	?
Client_SS	DW	?
Client_res2	DW	?
Client_ES	DW	?
Client_res3	DW	?
Client_DS	DW	?
Client_res4	DW	?
Client_FS	DW	?
Client_res5	DW	?
Client_GS	DW	?
Client_res6	DW	?
Client_Alt_EIP	DD	?
Client_Alt_CS	DW	?
Client_res7	DW	?
Client_Alt_EFlags	DD	?
Client_Alt_ESP	DD	?
Client_Alt_SS	DW	?
Client_res8	DW	?
Client_Alt_ES	DW	?
Client_res9	DW	?
Client_Alt_DS	DW	?
Client_res10	DW	?
Client_Alt_FS	DW	?
Client_res11	DW	?
Client_Alt_GS	DW	?
Client_res12	DW	?
Client_Reg_Struc	ENDS

Client_Word_Reg_Struc	STRUC
Client_DI	DW	?
Client_res13	DW	?
Client_SI	DW	?
Client_res14	DW	?
Client_BP	DW	?
Client_res15	DW	?
Client_res16	DD	?
Client_BX	DW	?
Client_res17	DW	?
Client_DX	DW	?
Client_res18	DW	?
Client_CX	DW	?
Client_res19	DW	?
Client_AX	DW	?
Client_res20	DW	?
Client_res21	DD	?
Client_IP	DW	?
Client_res22	DW	?
Client_res23	DD	?
Client_Flags	DW	?
Client_res24	DW	?
Client_SP	DW	?
Client_res25	DW	?
Client_res26	DD	5 DUP (?)
Client_Alt_IP	DW	?
Client_res27	DW	?
Client_res28	DD	?
Client_Alt_Flags	DW	?
Client_res29	DW	?
Client_Alt_SP	DW	?
Client_Word_Reg_Struc	ENDS

Client_Byte_Reg_Struc	STRUC
Client_res30	DD	4 DUP (?)
Client_BL	DB	?
Client_BH	DB	?
Client_res31	DW	?
Client_DL	DB	?
Client_DH	DB	?
Client_res32	DW	?
Client_CL	DB	?
Client_CH	DB	?
Client_res33	DW	?
Client_AL	DB	?
Client_AH	DB	?
Client_Byte_Reg_Struc	ENDS
?UnionSize = 0
if size Client_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Reg_Struc
endif
CRS	equ	<(byte ptr 0)>

if size Client_Word_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Word_Reg_Struc
endif
CWRS	equ	<(byte ptr 0)>

if size Client_Byte_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Byte_Reg_Struc
endif
CBRS	equ	<(byte ptr 0)>


tagCLIENT_STRUC	STRUC
	DB	?UnionSize dup(?)
tagCLIENT_STRUC	ENDS

IF 0
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX

endif
DYNA_LINK_INT	EQU	20H












DeclareNonstandardCcallService macro arglst
    irp x,<arglst>
	??_nonstandardccall_&&x = 1
    endm
endm






DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page>

BeginDoc













EndDoc


BeginDoc








EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd	OFFSET32 vt[sn+jf]
ENDM

GenDD	MACRO	P, vid, snum, jflag
    LOCAL   vtable
IFDEF	@@VxDName&vid
    Deftable	vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd	@@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)

    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

VxDJmp	MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

WDMCall MACRO P, Param, flags
    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    mov	eax,WDM@@&P
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

WDMJmp	MACRO P, Param
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to WDMJmp>
    endif
    mov	eax, WDM@@&P+WDM_DL_Jmp_Mask
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ENDM

WDM_DL_Jmp_Mask	EQU	80000000h
WDM_DL_Jmp_Bit	EQU	31

BeginDoc




























EndDoc




VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT	 ENDS
	ENDM




VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT	 ENDS
	ENDM




VxD_DEBUG_ONLY_CODE_SEG MACRO
_DB1CODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
	ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DB1CODE    ENDS
	ENDM




VxD_INIT_CODE_SEG   MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT	ENDS
	ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS




VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
	ENDM




VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
	ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
	ENDM




VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA	 ENDS
	ENDM




VxD_STATIC_CODE_SEG MACRO
_STEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT	 ENDS
	ENDM




VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA	 ENDS
	ENDM



VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DB2DATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DB2DATA    ENDS
	ENDM




VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
	  ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
	   ENDM



VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
	  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
	   ENDM

endif
ifndef DDK_VERSION
ifdef WIN31COMPAT
DDK_VERSION	EQU	30AH
else
ifdef WIN40COMPAT
DDK_VERSION	EQU	400H
else
DDK_VERSION	EQU	40AH
endif
endif
endif

VxD_Desc_Block	STRUC
DDB_Next	DD	?
DDB_SDK_Version	DW	DDK_VERSION
DDB_Req_Device_Number	DW	UNDEFINED_DEVICE_ID
DDB_Dev_Major_Version	DB	0
DDB_Dev_Minor_Version	DB	0
DDB_Flags	DW	0
DDB_Name	DB	"        "
DDB_Init_Order	DD	UNDEFINED_INIT_ORDER
DDB_Control_Proc	DD	?
DDB_V86_API_Proc	DD	0
DDB_PM_API_Proc	DD	0
DDB_V86_API_CSIP	DD	0
DDB_PM_API_CSIP	DD	0
DDB_Reference_Data	DD	?
DDB_Service_Table_Ptr	DD	0
DDB_Service_Table_Size	DD	0
DDB_Win32_Service_Table	DD	0
DDB_Prev	DD	'Prev'
DDB_Size	DD	SIZE(VxD_Desc_Block)
DDB_Reserved1	DD	'Rsv1'
DDB_Reserved2	DD	'Rsv2'
DDB_Reserved3	DD	'Rsv3'
VxD_Desc_Block	ENDS
ifndef Not_VxD
DDB_SYS_CRIT_INIT_DONE_BIT	EQU	0
DDB_SYS_CRIT_INIT_DONE	EQU	(1 SHL DDB_SYS_CRIT_INIT_DONE_BIT)
DDB_DEVICE_INIT_DONE_BIT	EQU	1
DDB_DEVICE_INIT_DONE	EQU	(1 SHL DDB_DEVICE_INIT_DONE_BIT)
DDB_HAS_WIN32_SVCS_BIT	EQU	14
DDB_HAS_WIN32_SVCS	EQU	(1 SHL DDB_HAS_WIN32_SVCS_BIT)
DDB_DYNAMIC_VXD_BIT	EQU	15
DDB_DYNAMIC_VXD	EQU	(1 SHL DDB_DYNAMIC_VXD_BIT)
DDB_DEVICE_DYNALINKED_BIT	EQU	13
DDB_DEVICE_DYNALINKED	EQU	(1 SHL DDB_DEVICE_DYNALINKED_BIT)
BeginDoc







EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB	<Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
	Ref_Data_Offset EQU 0
ELSE
	Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db	0dh, 0ah, 'D_E_B_U_G===>'
	db	"&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
	     OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
	     ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM





























Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd	OFFSET32 ??_cd_&&num
ELSE
    dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc




















EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz	Procedure
ENDIF

ELSE

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF

    ENDM

BYTE_INPUT	EQU	000H
BYTE_OUTPUT	EQU	004H
WORD_INPUT	EQU	008H
WORD_OUTPUT	EQU	00CH
DWORD_INPUT	EQU	010H
DWORD_OUTPUT	EQU	014H
OUTPUT_BIT	EQU	2
OUTPUT	EQU	(1 SHL OUTPUT_BIT)
WORD_IO_BIT	EQU	3
WORD_IO	EQU	(1 SHL WORD_IO_BIT)
DWORD_IO_BIT	EQU	4
DWORD_IO	EQU	(1 SHL DWORD_IO_BIT)
STRING_IO_BIT	EQU	5
STRING_IO	EQU	(1 SHL STRING_IO_BIT)
REP_IO_BIT	EQU	6
REP_IO	EQU	(1 SHL REP_IO_BIT)
ADDR_32_IO_BIT	EQU	7
ADDR_32_IO	EQU	(1 SHL ADDR_32_IO_BIT)
REVERSE_IO_BIT	EQU	8
REVERSE_IO	EQU	(1 SHL REVERSE_IO_BIT)
IO_SEG_MASK	EQU	0FFFF0000H
IO_SEG_SHIFT	EQU	10H
BeginDoc






EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb	In_Proc
ELSE
    je	Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc







EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM

BeginDoc








EndDoc


VxD_IOT_Hdr	STRUC
VxD_IO_Ports	DW	?
VxD_IOT_Hdr	ENDS

VxD_IO_Struc	STRUC
VxD_IO_Port	DW	?
VxD_IO_Proc	DD	?
VxD_IO_Struc	ENDS
.ERRNZ SIZE VxD_IOT_Hdr - 2
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw	Table_Name&_Entries
ELSE
    dw	?
ENDIF
ELSE
    dw	Table_Name&_Entries
ENDIF

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6
VxD_IO MACRO Port, Proc_Name
    dw	Port
    dd	OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
	ENDM













Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc














EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc















EndDoc

CallJmp MACRO Function_Name, Return_Label
IFDEF DEBUG
    call    Function_Name
    jmp     Return_Label
ELSE
    push    Return_Label
    jmp     Function_Name
ENDIF
    ENDM


BeginDoc






EndDoc

IFDEF	DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF



PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16











Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM



VxDint	MACRO	Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
	VMMCall _ExecVxDIntMustComplete
    ENDM

Load_FS 	macro
	VMMCall Load_FS_Service
endm

endif
DUPLICATE_DEVICE_ID_BIT	EQU	0
DUPLICATE_DEVICE_ID	EQU	(1 SHL DUPLICATE_DEVICE_ID_BIT)
DUPLICATE_FROM_INT2F_BIT	EQU	1
DUPLICATE_FROM_INT2F	EQU	(1 SHL DUPLICATE_FROM_INT2F_BIT)
LOADING_FROM_INT2F_BIT	EQU	2
LOADING_FROM_INT2F	EQU	(1 SHL LOADING_FROM_INT2F_BIT)
DEVICE_LOAD_OK	EQU	0
ABORT_DEVICE_LOAD	EQU	1
ABORT_WIN386_LOAD	EQU	2
DEVICE_NOT_NEEDED	EQU	3
NO_FAIL_MESSAGE_BIT	EQU	15
NO_FAIL_MESSAGE	EQU	(1 SHL NO_FAIL_MESSAGE_BIT)
LDRSRV_GET_PROFILE_STRING	EQU	0
LDRSRV_GET_NEXT_PROFILE_STRING	EQU	1
LDRSRV_RESERVED	EQU	2
LDRSRV_GET_PROFILE_BOOLEAN	EQU	3
LDRSRV_GET_PROFILE_DECIMAL_INT	EQU	4
LDRSRV_GET_PROFILE_HEX_INT	EQU	5
LDRSRV_COPY_EXTENDED_MEMORY	EQU	6
LDRSRV_GET_MEMORY_INFO	EQU	7
LDRSRV_RegOpenKey	EQU	100H
LDRSRV_RegCreateKey	EQU	101H
LDRSRV_RegCloseKey	EQU	102H
LDRSRV_RegDeleteKey	EQU	103H
LDRSRV_RegSetValue	EQU	104H
LDRSRV_RegQueryValue	EQU	105H
LDRSRV_RegEnumKey	EQU	106H
LDRSRV_RegDeleteValue	EQU	107H
LDRSRV_RegEnumValue	EQU	108H
LDRSRV_RegQueryValueEx	EQU	109H
LDRSRV_RegSetValueEx	EQU	10AH
LDRSRV_RegFlushKey	EQU	10BH
LDRSRV_COPY_INIT	EQU	1
LDRSRV_COPY_LOCKED	EQU	2
LDRSRV_COPY_PAGEABLE	EQU	3
RCODE_OBJ	EQU	-1
LCODE_OBJ	EQU	01H
LDATA_OBJ	EQU	02H
PCODE_OBJ	EQU	03H
PDATA_OBJ	EQU	04H
SCODE_OBJ	EQU	05H
SDATA_OBJ	EQU	06H
CODE16_OBJ	EQU	07H
LMSG_OBJ	EQU	08H
PMSG_OBJ	EQU	09H
DBOC_OBJ	EQU	0BH
DBOD_OBJ	EQU	0CH
PLCODE_OBJ	EQU	0DH
PPCODE_OBJ	EQU	0FH
ICODE_OBJ	EQU	11H
IDATA_OBJ	EQU	12H
ICODE16_OBJ	EQU	13H
IMSG_OBJ	EQU	14H

ObjectLocation	STRUC
OL_LinearAddr	DD	?
OL_Size	DD	?
OL_ObjType	DB	?
ObjectLocation	ENDS
MAXOBJECTS	EQU	25

Device_Location_List	STRUC
DLL_DDB	DD	?
DLL_NumObjects	DB	?
DLL_ObjLocation	DB	SIZE ObjectLocation * 1 DUP (?)
Device_Location_List	ENDS
PE_BIT	EQU	0
PE_MASK	EQU	(1 SHL PE_BIT)
MP_BIT	EQU	1
MP_MASK	EQU	(1 SHL MP_BIT)
EM_BIT	EQU	2
EM_MASK	EQU	(1 SHL EM_BIT)
TS_BIT	EQU	3
TS_MASK	EQU	(1 SHL TS_BIT)
ET_BIT	EQU	4
ET_MASK	EQU	(1 SHL ET_BIT)
PG_BIT	EQU	31
PG_MASK	EQU	(1 SHL PG_BIT)
CF_BIT	EQU	0
CF_MASK	EQU	(1 SHL CF_BIT)
PF_BIT	EQU	2
PF_MASK	EQU	(1 SHL PF_BIT)
AF_BIT	EQU	4
AF_MASK	EQU	(1 SHL AF_BIT)
ZF_BIT	EQU	6
ZF_MASK	EQU	(1 SHL ZF_BIT)
SF_BIT	EQU	7
SF_MASK	EQU	(1 SHL SF_BIT)
TF_BIT	EQU	8
TF_MASK	EQU	(1 SHL TF_BIT)
IF_BIT	EQU	9
IF_MASK	EQU	(1 SHL IF_BIT)
DF_BIT	EQU	10
DF_MASK	EQU	(1 SHL DF_BIT)
OF_BIT	EQU	11
OF_MASK	EQU	(1 SHL OF_BIT)
IOPL_MASK	EQU	3000H
IOPL_BIT0	EQU	12
IOPL_BIT1	EQU	13
NT_BIT	EQU	14
NT_MASK	EQU	(1 SHL NT_BIT)
RF_BIT	EQU	16
RF_MASK	EQU	(1 SHL RF_BIT)
VM_BIT	EQU	17
VM_MASK	EQU	(1 SHL VM_BIT)
AC_BIT	EQU	18
AC_MASK	EQU	(1 SHL AC_BIT)
VIF_BIT	EQU	19
VIF_MASK	EQU	(1 SHL VIF_BIT)
VIP_BIT	EQU	20
VIP_MASK	EQU	(1 SHL VIP_BIT)






IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF

P_SIZE	EQU	1000H
P_PRESBIT	EQU	0
P_PRES	EQU	(1 SHL P_PRESBIT)
P_WRITEBIT	EQU	1
P_WRITE	EQU	(1 SHL P_WRITEBIT)
P_USERBIT	EQU	2
P_USER	EQU	(1 SHL P_USERBIT)
P_ACCBIT	EQU	5
P_ACC	EQU	(1 SHL P_ACCBIT)
P_DIRTYBIT	EQU	6
P_DIRTY	EQU	(1 SHL P_DIRTYBIT)
P_AVAIL	EQU	(P_PRES+P_WRITE+P_USER)
PG_VM	EQU	0
PG_SYS	EQU	1
PG_RESERVED1	EQU	2
PG_PRIVATE	EQU	3
PG_RESERVED2	EQU	4
PG_RELOCK	EQU	5
PG_INSTANCE	EQU	6
PG_HOOKED	EQU	7
PG_IGNORE	EQU	0FFFFFFFFH
D_PRES	EQU	080H
D_NOTPRES	EQU	0
D_DPL0	EQU	0
D_DPL1	EQU	020H
D_DPL2	EQU	040H
D_DPL3	EQU	060H
D_SEG	EQU	010H
D_CTRL	EQU	0
D_GRAN_BYTE	EQU	000H
D_GRAN_PAGE	EQU	080H
D_DEF16	EQU	000H
D_DEF32	EQU	040H
D_CODE	EQU	08H
D_DATA	EQU	0
D_X	EQU	0
D_RX	EQU	02H
D_C	EQU	04H
D_R	EQU	0
D_W	EQU	02H
D_ED	EQU	04H
D_ACCESSED	EQU	1
RW_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_W)
R_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_R)
CODE_TYPE	EQU	(D_PRES+D_SEG+D_CODE+D_RX)
D_PAGE32	EQU	(D_GRAN_PAGE+D_DEF32)
SELECTOR_MASK	EQU	0FFF8H
SEL_LOW_MASK	EQU	0F8H
TABLE_MASK	EQU	04H
RPL_MASK	EQU	03H
RPL_CLR	EQU	(NOT RPL_MASK)
IVT_ROM_DATA_SIZE	EQU	500H
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\detect\findoem.cpp ===
/*** findoem.cpp - OEM detection interface
 *
 *  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/08/98
 *
 *  MODIFICATION HISTORY
 *	10/07/2000	waltw	Ripped out auto_hkey, auto_hfile, auto_hlib, _com_ptr_t (_COM_SMARTPTR_TYPEDEF),
 *						bstr_t, variant_t, & exceptions. Converted to generic text mappings
 *						(Unicode or ANSI compile)
 *	11/02/2000	waltw	Stub out VxD functions for Unicode builds and ia64 ANSI builds.
 */

#define		_WIN32_DCOM		// so we can attempt to call CoInitializeSecurity
#include <comdef.h>
#include <tchar.h>
#include <windows.h>
#include <objbase.h>
#include <ole2.h>
#include<MISTSAFE.h>

// #define __IUENGINE_USES_ATL_
#if defined(__IUENGINE_USES_ATL_)
#include <atlbase.h>
#define USES_IU_CONVERSION USES_CONVERSION
#else
#include <MemUtil.h>
#endif

#include <logging.h>
#include <iucommon.h>

#include <wuiutest.h>
#include <wbemcli.h>
#include <wubios.h>
#include <osdet.h>
#include <wusafefn.h>

//
// Do we really want a VxD?
//
#if defined(IA64) || defined(_IA64_) || defined(UNICODE) || defined(_UNICODE)
// It's gone...
#define NUKE_VXD 1
#else
// We still have friends on Win9x platforms
#define NUKE_VXD 0
#endif

// hardcodes - not defined in any header
const CLSID CLSID_WbemLocator = {0x4590f811,0x1d3a,0x11d0,{0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24}};

#if NUKE_VXD == 0
const TCHAR WUBIOS_VXD_NAME[] = {_T("\\\\.\\WUBIOS.VXD")};
#endif



#define BYTEOF(d,i)	(((BYTE *)&(d))[i])

// used in UseVxD()
HINSTANCE g_hinst;

/*** Local function prototypes
 */

static void UseOeminfoIni(POEMINFO pOemInfo);
static void UseAcpiReg(POEMINFO pOemInfo);
static void UseWBEM(POEMINFO pOemInfo);
static void UseVxD(POEMINFO pOemInfo);
static bool ReadFromReg(POEMINFO pOemInfo);
static void SaveToReg(POEMINFO pOemInfo);

/*** Registry access
 */
static const TCHAR REGSTR_KEY_OEMINFO[]		= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\OemInfo");
static const TCHAR REGSTR_VAL_MASK[]		= _T("Mask");
static const TCHAR REGSTR_VAL_ACPIOEM[]		= _T("AcpiOem");
static const TCHAR REGSTR_VAL_ACPIPRODUCT[]	= _T("AcpiProduct");
static const TCHAR REGSTR_VAL_SMBOEM[]		= _T("SmbOem");
static const TCHAR REGSTR_VAL_SMBPRODUCT[]	= _T("SmbProduct");
static const TCHAR REGSTR_VAL_PNPOEMID[]	= _T("PnpOemId");
static const TCHAR REGSTR_VAL_INIOEM[]		= _T("IniOem");
static const TCHAR REGSTR_VAL_WBEMOEM[]		= _T("WbemOem");
static const TCHAR REGSTR_VAL_WBEMPRODUCT[]	= _T("WbemProduct");
static const TCHAR REGSTR_VAL_OEMINFO_VER[]	= _T("OemInfoVersion");	// used to determine if we need to nuke old values
static const TCHAR REGSTR_VAL_SUPPORTURL[]	= _T("OemSupportURL");

//
// forward declarations
//
HRESULT GetOemInfo(POEMINFO pOemInfo, bool fAlwaysDetectAndDontSave = false);
BSTR StringID(DWORD dwID);



//
//	Increment REG_CURRENT_OEM_VER whenever you need to force override of
//	old values written to the OemInfo key. Doesn't need to change for each
//	new control version.
//
//	History: No version - original controls
//			 Version 1	- WUV3 when OEM functions first fixed Aug. 2000
//			 Version 2	- IU control
#define REG_CURRENT_OEM_VER	2

// Based on V3 MakeAndModel
//  Note that for OEMINFO_PNP_PRESENT or
//  OEMINFO_INI_PRESENT the model BSTR is an empty string.
HRESULT GetOemBstrs(BSTR& bstrManufacturer, BSTR& bstrModel, BSTR& bstrSupportURL)
{
	USES_IU_CONVERSION;

	LOG_Block("GetOemBstrs");

	if(NULL != bstrManufacturer || NULL != bstrModel || NULL != bstrSupportURL)
	{
		// BSTRs must be NULL on entry
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	// Collect all the data possible, but always prefer in the following order
	//				Win98	WinME	NT4		Win2k/WinXP
	//	-----------------------------------------
	//	WBEM/WMI	1		1		1		1
	//	SMBIOS/DMI	3		3					// wubios.vxd
	//	ACPI		2		2				2	// UseAcpiReg or wubios.vxd
	//	PNP			4		4					// wubios.vxd		
	//	OEMInfo.ini	5		5		2
	
	//
	// Move OEMINFO to heap per Prefast warning 831: GetOemBstrs uses 5792 bytes
	// of stack, consider moving some data to heap.  
	//
	POEMINFO pOemInfo = NULL;
	HRESULT hr;

	pOemInfo = (POEMINFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(OEMINFO));
	if (NULL == pOemInfo)
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
		return E_OUTOFMEMORY;
	}
	//
	// Fill in the pOemInfo struct.
	//
	if (SUCCEEDED(hr = GetOemInfo(pOemInfo)))
	{
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szWbemOem));
			bstrModel			= SysAllocString(T2OLE(pOemInfo->szWbemProduct));
		}
		// NTRAID#NTBUG9-248906-2000/12/13-waltw IU: Improve OEM detection and reporting.
		//	prefer SMBIOS over ACPI, and always try to report OEM support URL.
		else if (pOemInfo->dwMask & OEMINFO_SMB_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szSmbOem));
			bstrModel			= SysAllocString(T2OLE(pOemInfo->szSmbProduct));
		}
		else if (pOemInfo->dwMask & OEMINFO_ACPI_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szAcpiOem));
			bstrModel			= SysAllocString(T2OLE(pOemInfo->szAcpiProduct));
		}
		else if (pOemInfo->dwMask & OEMINFO_PNP_PRESENT)
		{
			bstrManufacturer	= StringID(pOemInfo->dwPnpOemId);
			bstrModel			= SysAllocString(T2OLE(_T("")));	// empty BSTR
		}
		else if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szIniOem));
			bstrModel			= SysAllocString(T2OLE(_T("")));	// empty BSTR
		}

		//
		// Always return the OEMSupportURL if available
		//
		if (0 < lstrlen(pOemInfo->szIniOemSupportUrl))
		{
			bstrSupportURL		= SysAllocString(T2OLE(pOemInfo->szIniOemSupportUrl));
		}
		else
		{
			bstrSupportURL		= SysAllocString(T2OLE(_T("")));	// empty BSTR
		}

		//
		// Manufacturer and Model are optional (if !pOemInfo->dwMask)
		//
		if (	(pOemInfo->dwMask && (NULL == bstrManufacturer || NULL == bstrModel)) ||
				NULL == bstrSupportURL	)
		{
			SafeSysFreeString(bstrManufacturer);
			SafeSysFreeString(bstrModel);
			SafeSysFreeString(bstrSupportURL);

			LOG_ErrorMsg(E_OUTOFMEMORY);
			hr = E_OUTOFMEMORY;
		}
	}

	SafeHeapFree(pOemInfo);
	return hr;
}

/*** GetOemInfo - Gather all available machine OEM and model information
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      
 */
HRESULT GetOemInfo(POEMINFO pOemInfo, bool fAlwaysDetectAndDontSave /*= false*/)
{
	LOG_Block("GetOemInfo");
	HRESULT hr;

	if (!pOemInfo)
	{
		LOG_Error(_T("E_INVALIDARG"));
		SetHrAndGotoCleanUp(E_INVALIDARG);
	}
	// Worst case:
	ZeroMemory(pOemInfo, sizeof(OEMINFO)); 
	// Do detection if necessary or requested
	if (fAlwaysDetectAndDontSave || ! ReadFromReg(pOemInfo))
	{
		//
		// Always attempt to get strings from oeminfo.ini, if present
		//
		UseOeminfoIni(pOemInfo);

		OSVERSIONINFO	osvi;
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		if (GetVersionEx(&osvi))
		{
			if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId)
			{
				UseWBEM(pOemInfo);
				UseVxD(pOemInfo);
			}
			else if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
			{
				if (4 < osvi.dwMajorVersion)
				{
					// Win2k and higher
					UseWBEM(pOemInfo);
					UseAcpiReg(pOemInfo);
				}
				else
				{
					UseWBEM(pOemInfo);
				}
			}
			// Save info to the registry
			if (!fAlwaysDetectAndDontSave)
			{
				SaveToReg(pOemInfo);
			}
		}
		else
		{
			LOG_Driver(_T("GetVersionEx:"));
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
	}

	//
	// Manufacturer and Model are now optional (RAID#337879	IU: can't get latest IU controls
	// to work with IU site) so it is OK to return with no information
	//

	return S_OK;

CleanUp:
	//
	// Only used for returning errors
	//
	return hr;
}


/***LP  StringID - convert numeric ID to string ID
 *
 *  ENTRY
 *      dwID - numeric PnP ID
 *
 *  EXIT
 *      returns string ID
 */

BSTR StringID(DWORD dwID)
{
	LOG_Block("StringID");

	USES_IU_CONVERSION;
	TCHAR szID[8];
    WORD wVenID;
    int i;

	wVenID = (WORD)(((dwID & 0x00ff) << 8) | ((dwID & 0xff00) >> 8));
	wVenID <<= 1;

	for (i = 0; i < 3; ++i)
	{
		szID[i] = (TCHAR)(((wVenID & 0xf800) >> 11) + 0x40);
		wVenID <<= 5;
	}
	wVenID = HIWORD(dwID);
	wVenID = (WORD)(((wVenID & 0x00ff) << 8) | ((wVenID & 0xff00) >> 8));
	for (i = 6; i > 2; --i)
	{
		szID[i] = (TCHAR)(wVenID & 0x000F);
		if(szID[i] > 9)
		{
			szID[i] += 0x37; // 'A' - 0xA	for digits A to F
		}
		else
		{
			szID[i] += 0x30; // '0'			for digits 0 to 9
		}
		wVenID >>= 4;
	}

    return SysAllocString(T2OLE(szID));
} //StringID


/*** UseOeminfoIni - get OemInfo from OEMINFO.INI
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseOeminfoIni(POEMINFO pOemInfo)
{
	LOG_Block("UseOeminfoIni");
	static const TCHAR szFile[]			= _T("OEMINFO.INI");
	static const TCHAR szSection[]		= _T("General");
	static const TCHAR szKey[]			= _T("Manufacturer");
	static const TCHAR szSupportURL[]	= _T("SupportURL");

	HRESULT hr=S_OK;
	

	TCHAR szPath[MAX_PATH + 1];
	// OEMINFO.INI is in system directory
	if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)) > 0)
	{
		hr=PathCchAppend(szPath,ARRAYSIZE(szPath),szFile);

		if(FAILED(hr))
		{
			LOG_ErrorMsg(HRESULT_CODE(hr));
			return;
		}

		GetPrivateProfileString(szSection, szKey, _T(""), 
			pOemInfo->szIniOem, ARRAYSIZE(pOemInfo->szIniOem), szPath);
		if (lstrlen(pOemInfo->szIniOem))
		{
			pOemInfo->dwMask |= OEMINFO_INI_PRESENT;
			LOG_Driver(_T("Set OEMINFO_INI_PRESENT bit"));
		}
		//
		// We'll use szIniOemSupportUrl any time we can get it, but don't need to set flag
		//
		GetPrivateProfileString(szSection, szSupportURL, _T(""), 
			pOemInfo->szIniOemSupportUrl, ARRAYSIZE(pOemInfo->szIniOemSupportUrl), szPath);
   }
}

/*** UseAcpiReg - get OemInfo from the registry
 *
 *  Structure of the registry will be:
 *	HKEY_LOCAL_MACHINE\Hardware\ACPI\<TableSig>\<OEMID>\<TableID>\<TableRev>
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseAcpiReg(POEMINFO pOemInfo)
{
	LOG_Block("UseAcpiReg");

	static const TCHAR szRSDT[] = _T("Hardware\\ACPI\\DSDT");
	HKEY hKeyTable;
	LONG lRet;
	if (NO_ERROR ==(lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRSDT, 0, MAXIMUM_ALLOWED, &hKeyTable)))
	{
		if (NO_ERROR == (lRet = RegEnumKey(hKeyTable, 0, pOemInfo->szAcpiOem, sizeof(pOemInfo->szAcpiOem)/sizeof(TCHAR))))
		{
			HKEY hKeyOEM;
			if (NO_ERROR == (lRet = RegOpenKeyEx(hKeyTable, pOemInfo->szAcpiOem, 0, MAXIMUM_ALLOWED, &hKeyOEM)))
			{
				if (NO_ERROR == (lRet = RegEnumKey(hKeyOEM, 0, pOemInfo->szAcpiProduct, sizeof(pOemInfo->szAcpiProduct)/sizeof(TCHAR))))
				{
					pOemInfo->dwMask |= OEMINFO_ACPI_PRESENT;
					LOG_Driver(_T("Set OEMINFO_ACPI_PRESENT bit"));
				}
				else
				{
					LOG_Error(_T("RegEnumKey:"));
					LOG_ErrorMsg(lRet);
				}
				RegCloseKey(hKeyOEM);
			}
			else
			{
				LOG_Error(_T("RegOpenKeyEx:"));
				LOG_ErrorMsg(lRet);
			}
		}
		else
		{
			LOG_Error(_T("RegEnumKey:"));
			LOG_ErrorMsg(lRet);
		}
		RegCloseKey(hKeyTable);
	}
	else
	{
		LOG_Error(_T("RegOpenKeyEx:"));
		LOG_ErrorMsg(lRet);
	}
}

/*** UseWBEM - Get info through WBEM access
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */

void UseWBEM(POEMINFO pOemInfo)
{
	LOG_Block("UseWBEM");

	USES_IU_CONVERSION;

	IWbemLocator* pWbemLocator = NULL;
	IWbemServices* pWbemServices = NULL;
	IEnumWbemClassObject* pEnum = NULL;
	IWbemClassObject* pObject = NULL;
	BSTR bstrNetworkResource = NULL;
	BSTR bstrComputerSystem = NULL;
	VARIANT var;
	VariantInit(&var);
	HRESULT hr;

	if (NULL == pOemInfo)
		return;

	// Create Locator
	if (FAILED(hr =  CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, __uuidof(IWbemLocator), (LPVOID*) &pWbemLocator)))
	{
		LOG_Error(_T("CoCreateInstance returned 0x%08x in UseWBEM"), hr);
		goto CleanUp;
	}
	
	// Get services
	if (bstrNetworkResource = SysAllocString(L"\\\\.\\root\\cimv2"))
	{
		if (FAILED(pWbemLocator->ConnectServer(bstrNetworkResource, NULL, NULL, 0L, 0L, NULL, NULL, &pWbemServices)))
		{
			LOG_Error(_T("pWbemLocator->ConnectServer returned 0x%08x in UseWBEM"), hr);
			goto CleanUp;
		}
		if (FAILED(hr = CoSetProxyBlanket(pWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
					   RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE)))
		{
			LOG_Error(_T("CoSetProxyBlanket returned 0x%08x in UseWBEM"), hr);
			goto CleanUp;
		}

		// Create enumerator
		if (bstrComputerSystem = SysAllocString(L"Win32_ComputerSystem"))
		{
			if (FAILED(hr = pWbemServices->CreateInstanceEnum(bstrComputerSystem, 0, NULL, &pEnum)))
			{
				goto CleanUp;
			}
			if (FAILED(CoSetProxyBlanket(pEnum, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
						   RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE)))
			{
				goto CleanUp;
			}

			// Get our object now
			ULONG uReturned = 1;
			hr = pEnum->Next(
					6000,           // timeout in six seconds
					1,              // return just one storage device
					&pObject,		// pointer to storage device
					&uReturned);	// number obtained: one or zero
			//
			// 569939 Need to verify IEnumWbemClassObject::Next uReturned value
			//
			if (FAILED(hr) || 0 == uReturned || NULL == pObject)
			{
				goto CleanUp;
			}


			if (FAILED(hr = pObject->Get(L"Manufacturer", 0L, &var, NULL, NULL)))
			{
				goto CleanUp;
			}

			if (VT_BSTR == var.vt)
			{
				lstrcpyn(pOemInfo->szWbemOem, OLE2T(var.bstrVal), ARRAYSIZE(pOemInfo->szWbemOem));
			}

			//
			// 569968  Call VariantClear before line 549 to prevent leak of BSTR
			//
			VariantClear(&var);

			if (FAILED(hr = pObject->Get(L"Model", 0L, &var, NULL, NULL)))
			{
				goto CleanUp;
			}

			if (VT_BSTR == var.vt) 
			{
				lstrcpyn(pOemInfo->szWbemProduct, OLE2T(var.bstrVal), ARRAYSIZE(pOemInfo->szWbemProduct));
			}

			if (0 != lstrlen(pOemInfo->szWbemOem) || 0 != lstrlen(pOemInfo->szWbemProduct))
			{
				pOemInfo->dwMask |= OEMINFO_WBEM_PRESENT;
				LOG_Driver(_T("Set OEMINFO_WBEM_PRESENT"));
			}
		}
		else
		{
			LOG_Error(_T("SysAllocString failed in UseWBEM"));
		}
	}

CleanUp:
		SafeReleaseNULL(pWbemLocator);

		SafeReleaseNULL(pWbemServices);

		SafeReleaseNULL(pEnum);

		SafeReleaseNULL(pObject);

		SysFreeString(bstrNetworkResource);

		SysFreeString(bstrComputerSystem);

		if (VT_EMPTY != var.vt)
			VariantClear(&var);
	return;
}

/*** Calls to wubios.vxd
 */
class CWubiosVxD
{
public:
	bool Init(HMODULE hModuleGlobal);
	PBYTE GetAcpiTable(DWORD dwTabSig);
	PBYTE GetSmbTable(DWORD dwTableType);
	DWORD GetPnpOemId();

	CWubiosVxD();
	~CWubiosVxD();

private:
	HANDLE m_hVxD;
	TCHAR m_szVxdPath[MAX_PATH + 1];
};

CWubiosVxD::CWubiosVxD()
{
	LOG_Block("CWubiosVxD::CWubiosVxD");

	m_hVxD = INVALID_HANDLE_VALUE;
	m_szVxdPath[0] = _T('\0');
}

CWubiosVxD::~CWubiosVxD()
{
	LOG_Block("CWubiosVxD::~CWubiosVxD");

	if	(INVALID_HANDLE_VALUE != m_hVxD)
	{
		CloseHandle(m_hVxD);
	}

	if (0 != lstrlen(m_szVxdPath))
	{
		DeleteFile(m_szVxdPath);
	}
}


/***LP  CWubiosVxD::Init - Loads VxD
 *
 *  ENTRY
 *      none
 *
 *  EXIT
 *      path
 */
bool CWubiosVxD::Init(HMODULE hModuleGlobal)
{
	LOG_Block("CWubiosVxD::Init");

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
	return false;
#else
	bool fRet = false;
	HMODULE hModule = NULL;
	HRSRC hrscVxd = 0;
	HGLOBAL hRes = 0;
	PBYTE pImage = NULL;
	DWORD dwResSize = 0;
	DWORD dwWritten = 0;
	DWORD dwVersion = ~WUBIOS_VERSION;
	HANDLE hfile = INVALID_HANDLE_VALUE;
	TCHAR szMyFileName[MAX_PATH + 1];

	HRESULT hr=S_OK;
	// Init
	if (0 == GetSystemDirectory(m_szVxdPath, ARRAYSIZE(m_szVxdPath)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	
	hr=PathCchAppend(m_szVxdPath,ARRAYSIZE(m_szVxdPath),_T("\\wubios.vxd"));
	if(FAILED(hr))
	{
		LOG_ErrorMsg(HRESULT_CODE(hr));
		goto CleanUp;
	}


	if (0 == GetModuleFileName(hModuleGlobal, szMyFileName, ARRAYSIZE(szMyFileName)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	hModule = LoadLibraryEx(szMyFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
	if (INVALID_HANDLE_VALUE == hModule)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	// Get Vxd from resource and save it
	hrscVxd = FindResource(hModule, _T("WUBIOS"), RT_VXD);			
	if (0 == hrscVxd)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (0 == (hRes = LoadResource(hModule, hrscVxd)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	pImage = (PBYTE) LockResource(hRes);
	if (NULL == pImage)
	{
		LOG_Error(_T("LockResource failed"));
		goto CleanUp;
	}

	dwResSize = SizeofResource(hModule, hrscVxd);
	if (0 == dwResSize)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	hfile = CreateFile(m_szVxdPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE == hfile)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}
	else
	{
		LOG_Driver(_T("Success: CreateFile \"%s\""), m_szVxdPath);
	}

	if (0 == WriteFile(hfile, pImage, dwResSize, &dwWritten, NULL))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (0 == CloseHandle(hfile))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}
	hfile = INVALID_HANDLE_VALUE;

	if (dwWritten != dwResSize)
	{
		LOG_Error(_T("WriteFile wrote %d bytes to \"%s\", should be %d"), dwWritten, m_szVxdPath, dwResSize);
		goto CleanUp;
	}

	// Load Vxd
	if (INVALID_HANDLE_VALUE != (m_hVxD = CreateFile(WUBIOS_VXD_NAME, 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL)))
	{
		// Check version
		if (DeviceIoControl(m_hVxD, WUBIOCTL_GET_VERSION, NULL, 0, &dwVersion, sizeof(dwVersion), NULL, NULL))
		{
			if (dwVersion == WUBIOS_VERSION)
			{
				fRet = true;
			}
			else
			{
				LOG_Error(_T("Wrong VxD Version"));
				CloseHandle(m_hVxD);
				m_hVxD = INVALID_HANDLE_VALUE;
				goto CleanUp;
			}
		}
		else
		{
			LOG_ErrorMsg(GetLastError());
			goto CleanUp;
		}
	}
	else
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hfile)
		CloseHandle(hfile);

	if (hModule)
		FreeLibrary(hModule);

	return fRet;
#endif	// NUKE_VXD
}

/***LP CWubiosVxD::GetAcpiTable - Get table
 *
 *  ENTRY
 *      m_hVxD - VxD handle
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */
PBYTE CWubiosVxD::GetAcpiTable(DWORD dwTabSig)
{
	LOG_Block("CWubiosVxD::GetAcpiTable");

	PBYTE pb = NULL;

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
#else

	ACPITABINFO TabInfo;
	TabInfo.dwTabSig = dwTabSig;

	if (INVALID_HANDLE_VALUE == m_hVxD)
	{
		LOG_Error(_T("INVALID_HANDLE_VALUE == m_hVxD"));
		return NULL;
	}

	if (DeviceIoControl(m_hVxD, WUBIOCTL_GET_ACPI_TABINFO, NULL, 0, &TabInfo, sizeof(TabInfo), NULL, NULL))
	{
		if (pb = (PBYTE) HeapAlloc(GetProcessHeap(), 0, TabInfo.dh.Length))
		{
			if (0 == DeviceIoControl(m_hVxD, WUBIOCTL_GET_ACPI_TABLE,
				(PVOID)TabInfo.dwPhyAddr, 0, pb,TabInfo.dh.Length, NULL, NULL))
			{
				SafeHeapFree(pb);
				LOG_Error(_T("Second DeviceIoControl:"));
				LOG_ErrorMsg(GetLastError());
				return NULL;
			}
		}
		else
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
		}
	}
	else
	{
		LOG_Error(_T("First DeviceIoControl:"));
		LOG_ErrorMsg(GetLastError());
	}
#endif	// NUKE_VXD

	return pb;
}//GetAcpiTable

/***LP  CWubiosVxD::GetSmbTable - Get table
 *
 *  ENTRY
 *		dwTableType - table type
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */
PBYTE CWubiosVxD::GetSmbTable(DWORD dwTableType)
{
	LOG_Block("CWubiosVxD::GetSmbTable");

	PBYTE pb = NULL;

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
#else
	
	if (INVALID_HANDLE_VALUE == m_hVxD)
	{
		LOG_Error(_T("m_hVxD invalid"));
		return NULL;
	}

	DWORD dwMaxSize = 0;
	if (DeviceIoControl(m_hVxD, WUBIOCTL_GET_SMB_STRUCTSIZE, NULL, 0, &dwMaxSize, sizeof(dwMaxSize), NULL, NULL) && dwMaxSize)
	{
		if (pb = (PBYTE) HeapAlloc(GetProcessHeap(), 0, dwMaxSize))
		{
			if (0 == DeviceIoControl(m_hVxD, WUBIOCTL_GET_SMB_STRUCT,
				(PVOID)dwTableType, 0, pb, dwMaxSize, NULL, NULL))
			{
				SafeHeapFree(pb);
				LOG_Error(_T("Second DeviceIoControl:"));
				LOG_ErrorMsg(GetLastError());
				return NULL;
			}
		}
		else
		{
			LOG_Error(_T("HeapAlloc failed"));
		}
	}
	else
	{
		LOG_Error(_T("First DeviceIoControl:"));
		LOG_ErrorMsg(GetLastError());
	}
#endif	// NUKE_VXD

	return pb;
}// GetSmbTable


/***LP  CWubiosVxD::GetPnpOemId - Do it
 *
 *  ENTRY
 *      none
 *
 *  EXIT
 *      path
 */
DWORD CWubiosVxD::GetPnpOemId()
{
	LOG_Block("CWubiosVxD::GetPnpOemId");

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
	return 0;
#else

	// PnP last
	DWORD dwOemId = 0;
	if (INVALID_HANDLE_VALUE == m_hVxD)
	{
		LOG_Error(_T("m_hVxD invalid"));
		return 0;
	}

	if (0 == DeviceIoControl(m_hVxD, WUBIOCTL_GET_PNP_OEMID, NULL, 0, 
		&dwOemId, sizeof(dwOemId), NULL, NULL))
	{
		// make sure it didn't mess with the size on error
		dwOemId = 0;
		LOG_Error(_T("DeviceIoControl:"));
		LOG_ErrorMsg(GetLastError());
	}

	return dwOemId;
#endif	// NUKE_VXD
}

/*** UseVxD - Get bios info from it
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseVxD(POEMINFO pOemInfo)
{

	HRESULT hr=S_OK;

	LOG_Block("CWubiosVxD::UseVxD");

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
	return;
#else

	USES_IU_CONVERSION;

	CWubiosVxD vxd;
	if(false == vxd.Init(g_hinst))
		return;

	// ISSUE-2000/10/10-waltw I don't have a machine to test vxd.GetAcpiTable on...
	// ACPI first
	PDESCRIPTION_HEADER pHeader = (PDESCRIPTION_HEADER)vxd.GetAcpiTable(DSDT_SIGNATURE);
	if (NULL != pHeader)
	{
		memcpy(pOemInfo->szAcpiOem, pHeader->OEMID, sizeof(pHeader->OEMID));
		memcpy(pOemInfo->szAcpiProduct, pHeader->OEMTableID, sizeof(pHeader->OEMTableID));
		HeapFree(GetProcessHeap(), 0, pHeader);
		pOemInfo->dwMask |= OEMINFO_ACPI_PRESENT;
		LOG_Driver(_T("Set OEMINFO_ACPI_PRESENT bit"));
	}
	
	// SMBIOS second
	PSMBIOSSYSINFO pTable = (PSMBIOSSYSINFO)vxd.GetSmbTable(SMBIOS_SYSTEM_INFO_TABLE);
	if (NULL != pTable)
	{
		// Search counter
		int cnStrs = max(pTable->bManufacturer, pTable->bProductName);
		char* sz = (char*)pTable + pTable->bLength;
		for (int i = 1; i <= cnStrs && sz; i ++)
		{
			if (pTable->bManufacturer == i)
			{
				
				hr=StringCchCopyEx(pOemInfo->szSmbOem,ARRAYSIZE(pOemInfo->szSmbOem),A2T(sz),NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr))
				{	
					LOG_ErrorMsg(HRESULT_CODE(hr));
					return;
				}

			}
			else if (pTable->bProductName == i)
			{
				
				hr=StringCchCopyEx(pOemInfo->szSmbProduct,ARRAYSIZE(pOemInfo->szSmbProduct),A2T(sz),NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr))
				{
					LOG_ErrorMsg(HRESULT_CODE(hr));
					return;
				}

			}
			sz += strlen(sz) + 1;
		}
		pOemInfo->dwMask |= OEMINFO_SMB_PRESENT;
		SafeHeapFree(pTable);
		LOG_Driver(_T("Set OEMINFO_SMB_PRESENT bit"));
	}

	// ISSUE-2000/10/10-waltw I don't have a machine to test vxd.GetPnpOemId on...
	// PnP last
	pOemInfo->dwPnpOemId = vxd.GetPnpOemId();
	if (pOemInfo->dwPnpOemId != 0)
	{
		pOemInfo->dwMask |= OEMINFO_PNP_PRESENT;
		LOG_Driver(_T("Set OEMINFO_PNP_PRESENT bit"));
	}		
#endif	// NUKE_VXD
}


/*** ReadFromReg - read OEMINFO from registry
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      true if info is present
 *		false otherwise
 */
bool ReadFromReg(POEMINFO pOemInfo)
{
	LOG_Block("ReadFromReg");

	DWORD dwVersion = 0;
	bool  fReturn = false;
	bool  fRegKeyOpened = false;
	LONG lReg;
	//read registry first
	HKEY hKeyOemInfo;
	HRESULT hr;
	int cchValueSize;

	if (NULL == pOemInfo)
	{
		return false;
	}

	if	(NO_ERROR == (lReg = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO, 0, KEY_READ, &hKeyOemInfo)))
	{
		fRegKeyOpened = true;
		DWORD dwCount = sizeof(pOemInfo->dwMask);
		if (ERROR_SUCCESS != RegQueryValueEx(hKeyOemInfo, REGSTR_VAL_MASK, 0, 0, (LPBYTE)&(pOemInfo->dwMask), &dwCount))
		{
			goto CleanUp;
		}
		//
		// ***** WU Bug# 11921 *****
		//
		
		//
		//	No bits set requires detection
		//
		if(!pOemInfo->dwMask)
		{
			LOG_Error(_T("No pOemInfo->dwMask bits set in ReadFromReg"));
			goto CleanUp;
		}

		//
		//	If an older version of the detection wrote the OemInfo return false to force detection.
		//	This value is written starting with 1 around August 2000 for the Classic control.
		//
		dwCount = sizeof(dwVersion);
		if (NO_ERROR == (lReg = RegQueryValueEx(hKeyOemInfo, REGSTR_VAL_OEMINFO_VER, 0, 0, (LPBYTE)&dwVersion, &dwCount)))
		{
			if(REG_CURRENT_OEM_VER > dwVersion)
			{
				LOG_Error(_T("REG_CURRENT_OEM_VER > %lu in Registry"), dwVersion);
				goto CleanUp;
			}
		}
		else
		{
			Win32MsgSetHrGotoCleanup(lReg);
		}

		//
		// ***** end WU Bug *****
		//

		if (pOemInfo->dwMask & OEMINFO_ACPI_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szAcpiOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_ACPIOEM, pOemInfo->szAcpiOem, cchValueSize, &cchValueSize));

			cchValueSize = ARRAYSIZE(pOemInfo->szAcpiProduct);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_ACPIPRODUCT, pOemInfo->szAcpiProduct, cchValueSize, &cchValueSize));
		}
		if (pOemInfo->dwMask & OEMINFO_SMB_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szSmbOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_SMBOEM, pOemInfo->szSmbOem, cchValueSize, &cchValueSize));

			cchValueSize = ARRAYSIZE(pOemInfo->szSmbProduct);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_SMBPRODUCT, pOemInfo->szSmbProduct, cchValueSize, &cchValueSize));
		}
		if (pOemInfo->dwMask & OEMINFO_PNP_PRESENT)
		{
			dwCount = sizeof(pOemInfo->dwPnpOemId);	
			if (NO_ERROR != (lReg = RegQueryValueEx(hKeyOemInfo, REGSTR_VAL_PNPOEMID, 0, 0, (LPBYTE)&(pOemInfo->dwPnpOemId), &dwCount)))
				goto CleanUp;
		}
		if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szIniOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_INIOEM, pOemInfo->szIniOem, cchValueSize, &cchValueSize));
		}
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szWbemOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_WBEMOEM, pOemInfo->szWbemOem, cchValueSize, &cchValueSize));

			cchValueSize = ARRAYSIZE(pOemInfo->szWbemProduct);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_WBEMPRODUCT, pOemInfo->szWbemProduct, cchValueSize, &cchValueSize));
		}
		//
		// Always try to get the OEM Support URL, but don't bail if we don't have it.
		//
		cchValueSize = ARRAYSIZE(pOemInfo->szIniOemSupportUrl);	
		(void) SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_SUPPORTURL, pOemInfo->szIniOemSupportUrl, cchValueSize, &cchValueSize);
		//
		// We got everything we had a dwMask bit set for - drop through to CleanUp
		//
		fReturn = true;
	}
	else
	{
		LOG_ErrorMsg(lReg);
		goto CleanUp;
	}

CleanUp:

	if (true == fRegKeyOpened)
	{
		RegCloseKey(hKeyOemInfo);
	}

	return fReturn;
}

/*** SaveToReg - Save OEMINFO
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      none
 */
void SaveToReg(POEMINFO pOemInfo)
{
	LOG_Block("SaveToReg");

	DWORD dwDisp;
	DWORD dwVersion = REG_CURRENT_OEM_VER;
	LONG lReg;
	HKEY hKey;
	//
	// Nuke the existing key (it has no subkeys)
	//

	if (NO_ERROR != (lReg = RegDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO)))
	{
		//
		// Log error but don't bail - it may not have existed before
		//
		LOG_Driver(_T("Optional RegDeleteKey:"));
		LOG_ErrorMsg(lReg);
	}

	if	(NO_ERROR == (lReg = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO, 0, NULL, 
		REG_OPTION_NON_VOLATILE, KEY_WRITE, 0, &hKey, &dwDisp)))
	{
		//
		// Ignore errors from RegSetValueEx - we check for errors in ReadFromReg
		//
		RegSetValueEx(hKey, REGSTR_VAL_MASK, 0, REG_DWORD, (LPBYTE)&(pOemInfo->dwMask), sizeof(pOemInfo->dwMask));

		//
		//	Write the current version so future controls can check version of detection that wrote this key.
		//	WU RAID # 11921
		//
		RegSetValueEx(hKey, REGSTR_VAL_OEMINFO_VER, 0, REG_DWORD, (LPBYTE)&dwVersion, sizeof(dwVersion));

		if (pOemInfo->dwMask & OEMINFO_ACPI_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_ACPIOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szAcpiOem), (lstrlen(pOemInfo->szAcpiOem) + 1) * sizeof(TCHAR));
			RegSetValueEx(hKey, REGSTR_VAL_ACPIPRODUCT, 0, REG_SZ, (LPBYTE)&(pOemInfo->szAcpiProduct), (lstrlen(pOemInfo->szAcpiProduct) + 1) * sizeof(TCHAR));
		}
		if (pOemInfo->dwMask & OEMINFO_SMB_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_SMBOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szSmbOem), (lstrlen(pOemInfo->szSmbOem) + 1) * sizeof(TCHAR));
			RegSetValueEx(hKey, REGSTR_VAL_SMBPRODUCT, 0, REG_SZ, (LPBYTE)&(pOemInfo->szSmbProduct), (lstrlen(pOemInfo->szSmbProduct) + 1) * sizeof(TCHAR));
		}
		if (pOemInfo->dwMask & OEMINFO_PNP_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_PNPOEMID, 0, REG_DWORD, (LPBYTE)&(pOemInfo->dwPnpOemId), sizeof(pOemInfo->dwPnpOemId));
		}
		if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_INIOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szIniOem), (lstrlen(pOemInfo->szIniOem) + 1) * sizeof(TCHAR));
		}
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_WBEMOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szWbemOem), (lstrlen(pOemInfo->szWbemOem) + 1) * sizeof(TCHAR));
			RegSetValueEx(hKey, REGSTR_VAL_WBEMPRODUCT, 0, REG_SZ, (LPBYTE)&(pOemInfo->szWbemProduct), (lstrlen(pOemInfo->szWbemProduct) + 1) * sizeof(TCHAR));
		}
		//
		// Always save REGSTR_VAL_SUPPORTURL if we have it
		//
		int nUrlLen = lstrlen(pOemInfo->szIniOemSupportUrl);
		if (0 < nUrlLen)
		{
			RegSetValueEx(hKey, REGSTR_VAL_SUPPORTURL, 0, REG_SZ, (LPBYTE)&(pOemInfo->szIniOemSupportUrl), (nUrlLen + 1) * sizeof(TCHAR));
		}

		RegCloseKey(hKey);
	}
	else
	{
		LOG_Error(_T("RegCreateKeyEx returned 0x%08x in SaveToReg"), lReg);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\detect\osdet.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   osdet.cpp
//
//  Description:
//
//      Ported to lib from V3 SLM DLL sources
//
//=======================================================================

#include <windows.h>
#include <wuiutest.h>
#include <tchar.h>
#include <osdet.h>
#include <logging.h>
#include <iucommon.h>
#include "wusafefn.h"
#include<MISTSAFE.h>

// Forwared Declarations
static LANGID CorrectGetSystemDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95);
static LANGID CorrectGetUserDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95);
static WORD CorrectGetACP(void);
static WORD CorrectGetOEMCP(void);
static LANGID MapLangID(LANGID langid);
static bool FIsNECMachine();
static int aton(LPCTSTR ptr);
static int atoh(LPCTSTR ptr);


//
// Constants and defines
//
const LANGID LANGID_ENGLISH         = MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);            // 0x0409
const LANGID LANGID_GREEK           = MAKELANGID(LANG_GREEK, SUBLANG_DEFAULT);              // 0x0408
const LANGID LANGID_JAPANESE        = MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);           // 0x0411

const LANGID LANGID_ARABIC          = MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA); // 0x0401
const LANGID LANGID_HEBREW          = MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT);             // 0x040D
const LANGID LANGID_THAI            = MAKELANGID(LANG_THAI, SUBLANG_DEFAULT);               // 0x041E


const TCHAR Win98_REGPATH_MACHLCID[]    = _T("Control Panel\\Desktop\\ResourceLocale");
const TCHAR REGPATH_CODEPAGE[]          = _T("SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage");
const TCHAR REGKEY_OEMCP[]              = _T("OEMCP");
const TCHAR REGKEY_ACP[]                = _T("ACP");
const TCHAR REGKEY_LOCALE[]             = _T("Locale");
const TCHAR REGKEY_IE[]                 = _T("Software\\Microsoft\\Internet Explorer");
const TCHAR REGKEY_VERSION[]            = _T("Version");
const TCHAR REGKEY_CP_INTERNATIONAL[]   = _T(".DEFAULT\\Control Panel\\International");
const TCHAR REGKEY_CP_RESOURCELOCAL[]   = _T("Control Panel\\Desktop\\ResourceLocale");


const TCHAR KERNEL32_DLL[]              = _T("kernel32.dll");

const WORD CODEPAGE_ARABIC          = 1256;
const WORD CODEPAGE_HEBREW          = 1255;
const WORD CODEPAGE_THAI            = 874;
const WORD CODEPAGE_GREEK_MS        = 737;
const WORD CODEPAGE_GREEK_IBM       = 869;

// ISO code for Greek OS's on Windows 98 ONLY.
const TCHAR ISOCODE_GREEK_MS[]      = _T("el_MS");
const TCHAR ISOCODE_GREEK_IBM[]     = _T("el_IBM");
   

// Registry keys to determine NEC machines
const TCHAR NT5_REGPATH_MACHTYPE[]      = _T("HARDWARE\\DESCRIPTION\\System");
const TCHAR NT5_REGKEY_MACHTYPE[]       = _T("Identifier");
const TCHAR REGVAL_MACHTYPE_AT[]        = _T("AT/AT COMPATIBLE");
const TCHAR REGVAL_MACHTYPE_NEC[]       = _T("NEC PC-98");
const TCHAR REGVAL_GREEK_IBM[]          = _T("869");

// Platform strings
const TCHAR SZ_PLAT_WIN95[]     = _T("w95");
const TCHAR SZ_PLAT_WIN98[]     = _T("w98");
const TCHAR SZ_PLAT_WINME[]     = _T("mil");
const TCHAR SZ_PLAT_NT4[]       = _T("NT4");
const TCHAR SZ_PLAT_W2K[]       = _T("W2k");
const TCHAR SZ_PLAT_WHISTLER[]  = _T("Whi");
const TCHAR SZ_PLAT_UNKNOWN[]   = _T("unk");


#define LOOKUP_OEMID(keybdid)     HIBYTE(LOWORD((keybdid)))
#define PC98_KEYBOARD_ID          0x0D

//
// Globals
//

//
// We derive this from WINVER >= 0x0500 section of winnls.h
//
typedef LANGID (WINAPI * PFN_GetUserDefaultUILanguage) (void);
typedef LANGID (WINAPI * PFN_GetSystemDefaultUILanguage) (void);

typedef struct
{
    LANGID  langidUser;
    TCHAR * pszISOCode;

} USER_LANGID;

typedef struct
{
    LANGID  langidMachine;
    TCHAR * pszDefaultISOCode;
    int     cElems;
    const USER_LANGID * grLangidUser;

} MACH_LANGID;


// We give a Japanese NEC machine its own ISO code.
#define LANGID_JAPANESE     0x0411
#define ISOCODE_NEC         _T("nec")
#define ISOCODE_EN          _T("en")
#define grsize(langid) (sizeof(gr##langid) / sizeof(USER_LANGID))

// These are all the user langids associated with a particular machine.

// NTRAID#NTBUG9-220063-2000/12/13-waltw 220063 IU: Specify mappings between GetSystemDefaultUILanguage LANGID and ISO/639/1988
//  From Industry Update XML Schema.doc
//      3.1 Language Codes
//      The languages are defined by ISO 639. They are represented by lowercase 2 letter symbols such as "en" for English, "fr" for French etc.
//
//      3.2 Country Codes
//      The country codes are defined in ISO 3166-1, using the Alpha-2 representation (two letter symbols).
//
//      3.3 Representation in Industry Update
//      Industry Update uses the RFC 1766 standard to manage the representation of language+locale symbols. 
//      3.3.1   Simple Case - Language Alone
//      When no regional flavor is considered for a language, or when it pertains to the "standard" version of the language, such as Portuguese as spoken in Portugal, it uses a straight ISO 639 symbol:
//      en, fr, de
//
//      3.3.2   Regional Variants
//      Managed by the RFCThe lowercase version of the Alpha-2 ISO 3166-1 country (or region) code is hyphenated to the language code, e.g. en-us, en-ca, fr-be, fr-ca, zh-hk, zh-tw


const USER_LANGID gr0404[] = {{0x0804,_T("zh-CN")},{0x1004,_T("zh-CN")}};
const USER_LANGID gr0407[] = {{0x0c07,_T("de-AT")},{0x0807,_T("de-CH")}};
const USER_LANGID gr0409[] = {{0x1c09,_T("en-ZA")},{0x0809,_T("en-GB")},{0x0c09,_T("en-AU")},{0x1009,_T("en-CA")},
                        {0x1409,_T("en-NZ")},{0x1809,_T("en-IE")}};
const USER_LANGID gr040c[] = {{0x080c,_T("fr-BE")},{0x0c0c,_T("fr-CA")},{0x100c,_T("fr-CH")}};
const USER_LANGID gr0410[] = {{0x0810,_T("it-CH")}};
const USER_LANGID gr0413[] = {{0x0813,_T("nl-BE")}};
const USER_LANGID gr0416[] = {{0x0816,_T("pt")}};
const USER_LANGID gr080a[] = {{0x040a,_T("es")},{0x080a,_T("es-MX")},{0x200a,_T("es-VE")},{0x240a,_T("es-CO")},
                        {0x280a,_T("es-PE")},{0x2c0a,_T("es-AR")},{0x300a,_T("es-EC")},{0x340a,_T("es-CL")}};
const USER_LANGID gr0c0a[] = {{0x040a,_T("es")},{0x080a,_T("es-MX")},{0x200a,_T("es-VE")},{0x240a,_T("es-CO")},
                        {0x280a,_T("es-PE")},{0x2c0a,_T("es-AR")},{0x300a,_T("es-EC")},{0x340a,_T("es-CL")}};

// These are all the machine langids.  If there isn't an associated array of user langids, then
// the user langid is irrelevant, and the default ISO language code should be used. If there is
// an associated array of user langids, then it should be searched first and the specific langid used.
// If no match is found in the user langids, then the default langid is used.
const MACH_LANGID grLangids[] = {
    { 0x0401, _T("ar"),     0,              NULL },
    { 0x0403, _T("ca"),     0,              NULL },
    { 0x0404, _T("zh-TW"),  grsize(0404),   gr0404 },
    { 0x0405, _T("cs"),     0,              NULL },
    { 0x0406, _T("da"),     0,              NULL },
    { 0x0407, _T("de"),     grsize(0407),   gr0407 },
    { 0x0408, _T("el"),     0,              NULL },
    { 0x0409, _T("en"),     grsize(0409),   gr0409 },
    { 0x040b, _T("fi"),     0,              NULL },
    { 0x040c, _T("fr"),     grsize(040c),   gr040c },
    { 0x040d, _T("iw"),     0,              NULL },
    { 0x040e, _T("hu"),     0,              NULL },
    { 0x0410, _T("it"),     grsize(0410),   gr0410 },
    { 0x0411, _T("ja"),     0,              NULL },
    { 0x0412, _T("ko"),     0,              NULL },
    { 0x0413, _T("nl"),     grsize(0413),   gr0413 },
    { 0x0414, _T("no"),     0,              NULL },
    { 0x0415, _T("pl"),     0,              NULL },
    { 0x0416, _T("pt-BR"),  grsize(0416),   gr0416 },               
    { 0x0419, _T("ru"),     0,              NULL },
    { 0x041b, _T("sk"),     0,              NULL },
    { 0x041d, _T("sv"),     0,              NULL },
    { 0x041e, _T("th"),     0,              NULL },
    { 0x041f, _T("tr"),     0,              NULL },
    { 0x0424, _T("sl"),     0,              NULL },
    { 0x042d, _T("eu"),     0,              NULL },
    { 0x0804, _T("zh-CN"),  0,              NULL },
    { 0x080a, _T("es"),     grsize(080a),   gr080a },
    { 0x0816, _T("pt"),     0,              NULL },
    { 0x0c0a, _T("es"),     grsize(0c0a),   gr0c0a }
};

#define cLangids (sizeof(grLangids) / sizeof(MACH_LANGID))

static LANGID MapLangID(LANGID langid)
{
    switch (PRIMARYLANGID(langid))
    {
        case LANG_ARABIC:
            langid = MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA);
            break;

        case LANG_CHINESE:
            if (SUBLANGID(langid) != SUBLANG_CHINESE_TRADITIONAL)
                langid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
            break;

        case LANG_DUTCH:
            langid = MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH);
            break;

        case LANG_GERMAN:
            langid = MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN);
            break;

        case LANG_ENGLISH:
            if (SUBLANGID(langid) != SUBLANG_ENGLISH_UK)
                langid = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            break;

        case LANG_FRENCH:
            langid = MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH);
            break;

        case LANG_ITALIAN:
            langid = MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN);
            break;

        case LANG_KOREAN:
            langid = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
            break;

        case LANG_NORWEGIAN:
            langid = MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL);
            break;

        case LANG_PORTUGUESE:
            // We support both SUBLANG_PORTUGUESE and SUBLANG_PORTUGUESE_BRAZILIAN
            break;

        case LANG_SPANISH:
            langid = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH);
            break;

        case LANG_SWEDISH:
            langid = MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH);
            break;
    };
    return langid;
}



// return user language ID
LANGID WINAPI GetUserLangID()
{
    LOG_Block("GetUserLangID");

#ifdef __WUIUTEST
    // language spoofing
    HKEY hKey;
    DWORD dwLangID = 0;
    int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == error)
    {
        DWORD dwSize = sizeof(dwLangID);
        error = RegQueryValueEx(hKey, REGVAL_USER_LANGID, 0, 0, (LPBYTE)&dwLangID, &dwSize);
        RegCloseKey(hKey);
        if (ERROR_SUCCESS == error)
        {
            return (WORD) dwLangID;
        }
    }
#endif

    WORD wCodePage = 0;
    BOOL bIsNT4 = FALSE;
    BOOL bIsW95 = FALSE;
    
    // 
    // get base language id
    //
    LANGID langidCurrent = CorrectGetUserDefaultLangID(bIsNT4, bIsW95);  // Passed by reference

    //
 //     // special handling for languages
 //     //
 //     switch (langidCurrent) 
 //     {
 //         case LANGID_ENGLISH:
 // 
 //             // enabled langauges
 //             wCodePage = CorrectGetACP();
 //             if (CODEPAGE_ARABIC != wCodePage && 
 //                 CODEPAGE_HEBREW != wCodePage && 
 //                 CODEPAGE_THAI != wCodePage)
 //             {
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_GREEK:
 // 
 //             // Greek IBM?
 //             wCodePage = CorrectGetOEMCP();
 //             if (wCodePage != CODEPAGE_GREEK_IBM)
 //             {
 //                 // if its not Greek IBM we assume its MS. The language code for Greek MS does not include
 //                 // the code page
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_JAPANESE:
 // 
 //             if (FIsNECMachine())
 //             {
 //                 wCodePage = 1;  
 //             }
 // 
 //             break;
 //         
 //         default:
 // 
    // map language to the ones we support
    //
    langidCurrent = MapLangID(langidCurrent);   
 //             break;
 //     }

    //
    // Special treatment of NT4 and W95 languages.  
    // On NT4, Enabled Arabic, Thai, and Hebrew systems report as fully localized but we want to map them to Enabled
    // On W95, Enabled Thai is reported as Thai but we want to map to Enabled Thai
    //
    if (bIsNT4)
    {
        // NT4
        switch (langidCurrent) 
        {
            case LANGID_ARABIC:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_HEBREW:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_THAI:
                langidCurrent = LANGID_ENGLISH;
                break;
        }
    }
    else if (bIsW95)
    {
        // W95 - only tweek Thai
        if (langidCurrent == LANGID_THAI)
        {
//          wCodePage = CODEPAGE_THAI;
            langidCurrent = LANGID_ENGLISH;
        }
    }

    LOG_Driver(_T("Returning 0x%04x"), langidCurrent);
    return langidCurrent;
}

// return system language ID
LANGID WINAPI GetSystemLangID()
{
    LOG_Block("GetSystemLangID");

#ifdef __WUIUTEST
    // language spoofing
    HKEY hKey;
    DWORD dwLangID = 0;
    int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == error)
    {
        DWORD dwSize = sizeof(dwLangID);
        error = RegQueryValueEx(hKey, REGVAL_OS_LANGID, 0, 0, (LPBYTE)&dwLangID, &dwSize);
        RegCloseKey(hKey);
        if (ERROR_SUCCESS == error)
        {
            return (WORD) dwLangID;
        }
    }
#endif

    WORD wCodePage = 0;
    BOOL bIsNT4 = FALSE;
    BOOL bIsW95 = FALSE;
    
    // 
    // get base language id
    //
    LANGID langidCurrent = CorrectGetSystemDefaultLangID(bIsNT4, bIsW95);  // Passed by reference

    //
 //     // special handling for languages
 //     //
 //     switch (langidCurrent) 
 //     {
 //         case LANGID_ENGLISH:
 // 
 //             // enabled langauges
 //             wCodePage = CorrectGetACP();
 //             if (CODEPAGE_ARABIC != wCodePage && 
 //                 CODEPAGE_HEBREW != wCodePage && 
 //                 CODEPAGE_THAI != wCodePage)
 //             {
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_GREEK:
 // 
 //             // Greek IBM?
 //             wCodePage = CorrectGetOEMCP();
 //             if (wCodePage != CODEPAGE_GREEK_IBM)
 //             {
 //                 // if its not Greek IBM we assume its MS. The language code for Greek MS does not include
 //                 // the code page
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_JAPANESE:
 // 
 //             if (FIsNECMachine())
 //             {
 //                 wCodePage = 1;  
 //             }
 // 
 //             break;
 //         
 //         default:
 // 
    // map language to the ones we support
    //
    langidCurrent = MapLangID(langidCurrent);   
 //             break;
 //     }

    //
    // Special treatment of NT4 and W95 languages.  
    // On NT4, Enabled Arabic, Thai, and Hebrew systems report as fully localized but we want to map them to Enabled
    // On W95, Enabled Thai is reported as Thai but we want to map to Enabled Thai
    //
    if (bIsNT4)
    {
        // NT4
        switch (langidCurrent) 
        {
            case LANGID_ARABIC:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_HEBREW:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_THAI:
                langidCurrent = LANGID_ENGLISH;
                break;
        }
    }
    else if (bIsW95)
    {
        // W95
        if (langidCurrent == LANGID_THAI)
        {
//          wCodePage = CODEPAGE_THAI;
            langidCurrent = LANGID_ENGLISH;
        }
    }

    LOG_Driver(_T("Returning 0x%04x"), langidCurrent);
    return langidCurrent;
}


HRESULT WINAPI DetectClientIUPlatform(PIU_PLATFORM_INFO pIuPlatformInfo)
{
    LOG_Block("DetectClientIUPlatform");
    HRESULT hr = S_OK;

    if (!pIuPlatformInfo)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    ZeroMemory(pIuPlatformInfo, sizeof(IU_PLATFORM_INFO));

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( !GetVersionEx(&osverinfo) )
    {
        LOG_ErrorMsg(GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

#ifdef __WUIUTEST
    // platform spoofing
    HKEY hKey;
    int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == error)
    {
        DWORD dwSize = sizeof(DWORD);
        RegQueryValueEx(hKey, REGVAL_MAJORVER, 0, 0, (LPBYTE)&osverinfo.dwMajorVersion, &dwSize);
        RegQueryValueEx(hKey, REGVAL_MINORVER, 0, 0, (LPBYTE)&osverinfo.dwMinorVersion, &dwSize);
        RegQueryValueEx(hKey, REGVAL_BLDNUMBER, 0, 0, (LPBYTE)&osverinfo.dwBuildNumber, &dwSize);
        RegQueryValueEx(hKey, REGVAL_PLATFORMID, 0, 0, (LPBYTE)&osverinfo.dwPlatformId, &dwSize);
        int cchValueSize;
        (void) SafeRegQueryStringValueCch(hKey, REGVAL_SZCSDVER, osverinfo.szCSDVersion, ARRAYSIZE(osverinfo.szCSDVersion), &cchValueSize);

        RegCloseKey(hKey);
    }
#endif

    if ( VER_PLATFORM_WIN32_WINDOWS == osverinfo.dwPlatformId 
        || ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 > osverinfo.dwMajorVersion ) )
    {
        //
        // We're on a Win9x platform or NT < 5.0 (Win2K) - just copy OSVERSIONINFO
        //
        memcpy(&pIuPlatformInfo->osVersionInfoEx, &osverinfo, sizeof(OSVERSIONINFO));
        //
        // For Win9x platforms, remove redundant Major/Minor info from high word of build
        //
        if (VER_PLATFORM_WIN32_WINDOWS == osverinfo.dwPlatformId)
        {
            pIuPlatformInfo->osVersionInfoEx.dwBuildNumber = (0x0000FFFF & pIuPlatformInfo->osVersionInfoEx.dwBuildNumber);
        }
    }
    else
    {
        //
        //  We're on Win2K or greater, get and copy OSVERSIONINFOEX
        //
        OSVERSIONINFOEX osverinfoex;
        osverinfoex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        if ( !GetVersionEx((OSVERSIONINFO*)&osverinfoex) )
        {
            LOG_ErrorMsg(GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }
        memcpy(&pIuPlatformInfo->osVersionInfoEx, &osverinfoex, sizeof(OSVERSIONINFOEX));
    }
    //
    // Fill in the OEM BSTRs
    //
    if (FAILED(hr = GetOemBstrs(pIuPlatformInfo->bstrOEMManufacturer, pIuPlatformInfo->bstrOEMModel, pIuPlatformInfo->bstrOEMSupportURL)))
    {
        goto FreeBSTRsAndReturnError;
    }

    //
    // Fill in pIuPlatformInfo->fIsAdministrator
    //
    pIuPlatformInfo->fIsAdministrator = IsAdministrator();

    return S_OK;

FreeBSTRsAndReturnError:

    SafeSysFreeString(pIuPlatformInfo->bstrOEMManufacturer);
    SafeSysFreeString(pIuPlatformInfo->bstrOEMModel);
    SafeSysFreeString(pIuPlatformInfo->bstrOEMSupportURL);

    return hr;
}



static int atoh(LPCTSTR ptr)
{
    int     i = 0;

    //skip 0x if present
    if ( ptr[0] == '0' && (ptr[1] == 'x' || ptr[1] == 'X') )
        ptr += 2;

    for(;;) // until break
    {
        TCHAR ch = *ptr;

        if ('0' <= ch && ch <= '9')
            ch -= '0';
        else if ('a' <= ch && ch <= 'f')
            ch -= ('a' - 10);
        else if ('A' <= ch && ch <= 'F')
            ch -= ('A' - 10);
        else
            break;
        i = 16 * i + (int)ch;
        ptr++;
    }
    return i;
}


static int aton(LPCTSTR ptr)
{
    int i = 0;
    while ('0' <= *ptr && *ptr <= '9')
    {
        i = 10 * i + (int)(*ptr - '0');
        ptr ++;
    }
    return i;
}


static LANGID CorrectGetSystemDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95)
{
    LOG_Block("CorrectGetSystemDefaultLangID");
    LANGID langidMachine = LANGID_ENGLISH; // default is english 

    bIsNT4 = FALSE;
    bIsW95 = FALSE;
    
    TCHAR szMachineLCID[MAX_PATH];

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            //
            if (5 == osverinfo.dwMajorVersion)
            {
                // langidMachine = GetSystemDefaultLangID(); 
                typedef LANGID (WINAPI *PFN_GetSystemDefaultUILanguage)(void);

                //
                //kernel32.dll will  always be loaded in process
                //
                HMODULE hLibModule = GetModuleHandle(KERNEL32_DLL);
                if (hLibModule)
                {
                    PFN_GetSystemDefaultUILanguage fpnGetSystemDefaultUILanguage = 
                        (PFN_GetSystemDefaultUILanguage)GetProcAddress(hLibModule, "GetSystemDefaultUILanguage");
                    if (NULL != fpnGetSystemDefaultUILanguage)
                    { 
                        langidMachine = fpnGetSystemDefaultUILanguage();

                        if (0 == langidMachine)
                        {
                            LOG_Driver(_T("GetSystemDefaultUILanguage() returned 0, setting langidMachine back to LANGID_ENGLISH"));
                            langidMachine = LANGID_ENGLISH;
                        }
                    }
                
                }
            }
            else
            {
                // Get the OS lang from the registry to correct NT4 bug in
                // GetSystemDefaultLangID -- it returns the UI lang and 
                // the UI bits get installed (incorrect) as opposed to the actual OS
                // lang bits.
                HKEY hKey;
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS, REGKEY_CP_INTERNATIONAL, 0, KEY_QUERY_VALUE, &hKey))
                {
                    int cchValueSize = ARRAYSIZE(szMachineLCID);
                    if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, REGKEY_LOCALE, szMachineLCID, cchValueSize, &cchValueSize)))
                    {
                        langidMachine = LANGIDFROMLCID(atoh(szMachineLCID));
                    }
                    else
                    {
                        LOG_Driver(_T("Failed to get langid from \"Locale\" registry value - defaults to LANGID_ENGLISH"));
                    }
                    RegCloseKey(hKey);  
                }
                else
                {
                    LOG_Driver(_T("Failed to open \"HKCU\\.DEFAULT\\Control Panel\\International\" - defaults to LANGID_ENGLISH"));
                }
            }

            if (osverinfo.dwMajorVersion == 4) // NT 4
            {
                bIsNT4 = TRUE;
            }

        }
        else
        {
            //
            // hack around a problem introduced in Win95 and still existing
            // in Win98 whereby the System Langid is the same as the User Langid.
            // We must look in the registry to get the real value.
            //
            HKEY hKey;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_CP_RESOURCELOCAL, 0, KEY_QUERY_VALUE, &hKey))
            {
                int cchValueSize = ARRAYSIZE(szMachineLCID);
                if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, NULL, szMachineLCID, cchValueSize, &cchValueSize))) 
                {
                    langidMachine = LANGIDFROMLCID(atoh(szMachineLCID));
                }
                else
                {
                    LOG_Driver(_T("Failed to get (Default) from \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
                }
                RegCloseKey(hKey);
            }
            else
            {
                LOG_Driver(_T("Failed to open \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
            }


            if ((osverinfo.dwMajorVersion == 4) && (osverinfo.dwMinorVersion <= 0)) // Windows 95
            {
                bIsW95 = TRUE;
            }

        }
    }

    return langidMachine;
}

static LANGID CorrectGetUserDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95)
{
    LOG_Block("CorrectGetUserDefaultLangID");
    LANGID langidMachine = LANGID_ENGLISH; // default is english 

    bIsNT4 = FALSE;
    bIsW95 = FALSE;
    TCHAR szMachineLCID[MAX_PATH];
    
    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            //
            // We shouldn't be using this function from NT, so just default to LANGID_ENGLISH
            // and log a message. This function will hopefully go away when we port to downlevel OS's
            //
            LOG_ErrorMsg(E_INVALIDARG);
        }
        else
        {
            //
            // hack around a problem introduced in Win95 and still existing
            // in Win98 whereby the System Langid is the same as the User Langid.
            // We must look in the registry to get the real value.
            //
            HKEY hKey;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_CP_INTERNATIONAL, 0, KEY_QUERY_VALUE, &hKey))
            {
                int cchValueSize = ARRAYSIZE(szMachineLCID);
                if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, NULL, szMachineLCID, cchValueSize, &cchValueSize)))
                {
                    langidMachine = LANGIDFROMLCID(atoh(szMachineLCID));
                }
                else
                {
                    LOG_Driver(_T("Failed to get (Default) from \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
                }
                RegCloseKey(hKey);
            }
            else
            {
                LOG_Driver(_T("Failed to open \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
            }


            if ((osverinfo.dwMajorVersion == 4) && (osverinfo.dwMinorVersion <= 0)) // Windows 95
            {
                bIsW95 = TRUE;
            }

        }
    }

    return langidMachine;
}


static WORD CorrectGetACP(void)
{
    LOG_Block("CorrectGetACP");
    WORD wCodePage = 0;
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hKey))
    {
        TCHAR szCodePage[MAX_PATH];
        int cchValueSize = ARRAYSIZE(szCodePage);
        if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, REGKEY_ACP, szCodePage, cchValueSize, &cchValueSize)))
        {
            wCodePage = (WORD)aton(szCodePage);
        }
        else
        {
            LOG_Driver(_T("Failed SafeRegQueryStringValueCch in CorrectGetACP - defaulting to code page 0"));
        }
        RegCloseKey(hKey);
    }
    else
    {
        LOG_Driver(_T("Failed RegOpenKeyEx in CorrectGetACP - defaulting to code page 0"));
    }
    return wCodePage;
}


static WORD CorrectGetOEMCP(void)
{
    LOG_Block("CorrectGetOEMCP");
    WORD wCodePage = 0;
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hKey))
    {
        TCHAR szCodePage[MAX_PATH];
        int cchValueSize = ARRAYSIZE(szCodePage);
        if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, REGKEY_OEMCP, szCodePage, cchValueSize, &cchValueSize)))
        {
            wCodePage = (WORD)aton(szCodePage);
        }
        else
        {
            LOG_Driver(_T("Failed SafeRegQueryStringValueCch in CorrectGetOEMCP - defaulting to code page 0"));
        }
        RegCloseKey(hKey);
    }
    else
    {
        LOG_Driver(_T("Failed RegOpenKeyEx in CorrectGetOEMCP - defaulting to code page 0"));
    }
    return wCodePage;
}


static bool FIsNECMachine()
{
    LOG_Block("FIsNECMachine");
    bool fNEC = false;
    OSVERSIONINFO osverinfo;
    LONG lErr;

    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osverinfo))
    {
        if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            HKEY hKey;
            TCHAR tszMachineType[50];
            int cchValueSize;

            if (ERROR_SUCCESS == (lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 NT5_REGPATH_MACHTYPE,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hKey)))
            {
                cchValueSize = ARRAYSIZE(tszMachineType);
                if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, 
                                        NT5_REGKEY_MACHTYPE, 
                                        tszMachineType,
                                        cchValueSize,
                                        &cchValueSize)))
                {
                    if (lstrcmp(tszMachineType, REGVAL_MACHTYPE_NEC) == 0)
                    {
                        fNEC = true;
                    }
                }
                else
                {
                    LOG_ErrorMsg(lErr);
                    LOG_Driver(_T("Failed SafeRegQueryStringValueCch in FIsNECMachine - defaulting to fNEC = false"));
                }

                RegCloseKey(hKey);
            }
            else
            {
                LOG_ErrorMsg(lErr);
                LOG_Driver(_T("Failed RegOpenKeyEx in FIsNECMachine - defaulting to fNEC = false"));
            }
        }
        else // enOSWin98
        {
            // All NEC machines have NEC keyboards for Win98.  NEC
            // machine detection is based on this.
            if (LOOKUP_OEMID(GetKeyboardType(1)) == PC98_KEYBOARD_ID)
            {
                fNEC = true;
            }
            else
            {
                LOG_Driver(_T("LOOKUP_OEMID(GetKeyboardType(1)) == PC98_KEYBOARD_ID was FALSE: defaulting to fNEC = false"));
            }
        }
    }
    
    return fNEC;
}

//
// NOTES:   If you pass in a NULL pointer you'll get it right back.
//          dwcBuffLen is in characters, not bytes.
//
LPTSTR GetIdentPlatformString(LPTSTR pszPlatformBuff, DWORD dwcBuffLen)
{
    
    HRESULT hr=S_OK;
    LOG_Block("GetIdentPlatformString");

    if (NULL == pszPlatformBuff || 1 > dwcBuffLen)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return pszPlatformBuff;
    }

    LPTSTR szOSNamePtr = (LPTSTR) SZ_PLAT_UNKNOWN;
    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osverinfo))
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
        {
            // ADD CHECK FOR NEPTUNE HERE!!!!!
            if ( osverinfo.dwMinorVersion >= 90) // Millenium
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_WINME;
            }
            else if (osverinfo.dwMinorVersion > 0 && osverinfo.dwMinorVersion < 90) // Windows 98
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_WIN98;
            }
            else  // Windows 95
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_WIN95;
            }
        }
        else // osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT 
        {
            if ( osverinfo.dwMajorVersion == 4 ) // NT 4
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_NT4;
            }
            else if (osverinfo.dwMajorVersion == 5) // NT 5 
            {
                if (0 == osverinfo.dwMinorVersion)
                {
                    szOSNamePtr = (LPTSTR) SZ_PLAT_W2K;
                }
                else if (1 <= osverinfo.dwMinorVersion)
                {
                    szOSNamePtr = (LPTSTR) SZ_PLAT_WHISTLER;
                }
            }
        }
    }

    if(lstrlen(szOSNamePtr) + 1 > (int) dwcBuffLen)
    {
        pszPlatformBuff[0] = 0;
    }
    else
    {
        

        //The length is validated  above. So this function cannot possibly fail
        hr=StringCchCopyEx(pszPlatformBuff,dwcBuffLen,szOSNamePtr,NULL,NULL,MISTSAFE_STRING_FLAGS);
        if(FAILED(hr))
            pszPlatformBuff[0] = 0;
    }
    return pszPlatformBuff;
}

//
// GetIdentLocaleString and related functions ported from Drizzle Utils
//

/////////////////////////////////////////////////////////////////////////////
// DistinguishGreekOSs
//   Append additional code to distinguish the Greek OS version.
//
// Parameters:
//   pszISOCodeOut-
//       Greek-specific ISO code is appended to this parameter.
/////////////////////////////////////////////////////////////////////////////

void DistinguishGreekOSs(const TCHAR*& pszISOCodeOut /* out */)
{
    LOG_Block("DistinguishGreekOSs");
    //
    // Default ISO code to Greek OS (MS).
    //

    pszISOCodeOut = ISOCODE_GREEK_MS;

    
    //
    // Determine from the registry which version of Greek OS. There are
    // two versions of the Greek OS.
    //

    HKEY hKey;
    DWORD type;
    TCHAR tszOSType[50];
    int cchValueSize;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGPATH_CODEPAGE,
                     0,
                     KEY_QUERY_VALUE,
                     &hKey) == ERROR_SUCCESS)
    {
        cchValueSize = ARRAYSIZE(tszOSType);
        if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, 
                            REGKEY_OEMCP, 
                            tszOSType,
                            cchValueSize,
                            &cchValueSize)))
        {
            if (0 == lstrcmp(tszOSType, REGVAL_GREEK_IBM))
            {
                // Greek2
                pszISOCodeOut = ISOCODE_GREEK_IBM;
            }
        }

        RegCloseKey(hKey);
    }

}

/////////////////////////////////////////////////////////////////////////////
// HandleExceptionCases
//   Take care of a few exception cases (i.e. Greek OS).
//
// Parameters:
//   langidMachine-
//       Contains a language id for the current OS.
//
//   pszISOCode-
//       Points to a valid language id string for the current OS.
/////////////////////////////////////////////////////////////////////////////

inline void HandleExceptionCases(const LANGID& langidMachine,   /* in  */
                                 const TCHAR*& pszISOCode       /* out */)
{
    LOG_Block("HandleExceptionCases");

    // NEC machines are treated as having their own langid.
    // See if we have a Japanese machine, then check if it
    // is NEC.
    

    if (LANGID_JAPANESE == langidMachine)
    {

        if (FIsNECMachine())
        {
            pszISOCode = ISOCODE_NEC;
        }

        return;
    }
    

    
    // Windows 98 has two versions of Greek OS distinguished
    // only by a key in the registry.
        
    if(LANGID_GREEK == langidMachine)
    {
        OSVERSIONINFO osverinfo;
        osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (! GetVersionEx(&osverinfo))
        {
            return;
        }
        if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            if (osverinfo.dwMinorVersion > 0) 
            {
                DistinguishGreekOSs(pszISOCode);
            }
            return;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// langidCorrectGetSystemDefaultLangID
//   Make this return what GetSystemDefaultLangID should have returned
//   under Win98.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

LANGID langidCorrectGetSystemDefaultLangID(void)
{
    LOG_Block("langidCorrectGetSystemDefaultLangID");

    LANGID langidMachine = LANGID_ENGLISH; // default is english 
    OSVERSIONINFO osverinfo;


    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            langidMachine = GetSystemDefaultLangID(); 
        }
        else
        {
            //  hack around a problem introduced in Win95 and still existing
            //  in Win98 whereby the System Langid is the same as the User Langid.
            //  We must look in the registry to get the real value.
            
            HKEY hKey;

            // determine if we should log transmissions
            if ( RegOpenKeyEx(  HKEY_CURRENT_USER,
                                 Win98_REGPATH_MACHLCID,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hKey) == ERROR_SUCCESS )
            {
                TCHAR tszMachineLCID[MAX_PATH];
                int cchValueSize = ARRAYSIZE(tszMachineLCID);

                if (FAILED(SafeRegQueryStringValueCch(hKey, 
                                        NULL, 
                                        tszMachineLCID,
                                        cchValueSize,
                                        &cchValueSize)))
                {
                    
                    //The size of tszMachineLCID is much larger than the Source string. So cannot possibly fail
                    if(FAILED(StringCchCopyEx(tszMachineLCID,MAX_PATH,_T("00000409"),NULL,NULL,MISTSAFE_STRING_FLAGS)))
                        return langidMachine;
                }

                // Now convert to hexadecimal.
                langidMachine = LANGIDFROMLCID(atoh(tszMachineLCID));

                RegCloseKey(hKey);
            }
        }
    }

    return langidMachine;
}

//
// NOTES:   If you pass in a NULL pointer you'll get it right back.
//          dwcBuffLen is in characters, not bytes.
//
LPTSTR GetIdentLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen)
{
    LOG_Block("GetIdentLocaleString");
    HRESULT hr=S_OK;

    if (NULL == pszISOCode || 1 > dwcBuffLen)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return pszISOCode;
    }
    // if we don't find any matching machine langids, we go to the english page.
    LPTSTR pszISOCodePtr = ISOCODE_EN;

    // First get the system and user LCID.
    LANGID langidMachine = langidCorrectGetSystemDefaultLangID();

    // First, locate the machine langid in the table.
    for ( int iMachine = 0; iMachine < cLangids; iMachine++ )
    {
        if ( grLangids[iMachine].langidMachine == langidMachine )
        {
            // set the default langid in case we don't find a matching user langid.
            pszISOCodePtr = grLangids[iMachine].pszDefaultISOCode;

            // Found the machine langid, now lookup the user langid
            if ( grLangids[iMachine].cElems != 0 )
            {
                LANGID langidUser = GetUserDefaultLangID();

                // We check for specific user langids
                for ( int iUser = 0; iUser < grLangids[iMachine].cElems; iUser++ )
                {
                    if ( grLangids[iMachine].grLangidUser[iUser].langidUser == langidUser )
                    {
                        pszISOCodePtr = grLangids[iMachine].grLangidUser[iUser].pszISOCode;
                        break;
                    }
                }
            }
            break;
        }
    }

    // Take care of a few exceptions.
//  HandleExceptionCases(langidMachine, pszISOCodePtr);

    if(lstrlen(pszISOCodePtr) + 1 > (int) dwcBuffLen)
    {
        pszISOCode[0] = 0;
    }
    else
    {

        
        hr=StringCchCopyEx(pszISOCode,dwcBuffLen,pszISOCodePtr,NULL,NULL,MISTSAFE_STRING_FLAGS);

        //cannot possibly fail since  length is already validated
        if(FAILED(hr))
        {
            pszISOCode[0] = 0;
        }
    }

    return pszISOCode;
}


BOOL LookupLocaleStringFromLCID(LCID lcid, LPTSTR pszISOCode, DWORD cchISOCode)
{
    LOG_Block("LookupLocaleStringFromLCID");

    TCHAR   szCountry[MAX_PATH];
    BOOL    fRet = FALSE;

    if (GetLocaleInfo(lcid, LOCALE_SISO639LANGNAME,
                      pszISOCode, cchISOCode) == FALSE)
    {
        LOG_ErrorMsg(GetLastError());
        goto done;
    }

    szCountry[0] = _T('-');
    
    if (GetLocaleInfo(lcid, LOCALE_SISO3166CTRYNAME,
                      szCountry + 1, ARRAYSIZE(szCountry) - 1) == FALSE)
    {
        LOG_ErrorMsg(GetLastError());
        goto done;
    }
    else
    {
        HRESULT hr;
        
        hr = StringCchCatEx(pszISOCode, cchISOCode, szCountry,
                            NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            LOG_ErrorMsg(hr);
            pszISOCode[0] = _T('\0');
            goto done;
        }
    }

    fRet = TRUE;

done:
    return fRet;
}


//
// NOTES:   If you pass in a NULL pointer you'll get it right back.
//          dwcBuffLen is in characters, not bytes.
//
LPTSTR LookupLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen, BOOL fIsUser)
{
    LOG_Block("LookupLocaleString");

    TCHAR szCtryName[MAX_PATH];
    LANGID langid = 0;
    LCID lcid = 0;
    PFN_GetUserDefaultUILanguage pfnGetUserDefaultUILanguage = NULL;
    PFN_GetSystemDefaultUILanguage pfnGetSystemDefaultUILanguage = NULL;
    HMODULE hModule = NULL;
    HRESULT hr=S_OK;

    if (NULL == pszISOCode)
    {
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return NULL;
    }
    //
    // If we hit an error, return a "Error" string
    //
    const TCHAR szError[] = _T("Error");

    if (lstrlen(szError) < (int) dwcBuffLen)
    {
        
        hr=StringCchCopyEx(pszISOCode,dwcBuffLen,szError,NULL,NULL,MISTSAFE_STRING_FLAGS);

        //This should not ideally happen
        if(FAILED(hr))
        {
            LOG_ErrorMsg(HRESULT_CODE(hr));
            pszISOCode[0] = 0;
            goto CleanUp;
        }

    }
    else
    {
        pszISOCode[0] = 0;
    }

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT && 5 <= osverinfo.dwMajorVersion)
        {
            //
            // Windows 2000 and greater (Windows XP)
            //
            //kernel32.dll will  always be loaded in process
            //

            hModule = GetModuleHandle(KERNEL32_DLL);
            if (NULL == hModule)
            {
                LOG_ErrorMsg(GetLastError());
                goto CleanUp;
            }

            if (TRUE == fIsUser)
            {
                //
                // We want the MUI language rather than the LOCALE_USER_DEFAULT and we are >= Win2k
                //
                pfnGetUserDefaultUILanguage = (PFN_GetUserDefaultUILanguage) GetProcAddress(hModule, "GetUserDefaultUILanguage");
                if (NULL == pfnGetUserDefaultUILanguage)
                {
                    LOG_ErrorMsg(GetLastError());
                    goto CleanUp;
                }

                langid = pfnGetUserDefaultUILanguage();
                if (0 == langid)
                {
                    LOG_ErrorMsg(E_FAIL);
                    goto CleanUp;
                }

                lcid = MAKELCID(langid, SORT_DEFAULT);
            }
            else
            {
                pfnGetSystemDefaultUILanguage = (PFN_GetSystemDefaultUILanguage) GetProcAddress(hModule, "GetSystemDefaultUILanguage");
                if (NULL == pfnGetSystemDefaultUILanguage)
                {
                    LOG_ErrorMsg(GetLastError());
                    goto CleanUp;
                }

                langid = pfnGetSystemDefaultUILanguage();
                if (0 == langid)
                {
                    LOG_ErrorMsg(E_FAIL);
                    goto CleanUp;
                }

                lcid = MAKELCID(langid, SORT_DEFAULT);
            }

            if (FALSE == fIsUser && FIsNECMachine())
            {
                //
                // 523660 Website is not distinguishing the JA_NEC and JA machine types
                //
                // For context="OS", special case NEC machines and just return "nec" for <language/>
                //
                lstrcpyn(pszISOCode, _T("nec"), (int) dwcBuffLen);
            }
            else
            {
                // don't check for error return because the previous code didn't
                LookupLocaleStringFromLCID(lcid, pszISOCode, dwcBuffLen);
            }

        }
        else
        {
            //
            // Use methods ported from V3 to get local strings
            //

            // if we don't find any matching machine langids, we go to the english page.
            LPTSTR pszISOCodePtr = ISOCODE_EN;

            // First get the system or user LCID.
            LANGID langidMachine = fIsUser ? GetUserLangID() : GetSystemLangID();
            
            // First, locate the machine langid in the table.
            for ( int iMachine = 0; iMachine < cLangids; iMachine++ )
            {
                if ( grLangids[iMachine].langidMachine == langidMachine )
                {
                    // set the default langid in case we don't find a matching user langid.
                    pszISOCodePtr = grLangids[iMachine].pszDefaultISOCode;

                    // Found the machine langid, now lookup the user langid
                    if ( grLangids[iMachine].cElems != 0 )
                    {
                        LANGID langidUser = fIsUser ? GetUserDefaultLangID() : GetSystemDefaultLangID();

                        // We check for specific user langids
                        for ( int iUser = 0; iUser < grLangids[iMachine].cElems; iUser++ )
                        {
                            if ( grLangids[iMachine].grLangidUser[iUser].langidUser == langidUser )
                            {
                                pszISOCodePtr = grLangids[iMachine].grLangidUser[iUser].pszISOCode;
                                break;
                            }
                        }
                    }
                    break;
                }
            }

            // Take care of a few exceptions.
            // HandleExceptionCases(langidMachine, pszISOCodePtr);

            if(lstrlen(pszISOCodePtr) < (int) dwcBuffLen)
            {
                
                hr=StringCchCopyEx(pszISOCode,dwcBuffLen,pszISOCodePtr,NULL,NULL,MISTSAFE_STRING_FLAGS);
                if(FAILED(hr))
                {
                    LOG_ErrorMsg(HRESULT_CODE(hr));
                    pszISOCode[0] = 0;
                    goto CleanUp;

                }
            }
        }
    }
    else
    {
        LOG_ErrorMsg(GetLastError());
    }

CleanUp:
    return pszISOCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\detect\osdetutl.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   osdetutl.cpp
//
//  Description:
//
//      Additional OS detection utility routines for:
//			* Returning free drive space
//			* Returning "Administrator" flag
//
//=======================================================================

#include <windows.h>
#include <oleauto.h>
#include <wuiutest.h>
#include <tchar.h>
#include <osdet.h>
#include <logging.h>
#include <iucommon.h>
#include <stdio.h>	// for _i64tot

// #define __IUENGINE_USES_ATL_
#if defined(__IUENGINE_USES_ATL_)
#include <atlbase.h>
#define USES_IU_CONVERSION USES_CONVERSION
#else
#include <MemUtil.h>
#endif

typedef BOOL (WINAPI * PFN_GetDiskFreeSpaceEx) (LPTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

const TCHAR REGPATH_AU[]			= _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU");
const TCHAR REGKEY_AU_OPTIONS[]		= _T("NoAutoUpdate");
const TCHAR REGPATH_EXPLORER[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
const TCHAR REGKEY_WINUPD_DISABLED[] = _T("NoWindowsUpdate");
const TCHAR REGPATH_POLICY_USERACCESS_DISABLED[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate");
const TCHAR REGKEY_WU_USERACCESS_DISABLED[] = _T("DisableWindowsUpdateAccess");


HRESULT GetLocalFixedDriveInfo(DWORD* pdwNumDrives, PPIU_DRIVEINFO ppDriveInfo)
{
	USES_IU_CONVERSION;
	LOG_Block("GetLocalFixedDriveInfo");

	DWORD dwNumCharacters = 0;
	LPTSTR pszDriveStrBuffer = NULL;
	HRESULT hr = E_FAIL;
	LPTSTR pszRootPathName;

	if (NULL == pdwNumDrives || ppDriveInfo == NULL)
	{
		LOG_Error(_T("E_INVALIDARG"));
		return E_INVALIDARG;
	}

	*ppDriveInfo = NULL;
	*pdwNumDrives = 0;

	//
	// kernel32.dll is loaded into all processes, so we don't need to LoadLibrary, but need to look for W or A versions
	//
	PFN_GetDiskFreeSpaceEx pfnGetDiskFreeSpaceEx;
#if defined(UNICODE) || defined (_UNICODE)
	pfnGetDiskFreeSpaceEx = (PFN_GetDiskFreeSpaceEx) GetProcAddress( GetModuleHandle(L"kernel32.dll"), "GetDiskFreeSpaceExW");
#else
	pfnGetDiskFreeSpaceEx = (PFN_GetDiskFreeSpaceEx) GetProcAddress( GetModuleHandle("kernel32.dll"), "GetDiskFreeSpaceExA");
#endif
	if (NULL == pfnGetDiskFreeSpaceEx)
	{
		//
		// This could fail on Win95 Gold, but we don't support that anyway
		//
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//
	// Handle corner case of race issue when new drives are hot-plugged between the first
	// and second calls to GetLogicalDriveStrings and the buffer requirements increase
	//
	for (;;)
	{
		if (0 == (dwNumCharacters = GetLogicalDriveStrings(0, NULL)))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		//
		// Add space for terminating NULL
		//
		dwNumCharacters += 1;

		CleanUpFailedAllocSetHrMsg(pszDriveStrBuffer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwNumCharacters * sizeof(TCHAR)));

		DWORD dwRet = GetLogicalDriveStrings(dwNumCharacters, pszDriveStrBuffer);
		if (0 == dwRet)
		{
			//
			// Unknown error - we gotta bail
			//
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
		else if (dwRet > dwNumCharacters)
		{
			//
			// Someone plugged in a new drive, get the new buffer space requirements and try again
			//
			SafeHeapFree(pszDriveStrBuffer);
			continue;
		}
		//
		// GetLogicalDriveStrings succeeded, break and continue
		//
		break;
	}

	//
	// Count the number of fixed drives while building the return array of IU_DRIVEINFO
	//
	for (pszRootPathName = pszDriveStrBuffer; NULL != *pszRootPathName; pszRootPathName += lstrlen(pszRootPathName) + 1)
	{
		//
		// Only return sizes for fixed drives
		//
		if (DRIVE_FIXED == GetDriveType(pszRootPathName))
		{
			//
			// Make sure pszRootPathName is of the form "<drive letter>:\" by checking for ':' in second position
			//
			if (_T(':') != pszRootPathName[1])
			{
				LOG_Error(_T("Root paths must be of form \"<drive letter>:\\\""));
				SetHrAndGotoCleanUp(E_FAIL);
			}

			ULARGE_INTEGER i64FreeBytesAvailable;
			ULARGE_INTEGER i64TotalBytes;
			ULARGE_INTEGER i64TotalFreeBytes;
			BOOL fResult;

			//
			// Get the free space
			//
			fResult = pfnGetDiskFreeSpaceEx(pszRootPathName,
											&i64FreeBytesAvailable,
											&i64TotalBytes,
											&i64TotalFreeBytes);

			// Process GetDiskFreeSpaceEx results.
			if (!fResult)
			{
				LOG_Driver(_T("GetDiskFreeSpaceEx(%s, ...) returned an error. We will not report space for this drive"), \
					pszRootPathName);
				LOG_ErrorMsg(GetLastError());
			}
			else
			{
				//
				// We return KiloBytes
				//
				i64FreeBytesAvailable.QuadPart /= 1024;
				
				if (NULL == *ppDriveInfo)
				{
					//
					// Allocate one IU_DRIVEINFO struct
					//
					CleanUpFailedAllocSetHrMsg(*ppDriveInfo = (PIU_DRIVEINFO) HeapAlloc(GetProcessHeap(), 0, sizeof(IU_DRIVEINFO)));
				}
				else
				{
					//
					// Realloc buffer so we can append
					//
					PIU_DRIVEINFO pDriveInfoTemp;
					if (NULL == (pDriveInfoTemp = (PIU_DRIVEINFO) HeapReAlloc(GetProcessHeap(), 0, *ppDriveInfo, ((*pdwNumDrives)+1) * sizeof(IU_DRIVEINFO))))
					{
						LOG_Error(_T("E_OUTOFMEMORY"));
						SetHrAndGotoCleanUp(E_OUTOFMEMORY);
						// Note: *ppDriveInfo still points to previously allocated memory
					}
					*ppDriveInfo = pDriveInfoTemp; // in case it was moved
				}
				//
				// First copy the drive letter
				//
				lstrcpyn(((&(*ppDriveInfo)[*pdwNumDrives]))->szDriveStr, pszRootPathName, 4);
				//
				// Next copy the bytes, but truncate to MAXLONG 
				//
				((&(*ppDriveInfo)[*pdwNumDrives]))->iKBytes = (i64FreeBytesAvailable.QuadPart > 0x000000007FFFFFFF) ? MAXLONG : (INT) i64FreeBytesAvailable.QuadPart;
				//
				// increment drive count
				//
				(*pdwNumDrives)++;
				}
		}
	}

	hr = S_OK;

CleanUp:

	SafeHeapFree(pszDriveStrBuffer);

	if (FAILED(hr))
	{
		SafeHeapFree(*ppDriveInfo);
		*pdwNumDrives = 0;
	}

	return hr;
}

//
// Code adapted from MSDN SearchTokenGroupsForSID since CheckTokenMembership is Win2K only
//
BOOL IsAdministrator(void)
{
	LOG_Block("IsAdministrator");
	return (GetLogonGroupInfo() & IU_SECURITY_MASK_ADMINS);
}

DWORD GetLogonGroupInfo(void)
{
	DWORD dwRet = 0x0;
	LOG_Block("GetLogonGroupInfo");
	DWORD dwSize = 0;
	DWORD i = 0;
	HANDLE hToken = INVALID_HANDLE_VALUE;
	PTOKEN_GROUPS pGroupInfo = NULL;
	PSID pAdminSID = NULL, pPowerUsrSID = NULL;
	SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
	HRESULT hr;	// so we can use CleanUpXxxxx macros

	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (GetVersionEx(&osvi))
	{
		if (VER_PLATFORM_WIN32_NT != osvi.dwPlatformId)
		{
			LOG_Driver(_T("Platform isn't VER_PLATFORM_WIN32_NT - returning TRUE by default"));
			dwRet = IU_SECURITY_MASK_ADMINS | IU_SECURITY_MAST_POWERUSERS;
			LOG_Out(_T("Non NT system, return TRUE for all groups"));
			goto CleanUp;
		}
	}
	else
	{
		LOG_Error(_T("GetVersionEx:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//
	// Open a handle to the access token for the calling process.
	//
	if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
	{
		LOG_Error(_T("OpenProcessToken:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Call GetTokenInformation to get the buffer size.

	if (!GetTokenInformation(hToken, TokenGroups, NULL, dwSize, &dwSize))
	{
		DWORD dwResult = GetLastError();
		if( dwResult != ERROR_INSUFFICIENT_BUFFER )
		{
			LOG_Error(_T("GetTokenInformation:"));
			Win32MsgSetHrGotoCleanup(dwResult);
		}
	}

	// Allocate the buffer.

	if (NULL == (pGroupInfo = (PTOKEN_GROUPS) HeapAlloc(GetProcessHeap(), 0, dwSize)))
	{
		LOG_Error(_T("HeapAlloc"));
		goto CleanUp;
	}

	// Call GetTokenInformation again to get the group information.

	if (! GetTokenInformation(hToken, TokenGroups, pGroupInfo, 
							dwSize, &dwSize ) )
	{
		LOG_Error(_T("GetTokenInformation:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Create a SID for the BUILTIN\Administrators group.

	if (! AllocateAndInitializeSid( &SIDAuth, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_ADMINS,
					 0, 0, 0, 0, 0, 0,
					 &pAdminSID) )
	{
		LOG_Error(_T("AllocateAndInitializeSid:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	if (! AllocateAndInitializeSid( &SIDAuth, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_POWER_USERS,
					 0, 0, 0, 0, 0, 0,
					 &pPowerUsrSID) )
	{
		LOG_Error(_T("AllocateAndInitializeSid:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Loop through the group SIDs looking for the administrator SID.
	
	for(i = 0; i < pGroupInfo->GroupCount; i++)
	{
		if (EqualSid(pAdminSID, pGroupInfo->Groups[i].Sid) && 
			(pGroupInfo->Groups[i].Attributes & SE_GROUP_ENABLED))
		{
			dwRet |= IU_SECURITY_MASK_ADMINS;
		}
		if (EqualSid(pPowerUsrSID, pGroupInfo->Groups[i].Sid) && 
			(pGroupInfo->Groups[i].Attributes & SE_GROUP_ENABLED))
		{
			dwRet |= IU_SECURITY_MAST_POWERUSERS;
		}
	}

CleanUp:

	if (pAdminSID)
	{
		FreeSid(pAdminSID);
	}
	if (pPowerUsrSID)
	{
		FreeSid(pPowerUsrSID);
	}

	SafeHeapFree(pGroupInfo);

	if (INVALID_HANDLE_VALUE != hToken)
	{
		CloseHandle(hToken);
	}

	LOG_Out(_T("Return 0x%08x"), dwRet);

	return dwRet;
}

// ----------------------------------------------------------------------------------
//
// Returns:
//		1	If the NoWindowsUpdate value exists and is != 0 under
//			HKEY_CURRENT_USER for NT or HKEY_LOCAL_MACHINE for Win9x.
//		0	If the NoWindowsUpdate value exists and is zero.
//	   -1	If the NoWindowsUpdate value doesn't exist. 
//
// ----------------------------------------------------------------------------------
int IsWindowsUpdateDisabled(void)
{
	LOG_Block("IsWindowsUpdateDisabled");

	int nRet = -1;
	HKEY hKey;
	DWORD dwDisabled;
	DWORD dwSize = sizeof(dwDisabled);
	DWORD dwType;
	HKEY hkeyRoot;
	OSVERSIONINFO	versionInformation;

	versionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&versionInformation);

	if (versionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		hkeyRoot = HKEY_CURRENT_USER;
	}
	else
	{
		hkeyRoot = HKEY_LOCAL_MACHINE;
	}

	if ( RegOpenKeyEx(	hkeyRoot,
						REGPATH_EXPLORER,
						NULL,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS )
	{
		if ( RegQueryValueEx(hKey,
							REGKEY_WINUPD_DISABLED,
							NULL,
							&dwType,
							(LPBYTE)&dwDisabled,
							&dwSize) == ERROR_SUCCESS )
		{
			if ( (dwType == REG_DWORD) && (dwDisabled == 0) )
			{
				nRet = 0;
			}
			else
			{
				nRet = 1;
			}
		}

		RegCloseKey(hKey);
	}

	LOG_Out(_T("Return: %d"), nRet);
	return nRet;
}

// ----------------------------------------------------------------------------------
//
// Returns:
//		1	If the DisableWindowsUpdateAccess value exists and is != 0 under
//			HKEY_CURRENT_USER for NT or HKEY_LOCAL_MACHINE for Win9x.
//		0	If the DisableWindowsUpdateAccess value exists and is zero.
//	   -1	If the DisableWindowsUpdateAccess value doesn't exist. 
//
// ----------------------------------------------------------------------------------
int IsWindowsUpdateUserAccessDisabled(void)
{
	LOG_Block("IsWindowsUpdateUserAccessDisabled");

	int nRet = -1;
	HKEY hKey;
	DWORD dwDisabled;
	DWORD dwSize = sizeof(dwDisabled);
	DWORD dwType;
	HKEY hkeyRoot;
	OSVERSIONINFO	versionInformation;

	versionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&versionInformation);

	if (versionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		hkeyRoot = HKEY_CURRENT_USER;
	}
	else
	{
		hkeyRoot = HKEY_LOCAL_MACHINE;
	}

	if ( RegOpenKeyEx(	hkeyRoot,
						REGPATH_POLICY_USERACCESS_DISABLED,
						NULL,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS )
	{
		if ( RegQueryValueEx(hKey,
							REGKEY_WU_USERACCESS_DISABLED,
							NULL,
							&dwType,
							(LPBYTE)&dwDisabled,
							&dwSize) == ERROR_SUCCESS )
		{
			if ( (dwType == REG_DWORD) && (dwDisabled == 0) )
			{
				nRet = 0;
			}
			else
			{
				nRet = 1;
			}
		}

		RegCloseKey(hKey);
	}

	LOG_Out(_T("Return: %d"), nRet);

	if (1 == nRet)
	{
		LogMessage("Access to Windows Update has been disabled by administrative policy");
	}

	return nRet;
}

//
// Returns 1 for enabled, 0 for disabled, and -1 for unknown/default (registry doesn't exist)
//
int IsAutoUpdateEnabled(void)
{
	LOG_Block("IsAutoUpdateEnabled");

	HKEY	hSubKey;
	DWORD	dwType;
	ULONG	nLen;
	DWORD	dwAUOptions;
	int		nRet = -1;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_AU, 0, KEY_READ, &hSubKey))	
	{
		nLen = sizeof(dwAUOptions);
		if (ERROR_SUCCESS == RegQueryValueEx(hSubKey, REGKEY_AU_OPTIONS, NULL, &dwType, (LPBYTE)&dwAUOptions, &nLen))
		{
			//
			// 1 is disabled, 2 & 3 are enabled
			//
			nRet = (1 == dwAUOptions ? 0 : 1);
		}	
		RegCloseKey(hSubKey);	
	}
	else
	{
		LOG_Error(_T("RegOpenKeyEx failed - returning -1"));
	}

	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\iuengine\wubios\inc\vxdwraps.h ===
/****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1993
 *
 *   Title: VXDWRAPS.H - Include file for using VXDWRAPS.LIB
 *
 *   Version:   1.00
 *
 *   Date:  18-September-1993
 *
 *   Author:    PYS
 *
 *--------------------------------------------------------------------------
 *
 *   Change log:
 *
 ***************************************************************************/

#ifndef _VXDWRAPS_H
#define _VXDWRAPS_H

#ifndef NOBASEDEFS

typedef (*PFN)();                       // pfn
typedef PFN *PPFN;                      // ppfn

#endif  // NOBASEDEFS

#ifdef  _VMM_

#define VMM_MAP_PHYS_TO_LINEAR_INVALID  0xFFFFFFFF

typedef VOID                (_cdecl *VMM_TIMEOUT_HANDLER)();
typedef VOID                (_cdecl *VMM_EVENT_HANDLER)();
typedef VOID                (_cdecl *VMM_HOOK_HANDLER)(VOID);
typedef ULONG               (_cdecl *VMMSWP)(ULONG frame, ULONG npages);
typedef VOID                (_cdecl *VMMCOMS)(DWORD dwParam);
typedef DWORD               (_cdecl *VMMCOMNFS)();

typedef struct Exception_Handler_Struc  *PVMMEXCEPTION;
//typedef   QWORD               DESCDWORDS;
typedef	DWORD			VMMEVENT;
typedef DWORD               VMMLIST;
typedef PVOID               VMMLISTNODE;
typedef DWORD               SIGNATURE;
typedef SIGNATURE           *PSIGNATURE;    // Pointer to a signature.
typedef struct _vmmmtx {int unused;}    *PVMMMUTEX;
typedef struct cb_s                     *PVMMCB;

#endif  // _VMM_

#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)

#ifndef CURSEG
#define CURSEG()        LCODE
#endif

/****************************************************************************
 *
 * There are two types of VxD 'C' wrappers. The ones that are VXDINLINE and
 * the one that have little stubs.
 *
 ***************************************************************************/

/****************************************************************************
 *
 * The following are VxD wrappers done with VXDINLINE. They must return void
 * (to avoid a problem with C++), must take VOID (so that no parameter are
 * used as temporary stack) and all registers are preserved. The two
 * *_Debug_String also fall in that category since they need esp and ebp
 * not to be in a nested stack frame.
 *
 ***************************************************************************/

#ifdef  _VMM_

VOID VXDINLINE
Load_FS_Service(VOID)
{
    VMMCall(Load_FS_Service)
}

VOID VXDINLINE
End_Critical_Section(VOID)
{
    VMMCall(End_Critical_Section)
}

VOID VXDINLINE
Fatal_Memory_Handler(VOID)
{
    VMMJmp(Fatal_Memory_Error);
}

VOID VXDINLINE
Begin_Nest_Exec(VOID)
{
    VMMCall(Begin_Nest_Exec)
}

VOID VXDINLINE
End_Nest_Exec(VOID)
{
    VMMCall(End_Nest_Exec)
}

VOID VXDINLINE
Resume_Exec(VOID)
{
    VMMCall(Resume_Exec)
}

VOID VXDINLINE
Enable_Touch_1st_Meg(VOID)
{
    VMMCall(Enable_Touch_1st_Meg)
}

VOID VXDINLINE
Disable_Touch_1st_Meg(VOID)
{
    VMMCall(Disable_Touch_1st_Meg)
}

VOID VXDINLINE
Out_Debug_String(PCHAR psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

VOID VXDINLINE
Queue_Debug_String(PCHAR psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#endif  // _VMM_

#define MAKE_HEADER(RetType, DecType, Function, Parameters) \
extern  RetType DecType CAT(LCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(ICODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(PCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(SCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(DCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(CCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(KCODE_, CAT(Function, Parameters));

#define PREPEND(Name)       CURSEG()##_##Name

#ifdef  _VMM_

WORD VXDINLINE
Get_VMM_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(PVOID,_cdecl, _MapPhysToLinear, (ULONG PhysAddr, ULONG nBytes, ULONG flags))
MAKE_HEADER(PVOID,_cdecl,_HeapAllocate, (ULONG Bytes, ULONG Flags))
MAKE_HEADER(PVOID,_stdcall,_HeapAllocateEx, (ULONG cBytes, PVOID Res, PVOID Res1, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_HeapFree, (PVOID Address, ULONG Flags))
MAKE_HEADER(VOID,_stdcall,_HeapFreeEx, (PVOID Address, ULONG Flags))
MAKE_HEADER(PVOID,_cdecl,_HeapReAllocate, (PVOID pOld, ULONG Bytes, ULONG Flags))
MAKE_HEADER(ULONG,_cdecl,_HeapGetSize, (PVOID p, ULONG Flags))
MAKE_HEADER(VOID,_stdcall,Fatal_Error_Handler, (PCHAR pszMessage, DWORD dwExitFlag))
MAKE_HEADER(VOID,_stdcall,Begin_Critical_Section, (ULONG Flags))
MAKE_HEADER(HEVENT,_stdcall,Schedule_Global_Event, (VMM_EVENT_HANDLER pfnEvent, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Global_Event, (HEVENT hEvent));
MAKE_HEADER(HVM,_cdecl,Get_Sys_VM_Handle, (VOID))
MAKE_HEADER(DWORD,_stdcall,Get_Profile_Hex_Int, (PCHAR pszSection, PCHAR pszKeyName, DWORD dwDefault))
MAKE_HEADER(BOOL,_stdcall,Get_Profile_Boolean, (PCHAR pszSection, PCHAR pszKeyName, BOOL fDefault))
MAKE_HEADER(VMM_SEMAPHORE,_stdcall,Create_Semaphore, (LONG lTokenCount))
MAKE_HEADER(VOID,_stdcall,Destroy_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Signal_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Wait_Semaphore, (VMM_SEMAPHORE vsSemaphore, DWORD dwFlags))
MAKE_HEADER(HVM,_cdecl,Get_Execution_Focus, (VOID))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_VM_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_Global_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Time_Out, (HTIMEOUT htimeout))
MAKE_HEADER(VOID,_stdcall,Update_System_Clock, (ULONG msElapsed))
MAKE_HEADER(BOOL,_stdcall,Install_Exception_Handler, (PVMMEXCEPTION pveException))
MAKE_HEADER(PCHAR,_stdcall,Get_Exec_Path, (PULONG pulPathLength))
MAKE_HEADER(DWORD,_cdecl,Get_Last_Updated_System_Time, (VOID))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Allocate, (VMMLIST List))
MAKE_HEADER(VOID,_stdcall,List_Attach, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Attach_Tail, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLIST,_stdcall,List_Create, (ULONG Flags, ULONG NodeSize))
MAKE_HEADER(VOID,_stdcall,List_Deallocate, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Destroy, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_First, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_Next, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Insert, (VMMLIST List, VMMLISTNODE NewNode, VMMLISTNODE Node))
MAKE_HEADER(BOOL,_stdcall,List_Remove, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Remove_First, (VMMLIST List))
MAKE_HEADER(PVOID,_cdecl,_PageAllocate, (DWORD nPages, DWORD pType, HVM hvm, DWORD AlignMask, DWORD minPhys, DWORD maxPhys, PVOID *PhysAddr, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_PageFree, (PVOID hMem, DWORD flags))
MAKE_HEADER(DWORD,_cdecl,_AddFreePhysPage, (ULONG PhysPgNum, ULONG nPages, ULONG flags, VMMSWP pfnSwapOutNotify))
MAKE_HEADER(HVM,_cdecl,Get_Cur_VM_Handle, (VOID))
MAKE_HEADER(BOOL,_cdecl,_LinPageLock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_LinPageUnLock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))
MAKE_HEADER(DWORD,_cdecl,_Allocate_Device_CB_Area, (DWORD nBytes, DWORD flags))
MAKE_HEADER(HVM,_stdcall,Get_Next_VM_Handle, (HVM hvm))
MAKE_HEADER(BOOL,_stdcall,Test_Cur_VM_Handle, (HVM hvm))
MAKE_HEADER(BOOL,_stdcall,Test_Sys_VM_Handle, (HVM hvm))
MAKE_HEADER(BOOL,_stdcall,Hook_V86_Int_Chain, (VMM_HOOK_HANDLER pfHook, DWORD dwInterrupt))
MAKE_HEADER(BOOL,_stdcall,Unhook_V86_Int_Chain, (VMM_HOOK_HANDLER pfHook, DWORD dwInterrupt))
MAKE_HEADER(PCHAR,_cdecl,Get_Config_Directory,(VOID))
MAKE_HEADER(DWORD,_cdecl,_Allocate_Temp_V86_Data_Area,(DWORD nBytes, DWORD Flags))
MAKE_HEADER(BOOL,_cdecl,_Free_Temp_V86_Data_Area,(VOID))
MAKE_HEADER(PVOID,_cdecl,_GetNulPageHandle,(VOID))
MAKE_HEADER(VOID,_stdcall,Get_Machine_Info,(PULONG prEAX, PULONG prEBX, PULONG prECX, PULONG prEDX))
MAKE_HEADER(ULONG,_cdecl,_PageModifyPermissions,(ULONG page, ULONG npages, ULONG permand, ULONG permor))
//MAKE_HEADER(WORD,_cdecl,_Allocate_GDT_Selector, (DESCDWORDS DescDWORDS, ULONG flags))
//MAKE_HEADER(DESCDWORDS,_cdecl,_BuildDescriptorDWORDs, (DWORD DESCBase, DWORD DESCLimit, DWORD DESCType, DWORD DESCSize, ULONG flags))
//MAKE_HEADER(BOOL,_cdecl,_Free_GDT_Selector, (WORD Selector, ULONG flags))
MAKE_HEADER(DWORD,_cdecl,_CallRing3, (DWORD ulCS, DWORD ulEIP, DWORD cbArgs, PDWORD lpvArgs))

#ifdef  WIN40SERVICES

MAKE_HEADER(ULONG,_cdecl,VMM_GetSystemInitState, (VOID))
MAKE_HEADER(VOID,_stdcall,_Trace_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Flags_Service, (ULONG flags))
MAKE_HEADER(VOID,_cdecl,_Debug_Printf_Service, (PCHAR pszfmt, ...))
MAKE_HEADER(HTIMEOUT,_stdcall, Set_Async_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(PVMMDDB,_stdcall,Get_DDB, (WORD DeviceID, PCHAR Name))
MAKE_HEADER(DWORD,_stdcall,Directed_Sys_Control, (PVMMDDB pDDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI))
MAKE_HEADER(BOOL,_cdecl,_Assert_Range, (PVOID p, ULONG ulSize, SIGNATURE sSignature, LONG lSignatureOffset, ULONG ulFlags))
MAKE_HEADER(ULONG,_cdecl,_Sprintf, (PCHAR pszBuf, PCHAR pszFmt, ...))
MAKE_HEADER(PVMMMUTEX,_cdecl,_CreateMutex, (LONG Boost, ULONG Flags))
MAKE_HEADER(BOOL,_cdecl,_DestroyMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_EnterMutex, (PVMMMUTEX hmtx, ULONG Flags))
MAKE_HEADER(PTCB,_cdecl,_GetMutexOwner, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_LeaveMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_SignalID, (DWORD id))
MAKE_HEADER(VOID,_cdecl,_BlockOnID, (DWORD id, ULONG Flags))
MAKE_HEADER(PCHAR,_cdecl,_lstrcpyn,(PCHAR pszDest,const char *pszSrc,DWORD cb))
MAKE_HEADER(ULONG,_cdecl,_lstrlen,(const char *psz))
MAKE_HEADER(ULONG,_cdecl,_lmemcpy,(PVOID pDst, const void *pSrc, DWORD cb))
MAKE_HEADER(DWORD,_cdecl,Get_Boot_Flags, (VOID))
MAKE_HEADER(PTCB,_cdecl,Get_Cur_Thread_Handle, (VOID))
MAKE_HEADER(PVOID,_cdecl,_GetVxDName, (PVOID pLinAddr, PCHAR pBuffer))
MAKE_HEADER(VOID,_cdecl,_Call_On_My_Stack, (VMMCOMS Callback, DWORD LParam, PVOID StackPtr, DWORD StackSize))
MAKE_HEADER(PVOID,_cdecl,_PageReserve,(ULONG page, ULONG npages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PageCommit,(ULONG page, ULONG npages, ULONG hpd, ULONG pagerdata, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PageDecommit,(ULONG page, ULONG npages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PageCommitPhys,(ULONG page, ULONG npages, ULONG physpg, ULONG flags))
MAKE_HEADER(DWORD,_cdecl,Open_Boot_Log,(VOID))          // Warning 0 means success
MAKE_HEADER(VOID,_cdecl,Close_Boot_Log,(VOID))
MAKE_HEADER(VOID,_stdcall,Write_Boot_Log,(DWORD dwLength, PCHAR pString))
MAKE_HEADER(BOOL,_cdecl,_CopyPageTable,(ULONG PageNumber, ULONG nPages, PULONG ppte, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PhysIntoV86,(ULONG PhysPage, HVM VM, ULONG VMLinPgNum, ULONG nPages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_LinMapIntoV86,(ULONG HLinPgNum, HVM VM, ULONG VMLinPgNum, ULONG nPages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_ModifyPageBits,(HVM VM, ULONG VMLinPgNum, ULONG nPages, ULONG AndMask, ULONG OrMask, ULONG pType, ULONG flags))
MAKE_HEADER(PVOID,_cdecl,_PageReAllocate,(PVOID pMem, ULONG nPages, ULONG flags))
MAKE_HEADER(BOOL,_stdcall,VMM_Add_DDB, (PVMMDDB pDDB))
MAKE_HEADER(BOOL,_stdcall,VMM_Remove_DDB, (PVMMDDB pDDB))
MAKE_HEADER(ULONG,_cdecl,_AtEventTime,(VOID))
MAKE_HEADER(VMMEVENT,_stdcall,Call_Restricted_Event,(ULONG ulBoost, HVM hvm, ULONG ulFlags, ULONG ulRefData, VMM_EVENT_HANDLER Handler, CMS cms))
MAKE_HEADER(VOID,_stdcall,Cancel_Restricted_Event,(VMMEVENT Event))
MAKE_HEADER(DWORD,_cdecl,_AllocateThreadDataSlot, (VOID))
MAKE_HEADER(VOID,_cdecl,_FreeThreadDataSlot, (DWORD))
MAKE_HEADER(PTCB,_stdcall,Get_Next_Thread_Handle, (PTCB))

//
// 4.1 Service
//
MAKE_HEADER(DWORD,_cdecl,_Call_On_My_Not_Flat_Stack, (DWORD dwCallback, DWORD dwNewCS, DWORD dwNewESP, DWORD dwNewSS, DWORD dwNewDS, DWORD dwNewES, DWORD dwStackSizeInWords, PVOID pFlatStackOffset, DWORD dwReturnOfFail, DWORD dwFlags))
MAKE_HEADER(BOOL,_cdecl,_LinRegionLock, (DWORD dwBeginLock, DWORD dwEndLock, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_LinRegionUnLock, (DWORD dwBeginLock, DWORD dwEndLock, DWORD flags))
MAKE_HEADER(ASD_RESULT,_cdecl,_AttemptingSomethingDangerous,(DWORD dwFunction, VMMREFIID vrOperation, PVOID pRefData, DWORD dwSizeRefData, DWORD dwFlags))
MAKE_HEADER(ULONG,_cdecl,_Vsprintf,(PCHAR pchBuffer, PCHAR pszFormat, PVOID paParameters))
MAKE_HEADER(BOOL, _cdecl, _RegisterGARTHandler,(PVOID pGARTHandler))
MAKE_HEADER(PVOID, _cdecl, _GARTReserve,(PVOID pDevObj, ULONG ulNumPages, ULONG ulAlignMask, PULONG pulGARTDev, ULONG ulFlags))
MAKE_HEADER(BOOL, _cdecl, _GARTCommit,(PVOID pGARTLin, ULONG ulPageOffset, ULONG ulNumPages, PULONG pulGARTDev, ULONG ulFlags))
MAKE_HEADER(VOID, _cdecl, _GARTUnCommit,(PVOID pGARTLin, ULONG ulPageOffset, ULONG ulNumPages))
MAKE_HEADER(VOID, _cdecl, _GARTFree,(PVOID pGARTLin))
MAKE_HEADER(VOID, _cdecl, _GARTMemAttributes,(PVOID pGARTLin, PULONG pulFlags))
MAKE_HEADER(DWORD,_cdecl,_FlushCaches,(DWORD dwService))
MAKE_HEADER(HTIMEOUT,_cdecl,_Set_Global_Time_Out_Ex, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData, ULONG ulScheduleFlags))

#endif  // WIN40SERVICES

#endif  // _VMM_

#ifdef	_PCI_H

WORD VXDINLINE
PCI_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(_PCI_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD,_cdecl,_PCI_Read_Config,(BYTE bBus, BYTE bDevFunc, BYTE bOffset))
MAKE_HEADER(VOID,_cdecl,_PCI_Write_Config,(BYTE bBus, BYTE bDevFunc, BYTE bOffset, DWORD dwValue))
MAKE_HEADER(BOOL,_cdecl,_PCI_Lock_Unlock,(DWORD dnDevNode, ULONG ulFlags))

#endif	// _PCI_H

#ifdef	_MTRR_H_

WORD VXDINLINE
MTRRGetVersion(VOID)
{
    WORD w;
    Touch_Register(eax)
    VxDCall(_MTRR_Get_Version);
    _asm mov [w], ax;
    return (w);
}

MAKE_HEADER(ULONG,_stdcall,MTRRSetPhysicalCacheTypeRange,(PVOID PhysicalAddress, ULONG NumberOfBytes, MEMORY_CACHING_TYPE CacheType))

#endif	// _MTRR_H_

#ifdef	_NTKERN_H

WORD VXDINLINE
NTKERN_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(_NTKERN_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(NTSTATUS,_stdcall,_NtKernCreateFile,(PHANDLE FileHandle,ACCESS_MASK DesiredAccess,\
	POBJECT_ATTRIBUTES ObjectAttributes,PIO_STATUS_BLOCK IoStatusBlock,PLARGE_INTEGER AllocationSize, \
	ULONG FileAttributes,ULONG ShareAccess,ULONG CreateDisposition,ULONG CreateOptions,PVOID EaBuffer,ULONG EaLength))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernClose,(HANDLE FileHandle))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernDeviceIoControl,(HANDLE FileHandle,HANDLE Event,PIO_APC_ROUTINE ApcRoutine,\
	PVOID ApcContext,PIO_STATUS_BLOCK IoStatusBlock,ULONG IoControlCode,PVOID InputBuffer,ULONG InputBufferLength,\
	PVOID OutputBuffer,ULONG OutputBufferLength))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernReadFile,(HANDLE FileHandle,HANDLE Event,PIO_APC_ROUTINE ApcRoutine,PVOID ApcContext,\
	PIO_STATUS_BLOCK IoStatusBlock,PVOID Buffer,ULONG Length,PLARGE_INTEGER ByteOffset,PULONG Key))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernWriteFile,(HANDLE FileHandle,HANDLE Event,PIO_APC_ROUTINE ApcRoutine,PVOID ApcContext,\
	PIO_STATUS_BLOCK IoStatusBlock,PVOID Buffer,ULONG Length,PLARGE_INTEGER ByteOffset,PULONG Key))
MAKE_HEADER(ULONG,_cdecl,_NtKernGetWorkerThread,(ULONG ThreadType))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernLoadDriver,(PUNICODE_STRING DriverServiceName))
MAKE_HEADER(VOID,_stdcall,_NtKernQueueWorkItem,(PWORK_QUEUE_ITEM workitem,WORK_QUEUE_TYPE worktype))
MAKE_HEADER(DWORD,_cdecl,_NtKernPhysicalDeviceObjectToDevNode,(PDEVICE_OBJECT PhysicalDeviceObject))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernSetPhysicalCacheTypeRange,(ULONG BaseAddressHigh, ULONG BaseAddressLow, ULONG NumberOfBytex, ULONG CacheType))
MAKE_HEADER(PDRIVER_OBJECT,_cdecl,_NtKernWin9XLoadDriver,(PCHAR FileName,PCHAR RegisteryPath))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernCancelIoFile,(HANDLE FileHandle,PIO_STATUS_BLOCK IoStatusBlock))



#endif	// _NTKERN_H

#ifdef  _SHELL_H

typedef DWORD       SHELL_HINSTANCE;
typedef PVOID       SHELL_FARPROC;

WORD VXDINLINE
SHELL_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(SHELL_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD,_stdcall,SHELL_SYSMODAL_Message, (HVM hvm, DWORD dwMBFlags, PCHAR pszMessage, PCHAR pszCaption))

#ifndef WIN31COMPAT

MAKE_HEADER(APPY_HANDLE,_cdecl,_SHELL_CallAtAppyTime, (APPY_CALLBACK pfnAppyCallBack, DWORD dwRefData, DWORD flAppy, ...))
MAKE_HEADER(BOOL,_cdecl,_SHELL_CancelAppyTimeEvent, (APPY_HANDLE appy_handle))
MAKE_HEADER(BOOL,_cdecl,_SHELL_QueryAppyTimeAvailable, (VOID))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalAllocEx, (DWORD fl, DWORD cb, PVOID lpvBuf))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalFree, (DWORD hdata))
MAKE_HEADER(DWORD,_cdecl,_SHELL_CallDll, (PCHAR lpszDll, PCHAR lpszProcName, DWORD cbArgs, PVOID lpvArgs))
MAKE_HEADER(DWORD,_cdecl,_SHELL_BroadcastSystemMessage, (DWORD dwFlags, PDWORD lpdwRecipients, DWORD uMsg, DWORD wparam, DWORD lparam))
MAKE_HEADER(SYSBHOOK_HANDLE,_cdecl,_SHELL_HookSystemBroadcast, (SYSBHOOK_CALLBACK pfnSysBHookCallBack, DWORD dwRefData, DWORD dwCallOrder))
MAKE_HEADER(VOID,_cdecl,_SHELL_UnhookSystemBroadcast, (SYSBHOOK_HANDLE SysBHookHandle))
MAKE_HEADER(SHELL_HINSTANCE,_cdecl,_SHELL_LoadLibrary, (PCHAR pszDll))
MAKE_HEADER(VOID,_cdecl,_SHELL_FreeLibrary, (SHELL_HINSTANCE hinstance))
MAKE_HEADER(SHELL_FARPROC,_cdecl,_SHELL_GetProcAddress, (SHELL_HINSTANCE hinstance, PCHAR pszProcName))

#ifdef WIN41SERVICES
MAKE_HEADER(PSHELL_SUUAE_INFO,_cdecl,_SHELL_Update_User_Activity_Ex, (ULONG ulFlags))
#endif

#endif  // WIN31COMPAT

#endif  // _SHELL_H

#ifdef  _PCCARD_H

MAKE_HEADER(DWORD,_cdecl,_PCCARD_Access_CIS_Memory, (DWORD dnDevNode, PUCHAR pBuffer, DWORD dwOffset, DWORD dwLength, DWORD fFlags))

#endif

#ifdef  _VTD_H
#ifndef WIN31COMPAT

MAKE_HEADER(DWORD,_stdcall,VTD_GetTimeZoneBias, (VOID))
MAKE_HEADER(ULONGLONG,_cdecl,VTD_Get_Real_Time, (VOID))
MAKE_HEADER(VOID,_cdecl,_VTD_Delay_Ex,(ULONG us, ULONG ulFlags))

#endif  // WIN31COMPAT
#endif  // _VTD_H

#ifdef  _VMMREG_H

#ifndef WIN31COMPAT

MAKE_HEADER(VMMREGRET,cdecl,_RegOpenKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegCloseKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteKey, (VMMHKEY hkey, PCHAR lpszSubKey))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumKey, (VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValue, (VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValue, (VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteValue, (VMMHKEY hkey, PCHAR lpszValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumValue, (VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValueEx, (VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValueEx, (VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PVOID lpbData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegFlushKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryInfoKey, (VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, \
			PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime))
MAKE_HEADER(VMMREGRET,cdecl,_RegRemapPreDefKey, (VMMHKEY hkey,VMMHKEY hkRootKey))
MAKE_HEADER(ULONG,cdecl,_GetRegistryPath, (PVMMDDB ThisDDB, PVOID pUserBuff, ULONG ulUserBuffSize))
MAKE_HEADER(VMMREGRET,cdecl,_GetRegistryKey, (DWORD dwType, PCHAR lpszDevName, DWORD dwFlags, PVMMHKEY lpHkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateDynKey, (PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryMultipleValues, (VMMHKEY hKey,PVOID val_list,DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize))

#endif  // WIN31COMPAT

#endif  // _VWWREG_H

#ifdef  _VPICD_H

MAKE_HEADER(HIRQ,_stdcall,VPICD_Virtualize_IRQ, (PVID pvid))
MAKE_HEADER(VOID,_stdcall,VPICD_Phys_EOI, (HIRQ hirq))
MAKE_HEADER(VOID,_stdcall,VPICD_Physically_Mask, (HIRQ hirq))
MAKE_HEADER(VOID,_stdcall,VPICD_Physically_Unmask, (HIRQ hirq))
MAKE_HEADER(VOID,_stdcall,VPICD_Force_Default_Behavior, (HIRQ hirq))
MAKE_HEADER(VOID,_cdecl,_VPICD_Clear_IR_Bits, (DWORD dwIRQMask))
MAKE_HEADER(WORD,_cdecl,_VPICD_Get_Level_Mask, (VOID))
MAKE_HEADER(VOID,_cdecl,_VPICD_Set_Level_Mask, (WORD wIRQMask))
MAKE_HEADER(VOID,_cdecl,_VPICD_Set_Irql_Mask, (DWORD dwNewLevel))
MAKE_HEADER(VOID,_cdecl,_VPICD_Set_Channel_Irql, (DWORD dwChannel, DWORD dwNewLevel))
MAKE_HEADER(ULONG,_cdecl,_VPICD_Register_Trigger_Handler, (VPICDTRIGGERHANDLER vthHandler, ULONG ulMBZ))

#endif  // _VPICD_H

#ifdef  _VXDLDR_H

typedef struct DeviceInfo   *PDEVICEINFO;
typedef PDEVICEINFO     *PPDEVICEINFO;

WORD VXDINLINE
VXDLDR_GetVersion(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(VXDLDR_GetVersion);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_LoadDevice, (PPVMMDDB ppDDB, PPDEVICEINFO ppDeviceHandle, PCHAR Filename, BOOL InitDevice))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_UnloadDevice, (USHORT DevID, PCHAR szName))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitSucceeded, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitFailed, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(PDEVICEINFO,_cdecl,VXDLDR_GetDeviceList, (VOID))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_UnloadMe, (USHORT DevID, PCHAR szName))
MAKE_HEADER(LRESULT,_cdecl,_PELDR_LoadModule, (PHPEMODULE phl, PSTR pFileName, PHLIST phetl));
MAKE_HEADER(HPEMODULE,_cdecl,_PELDR_GetModuleHandle, (PSTR pFileName));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_GetModuleUsage, (HPEMODULE hl));
MAKE_HEADER(PFN,_cdecl,_PELDR_GetEntryPoint, (HPEMODULE hl));
MAKE_HEADER(PFN,_cdecl,_PELDR_GetProcAddress, (HPEMODULE hl, PVOID pFuncName, PHLIST phetl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_LoadModuleEx, (PHPEMODULE phl, PSTR pFileName, PHLIST phetl, DWORD dwFlags));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_InitCompleted, (HPEMODULE hl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_AddExportTable, (PHPEEXPORTTABLE pht, PSTR pszModuleName, \
	ULONG cExportedFunctions, ULONG cExportedNames, ULONG ulOrdinalBase, PVOID *pExportNameList, \
	PUSHORT pExportOrdinals, PFN *ppExportAddrs, PHLIST phetl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_RemoveExportTable, (HPEEXPORTTABLE ht, PHLIST phetl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_FreeModule, (HPEMODULE hl, PHLIST phetl));
#endif  // _VXDLDR_H

#ifdef _VCOMM_H

WORD VXDINLINE
VCOMM_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(VCOMM_Get_Version);
    _asm mov [w], ax
    return(w);
}

// VCOMM headers
#ifndef HPORT
    #define HPORT   DWORD
#endif

MAKE_HEADER(BOOL, _cdecl, _VCOMM_Register_Port_Driver, (PFN InitFn))
MAKE_HEADER(ULONG, _cdecl, _VCOMM_Acquire_Port, (HANDLE PHandle, ULONG PortNum, ULONG OwnerVM, ULONG flags, char *PortName))
MAKE_HEADER(void, _cdecl, _VCOMM_Release_Port,(ULONG PortHandle, ULONG OwnerVM))
MAKE_HEADER(HPORT, _cdecl, _VCOMM_OpenComm, (char *PortName, ULONG VMId))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommState, (HPORT hPort, _DCB *pDcb, DWORD ActionMask))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommState, (HPORT hPort, _DCB *pDcb))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetupComm, (HPORT hPort,BYTE *RxBase, ULONG RxLength, BYTE *TxBase, ULONG TxLength, _QSB *pqsb))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_TransmitCommChar, (HPORT hPort, char ch))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_CloseComm, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommQueueStatus, (HPORT hPort, _COMSTAT *pComStat))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ClearCommError, (HPORT hPort, _COMSTAT *pComstat, ULONG *perror))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetModemStatus, (HPORT hPort, ULONG *pModemStatus))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommProperties, (HPORT hPort, _COMMPROP *pCommprop))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EscapeCommFunction, (HPORT hPort, long lFunc, long IData, long OData))
// MAKE_HEADER(BOOL, _cdecl, _VCOMM_DeviceIOControl, (HPORT hPort, long IOCTL, long IData, long cbIData, long OData, long cbOData, long *cbBytesReturned))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_PurgeComm, (HPORT hPort, long QueueType))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommEventMask, (HPORT hPort, long EvtMask, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommEventMask, (HPORT hPort, long EvtMaskToClear, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_WriteComm, (HPORT hPort, char *lpBuf, ULONG ToWrite,ULONG *Written))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ReadComm, (HPORT hPort, char *lpBuf, long ToRead, long *Read))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EnableCommNotification, (HPORT hPort, PVOID Fn, long ReferenceData))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_GetLastError, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Steal_Port, (ULONG PortHandle, ULONG VMHandle))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetReadCallBack, (HPORT hPort, ULONG RecvTrigger, PVOID FnReadEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetWriteCallBack, (HPORT hPort,ULONG SendTrigger, PVOID FnWriteEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Add_Port, (DWORD refData, PFN PortEntry, char *PortName))

#ifndef WIN31COMPAT
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetSetCommTimeouts, (HPORT hPort, LPCOMMTIMEOUTS lpct, DWORD dwAction))
MAKE_HEADER(IORequest * , _cdecl, _VCOMM_SetWriteRequest, (HPORT hPort, IORequest *ioreq, ULONG *lpNumWritten))
MAKE_HEADER(IORequest *, _cdecl, _VCOMM_SetReadRequest, (HPORT hPort,IORequest *ioreq, ULONG *lpNumRead))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Dequeue_Request,(DWORD listElement, PDWORD  lpcbTransfer))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Enumerate_DevNodes, (void))
MAKE_HEADER(PFN, _cdecl, _VCOMM_Get_Contention_Handler, (char *PortName))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Map_Name_To_Resource, (char *PortName))
#endif

#endif          // _VCOMM_H

#ifdef      _IRS_H
MAKE_HEADER(void, _cdecl, IOS_Requestor_Service, (ULONG p))
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

WORD VXDINLINE
VPOWERD_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(_VPOWERD_Get_Version);
    _asm mov [w], ax
	return(w);
}

MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_APM_BIOS_Version, (VOID))
MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_Power_Management_Level, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Power_Management_Level, (DWORD Power_Management_Level))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Device_Power_State, (POWER_DEVICE_ID Power_Device_ID, POWER_STATE Power_State))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Restore_Power_On_Defaults, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_Status, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATUS pPower_Status))
#ifndef _NTDDK_
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_State, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATE pPower_State))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_System_Power_State, (POWER_STATE Power_State, DWORD Request_Type))
#else
MAKE_HEADER(VOID, _cdecl, _VPOWERD_Transfer_Control, (PVTC_INFO pvtc))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_System_Power_State, (VXD_POWER_STATE Power_State, DWORD Request_Type))
#endif
MAKE_HEADER(VOID, _cdecl, _VPOWERD_OEM_APM_Function, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Register_Power_Handler, (POWER_HANDLER Power_Handler, DWORD Priority))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Deregister_Power_Handler, (POWER_HANDLER Power_Handler));

#endif      // _INC_VPOWERD

#ifdef  _ACPIVXD_H
#ifndef	_ACPIVXD_SERVICES_PROVIDER

WORD VXDINLINE
ACPI_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(ACPI_GetVersion);
    _asm mov [w], ax
	return(w);
}

MAKE_HEADER(BOOL, _cdecl, _ACPI_SetTimingMode, (DEVNODE IDEChannelDevnode, PTIMINGMODE TimingMode, ULONG Drive0IDEBlockLength, PVOID Drive0IDEBlock, ULONG Drive1IDEBlockLength, PVOID Drive1IDEBlock))
#ifdef _NTDDK_
MAKE_HEADER(BOOL, _cdecl, _ACPI_SetSystemPowerState, (SYSTEM_POWER_STATE PowerState))
#endif
MAKE_HEADER(BOOL, _cdecl, _ACPI_RegisterOpRegionCookedHandler, (OPREGIONHANDLER pCallBack, ULONG Type, ULONG Context))
#ifdef _NTDDK_
MAKE_HEADER(BOOL, _cdecl, _ACPI_Set_RTC, (PTIME_FIELDS TimeFields))
#endif
MAKE_HEADER(BOOL, _cdecl, _ACPI_GetTimingMode, (DEVNODE Channel, PTIMINGMODE TimingMode))
MAKE_HEADER(BOOL, _cdecl, _ACPI_GetTaskFile, (DEVNODE Drive, PVOID ATACommandBuffer, PULONG ReturnedBufferSize))
#ifdef	_AMLI_H
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_WalkNameSpace, (PNSOBJ pnsObj, ULONG ulDirection))
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_GetObject, (PNSOBJ pnsObj, ULONG ulPackedID))
MAKE_HEADER(DEVNODE, _cdecl, _ACPI_NameSpaceToDevNode, (PNSOBJ pnsObj))
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_DevNodeToNameSpace, (DEVNODE dnDevNode))
MAKE_HEADER(BOOL, _cdecl, _ACPI_RunControlMethod, (PNSOBJ pnsObj, ULONG ulParamCount, POBJDATA pParams, DWORD dwExpectedType, PDWORD pdwBufferSize, PVOID pBuffer))
#endif
#ifdef	_AMLI_H
MAKE_HEADER(BOOL, _cdecl, _ACPI_EvalPackageElement, (PNSOBJ pns, int iPktIndex, POBJDATA pResult))
MAKE_HEADER(BOOL, _cdecl, _ACPI_EvalPkgDataElement, (POBJDATA pdataPkg, int iPkgIndex, POBJDATA pdataResult))
MAKE_HEADER(VOID, _cdecl, _ACPI_FreeDataBuffs, (POBJDATA pdata, int icData))
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_GetNameSpaceObject, (PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns, ULONG dwfFlags))
#endif

#endif	// _ACPIVXD_SERVICES_PROVIDER
#endif  // _ACPIVXD_H

#ifdef _VDMAD_H_
MAKE_HEADER(ULONG, _stdcall, VDMAD_Get_Phys_Count, (HDMA hdma, HVM hvm))
MAKE_HEADER(VOID, _stdcall, VDMAD_Phys_Mask_Channel, (HDMA hdma))
MAKE_HEADER(VOID, _stdcall, VDMAD_Phys_Unmask_Channel, (HDMA hdma, HVM hvm))
MAKE_HEADER(VOID, _stdcall, VDMAD_Set_Phys_State( HDMA hdma, HVM hVM, ULONG ulMode, ULONG ulExtMode ))
MAKE_HEADER(VOID, _stdcall, VDMAD_Set_Region_Info, (HDMA hdma, ULONG ulBufferId, BOOLEAN fLocked, ULONG ulLinear, ULONG cbSize, ULONG ulPhysical))
MAKE_HEADER(VOID, _stdcall, VDMAD_Unvirtualize_Channel, (HDMA hdma))
MAKE_HEADER(HDMA, _stdcall, VDMAD_Virtualize_Channel, (ULONG ulChannel, PVOID pHandler))
#endif // _VDMAD_H_

#ifdef _VWIN32_H_
#ifdef NOBASEDEFS
MAKE_HEADER(ULONG, _cdecl, VWIN32_AllocExternalHandle, (PR0OBJTYPETABLE, PVOID, PHANDLE, ULONG))
MAKE_HEADER(VOID, _cdecl, VWIN32_UseExternalHandle, (HANDLE))
MAKE_HEADER(VOID, _cdecl, VWIN32_UnuseExternalHandle, (HANDLE))
MAKE_HEADER(DWORD, _stdcall, VWIN32_ConvertNtTimeout, (PLARGE_INTEGER))
MAKE_HEADER(VOID, _cdecl, VWIN32_SetWin32EventBoostPriority, (PVOID, PULONG))
MAKE_HEADER(ULONG, _cdecl, VWIN32_GetCurThreadCondition, (ULONG))

#define VWIN32_AllocExternalHandle  PREPEND(VWIN32_AllocExternalHandle)
#define VWIN32_UseExternalHandle    PREPEND(VWIN32_UseExternalHandle)
#define VWIN32_UnuseExternalHandle  PREPEND(VWIN32_UnuseExternalHandle)
#define VWIN32_ConvertNtTimeout  PREPEND(VWIN32_ConvertNtTimeout)
#define VWIN32_SetWin32EventBoostPriority PREPEND(VWIN32_SetWin32EventBoostPriority)
#define VWIN32_GetCurThreadCondition	PREPEND(VWIN32_GetCurThreadCondition)

#endif // NOBASEDEFS
#endif  // _VWIN32_H_

#define _MapPhysToLinear        PREPEND(_MapPhysToLinear)
#define _HeapAllocate           PREPEND(_HeapAllocate)
#define _HeapFree           PREPEND(_HeapFree)
#define _HeapReAllocate         PREPEND(_HeapReAllocate)
#define _HeapGetSize            PREPEND(_HeapGetSize)
#define _Trace_Out_Service      PREPEND(_Trace_Out_Service)
#define _Debug_Out_Service      PREPEND(_Debug_Out_Service)
#define _Debug_Flags_Service        PREPEND(_Debug_Flags_Service)
#define _Debug_Printf_Service       PREPEND(_Debug_Printf_Service)
#define Fatal_Error_Handler     PREPEND(Fatal_Error_Handler)
#define Begin_Critical_Section      PREPEND(Begin_Critical_Section)
#define Schedule_Global_Event       PREPEND(Schedule_Global_Event)
#define Cancel_Global_Event     PREPEND(Cancel_Global_Event)
#define Get_Sys_VM_Handle       PREPEND(Get_Sys_VM_Handle)
#define Get_Profile_Hex_Int     PREPEND(Get_Profile_Hex_Int)
#define Get_Profile_Boolean     PREPEND(Get_Profile_Boolean)
#define Create_Semaphore        PREPEND(Create_Semaphore)
#define Destroy_Semaphore       PREPEND(Destroy_Semaphore)
#define Signal_Semaphore        PREPEND(Signal_Semaphore)
#define Wait_Semaphore          PREPEND(Wait_Semaphore)
#define Get_Execution_Focus     PREPEND(Get_Execution_Focus)
#define Set_VM_Time_Out         PREPEND(Set_VM_Time_Out)
#define Set_Global_Time_Out     PREPEND(Set_Global_Time_Out)
#define Cancel_Time_Out         PREPEND(Cancel_Time_Out)
#define Update_System_Clock     PREPEND(Update_System_Clock)
#define Set_Async_Time_Out      PREPEND(Set_Async_Time_Out)
#define Get_Last_Updated_System_Time    PREPEND(Get_Last_Updated_System_Time)
#define List_Allocate           PREPEND(List_Allocate)
#define List_Attach         PREPEND(List_Attach)
#define List_Attach_Tail        PREPEND(List_Attach_Tail)
#define List_Create         PREPEND(List_Create)
#define List_Deallocate         PREPEND(List_Deallocate)
#define List_Destroy            PREPEND(List_Destroy)
#define List_Get_First          PREPEND(List_Get_First)
#define List_Get_Next           PREPEND(List_Get_Next)
#define List_Insert         PREPEND(List_Insert)
#define List_Remove         PREPEND(List_Remove)
#define List_Remove_First       PREPEND(List_Remove_First)
#define Get_DDB             PREPEND(Get_DDB)
#define Directed_Sys_Control        PREPEND(Directed_Sys_Control)
#define Install_Exeption_Handler    PREPEND(Install_Exeption_Handler)
#define _Assert_Range           PREPEND(_Assert_Range)
#define _Sprintf            PREPEND(_Sprintf)
#define _PageAllocate           PREPEND(_PageAllocate)
#define _PageFree           PREPEND(_PageFree)
#define _PageReserve        PREPEND(_PageReserve)
#define _PageCommit         PREPEND(_PageCommit)
#define _PageDecommit       PREPEND(_PageDecommit)
#define _AddFreePhysPage        PREPEND(_AddFreePhysPage)
#define Get_Cur_VM_Handle       PREPEND(Get_Cur_VM_Handle)
#define _CreateMutex            PREPEND(_CreateMutex)
#define _DestroyMutex           PREPEND(_DestroyMutex)
#define _EnterMutex         PREPEND(_EnterMutex)
#define _GetMutexOwner          PREPEND(_GetMutexOwner)
#define _LeaveMutex         PREPEND(_LeaveMutex)
#define _SignalID           PREPEND(_SignalID)
#define _BlockOnID          PREPEND(_BlockOnID)
#define _lstrcpyn           PREPEND(_lstrcpyn)
#define _lstrlen            PREPEND(_lstrlen)
#define _lmemcpy            PREPEND(_lmemcpy)
#define VMM_GetSystemInitState      PREPEND(VMM_GetSystemInitState)
#define Get_Boot_Flags          PREPEND(Get_Boot_Flags)
#define Get_Cur_Thread_Handle       PREPEND(Get_Cur_Thread_Handle)
#define _GetVxDName             PREPEND(_GetVxDName)
#define _Call_On_My_Stack       PREPEND(_Call_On_My_Stack)
#define _LinPageLock            PREPEND(_LinPageLock)
#define _LinPageUnLock          PREPEND(_LinPageUnLock)
#define _Allocate_Device_CB_Area        PREPEND(_Allocate_Device_CB_Area)
#define Hook_V86_Int_Chain      PREPEND(Hook_V86_Int_Chain)
#define Unhook_V86_Int_Chain    PREPEND(Unhook_V86_Int_Chain)
#define Get_Next_VM_Handle              PREPEND(Get_Next_VM_Handle)
#define Test_Cur_VM_Handle       PREPEND(Test_Cur_VM_Handle)
#define Test_Sys_VM_Handle       PREPEND(Test_Sys_VM_Handle)
#define _PageCommitPhys         PREPEND(_PageCommitPhys)
#define Open_Boot_Log           PREPEND(Open_Boot_Log)
#define Close_Boot_Log          PREPEND(Close_Boot_Log)
#define Write_Boot_Log          PREPEND(Write_Boot_Log)
#define _CopyPageTable          PREPEND(_CopyPageTable)
#define _PhysIntoV86            PREPEND(_PhysIntoV86)
#define _LinMapIntoV86          PREPEND(_LinMapIntoV86)
#define _ModifyPageBits         PREPEND(_ModifyPageBits)
#define _PageReAllocate         PREPEND(_PageReAllocate)
#define VMM_Add_DDB		PREPEND(VMM_Add_DDB)
#define VMM_Remove_DDB		PREPEND(VMM_Remove_DDB)
#define _AtEventTime            PREPEND(_AtEventTime)
#define	Call_Restricted_Event	PREPEND(Call_Restricted_Event)
#define	Cancel_Restricted_Event	PREPEND(Cancel_Restricted_Event)
#define	_Free_Temp_V86_Data_Area	PREPEND(_Free_Temp_V86_Data_Area)
#define	_Allocate_Temp_V86_Data_Area	PREPEND(_Allocate_Temp_V86_Data_Area)
#define	_GetNulPageHandle	PREPEND(_GetNulPageHandle)
#define	_RegisterGARTHandler	PREPEND(_RegisterGARTHandler)
#define	_GARTReserve		PREPEND(_GARTReserve)
#define	_GARTCommit		PREPEND(_GARTCommit)
#define	_GARTUnCommit		PREPEND(_GARTUnCommit)
#define	_GARTFree		PREPEND(_GARTFree)
#define	_GARTMemAttributes	PREPEND(_GARTMemAttributes)
#define	_FlushCaches		PREPEND(_FlushCaches)
#define	_Set_Global_Time_Out_Ex	PREPEND(_Set_Global_Time_Out_Ex)
#define	_AllocateThreadDataSlot	PREPEND(_AllocateThreadDataSlot)
#define	_FreeThreadDataSlot	PREPEND(_FreeThreadDataSlot)
#define	Get_Next_Thread_Handle	PREPEND(Get_Next_Thread_Handle)
#define	Get_Machine_Info	PREPEND(Get_Machine_Info)
#define	_PageModifyPermissions	PREPEND(_PageModifyPermissions)
#define	_CallRing3		PREPEND(_CallRing3)
#define	_NtKernCreateFile	PREPEND(_NtKernCreateFile)
#define	_NtKernClose	PREPEND(_NtKernClose)
#define	_NtKernReadFile	PREPEND(_NtKernReadFile)
#define	_NtKernWriteFile	PREPEND(_NtKernWriteFile)
#define	_NtKernDeviceIoControl	PREPEND(_NtKernDeviceIoControl)
#define	_NtKernGetWorkerThread	PREPEND(_NtKernGetWorkerThread)
#define	_NtKernLoadDriver	PREPEND(_NtKernLoadDriver)
#define	_NtKernQueueWorkItem	PREPEND(_NtKernQueueWorkItem)
#define	_NtKernPhysicalDeviceObjectToDevNode	PREPEND(_NtKernPhysicalDeviceObjectToDevNode)
#define	_NtKernSetPhysicalCacheTypeRange PREPEND(_NtKernSetPhysicalCacheTypeRange)
#define	_NtKernWin9XLoadDriver		PREPEND(_NtKernWin9XLoadDriver)
#define _SHELL_CallAtAppyTime       PREPEND(_SHELL_CallAtAppyTime)
#define _SHELL_CancelAppyTimeEvent  PREPEND(_SHELL_CancelAppyTimeEvent)
#define _SHELL_QueryAppyTimeAvailable   PREPEND(_SHELL_QueryAppyTimeAvailable)
#define _SHELL_LocalAllocEx     PREPEND(_SHELL_LocalAllocEx)
#define _SHELL_LocalFree        PREPEND(_SHELL_LocalFree)
#define _SHELL_CallDll          PREPEND(_SHELL_CallDll)
#define _SHELL_BroadcastSystemMessage   PREPEND(_SHELL_BroadcastSystemMessage)
#define _SHELL_HookSystemBroadcast  PREPEND(_SHELL_HookSystemBroadcast)
#define _SHELL_UnhookSystemBroadcast    PREPEND(_SHELL_UnhookSystemBroadcast)
#define _SHELL_LoadLibrary      PREPEND(_SHELL_LoadLibrary)
#define _SHELL_FreeLibrary      PREPEND(_SHELL_FreeLibrary)
#define _SHELL_GetProcAddress       PREPEND(_SHELL_GetProcAddress)
#define SHELL_SYSMODAL_Message      PREPEND(SHELL_SYSMODAL_Message)
#define	_SHELL_Update_User_Activity_Ex	PREPEND(_SHELL_Update_User_Activity_Ex)
#define _RegOpenKey         PREPEND(_RegOpenKey)
#define _RegCloseKey            PREPEND(_RegCloseKey)
#define _RegCreateKey           PREPEND(_RegCreateKey)
#define _RegCreateDynKey        PREPEND(_RegCreateDynKey)
#define _RegQueryMultipleValues PREPEND(_RegQueryMultipleValues)
#define _RegDeleteKey           PREPEND(_RegDeleteKey)
#define _RegEnumKey         PREPEND(_RegEnumKey)
#define _RegQueryValue          PREPEND(_RegQueryValue)
#define _RegSetValue            PREPEND(_RegSetValue)
#define _RegDeleteValue         PREPEND(_RegDeleteValue)
#define _RegEnumValue           PREPEND(_RegEnumValue)
#define _RegQueryValueEx        PREPEND(_RegQueryValueEx)
#define _RegSetValueEx          PREPEND(_RegSetValueEx)
#define _RegFlushKey            PREPEND(_RegFlushKey)
#define _RegQueryInfoKey        PREPEND(_RegQueryInfoKey)
#define _RegRemapPreDefKey      PREPEND(_RegRemapPreDefKey)
#define _GetRegistryPath        PREPEND(_GetRegistryPath)
#define _GetRegistryKey         PREPEND(_GetRegistryKey)
#define Get_Config_Directory            PREPEND(Get_Config_Directory)
#define _Call_On_My_Not_Flat_Stack      PREPEND(_Call_On_My_Not_Flat_Stack)
#define _LinRegionLock          PREPEND(_LinRegionLock)
#define _LinRegionUnLock                PREPEND(_LinRegionUnLock)
#define _AttemptingSomethingDangerous   PREPEND(_AttemptingSomethingDangerous)
#define	_Vsprintf			PREPEND(_Vsprintf)

#ifndef	PCI_WITH_PCIMP

#define	_PCI_Read_Config			PREPEND(_PCI_Read_Config)
#define	_PCI_Write_Config			PREPEND(_PCI_Write_Config)
#define	_PCI_Lock_Unlock			PREPEND(_PCI_Lock_Unlock)

#endif	// PCI_WITH_PCIMP

#ifdef  _VTD_H
#ifndef	_VTD_SERVICES_PROVIDER

#define VTD_GetTimeZoneBias         PREPEND(VTD_GetTimeZoneBias)
#define VTD_Get_Real_Time	    PREPEND(VTD_Get_Real_Time)
#define	VTD_Delay_Ex			PREPEND(VTD_Delay_Ex)

#endif
#endif

#ifndef	_PCCARD_SERVICES_PROVIDER

#define	_PCCARD_Access_CIS_Memory	PREPEND(_PCCARD_Access_CIS_Memory)

#endif

#define	MTRRSetPhysicalCacheTypeRange	PREPEND(MTRRSetPhysicalCacheTypeRange)

#define VPICD_Virtualize_IRQ            PREPEND(VPICD_Virtualize_IRQ)
#define VPICD_Phys_EOI                  PREPEND(VPICD_Phys_EOI)
#define VPICD_Physically_Mask           PREPEND(VPICD_Physically_Mask)
#define VPICD_Physically_Unmask         PREPEND(VPICD_Physically_Unmask)
#define VPICD_Force_Default_Behavior    PREPEND(VPICD_Force_Default_Behavior)
#define _VPICD_Clear_IR_Bits            PREPEND(_VPICD_Clear_IR_Bits)
#define _VPICD_Get_Level_Mask   PREPEND(_VPICD_Get_Level_Mask)
#define _VPICD_Set_Level_Mask   PREPEND(_VPICD_Set_Level_Mask)
#define _VPICD_Set_Irql_Mask            PREPEND(_VPICD_Set_Irql_Mask)
#define _VPICD_Set_Channel_Irql         PREPEND(_VPICD_Set_Channel_Irql)
#define	_VPICD_Register_Trigger_Handler PREPEND(_VPICD_Register_Trigger_Handler)

#define	_ACPI_SetTimingMode			PREPEND(_ACPI_SetTimingMode)
#define	_ACPI_SetSystemPowerState		PREPEND(_ACPI_SetSystemPowerState)
#define	_ACPI_RegisterOpRegionCookedHandler	PREPEND(_ACPI_RegisterOpRegionCookedHandler)
#define	_ACPI_Set_RTC				PREPEND(_ACPI_Set_RTC)
#define	_ACPI_GetTimingMode			PREPEND(_ACPI_GetTimingMode)
#define	_ACPI_GetTaskFile			PREPEND(_ACPI_GetTaskFile)
#define	_ACPI_WalkNameSpace			PREPEND(_ACPI_WalkNameSpace)
#define	_ACPI_GetObject				PREPEND(_ACPI_GetObject)
#define	_ACPI_NameSpaceToDevNode		PREPEND(_ACPI_NameSpaceToDevNode)
#define	_ACPI_DevNodeToNameSpace		PREPEND(_ACPI_DevNodeToNameSpace)
#define	_ACPI_RunControlMethod			PREPEND(_ACPI_RunControlMethod)
#define	_ACPI_EvalPackageElement		PREPEND(_ACPI_EvalPackageElement)
#define	_ACPI_EvalPkgDataElement		PREPEND(_ACPI_EvalPkgDataElement)
#define	_ACPI_FreeDataBuffs			PREPEND(_ACPI_FreeDataBuffs)
#define	_ACPI_GetNameSpaceObject		PREPEND(_ACPI_GetNameSpaceObject)

#define VXDLDR_LoadDevice       PREPEND(VXDLDR_LoadDevice)
#define VXDLDR_UnloadDevice     PREPEND(VXDLDR_UnloadDevice)
#define VXDLDR_DevInitSucceeded     PREPEND(VXDLDR_DevInitSucceeded)
#define VXDLDR_DevInitFailed        PREPEND(VXDLDR_DevInitFailed)
#define VXDLDR_GetDeviceList        PREPEND(VXDLDR_GetDeviceList)
#define _PELDR_LoadModule               PREPEND(_PELDR_LoadModule)
#define _PELDR_GetModuleHandle  PREPEND(_PELDR_GetModuleHandle)
#define _PELDR_GetModuleUsage   PREPEND(_PELDR_GetModuleUsage)
#define _PELDR_GetEntryPoint    PREPEND(_PELDR_GetEntryPoint)
#define _PELDR_GetProcAddress   PREPEND(_PELDR_GetProcAddress)
#define _PELDR_AddExportTable   PREPEND(_PELDR_AddExportTable)
#define _PELDR_RemoveExportTable        PREPEND(_PELDR_RemoveExportTable)
#define _PELDR_FreeModule       PREPEND(_PELDR_FreeModule)
#define _PELDR_InitCompleted    PREPEND(_PELDR_InitCompleted)
#define _PELDR_LoadModuleEx     PREPEND(_PELDR_LoadModuleEx)

#define Get_Exec_Path           PREPEND(Get_Exec_Path)
#define CM_Initialize           PREPEND(_CONFIGMG_Initialize)
#define CM_Locate_DevNode       PREPEND(_CONFIGMG_Locate_DevNode)
#define CM_Get_Parent           PREPEND(_CONFIGMG_Get_Parent)
#define CM_Get_Child            PREPEND(_CONFIGMG_Get_Child)
#define CM_Get_Sibling          PREPEND(_CONFIGMG_Get_Sibling)
#define CM_Get_Device_ID_Size       PREPEND(_CONFIGMG_Get_Device_ID_Size)
#define CM_Get_Device_ID        PREPEND(_CONFIGMG_Get_Device_ID)
#define CM_Get_Depth            PREPEND(_CONFIGMG_Get_Depth)
#define CM_Get_Private_DWord        PREPEND(_CONFIGMG_Get_Private_DWord)
#define CM_Set_Private_DWord        PREPEND(_CONFIGMG_Set_Private_DWord)
#define CM_Create_DevNode       PREPEND(_CONFIGMG_Create_DevNode)
#define CM_Query_Remove_SubTree     PREPEND(_CONFIGMG_Query_Remove_SubTree)
#define CM_Remove_SubTree       PREPEND(_CONFIGMG_Remove_SubTree)
#define CM_Register_Device_Driver   PREPEND(_CONFIGMG_Register_Device_Driver)
#define CM_Register_Enumerator      PREPEND(_CONFIGMG_Register_Enumerator)
#define CM_Register_Arbitrator      PREPEND(_CONFIGMG_Register_Arbitrator)
#define CM_Deregister_Arbitrator    PREPEND(_CONFIGMG_Deregister_Arbitrator)
#define CM_Query_Arbitrator_Free_Size   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Size)
#define CM_Query_Arbitrator_Free_Data   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Data)
#define CM_Sort_NodeList        PREPEND(_CONFIGMG_Sort_NodeList)
#define CM_Yield            PREPEND(_CONFIGMG_Yield)
#define CM_Lock             PREPEND(_CONFIGMG_Lock)
#define CM_Unlock           PREPEND(_CONFIGMG_Unlock)
#define CM_Add_Empty_Log_Conf       PREPEND(_CONFIGMG_Add_Empty_Log_Conf)
#define CM_Free_Log_Conf        PREPEND(_CONFIGMG_Free_Log_Conf)
#define CM_Get_First_Log_Conf       PREPEND(_CONFIGMG_Get_First_Log_Conf)
#define CM_Get_Next_Log_Conf        PREPEND(_CONFIGMG_Get_Next_Log_Conf)
#define CM_Add_Res_Des          PREPEND(_CONFIGMG_Add_Res_Des)
#define CM_Modify_Res_Des       PREPEND(_CONFIGMG_Modify_Res_Des)
#define CM_Free_Res_Des         PREPEND(_CONFIGMG_Free_Res_Des)
#define CM_Get_Next_Res_Des     PREPEND(_CONFIGMG_Get_Next_Res_Des)
#define CM_Get_Res_Des_Header_Size  PREPEND(_CONFIGMG_Get_Res_Des_Header_Size)
#define CM_Get_Res_Des_Data_Size    PREPEND(_CONFIGMG_Get_Res_Des_Data_Size)
#define CM_Get_Res_Des_Data     PREPEND(_CONFIGMG_Get_Res_Des_Data)
#define CM_Process_Events_Now       PREPEND(_CONFIGMG_Process_Events_Now)
#define CM_Create_Range_List        PREPEND(_CONFIGMG_Create_Range_List)
#define CM_Add_Range            PREPEND(_CONFIGMG_Add_Range)
#define CM_Delete_Range         PREPEND(_CONFIGMG_Delete_Range)
#define CM_Test_Range_Available     PREPEND(_CONFIGMG_Test_Range_Available)
#define CM_Dup_Range_List       PREPEND(_CONFIGMG_Dup_Range_List)
#define CM_Free_Range_List      PREPEND(_CONFIGMG_Free_Range_List)
#define CM_Invert_Range_List        PREPEND(_CONFIGMG_Invert_Range_List)
#define CM_Intersect_Range_List     PREPEND(_CONFIGMG_Intersect_Range_List)
#define CM_First_Range          PREPEND(_CONFIGMG_First_Range)
#define CM_Next_Range           PREPEND(_CONFIGMG_Next_Range)
#define CM_Dump_Range_List      PREPEND(_CONFIGMG_Dump_Range_List)
#define CM_Load_DLVxDs          PREPEND(_CONFIGMG_Load_DLVxDs)
#define CM_Get_DDBs         PREPEND(_CONFIGMG_Get_DDBs)
#define CM_Get_CRC_CheckSum     PREPEND(_CONFIGMG_Get_CRC_CheckSum)
#define CM_Register_DevLoader       PREPEND(_CONFIGMG_Register_DevLoader)
#define CM_Reenumerate_DevNode      PREPEND(_CONFIGMG_Reenumerate_DevNode)
#define CM_Setup_DevNode        PREPEND(_CONFIGMG_Setup_DevNode)
#define CM_Reset_Children_Marks     PREPEND(_CONFIGMG_Reset_Children_Marks)
#define CM_Get_DevNode_Status       PREPEND(_CONFIGMG_Get_DevNode_Status)
#define CM_Remove_Unmarked_Children PREPEND(_CONFIGMG_Remove_Unmarked_Children)
#define CM_ISAPNP_To_CM         PREPEND(_CONFIGMG_ISAPNP_To_CM)
#define CM_CallBack_Device_Driver   PREPEND(_CONFIGMG_CallBack_Device_Driver)
#define CM_CallBack_Enumerator      PREPEND(_CONFIGMG_CallBack_Enumerator)
#define CM_Get_Alloc_Log_Conf       PREPEND(_CONFIGMG_Get_Alloc_Log_Conf)
#define CM_Get_DevNode_Key_Size     PREPEND(_CONFIGMG_Get_DevNode_Key_Size)
#define CM_Get_DevNode_Key      PREPEND(_CONFIGMG_Get_DevNode_Key)
#define CM_Read_Registry_Value      PREPEND(_CONFIGMG_Read_Registry_Value)
#define CM_Write_Registry_Value     PREPEND(_CONFIGMG_Write_Registry_Value)
#define CM_Disable_DevNode      PREPEND(_CONFIGMG_Disable_DevNode)
#define CM_Enable_DevNode       PREPEND(_CONFIGMG_Enable_DevNode)
#define CM_Move_DevNode         PREPEND(_CONFIGMG_Move_DevNode)
#define CM_Set_Bus_Info         PREPEND(_CONFIGMG_Set_Bus_Info)
#define CM_Get_Bus_Info         PREPEND(_CONFIGMG_Get_Bus_Info)
#define CM_Set_HW_Prof          PREPEND(_CONFIGMG_Set_HW_Prof)
#define CM_Recompute_HW_Prof        PREPEND(_CONFIGMG_Recompute_HW_Prof)
#define CM_Get_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Get_Device_Driver_Private_DWord)
#define CM_Set_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Set_Device_Driver_Private_DWord)
#define CM_Query_Change_HW_Prof     PREPEND(_CONFIGMG_Query_Change_HW_Prof)
#define CM_Get_HW_Prof_Flags        PREPEND(_CONFIGMG_Get_HW_Prof_Flags)
#define CM_Set_HW_Prof_Flags        PREPEND(_CONFIGMG_Set_HW_Prof_Flags)
#define CM_Read_Registry_Log_Confs  PREPEND(_CONFIGMG_Read_Registry_Log_Confs)
#define CM_Run_Detection        PREPEND(_CONFIGMG_Run_Detection)
#define CM_Call_At_Appy_Time        PREPEND(_CONFIGMG_Call_At_Appy_Time)
#define CM_Fail_Change_HW_Prof      PREPEND(_CONFIGMG_Fail_Change_HW_Prof)
#define CM_Set_Private_Problem      PREPEND(_CONFIGMG_Set_Private_Problem)
#define CM_Debug_DevNode        PREPEND(_CONFIGMG_Debug_DevNode)
#define CM_Get_Hardware_Profile_Info    PREPEND(_CONFIGMG_Get_Hardware_Profile_Info)
#define CM_Register_Enumerator_Function PREPEND(_CONFIGMG_Register_Enumerator_Function)
#define CM_Call_Enumerator_Function     PREPEND(_CONFIGMG_Call_Enumerator_Function)
#define CM_Add_ID                       PREPEND(_CONFIGMG_Add_ID)
#define CM_Find_Range                   PREPEND(_CONFIGMG_Find_Range)
#define CM_Get_Global_State             PREPEND(_CONFIGMG_Get_Global_State)
#define CM_Broadcast_Device_Change_Message      PREPEND(_CONFIGMG_Broadcast_Device_Change_Message)
#define CM_Call_DevNode_Handler         PREPEND(_CONFIGMG_Call_DevNode_Handler)
#define CM_Remove_Reinsert_All                  PREPEND(_CONFIGMG_Remove_Reinsert_All)
//
// OPK2 Services
//
#define CM_Change_DevNode_Status        PREPEND(_CONFIGMG_Change_DevNode_Status)
#define CM_Reprocess_DevNode            PREPEND(_CONFIGMG_Reprocess_DevNode)
#define CM_Assert_Structure             PREPEND(_CONFIGMG_Assert_Structure)
#define CM_Discard_Boot_Log_Conf        PREPEND(_CONFIGMG_Discard_Boot_Log_Conf)
#define CM_Set_Dependent_DevNode        PREPEND(_CONFIGMG_Set_Dependent_DevNode)
#define CM_Get_Dependent_DevNode        PREPEND(_CONFIGMG_Get_Dependent_DevNode)
#define CM_Refilter_DevNode             PREPEND(_CONFIGMG_Refilter_DevNode)
#define CM_Merge_Range_List             PREPEND(_CONFIGMG_Merge_Range_List);
#define CM_Substract_Range_List         PREPEND(_CONFIGMG_Substract_Range_List);
#define	CM_Set_DevNode_PowerState	PREPEND(_CONFIGMG_Set_DevNode_PowerState)
#define	CM_Get_DevNode_PowerState	PREPEND(_CONFIGMG_Get_DevNode_PowerState)
#define	CM_Set_DevNode_PowerCapabilities	PREPEND(_CONFIGMG_Set_DevNode_PowerCapabilities)
#define	CM_Get_DevNode_PowerCapabilities	PREPEND(_CONFIGMG_Get_DevNode_PowerCapabilities)
#define	CM_Read_Range_List		PREPEND(_CONFIGMG_Read_Range_List)
#define	CM_Write_Range_List		PREPEND(_CONFIGMG_Write_Range_List)
#define	CM_Get_Set_Log_Conf_Priority	PREPEND(_CONFIGMG_Get_Set_Log_Conf_Priority)
#define	CM_Support_Share_Irq		PREPEND(_CONFIGMG_Support_Share_Irq)
#define	CM_Get_Parent_Structure		PREPEND(_CONFIGMG_Get_Parent_Structure)
//
// 4.1 Services
//
#define	CM_Register_DevNode_For_Idle_Detection	PREPEND(_CONFIGMG_Register_DevNode_For_Idle_Detection)
#define	CM_CM_To_ISAPNP				PREPEND(_CONFIGMG_CM_To_ISAPNP)
#define	CM_Get_DevNode_Handler			PREPEND(_CONFIGMG_Get_DevNode_Handler)
#define	CM_Detect_Resource_Conflict		PREPEND(_CONFIGMG_Detect_Resource_Conflict)
#define	CM_Get_Interface_Device_List		PREPEND(_CONFIGMG_Get_Interface_Device_List)
#define	CM_Get_Interface_Device_List_Size	PREPEND(_CONFIGMG_Get_Interface_Device_List_Size)
#define	CM_Get_Conflict_Info			PREPEND(_CONFIGMG_Get_Conflict_Info)
#define	CM_Add_Remove_DevNode_Property		PREPEND(_CONFIGMG_Add_Remove_DevNode_Property)
#define	CM_CallBack_At_Appy_Time		PREPEND(_CONFIGMG_CallBack_At_Appy_Time)
#define	CM_Register_Interface_Device		PREPEND(_CONFIGMG_Register_Interface_Device)
#define	CM_System_Device_Power_State_Mapping	PREPEND(_CONFIGMG_System_Device_Power_State_Mapping)
#define	CM_Get_Arbitrator_Info			PREPEND(_CONFIGMG_Get_Arbitrator_Info)
#define	CM_Waking_Up_From_DevNode		PREPEND(_CONFIGMG_Waking_Up_From_DevNode)
#define	CM_Set_DevNode_Problem			PREPEND(_CONFIGMG_Set_DevNode_Problem)

#ifdef _VCOMM_H
#define VCOMM_Register_Port_Driver      PREPEND(_VCOMM_Register_Port_Driver)
#define VCOMM_Acquire_Port              PREPEND(_VCOMM_Acquire_Port)
#define VCOMM_Release_Port              PREPEND(_VCOMM_Release_Port)
#define VCOMM_OpenComm                  PREPEND(_VCOMM_OpenComm)
#define VCOMM_SetCommState              PREPEND(_VCOMM_SetCommState)
#define VCOMM_GetCommState              PREPEND(_VCOMM_GetCommState)
#define VCOMM_SetupComm                 PREPEND(_VCOMM_SetupComm)
#define VCOMM_TransmitCommChar          PREPEND(_VCOMM_TransmitCommChar)
#define VCOMM_CloseComm                 PREPEND(_VCOMM_CloseComm)
#define VCOMM_GetCommQueueStatus        PREPEND(_VCOMM_GetCommQueueStatus)
#define VCOMM_ClearCommError            PREPEND(_VCOMM_ClearCommError)
#define VCOMM_GetModemStatus            PREPEND(_VCOMM_GetModemStatus)
#define VCOMM_GetCommProperties         PREPEND(_VCOMM_GetCommProperties)
#define VCOMM_EscapeCommFunction        PREPEND(_VCOMM_EscapeCommFunction)
// #define VCOMM_DeviceIOControl           PREPEND(_VCOMM_DeviceIOControl)
#define VCOMM_PurgeComm                 PREPEND(_VCOMM_PurgeComm)
#define VCOMM_SetCommEventMask          PREPEND(_VCOMM_SetCommEventMask)
#define VCOMM_GetCommEventMask          PREPEND(_VCOMM_GetCommEventMask)
#define VCOMM_WriteComm                 PREPEND(_VCOMM_WriteComm)
#define VCOMM_ReadComm                  PREPEND(_VCOMM_ReadComm)
#define VCOMM_EnableCommNotification    PREPEND(_VCOMM_EnableCommNotification)
#define VCOMM_GetLastError              PREPEND(_VCOMM_GetLastError)
#define VCOMM_Steal_Port                PREPEND(_VCOMM_Steal_Port)
#define VCOMM_SetReadCallBack           PREPEND(_VCOMM_SetReadCallBack)
#define VCOMM_SetWriteCallBack          PREPEND(_VCOMM_SetWriteCallBack)
#define VCOMM_Add_Port                  PREPEND(_VCOMM_Add_Port)

#ifndef WIN31COMPAT
#define VCOMM_GetSetCommTimeouts        PREPEND(_VCOMM_GetSetCommTimeouts)
#define VCOMM_SetWriteRequest           PREPEND(_VCOMM_SetWriteRequest)
#define VCOMM_SetReadRequest            PREPEND(_VCOMM_SetReadRequest)
#define VCOMM_Dequeue_Request           PREPEND(_VCOMM_Dequeue_Request)
#define VCOMM_Enumerate_DevNodes        PREPEND(_VCOMM_Enumerate_DevNodes)
#define VCOMM_Get_Contention_Handler    PREPEND(_VCOMM_Get_Contention_Handler)
#define VCOMM_Map_Name_To_Resource  PREPEND(_VCOMM_Map_Name_To_Resource)
#endif
#endif // _VCOMM_H

#ifdef      _IRS_H
#define IOS_Requestor_Service       PREPEND(IOS_Requestor_Service)
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

#define _VPOWERD_Get_APM_BIOS_Version       PREPEND(_VPOWERD_Get_APM_BIOS_Version)
#define _VPOWERD_Get_Power_Management_Level PREPEND(_VPOWERD_Get_Power_Management_Level)
#define _VPOWERD_Set_Power_Management_Level PREPEND(_VPOWERD_Set_Power_Management_Level)
#define _VPOWERD_Set_Device_Power_State     PREPEND(_VPOWERD_Set_Device_Power_State)
#define _VPOWERD_Set_System_Power_State     PREPEND(_VPOWERD_Set_System_Power_State)
#define _VPOWERD_Restore_Power_On_Defaults  PREPEND(_VPOWERD_Restore_Power_On_Defaults)
#define _VPOWERD_Get_Power_Status       PREPEND(_VPOWERD_Get_Power_Status)
#define	_VPOWERD_Transfer_Control	PREPEND(_VPOWERD_Transfer_Control)
#define _VPOWERD_Get_Power_State        PREPEND(_VPOWERD_Get_Power_State)
#define _VPOWERD_OEM_APM_Function       PREPEND(_VPOWERD_OEM_APM_Function)
#define _VPOWERD_Register_Power_Handler     PREPEND(_VPOWERD_Register_Power_Handler)
#define _VPOWERD_Deregister_Power_Handler   PREPEND(_VPOWERD_Deregister_Power_Handler)

#endif      // _INC_VPOWERD

#ifdef _VDMAD_H_
#define VDMAD_Get_Phys_Count    PREPEND(VDMAD_Get_Phys_Count)
#define VDMAD_Phys_Mask_Channel PREPEND(VDMAD_Phys_Mask_Channel)
#define VDMAD_Phys_Unmask_Channel PREPEND(VDMAD_Phys_Unmask_Channel)
#define VDMAD_Set_Phys_State PREPEND(VDMAD_Set_Phys_State)
#define VDMAD_Set_Region_Info PREPEND(VDMAD_Set_Region_Info)
#define VDMAD_Unvirtualize_Channel PREPEND(VDMAD_Unvirtualize_Channel)
#define VDMAD_Virtualize_Channel PREPEND(VDMAD_Virtualize_Channel)
#endif // _VDMAD_H_

#ifdef  USECMDWRAPPERS

struct _CMDDEBUGCOMMAND {
	CHAR    cLetter;
	VOID    (_cdecl *pFunction)(VOID);
	PCHAR   pszShortName;
	PCHAR   pszExplanation;
};

typedef struct _CMDDEBUGCOMMAND CMDDC;
typedef CMDDC                   *PCMDDC;

#define CMDD            _Debug_Printf_Service
#define CMD_LOCAL       _fastcall

/****************************************************************************
 *
 *      CMDInChar - Get a character from the debug terminal
 *
 *      ENTRY:  None.
 *
 *      EXIT:   ASCII character.
 *
 ***************************************************************************/
CHAR CMD_LOCAL
CMDInChar(VOID);

/****************************************************************************
 *
 *      CMDMenu - Display standard menu
 *
 *      ENTRY:  pszVxDName is the name of the VxD which wants this debugger.
 *
 *              pdcDebugCommands are the various debug commands.
 *
 *      EXIT:   None.
 *
 ***************************************************************************/
VOID CMD_LOCAL
CMDMenu(PCHAR pszVxDName, PCMDDC pdcDebugCommands);

/****************************************************************************
 *
 *      CMDReadNumber - Returns an hex number read from the debug terminal
 *
 *      ENTRY:  pszQuestion is the prompt (can be NULL).
 *
 *              bNumDigits is the number of hex digits of maximum input (1-8).
 *
 *              fAppendCrLf is TRUE if a carriage return is wanted after the
 *              input.
 *
 *      EXIT:   A DWORD being the inputted value.
 *
 ***************************************************************************/
DWORD CMD_LOCAL
CMDReadNumber(PCHAR pszQuestion, BYTE bNumDigits, BOOL fAppendCrLf);

/***LP  CMDGetString - Read a string from the debug terminal
 *
 *  ENTRY
 *      pszPrompt -> prompt string
 *      pszBuff -> buffer to hold the string
 *      dwcbLen - buffer length
 *      fUpper - TRUE if convert to upper case
 *
 *  EXIT
 *      returns the number of characters read including the terminating newline.
 */
DWORD CMD_LOCAL
CMDGetString(PCHAR pszPrompt, PCHAR pszBuff, DWORD dwcbLen, BOOL fUpper);

#endif  // USECMDWRAPPERS

#endif  // _VXDWRAPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\download\dlcache.h ===
/********************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    dlcache.h

Revision History:
    DerekM  created  11/26/01

********************************************************************/

#ifndef DLCACHE_H
#define DLCACHE_H

#if defined(UNICODE)

#include <tchar.h>
#include <dllite.h>

const DWORD c_dwProxyCacheTimeLimit = 60 * 60 * 1000; // 1h

struct SWUDLProxyCacheObj
{
    LPWSTR  wszSrv;
    LPWSTR  wszProxy;
    LPWSTR  wszBypass;
    DWORD   dwAccessType;
    DWORD   cbProxy;
    DWORD   cbBypass;
    DWORD   dwLastCacheTime;
    DWORD   iLastKnownGood;

    SWUDLProxyCacheObj *pNext;
};

class CWUDLProxyCache
{
private:
    SWUDLProxyCacheObj   *m_rgpObj;

    SWUDLProxyCacheObj *internalFind(LPCWSTR wszSrv);

public:
    CWUDLProxyCache();
    ~CWUDLProxyCache();

    BOOL    Set(LPCWSTR wszSrv, LPCWSTR wszProxy, LPCWSTR wszBypass, 
                DWORD dwAccessType);
    BOOL    Find(LPCWSTR wszSrv, LPWSTR *pwszProxy, LPWSTR *pwszBypass, 
                DWORD *pdwAccessType);
    BOOL    SetLastGoodProxy(LPCWSTR wszSrv, DWORD iProxy);
    BOOL    GetLastGoodProxy(LPCWSTR wszSrv, SAUProxySettings *paups);
    BOOL    Empty(void);
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\detect\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	detect
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.util

TARGETNAME=detect
# TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;$(WINDOWS_COM)\inc;

SOURCES= \
	..\osdet.cpp	\
	..\findoem.cpp	\
	..\osdetutl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\download\dlcache.cpp ===
/********************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    pcache.cpp

Revision History:
    DerekM  created  11/26/01

********************************************************************/

#if defined(UNICODE)

#include <windows.h>
#include "dlcache.h"
#include <strsafe.h>
#include <mistsafe.h>

// **************************************************************************
inline 
DWORD RolloverSubtract(DWORD dwA, DWORD dwB)
{
    return (dwA >= dwB) ? (dwA - dwB) : (dwA + ((DWORD)-1 - dwB));
}

// **************************************************************************
CWUDLProxyCache::CWUDLProxyCache()
{
    m_rgpObj  = NULL;
}

// **************************************************************************
CWUDLProxyCache::~CWUDLProxyCache()
{
    this->Empty();
}

// **************************************************************************
SWUDLProxyCacheObj *CWUDLProxyCache::internalFind(LPCWSTR wszSrv)
{
    SWUDLProxyCacheObj   *pObj = m_rgpObj;
    SWUDLProxyCacheObj   **ppNextPtr = &m_rgpObj;
    
    // see if it exists
    while(pObj != NULL)
    {
        if (pObj->wszSrv != NULL && _wcsicmp(pObj->wszSrv, wszSrv) == 0)
        {
            // detach it from the list
            *ppNextPtr  = pObj->pNext;
            pObj->pNext = NULL; 
            break;
        }

        ppNextPtr = &pObj->pNext;
        pObj      = pObj->pNext;
    }

    return pObj;    
}

// **************************************************************************
BOOL CWUDLProxyCache::Set(LPCWSTR wszSrv, LPCWSTR wszProxy, LPCWSTR wszBypass, 
                          DWORD dwAccessType)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    HRESULT             hr = NOERROR;
    DWORD               cbProxy = 0, cbBypass = 0, cbSrv, cbNeed;
    BOOL                fRet = FALSE;

    if (wszSrv == NULL || *wszSrv == L'\0')
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    cbSrv  = (wcslen(wszSrv) + 1) * sizeof(WCHAR);
    cbNeed = cbSrv + sizeof(SWUDLProxyCacheObj);

    if (wszProxy != NULL)
    {
        cbProxy = (wcslen(wszProxy) + 1) * sizeof(WCHAR);
        cbNeed  += cbProxy;
        
        if (wszBypass != NULL)
        {
            cbBypass = (wcslen(wszBypass) + 1) * sizeof(WCHAR);
            cbNeed   += cbBypass;
        }
    }    


    // Now, in theory, we should look for an existing object in the list for this
    //  server, but a couple things make it unnecessary:
    //  1. we only use this class in one place
    //  2. we will always attempt a find first
    //  3. we will only get to this function if find returns NULL
    //  4. if one exists, but it's outdated, find will delete it and return NULL
    // 
    // Given the above, there should never be an existing object when Set is
    //  called.

    pObj = (SWUDLProxyCacheObj *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                                           cbNeed);
    if (pObj == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // set up pointers into the blob for the strings & copy the data down
    pObj->wszSrv = (LPWSTR)((LPBYTE)pObj + sizeof(SWUDLProxyCacheObj));
    hr = StringCbCopyExW(pObj->wszSrv, cbSrv, wszSrv, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        goto done;
    }

    if (wszProxy != NULL)
    {
        pObj->wszProxy  = (LPWSTR)((LPBYTE)pObj->wszSrv + cbSrv);
        hr = StringCbCopyExW(pObj->wszProxy, cbProxy, wszProxy, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
        
        if (wszBypass != NULL)
        {
            pObj->wszBypass = (LPWSTR)((LPBYTE)pObj->wszProxy + cbProxy);
            hr = StringCbCopyExW(pObj->wszBypass, cbBypass, wszBypass, 
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                SetLastError(HRESULT_CODE(hr));
                goto done;
            }
        }
    }

    
    pObj->dwLastCacheTime = GetTickCount();
    pObj->dwAccessType    = dwAccessType;
    pObj->cbBypass        = cbBypass;
    pObj->cbProxy         = cbProxy;
    pObj->iLastKnownGood  = (DWORD)-1;
    
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;
    pObj        = NULL;

    fRet = TRUE;

done:
    if (pObj != NULL)
        HeapFree(GetProcessHeap(), 0, pObj);
    
    return fRet;
}

// **************************************************************************
BOOL CWUDLProxyCache::Find(LPCWSTR wszSrv, LPWSTR *pwszProxy, LPWSTR *pwszBypass, 
                           DWORD *pdwAccessType)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    HRESULT             hr = NOERROR;
    LPWSTR              wszProxy = NULL;
    LPWSTR              wszBypass = NULL;
    DWORD               dwNow;
    BOOL                fRet = FALSE, fFreeObjMemory = FALSE;
    
    if (wszSrv == NULL || pwszProxy == NULL || pwszBypass == NULL || 
        pdwAccessType == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *pdwAccessType  = 0;
    *pwszBypass     = NULL;
    *pwszProxy      = NULL;

    // does it exist?
    pObj = this->internalFind(wszSrv);
    if (pObj == NULL)
        goto done;

    // has the object expired?
    dwNow = GetTickCount();
    if (RolloverSubtract(dwNow, pObj->dwLastCacheTime) > c_dwProxyCacheTimeLimit)
    {
        fFreeObjMemory = TRUE;
        goto done;
    }

    // reset object to front of list
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;


    // need to use GloablAlloc here cuz that's what WinHttp uses and we need 
    //  to match it
    if (pObj->cbBypass > 0 && pObj->wszBypass != NULL)
    {
        wszBypass = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbBypass);
        if (wszBypass == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        hr = StringCbCopyExW(wszBypass, pObj->cbBypass, pObj->wszBypass, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    if (pObj->cbProxy > 0 && pObj->wszProxy != NULL)
    {
        wszProxy = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbProxy);
        if (wszProxy == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }
        
        hr = StringCbCopyExW(wszProxy, pObj->cbProxy, pObj->wszProxy, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    *pdwAccessType  = pObj->dwAccessType;
    *pwszBypass     = wszBypass;
    *pwszProxy      = wszProxy;

    wszBypass       = NULL;
    wszProxy        = NULL;
    pObj            = NULL;

    fRet = TRUE;
    
done:
    if (fFreeObjMemory && pObj != NULL)
        HeapFree(GetProcessHeap(), 0, pObj);
    if (wszProxy != NULL)
        GlobalFree(wszProxy);
    if (wszBypass != NULL)
        GlobalFree(wszBypass);
    
    return fRet;    
}

// **************************************************************************
BOOL CWUDLProxyCache::SetLastGoodProxy(LPCWSTR wszSrv, DWORD iProxy)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    BOOL                fRet = FALSE;

    // does it exist?
    pObj = this->internalFind(wszSrv);
    if (pObj == NULL)
        goto done;

    // reset object to front of list
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;

    pObj->iLastKnownGood = iProxy;

    fRet = TRUE;

done:
    return fRet;
}

// **************************************************************************
BOOL CWUDLProxyCache::GetLastGoodProxy(LPCWSTR wszSrv, SAUProxySettings *paups)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    HRESULT             hr = NOERROR;
    LPWSTR              wszBypass = NULL, wszProxy = NULL;
    BOOL                fRet = FALSE;

    if (wszSrv == NULL || paups == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // does it exist?
    pObj = this->internalFind(wszSrv);
    if (pObj == NULL)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        goto done;
    }

    // reset object to front of list
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;

    // need to use GloablAlloc here cuz that's what WinHttp uses and we need 
    //  to match it
    if (pObj->cbBypass > 0 && pObj->wszBypass != NULL)
    {
        wszBypass = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbBypass);
        if (wszBypass == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }
        
        hr = StringCbCopyExW(wszBypass, pObj->cbBypass, pObj->wszBypass, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    if (pObj->cbProxy > 0 && pObj->wszProxy != NULL)
    {
        wszProxy = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbProxy);
        if (wszProxy == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }
        
        hr = StringCbCopyExW(wszProxy, pObj->cbProxy, pObj->wszProxy, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    ZeroMemory(paups, sizeof(SAUProxySettings));

    paups->dwAccessType = pObj->dwAccessType;
    paups->wszBypass    = wszBypass;
    paups->wszProxyOrig = wszProxy;
    paups->iProxy       = pObj->iLastKnownGood;

    wszBypass       = NULL;
    wszProxy        = NULL;

    fRet = TRUE;
    
done:
    if (wszProxy != NULL)
        GlobalFree(wszProxy);
    if (wszBypass != NULL)
        GlobalFree(wszBypass);
    
    return fRet;    


    
}

// **************************************************************************
BOOL CWUDLProxyCache::Empty(void)
{
    SWUDLProxyCacheObj  *pObj = m_rgpObj;

    while (pObj != NULL)
    {
        m_rgpObj = pObj->pNext;
        HeapFree(GetProcessHeap(), 0, pObj);
        pObj = m_rgpObj;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\download\dlutil.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    dlutil.h

Abstract:
    header for download library

******************************************************************************/

#ifndef DLUTIL_H
#define DLUTIL_H

#include <strsafe.h>
#include <wusafefn.h>
#include <mistsafe.h>

///////////////////////////////////////////////////////////////////////////////
// const defines & typedefs

#define UNLEN 256

// need to define this here cuz winhttp.h doesn't define it and we get dupe 
//  definitions if we try to include wininet.h just to get it.
#ifndef INTERNET_MAX_URL_LENGTH
#define INTERNET_MAX_URL_LENGTH  2200
#endif

const DWORD c_cbDownloadBuffer      = 32 * 1024; // 32k
const DWORD c_cbDownloadBufferLite  = 4 * 1024;  // 4k

const DWORD c_dwRetryTimeLimitInmsWinHttp  = 2 * 60 * 1000; // 120s (2m)
const DWORD c_dwRetryTimeLimitInmsWiuInet  = 10 * 1000;       // 10s
const DWORD c_cMaxRetries           = 3;

const WCHAR c_wszUserAgent[]        = L"Industry Update Control";
const char  c_szUserAgent[]         = "Industry Update Control";

const DWORD c_cchMaxURLSize         = INTERNET_MAX_URL_LENGTH;

#ifdef UNICODE
#define c_tszUserAgent c_wszUserAgent
#else
#define c_tszUserAgent c_szUserAgent
#endif

typedef BOOL (__stdcall *pfn_ReadDataFromSite)(HINTERNET, LPVOID, DWORD, LPDWORD);


///////////////////////////////////////////////////////////////////////////////
// macro defines

#define sizeofSTRW(wsz) (sizeof(wsz) / sizeof(WCHAR))
#define sizeofSTRA(sz)  (sizeof(sz))
#define sizeofSTRT(sz)  (sizeof(sz) / sizeof(TCHAR))


///////////////////////////////////////////////////////////////////////////////
// necessary classes

class CAutoCritSec
{
private:
#if defined(DEBUG) || defined(DBG)
    DWORD               m_dwOwningThread;
    DWORD               m_cLocks;
#endif

    CRITICAL_SECTION    m_cs;
    BOOL                m_fInit;

public:
    CAutoCritSec(void)
    {
        m_fInit = WUInitializeCriticalSectionAndSpinCount(&m_cs, 0x8000FA0);
#if defined(DEBUG) || defined(DBG)
        m_cLocks         = 0;
        m_dwOwningThread = 0;
#endif
    }

    ~CAutoCritSec(void)
    {
#if defined(DEBUG) || defined(DBG)
        if (m_cLocks > 0 || m_dwOwningThread != 0)
        {
            // can't do logging here cuz this could be run during DllMain
        }
#endif
        if (m_fInit)
            DeleteCriticalSection(&m_cs);
    }

    BOOL Lock(void)
    {
        LOG_Block("CAutoCritSec::Lock()");
        
        if (m_fInit)
        {
            EnterCriticalSection(&m_cs);
#if defined(DEBUG) || defined(DBG)
            m_cLocks++;
            m_dwOwningThread = GetCurrentThreadId();
#endif
        }
        else
        {
            LOG_Internet(_T("CAutoCritSec not initialized during Lock."));
        }

        return m_fInit;
    }

    BOOL Unlock(void)
    {
        LOG_Block("CAutoCritSec::Unlock()");

        if (m_fInit)
        {
#if defined(DEBUG) || defined(DBG)
            if (m_cLocks == 0)
                LOG_Internet(_T("CAutoCritSec: trying to unlock when lock count is 0"));
            else
                m_cLocks--;

            if (m_dwOwningThread != GetCurrentThreadId())
            {
                LOG_Internet(_T("CAutoCritSec: lock not owned by current thread: Owning thread: %d. Current thread: %d"), 
                             m_dwOwningThread, GetCurrentThreadId());
            }
            
            if (m_cLocks == 0)
                m_dwOwningThread = 0;
#endif        
            LeaveCriticalSection(&m_cs);
        }
        else
        {
            LOG_Internet(_T("CAutoCritSec not initialized during Unlock."));
        }

        return m_fInit;
    }
};


///////////////////////////////////////////////////////////////////////////////
// prototypes

BOOL IsServerFileDifferentW(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                           LPCWSTR wszLocalFile);
BOOL IsServerFileDifferentA(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                           LPCSTR szLocalFile);
#ifdef UNICODE
#define IsServerFileDifferent  IsServerFileDifferentW
#else
#define IsServerFileDifferent  IsServerFileDifferentA
#endif // !UNICODE


HRESULT PerformDownloadToFile(pfn_ReadDataFromSite pfnRead,
                              HINTERNET hRequest, 
                              HANDLE hFile, DWORD cbFile,
                              DWORD cbBuffer,
                              HANDLE *rghEvents, DWORD cEvents,
                              PFNDownloadCallback fpnCallback, LPVOID pCallbackData,
                              DWORD *pcbDownloaded);


HRESULT StartWinInetDownload(HMODULE hmodWinInet,
                             LPCTSTR pszServerUrl, 
                             LPCTSTR pszLocalPath,
                             DWORD *pdwDownloadedBytes,
                             HANDLE *hQuitEvents,
                             UINT nQuitEventCount,
                             PFNDownloadCallback fpnCallback,
                             LPVOID pCallbackData,
                             DWORD dwFlags,
                             DWORD cbDownloadBuffer);

HRESULT IsFileHtml(LPCTSTR pszFileName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\download\dlutil.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <tchar.h>
#include <winhttp.h>
#include "iucommon.h"
#include "logging.h"
#include "download.h"
#include "dlutil.h"
#include "malloc.h"

#include "wusafefn.h"

///////////////////////////////////////////////////////////////////////////////
// 

typedef BOOL  (WINAPI *pfn_OpenProcessToken)(HANDLE, DWORD, PHANDLE);
typedef BOOL  (WINAPI *pfn_OpenThreadToken)(HANDLE, DWORD, BOOL, PHANDLE);
typedef BOOL  (WINAPI *pfn_SetThreadToken)(PHANDLE, HANDLE);
typedef BOOL  (WINAPI *pfn_GetTokenInformation)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD);
typedef BOOL  (WINAPI *pfn_IsValidSid)(PSID);
typedef BOOL  (WINAPI *pfn_AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, PSID);
typedef BOOL  (WINAPI *pfn_EqualSid)(PSID, PSID);
typedef PVOID (WINAPI *pfn_FreeSid)(PSID);

const TCHAR c_szRPWU[]        = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate");
const TCHAR c_szRVTransport[] = _T("DownloadTransport");
const TCHAR c_szAdvapi32[]    = _T("advapi32.dll");

// ***************************************************************************
static
BOOL AmIPrivileged(void)
{
    LOG_Block("AmINotPrivileged()");

    pfn_AllocateAndInitializeSid    pfnAllocateAndInitializeSid = NULL;
    pfn_GetTokenInformation         pfnGetTokenInformation = NULL;
    pfn_OpenProcessToken            pfnOpenProcessToken = NULL;
    pfn_OpenThreadToken             pfnOpenThreadToken = NULL;
    pfn_SetThreadToken              pfnSetThreadToken = NULL;
    pfn_IsValidSid                  pfnIsValidSid = NULL;
    pfn_EqualSid                    pfnEqualSid = NULL;
    pfn_FreeSid                     pfnFreeSid = NULL;
    HMODULE                         hmod = NULL;
    
    SID_IDENTIFIER_AUTHORITY        siaNT = SECURITY_NT_AUTHORITY;
    TOKEN_USER                      *ptu = NULL;
    HANDLE                          hToken = NULL, hTokenImp = NULL;
    DWORD                           cb, cbGot, i;
    PSID                            psid = NULL;
    BOOL                            fRet = FALSE;

    DWORD                           rgRIDs[3] = { SECURITY_LOCAL_SYSTEM_RID,
                                                  SECURITY_LOCAL_SERVICE_RID,
                                                  SECURITY_NETWORK_SERVICE_RID };

    hmod = LoadLibraryFromSystemDir(c_szAdvapi32);
    if (hmod == NULL)
        goto done;

    pfnAllocateAndInitializeSid = (pfn_AllocateAndInitializeSid)GetProcAddress(hmod, "AllocateAndInitializeSid");
    pfnGetTokenInformation      = (pfn_GetTokenInformation)GetProcAddress(hmod, "GetTokenInformation");
    pfnOpenProcessToken         = (pfn_OpenProcessToken)GetProcAddress(hmod, "OpenProcessToken");
    pfnOpenThreadToken          = (pfn_OpenThreadToken)GetProcAddress(hmod, "OpenThreadToken");
    pfnSetThreadToken           = (pfn_SetThreadToken)GetProcAddress(hmod, "SetThreadToken");
    pfnIsValidSid               = (pfn_IsValidSid)GetProcAddress(hmod, "IsValidSid");
    pfnEqualSid                 = (pfn_EqualSid)GetProcAddress(hmod, "EqualSid");
    pfnFreeSid                  = (pfn_FreeSid)GetProcAddress(hmod, "FreeSid");
    if (pfnAllocateAndInitializeSid == NULL || 
        pfnGetTokenInformation == NULL || 
        pfnOpenProcessToken == NULL ||
        pfnOpenThreadToken == NULL ||
        pfnSetThreadToken == NULL ||
        pfnIsValidSid == NULL ||
        pfnEqualSid == NULL ||
        pfnFreeSid == NULL)
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        goto done;
    }

    // need the process token
    fRet = (*pfnOpenProcessToken)(GetCurrentProcess(), TOKEN_READ, &hToken);
    if (fRet == FALSE)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            fRet = (*pfnOpenThreadToken)(GetCurrentThread(), 
                                         TOKEN_READ | TOKEN_IMPERSONATE,
                                         TRUE, &hTokenImp);
            if (fRet == FALSE)
                goto done;

            fRet = (*pfnSetThreadToken)(NULL, NULL);

            fRet = (*pfnOpenProcessToken)(GetCurrentProcess(), TOKEN_READ, 
                                          &hToken);
            if ((*pfnSetThreadToken)(NULL, hTokenImp) == FALSE)
                fRet = FALSE;
        }

        if (fRet == FALSE)
            goto done;
    }

    // need the SID from the token
    fRet = (*pfnGetTokenInformation)(hToken, TokenUser, NULL, 0, &cb);
    if (fRet != FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        fRet = FALSE;
        goto done;
    }

    ptu = (TOKEN_USER *)HeapAlloc(GetProcessHeap(), 0, cb);
    if (ptu == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto done;
    }

    fRet = (*pfnGetTokenInformation)(hToken, TokenUser, (LPVOID)ptu, cb, 
                                     &cbGot);
    if (fRet == FALSE)
        goto done;

    fRet = (*pfnIsValidSid)(ptu->User.Sid);
    if (fRet == FALSE)
        goto done;

    // loop thru & check against the SIDs we are interested in
    for (i = 0; i < 3; i++)
    {
        fRet = (*pfnAllocateAndInitializeSid)(&siaNT, 1, rgRIDs[i], 0, 0, 0, 
                                              0, 0, 0, 0, &psid);
        if (fRet == FALSE)
            goto done;

        fRet = (*pfnIsValidSid)(psid);
        if (fRet == FALSE)
            goto done;

        // if we get a SID match, then return TRUE
        fRet = (*pfnEqualSid)(psid, ptu->User.Sid);
        (*pfnFreeSid)(psid);
        psid = NULL;
        if (fRet)
        {
            fRet = TRUE;
            goto done;
        }
    }

    // only way to get here is to fail all the SID checks above.  So we ain't
    //  privileged.  Yeehaw.
    fRet = FALSE;
    
done:
    // if we had an impersonation token on the thread, put it back in place.
    if (ptu != NULL)
        HeapFree(GetProcessHeap(), 0, ptu);
    if (hToken != NULL)
        CloseHandle(hToken);
    if (hTokenImp != NULL)
        CloseHandle(hTokenImp);
    if (psid != NULL && pfnFreeSid != NULL)
        (*pfnFreeSid)(psid);
    if (hmod != NULL)
        FreeLibrary(hmod);

    return fRet;
}

#if defined(DEBUG) || defined(DBG)

// **************************************************************************
static
BOOL CheckDebugRegKey(DWORD *pdwAllowed)
{
    LOG_Block("CheckDebugRegKey()");

    DWORD   dw, dwType, dwValue, cb;
    HKEY    hkey = NULL;
    BOOL    fRet = FALSE;

    // explictly do not initialize *pdwAllowed.  We only want it overwritten
    //  if the reg key is properly set

    dw = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRPWU, 0, KEY_READ, &hkey);
    if (dw != ERROR_SUCCESS)
        goto done;

    cb = sizeof(dwValue);
    dw = RegQueryValueEx(hkey, c_szRVTransport, 0, &dwType, (LPBYTE)&dwValue, 
                         &cb);
    if (dw != ERROR_SUCCESS)
        goto done;

    // set this to 3 so we'll fall down into the error case below
    if (dwType != REG_DWORD)
        dwValue = 3;
    
    fRet = TRUE;

    switch(dwValue)
    {
        case 0:
            *pdwAllowed = 0;
            break;

        case 1:
            *pdwAllowed = WUDF_ALLOWWINHTTPONLY;
            break;

        case 2:
            *pdwAllowed = WUDF_ALLOWWININETONLY;
            break;

        default:
            LOG_Internet(_T("Bad reg value in DownloadTransport.  Ignoring."));
            fRet = FALSE;
            break;
    }

done:
    if (hkey != NULL)
        RegCloseKey(hkey);

    return fRet;
}

#endif

// **************************************************************************
DWORD GetAllowedDownloadTransport(DWORD dwFlagsInitial)
{
    DWORD   dwFlags = (dwFlagsInitial & WUDF_TRANSPORTMASK);

#if defined(UNICODE)
    // don't bother checking if we're local system if we're already using
    //  wininet
    if ((dwFlags & WUDF_ALLOWWININETONLY) == 0)
    {
        if (AmIPrivileged() == FALSE)
            dwFlags = WUDF_ALLOWWININETONLY;
    }

#if defined(DEBUG) || defined(DBG)
    CheckDebugRegKey(&dwFlags);
#endif // defined(DEBUG) || defined(DBG)

#else // defined(UNICODE)

    // only allow wininet on ANSI
    dwFlags = WUDF_ALLOWWININETONLY;

#endif // defined(UNICODE)

    return (dwFlags | (dwFlagsInitial & ~WUDF_TRANSPORTMASK));
}

///////////////////////////////////////////////////////////////////////////////
// 

// **************************************************************************
static inline
BOOL IsServerFileDifferentWorker(FILETIME &ftServerTime, 
                                 DWORD dwServerFileSize, HANDLE hFile)
{
    LOG_Block("IsServerFileNewerWorker()");

    FILETIME    ftCreateTime;
    DWORD       cbLocalFile;

    // By default, always return TRUE so we can download a new file..
	BOOL        fRet = TRUE;

    // if we don't have a valid file handle, just return TRUE to download a 
    //  new copy
    if (hFile == INVALID_HANDLE_VALUE)
        goto done;

    cbLocalFile = GetFileSize(hFile, NULL);

	LOG_Internet(_T("IsServerFileNewer: Local size: %d.  Remote size: %d"),
				 cbLocalFile, dwServerFileSize);

    // if the sizes are not equal, then return TRUE
	if (cbLocalFile != dwServerFileSize)
	    goto done;

	if (GetFileTime(hFile, &ftCreateTime, NULL, NULL))
	{
		LOG_Internet(_T("IsServerFileNewer: Local time: %x%0x.  Remote time: %x%0x."),
					 ftCreateTime.dwHighDateTime, ftCreateTime.dwLowDateTime,
					 ftServerTime.dwHighDateTime, ftServerTime.dwLowDateTime);

		// if the local file has a different timestamp, then return TRUE.  
		fRet = (CompareFileTime(&ftCreateTime, &ftServerTime) != 0);
	}

done:
    return fRet;
}

// **************************************************************************
BOOL IsServerFileDifferentW(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                            LPCWSTR wszLocalFile)
{
    LOG_Block("IsServerFileDifferentW()");

    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    fRet = TRUE;

    // if we have an error opening the file, just return TRUE to download a 
    //  new copy
    hFile = CreateFileW(wszLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        LOG_Internet(_T("IsServerFileDifferent: %ls does not exist."), wszLocalFile);
        return TRUE;
    }
    else
    {
        fRet = IsServerFileDifferentWorker(ftServerTime, dwServerFileSize, hFile);
        CloseHandle(hFile);
        return fRet;
    }
}

// **************************************************************************
BOOL IsServerFileDifferentA(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                            LPCSTR szLocalFile)
{
    LOG_Block("IsServerFileDifferentA()");

    HANDLE hFile = INVALID_HANDLE_VALUE;

    // if we have an error opening the file, just return TRUE to download a 
    //  new copy
    hFile = CreateFileA(szLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        LOG_Internet(_T("IsServerFileDifferent: %s does not exist."), szLocalFile);
        return TRUE;
    }
    else
    {
        BOOL fRet;
        fRet = IsServerFileDifferentWorker(ftServerTime, dwServerFileSize, hFile);
        CloseHandle(hFile);
        return fRet;
    }
}

// **************************************************************************
// helper function to handle quit events
//
// return TRUE if okay to continue
// return FALSE if we should quit now!
BOOL HandleEvents(HANDLE *phEvents, UINT nEventCount)
{
    LOG_Block("HandleEvents()");

    DWORD dwWait;

    // is there any events to handle?
    if (phEvents == NULL || nEventCount == 0)
        return TRUE;

    // we only want to check the signaled status, so don't bother waiting
    dwWait = WaitForMultipleObjects(nEventCount, phEvents, FALSE, 0);

    if (dwWait == WAIT_TIMEOUT)
    {
        return TRUE;
    }
    else
    {
        LOG_Internet(_T("HandleEvents: A quit event was signaled.  Aborting..."));
        return FALSE;
    }
}


///////////////////////////////////////////////////////////////////////////////
// 

// **************************************************************************
HRESULT PerformDownloadToFile(pfn_ReadDataFromSite pfnRead,
                              HINTERNET hRequest, 
                              HANDLE hFile, DWORD cbFile,
                              DWORD cbBuffer,
                              HANDLE *rghEvents, DWORD cEvents,
                              PFNDownloadCallback fpnCallback, LPVOID pCallbackData,
                              DWORD *pcbDownloaded)
{
    LOG_Block("PerformDownloadToFile()");

    HRESULT hr = S_OK;
    PBYTE   pbBuffer = NULL;
    DWORD   cbDownloaded = 0, cbRead, cbWritten;
    LONG    lCallbackRequest = 0;

    pbBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbBuffer);
    if (pbBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        LOG_ErrorMsg(hr);
        goto done;
    }

    // Download the File
    for(;;)
    {
        if ((*pfnRead)(hRequest, pbBuffer, cbBuffer, &cbRead) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto done;
            }
        }
            
        if (cbRead == 0)
        {
            BYTE bTemp[32];
            
            // Make one final call to WinHttpReadData to commit the file to
            //  Cache.  (the download is not complete otherwise)
            (*pfnRead)(hRequest, bTemp, ARRAYSIZE(bTemp), &cbRead);
            break;
        }
        
        cbDownloaded += cbRead;

        if (fpnCallback != NULL)
        {
            fpnCallback(pCallbackData, DOWNLOAD_STATUS_OK, cbFile, cbRead, NULL, 
                        &lCallbackRequest);
            if (lCallbackRequest == 4)
            {
                // QuitEvent was Signaled.. abort requested. We will do 
                //  another callback and pass the Abort State back
                fpnCallback(pCallbackData, DOWNLOAD_STATUS_ABORTED, cbFile, cbRead, NULL, NULL);
                
                hr = E_ABORT; // set return result to abort.
                goto done;
            }
        }

        if (WriteFile(hFile, pbBuffer, cbRead, &cbWritten, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }

        if (HandleEvents(rghEvents, cEvents) == FALSE)
        {
            // we need to quit the download clean up, send abort event and clean up what we've downloaded
            if (fpnCallback != NULL)
                fpnCallback(pCallbackData, DOWNLOAD_STATUS_ABORTED, cbFile, cbRead, NULL, NULL);

            hr = E_ABORT; // set return result to abort.
            goto done;
        }
    }

    if (pcbDownloaded != NULL)
        *pcbDownloaded = cbDownloaded;

done:
    SafeHeapFree(pbBuffer);

    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//

struct MY_OSVERSIONINFOEX
{
    OSVERSIONINFOEX osvi;
    LCID            lcidCompare;
};
static MY_OSVERSIONINFOEX g_myosvi;
static BOOL               g_fInit = FALSE;

// **************************************************************************
// Loads the current OS version info if needed, and returns a pointer to
//  a cached copy of it.
const OSVERSIONINFOEX* GetOSVersionInfo(void)
{
    if (g_fInit == FALSE)
    {
        OSVERSIONINFOEX* pOSVI = &g_myosvi.osvi;
        
        g_myosvi.osvi.dwOSVersionInfoSize = sizeof(g_myosvi.osvi);
        GetVersionEx((OSVERSIONINFO*)&g_myosvi.osvi);

        // WinXP-specific stuff
        if ((pOSVI->dwMajorVersion > 5) || 
            (pOSVI->dwMajorVersion == 5 && pOSVI->dwMinorVersion >= 1))
            g_myosvi.lcidCompare = LOCALE_INVARIANT;
        else
            g_myosvi.lcidCompare = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

        g_fInit = TRUE;
    }
    
    return &g_myosvi.osvi;
}

// **************************************************************************
// String lengths can be -1 if the strings are null-terminated.
int LangNeutralStrCmpNIA(LPCSTR psz1, int cch1, LPCSTR psz2, int cch2)
{
    if (g_fInit == FALSE)
        GetOSVersionInfo();

    int nCompare = CompareStringA(g_myosvi.lcidCompare,
                                  NORM_IGNORECASE,
                                  psz1, cch1,
                                  psz2, cch2);

    return (nCompare - 2); // convert from (1, 2, 3) to (-1, 0, 1)
}

// **************************************************************************
// Finds the first instance of pszSearchFor in pszSearchIn, case-insensitive.
//  Returns an index into pszSearchIn if found, or -1 if not.
//  You can pass -1 for either or both of the lengths.
int LangNeutralStrStrNIA(LPCSTR pszSearchIn, int cchSearchIn, 
                         LPCSTR pszSearchFor, int cchSearchFor)
{
    char chLower, chUpper;
    
    if (cchSearchIn == -1)
        cchSearchIn = lstrlenA(pszSearchIn);
    if (cchSearchFor == -1)
        cchSearchFor = lstrlenA(pszSearchFor);

    // Note: since this is lang-neutral, we can assume no DBCS search chars
    chLower = (char)CharLowerA(MAKEINTRESOURCEA(*pszSearchFor));
    chUpper = (char)CharUpperA(MAKEINTRESOURCEA(*pszSearchFor));

    // Note: since search-for is lang-neutral, we can ignore any DBCS chars 
    //        in search-in
    for (int ichIn = 0; ichIn <= cchSearchIn - cchSearchFor; ichIn++)
    {
        if (pszSearchIn[ichIn] == chLower || pszSearchIn[ichIn] == chUpper)
        {
            if (LangNeutralStrCmpNIA(pszSearchIn + ichIn + 1, cchSearchFor - 1, 
                                     pszSearchFor + 1, cchSearchFor - 1) == 0)
            {
                return ichIn;
            }
        }
    }

    return -1;
}

// **************************************************************************
// Opens the given file and looks for "<html" (case-insensitive) within the
//  first 200 characters. If there are any binary chars before "<html", the
//  file is assumed to *not* be HTML.
// Returns S_OK if so, S_FALSE if not, or an error if file couldn't be opened.
HRESULT IsFileHtml(LPCTSTR pszFileName)
{
    LOG_Block("IsFileHtml()");

    HRESULT hr = S_FALSE;
    LPCSTR  pszFile;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hMapping = NULL;
    LPVOID  pvMem = NULL;
    DWORD   cbFile;

    hFile = CreateFile(pszFileName, GENERIC_READ, 
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0)
        goto done;

    // Only examine the 1st 200 bytes
    if (cbFile > 200)
        cbFile = 200;

    hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbFile, NULL);
    if (hMapping == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    pvMem = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, cbFile);
    if (pvMem == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    pszFile = (LPCSTR)pvMem;
    int ichHtml = LangNeutralStrStrNIA(pszFile, cbFile, "<html", 5);
    if (ichHtml != -1)
    {
        // Looks like html...
        hr = S_OK;

        // Just make sure there aren't any binary chars before the <HTML> tag
        for (int ich = 0; ich < ichHtml; ich++)
        {
            char ch = pszFile[ich];
            if (ch < 32 && ch != '\t' && ch != '\r' && ch != '\n')
            {
                // Found a binary character (before <HTML>)
                hr = S_FALSE;
                break;
            }
        }
    }

done:
    if (pvMem != NULL)
        UnmapViewOfFile(pvMem);
    if (hMapping != NULL)
        CloseHandle(hMapping);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\install\drvinst.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   drvinst.cpp
//
//  Description:
//
//      Functions called to install drivers and printer drivers
//
//=======================================================================

#include <windows.h>
#include <wuiutest.h>
#include <tchar.h>
#include <winspool.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <fileutil.h>

#include <install.h>
#include <logging.h>
#include <memutil.h>
#include <stringutil.h>
#include <iucommon.h>
#include <wusafefn.h>
#include <mistsafe.h>

#if defined(_X86_) || defined(i386)
const TCHAR SZ_PROCESSOR[] = _T("Intel");
#else // defined(_IA64_) || defined(IA64)
const TCHAR SZ_PROCESSOR[] = _T("IA64");
#endif

const TCHAR SZ_PRINTER[] = _T("Printer");


///////////////////////////////////////////////////////////////////////////
//
// InstallPrinterDriver 
//
///////////////////////////////////////////////////////////////////////////
HRESULT InstallPrinterDriver(
	IN LPCTSTR szDriverName,
	IN LPCTSTR pszLocalDir,		//Local directory where installation files are.
	IN LPCTSTR szArchitecture,
	OUT	DWORD* pdwStatus
	)
{
	LOG_Block("InstallPrinterDriver");

	USES_IU_CONVERSION;

	HRESULT hr = S_OK;
	DWORD dwError = ERROR_INVALID_FUNCTION;
	TCHAR szFileName[MAX_PATH + 1];
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	OSVERSIONINFO	osvi;
	WIN32_FIND_DATA ffd;
	HMODULE hLibModule = NULL;
	LPWSTR pszwCmd = NULL;
	HINF hInfFile = INVALID_HANDLE_VALUE;

	if (NULL == szDriverName || NULL == pszLocalDir || NULL == pdwStatus)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}

	LOG_Driver(_T("Called with szDriverName = %s, pszLocalDir = %s, szArchitecture = %s"),
		szDriverName, pszLocalDir, (NULL == szArchitecture) ? _T("NULL") : szArchitecture);
	//
	// DecompressFolderCabs may return S_FALSE if it didn't find a cab to decompress...
	//
	hr = DecompressFolderCabs(pszLocalDir);
	if (S_OK != hr)
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}
	
	//
	// Find the first *.inf file in pszLocalDir
	//
	CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szFileName, ARRAYSIZE(szFileName), pszLocalDir, \
														NULL, NULL, MISTSAFE_STRING_FLAGS));
	CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFileName, ARRAYSIZE(szFileName), _T("*.inf")));

	if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(szFileName, &ffd)))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	//
	// 574593  During site printer install, we pass path to first INF - this may not be correct for MFD's or multi-platform CABs
	//
	// Find the first printer INF by calling SetupOpenInfFile() with class "Printer"
	//
	for (;;)
	{
		//
		// Construct .inf path using FindXxxFile name
		//
		CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szFileName, ARRAYSIZE(szFileName), pszLocalDir, \
															NULL, NULL, MISTSAFE_STRING_FLAGS));
		CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFileName, ARRAYSIZE(szFileName), ffd.cFileName));

		if (INVALID_HANDLE_VALUE == (hInfFile = SetupOpenInfFile(szFileName, SZ_PRINTER, INF_STYLE_WIN4, NULL)))
		{
			if (ERROR_CLASS_MISMATCH != GetLastError())
			{
				Win32MsgSetHrGotoCleanup(GetLastError());
			}
			//
			// If this isn't a Printer INF (ERROR_CLASS_MISMATCH) try the next file
			//
			if (0 == FindNextFile(hFindFile, &ffd))
			{
				//
				// We ran out of *.inf files or hit other FindNextFile error before finding class match
				//
				Win32MsgSetHrGotoCleanup(GetLastError());
			}
			continue;
		}
		else
		{
			//
			// We found the printer INF in the cab. NOTE: WHQL assumption that only one "Printer" class
			// INF will exist in any particular cab.
			//
			SetupCloseInfFile(hInfFile);
			hInfFile = INVALID_HANDLE_VALUE;
			//
			// Go use szFileName
			//
			break;
		}
	}
	//
	// We've broken out of for (;;) loop without jumping to CleanUp, so we have a
	// "Printer" class INF path in szFileName
	//
	
	// Only works on NT 5 up and Millennium
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId && 4 == osvi.dwMajorVersion && 90 == osvi.dwMinorVersion)
	{
#if !(defined(_UNICODE) || defined(UNICODE))
		//
		// Millennium (ANSI only)
		//
		typedef DWORD (WINAPI *PFN_InstallPrinterDriver)(LPCSTR lpszDriverName, LPCSTR lpszINF);

		if (NULL == (hLibModule = LoadLibraryFromSystemDir(_T("msprint2.dll"))))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		PFN_InstallPrinterDriver pfnIPD;
		
		if (NULL == (pfnIPD= (PFN_InstallPrinterDriver) GetProcAddress(hLibModule, "InstallPrinterDriver")))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		if (NO_ERROR != (dwError = pfnIPD(szDriverName, szFileName)))
		{
			LOG_Driver("pfnIPD(%s, %s) returns %d", szDriverName, szFileName, dwError);
			Win32MsgSetHrGotoCleanup(dwError);
		}
#endif
	}
	else if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && 5 <= osvi.dwMajorVersion)
	{
		//
		// Windows 2000 and Whistler:  PrintUIEntryW is the only supported method of installing printer drivers.
		// Don't try and use PnPInterface() defined in printui.dll (and don't ask *me* why PrintUIEntryW isn't
		// typedef'ed there...)
		//
		// Type "rundll32.exe printui.dll,PrintUIEntry /?" from a cmd prompt for help on the command parameters.
		//
		// Private typedef since this isn't exposed in any internal or external SDK headers
		//
		typedef DWORD (*PFN_PrintUIEntryW)(
			IN HWND        hwnd,
			IN HINSTANCE   hInstance,
			IN LPCWSTR     pszCmdLine,
			IN UINT        nCmdShow
			);
		///////////////////////////////////

		if (NULL == szArchitecture)
		{
			szArchitecture = (LPCTSTR) &SZ_PROCESSOR;
		}

		//
		// 491157 Trying to update an English  language printer driver installed on a German build through the German WU website fails.
		//
		// Don't pass optional /u, /h, and /v parameters (localized). They aren't required since we always provide
		// drivers for the client architecture and OS.
		//
		// 574593  Per attached discussion we need to pass an undocumented upper-case 'U' flag.
		//
		const WCHAR szwCmdLineFormat[] = L"/ia /m \"%s\" /f \"%s\" /q /U";
		const size_t nCmdLineFormatLength = wcslen(szwCmdLineFormat);
#define MAX_PLATFORMVERSION 20 // NOTE:: Max Version Length Needs to be Updated if the OS Strings in the Below Command Line Change

		// NOTE: this doesn't bother to remove the length of the %s characters from nCmdLineFormatLength

		DWORD dwLength=(nCmdLineFormatLength + lstrlen(szDriverName) + lstrlen(szArchitecture) + MAX_PLATFORMVERSION + lstrlen(szFileName) + 1);
		pszwCmd = (LPWSTR) HeapAlloc(
					GetProcessHeap(),
					0,
					dwLength * sizeof(WCHAR));
		CleanUpFailedAllocSetHrMsg(pszwCmd);

		// OK to cast away const-ness on string params so T2OLE works, since it doesn't modify them anyway
					
		hr=StringCchPrintfExW(pszwCmd,dwLength,NULL,NULL,MISTSAFE_STRING_FLAGS,(LPCWSTR) szwCmdLineFormat,
			T2OLE(const_cast<TCHAR*>(szDriverName)),
			T2OLE(const_cast<TCHAR*>(szFileName)) );
		
		CleanUpIfFailedAndSetHr(hr);

		// Load printui.dll
		if (NULL == (hLibModule = LoadLibraryFromSystemDir(_T("printui.dll"))))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		PFN_PrintUIEntryW pfnPrintUIEntryW;
		if (NULL == (pfnPrintUIEntryW = (PFN_PrintUIEntryW) GetProcAddress(hLibModule, "PrintUIEntryW")))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		if (NO_ERROR != (dwError = pfnPrintUIEntryW(GetActiveWindow(), 0, pszwCmd, SW_HIDE)))
		{
			LOG_Driver(_T("pfnPrintUIEntryW(%s) returns %d"), OLE2T(pszwCmd), dwError);
			Win32MsgSetHrGotoCleanup(dwError);
		}
	}
	else
	{
		SetHrMsgAndGotoCleanUp(E_NOTIMPL);
	}

	*pdwStatus = ITEM_STATUS_SUCCESS;

CleanUp:

	SafeHeapFree(pszwCmd);
		
	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}

	if (INVALID_HANDLE_VALUE != hInfFile)
	{
		SetupCloseInfFile(hInfFile);
	}

	if (NULL != hLibModule)
	{
		FreeLibrary(hLibModule);
	}

	if (FAILED(hr))
	{
        if (NULL != pdwStatus)
        {
    		*pdwStatus = ITEM_STATUS_FAILED;
        }
	}

	return hr; 
}

///////////////////////////////////////////////////////////////////////////
//
// InstallDriver and helper functions
//
///////////////////////////////////////////////////////////////////////////


DWORD OpenReinstallKey(HKEY* phKeyReinstall)
{
	return RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall"),
		0, KEY_ALL_ACCESS, phKeyReinstall);
}


//-----------------------------------------------------------------------------------
// LaunchProcess
//   Launches pszCmd and optionally waits till the process terminates
//-----------------------------------------------------------------------------------
static HRESULT LaunchProcess(LPTSTR pszCmd, LPCTSTR pszDir, UINT uShow, BOOL bWait)
{
	LOG_Block("LaunchProcess");

	HRESULT hr = S_OK;

	STARTUPINFO startInfo;
	PROCESS_INFORMATION processInfo;
	
	ZeroMemory(&startInfo, sizeof(startInfo));
	startInfo.cb = sizeof(startInfo);
	startInfo.dwFlags |= STARTF_USESHOWWINDOW;
	startInfo.wShowWindow = (USHORT)uShow;
	
	BOOL bRet = CreateProcess(NULL, pszCmd, NULL, NULL, FALSE,
		NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
	if (!bRet)
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	CloseHandle(processInfo.hThread);

	if (bWait)
	{
		BOOL bDone = FALSE;
		
		while (!bDone)
		{
			DWORD dwObject = MsgWaitForMultipleObjects(1, &processInfo.hProcess, FALSE,INFINITE, QS_ALLINPUT);
			if (dwObject == WAIT_OBJECT_0 || dwObject == WAIT_FAILED)
			{
				bDone = TRUE;
			}
			else
			{
				MSG msg;
				while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE))
				{
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}
		}  // while

	} // bWait

	CloseHandle(processInfo.hProcess);

CleanUp:

  return hr;
}

//	"@rundll sysdm.cpl,UpdateDriver_Start"
//	"@rundll sysdm.cpl,UpdateDriver_RunDLL .\,,1,Win98 signed test pkg for System Devices"
//	"@rundll sysdm.cpl,UpdateDriver_Finish 0"
//	"@rundll sysdm.cpl,UpdateDriver_RunDLL .\,,1,Win98 signed test pkg for System Devices"
//Note: Windows 98 uses rundll.exe to call device manager. This is because sysdm.cpl which
//is device manager for 98 is a 16 bit dll. Since we would need to create something that
//worked similar to rundll in order call device manager we have brought the existing code
//across with some minor clean ups. win98 device manager provides three apis for our use
//in installing device drivers. These are:
//	UpdateDriver_Start()	- Start the device installation
//	UpdateDriver_RunDLL(inf Directory,hardware id, force flag, display string)
//	UpdateDriver_Finish 0 - finish the installation.
//The UpdateDriver_RunDLL() command 
//Comma separated string in following format:
//INFPath,HardwareID,flags,DisplayName
//INFPath = Path to INF and installation files
//HardwareID = PnpHardware ID
//flags	= '1' = force driver, '0' = do not force driver.
//Note: A Reinstall driver is detected based on the location of the INF path. If INF path
//is the same path as the reinstallbackups registry key then reinstall is selected.
//DisplayName = Name to display in install dialogs.

//This method installs a CDM driver for Windows 98.
static HRESULT Install98(
	LPCTSTR pszHardwareID,			
	LPCTSTR pszLocalDir,			// location of INF and other driver install files
	LPCTSTR pszDisplayName,	
	PDWORD pdwReboot			
)
{
	LOG_Block("Install98");

	HRESULT hr = E_NOTIMPL;

	DWORD dwStatus = 0;
	LPTSTR pszCmd = NULL;
	DWORD dwLen;
	LONG lRet;
	DWORD dwSize;


	if (NULL == pdwReboot)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#if defined(DBG)
	// checked by caller
	if (NULL == pszHardwareID || NULL == pszLocalDir || NULL == pszDisplayName)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#endif

#if !(defined(_UNICODE) || defined(UNICODE))
	//
	// Win98 and WinME (ANSI only)
	//

	// Start
	CleanUpIfFailedAndSetHr(LaunchProcess(_T("rundll32 sysdm.cpl,UpdateDriver_Start"), NULL, SW_NORMAL, TRUE));

	TCHAR szShortInfPathName[MAX_PATH] = {0};
	dwLen = GetShortPathName(pszLocalDir, szShortInfPathName, ARRAYSIZE(szShortInfPathName));

	//Note: The maximum a hardware or compatible ID can be is 200 characters
	//      (MAX_DEVICE_ID_LEN defined in sdk\inc\cfgmgr32.h)

	DWORD dwBuffLength=( lstrlen(szShortInfPathName) + lstrlen(pszHardwareID) + lstrlen(pszDisplayName) + 64);
	CleanUpFailedAllocSetHrMsg(pszCmd = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
		dwLen * sizeof(TCHAR)));


	hr=StringCchPrintfEx(pszCmd,dwBuffLength,NULL,NULL,MISTSAFE_STRING_FLAGS,
	_T("rundll32 sysdm.cpl,UpdateDriver_RunDLL %s,%s,%d,%s"), 
	szShortInfPathName, pszHardwareID,0,pszDisplayName);

	CleanUpIfFailedAndSetHr(hr);

	// RunDLL
	LOG_Driver(_T("LaunchProcess(%s)"), pszCmd);
	CleanUpIfFailedAndSetHr(LaunchProcess(pszCmd, NULL, SW_NORMAL, TRUE));

	// Get resulting code
	HKEY hKeyReinstall;
	if (ERROR_SUCCESS == (lRet = OpenReinstallKey(&hKeyReinstall)))
	{
		dwSize = sizeof(dwStatus);
		if (ERROR_SUCCESS == (lRet = RegQueryValueEx(hKeyReinstall, _T("LastInstallStatus"), NULL, NULL, (LPBYTE)&dwStatus, &dwSize)))
		{
			if (3 == dwStatus)
			{
				//Check if we need to reboot
				HKEY hKeySysDM;
				*pdwReboot = 0;
				dwSize = sizeof(*pdwReboot);
				if (ERROR_SUCCESS == (lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SysDM"), 0, KEY_READ, &hKeySysDM)))
				{
					if (ERROR_SUCCESS != (lRet = RegQueryValueEx(hKeySysDM, "UpgradeDeviceFlags", NULL, NULL, (LPBYTE)&pdwReboot, &dwSize)))
					{
						LOG_ErrorMsg(lRet);
						hr = HRESULT_FROM_WIN32(lRet);
					}

					RegCloseKey(hKeySysDM);
				}
				else
				{
					LOG_ErrorMsg(lRet);
					hr = HRESULT_FROM_WIN32(lRet);
				}
			}
		}
		else
		{
			LOG_ErrorMsg(lRet);
			hr = HRESULT_FROM_WIN32(lRet);
		}

		LOG_Driver(_T("Reboot %srequired"), *pdwReboot ? _T(" ") : _T("not "));

		RegCloseKey(hKeyReinstall);
	}
	else
	{
		LOG_ErrorMsg(lRet);
		hr = HRESULT_FROM_WIN32(lRet);
	}

	// Finish no reboot
	CleanUpIfFailedAndSetHr(LaunchProcess(_T("rundll32 sysdm.cpl,UpdateDriver_Finish 2"), NULL, SW_NORMAL, TRUE));

	if (3 != dwStatus) 
	{
		LOG_Error("3 != dwStatus");
		hr = E_FAIL;
	}
	else
	{
		hr = S_OK;
	}


#endif // #if !(defined(_UNICODE) || defined(UNICODE))
CleanUp:

	SafeHeapFree(pszCmd);

	return hr;
}

//This function installs a driver on Windows NT.
// Its prototype is:
// BOOL
// InstallWindowsUpdateDriver(
//   HWND hwndParent,
//   LPCWSTR HardwareId,
//   LPCWSTR InfPathName,
//   LPCWSTR DisplayName,
//   BOOL Force,
//   BOOL Backup,
//   PDWORD pReboot
//   )
// This API takes a HardwareID.  Newdev will cycle through all devices that match this hardware ID
// and install the specified driver on them all.
// It also takes a BOOL value Backup which specifies whether or not to backup the current drivers.
// This should always be TRUE.
static HRESULT InstallNT(
	LPCTSTR pszHardwareID,	
	LPCTSTR pszLocalDir,			// passed to InstallWindowsUpdateDriver(... InfPathName, ...)
	LPCTSTR pszDisplayName,
	PDWORD pdwReboot		
	)
{
	USES_IU_CONVERSION;

	LOG_Block("InstallNT");

	//
	// InstallWindowsUpdateDriver function found in $(BASEDIR)\shell\osshell\cpls\newdev\init.c (not in any headers)
	//
	typedef BOOL (*PFN_InstallWindowsUpdateDriver)(HWND hwndParent, LPCWSTR HardwareId, LPCWSTR InfPathName, LPCWSTR DisplayName, BOOL Force, BOOL Backup, PDWORD pReboot);
	
	HRESULT hr = S_OK;
	HMODULE hLibModule = NULL;
	PFN_InstallWindowsUpdateDriver pfnInstallWindowsUpdateDriver;

	if (NULL == pdwReboot)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#if defined(